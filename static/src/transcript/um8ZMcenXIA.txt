And welcome to our presentation about the character pipeline and customization system of Far Cry Primal.
I'm Kieran O'Sullivan.
I'm the character technical director for Far Cry Primal.
And I'm Julien Lavey.
I was the character tech programmer on Far Cry Primal.
Can everyone hear us all good up the back?
Yeah, great.
OK.
So Far Cry Primal, hopefully most of you have played it.
But if you haven't, it's a Far Cry game set in 10,000 BC, so prehistoric cave people times.
You don't need to know much more than that.
You can probably fill in the blanks in your head.
Some things you might need to know for this presentation, a few buzzwords.
So DCC, we use it all the time.
You've probably heard it tons at the convention already.
You probably know what it means.
It stands for Digital Content Creation Software.
And that's things like 3D Studio Max, Maya, Blender, Houdini, Motion Builder, whatever, anything that the artist or animator works in outside of the game engine.
We also have Dunia.
Dunia is the name of the game engine that we use on Far Cry.
Wolfskin.
So we're going to be talking about Wolfskin a lot today.
It's the name of our new system to assemble and customize characters.
And DNA, which is a piece of data inside that that represents a whole character.
So when we started on Far Cry Primal, we were starting with the pipeline that we used for Far Cry 3 and Far Cry 4.
So.
That was a MaxScript-based pipeline.
This is, unfortunately, a typical Max viewport from Far Cry 3.
So you can see our character has maybe a couple of meshes for his upper body.
He has some pants.
He has some arms and things.
He doesn't have legs, and he doesn't have shoes.
So they're probably coming from a totally different Max file.
As well, he doesn't have shaders.
You can see there's no textures on this guy.
And that was unfortunately very common for our artists in Max on the previous Far Cry games.
So what did it look like in a more abstract sense?
We'd have these big Max files, like really, like it would be full of like a lot of meshes.
This is a conservative example where we're just exporting four meshes out of a Max file.
After that, we'd go into a game engine, and we would assemble a character from different mesh parts.
So here we're pulling two of the meshes out of this Max file, and we're using them for the hair and the body of this character.
Some other parts of him are probably coming from a totally different place.
If you remember, that character didn't have legs or shoes.
So he may be pulling other parts of himself from a different Max scene.
That's not really great, because now you can see if I actually wanted to work on this character, I don't have all the meshes that I need to actually edit him.
Because I'm going to check out that Max file, and I'm going to work on stuff in there, I'm basically blocking it from anyone else working on any mesh that comes out of that file.
So you can see in red, there's a few meshes I don't even need, but they're locked and no one can work on them.
I don't really care, though, because who cares?
Well, if someone else checks out a Max file, I care, because now I can't work on any meshes that came out of that scene.
It gets a bit worse again, because we also had skeletons.
And we had a big master skeleton on the previous Far Cry games.
And we would use that for all the characters.
And we would need that skeleton to be up to date in all of the files that had meshes in them.
So that meant it was really difficult for us to actually update the skeleton on the project because we'd have to go to that source file and we'd change the skeleton.
But we'd also have to change that skeleton in every max file.
So it became very complicated and time consuming.
And it basically means you can't do it.
It's just never going to happen.
So before we figure out what pipeline we'd like to have, we want to look at who's the team, because that's the most important thing.
So the primary users of the pipeline, the guys that work the most with exporting things to the engine, are actually our lead character artists, the TDs, and the riggers.
Our modelers also use it a fair bit, but in this case, these are the guys that are iterating a lot back and forwards, whereas the modelers are more creating the asset, and then it's going through a longer pipeline.
So what do they want to use?
Well, our lead character artist likes to use Maya.
He's always been using Maya, and in the past, he would have to then send that to Max with an FBX file.
I like to use Maya as well on the character TD, but I do use Max.
We had a rigger who liked Maya, and we had three riggers that liked Max.
So we knew, based on our team, we had to support both software packages.
If we let them use the software they want to use, they're going to be faster, they're going to be more efficient, they're going to have more time for polish.
And we can use the best tool for the job.
So what would that look like if we had this idle pipeline?
Well, every mesh would be its own separate piece.
We don't want these big max files anymore.
We just want to have all these separate meshes.
And we want to assemble characters from them.
As well, if I want to edit them, I just want to pull whichever mesh I need and open it into the 3DS Max or into Maya.
And I want to be able to pull any of the meshes I needed.
As well, you can see down the bottom, there's the skeleton.
So that skeleton that was hard to update, Now we've made it its own asset and it can just be pulled in first and then all the other meshes can come in and skin to it.
So that's really cool.
When I export, I'm only going to check out the file that I changed.
So that way, even if I have all the pants on the project checked out and I'm only changing one of them, it's the only file that's locked.
Everyone else can keep working.
So ideally, this means that our artist could work in parallel, maybe even on the same character while the modeler's working on the hair.
A rigger might be working on the pants.
So how do we get there?
So to understand how we went from what we had and what we got in the end, first, let's look at the technical aspects of where we were on FC3 and FC4.
So we had a very 3ds Max-centric pipeline.
It was all in 3ds Max 2012, a lot of MaxScript, some 3ds Max plugins in C++, some 3ds Max-specific shaders.
with a lot of Mac script, once again, to bind the shaders.
We also had the dependency on the other plugins and all these things.
And as you saw, we have one Mac scene goes into the pipeline, and then a bunch of meshes come out.
Now, if we go back a few years ago, here at GDC, our colleagues, Thomas Felix and Pierre Blaiseau, presented a session entitled, Passenger, Story of a Convergent Pipeline.
How this is related is that the point of that framework was to create.
a communication framework between the game engines and the DCCs to sort of extract assets from the game engine into any DCC that we wanted for marketing purpose.
So you would be able to go into Assassin's Creed and then select the characters and the world and import all of that in 3ds Max.
And then there you would be able to make pre-rendered trailers.
Because of that, they supported a lot of DCCs, such as 3ds Max, Maya, and Mobiu.
And to make it happen, they created a standard file format for the assets, which they called GameX, which would then provide functionality to load this thing into many DCCs.
So at this point, we had, from the passenger framework, the possibility to load standard assets in all the DCCs.
And the question was, what if the game engine was also reading this format?
So we would be in a situation where we would be able to make back and forth.
between NDDCC and the source format, and we could get rid completely of the Maxines and the source files.
So this is what we implemented.
This is what the pipeline looks like now.
So there's only the GammaX mesh for each asset, so each asset is gonna be its own file.
There is no Maxine grouping anything anymore.
Passenger from technology group at Ubisoft provided us with plugins to load our standard asset formats They support many DCC's and many versions of them So we were already able to load the files in for instance max and Maya But then on top of that you want to create a pipeline that's going to be able to like be customized for your game engines needs so very often you want to add some metadata you want to link the materials in a way that your game engine is going to understand and So we did not think it was feasible for us to create one pipeline in Maya, one pipeline in Max.
So we wanted to share the pipeline.
So we're going to show now all the things that we did to share the pipeline between Max and Maya.
The first thing was we needed to share code.
So we looked at the options in the Autodesk packages.
And Python is well-supported now between Max and Maya.
So this is what the pipeline looks like.
You can see there's a few things there.
First is there's some stuff like an import-export module there with the exporter and an importer.
These things are kind of DCC agnostic.
But you can see there's also some stuff, like there's a DCC helpers module.
And in there you can see there's a DCC helpers file, but there's also DCC helpers max and DCC helpers maya.
So let's look at how that works.
Most of the code is in the DCC agnostic high level code.
So the exporter doesn't know in which DCC it's running.
For instance, there you see the export geometry function.
How do we export a geometry?
So first thing we do is we get the selection from the user.
What did they select in the editor?
And then we are going to apply some manipulation to these assets and export the assets to the disk.
You can see the first line there is like DCC helpers dot get selected nodes.
Obviously, the APIs in 3ds Max and Maya to do this thing are going to be different.
So this is where we branch the code.
So we're going to the lower level of the pipeline.
We become very much unit atomic operations.
The DCCL first part is going to try to figure out first, OK, which DCC is this.
If it's Maya, we're going to import the Maya version of the code.
And then if it's Max, we're going to import the Max version of the code.
So there.
You go, and finally, we're in the low-level code, and we get the selection.
In 3ds Max, we call the MaxPlus API in Python.
And in Maya, we call the Maya commands.
We return.
We wrap the nodes into a DC seragnostic wrapper, and then we pass that to the DC seragnostic pipeline so that the big pipeline doesn't know where we are.
So the good thing with that.
is that as you go through production, you're going to build this little library that hides the API of 3ds Max and Maya.
And you're going to have little operations in there, such as getting the selection, renaming nodes, deleting nodes, creating nodes.
And each time you know you create new features, at the beginning you're going to have a bunch of those operations.
But as you go, there's going to be less and less that you need to add to this library.
And you're going to be able to focus on building the logic of the pipeline instead of building the library.
So that is how we shared code.
Now the next thing that we needed to do was sharing a UI between the DCCs.
So for this, we looked once again, what's supported in Max and Maya this time, and we found that PySide, which is the Python bindings for Qt 4, is available in a bunch of those DCCs.
When we were starting production, we were at the 2015 version of Max and Maya, so PySide seemed like a good fit.
So this is just an example of some of the tools we have.
In the middle, you can see our node editor.
So this is where the artists will go in and set things like maybe LOD distances.
They can set up their simplygon settings for LODs for automatic generation, and it's stored with the mesh.
There's a few properties and other things that they can do in there.
But what's really important there is because it's a QT UI and because this UI is exactly the same in both Max and Maya, it's very easy for our artists to switch back and forth.
It also is really easy for us to build documentation.
Because we're not documenting a Max pipeline and a Maya pipeline, we're just documenting the pipeline.
At the top is a toolbar.
So same toolbar in Max and Maya.
In Maya, it's a shelf.
In Max, it's a toolbar that you can move around.
And the icons are the same in both packages, and they have the exact same behavior.
So again, if an artist is switching back and forwards, or if they want to migrate from one to the other, it's really easy for them to learn the software that they're going to be using, because the pipeline will be the same.
And lastly, there's just a dropdown menu, which is a standard kind of thing you see from the top of the application.
And for us, we actually made it the exact same order as the icons in the toolbar.
So it's really simple and straightforward.
So shaders, if you remember back at the start, I showed you the screenshot of Max and there's just no textures, no shaders.
So we knew that had to change.
But we had to support two DCCs.
So when we had a look, the best option for us was ShaderFX.
It was integrated in both the 2015 version of Max and Maya.
So that seemed like a pretty good choice for us.
If you don't know what ShaderFX is, it's a node-based shader creation system.
It comes built in so you can just open it up from Max or Maya and start creating shaders using nodes.
It was really great for us because it meant that the TDs or the artist even could go in there and understand this thing and start building the shader.
And for us, it's all about matching basically what the engine shaders are doing and making it easy for the artist to work on their UVs, their vertex color, that type of thing.
Also meant that the 3D programmers could focus on just getting the features into the engine shaders, and they didn't need to worry about the DCC.
The TDs could just jump in there and quickly update the shaders whenever an engine shader changed.
As well, it also has automatic mapping.
So we just made it so if you name the texture node in the graph.
diffuse map or detail diffuse one, detail diffuse two, it automatically maps to the properties from your engine materials.
So it's really easy, and there's no extra code around this thing.
So what does it look like when an artist is using this pipeline?
There we go.
OK.
Whew.
So OK.
So here we're in our game engine, Dunia.
And we have our character.
We just selected the character in the game engine, and we're going into 3D Studio Max.
And we click our Import button.
So what that does is, using the Passenger framework, it's communicating to the game engine and asking what's selected, and then importing all the meshes for that character.
So I can just click on one of the meshes.
And I can just make a change so you can see something happen.
OK, so now we've made some changes to our mesh.
We just want to click our Export button, and it'll export the mesh back to the engine.
So we get this little pop-up.
It doesn't get in your face.
You don't have to click it away.
It's just a little notification.
And when we switch back to the engine, you can see it's already actually hot reloaded.
So usually before we even go back there, it's hot reloaded.
Now just to show that this pipeline's the same in Maya, we're just opening the character into Maya.
And you can see we've got that new change that we've made.
And we can just remove it again.
And then we're going to click Export.
And again, you'll see these little pop-ups down the bottom, these little notifications just telling us export successful.
So now if we switch back to the game engine, you can see she's already hot reloaded, and it's live updated.
So really fast and easy turnaround, and you can see the artist can use whatever they want to use.
So that means there's no more big scenes.
There's no more giant max files.
If an artist wants to use one package, they're not forcing everyone else to use that.
And the artist can just open the meshes, whichever meshes they want, into any package.
Once it's in the game engine, we actually need to assemble that character from different meshes.
This is the old system we used.
I don't want to get too deep.
into it, but you can see it's kind of pretty big, confusing UI.
I would wager you can't guess how to use this just by looking at it.
The other problem with it was it was a single user tool.
It was one giant database for the whole project.
So that meant that if someone wanted to work in there, it would check it out.
No one else could work.
It became a little bit annoying on FarQuay 3 and 4.
because we were doing Codev with our Shanghai studio, who were doing animals for us.
So they might check out this database and lock it.
And then if they go home at night and don't check it in, that means the next day in Montreal, none of us can work in there.
It's an even bigger problem for us, because on Primal, we were actually doing Codev with our Toronto team.
And Toronto and Montreal are in the same time zone.
So now you've got a database where only one person in two studios can ever work in there at the same time.
So it creates a giant bottleneck.
And it ends up being mostly the riggers had to be the ones that work in there, and they really hated it.
So instead, oh no, sorry.
This is just an abstract view of what this meant.
So you've got all these different meshes, and you load them into this little part database.
And then from the parts, you make a character.
It was very simple, nothing too complicated, but also kind of frustrating to use.
So that's where we turn to our new system, which we called WolfSkin.
So now we're going to describe how we built the character system and how we were based on our customization system.
So WolfSkin, in the first part, we showed that we repurposed our marketing framework to become a modeling pipeline.
WolfSkin also started before Factory Primal, and it was mostly a character customization system.
And the thing is, when we entered the production for Factory Primal, we thought maybe.
we could actually turn this character customization system into a character system for building characters.
So that's what we did.
Now I'm going to describe in detail how the system works and how you can build a customization system like this.
The one thing to understand about WolfSkin is that it's completely data-oriented, so it doesn't know what it's customizing.
So you can apply it to many things.
So a good way to describe a data-oriented pipeline is to look at the data and then find out what's in there.
So there's going to be two types of data that I'm going to talk about in WolfSkin.
There's the config files on one side, and there's the item files on the other side.
The config files, they're going to be shared by all the entity of the same group.
So for instance, all the humans are going to point to the human configuration file.
And then on the side, you're going to have a bunch of items that describe human parts and stuff like this.
So the config file has three parts, which I'm going to go into in details right after.
But first, we have the slot hierarchy there.
So the slot hierarchy is just basically going to define how you build a character.
So there we have a human slot at the top.
Then we have a morphology folder in which we have head and body.
And then you could have a bunch of clothes, body parts, stuff like this.
Then we have solver rules.
WorldSkin runs solvers on the data to find out what it should spawn.
when building the character.
For instance, there we have a rule that handles the conflict between head mesh, like the hair mesh, and the hat mesh that could occur.
Finally, we have automation hints.
When we were building WolfSkin, we found it's very important that it's super fast to add data.
And so for that, we created some automation hints that the artist can make to speed up the process.
So let's look at the slot hierarchy for a while.
There you have the human slot on the top.
It has a special meaning, the top slot, but I'll show it with the item.
Then you have stuff like the red slots there, like body, torso, and pants.
These are typically slots in which you're going to find meshes.
You could also have stuff in the nodes in the hierarchy, such as a suit, which is basically there, just grouping a torso and a pants item.
You can have other things in the slot hierarchy, such as enumerated values of our Boolean flags.
There we have a gender enumerated value.
which we described can just take male and female values.
Finally, we can have some stuff like material parameters.
So there we have a body paint slot, and we have some team logo slot.
These are going to feed material parameters to the meshes and interact with each other, and we'll see that in detail.
So that's the slot hierarchy in the config file.
Now what are the items?
So the items, it's just going to be any piece of data that targets a particular slot in the hierarchy.
So if you target the top slot of the hierarchy, you're basically describing a full human and you're going to reuse items that target the other slots.
So hopefully we can look at workflow video.
So Wolfskin is integrated in Maya, where the artists work and Max.
There we are just saying, okay, I'm going to create a new item.
I said this is for the human config file, and then we're targeting the top slot, so human.
Now we're just gonna give a name to our character, and this is going to create a file on disk.
Now you can see on the left side, I have all the Wolskim data, and on the right side I have an addition pane.
Because I've targeted the top slot there, I have like picker values for all the other slots.
So I'm just selecting a gender there, and then I'm gonna select items that target the other slots, such as maybe a body.
maybe a shirt and some pants.
And because we are running in the DCC right now, we have control over the modeling pipeline.
So we're going to be able to save a file and then click an eye icon to see the character.
And this is going to trigger loading of the skeleton, loading of the gamex meshes, and then put that all together in the Maya part.
And a little disclaimer here, the loading times are.
shortened, but this is still pretty fast.
So there you see I can just change the gender of my character, and it's the same character which is loading in the DCC.
So the characters look the same, but with adapted morphology.
We can continue editing the character, add some clothes.
So again, changing the gender is an atomic operation.
So you can just quickly gender swap the character and click the eye icon and save.
So a little loading.
There we go.
So maybe just swap again.
And then once we're happy, we're going to be able to just save our file and integrate into the game engine.
Let's go into Dunia.
So we go into the game engine, which is a component-based game engine.
So I'm just going to drop a character.
And on this character, I have a Wolfskin component, in which I'm just going to point to the file that we just created.
As you can see, we are loading the character.
Now, because, as you saw before, we have a pre-loading of all the resources in the game engine, So it's the same for both skin.
I can go back into Maya, open my application, do a change, save the file, and then it's going to hot reload the character in the engine.
Then we can continue customizing the character.
So before, it would take us a really long time to integrate the character.
And as you see right now, it takes a minute or two to create a character and integrate them in the game engine, so that was really good for us.
So that was how you create a DNA character, so a full character.
Now let's look a little bit at the other items and how you create them and make them usable for the system.
So you're going to have very simple item.
For instance, the shoes in Far Cry Primal, they're unisex.
So it's just one mesh.
So maybe a shoes item is just going to be pointing to one mesh.
Then you have more complex items, such as the torso items.
There you see an easy armor.
And there's a male and a female version of the same mesh.
And these are going to be tagged appropriately so that the solver can load them.
So I think we can see an example of that.
You want to talk about it?
So let's see how the artists work with this.
So in this tab, this is the Mesh tab, they have a quick view of every mesh that's on data for the project.
So it's really fast and easy.
They can just filter and type some keywords in there and find meshes.
So we just clicked, we're just loading some meshes so you can see specifically the meshes we're gonna be working with.
So it's the same meshes you just saw before.
So if the artist has just finished creating these meshes and now they wanna put them inside Wolfskin so that they could be used by a character, they're gonna go into the Mesh tab, select the two meshes that they have, and they'll just click the New Item button.
That's going to guess automatically that this is a human piece, and it's going to be targeting the torso part.
Now, it's also going to suggest a file name for this asset, and it's going to suggest a folder to save that file.
And every piece of Wolskin data is its own separate file, so we're not blocking anyone else from working if we're working on parts.
Lastly, this is the, again, you can see like Wolskin here.
And this is what it looks like when you're editing a specific item.
So there's the two meshes, and there's some tags.
And they've already been set up.
So let's see it a little bit faster.
So I select my two meshes, click OK.
It's giving me a file name folder.
And I just have to validate that the tags have been correctly tagged for male, female for the two versions of meshes, and that's about it.
So it's really, really fast.
And we're just going to do one more so you can get a real idea of how easy it was to integrate.
OK.
So how does that work?
So just when I was describing configuration file, I said there's a section about automation hints.
These are really simple.
There's just two types of automation hints.
The first is going to be a folder structure to start mapping.
So basically, we'll skin if we're creating an item with meshes in the human slash body folder, we're just going to guess that this is a human item for the body slot.
Likewise, we have naming convention to tags.
So the meshes themselves, when you create the easy layout more for the female character, you're going to name it maybe underscore F.
And in the configuration file, you're going to say, if you find underscore F, just tag it female automatically.
So this enforces good practice in the data structure.
You make sure that your data is nice and organized.
And it also makes creating the items really fast.
So before we move on to a few other things in the slot hierarchy, let's look at how the solver works.
So you saw that I was able to change the gender and then just read out the character.
We're going to run into detail the example of how the solver is running on the data.
So I mentioned there's the rules section in a configuration file, and these are basically pieces of data that I'm gonna say, this is how you select the best version of the meshes for each items that you are finding DNA.
So let's run through an example.
We have a very simple configuration file with just one rule in there, and it says require tag from a new slot gender.
So let's just build a DNA.
I'm just gonna add some items in there.
You can see I have a body, a leather top, and some pants.
And the body and the leather top each have two mesh versions, one tag male, one tag female.
And then the pants have only one version, which is tagged male and female, so it would be a unisex mesh that fits both characters.
I also need to select the gender, so I'm just gonna go in my DNA and select a female gender.
Now the solver is gonna run on the character and select the right versions.
So the first thing that the solver does is to initialize a score of zero on all the mesh's versions, and then run through the rules.
So we run through the first rule, require a tag for a name sub-gender.
we can eliminate anything that doesn't have a female tag.
And as you can see, basically, we just removed the male-only versions.
Because this is a really simple example, the solving is done now.
So we have female meshes and unisex meshes selected.
Now, let's look at a more complex example on this character, hopefully.
Yeah, notice how she has a hair in the back of her head that would clip, and we're gonna add a hood on the character.
So you can see that the part that would be clipping has disappeared, but you can still see the fringe that she had on the front, so the visual quality of the thing is still there.
There, just for fun, we added a Boolean flag in the DNA that makes you able to select whether or not you want the hood, so we also remove the hood, you see the hair come back.
Now let's put on a big hat, like let's put the hood back, and then I try to put a big hat on the character.
And you can see, likewise, the hat would not fit under the hood, so it removed the hood and the hair back.
And then we can add some cool effects to look really cool.
So let's look at how an example like this works.
So we start again from our same configuration file, but we have two rules now.
So the first one that we add is bonus to covers the head in top plus one.
So this is basically going to be a default selecting rule.
There we are just saying if you have the choice between a version that covers the head or that doesn't in top, just give a bonus to this one.
Finally, we have a conditional rule in there.
If the hat as a tag is thick, then you're going to ask to reject covers the head in top.
So this is basically the translation of if the hat does not fit under the hood, then remove the hood.
You could have a hat which is not tagged as thick, and it would fit nicely in the hood.
So you can support those.
Let's fill our DNA.
So now you can see that the hoodie has four meshes, male and female version again.
But this time, there's the covers the head and the doesn't cover the head versions.
The hat has only two versions, and they're both thick because the hat does not fit in their hood.
So once again, we initialize the score of zero to all the mesh versions.
And then we run through the rules.
The gender rule is going to eliminate half of the choices again.
Then the default selecting rule bonus is going to try and select the version with the hood on.
So we give a bonus score to the female hood.
But then we run the last one, and we look at all the available version in the hat, and we see that there is the tag is thick.
And this rule is rejecting the covers the head tag in the hood So now Solver has finished selecting the right mesh versions, and you can see that the character would have the hat on the head, and she would not have the hood on her head at the same time.
So that's how the Solver works.
The good thing with having a Solver in data and the rule is that you can come in any time in the production and try to fix some conflicts that you have, for instance, on Primal.
Late in the production, we noticed that the quivers were made to fit on top of a coat.
So the problem was that when we had the topless characters, the quiver would not match their body very well.
So we created a new version of the quiver to better match the morphology.
And in just like one hour or two sitting with the artist, we created a rule, and then created data, created some mesh variations, and then put that in the game.
So that's it.
It for the solver, now a little more about the slots that we didn't mention there.
So I mentioned that there's some material slots in there, and because they're separate from all the meshes, we can wonder how that works.
So when you define those material parameter slots, you're going to be free of the logic of how to apply those material parameters to the items.
So the only thing that you're gonna do, you're gonna say I have a palette slot there, and it just takes two colors, and those colors are named.
We just say, OK, a palette is a main color and a secondary color.
And the team skin is maybe just a team logo.
Now, when you create items for those slots in WolfSkin, you're just basically going to fill values for them.
So for instance, I can create a palette, select two colors.
I can create a team logo and then just point to a texture.
And I can create a lot of those.
But we still are away from logic.
On the other hand, when you create an item which chooses meshes.
there you're going to have an interface that lets you override the parameters of this item.
So you're going to gather all the materials in those meshes and then be able to point, OK, for this item, I want you to override the diffuse color of this material and then put those values.
So you could put the values by hand, but you could also point to variables in the DNA.
So there, we're just going to say, my diffuse color is the main color, my diffuse color 2 is the secondary color, and all these things.
This lets you have those atomic operations that deal with the meshes.
And all the meshes are free to do whatever they want with the palette.
The good point, the good thing with that is that because we have heterogeneous shaders in the meshes, it's easier for us to have the logic in the meshes.
That way we can support many setups and variations instead of having a very strict, like all the items, all the shirts needs to have the material set up like this.
Another example, like an example in Primal, I think we have some class-based body paints.
So the enemies, they will share the same body, but based on their class, they're going to change the body paint of their body.
We also have some pre-order bonus for Takkar when he has custom tattoos.
That was what we used it for.
Now, one last detail that I want to go over is the orange slots in this hierarchy.
So there I just mentioned that we have a suit slot sometimes and it groups items, but there's a little more to it.
So let's look at an example.
Now we have to go back a little bit to the research phase of the system, because this is not really, it's not greatly used in Primal.
But if you remember in Far Cry 3 and 4, we had some PVP with team-based gameplay.
So there we just created a simple hierarchy.
We have a top and pants slot, and we have a palette slot.
And then on top of that, we have a full suit.
slot and a gameplay slot.
So I'm creating my character, and I can just select a top and pants and a palette, and have my character look the way I want.
Now, sometimes you want to give a suit to the player, but you don't want them to mix and match items.
So there, we created a hunter suit, and it's a very specific top that goes well with some very specific top, pants, and a palette.
Now, this character could try and go into PVP mode now.
and you want to display the team color of their character.
The thing is, so then you can give control to the gameplay team and be like, OK, so I created a slot for you in hierarchy.
And the rule with the hierarchy is that the higher the slot is, the more priority it has over the other slots.
So when you put the suit, it overrides the top and pants.
And when I give the gameplay team, like they override the palette, they put their item higher in the hierarchy, and they're going to be able to override the palette.
Now, the good thing about that is that in the DNA now, I have like three tops, but they all come from different levels in hierarchy.
And the priority, so conflict solving, is handling that.
But it also means that it's a non-destructive operation.
So as soon as they exit the arena, I'm going to be able to remove the gameplay item, and it's going to remove my team color without destroying my customization.
Likewise, if I remove my suit, I'm going to still find my character there.
So that's it for Wolfskin.
No, we have a little more details.
So the next thing we wanted to look at was variety.
So what is variety in a game like Far Cry?
It's taking all these separate meshes that we built, all these separate parts, and assembling them in different ways to build an even greater number of characters.
In the past.
We do this through random combinations whenever a character spawns.
And we decided to solve that a little differently for this project because what we wanted to do was actually do full DNAs for our NPCs and then randomly spawn full characters.
So why would we want to do that?
The way we used to work was we would have to tag meshes that worked well together.
So these pants work well with these shirts.
The skirt works well with these shirts.
But the hood and tunic don't work well with the one on the top left.
So you can imagine, the more and more and more things we add, this thing can just fly out of control.
And it's a giant maze of tags of include, exclude, and that type of thing.
Experience showed us this is really difficult, also dangerous, because when artists are dropping characters in the map, they're going to see random spawned characters, but they're not going to see every possible combination.
There could be millions of possible combinations.
So that becomes really hard to debug and make sure that we actually don't have any problems, especially because once it gets in the hands of our players, if this gets in the hands of millions of players and each of them sees thousands of characters through the course of the game.
They're going to see combinations that we just never, ever saw as artists.
The other issue is, even if our QC team did find issues and flag them and say, hey, here's a screenshot of a character that has meshes that don't work together, or their skin color is the wrong color on the hands and their face, that's another big problem.
Because now it's really hard with this mess of tagging data to figure out what combination of tags actually let that happen.
Instead, we decided to.
just simplify it and break it down into small, solvable problems.
So what we did was we could take a bunch of meshes that we knew worked well together and throw them into something we called a generator.
And that would generate random DNAs.
It would tell us how many possible DNAs we could build, and we would tell it how many we would like it to build.
So in this example, maybe we built a possible 600 combinations of these meshes.
When we're done, we might go to a different generator, build another selection of meshes, and build a few more characters.
And then we just keep going, and we keep going.
And we just add meshes that we know will work well together or that fit this character class, throw them into generators, and build randomly generated characters.
But we can also build them by hand.
If an artist builds a new asset and they want to actually custom build a character, or if they want to tweak one that's being built by the generator.
And sometimes we even want to pull them out of a list.
So whenever they go out of the generator, they just get thrown into a list of NPCs to spawn.
But sometimes we want to pull them out and make them a quest giver.
So we can go in and play with it however we want.
And when we're done, we have a giant list of DNAs for characters.
And then they're deterministic.
So we can control them.
We can bug fix them.
If there's ever an issue, we can just go into the DNA of any specific character.
and change the items that it's wearing or fix the bug, or even debug what specific tags are causing conflict.
So that's really cool.
And of course, if we ever find that we don't have enough possible combinations, we can just go back to that original generator and generate some more of that 600 possible combinations.
So we're coming towards the end.
And we're just going to talk a little bit about what went right.
And then we'll also talk about what went wrong.
So what went right?
We built a complete character customization and modeling pipeline.
We supported skin characters, skeletons, and static and breakable props.
We didn't talk about them, but if you play through Primal, you'll see a lot of armor or helmets that can be shattered when you strike them.
So we supported those as well in our pipeline.
We had to maximize support so artists could use whatever they wanted, and riggers could use whatever they wanted.
We have this fast Wolfskin and GameX iteration loop where the two, the customization system and the modeling pipeline are really connected to each other and it's really fast and easy to work and then integrate new items.
And lastly, because of all of this, we actually got to do a lot of stuff that we normally wouldn't bother doing.
So for example, we added DLC. Julian mentioned we have this paint that you can unlock as a pre-order bonus.
And crafting costumes.
During the course of the game, even though it's first person, you are crafting your winter gear.
So when you go into the northern part of the map, it's a frozen north, and you need to upgrade your gear to go there.
So we actually were able to really easily, on the artist team, just integrate this upgrading clothing.
And we used some of those things we saw with the folder slots and things.
And we also use them on the NPCs as well.
So the NPCs also equip winter gear when they go in the north.
So we were able to do a few things like that that we normally would have required programmers or support.
And instead, we could just build it out in data.
So lastly, we'll just have a, for what went right, we'll just go through a little video so you can see some more things about what we built with the pipeline and see some of the characters in action.
So that was for what went right.
Now let's talk a little bit about what went wrong.
There's also obviously a lot of that as well.
First thing we want to talk about is that very commonly now in AAA, we're not equipped to deal with transversal tasks very well.
So there was a longer research period where we tried to say, OK, we think this is the direction we want to go with the character system.
And the thing is, when you start pulling something in a AAA engine, everything comes together.
So it's true about characters.
You start pulling that, and then get play, engine, tools, animation, online graphics, they all come at the same time.
So when you try and sit down with everybody, all the stakeholders in a room, and then you try to say, okay, this is the direction that we want to go, it's very hard to have 10 people agree on a direction, especially when it's not a thing that you can see at the time.
So, actually, there was two thing on Primal that helped us solve that.
The first was clearing up the decision process.
We really had a very tight schedule in Primal, so we agreed that we only had maybe a very short amount of time to make the decision.
So we've reduced the number of stakeholders.
We made a clear decision process, and that helped us.
The second thing is instead of having teams waiting for each other, like the engine team does their part, and then we wait for the tools team to do their part, and all this thing, you can have scheduling conflicts and everything.
Instead, we sort of.
made it more a topic in itself, so I took over, even though I wasn't a tools programmer or something, I took over all the parts from the pipeline to the tools to the engine, and then tried to make all the characters work together.
That way we would not be trying to wait for each other.
The other thing was, Junia is a very old engine.
It's actually based on CryEngine that we bought from Crytek when Ubisoft bought Far Cry.
So it's been like 15 years probably in use at Ubisoft.
And over like very large production, a lot of people have come and gone.
So there's a lot of the engine that we don't know now.
So we have lost knowledge.
For instance, the 3ds Max pipeline was a big mystery box.
So it creates a lot of fear in your discussion when you're like, okay, we think we want to change the pipeline, but we don't know it works.
So we don't know, we cannot evaluate it.
So in the end, yeah, we had to jump in the dark.
Let's talk a little bit about the future of Wolfskin.
So we're not there to make any announcements, obviously, but if you look at our past games, in Far Cry, there's been a lot of focus on weapons, vehicles, animals.
We think because Wolfskin is data-oriented, it would be a good fit to extend the customization take to all these things, and then extend the pipeline as well.
The other thing is we mentioned that you can load the assets into MotionBuilder, but right now, WolfSkin is not there, so we would find it really cool if we could have WolfSkin in MotionBuilder so that the animators can just load the last version of the character and then have the cool assets instead of right now where we have to export an FBX and then for the animators to work in MotionBuilder.
So that's it for us.
Thanks for listening to us.
And special thanks to everyone that worked on the pipeline and provided support needed to make it possible.
There's a few of you in the audience, I think.
So thank you to everyone here as well.
And looks like we have a few minutes for questions, if anyone has questions.
Just jump up.
There's a couple of mics there.
And don't forget to do the review when the survey comes out.
Hi.
I was wondering, did you guys have issues with piercing on tight-fitting meshes, particularly like the body slot?
Did you have to call out certain parts of the body to fix piercing issues?
Yeah, that's actually something that we identified at the beginning in the research phase.
And with the previous Far Cry games, we might actually have different versions of the naked body with different parts hidden or unhidden.
Specifically for Primal, we actually have a lot of naked characters and a lot of their clothes are like really loose fitting.
So we got really lucky on that side where because of this we actually kind of wanted to keep that naked body there the whole time.
But definitely like on the previous Far Cry games, we needed to deal with like hiding parts of the naked mesh in order to make sure that there was no clipping with the outer layers of clothes and even potentially with layering of clothes as well.
Thanks.
Yeah.
Hey.
Two small questions. The first one, we can see that you can navigate through a different piece of the body, and you can see the last version. Can you navigate through the different versions that have been pushed previously?
Sometimes it's really cool to see the evolution of one asset, and yet sometimes you're losing something instead of...
Yeah.
It's not better than before, and you want to see what's changed.
That's actually a really interesting thing that we actually benefit from with this pipeline.
In the past, all of our data, like our big max files and things, would be in their own separate data structure.
We didn't actually keep a lot of the history on those things because they're such big files, especially the ZBrush files.
Because now our data format that you load the mesh and you save the mesh is actually inside our project data, we always keep a history of that.
And so with Perforce, just like with standard Perforce revisioning, we could just roll back between things.
It would be nice to actually link a little bit more logic there between the mesh and its texture as well.
You can feel that if you have this button to navigate through the previous version in the same thing, it could be great because you have already a lot of things.
Yeah, we did do that a few times where just manually in Perforce, rolling back.
But because you're actually importing it from the engines, or the same data format the engine uses, you can kind of roll back that one, see the change in the engine.
And if you wanted to grab it back into Maya, you could open it still.
And just the second question was about the morphology of the characters.
Because you have a woman, man, and they are.
pretty a lot of muscle or not or something like this.
Did you manage specific topologies? It seemed to be when we see all the characters you generate have pretty all the same size and everything because it's modular you need to have some consistency on this.
How do you manage to upgrade this or maybe you already do this? I don't know.
Yeah, so they actually share the skeleton.
That's for, we have a lot of male and female enemies, so all of the enemy animation ends up being used for both genders.
We did share the base topology for the naked mesh, and then I think pretty much most of the clothing as well, because they're often adapted at the low poly.
So we might do a high poly on one gender, and then just adapt the low poly sometimes.
So they were kept.
kind of consistent between the genders.
And I think that's part of it.
But definitely the shapes were very different between the genders.
So it did mean for things like shoes, it's the same.
For hands, I think they were the same.
But once we got into the arms and the torso, we would have to adapt the meshes as well to fit that morphology.
OK.
Thanks a lot.
Thank you.
Hi.
I wanted to know if this system was used for the main character as well as the NPCs.
Yeah, I think when we started we weren't using it on the main character and at a certain point we switched because it just made perfect sense for us.
So we do use it on the main character and that's how we got the unlockable or DLC paint on the player's arm is an actual texture swap that's a separate item in the system.
And the same with the crafting of the clothing.
And if you go third person, like you can actually in Primal, you can switch to the eagle and fly around and you can see yourself third person.
So it was really valuable for us to actually be able to show that progression on the character through the game.
Because you actually do see him even though it's a first person game.
Quick follow up, is there any system that prevents NPCs to get items from main characters?
Like some crowns, who are very specific?
No, it was really up to the artist.
to just choose if they wanted to share the meshes between the player or not.
They're on the same skeleton and the player...
I think the player was actually the same config...
It was the same config, right?
Yeah, so it was the same config as the NPCs.
So, yeah, they shared things.
In fact, a lot of the things that the player wears are the same for NPC clothing.
Especially one of the main narrative characters at the start of the game, you meet, he wears pretty much the same outfit as you, you're a similar kind of warrior type character.
Thank you.
Thanks.
Hi.
Great talk, thank you.
Thanks.
When I saw Maya and Max interface, I couldn't ignore that big simply gone icon.
Was it part of Wolfskin pipeline?
to make it all D or it's totally separate and didn't really work with the skin.
Yeah, so yeah, we were using simply gone.
We didn't talk about it here, but actually at the booth later we'll be demoing a video of that.
But it's there we go.
There's the time that will be at the Ubisoft booth.
So 2 p.m. this afternoon.
We'll show a few more videos and one of them is simply gone.
So the we chose to use simply gone in the pipeline because before we used to have a LOD tool in Mac.
But of course, it's only in Max.
And then on Primal, I built one in Maya.
But that wasn't really good, because you get different quality LODs with those two separate tools.
And Simplygon is just way better at doing it than my tool was ever.
So we actually used the passenger and GameX data to send the data from either Max or Maya off to Simplygon.
And we worked with our tools group to have a little Python API for dealing with Simplygon.
And so we send the meshes out of either Max or Maya, send it to Simplygon, and then it comes back again.
And we just get these little notifications as they start coming into your Maya file.
So it was really good.
And as well, we actually embedded a lot of the Simplygon settings into that node editor that I showed at the start, the big thing.
So a lot of the stuff for Simplygon was set there, and you could save it with the mesh.
So if a rigger came and did a skinning pass on your character or something, you could click regenerate for Simplygon, and you would actually get the same LOD Simplygon settings whenever anyone clicked that button.
So yeah.
Thank you.
No problem.
Hey there, I got two questions.
First off is how do you manage the rigging process?
you know, let's say character has a big wolf head here and Goes to down low here. How do you auto rig it? Because you know, I saw that you got a previous Within, you know all three packages. Yep, and you can just boom see it Do you auto rig it at some point or so the characters are sharing skeletons?
But all the extra stuff that goes on top could be customized for the characters In Primal, we would put these shared rig extra constraints and bones and things into the core skeleton so they could be reused across different characters.
So in the video, you might have noticed there was some muscle system on the character.
So that was set up in Max, but we have a plug-in for that.
So the constraints are like a muscle constraint or look at position orientation type constraints.
or pose correctives like a driven key type system.
So the riggers could actually rig this in Max.
And then there's plugins from Maya for MotionBuilder as well.
So the animators see the muscle deformation, and they see the constraints in MotionBuilder.
And the exact same code runs in a game engine.
So all those extra bones, like there's the core 60, and then there's probably another 100 or so extra muscle bones and dynamic bones and things.
So all of those kind of get saved into this little XML description of what the constraint is and what bones it's affecting.
And then it gets sent to MotionBuilder for the animators, to the game engine for the runtime version of those constraints.
We'll show that a bit more at the launch at 2pm, so we'll have a bit video.
Oh yeah, yeah.
I think we have to free the room, so I think...
Oh yeah, yeah, I think we...
Thank you for coming.
Come up and...
