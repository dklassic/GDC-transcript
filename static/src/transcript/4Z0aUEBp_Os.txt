Thanks for being here today.
So just a quick reminder, if you can just mute your phone.
And also, at the end of the session, there is a survey that you can fill.
If we want to give any feedback, it will be really appreciated.
It's our first talk here at GDC, so anything can be interesting for us.
So this is Xavier Guibaud, gameplay tech lead on For Honor.
And I am Frédéric Doll, AI programmer on For Honor at Ubisoft Montreal.
So the game has been released two weeks ago.
And the feedback we get from the community is really incredible.
But a few years ago, when we started working on the project, we didn't know exactly what would be the game today.
And in fact, most of the time, when you work on a new IP, on a new game, you don't know what you will be released at the end.
You need to iterate.
You need to prototype.
You need to test stuff.
You need to find what is fun and try to build around it.
On the tech side, it means that.
You have multiple needs that will emerge.
And as we were able to see during this conference, sometimes one technology is not enough to fulfill all these needs.
And you have to test multiple approaches, and maybe have multiple approaches that cohabit in your game.
So the vision for For Honor was to create a melee fighting game.
So basically, you control a character, but most importantly, you control his weapon.
So you really are inside the battlefield.
You are inside the combat.
One important aspect is that the game needed to have a competitive, multi-player aspect.
The game needs to be fair because it's player against players.
It needs to be skill-based, responsive, reactive, and stuff like that.
Also, we wanted to create a game where you are in a believable battlefield.
It means that it's not.
a kind of arena of gladiators where a few fighters are fighting each other, but really a huge battlefield with the clash of armies, hundreds of NPCs that fight each other and you are only one soldier inside this battlefield.
So for the AI, we ended up creating two separated systems.
One deterministic, one replicated.
Why?
What's happened during the process?
What are the needs that we needed to fulfill?
That's what we'll try to show today with this talk.
So in this talk, we'll first show a few fundamentals of the game, how we control characters, how we handle the online part, and stuff like that.
Then Xavier will talk about the deterministic AI system.
I will follow with the replicated one.
And we will have a few takeaways at the end of the session.
So let's start with the fundamentals.
In the game, we have multiple characters that you have to control.
First one is the hero, the one with the more skills, the more abilities.
It's the one that the player is able to control in the game.
But we have also what we could call the map feeders.
So on the left, captain, soldiers, archers, this kind of stuff.
These are the characters that create the feeling of the army.
Also in the campaign, we have a cute elephant and huge wolves.
We have horses and other kind of characters.
So yeah, that's the kind of character we have to control.
To control this character, we decided to use an input-driven approach.
It means that it's like controlling a gamepad.
So if you have a gamepad, you just press a button, and it will have an impact on your character.
But it means also that you have indirect control on your character.
You can't say in the eye, for example, I want my character to go at 10 meters per second.
There is no way to do that.
The only thing you can do is give the orientation of the left stick of your gamepad and the strength of the stick and that's all.
So it means that the AI is input driven.
We use exactly the same pipeline for the player and for the AI in this game.
We let you go to one of our tools, we call it Katana.
Basically, it's a tool that the character designer used to create the characters.
So it's a huge state machine in which all the states, the blue boxes that you can see here, define a state of the character.
So it defines a gameplay.
during a certain duration.
The duration is defined by the length of the clip.
And they can define all kind of properties, the movement available for the character at this moment.
Does he have some defense?
Maybe he has some modifier.
He has some special abilities.
And they also can define all the branchings between the states.
And as you can see on the bottom, they can specify some kind of conditions that allow to trigger these kind of branchings.
So yeah, that's it.
Sorry.
So what does an update loop look like in our game?
It's, in fact, pretty simple.
We just generate inputs from a pad.
We send them into Katana.
Katana updates the state of the actor.
We get this into the world, and we're able to render it.
If we have multiple characters, it's exactly the same.
We just generate input for the other character.
We send them into Katana.
It updates the state of the associated actor, and we're able to put that in the world.
So for the AI, since we use the same pipeline, it's pretty simple.
The AI has to generate inputs, send them into Katana, and you know what happens after that.
But how does it work in multiplayer?
I will let Xavier explain this system.
Hello?
So yes, our game is a multiplayer game.
It works online.
The players are fighting against each other.
And the architecture that we chose from the beginning was to build a peer-to-peer one.
And the main reason was that we wanted as little latency as possible between two fighters, between when you're fighting somebody, he's in front of you, he's in your face.
We wanted it to be as fast as possible.
So what we actually send between each of the peers in a session are actually the inputs of the players.
It's the only thing, with very rare exceptions, that are actually sent.
And the way that it works is when a peer receives those inputs from the network, it's the exact same pipeline that Frédéric mentioned.
We get those inputs.
It starts driving the new actor with Katana.
But obviously, there is lag.
We're not receiving those inputs immediately yet.
So what we do is we have a deterministic simulation that runs on every single peer of the session.
What that means is that every peer is responsible to keeping in sync with everybody.
When we receive an input from another peer, every peer rewinds in time and resimulates every single step to catch up.
And we end up with the same conclusion.
So this deterministic simulation in the game, what Frédéric showed you before, the graph, it's all our gameplay runs into that simulation.
So everything is deterministic and comes to the same conclusion.
To illustrate a bit what that means, I'm going to give an example that doesn't really happen in our game, because we don't have three frames attacks in our game, but I think it illustrates what happens.
Imagine you're fighting somebody over the net.
He's on the other side.
And you launch an attack.
So at time zero, your attack is launched.
And we compute the frame.
You start winding up the attack.
Your weapon is starting to travel.
The frame continues.
We get to the second part of the animation.
And you finally hit your opponent.
You're happy.
You're trying to celebrate.
And then now comes the fourth frame.
Imagine at that moment that you actually receive an input from your opponent at that moment.
I mentioned that the inputs are time stamped.
So we see at that moment that at time zero, the opponent decided to change his stance.
So what that means for us in the game is that that input, it needs to be taken into account at time zero the moment that it happened.
And what we do is that we completely invalidate the state in which we were.
So there were never any hits.
It didn't happen.
And always in the same frame that were mentioned, so the fourth frame, we start resimulating every single step, but now with that new information.
So the information catches on, we resimulate, and we end up with the result.
Obviously, in that case, it's pretty intense.
But as I mentioned, we don't have four frames attacks in our games.
But it's really important, that aspect, because it introduces a fundamental difference in our game between a frame and a simulation step.
Because simulation steps happen multiple times per frame.
They're directly dependent about your network conditions.
When you receive those inputs, what's happening?
So imagine you have your big frame, do a couple of simulations, but as soon as you start having inputs that bring you really far away in time, your frame becomes way too big, the player is sad, the framerate drops.
So this was a really big implication for our game.
Those rewinds, they happen all the time.
We have a way of prioritizing the inputs of the actor that's fighting in front of you, so you won't see any rewinds with him, or as least as possible.
But the actors that are around him, players that are on the other side of the map, they still generate those inputs that are processed more slowly.
So we always have up to three to four resimulation steps per frame.
So it's our normal operation.
And we need to be able to recover and not have a big impact on frame rate when we have a really big resimulation.
So in that case, for example, 300 milliseconds delay, which would mean 600 milliseconds of ping, it incurs up to nine steps of resimulation in a single frame.
To be able to do this, every single object in our game has a history buffer.
So we save the states of those actors.
It's in a simplified structure, optimized and compressed as much as possible.
And every actor has a definition of that state that's then copied inside a bigger list.
And that history buffer, we keep around up to five seconds for every single object.
So of course, that takes a lot of memory.
But that enables us really to, when you go back in time, to resimulate from that moment.
I mentioned every single object has that, and it's really the case.
You get the idea.
Every gameplay element, the explosions in the background, the guys fighting, the heroes, the small soldiers, they all use that system.
It introduces also something really awesome that we did in the game that helped the production that you don't really see when you play it.
It's the fact that since we keep all those states and our game is deterministic, we're able to have those kind of features in our editor.
Let's say you're fighting, you're testing something, our designer is working in it and he sees a bug.
And he's like, this didn't work as expected.
Maybe there's something that was wrong.
Well, we have the ability to rewind and go back directly to where was the interesting moment.
And we can replay.
And all the inputs of the players at that moment were recorded, and we replayed them.
So we get to the exact same conclusion than what we saw before.
And all our tools can enable us to inspect what's happening.
We can see what's the states of the objects.
And I mentioned designers because it's a really powerful tool for them.
But even for us programmers, I mean, since the code is deterministic, we can put a breakpoint in the code.
And what we're going to see is the exact same values happening.
Awesome camera work, by the way.
So everything that's happening, it's a really powerful tool.
It was a bit of a side effect of that architecture choice, but we wanted to share a bit about it.
You probably see me coming.
This talk is about AI, deterministic AI.
So the deterministic simulation is where they live, what's happening.
And when we started the game, we knew a bit in which direction we were going.
But we wanted to give a believable medieval battlefield to the player.
We wanted them to have a sense of scale, being able to fight other fierce opponents, the other players, but also to be part of something bigger.
So we knew that we wanted to add a lot of factors in our world.
We were not aiming to tens of thousands of actors.
I mean, we're not a shooter, so the size of our maps was not going to be that big.
But around 200 actors was basically our goal at that moment.
And with the architecture that we showed you in the beginning, sending all those inputs over the network, we knew it was not going to cut it.
It was going to take way too much bandwidth.
So our solution for that, as we mentioned in the simulation, was rather than computing the inputs that we're sending to actors from outside the simulation and sending them, compute them from inside the simulation.
Thus, the deterministic AI.
What that means is that when you're playing online, every single peer is coming to the same conclusion and controls his AI in the exact same way, everybody's synchronized, without sending anything over the network.
That's a really big implication for us.
It met our requirements.
It worked well for that.
No network traffic.
That's awesome.
But it had a really big implication about what did that mean on the CPU side.
Computing all those actors with those rewinds, it was going to come to a cost.
So we needed to find a good solution for that.
So we have multiple one of them, but the big ones that enabled us to do that is the first one is time slicing.
Those actors, we wanted them to fill the map so that the players had a sense of scale.
They did not have to be as reactive as possible, so we cheated a bit.
and time slicing them and basically not updating them every single step of the simulation means that if we get to a frame that we need to resimulate multiple simulation steps well those actors are only going to be updated once.
So our update time that we came up with was around 3 hertz.
So of course, it's something that we tested through play tests, through gameplays.
We needed to see what was the limit at which we could bring that.
But it did allow us to be extremely resilient to rewinds in that case.
The second steps are simplified physics.
So this is the world that you see when you play the game.
It looks pretty and all.
And this is the world that the players, the collisions that the players actually interact with.
The collision meshes, everybody's probably aware of those systems.
But even that, it proved too much, too costly for simple soldiers.
So what we do is we extract the collision edges of all those meshes.
And all of that is cached in a localized matter in the map.
So the actors really only test the ground.
And they test those edges.
And that's all.
It's a very dull life.
They're not aware of the risks, but they don't care.
They're there to die for you, so we're not too attached to them.
Third of all, it's awesome, but we needed a solution for navigation.
And it came clear at the beginning that NavMesh path finding, in our case, was going to be problematic.
One of the reasons was that our libraries were not deterministic from the get go, so it was going to cause issues.
And we had concerns about the CPU costs of all of that.
So our solution was to use what we call nav flows.
They're basically big roads that level designers and mission designers drawing the maps.
It looks a bit like something like that.
Obviously, it limits the gameplay space of those actors.
They don't go everywhere.
But they really have a defined role in the game.
They're fighting over a certain piece of territory.
So level designers draw those nav flows.
They define which direction the actors should be going.
But they still have parameters that they can tweak to tweak the AI on those.
So we started to have something that was interesting.
We wanted to see those actors fight and have some meaningful gameplay in that section.
And our first solution was to start with a top-down approach to controlling where every single of those actors should be going.
So you can imagine the formations, the soldiers are marching together, and having a clash.
But our problem with that is, so on For Honor, we were extremely gameplay driven.
It was our mantra was follow the fun, and fell faster and follow the fun, the four Fs.
And we were playing that, and we were not feeling that it was interesting.
It started to be evident to the players that there were some higher rules that were happening that were weird sometimes with the exact positioning.
And also, we were still having the merge issue.
It's a big battlefield, the players kill those guys extremely, extremely fast, so we need to fill it up as often as possible.
And having those formations, those platoons, and merging them was proving to be...
a daunting task. I'm not saying it's not solvable, but in our case it was causing, it was starting to be extremely costly, it was not really fun, and it started to be, it was a bit of a mess. So we took a step back. And our solution, when we think about it, is really simple, it's flocking. And I'm not even kidding, our first implementations were pretty much that, they were wandering aimlessly.
But the idea was to find simple rules that would govern those actors, that when they're going to the center of the battlefield, so that it started to make more sense to the player.
The rules are simple.
It's easy to visualize.
And the player started to see that they had an impact on each of those actors.
So the complexity of those behaviors, they come from the number of rules that you start adding to them.
By themselves, those rules are not very complicated.
But the more you add, the more you start adding something that's interesting.
So one of them, for example, was the distance between actors.
When they're traveling to the battle, the distance between themselves, we allow them to be closer.
But if they fight, we ask them to spread a bit more.
There is this notion centered around the player that we have that repulsion bubble that increases and decreases based on his actions.
So they start being afraid of you.
And all of those starting adding up.
And up to one of my favorite.
When the player fights, that bubble increases and decreases, and the soldiers can move out of the way.
And those rules starting adding up.
So for example, this one, the Moses effect, you start moving, they move out of the way.
It's always very satisfying.
So all those rules adding over and over, we were like, yay, that's perfect.
The system works.
Let's give that to the designers so they can start tweaking those values.
Well, they were not that happy.
So we gave those systems and what was happening?
Whoops, yes, so it's working.
So what was happening is that the, I need to find my laptop.
So what we wanted was really the end result, the battlefield in which the player was actually fighting.
But we were getting to that point with very simple rules.
So every time we were changing one, it could affect the other, and it's that weird moment that our, We were creating emergent gameplay, but our goal was that emergent state.
So it was finding the rules that bring to that state proved to be a lot of trial and error, left and right, trying to see what happened.
To quote one of the designer I had a chance to work with, that's pretty much what she was saying.
She was scared of touching those values.
It was starting to do something weird.
So our solution for that, was to create presets.
In the end, when we think about it, the experience of the player in those lanes and where he's fighting was very pretty fine.
So we wanted something very compact, claustrophobic, or something more spread out, or something that we call the scattered one.
So those systems, if you look a bit at how it works.
So we can see a bit of the debug display, all those forces that are applied to every actor, the soldiers in the back that joined the battle.
Everything was very systemic, it evolved well, it was giving the result that we wanted.
To go back a bit to the scattered part, we all saw those movies.
I mean, those two armies are crashing into each other.
Then there's that big camera cut and smoke.
And then everybody is mixed up, left and right.
There's a big bunch of battles on each side.
And every time we were trying to get to that point, well, it wasn't working.
The reality is that when you think about it, the first layers just started hitting each other.
So it wasn't creating what we really wanted.
So to show the kind of thinking that brought us to there is that the simple rule that we ended implementing, that by itself is very complicated, but that brings us to the proper result, is something like that.
That we can call the Gentleman Rule.
Which is, if somebody is fighting an actor, so let's say we have a blue soldier that comes to the battle, and then the other blue soldier sees, oh, I'm sorry, you're doing a duel.
He lets him fight, and he goes to find a new target, which is more appropriate, and starts fighting.
So only that simple rule, when generalized, brought us to the state that we wanted.
So to give a small example, it gives something like that.
It's extremely messy.
There's a bunch of guys fighting, guys and girls, fighting left and right on the battlefield.
But finding those small rules was really one of the challenging parts because of the intricacies and the interdependence of all of them.
So.
It's fine, we have those soldiers, they go to the battle, they start fighting, but we still need it to be able to generate those inputs.
So Frederic mentioned at the beginning that we use the same character pipeline for every single of our actors, and it's the same thing for the small soldiers.
So this is really great for animators.
They can take the small soldier and start using with them.
But it's not really interesting for the player, or maybe it's DLC character announced.
And this is really a great tool for animators, because they don't rely on setups from the AI programmers or AI designers to test something.
They can build the animation.
They can look and control the movement, see what's happening.
So it made them extremely independent from us.
Not that they don't like to talk to us, but.
So the way that we use to generate those inputs is that we have an implementation of our beaver trees inside the simulation.
It's not extremely complex, but it does a good job.
So you can see actually that the beaver trees that we have right now in the game are extremely simple.
It's different rhythms of attack depending on the distance of the target.
But what's interesting is that we developed the tools that enable designers to actually debug what was happening and see and control the rhythm and the difficulty.
This can also be applied to any other actor.
This is one of the other actors that we have in the game that uses the deterministic system.
We call them captains.
The trees started to be a bit more complex, but it's still not like our bigger fighters It's going to come later, but it started to prove interesting.
So our behavior trees by themselves are nodes.
They're the one that are actually generating the inputs when it runs.
Really, the output of those nodes is it creates a structure that are the inputs.
Is the character attacking?
Is he moving?
Is he dodging?
And the conditions that the designers can put in place and hooks that enable the actors to influence the environment.
They're basically events.
So our experience of using the EverTrees inside the simulation was a mixed one, in the sense that it was extremely powerful for prototyping.
Designers could come with quick ways of testing gameplay, see what was working.
But we ended up often to, once that system was validated on a gameplay level, we needed to extract those functionalities and then implement them as services.
So we had a lot of analyzing what we wanted to do, strip them out.
So it was a really good way to iterate quickly.
But CPU-wise, it was costing too much.
So we needed to extract the logic of those and put them in separated nodes.
So you saw the actors.
We have a living battlefield.
But then on the other part, there's still heroes that needed to fight.
That's Fred's part.
Thank you, Xavier.
So can you hear me?
Yeah.
Can you hear me?
Yeah.
Yeah, it's OK?
Yeah, good.
So yes, we have, with the Deterministic AI, we have a battlefield with a lot of character inside it.
You are able to go and play with the system.
But we wanted to also bring challenges to the player.
It was meant to be a PvP game.
It was meant to have a PvP experience inside it.
So we needed ways to control as well the heroes, the kind of characters the player is able to play.
So we tried to create a system to handle this kind of challenge.
So why do we need another AI system for it?
First of all, we have NaFlu in the map for the deterministic AI system, but if the player go out of it, we can't do anything.
So we needed to have a way to be able to chase the player everywhere in the map.
Also, we want to have this cool moment, like you can see in the picture, where you grab the player on your shoulder and you throw him into spikes.
So we needed to have a more, a better understanding of what is your environment, what do you have around your hero.
We needed also better reactivity, 300 milliseconds to update your AI, it's a bit slow and if your player is just in front of you and you have to react to it, it can be problematic.
And one important aspect is that we wanted the AI to control the same kind of character.
We didn't want it to add, because it's a bot, to add 10,000 HP so that the player had to just attack him all over again to be able to kill him.
So we needed to base the difficulty on the skill and not on the statistic of the character.
So if we look back to how do we control the character, the player for the player, we get the pad, we generate input, send them into the simulation.
So for the replicated AI system for the bots, the AI will generate inputs.
So it will generate the inputs on one machine and send them over the network.
Here we have an interesting system.
Since we are working with a deterministic simulation, so what does it give us?
Basically, it gives us that we don't need to predict the state of the replicated characters of the other players, for example, because the simulation does it for us.
In fact, in the simulation, if you look at the current state, you have, in fact, the latest updated version of your character.
And if you receive an input and a rewind happens, it will be updated and you will be fine.
So of course, what happens if you have a rewind?
The state of the world can change.
So we discussed with the designer, and we decided that we didn't want to consider the rewind.
Because most of the time, a rewind happens, but it can be on another place on the battlefield.
It doesn't really necessarily affect the fights that you are currently doing.
And but if it happens that it affects the fights that you are currently doing, we, the only thing that you have to do is just check your current world state and change the decision of the AI. So for a certain amount of time, when you fight against someone who is controlled by another machine, you can take wrong decisions. But we decided that it was okay because as soon as you will receive the real state where you are, we'll just update.
and take new decisions for the AI.
And also, one really important aspect is that since we are updated outside of the simulation, we are updated only once per frame.
If a rewind happens, it doesn't affect the replicated AI system.
So we have more CPU than the sims.
So for the system, we built a lot of elements.
First one is the team strategies that will analyze the battlefield and try to assign tasks to the characters to spread them and try to win the game.
Then each actor will have to try to accomplish this task and you have a lot of services to fight, to navigate and that kind of stuff.
But in the end, what we want is to generate inputs for Katana to control the character.
So in this talk, we will mainly focus on the fight service and the inputs, because that's really a specific aspect of Forerunner.
Maybe next year, our colleague will want to give you more information about the other systems.
So if we look at Katana, so the way we control the characters, basically, it's a state machine.
So if we want to control the character, what we want, really, is to control what happens into the state machine.
what are the state, what are the transitions that we do in this, what is the execution of your state machine.
But the main issue we have is that we have 12 different characters.
All 12 characters have a unique state machine that defines their gameplay.
And also, this data was edited by designers.
So they were able to submit and make changes every day.
So it was really problematic for the AI to be always up to date.
So we decided to automatically extract information from this data.
So we have two aspects that we extract automatically.
The first one is standard information.
So what kind of attack are you able to do?
Are you able to charge your attacks?
Can you feint your attack?
What are the ranges, the timings, and do you have special properties?
Like, for example, as you can see on the pictures, you have on the left an assassin, which doesn't have some defense when he's idle.
And on the right, you have a tank that has some defense when he's idle.
So to be able to extract this kind of information, we discussed with the character designers, and we were able to define standards.
And so it means that they built all the characters, all this standard information in the characters with the same kind of patterns.
So the algorithm was able to extract and locate these patterns inside the state machine and extract the information for the AI.
But.
You have always combos and unique abilities, unique actions that define and give the flavor to your character.
So you can see that, for example, we have an ability which looks like this.
The content's not really important, it's like more of the structure.
And what we want for the bot is to go to this state.
This state represents, for example, the end of the attack.
But how can we do that?
Basically, what we want is to be able to extract the path into the state machine.
So we go into the branching between the states, we look at the condition, and we try to extract what kind of inputs, what are the elements that will allow the character to fulfill the condition and thus trigger the branching.
So we do that for all the states until we go to the root of the ability.
So to be able to do that, it was in fact pretty simple.
We needed to find a way to give information to the algorithm to say I want to reach this specific state.
So in fact, it's some data that the character designer have to put directly inside the data.
And that's it.
We are able to locate them.
And in fact, since they know their characters, they are able to define, OK, this is a special ability of my character, and I want to be sure that the AI is able to do it.
So with that, we have all the knowledge of our character.
We know how to control it, but we have to get this information and bring it to the AI.
So we decided to create simple elements that we call fight actions that are able to perform one specific action.
So for example, we have a fight action for the block, one for the attack, the dodge, guard breaks and stuff like that.
And we have also one that is able to play an input pass, so the pass that we have extracted with the algorithm.
One important aspect of it is that all these blocks, all these fight actions are character agnostic.
There is no code that say, for the Viking assassin, in this specific condition, you have to do this kind of stuff.
So they only use the auto-extracted data.
It's way easier, way easier to debug.
It was really a good thing.
So if we take a look at one example, We'll just look at a block of the attack.
So on the left, you have a player.
He will attack the bot, and the bot will try to defend himself.
So it's pretty simple, but how do we do that in the game?
So first of all, we need to be able to detect that the bot is attacked by the player.
Then at runtime, we go inside the katana graph of the player, and we're able to detect that, OK, he's attacking, and we know when will be the hit time.
After that, we go inside the extracted information for the bot, and we get the defense duration of this character and the delay to trigger, to activate this defense when we send the input.
And the only remaining part is just to be sure that we will have some defense when it occurs so that we can block the attack.
So we do that for all these kind of actions.
Most of them are really pretty simple, but we are able to combine them.
But yeah, we wanted, so now we are able to do all the small elements.
But we have two needs in our game.
First of all is PvP.
In PvP we want to replace players, we want to have unpredictable fighters, that when a player will face an opponent, he will not...
We will not recognize pattern in it, but in PvE it's different.
We wanted to be able to teach the game.
We wanted to create some elements that will help the player learn the mechanics and try different things and try to find what is the best option against special abilities and stuff like that.
So these kind of characters are more pattern-based, and we also had a few bosses in the game with multiple stages and stuff like that.
So we decided to, yeah, our solution to create this kind of factor was to create a kind of database of all the moves, all the actions so the bot will be able to perform.
So if we look at the editor, as you can see, it looks like Katana, but it's another one.
We were able to reuse a lot of elements.
That's why it looks almost the same.
But so we have three main elements.
On the right, it's what we call the action graph.
So we put all the fight action blocks together.
We are able to create branching between them, set up conditions that allow to activate this branching.
On the left, you have the decision tree parts.
It's where you will create a tree structure that will contain all the action graph.
So all the leaf of the tree contain an action graph and in fact is an action that you are able to perform.
And we have conditions, filters, cool down that allow you to define what branches of your tree are available at a specific moment.
So how does it look at runtime?
Basically, we do a query inside this database every frame, which can be problematic.
So we can optimize.
We did some stuff to be able to be sure that it's not a big deal.
So the first thing is that we pre-compute everything.
We noticed that most of the conditions are duplicated.
So instead of computing your information into your condition, what we did is that we compute the information before.
And in the condition, you have only to just check a value.
It's really, really easy.
After that, since we use a tree structure, if the designer organizes well the condition and the branches, we are able to have a good early out.
And also we are able to do partial queries.
Basically, when the bot is fighting, when it's performing a specific action, it's performing, it's doing an action graph.
So we have, we define a priority for it, and we can trim and remove in the query all the elements that are less important in the tree.
So in fact, most of the time, you just look at a few parts, a really small amount of branches in your tree.
So if we take a look at one example, so on the left, you can see the bot editor at runtime.
And on the right, you have the player in blue and the bot in orange.
And the bot will try to defend himself and attack.
And you can see on the bottom, the condition, they are highlighted in green and red when the condition are met or not.
So it was really powerful to help the designer understand what is happening.
He's doing a pretty good job.
But...
So, right now we have...
The designer was able to create all these fighters, but...
How can we...
But we have to use them in PvP.
So if we take a look at one simple example, we have six players.
The matchmaking, they want to play a game where you have two teams, two teams of four players.
The matchmaking will balance all the players.
So you know that your team are balanced, but you have one missing guy in each team.
So you need to add a bot in each team.
But what kind of bot do you choose?
You don't want to introduce an advantage to one team by choosing a fighter which is way too hard and select two bots that don't have the same difficulty.
And In fact, in the game, we created three difficulty levels from rank one to rank three.
So how can you be sure that your difficulty looks something like this?
All the rank one are at the same level, approximately.
And they are less hard than the rank two.
And the rank three are better than everyone else.
How can you guarantee that you have your difficulties almost homogeneous?
In fact, we ended up wanting to validate the EI.
But we have 12 characters, we have three difficulty levels, it means that we have too many matchups that we want to test.
And most of the time when we had meetings with designers, testers, directors, and we were fighting against a specific bot, and everyone was saying, oh yeah, I feel this guy is easy, I feel he's hard, but...
It was only feeling, not science.
So we decided to implement automatic duels between the bots and we tracked the results.
So it's very simple.
You set up an arena.
You put two fighters against each other.
And as soon as there is one dead, you have your results.
So the usage was really, really cool.
We were able to play more than 250 duels.
each night on one PC.
And the goal was to reach a pretty fine win ratio because an assassin, for example, should win more easily against a tank.
So you don't need to aim to a 50% ratio for all your characters.
But it's not a silver bullet because if you have two bots that are broken, the result doesn't make any sense.
You need to be sure that you have one bot at least that represents exactly the level of difficulties that you want for a specific rank.
And after that, you are able to compare it with others and so on.
So it's mainly to detect high-level anomalies, but we were able to use it in that way.
So that's it for the replicated AI.
We'll try to share a few takeaways about all this process.
So we use the input-driven approach.
Was it worth it?
Basically, yes.
In fact, we were able to share all the player improvements and testing.
We have on For Honor a team of testers that is fully dedicated to test the characters.
And they do that by just playing with the characters.
And on the AI side, we are sure that the characters are well tested and well...
Well, in fact, if we send an input to the character, it will do exactly what we wanted him to do.
So mostly, when we had the bugs, when a bot wasn't able to perform something, it was on the AI side that the input that was sent was not a good one.
Also, as Xavier mentioned, it allows the user, the animators, the designers, to prototype really easily.
They were able to spawn an elephant, for example, and just play with him with the pad.
So it was no need of any programmer for that, which is a really good thing because programmers can be a bottleneck sometimes.
And also it was really lightweight for the networking.
And one interesting thing is that since we use the same pipeline, the AI can't cheat.
It's not possible.
The AI can only send input, like the player.
And so if the player can do something, the AI can do it.
And if the player can't do something, the AI can't do it.
So for a multiplayer game, it's important so that you know that when you are in PvP, your AI can't cheat.
It's important.
So we used also a lot of data driven, as you were.
As we explained, the Bivy trees on the left, on the top right you have Katana, on the bottom right you have the bot editor.
Was it really worth it?
Yes.
Basically, the designers were really autonomous.
as the owner of the future of the fighters of the characters of anything it was really really important for us and but also and we were able to create a lot of characters we have so 12 characters at lunch. In the game we have I think and 100 of 4 different kind of fighters of a I fight those that can go to take control of these characters.
It's really important to us to give them great tools you you can just.
give them, like as Xavier mentioned, a list of properties to set, and that's it.
You need to be able to give them good visualization, you need to give them debug tools, a way to understand what's happening, so that they are able to isolate when they have problems and bugs, and they are able to isolate, understand what is happening, and after that they come to see you, and that's because maybe there is a bug inside.
And then the other side, working with a simulation, I mean it's been five years in total, and for Honor.
What was it?
Was it a good idea?
Did it work?
And it's been a daunting task.
We learned a lot.
But the advantages of having something that you don't need to think.
Basically, programmers that are working the simulation, they don't need to care about the fact that they're on a network or not.
The simulation is always right.
It's going to take care of what's happening.
If a programmer was working in the constraints of the simulation in a deterministic fashion, well, it was already working online.
So that was really a great thing.
We didn't need to be taking into account.
Is it the real position?
Is it an entity that's owned by my system, by my session?
Or is it somebody else handling which replicas?
It's something that we didn't need to look into.
So that was really great.
Of course, you need to take into account that...
you need to work with deterministic code.
So it happened a lot, storing something outside of the history buffers that we showed in the beginning, well, it caused these things.
So obviously, once everybody knew the framework in which we were working, it worked pretty well.
And I mean, it's the whole talk, why we're here.
Two AI systems.
Was it a good thing?
Was it a bad thing?
And for us, really, when we think about it, those systems did what we wanted.
From the beginning, it's really what were the tools that we needed to build those systems, what's the behavior that we wanted, and by having the approach of always centering our design decisions, our technical decisions on the player, well, it enabled us to come to that point.
And in the end, yes, we think we made the right calls.
It's doing a great job.
Both systems are different.
However, having those two systems, it's not an LOD.
So soldiers that are going in a NAFLO cannot become a bot and start going somewhere else.
So there's definitely some limitations.
It's some things that we can think about evolving.
And it's a constraint that was definitely something to look into throughout all the production.
So that covers it all.
Thank you very much for your time.
I think we have some time for questions.
And also one point, just after this presentation, there's an awesome presentation about modifiers in Foreigner that's done by one of our colleagues, Aurelie Lechevalier.
Yes.
Good.
So I don't know if there's any questions.
Do we have time?
Yes.
Yes.
Yes.
It's not directly AI related, but in the replicated AI, how do you decide, in a peer-to-peer based game, how do you decide who simulates the replicated AI?
The way that it works is that there's a peer that's owner of one of that AI.
So it can be one machine or multiple machines that can send those inputs.
The goal of the bots when they're fighting is really to replace a player.
There's no specific metric about choosing who's going to be the owner of that bot.
I mean, it's going to be...
There's definitely going to be a difference for players that are fighting against that bot.
I mean, he's going to have the same lag as the host, as the owner of that peer.
But it's the same thing as the player against who you're fighting.
A good choice, I would say, would probably to choose the teams.
So basically, if on my machine, I'm handling a bot that's on my side, I won't be fighting him.
I won't get an advantage.
I won't get zero lag, zero ping.
So by using that rule, it's a good way to mitigate that issue.
Thank you.
Hello.
So you mentioned specifically about AI.
I wanted to know if for the player versus player, you also only send the inputs?
Or if you also send some state properties on the players or else or anything?
The same thing, yeah.
It's the same thing, only inputs.
Only the inputs, and everybody gets the same conclusion.
And so yeah, as soon as you play on your machine, you take your decisions instantaneously.
So it's deterministic.
And those inputs, when they're received on the other side, the other machine really syncs up and goes to the same point.
But it's the only information that we send.
So it's closer to a lockstep system than to a proper request.
Exactly.
Thanks.
No problem.
Two questions, would you re-do the matches between the bots, like if you did balance changes for the heroes?
And then also, did you only do that with one map, or did you do that with multiple kinds of maps?
Can you just repeat?
I just, I didn't understand.
Oh, sorry.
The bot versus bot matches, if you re-balanced the champions to like maybe affect their range or something like that, would you re-run the rematches between all the bots to get a new ranking?
Yeah, yeah, of course.
Currently we are doing iterations and patches and stuff like that.
And yeah, we can use the same system to validate.
And we can, if we need, if we change something really important on one character, we can update the AI accordingly to be sure that we maintain the same difficulty, yes.
Gotcha.
And then for the bot versus bot matches, were you doing that just on one map or all the maps?
Currently we use it on one map, but we could use it in any map here.
Basically, we have one map, which was the first map that was created, and we use it all the time.
So we did the test in this one.
And I think we have all the kind of situations that we want in this map, like drops, so you can just throw someone from a bridge.
We have spikes and stuff like that.
So yeah.
Thank you.
Hi. Um, so are there properties to the melee combat that make the deterministic and uh input driven system that you guys went for more useful as compared to like other game types like a shooter or RTS or something like that?
It's a very good question.
Honestly, on our side, it worked really well.
What we wanted was really to get feedbacks as quick as possible, because your enemy is really in front of your face, so we wanted to have the link between those two peers as short as possible.
So that's why we went into that direction.
If your enemies are further away, I mean, I'm not sure you need such a big system because it has a cost.
Like, every single of our actors in the world, even somebody that's really far away, well, if there's a lag, if we get an input that's further away in time, we resimulate that actor.
So it has a toll on CPU.
So I don't think it's necessarily something I would be using on a first-person shooter, for example.
cool. Uh I also had a second question. Uh did you ever run into butterfly effects when like replaying stuff or um were there every like really long latency that like you wouldn't be able to replay?
Definitely at the beginning of the game it was certain that something that happened, we call them like the vortex of death.
Because if it takes too much time, then your next input is going to take more time, then the other resimulates longer, and then over and over.
So what we do is like we always ensure that we have enough time to catch up.
Luckily we didn't have that issue, but it's definitely something that can happen if you have something that's applied on, for example, all the actors in the world and if you do this and you need to resimulate a lot of uh...
of uh...
simulation steps it can definitely happen uh... what we probably do is that we our system is good if somebody's lagging too much he's gonna get kicked out before things get too bad cool thank you Yeah, I'm curious about your bot on bot matches.
Don't you get like a skewed statistic if like a certain type of AI is like just because of the balancing is just by design more effective against another type?
Like how do you like compensate for that?
I'm just curious like about the metrics.
Like won't that like skew them somehow?
I think it's weird.
We guarantee that at least one character is tweaked and tested by a human.
So that, in fact, the other one will only be tested against this one.
Of course, we test all the characters with the testers, but we guarantee that some characters are really, really heavily tested so that we are sure that...
it represents exactly the level of difficulty that we want.
So all characters are supposed to be equally effective against all other characters in that case?
Not equally, but that's why if we have an assassin, for example, against a tank, it may have a better win ratio against this one.
But we try to just be sure that it's homogeneous.
We allow a certain margin.
OK, thank you.
Hello.
My question is about the rules, determining the rules.
And I was wondering what the process was to determine if a rule was a good one or a bad one, and if there was some kind of formula you were using to judge the fitness of a certain rule, and if that could possibly be automated.
For the rules that govern the fighters?
Yes, you were talking about how you set a rule, and then it wasn't quite right, and then you'd go and change.
I was wondering about that process.
Yeah, it was a lot of, so our engine, since it's a simulation-based engine, we can speed up the process a lot.
So there were a lot of times where we were able to, so let's try those values, let's see what happens, simulate it, and some of our designers, people were wondering, what the hell are you doing?
It's been 10 minutes you're watching the game play on fast forward.
Well, they were validating the balance and what are the impacts of what they're doing.
So we have a way of really increasing really, really fast.
So that's one of the ways.
Other ways, a lot of debug display tools, visualizing what's happening with the different forces, the different algorithms that you're putting in place.
And, yeah, that's most of it.
All right, thanks.
I was curious on the bot-on-bot matches.
If you had completely deterministic AI, how the matches just didn't turn out exactly the same every single time.
No, the bots are not deterministic.
The AI of the bot is not deterministic, it's computed only on one machine, and that's why we replicate this stuff.
So...
But it's a good question.
I mean, our game, it's deterministic, but there's still random, like, the way that it works is that every single agent has its seed, its own random generator that's aligned to...
the current simulation step, the agent seed, and then we're sure that in the simulation step, we can use that random generator and have varying results.
So even if, but definitely if we use the same thing and we send the same inputs, you're gonna get the exact same result, absolutely.
So changing the seed of the session, stuff like that, is ways that we use to have a variance so that you're not doing exactly the same thing.
Okay, thanks.
Yeah, and yes, in fact, It's if you send the same input, but because for the bots, the system that generates input is not deterministic, you can just have different matches every time.
Yeah.
Thank you.
Hello.
My question is about what happens when you receive an update and you re-simulate.
Do you have a way to figure out which entities to re-simulate, or you just go to re-simulate everything?
Right now we resimulate everything, like when the naive approach maybe, and so we redo everything.
What we do is that when we see that there's a change that affected an object, so we have that other pattern that we call the observer pattern, that's responsible of all the visual effects, for example...
blood splatters, effects, sounds, so that when it sees that an object state has changed, well it cancels the effects that were linked to that object, so that we come in sync.
But yeah, so we're not separating.
It's for foreigners, too.
Hello, thank you for the talk.
So the game is available for different platforms, right?
Xbox, PlayStation, Windows.
Can you play across those?
No. No, we can't. Well, the domestic engine is one of the problems.
So you cannot do that.
But we have a metagame where you control territories and stuff like that.
This is the same across all the platforms, but the game, no, you can't play on PS4 against someone on Xbox One.
Because of the determinism.
But even for Windows versus Windows, I would think determinism would be a problem if you're platform dependent.
Yeah, well, we're not that platform dependent in the sense that we did have some issues, for example, at the beginning with Intel versus AMD CPUs.
We're not always getting the exact same results.
But it's something that I personally didn't do it, but our engineers figured a way to fix that.
So we probably would be able to fix it for multi-platform, inter-platform consoles, but it's not part of any plan.
It seems that we don't have enough time for more questions, but we can meet in the wrap room if you want after that.
Thank you very much again.
Thank you.
