Hello all, and thank you for coming to my talk on how to use shaders to create stylized visual effects.
Let me start off by saying that this will be a two-part talk.
The first part will focus on a generalized overview of shader concepts.
Part two will then walk you through a step-by-step way of how to implement said shader concepts in the game engine of your choice.
For the purposes of this talk, we'll be using Unreal Engine 4.
However, feel free to follow along in a game engine or shade editor of your choice.
A little bit about myself.
My name is Bir Sharma, and I'm a visual effects artist at a studio called Probably Monsters in Bellevue, Washington.
I've had the honor of working on some amazing titles on platforms from PC, current gen, next gen consoles, mobile phones, and even VR.
To give you a brief overview of what this talk is all about, we will start by talking about some of the common misconceptions and perceptions around stylized VFX.
And you'll just see in a bit why this is important.
We'll then move on to a VFX Shader 101 type of introduction, and you'll learn how these different systems work, or more importantly, how they come together to create some of the VFX that you see in your favorite games.
And then next, we move on to some neat shader tips and tricks that will help level up your VFX.
And then finally, we will do a Unreal Engine step-by-step walkthrough to implement the shader concepts that you just learned.
The topics on the right are not really in the scope of this talk.
However, I'm more than happy to chat with you about them if you grab me after this presentation.
So one of the bigger misconceptions about being a stylized visual effects artist is that you're either this hand-drawn, frame-by-frame, hand-painted visual effects artist, or you're this tech-savvy shader and simulation guru, but in reality...
If you have a strong grasp of these simple shader fundamentals, these simple shader concepts, you will be able to approach 90% of all visual effects problems of the stylized kind that come your way.
Another misconception that affects not just VFX, but the game industry as a whole, is what exactly is stylized?
Is Cuphead stylized or is Battlefield stylized?
is Fortnite or Uncharted or Borderlands stylized?
Well, you see, most people think of stylization as a spectrum, where on one end you've got cartoony and on the other end you've got realistic.
And I think that stylization can only fully be understood.
If you take a step back and take a look at the art holistically, from a point of view of the principles and elements of art, design, and animation, right?
And so there you realize that stylization is more of this design space as opposed to a linear spectrum.
Sure, making things cartoony is one way of stylizing your art, but you could very well choose to stylize just your motion, or I could very well choose to stylize just my form.
So a better definition of stylization could be that stylization is the abstraction of realism.
You know with realism you're forced to make your things look as realistic as possible while enhancing the visual language a little bit. However with stylization...
you're free to play with the shapes, colors, forms, motion.
You can exaggerate some elements or you can completely remove some elements to make sure it's in the line with your art direction.
Doing so with realism, it just break that illusion of reality and won't belong in the world of our video game.
And as you progress through this presentation and the different examples you will see, you will realize that they might be in opposite ends of the design space.
However, the same simple shader concepts apply to both those VFX or all those VFX even, regardless of where on the stylized design space they fall.
Okay?
So, here's an example of a personal piece that I made a couple years ago.
And as you can see, you might be like, hey, you know, Beard, you've stylized the cartoony values and you've got a color that is mostly cel-shaded and anime-like, but however, the motion of the liquid and the fluid is kind of realistic.
the buoyancy of that cube is kind of realistic. And you know, you would be right. But the reality is, even though the colors and values are stylized, there is absolutely nothing about this piece that has hand-painted elements in it. Even though the liquid motion or the buoyancy of the cube might be more on the realistic end of this design space, there is absolutely no liquid or fluid simulations involved. Every single thing that in this piece exists, you will be able to do just through all the simple shader concepts, excuse me, that you will learn throughout this talk. So let's begin with our first shader concept, okay?
It is the scrolling texture along UVs shader.
Now, this shader is called a few different things.
You can hear it called curve sweeps or swipe meshes or even the community of VFX favorite solar coasters, but they all do the same thing, which is they scroll a texture along the UVs of a particular mesh.
Now, just for instance, imagine I had a polystrip, okay?
And I had its UVs flat in a zero to one space.
If I scrolled a texture along that zero to one UV space, that would correspond to scrolling the texture on my polystrip, okay?
Now here you can see this in motion.
As I scroll my texture in my UV space, the same texture gets scrolled along my polystrip as well.
Okay, so let's go over real quick how to set this up in Unreal.
So here I've got a alpha texture and a emissive texture.
We will take a texture coordinate node and we will do a component mask where we will split this into a R channel and a G channel.
Now these directly correspond to the U and the V channel.
Okay, now, since this texture is horizontal and we wanna scroll it horizontally, we would scroll it along the U.
So we will do an add operation.
Now, add or subtract moves, okay?
This is important, remember this.
So we will do an add operation in the R channel, which is the U, and we will add a parameter called offset to this.
We will then do a append operation on both our R and G, and then it's just as simple as plugging that into the UVs of our alpha and our meso.
There you go, you have your very first simple scrolling texture shader.
And now that we have our shader ready, we can play around with the offset parameter and achieve our desired result.
Now, this brings me to our next important point, which is...
repeat textures versus clamped textures. A repeat texture, also known as a wrap texture mode in Unreal, does exactly what it sounds like. It repeats indefinitely loops your texture over and over again. This is useful for VFX that repeat themselves over and over again. As you can see in these examples you've got two games which are stylistically extremely different. However, they both follow the same simple shader concept which is on the left you've got Gears 5 whose waterfall is more on the realistic end of this design space. You see the colors, the values, the motion. However, the reason this is so so that the waterfall element exists in the world of Gears 5 without breaking that immersion for the player, especially at the very beginning of the game where this moment occurs.
And then you've got Spyro on the right, a radically different game in terms of stylization.
However, the lava faults are using the same repeating loop of a scrolling texture.
All right.
Now a clamp in contrast, what clamp does, is it indefinitely tiles very last pixel of your texture.
Okay, so in this instance if you see the alpha texture over here, it's got black pixels to either side. As we know black pixels represent transparency, so you can see once that your texture has scrolled past, it just repeats that very last transparent black pixels for the remainder of its life.
And these clamped textures can be useful for effects that go from point A to point B.
So effects that happen one-off, all right?
So you can see in these examples, stylistically quite different.
However, they all use VFX.
They go from one point to the other, and these use clamp textures, okay?
And as you can see, they can be used for VFX like sword slashes.
or a VFX like a projectile and trail or even bullet tracers.
Okay.
So in my example, I've used a repeat or wrap mode texture that scrolls along the UVs of the strip mesh.
Okay.
This scrolling was done using a banner node, okay?
Which scrolls your input in any given direction.
And since I wanted to scroll it downwards, I plugged in a value of negative one on the Y-axis.
So that'll make sure that my texture scrolls downward on my mesh.
Now, this is very interesting, because this principle of scrolling textures along your UVs doesn't have to be on strips of polygons as well.
In this example, you can see how the ripples moving outwards on the surface of the liquid were created using the exact same technique.
So, if you look at our previous example, we had a strip where the UVs were laid flat, scrolling that along it, scrolled it along the mesh.
Now, if we have a circular mesh, and if we lay its UVs out flat, let's say we have a ring, okay, now what you could do is have the bottom part of your UVs be the inner ring, and you can have the top part of your UVs be the outer ring. And now as you scroll your texture from the bottom to the top of the UVs, you'll have your same texture scrolling from the inner ring to the outward ring of your UVs.
right? And there's so many use cases of this technique guys. You could use it for like shock waves in the ground or you know maybe even like block VFX where you have you know if somebody hits you and block you have the circular almost dome like VFX that plays. They all use this similar technique. Now moving on to shader number two we have alpha erosion.
Now this one has a couple of different names as well.
You have heard it being called Alpha Threshold, Alpha Crushing, Alpha Clipping, Black Point Fading.
There's a couple of different names, but they all do the same thing.
Now, basically what an alpha does is it controls what parts of your texture are visible and which parts are not.
So a value of one or white.
usually means fully opaque, and a value of 0, or black, means fully transparent.
So, moving your value from 0 to 1 and back gives you a fade in and fade out, as you can see in the example below.
Now this is okay for some use cases.
However, sometimes we want a bit more fidelity in the way our texture fades in and out.
And that's where alpha erosion comes in handy.
And now you can see using alpha erosion, it gives this texture a more sense of being kind of eaten away, more of a dissolving feeling, as opposed to a uniform fade in and fade out, okay?
The way alpha erosion works is, if you supply it a gradient, Okay? Alpha erosion starts eating up from one end of the gradient all the way to the other.
So in this case, it will start eating up all the black values first, then the gray values, and finally make its way all the way up to the white values. This way, you get some sense of like non-uniform fading in and out, as opposed to the whole texture just going in and out. Okay?
Here you can see the comparison side by side of a traditional alpha fade in and out as opposed to alpha abrasion fade in and out.
Okay?
So setting this up, we will set up a very simple version of our alpha erosion.
We already have our noise map baked into our texture.
So we have our alpha mask with varying degrees of grays, blacks, and whites.
Now we're gonna make a parameter, call it erosion, and then we're gonna subtract this from our texture.
Then we're going to saturate this result. What saturation does is it clamps your result between 0 to 1. This is important because you don't want it going to super whites and neither do you want it going to negative values, okay? You plug this into your opacity and there you go, you have your very simple alpha erosion shader guys. And once it's ready, play around with your erosion parameter and see the result.
Here are some of the uses of alpha erosion.
We can see on the left-hand corner, Legend of Zelda, Breath of the Wild, the explosion and the smoke doesn't just fade out, right?
It has the smoke kind of being eroded away.
on the right side we've got Assassin's Creed, a game more on the realistic end of this design space, quite different from the style of Breath of the Wild. However, they used the exact same principle on their blood effects. So their blood effects erode out instead of dissolving, instead of fading away, sorry, they erode out giving this more sense of chunkier, goopier, globbier feeling to it. All right, moving on we have third and my personal favorite UV distortion shader. Now this shader does exactly what you think it does, it distorts your UVs. So as you can see here we have a static texture, if we pass some UV distortion onto it, it instantly comes to life. It's not more wiggly, it has this sense of motion than just the static texture on a card that it previously was.
The core principle behind UV distortion is if you take a scrolling texture and you add it to the UVs of another texture, it can manipulate its UVs. And so here we achieved the wiggly motion by scrolling this noise texture into our alpha texture. So a simple way to set this up would be we're gonna take a normal map.
Now we'll come to this in a moment why this is important, but we're gonna take a normal map texture.
And then if you remember from our very first shader, we used a panner node to move our texture, right?
So we will do something exactly similar.
We're gonna make a panner node and we're gonna move it downwards in the Y axis, okay?
By 0.5.
Now, for the purposes of this demonstration, I go ahead and scale the UVs to be 0.5 and 0.5.
And the reason for this is because I want to see more blobby-er distortion on my alpha texture, as opposed to more high-frequency noise, okay?
We're then going to multiply the red channel with a parameter, let's call it distortion.
And then finally, as we mentioned earlier, we're going to add this to the texture coordinate.
And then when we plug this value into our texture, we finally have our very first UV distortion shader.
Okay.
Now, when we play around with our distortion value, we've got a wiggly little line coming to life.
Now, as you saw in that previous walkthrough, we use a normal map. Now the reason for this is a normal map by default operates in a minus 1 to 1 texture range. Okay now a regular noise texture is usually in a 0 to 1 space. So the way we fix this is using an operation known as remapping.
Okay the way ReMAMIC works is we take a simple 0 to 1 space and using some math operations we convert it into a negative 1 to 1 space. Alright, now it's important to remember this little bit of math. Multiplying scales your texture range. Adding or subtracting moves your texture range. Okay, so let's visualize this really quick.
we've got our 0 to 1 space and if we multiply this by 2 scale 0 times 2 is 0 1 times 2 is 2 so our 0 to 1 space scales to 0 to 2 space okay now we can subtract by 1 okay subtracting moves so 0 minus 1 is minus 1 2 minus 1 is 1 and there you go it has moved now to a negative 1 to 1 range and our UVs have now been pre-mapped. Okay so another way to do this we take our 0 to 1 space and we can subtract this by negative 0.5. Subtracting moves our texture so 0 minus 0.5 is minus 0.5. 1 minus 0.5 is 0.5.
So this moves it right there.
Now we can multiply this by two to scale our texture.
So negative 0.5 into two is negative one and 0.5 into two is positive one.
And then boom, you have your texture is zero to one, from zero to one, excuse me, to minus one to one range.
So here we will do a remapping.
However, we'll use a built-in node in Unreal Engine called constant bias scale.
If you take a look at this texture, you can see it's off the center, right?
So we're gonna create our constant bias scale and we're gonna subtract by 0.5 and we're gonna multiply it by two.
And so what this will essentially do is move our UVs in the negative one to one range.
Now, if you take a look at that texture down below.
it is now in the center. So UV distortion has many many uses.
Alright, we take a look at Legend of Zelda once again. You can see these fires.
They were all done using the UV distortion shader.
That is the cool thing about this.
You do not need to hand draw these fires.
You do not need to simulate them in a software like Houdini or use FumeFX.
These are totally achievable by using some UV distortion noise on a texture.
Simon Trumpler has an amazing talk on how he created the fire in Rhyme.
And I would highly suggest taking a look at that talk if you're interested in how to make these kinds of fires.
And if you remember from our alpha erosion section, the Assassin's Creed blood, we can now go ahead and add some UV distortion to it.
And it totally gives this visceral, really flowy kind of motion to our blood textures, which is essentially just a static card texture and not some fancy liquid simulation being played.
All right?
And guys, UV distortion is...
really versatile. I've seen it being used in 2D games before where we had a flag texture that was a static card and passing some UV distortion to it just brought the flag back to life and had it waving. This has got to be one of my favorite UV shaders. So following the same principle, all the splashes and splatters were done by UV distorting these textures.
So let's move on to our next shader, vertex offset.
Now, vertex offset is also known as world position offset.
And the way it works is it allows the vertices of a mesh to be manipulated in world space by the shader, okay?
Now this is useful for making objects move around or change scale or change shape or rotate and plenty of other effects.
In this effect, you can see how we have passed a scrolling noise into our sphere, and that has created a more blobby sphere.
Okay, for this example, we will use vertex normals.
So, let's talk about what exactly the concept of a normal is.
Okay, a normal can be described as a vector that defines the orientation of the surface.
Okay.
As we can see over here, we all know that a sphere is not really a sphere, right?
It's a collection of quads or tris that come together to form that sphere.
And so the normals for each one of those faces is a line that is perpendicular to that surface that defines the orientation of that face.
Okay, so in our engine, we can get the world space vertex normal by using the vertex normal WS node.
As you may have guessed, the WS stands for world space.
And with this node, we can do operations in our vertex shader.
So let's create a very simple vertex offset shader.
As you saw in our previous example, we have a scrolling noise that goes down our sphere.
So what we're going to do is we're going to call the vertex normal node and then we're going to multiply this with a parameter. Let's call this parameter offset. Okay now we will once again multiply this parameter with another parameter and call it strength. Okay and then once we plug this into the world position offset node you will have control of the vertex shader of your object.
So if you can guess what this does, it will scale your object.
So in this example, we can see you can make your mesh grow or shrink within the material without having to manually transform it.
How cool is that guys?
Now, if we wanted our spherical blob that we saw in the previous example, in the first example, all you have to do is really just take your normal and pass that instead of your offset parameter node.
Because it's scrolling downwards, just like the distortion, it will create the same effect and it will create this blob.
Now once we tweak the strength, you can feel free to go as subtle or as crazy as possible depending on what your effect's called.
Some applications of this include Uncharted, where they have some really amazing, amazing examples of how they use vertex offset to create really great effects all throughout the game.
However, this is just one example. It barely scratches the surface, but it's still really cool.
The motion, the flowing of the liquid in the glass, is controlled by the vertex offset.
On the opposite end of the stylistic design space, way far away from Uncharted, we've got Abzu and Pathless, where their fish and birds are controlled by animated vertex offsets.
And that is really cool because it helps save the cost of having bones or having animations.
Everything can be controlled just through the shader.
I've seen many more useful applications, guys.
One example is ambient grass flowing in the wind, and this is a pretty universal application, regardless of where in the stylized design space your game falls.
All right, so coming back to our piece, this stream of water has this undulating, kind of uneven flow to it.
And so it's literally just a polygon strip with some scrolling noise, just like the sphere, creating that downward blobby motion that I showed you before.
So now we can move on to our neat tips and tricks.
The first tip is mask.
What is a mask?
A mask is usually a black and white texture that can be used to perform certain operations.
Just like an alpha, black usually means zero and white usually means one.
And so, operations from this, you know, you can have masks do really simple things to all the way to really complex things.
Here's an example from the vertex offset section with the fish from Abzu.
And here you can see you have the mask going from black at the head all the way to white at the tail.
What this means is your vertex offset will mostly affect that tail end and reduce in intensity the closer and closer it gets to the head, okay?
The next step is gradient mapping.
The concept behind gradient mapping is that given a black and white input image and a colored gradient, all black and white values are mapped to the equivalent color values of that gradient.
So where the image is darker, the colors at the left of the gradient are applied.
Where the image is lighter, the colors at the right of the gradient are applied.
So essentially, the way we map our gradient to our texture is as you can see above we have our gradient that goes all the way from teal to tan to pink. Okay down below we have our texture that is got some whites and grays and blacks and when it's fully mapped you can see that the white parts are pink, the gray parts are tan and the black parts are teal.
To set this up in our shader, it's just as simple as plugging the red channel or a combination of channels of your choices right into the UVs. That's it.
One of the great things about Unreal Engine is traditionally we used to make these gradients in a software like Photoshop externally.
But now in Unreal Engine, you can use curve atlases.
So you can create and preview gradients within the engine itself in real time.
It's super helpful when it comes to iteration.
Here are some examples of a gradient mapping in action.
Besides just saving a lot of texture memory, it is also very useful for creating this amazing variety using a limited number of assets.
Now debugging is something that I personally use to visualize the math that I'm doing, to visualize what controlling a potential parameter could look like, okay?
Out of all of these, I use scalar values and debug time sign the most.
Sine wave traditionally goes from negative one to one, but the debug time sign node has been normalized in Unreal Engine to go from zero to one, okay?
If you want a regular sine, you should plug a time into sine.
Okay? And below here, you can see that plugging the sign into a debug scaler values helps us visualize our math, seeing it go from negative one to one.
Our next step is LERP, also known as linear interpolate.
Now, this is many, many uses from scaling, transforming, colors.
It's pretty universal. The concept behind this is if you have two inputs, A and B, the alpha will denote a point either at A or at B or a blend of something in between.
Now your alpha can be anything, it can be a mask, it can be a scalar value, it can even be a Fresnel, whatever it is, it can be your alpha and that will denote that point between A and B.
So here we have an example where we have two colors, we've got red and we've got green.
we plug that into the A and B inputs.
Okay. Now, since the alpha of this lerp is by default set at 0.5, you get yellow, which is a blend of red and green.
If I set this value to 0, we get just red.
Set the value to 1, get just green.
All right. Now, to preview this, I can select the debug time sign node.
Remember, it goes from 0 to 1.
Once I plug that in, we can see our color going from 0 to 1, red to green, and blending in between.
right? Our last tip for the day is dynamic parameters. So initially we were controlling all our parameters manually through a material instance.
But if we want to access these properties in a particle system like Niagara or Cascade, we will use dynamic parameters instead. As you can see there are four inputs and they all correspond to RGBA values. You can see that we've named our first input offset and we've given a default value of zero. To control these parameters inside your particle system, you will use the dynamic parameter module in Cascade as well as Niagara.
And this is the end of part one guys.
And thank you for watching.
And I will catch up with you in part two, where we'll go through the simple concepts in Unreal Engine and set them up.
Hey guys, and welcome back to part two of how to use shaders to create stylized visual effects.
In this part, we'll be going over how to create those same simple shader concepts in Unreal Engine 4.
So to begin with, I've got one, mesh and four textures. Let's go over our mesh first.
Our mesh is a simple curve mesh that I built in Maya and its UVs have been laid out flat in a 0 to 1 space. Now It is important to note that these UVs are laid out vertically.
Now this is different to the examples we had in the previous presentation where they were laid out horizontally.
This does make a tiny bit of a difference in the way we do our operations, but we will get to that when we come to compiling our shader.
Next we have our four textures.
Just open them all up so we can talk through them.
So firstly we have our trail texture. Now our trail texture is what will be scrolling along our curved mesh.
We then have our noise texture. Now this is used for our UV distortion and can be used for several other purposes as well.
We next have a gradient texture.
Now a gradient map, this particular one was built in Photoshop.
This particular one has also a brown start and goes all the way to orange and yellows and white values.
Lastly, we have a alpha mask.
Now this alpha mask is what we will use on top of our curve mesh to hide the edges.
And the reason we do that is when your to rail texture scrolls along.
you do not want there to be this jarring hard edge that it clips against.
And so we use this soft edge to kind of create this softer mask on an edge.
Okay.
So let's begin by tossing our mesh into our scene.
Excuse me.
We will then go ahead and create a material.
We'll call this M underscore Shader.
Open this bad boy up.
Now the first thing you will do is change this from opaque to translucent blend mode.
Now the reason you do this is because you want to be able to use your alpha mask as your opacity input.
If something is opaque, there is no opacity input. It's just opaque.
We will then get our alpha mask texture and trail texture into our shader.
You can do that by selecting your texture, going into your material, holding down T for texture and clicking.
Once again, select the texture you want, go into your material graph, hold down T and click.
What I'm going to do is multiply these textures because I kind of want my trail texture to have a nice soft.
edge just like that. I'll plug that into the opacity channel. Then I will... then let's just make a vector parameter. Hold down V for vector parameter. Let's just call this emission and plug that into the emissive. Let's get a value of like 3 in the red channel. Hit save.
go back and let's right click and create material instance.
Now material instance is kind of like the child of a master material.
It inherits all the properties from the parent material, but it has its own values.
It's kind of its own entity in a way, okay?
Let's drag and drop this material instance onto our mesh.
You can see it automatically populated the material field.
Let's open it up.
Sorry guys, I just have the ability to record one screen at a time and so I have to drop this down here.
You see the emission parameter has shown up right here in my instance.
And you can click this and there's two ways to update it.
If you know your values, you can just plug them in right there.
Let's say I want to in blue and I have this nice neon pink trail thing going on.
Or you can always use your trusty color wheel if that's what you prefer.
Let's just go down here.
Very nice little wispy trail thing going on.
Okay.
So you see how even though both the parent and the child have the same property of color, they each have their own value of what that color means to them.
Let's go back to our shader and let's create our first shader function.
Let's do scrolling texture on UVs.
we need a texture coordinate node for that.
And the easiest way to create that in the material graph is to use, sorry, to hold down U for UVs and click.
We'll then, component masks, and we will mask out red and green channels.
In our previous demonstration.
we did the add operation in the red channel because we wanted to move our texture horizontally.
In this case, we wanted moving vertically, so we're going to do our add operation on the green channel instead, okay?
Just like we held down V to create a vector parameter for the emission, we'll hold down S to create a scalar parameter for our offset.
Now we'll do a append vector operation on these bad boys.
We'll plug them into the UVs.
Let's open up our instance. Let's see what we have here.
So now we have our offset parameter that's shown up.
And now if we scroll this guy, There you go, you have your nice infinite scrolling trail of doom.
Now what I would like is to see it just be a one-off trail, so just a one-off slash almost if you will.
And to do that we will need to change our texture repeat mode from repeat, from wrap to clamp.
So the way you do that is you open your trail texture.
Click on this little drop down, you see this tiling method. It says wrap. We want to change that to clamp.
Hit save.
Open up the texture.
Now we go from sun negative one.
We're going to go from negative one to one.
We have a nice little sweet little squirrel. Let's do that again.
Let's go from negative one.
Boom.
Okay.
Save.
And let us, let's unplug this guy.
Drag these away.
Let's select on those, press C.
Create a nice little box for them.
Texture.
Put that away.
Let's move on to our second operation now.
Let's do UV distortion.
So for that we're going to use our noise texture.
And we can select it, hold down T.
Okay.
For scrolling this noise I'm gonna use a panner node.
What a panner node does is it moves your texture in a given direction.
I'm gonna move it speed of maybe, let's say one in the Y direction.
Now if you want to visualize what's happening with your nodes, one good method is to click live nodes and live updates.
So now you can see it moving.
I think this noise is a bit too high frequency for me, for my liking, so I'm going to go ahead and scale the U and the V just a little bit.
Let's give this a 0.3 and let's give it a 0.1.
that is way too fast so let's go down and still 0.1 much better okay now remember since this is not a normal map you're gonna have to remap this using the constant bias scale or performing individual operation. Let's just go ahead and remap this from negative 1 to 1 let's put in 0.5 and 0.2 Now we can multiply this with the scale parameters, close distortion.
And remember you want to add these to the UVs, the trail texture.
All right, very nice.
Now we go back in here.
you have a distortion parameter. Let's start small. Let's give it a value of 0.1 maybe.
There you go. You have a nice little wispy motion going on there.
Let's turn this back off.
Here. Unplug this guy.
All right, let's do alpha erosion next.
Now our trail texture already has built in a decent range of grays, blacks, and whites, so let's just use that to our advantage.
We are going to subtract that.
And let's subtract it from chronic erosion.
then you want to saturate this because you want to make sure your values are between 0 to 1. Let's use this to multiply with our alpha mask.
Now one thing you want to make sure is Try and keep your parameters to be in the range that you want for your shader.
So in this case, I want my parameter tweakable from 0 to 1.
So what we can do is click on that parameter.
And where you see slider min and slider max, you can set those to 0 to 1.
What that will mean is your erosion parameter will only be slideable between 0 to 1.
Save this.
Let's go back in here.
Now that we have this, let's turn on our erosion.
And you see it doesn't go lower than zero.
And when we work towards one, it fades in and out.
A really cool way to visualize this without even going outside or leaving the editor is to, you can select your curved mesh, click this little T part right here, get your curved mesh in here, right?
Now you can, erosion, we know it goes from 0 to 1, so you can plug in a debug time sign node which does exactly the same.
As you plug that in, if you check out your preview, or even this right here, you can see your texture eroding in and out from 0 to 1.
Alright, I'm going to put this back here for now.
and let's...
Now lastly, let's do our world position offset.
Now you can do that.
Let's just copy these nodes right here.
In fact, let's do that.
All right.
uh...
you want to multiply this with your vertex normals remember WS stands for world space multiply this with another parameter, let's call this WPO strength oh wait, just WPO is enough we'll plug this into our world position offset Apply, save. Let's go in here and give this a value of maybe 0.1, 0.3 and 0.3.
Then I think this is panning way too quick, so let's halve this to 0.05.
Alright, let's do that.
And go back out, you can see a little trail.
turn on WPO. Let's set this to, I don't know, let's start small 10.
All right, you see that? Now, unlike UV distortion, this thing is actually lifting the vertices. So let's set it to 50. See that?
Okay, and set it to something really crazy, like 500. But there's not too many use cases where, you know, you would do something like this. And there's There's more smarter ways to do things like that.
So we'll set this back to zero, go back into our shader, unplug this guy.
Let's go over to Studio.
So now we've individually created all of our four different shader functions in Unreal Engine.
Let's go ahead and add our gradient map into this. So let's get rid of our emission parameter and let's take our let's take our trail and we can bring in our gradient.
Now, the simplest way to get your gray to white values from this texture to this, is to take your red channel in here and boom.
You can see right here, all your values, everything in here.
drag this, plug it into the emissive, hit apply, and boom! Now I have a nice little fiery thing going on. It seems a little off and the reason for this is your gradient map needs to be clamp not wrap and you can see over here it's repeating the last pixel we do not want that so let's go to clamp, clamp, save There you go.
Now that we've built these functions individually, let's compile them all together so we can perform all of these operations on all of the trail.
So let's start with our UV distortion and scrolling texture.
In fact this thing is independent. We can just plug this in directly. This will not be dependent on any of the other functions. These two however will be dependent on each other so let's drag that out of the way. And our erosion as well is independent so we can take this, plug this into the subtract and plug our saturate into the multiply.
Okay, very messy, spaghetti noodles all over.
Try to work as neatly as possible, but you know.
All right, so now we know that our scrolling texture is just scrolling on G.
So what we can do is take this mask and steal it for this right here.
and we can plug this ad into the append one cool little trick you can do is in Unreal you can double click a node link and it creates this little dot that you can drag around and now we will take this and plug it into our lovely trail texture UVs.
Now if you hit apply and save in your material instance, you have all your parameters showing up.
Go back here. Let's say WPL, let's just leave it at zero.
Offset, we can leave it at that. Distortion, let's set it to 0.1.
And there you go. Now you have a moving trail.
that you can control, say, it goes on, like that.
And then it starts out full, but towards the end of it, it kind of erodes away instead of just like traveling all the way out, it goes, and then just like dissipates away out of existence.
A lot of cool things you can do over here.
One of the main ways to control all these parameters as VFX artists is in a VFX Editor system, a particle system.
So you can use Cascade and Agra, whatever.
The way we will do that is using dynamic parameters instead of scalar parameters, okay?
So what we're going to do is go in and replace all our scalar parameters with dynamic parameters instead.
Let's go ahead and start that.
So we're going to go in here.
You create a dynamic parameter.
Let's see.
Distortion.
Erosion.
Offset.
And VPO.
Our default values are 0.1, 0, 0, 0.
Let's plug this bad boy in distortion. Duplicate it. Plug offset in offset.
We will then plug this guy, erosion, into erosion.
And lastly, WPL in there.
Alright, fantastic.
Now let's build a really quick particle system that shows the slash working.
Let's select this guy and delete it.
Save our little instance.
As you can see now, all our parameters have disappeared because now they are dynamic and not scalar and tweakable through this anymore.
So let's right click and create a particle system.
Let's call it p underscore slash.
open that guy up. We want a mesh. Let's select our little curve mesh right here.
Alright, now we definitely don't want 20 plus meshes, so let's go in here and turn the spawn rate to zero. And let's just spawn one mesh at a time.
There you go. I don't really want a velocity, so let's just want one and let it stay in place.
Size seems a bit too big, so yeah, that is, so let's set it to 1, 1, 1. There you go, now it spawns one.
Very good. Lifetime, it stays on a bit too long, you know, slashes are usually gone within less than a second. So let's set it to a point...
three, five. See what that does. So we have...
Okay, all right, great. Now let's drag this guy in.
Oh, wrong thing, I'm sorry. Drag our slash in.
Okay, now let us assign our... you go over here and click override material. The required tab you put your instance.
So go here.
Lock this guy in.
All right, now it's coming to life.
We see it.
Go to parameter, select dynamic.
Now you'll notice that all your values and parameter names are missing.
You right click, hit refresh.
It doesn't look like it refreshed the values, so we'll have to insert those manually.
We have 0.1 and the 0.0.0, call.
0, 0, 0, and there we go. Now we have our trail that spawns in. Spawns in way too quick.
Let's change the duration to 2. Spawns in once, we'll do twice. 2 seconds.
Now we can select our offset parameter.
Let's change that from a constant to a constant curve.
Now a constant curve will allow you to choose two points in time and their respective values as well.
So let's create, or I say two, but you can have multiple.
Let's just do two for the sake of simplicity for this example.
So at zero, I want my offset to have a value of minus one.
Now at one I want my offset to have value of one.
And now you can see it just swooshes.
Oof, there it goes.
Okay, and now what we can do is do a similar thing with the erosion.
Right now it's just traveling this entire path, but it's not like fading out.
So what we can do is go in to the erosion parameter and do the exact same thing.
Let's go into erosion, set that to curve.
grid two points for simplicity. Say at 0.3 seconds in, 0.35 seconds in, it's still full, but it slowly starts fading away the rest of the trail. So now you can see it's kind of eating up itself before it reaches the end.
We can obviously change the lifetime to be really, really slow.
So we can see this whole thing in action.
In slow-mo.
Alright, and there we have it. That is how to use dynamic parameters, how to create shader functions in Unreal Engine 4.
Alright, so guys, I will have a...
link to these project files in the chat, a few of the resources that have been very helpful for me while I was learning VFX, as well as a few resources I've mentioned throughout these slides, Simon Trumpler's blog with the UV distortion fire, and many other cool tricks if you're interested in learning how shaders can help support VFX.
their blog is a really fantastic read for that.
Shannon has a wonderful post on VFX forums on how she built different elements for the League of Legends VFX, and it is always wonderful to read through how the experts and the pros do their technique so you can learn from it and build phenomenal VFX of your own. Tobias has a blog where he talks in detail about gradient mapping if you would like to learn more on that topic. Other than that guys, the real-time VFX form is this wonderful trove of knowledge that I cannot recommend enough.
to people. They have a forum, they have a discord, they have a Facebook group even.
And if you're a student or even just starting out with real-time VFX, I highly recommend this group. You know, it is wonderful for networking, wonderful for getting the eyes of professionals in the industry, get eyes on your work and getting critiques and feedbacks and and just an all-round wonderful experience learning and becoming a VFX artist.
Other than that, I have left all my contact information on the screen. If y'all have any further questions or would like any feedback or critiques on your VFX art pieces, I'm more than happy to help. Shoot me an email and let's figure something out.
That being said, I have laid out all the wonderful and magical tools that we as VFX artists use to create VFX, and I hope with these tools in your arsenal, you can go ahead and create something wonderful and magical of your own.
Thank you so much for coming to this presentation.
Hope you all have a great summer 2021.
You