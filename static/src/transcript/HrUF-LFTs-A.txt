So I wanted to talk to you today about the journey of going from Clash of Clans to Everdale, from essentially solo game to an inherently social game.
My name's Tristan Williams.
I'm a senior programmer at Supercell.
I've been there since 2014.
Before that, I've been working at Remedy, Splash Damage, Ratbag on games such as Alan Wake, Quantum Break, and Quake Wars.
Topics today, intro.
We'll touch on the design.
I wanna dig into that a little bit, but the main meat of this topic will be the tech and some takeaways.
So in the beginning, well, you've probably all heard of Clash of Clans, but in case you haven't, we released it in 2012, and it's been effectively in the top 50 of the App Store ever since.
So we're near on 10 years now, which is just amazing.
And Everdale is one of our new software launch games released last year.
So Clash of Clans, if you haven't played it, is a village builder where you gather resources with these elixir pumps and gold mines.
You build your own defenses and armies.
And then you take your armies and attack other players' villages, steal their resources in this inverse tower defense type gameplay, and use their stolen resources to upgrade your own village and build more armies, and gain trophies by scorch up.
So this is a game that's always got one village on screen at a time, you never see multiple villages at a time.
The core gameplay is entirely solo.
In the game, there's clans, which is effectively an opt-in social layer.
You don't need to join a clan.
It will help you if you join a clan, because then you can earn more resources through clan wars, which is yet another thing that feeds back into the core loop of the game.
But your progress at your village is still entirely your own.
It's still essentially a solo experience with a social added-on layer there, which is nice.
And moving to Everdale.
So Everdale is inspired by classics like Settlers 2, one of my favorite games when I was a teenager.
So that inspired a lot of the village building gameplay where you build stuff and you get people to go chop some trees and dig up some rocks and use that for building more things.
Sims and Fallout Shelter, they were a big inspiration in terms of how we wanted the player to engage with the characters in their village.
They wanted to nurture them.
build them as part of their own village identity.
Another great inspiration was civilization.
Not so much for gameplay, but just for the sense of scale.
We wanted the game to feel bigger than any of our games before.
So here's some gameplay.
So as you can see, we've got a village builder here.
We've got Carolina here at the house.
We're gonna build another house to attract some new villagers to stay in our village.
And so we assign her a job to do, which is go work at that work site.
She'll go, oh no, I need some wood.
She'll run over to the wood storage, come back, drop off the wood, and start doing some building with some nice little critters around in the background.
Then once that's done, this is all sped up for debug purposes, pick a new villager, Gabrielle here, and here she comes to join in the village.
So there's all sorts of stuff to assign villagers to do.
collect trees, collect stone, collect clay, research at the library to make food for everybody to eat.
And we tried to make it all full of life.
But everything's related to each other, so first you have to get the trees and then you can start building the buildings.
That's not all.
Well, there's research, there's tech tree.
This'll be familiar to you if you've played games like Civilization or anything.
So you unlock from there all of the new buildings, the upgrade levels, and you get people to go and work at the library, or the study, I should say, to upgrade these things.
Cool. Then from very early in our game, the players are placed in a valley together.
So you zoom out from your village, and here you go.
Here's the valley, and you can see other players' villages right in this valley. There's no transitions.
It's seamless.
So they create one big world.
In the valley you create products.
For example, here I'm assigning a villager to go and work at the wool farm, gather some wool.
And then once we've got some wool, we can go to the tailor and make some socks.
This is a valley building.
This doesn't belong to the player, it belongs to everybody in the valley.
These are unlocked at the great library here where you together work to research new stuff for your whole valley to work on together.
And you build those together as well.
And there's this trading element.
We have orders that come in from faraway lands.
You fulfill the orders.
And from the orders, you get resources.
You get valley upgrade points.
That's just kind of fun.
Very relaxing, chill vibes.
So in Evadell, the valley is deeply linked to your village gameplay.
In the valley, you'll be upgrading your village's skills.
You'll be sending them off to a guild to train.
So that'll help you with your village gameplay, and you're also earning gold that you need for building new buildings in the valley.
So the village supports the valley, and the valley supports the village.
These two are deeply intertwined in the game design right from the very beginning.
It's not a new layer.
It's right at the core of the game.
And here we have shared progress and deep collaboration between the players.
A bit of background on our teams, the way we do things at Supercell before we go too much further, helps establish the context for the choices we've made.
So at Supercell we like to have small independent teams, as small as possible.
So this game, we actually started it back in 2016.
So it's quite a long project, but you have to understand that it was with less than six people for most of that time, and only towards the end when it was clear that we were going to move towards soft launch with this game, we started to grow the game towards 10 to 20 people ready for launch.
And at its peak, it's only had four client programmers and two server programmers working on it.
So that's the background, a bit of background.
Next, I want to talk about the dream.
Now, every creative project, whether it be at a game or a painting, a book, it starts with some kind of dream.
Even if you don't think of it that way, there's some sort of idea in your head that you want to bring out.
And these dreams, they come in all different shapes and sizes.
Could be small, they could be big, they could be medium, they could be triangle, could be square.
But here I'm gonna talk about small and big dreams.
So in my mind, how I categorize them, A small dream would be something like a cool mechanic.
Like if you played Hay Day, to harvest your crops, you don't tap them and press a button to harvest them.
You grab the scythe and you swipe your scythe through the crops, and it's a cool little mechanic.
And it could be a unique gameplay idea, like a game like Portal, where you take a first person puzzle game and you add this sweet gun that you can put a hole in one wall, a hole in the other wall, and pop between them.
Adds a whole bunch of really interesting gameplay.
It might be something like an art style.
A game that comes to mind for that would be Limbo.
So you get this, what is a classic platformer at its heart, but it's got this beautiful art style that creates a unique experience for the player.
Another one might be an interesting piece of tech, like a game I worked on many years ago, Alan Wake.
It was, the core idea of this light and shadow gameplay actually came from one of the designers seeing what one of the rendering programmers was working on.
He was working on some nice lighting tech.
He was like, oh cool, maybe we should make a game about light and dark.
So these kind of small dreams, I think of them a bit like this.
You've got the seed of an idea and you grow it into a big tree.
This is a really good way to build a game.
Often you've got clear reference material that you can build from.
You've kind of got a little twist that you're putting on an established genre, perhaps.
The real challenge here is differentiation.
How do you do something different?
But anyway, it's cool stuff.
Small dreams are great to have.
Then we've got big dreams.
And what I mean here by a big dream would be your lofty goals.
Your big dreams are more user experience and emotion driven usually.
You're thinking about how does the player feel when they play this game?
Do they feel like they're a space marine battling aliens in a galaxy far, far away?
Do they feel like they're a god playing Populous?
Or do they feel like...
a chief managing a village.
Starting from the high fantasy, what we're selling the game.
That's kind of, in some ways it's kind of the opposite.
Instead of growing from the ground up, you start from the canopy, you're looking at the tops of the trees of the forest, and then you grow down.
And you see.
what branches do we need to build to support this?
And eventually you might find the seed and it might start to grow back up again.
It can loop in all sorts of crazy ways.
And you can have both big and small dreams in a game.
So dreaming big is quite daunting.
You may not have any idea what the mechanics are gonna be yet.
You may just have this idea of like, I wanna have a game where I feel like a god.
How do you go about making that game?
There may be a lack of reference.
You may be inventing a new genre, basically.
The tech may not even exist yet.
So yeah, sounds easy, right?
Why would we do that?
Anyway, so getting back to Everdale, in the beginning, We felt like we wanted to reach a broader audience.
We wanted to make a game that was not necessarily about combat.
Now, if I could tell an anecdote about that.
It actually came a lot from me watching my wife play games like Clash of Clans and Age of Empires.
So if you play Clash of Clans, at the beginning, you've got this shield that lasts for several days.
That means that you can't be attacked.
Nobody can come and steal your stuff for the first few days that you're playing the game.
My wife installed it and she was loving it.
She was loving building her village, loving laying it out, upgrading things, having a great time.
Then a few days later, the shield dropped and she was attacked.
She logged into the game and she saw everything's crushed and she's lost a whole bunch of resources.
And she was so upset, she just uninstalled the game.
Then with Age of Empires, it's kind of similar.
She was playing the game, she loved sending people out to hunt deer and build up her town.
She was really loving that.
And then the Warhorn blew.
This is Age of Empires II that I'm referring to here, one of the old ones.
The Warhorn blew.
And once she experienced the stress of being attacked for the first time, she actually just started a new game.
And started playing another one up until the Warhorn blew.
And then she did the same thing.
Started again and played to the Warhorn Blue and then she uninstalled the game.
So that kind of raised my eyebrows and made me realize that actually, there aren't actually that many village building games that don't have combat or conflict in them in some form.
And I felt like this was actually, this was a challenge and a really interesting challenge that we should tackle.
You know, not all games have to be about fighting and sometimes, You might have, I play Everdale in between other games.
So at the moment I'm currently going back and playing Doom.
And in between some sessions of Doom, sometimes you just need to chill out, play something nice and relaxing, like a heyday or an Everdale.
Another dream we had was we wanted it to be more collaborative than anything we've made before.
And more immersive.
So we can look at this now through the lens of the dream terms that I described before.
So we've got some small dreams here.
We've got a village builder.
There's clear reference for this, but there's a bunch of really good village builders out there.
We want something nice and peaceful and relaxing.
Happy little villages, happy little deer.
Here's our big dreams.
This is the scary slide.
Game with collaboration built in at the core.
We wanted from the very beginning that you're working with other people to achieve bigger goals and what you can achieve on your own.
Wanted it to be meaningful cooperation, not just a layer on top.
We wanted it to actually mean something to the core of the game.
And we wanted to create a seamless world with multiple villages.
And as you saw from the videos before, we got there in some form.
So the dream, every game starts with some sort of dream.
It really helps if you can try to identify these early.
You might not even be conscious of what you're trying to do, but you might have a feeling in mind, a vibe that you're going for.
So try to identify these, because actually, these may form the core design pillars of your game.
And if you can write them down, then you can always refer back to those, and they'll help inform all of the decisions that you make from then on.
And especially in the case of this talk, the tech choices.
So I want to talk a little bit about what is collaboration in a game, and I'm gonna use Clash as an example here.
So here's a screenshot that I took of a offline build of Clash in the Alliance menu.
So you group up with other players.
This is what I think of as collaboration 101.
Group up with other players and you have a menu where you can see the names of the other players.
Maybe you can click on them and go visit their game states.
Maybe you can chat with them.
That's cool.
Next level above that might be.
where you've got something like clan wars, where you've got what are still essentially solo battles, but you've got some combined scoring that helps you get more points, more resources out of this.
So in clan wars, you've got the arranged battles between one clan and another clan, where you'll earn stars, get resources based on your performance, and those resources are still just yours.
They're still a solo element of the core loop.
We wanted to go for collaboration plus plus, seamless world, watching the other people play in real time, and real gameplay interaction in the real world, not just in the menus. We wanted to actually have as many of the things that you could do in the game as possible centered around some real object in the world that you scroll over to and tap.
We didn't want to have to open too many menus and do things in menus. Sometimes it's unavoidable, but we were trying to do as much as possible in the real world.
We wanted the teamwork to really mean something with shared goals between the players.
Exciting stuff. We were all pretty pumped about this idea, but also pretty scared about this idea, too, because it's a big world.
It's going to be expensive to simulate and render.
And remember, we're targeting phones here, phones and tablets, not PCs and next-gen consoles.
A game like this we knew was going to be complex to design and even more complex to test.
So we charged it in, of course.
So tech, well, in the beginning, we've got some technology that's fairly close, it's village-build technology, so we forked Clash of Clans.
Bit of background about Clash of Clans.
It's built on an in-house engine.
It's got a single village on screen at a time.
Collaboration is effectively only in menus.
and its rendering is completely 2D, sprite out of space.
These days it's not just 2D anymore, but it was completely 2D.
And what that means with the sprite atlas is, if you're not aware, is that we've got the original models in 3D, and then we render them out, the artist render them out in a whole bunch of different orientations and every different pose, and then we load those all up into the game as a pre-baked asset.
A bit more tech background is that it's a client-server architecture, as you probably expect.
The server's authoritative, and it always asserts that the client is in sync with it.
And we do that by having this chunk of code that we call logic code that we run on both the client and the server at all times.
And this code is designed to be as deterministic as possible.
In fact, it's designed to be absolutely deterministic.
We don't use any floating point values in our logic code.
So, logic state is persisted by the server automatically into the database, so you don't have to write any custom queries or transactions to the databases.
It's just all done for you.
The client and logic code, though, in Clash of Clans relied very heavily on singletons.
So, you know, you've got your game object manager, get instance, get me the game objects that are building.
shop offer manager, get the offers in the currently available to the shop.
Village, just get.
And it would just be one of everything and it was hard-coded, which is nice, it's convenient and very easy to code and obviously it's worked well for us for a very long time.
But you could only have one village running at a time.
So the first step was to break that up.
So the first step of making the multiple villages work was to break it up into the concept of contexts.
So the context would bundle all of the subsystems that the village needed to run into one class.
So you could get the context and that would effectively be a village.
It would have its own GameObjectManager, ShopOffManager, the village pointer, what is the context.
And it has some downsides.
It means that every object has to have a way of knowing what context it is in, but that's not a big deal.
So that was a fair chunk of refactoring, but it's just work.
So there was some cool benefits that came out of this though.
For example, we can now run the logic in the background as like a headless copy of the village.
We can just spawn one whenever we want, spin off a copy of the village that you've got running and do whatever we want with it in the background.
We could, for example, use it for some debug logic verification, I'll mention that.
a bit more later, we could predict it into the future.
If you've played the game, you know that it gives time estimates of how long something's going to take.
So, we can just, when a user does something that changes the world, we can just take a copy of the village and then fast forward it into the future for a long time and find out when that activity finishes.
So, the design goal actually gave us some nice technical benefits.
So then, next thing we wanted to do was achieve this seamless world.
We did that by giving each village its own rendering world, which has its own coordinate system, which means we could move it wherever we want, and it still got the same coordinate system.
So every village, like my village, your village, they all start at 0, 0 and go to whatever their maximum size is. And we had one render world for the valley, same system, just it was ...
one for the valley, the valley's buildings and all the ocean and the boats and things in it.
And the actual view we then composed by stitching together the worlds.
So each village would be rendered with an offset into the world.
And then, this was nice because When you then move to a different valley, which is unfortunate, but it's a design thing that we need to be able to cope with, we can then put that village in a different place in the new valley and everything's okay.
We don't have to do anything weird in the gameplay to update everything's position or anything like that.
So great, now we can see everything.
But back to this small dream.
The dream was to be a village builder.
We wanted to have a diverse cast of villagers from all sorts of different cultural, drawing inspiration from all sorts of different cultural backgrounds with different hair colors, different clothes.
We want them to be performing lots of different tasks.
So maybe they're carrying a hammer, maybe they're carrying a saw, an axe, or maybe they're wandering along with some logs or a pumpkin.
We also wanted to customize them.
We wanted players to be able to select what clothes each villager was wearing.
And if you think about that in the context of the 2D sprite-based content, that's a lot of permutations.
Every time we want to add a new set of clothing, we need to go on back and re-render a whole bunch of stuff.
All the different animations, any new animation just adds to the permutations.
So we made the choice to go to 3D.
But we didn't have a 3D engine.
We had some 3D rendering capabilities.
If you played Brawl Stars, if you played that during the soft launch, you may remember that it was actually a 2D background with 3D characters.
Boom Beach has some 3D background, and there's also some 3D menu elements in Clash Royale back in the day.
So we had some 3D rendering technology.
We had some pipeline, so we just built a 3D engine, a simple one, a really simple one, actually.
So we designed it.
to be as simple to use as possible, as close to our 2D engine as possible, because actually a lot of people at Supercell, a lot of programmers at Supercell don't have a 3D game background.
I did, and a few other people at the company did, from working on our console and AAA games in the past.
But yeah, it was important to make it so that people felt comfortable.
They could just jump in and start building new stuff as quickly as possible.
Another actually surprisingly tricky task was making the camera feel just as good as it did in Clash of Clans.
So if you play our games, you may not have noticed, but you certainly felt it, that it's very, very direct.
Everything matches your fingertips.
If you put your fingers on there and then scroll in and out or pan around, your fingertips will still be touching the exact same objects.
So we made it a goal to make sure that we matched that one-to-one.
And one cool thing about this engine that we built was actually it made its way back into Brawl Stars.
So Brawl Stars is now 3D.
And our other games in Softwatch at the moment are also using that same engine, and they're all 3D too.
And we now all improve the engine together.
And it gets better and better and better all the time.
So this little small dream actually ended up building a big piece of tech that benefited the company.
So, probably the real meat here is the collaboration tech.
We wanted to have these multiple players in one seamless world.
So, in the beginning we had that.
We had the multiple players in one seamless world.
And we had it so that the actions a player would do were transmitted to the other clients.
So you could see what other people were doing.
But you couldn't interact, and you couldn't yet do something together.
In your own village, this validation that you need to do is relatively simple.
On your client, if you think you can do an action, okay, cool, send it to the server.
Server can confirm, can validate when it's sent that this action is valid and apply it.
If not, all we need to do is just say, send back to the client the correct version of the village and it can just fix itself.
But when you influence shared state, it's a bit trickier.
Our other games in the past have gone about it in the way that there's manually persisted shared state, that you have a database table with the clan, and let's say that each one row per clan, let's say you've got the column for the name of the clan.
So that name is specifically written out to the database.
This was done with manual message handling and manual error resolution for every feature.
So everything you want to do in the shared world, required you to write the messages that you'd send from the client to the server to request to do it.
It would require the server handling to redirect that to the right part of the server, the right instances.
And it would need to validate it on the server side in server code and send a response back, an appropriate response that's like, yes, this change was made, no, this change wasn't made.
And the client would need to resolve that error if necessary.
So for a feature to be robust and good, you effectively needed both a client and a server programmer to handle it because well usually when us client programmers start writing database code, things go a bit wrong.
But...
But we wanted to have far more elaborate features than we've seen in our previous games.
And the previous way of doing things is kind of tedious, and we felt that it would make the development time of the game prohibitive if we were to develop the shared gameplay that way.
So we needed to improve.
So what were we gonna do?
Our first pass.
First thing we did was we added this shared logic state for the valley.
So this is the bundle of logic code and it had its own context as well.
It meant that we could now run game objects in the valley code, in the shared code as well.
And we implemented a well-defined action object, which is a class.
It was encapsulating.
play as action and its parameters, all of the validation checks necessary on every step of the way, all of the handling code for validation failure, and any rollbacks that would need to be applied.
So if you're writing a new action, you just derive from this class and implement the function, implement the interface.
As long as you implemented it correctly, it would work.
So.
How this worked in practice was it would validate the action on the client.
If the client thinks it would be okay, we'll send it to the server, the village part of the server.
So for scaling purposes, we were keeping each village separate and the values separate and communicating between them.
So the action will be sent to the village server.
If that failed, then you could respond to the client with the failure.
The client could then run the appropriate rollback code.
If it's okay, cool, send that on to the valley and let the valley server now validate.
If that failed, then you'd have to send it back to the server for the village, run some rollback code, then send that back to the client, run some more rollback code.
If it's okay, cool, just apply it and distribute that to the other clients.
So you can probably already see that this is not great.
But it had some advantages.
It was much neater and easier to see all the handling in one place.
Rather than having the whole flow of this action being spread between our client code and our server code and a whole bunch of different files along the way, instead it was all bundled together into one neat little package.
The setup that we've done meant we could share actually a lot of code between the valley and the village.
And one game programmer could now build a complete transaction without the help from a server programmer.
Which is great because server programmers, their time is usually best spent on things that they're amazing at, like balancing loads and managing databases and all this cool stuff.
Disadvantages.
Disadvantages we found were the onus was entirely on the programmer to foresee any potential failure case and implement appropriate rollback for any of these cases.
So at any of these points where that message was going through, something could happen that make it so that your action fails.
Someone else's action might have been applied first that makes yours fail.
It might just be that someone's running a hacked client perhaps.
All sorts of things like this could happen.
and you need to have appropriate rollback for all of them.
So it was still tedious, laborious, error-prone code to write.
It was actually pretty much the old way, just wrapped up in new packaging.
And all of the client and UI code would need to be written so that all edge cases can be handled with all the various bailout scenarios.
So let's say you were giving some wood to a construction project in the valley.
You'd say, okay, I've subtracted 10 wood and sent it off.
But it needs to come back and you need to get that 10 wood back again.
Or a menu might pop up and you need to get rid of the menu or change the state of the menu completely.
So often this sort of stuff is not trivial to write, and when you're dealing with a small team and you've got a lot of features you want to build and a lot of sub-features within those features, this consumes a lot of time, and it's wasted effort.
So we decided to improve this.
What we did was we adopted a resimulation-based approach.
If you've ever written any multiplayer tech before, you'd probably be familiar with.
this way of doing things where the clients run ahead of the server and kind of just assume immediately that their own actions work.
And then if something changes in their assumptions, then they rewind back and then re-predict, re-simulate again to the current time and try and do it so quickly that the client, the player never notices.
So here we changed it so that the server would be running all of the villages and the valley in each valley synchronously.
The clients will be running slightly ahead of the server, and we made it so the clients could rewind to the last known good state and re-simulate.
So the server here is validating and applying actions against the village and the whole valley at the same time.
So everything's in lockstep, moving together one step at a time.
So advantages of this, we no longer needed any error resolution or rollback required.
It was inherent in the way the system works.
we need validation and execution.
So our action class that we had defined before, the number of functions to implement drops to basically validate, validate with the village, validate with the village and the valley and execute.
This is a very robust way of doing things, because the server state is really well-defined at any point in time.
The server's got, in one instance, in one thread, it's got all of the villages in their current state all at the same tick, the valley at the same tick, and all of the actions that it's going to have to execute in the future.
In this case, as I said before, error resolution as predictions can be handled universally in most cases.
Not all the time, but.
most things can just drop out of this architecture.
I wouldn't necessarily recommend this architecture for every kind of game.
I wouldn't do it in an action game, but it's good for this sort of slow-paced game.
The disadvantages of this meant that we were going to have to store a lot more stuff in one thread and run a lot more stuff in a timely manner on the server than ever before.
and the client needs to store this history information and be able to rewind and fast forward again without the player ever noticing.
Some UI scenarios still need very careful handling.
You might have a dramatic change in state based on the misprediction.
You might have your menu up with, you know, you've selected that task to do and you've started doing it, and then suddenly you don't have that task anymore and all of that needs to be able to clean itself up.
Which actually, if you switch to more like polling style UI, a lot of these problems kind of go away.
As long as your polling UI can handle any random change in state, more like a true thin client, then it works quite well.
And we also found we need to avoid direct callbacks from logic code to client code.
In the past we've often had it so that you wanna play a sound, okay cool, there's a callback from the logic to the client and then the client plays the sound.
But now if we were to do that exact same way with resimulation, then while you're resimulating you might play that sound a whole bunch of times.
So this actually proved out to be a great success.
We were able to develop the systems that we were trying to develop much more rapidly than we could in the past.
We're talking weeks instead of months compared to the way we would have done things if we were doing them in Clash of Clans.
We only needed a single programmer per feature.
Which was really cool because I can think of one time during the project where we had a brainstorming session coming up with some cool ideas.
And we had this idea of this trade relations with different ships going out, like maintaining a relationship with different other countries.
At the same time, this other feature of challenges or events that would pop up in your land and you'd work together to resolve them.
So both of these are relatively complicated features when you dig into all of the different things there.
And we were able to do them with one programmer on each of those features, get the first versions that were ready for a proper play test in a couple of weeks.
Most of that time was actually just implementing UIs.
And well, if you've been in the games industry for any length of time, you know by now that iteration time is key, especially if you've got a small team like ours, where at the time, I think we only had three client programmers on the game, and one of them was focusing on rendering technology.
It's really important to keep up that momentum and test out the new features as fast as possible.
Fail fast.
All right.
He's so cute.
So performance, we've got a problem here.
We've got 10 villages, and we're gonna have hundreds of thousands of objects per village.
In fact, I was just debugging one village the other day which had 2,565 decorations in it.
We've got this complex flow-based logic where you can't just fast-forward a timer, like many of our other games.
Instead, you have to wait for one worker to bring something to the storage and the other worker to come and get it.
That whole process needs to go through.
So performance was definitely going to be an issue.
So for rendering, we chose to actually render our villages to texture imposters, so we loaded the whole village.
rather than trying to load the sub-objects in the village, instead just load the whole village.
As you zoom out, swap to rendering it to a Texture, and then stagger the imposter updates.
Because once you've zoomed out, especially on a phone screen, those villages are now so small on the screen that that one little villager walking around, we're talking sub-pixel changes here.
So we can easily just make it so that we only render one village at a time, one village per frame to a Texture.
and maintain the illusion that we're running all of the villages all of the time.
And then we made a lot of effort to make it so a near seamless transition between them.
Here's a video of that taking place. So here I'm zooming out from my village.
and zooming into another village.
If you know what to look for, you can spot it.
You can see the grass change shade a little bit there.
Still some more work to do to make that really, really good.
But you also see these objects that are scaling up and down, and that's actually nothing to do with this transition.
That's actually to do with, we felt that when we were drawing them as the normal scale of objects, but when we zoomed out, it looked too noisy.
It just didn't look quite right, so we went for this more iconified version of the village as you zoom out.
So what about logic optimization?
Obviously, we're running a lot of villages at once on the server, and we need to be able to rerun the logic quite often on the client.
So our gameplay is relatively slow.
So we found that we could actually reduce our logic tick rate from 25 hertz to five hertz and the player wouldn't notice any difference at all.
Of course.
Response time is definitely an issue there, where if you initiate an action, you might get up to 200 milliseconds of latency before the action actually starts to happen.
So to get rid of that, basically the client just, as soon as you've done an action, just jump ahead in time to the next tick, and then that extra that you've accumulated, just ease it out over a few frames, and long enough that you don't really notice the speeding up and slowing down of the gameplay, but it still maintains the illusion that your actions are happening immediately.
made the client interpolate logical state as necessary.
And that worked pretty well.
It's 1 1 5th already.
So then we moved to trying to ensure that our update functions could be deterministic with a variable update length.
So we could update the world tick by tick for 30 ticks.
We go tick, tick, tick, tick, tick, tick, tick, and that would be your state at the end.
Or we could update 30 ticks in one update call, update 30 instead of update one.
And here we want to make sure that our state at the end with update 30 is exactly the same as the state if you go tick by tick.
Now we probably do this a little bit differently if we were to be doing this from the very beginning, but this was a retrofit system, so we already had a lot of code, so we had to make the choice of doing it a little bit differently.
So what we did was we allowed any object or system to declare how many ticks that they can update for, deterministically.
We call this the max fast forward ticks.
we found that many objects can actually just skip their updates for multiple seconds at a time, so even up to hundreds of ticks, they could just fast-forward over that whole thing, one function call, update.
We had to reorganize some of our things like pathfinding and villager movement so that that wasn't a tick-by-tick update, instead it was just jump forward in time.
So we made it so the client would step tick-by-tick to maintain the smooth gameplay, and the server could fast-forward villages forward.
And this was really awesome.
I mean, this is a conservative number here, but it actually reduced server load by something like 80 to 90%.
And here we're talking about, compared to like a Clash of Clans village.
So even though we're running 10 villages at once, we're still like 1 10th the cost on server side of running a single Clash of Clans village.
It also let us do things like, The off-screen villages on the client, we could just not update them or update them less often and just fast-forward them up, which was a really good speed improvement on the client.
But of course, you might ask, how do we guarantee that everything is going to be deterministic?
So we can then take advantage of this ability to run a background copy of the village.
So we can run background verification.
load up an older version of the village, fast forward it to now from that older state, and then compare to now, and assert that they're the same.
If they're not, we can save an error trace, a JSON file with the last known good state, and then we can then load that up into a debug client, run it forward, and repeat over and over again the situation that's not deterministic, and find a way to fix it.
And servers, debug servers can also save traces out when these situations are detected.
So when we're testing, we can catch any really weird cases.
So with guaranteed determinism and decoupled logic execution.
We can do all sorts of cool stuff, like store replay traces for bug testing.
We can do regression testing where we just download all of the villages from the database and simulate them before and after any big system changes and assert that we have the same results.
Say, change pathfinding.
We still want the results to be comparable.
And all sorts of other systems can be validated in background threads while playing.
We also built AI logic that can play the game.
At first, that was just on the client side to simulate when you've got other players in the game with you.
But actually, we then realized, oh, yeah, we could actually just port this over to our logic code base, and we could also port our client synchronization logic over to the logic code base, too, and then we could just make server code that can connect to a load test environment and play the game, spawn thousands of bots, and gather a bunch of balance and stability data for us.
This was actually really useful for isolating some of these really rare bugs you get sometimes with these games.
And a real help because it was a very complex game with many, many systems that all work together.
So in the result, we achieved our dreams, mostly.
The game is now in soft launch.
We'll see what the future holds, but even if it doesn't make it to global, the tech will live on. So key takeaways here.
Dream big, but go in with your eyes open.
It's not necessarily going to be easy to achieve these big dreams, but you can achieve them, and you may get all sorts of side benefits along the way, technical improvements.
We've got better tools for our future games.
Investment in new tech usually does pay off.
So, yeah.
Hopefully, this talk has inspired you to maybe tackle your own lofty game design goals.
Dream big.
I want to see some cool games out there.
Thanks for coming.
Please remember to give the feedback, we're hiring.
Any questions?
Thank you.
You were talking about this discussion you guys had about the trading systems in which you like, you know, the trading systems, where you're talking about like the developers went off and they worked on one feature each, et cetera, right?
Were the developers directly involved in that conversation in terms of the design itself?
Oh yeah, absolutely.
Every step of the way.
When you're working with a small team, like having that kind of level of buy-in and everybody being involved with as many of the things that they work on as possible, it's like, it just saves so much time.
It's for motivation.
Absolutely, yeah.
Thank you.
Yeah, thank you.
Hey Tristan.
Hey.
A question on the zooming.
You were talking about how you did a lot of different approaches to the zooming.
How did you?
think about what size was too small and too large and when to do the swapping because that's a problem and you know it looks really good on the big screen but how do you approach that with the variety of screen sizes that you're dealing with on your game.
We tried a whole lot of different screen sizes.
Lots of experimentation.
We tried many different iterations, and I think there's probably still iterating, the artists are probably still iterating on those, you know, scaling up and scaling down things I was showing.
It's a constant process, but, you know, it's, everything can always be improved.
Lots of iteration, like you're talking, just a lot of play testing just to get that feel.
Lots of play testing to get that feel right.
Yeah, absolutely.
And everyone on the team is playing the game, so, like, it's, it's, You get the build out and everyone's like, oh yeah, that looks pretty good.
Gives feedback to the guy.
Off you go, try again.
Thank you.
No problem.
When working on something that was so experimental for so long, how did you balance between iterations for the experimental stuff and just play it with such a small team, just plain old housekeeping, keeping APIs up to date, all the stuff you need to make sure you don't get kicked off the Play Store.
Yeah, fantastic question. Yeah, I'd like to say that we have a silver bullet for that, but it's just using some common sense and usually if you've got a good bunch of developers that are really close to the game and know what's going around them, they usually make good decisions without actually needing sort of any...
any overarching philosophy to be applied.
It's kind of, we have a bit of a saying in the company of like, supercell first.
Or we have had that.
So sort of like, make a decision that's gonna be good for the company and not necessarily good for my, getting my jollies by doing another iteration and something, cause I'd be really cool if I did that.
But like, actually, does that really add something?
Am I really adding value here?
Just a different question.
In terms of determinism, how did you guarantee that across all devices and all different CPU architectures that the same code would result in the exact same result?
Yeah, it's a great question.
And actually, it's even more complicated than that because our servers are Java, and our clients are C++.
So we actually do it all in fixed point.
No floating points allowed in logic code.
No floating points allowed.
So once you're in fixed point, there's There are some really interesting edge cases in fixed point overflows, especially we found a few new ones with the M1, the new M1 CPUs that we had to manually figure out in some of our core libraries, but yeah.
Because of the tablet, not because of the laptop.
The laptop, actually.
It plays on the laptop?
Yeah, the M1s you've used in the iOS, they handle a certain kind of overflow slightly differently.
Okay.
Because it's like undefined in C++, that particular behavior.
So fixed point mostly solves the issue?
Fixed point, yep.
Thank you.
And when you're testing it on your computers, so you log the state to replay it if a player reported it or, you know, it automatically logged it, and on your computers it runs the exact same?
Yep, absolutely.
Thank you.
Yep.
No problem.
Ask a quick question.
So when you were talking about the server architecture, you talked about how you re-architected it a couple of times.
On the client side, it also sounds like you guys did several refactors.
How do you guys think about that in your planning process?
Because at the same time you're talking about building out prototypes very quickly in like a one week turnaround.
And how do you balance what needs to get built out quickly versus when something needs to be refactored?
Because it feels like, at least from my experience, a lot of time refactoring gets cut because it's not necessary to ship it does help the product, but.
Just want to hear your thought process on that.
Yeah, that's a really good question.
Again, I don't have a silver bullet for that one.
I have a personal philosophy on that one, that once I'm copying and pasting a bit of code more than three times, or three times or more, I start to refactor to combine them.
And then it comes down to a lot of just thinking about what's right.
Actually, some of the refactoring, like for example, the second pass on the way the actions worked for the shared logic, was probably twiddled my thumbs about it a bit too long before I started on that.
I wish I had done it sooner, because I kind of like, it was bugging me that this is still tedious, this is annoying to do this stuff, and then eventually bit the bullet, like, okay.
Scrap this, re-architect the server a bit, so there's a re-simulation instead.
And it was a bit of effort.
It was quite a lot of effort, but it totally paid off.
So we should have just done it earlier that way.
So it's a, it's an experience thing.
So when you go to your producer there and you're like, oh man, I have not refactored this.
I need to do this. It's going to take it. You may sound like a big effort, right?
So it also, you come into your producer and saying, oh man, I need to refactor this.
It may take another month, two months.
How do you work with that on the rest of the schedule?
Do you just say the schedule keeps pushing based off of that or do you guys look for trade-offs there?
Well, our producers are so close to the game, they kind of see a lot of these difficulties and they kind of see that this feature is going to take a long time.
So it's kind of a matter of making that case of like, okay, this might take a couple of months, but it's going to mean that we can iterate so much faster on our features.
And it's not everybody in the team that's stopped by this.
It's kind of maybe my work.
on the other things, slowed down for that time, and then the system was completed.
I did the migration for the other guys on all the work that they were continuing to do while I was working on this in a branch, and started moving on with the new tech.
So it comes down to helping your producer understand the trade-offs, and trying to be realistic with yourself about what the trade-offs are going to be, and trying to make good estimates.
Thank you.
Yeah, thank you.
Hi. So I was thinking about what you said at the beginning, dreaming big about a game that is not necessarily about combat and more inclusive and avoiding the frustration moments of seeing your base smashed in Clash of Clans.
Yep.
And I'm an avid player of Clash of Clans and I'm playing in Legends League now.
Sweet.
The most competitive league and I never see any more of my base smashed and I never lose any more resources. So it kind of looks like backwards, right? Like...
Did you guys consider having this kind of behavior at the beginning of the game to avoid the frustration of seeing your base smashed while pushing it more in the more competitive phase of the game and in the end in the Legends League?
Yeah, that's a really good question.
And we definitely talk about things like that.
And we have talked about things like that.
Like, oh, should we have a competitive end game for the game or something like that?
And that's all still quite open.
It's still pretty early days for the game.
And maybe that'll happen someday.
Not sure yet.
But actually, very early on, I had this extra dream, which is one of the ones that didn't quite get realized, which is that maybe it's kind of, maybe both can coexist in the same world.
People that are into combat and people that aren't, and that they all help each other still.
Maybe one day we'll have something like that, but yeah, cool question.
And congrats on Legends League, that's awesome.
My question was actually quite similar because most of the other games are competitive games So it's just like have you learned something from the players playing it so far?
And do they fall off because there's not like a good game loop there or what have you learned from so far?
It seems to really resonate so far.
It seems like there's a lot of people that have been hanging out for a game like this, where you're just taking care, nurturing, taking care of your village without having too many worries.
It's quite amazing the feedback we've been getting from it.
I mean, the people who...
One big surprise was that we actually kind of expected to find quite a different audience, like quite a different category of people.
But surprisingly, there's heaps of people who love to play Clash that also love to play Everdale, precisely because of it being just chill, which is kind of cool.
And if you really dig into it, there's actually, you can open up graphs and see what your resources are doing.
So if you want to, you can actually play it in a really hardcore way.
I wouldn't recommend it.
I did that for a little while and it drove me a bit crazy, but.
Have you seen if there is like more girls playing it or even different types of players?
We expected it to be a bit more female dominated audience, but it's actually pretty, it's pretty even.
It's it's been really nice to see the figures about that sort of stuff.
But as I said, it's still early days.
It'll be interesting to see what happens.
Hopefully we can bring it to the US market as well and see what happens here too.
Thanks.
Hi, you talked about you had this big dream about designing a new type of game.
And we know humans are kind of unpredictable, so since launching the game, did you guys see any strange behavior that players tend to do that diverge from the way the game was intended to be played? Diverge from the way the game was intended to be played?
Yes, we did actually. We didn't expect to see so many people wanting to play the kind of social side, how to put it, kind of the administration of the social side so differently than we expected.
So you may not be aware, but we had the game in a soft, soft launch under a different name.
before and the players from that kind of behaved quite differently.
And as soon as we put it to soft launch with our brand on it, we were a little bit surprised by how they behaved.
And it was really cool, it was a wake-up call that our assumptions were incorrect in a few places.
And actually, we'll have a new update out soon, which will hopefully help for people that are frustrated by the way that side of the gameplay works.
So yeah, that's a good question.
Thanks.
No one else has.
Go ahead.
In your takeaways, you mentioned that it may not result in a global launch.
And I'm just trying to decipher the reasons for that.
One assumption I could maybe make is because it's not as combat focused, more chill.
People don't go as intensely, don't spend as intensely.
Well, perhaps I just worded it wrong.
Soft launch for us is like this kind of partially proving ground, partially like a maturing ground.
And we just get the game out there and try it with real players and see how they really act.
And we learn lessons. Like we found that some of our assumptions about the way people play the game are completely wrong.
So, I wouldn't want to comment on the likelihood either way, but we're just gathering data.
You never know.
Sometimes we kill them, sometimes we...
And the killing decision always comes from within the team.
Like, do we still believe that we can make this into a game worthy of supporting for 10 plus years, like our other games?
So...
Yeah, I wasn't trying to imply that it's not going to go global, just that we'll see.
We'll see what happens.
Okay.
Sorry, just on that point, do you feel like making it more chill while maybe appealing to a broader audience or maybe a different market made it tough to have like extremely dedicated, extremely hardcore players?
No, the players are crazy.
It's amazing, I love the response we've had, it's insane.
It's really cool.
I think it's just different games for different kinds of people.
Some people like to chill, some people like it hardcore.
Okay, thank you very much.
Yeah, no worries.
So Clash of Clans, obviously, competitive game.
So you've got like a leaderboard where players are playing against each other.
So when you like monetize a game like that, it's a little bit easier since you've got like sort of a little bit more competitive aspect to it going on.
So how would that factor into Fidel?
Yeah, I mean we're still learning.
Okay.
We're still learning what's the best way to monetize games like this.
It's always a surprise.
You try things and they don't always go the way you think and you adapt, learn from them, try something else.
Ongoing process.
Yeah.
I think we have time for maybe one more.
I've noticed that with a lot of these social features, people like to form groups and communicate with their groups on strategy on places like Discord or Facebook or Reddit.
Have you thought about maybe making a first party tool for that or integrating something more officially with Supercell?
Yeah, I mean, there's a lot of ideas floating around always.
All these sorts of things pop up from time to time.
We'll see what happens.
Yeah, it's very cool.
I can't believe some of the stuff you see.
If you ever watch how people play Clash of Clans competitively at the top level, they've got like their painting overlays and everything.
It's amazing.
Super cool stuff.
Anyway, thank you very much.
And just come and talk with me if you've got some more questions.
