Hello. Thanks so much for coming. This is the second tech tool box for those of you who weren't here last year. What we try to do here is you know when you make video games? I hope that's a thing that sounds familiar. And you end up having this recurring problem that is just really tedious and maybe you write some code or you make a little tool or you make a little app that overcomes that problem.
post mortems and how did you do this. I always have to go.
this tedious thing or I never thought about solving a problem that way. And often for most games there never will be a postmortem and for most of those tools they'll never see the light of day. That's why we put this session together and we did an open call for just like what's the thing that you made basically for yourself? What interesting problems did you solve or did you solve them in an interesting way? So it's basically interesting solutions or interesting problems. We have five speakers today. They get about ten minutes each.
The first one is Evan Todd who is going to talk to us about his system for node based dialogue trees. Let's give him a applause.
Applause. Thank you.
Thank you.
I'm nobody. But thank you for coming out.
and I'm a poor man. And this is the poor man's dialogue tree.
How to make a dialogue tree if you don't have any money. So essentially I'm here for talking about dialogue, but I'm really here to sell you on my development philosophy and to get you to convert to it. It's this very powerful paradigm that is so powerful that it actually extends beyond game development into other aspects of life. In fact, it actually saved my parents' marriage. It's that powerful.
I'm just kidding, they're still divorced. Okay. So I'm going to talk about the right way to do things, which is, all right, I need a dialogue tree. I'll go to the unity asset store. I'll buy an asset and I'll kind of Frankenstein patch it into my project. And this is, I am not a big fan of this because it's expensive probably. It's third party so it's designed to do a lot of things for a lot of people. It's not exactly what you need. And crucially it's boring because, I don't know, you're letting other people do your job for you and it's fun to make stuff. So the poor man's way is to write your own to get 80% of the solution for 20% of the work and you get exactly what you need. So.
This is the poor man's dialogue tree. What I needed was an editor that I could create a node based system to hook dialogue nodes together and everything. The right way to do this would be write it in the same language as your game. Make a really nice Windows form application with all this stuff.
It would be performant. It would have the same code base as your game and everything.
but that takes a lot of work so I did it the poor man's way which was HTML5. Cross platform, easy to do, performance I don't really care about because it's just a tool for creating things so it doesn't have to run super fast. JavaScript has so many libraries it's insane. And everyone speaks JSON so you have a really easy to read format coming out of HTML5. So this is what I came up with.
I call it dialogger. And it's just a, there's a library called joint JS that I used for the fancy node sort of connecting things. It's really easy to set up. And you can see this is actually running in its own little application. It's not actually running in a browser. I use something called NW.JS for that, which is, it's really simple. You just take all your JavaScript stuff, zip it up and rename it to.
like a dot NW file, I think, and then you dump it into the NWJS folder and it turns it into an application. It's the easiest thing in the world to make a completely fake desktop application that feels like a real thing, but it's totally not a real thing. Yeah, so joint JS is great for making diagrams and graphs and things like, shoot, what's that called?
Anyway, for connecting things together, NWJS is great for stand alone apps. You have the full node APIs as well. So any kind of file access, networking, you get access to all that. The whole thing was 700 lines of JavaScript. So it was very small, easy to write. And it's very extensible, too. You can add widgets to nodes and things very easy with HTML.
So the way it works is I have three different types of files.
So there's a .dl file which is JSON and it's the full 2D layout of all the nodes and all the properties and things that you need. And then .dlz is the same JSON but it's just what I need for parsing a dialogue tree in the game. So it's kind of optimized. And then I use actually Excel files for the actual strings. So if you look, I'm going to show you a There we go. These are kind of like IDs. They're not actual dialogue. So what I do is I have an Excel file with all these IDs in one column and then the actual strings in another column. Why do I use Excel? It's because it's really when you're a poor man and you have no money and you don't want to pay anyone to translate your game.
You often have to do with fan translations and if you ship your strings in Excel and people will come to you and be like, hey, I want to translate your game, how do I do that? And it's really nice to be able to say, oh, it's just an Excel file, open it up and just change it yourself and then send me the Excel file. Like I said, this is my, one of my Excel files and people were just like, hey, can I add Hungarian? I'm like, whatever, just add another column. It's super easy. So TLDR, do it yourself. It's more fun that way. I'm sorry this wasn't very technical. If you are interested in dialogue trees and how to do all this stuff, it is on GitHub. There's also an article I wrote about it on my website if you want to see the exact details of how everything works and everything.
But we only have nine minutes. Thank you.
So thanks, Evan. Next up we have Kir, who worked on darkest dungeon and he's going to talk to us about how they did the data implementation for that game.
So hi, my name is Kier Meyer and I'm a programmer on darkest dungeon and today I'll be talking about automating data implementation with IDs. Over this talk I'm going to be talking about a short bit about syntax, a little bit about generating using IDs, referencing IDs, how we use the file system hierarchy to automate data implementation, linking code data to file data and automatically generating data. So a little bit about darkest dungeon, it's a term based RPG that's...
about dealing with the challenges of stress. A lot of the content is procedural so we're dealing with a lot of data that can be hooked up in many different ways. It's on many platforms as well as mostly a two person programming team and was made in C++11 with custom engine and a fair amount of middleware.
syntax about the talk. I'm going to refer to a lot of things as classes. That's just stuff that's not going to change while the game is running. So example of that is we have a jester that's a hero class and he has a max HP of 35. He has a skill called inspiring tune and his battle ballad is a ranged attack.
Another thing about syntax, because I'm going to be talking about IDs, a lot of the talk is going to be about, we'd be using string formats of inserting strings into other strings, numbers into strings. So instead of using the traditional string format code, I'm going to use a bold and square bracket syntax, which will make a lot more sense when I show you an example of it. So one great way of using IDs is when stuff is missing or there's an error or something is invalid. We use IDs a lot for validation messages, because we'd be just hooking up data.
programmers and having the content come in afterwards.
Missing audio message IDs or missing IDs of objects that don't have the appropriate data like if a skill was missing in effect. String formats are really useful for generating file paths.
when you have new IDs coming in, then new file paths are generated and your data will be hooked up. The one thing about this is you need to have those error messages like I showed before or be able to handle data being missing. So example of this is our resistances. We have eight resistances in the game that a hero or monster can have. And whenever we add a resistance ID, we generate a file path based on that ID. That made whenever we added a new one, that would automatically show up in the UI, that would automatically have an icon associated with it as well as value for the hero and like a localization name. So we can grab all those using those resistance IDs. Another useful thing we do with IDs is separate files into different folders. So we have items in the game and items are associated with types and IDs. So we're able to put all the trinkets in a trinkets folder and all the gems in a gem folder and automatically hook up all these icons because I didn't really want to spend the time of going through and saying, well, the lucky dice should use the lucky dice icon. Another thing that's useful is you can break up your files into a ‑‑ you can break up your data into multiple files using IDs. So we have an art file and an info file for every hero and they They were worked on by two different people with two completely different pipelines. Using the IDs we grabbed for a given hero class we could link the art file and the info file which I mostly designed it. Another useful thing about IDs is it makes sharing logic between multiple things very easy. So on the left we have a buff class which is referenced by ID by two different trinkets. So if that buff class did change and maybe instead of increase its attack rating that would reflect in both trinkets.
When you're using IDs, you can also reference shared IDs. So what we have here is we have our colors in the game. Notable, harmful and neutral are all defined with RGBA values. And then the four underneath, which are all part of the game over screen, they all reference, they're all, when the neutral, notable and harmful change, then the game over colors would change as well. This also helps with hooking stuff up because we can hook up these colors and then.
them to something and have art come in afterwards and fine tune all the different colors. Another useful thing when dealing with ID is you can generate the types of classes while parsing different types of classes. So for example, all the trinkets in dark extension are items. So whenever we parse the trinket class, which we have hundreds of, we automatically generate all the data that would be consistent for the item portion of the logic. We use the file system hierarchy to parse.
parse a lot of the, to generate these IDs. So we can go through the folders and grab the associated names of the folders and use those as our IDs to then hook up data with. So for example, every folder in data heroes is one of our hero classes and every folder in data monsters is a monster class. So we just create a new folder and the base assets to be able to create a new monster in the game.
we use regular expressions to grab the string we needed out of the folder path. So for instance the data monsters bloated corpse, data monsters swine attire and data monsters unclean giant would all become there. That's how we grab their IDs for those monsters. One other useful thing we did with IDs is we linked code data to file data. And this technique uses preprocessor macros and enums as well. And what it does is it links the declaration of enums to IDs and other constant data.
enums are very useful in code as most of you know. The IDs are great for parsing data files. First I'm going to show the unlinked method. This is what we accomplish with the linked method I'll show afterwards. But with just an example enum and array of strings, the have to be kept the same size. They can have spelling inconsistencies. If you mess up spelling, you might not catch that at compile time if it's in the string data. So the way we linked it is by using macros. We'd have nested macros that when we declare an enum, we'd go through and create enums associated with those IDs defined at the top. So whenever we added something to number types declare, that would create a string ID. This is great because they would always be in sync and they would always have, the spelling would always be consistent between the two of them. We use that for our options in the game. So, we have a string ID, we have a string each option in the game could have multiple constants linked to it. They only mattered in code. So stuff like how exactly a graphics option would work and whether that would require a reset was a code decision so the data would be kept in code. And then we'd access those through functions that took enums in. So we'd always know that we'd have the data associated with it because that's how you declared the data and we'd access them through different functions to grab that.
So that was very useful for automatically generating data.
Our save load is JSON based and our analytics data is JSON based. And parsing consists of going through that enum, grabbing the linked IDs and creating JSON dictionaries. So to the left is the save file for our option file and to the right is the code for restore loading that save file, which basically consists of going through each option, grabbing the associated ID, parsing the JSON. So whenever we added an option in the, oh, whenever we added an option, it would automatically be saved and restored. We also used it for our analytics data. So we would be posting our options, analytics data to, of what profile options different heroes would have. So when we added a new option, that would also show up in the analytics data because we're just going through every option, grabbing the appropriate ones we want to post the analytics data and then posting it using the ID we linked with the, you know, and as an outro, thanks to Red X Studios for working with me on Darkest Dungeon. Thanks to Power Up Audio for doing a great job on sound and Pierre Tardif and Calvin McBell, the other programmers. And that's my Twitter and e-mail and I'll put examples of the source I showed on my website when I return home. Thank you.
Thank you.
Thanks Gary.
I always find it really interesting when people do stuff that feels really counterintuitive like using file structures for actual logic. But it's really cool to see that you, you know, was the right solution for your project. So next up we have Kate Compton who wrote a tool called Tracery to generate text like orkish insults and things like that.
So I hope, yeah. Give it up for Kate.
Hi, everyone. I'm Kate Compton. I'm galaxy Kate at all the things that matter. And, yeah, this is my Twitter handle. You might know me because I made the planets on Spore or I was one of many people who made the planets on Spore. I did some fire stuff on Sim City. Then I got bored and I went back to grad school to get a Ph.D.
So now I'm at the UCSC expressive intelligence studio which uses AI to make art and weirdness and occasionally games.
And basically I'm getting a PhD in doing PCG.
So that's where this comes from.
Ghost logs, oh sorry, ghost logs, there we go.
So Trace raised the story of how I thought I was making a little text generation toy and it accidentally turned into a language.
And then Twitter bots happened.
So this is, oh let's see.
I don't have my timer up here. This is intended as a super easy tool. This is to keep myself from having to do a pencil and paper assignment that I had been given. I wrote a JavaScript program to do it instead. What it is, this is the minimal version of tracery on the left. Or of a tracery program on the left. And then I'm going to be super pissed if none of my gifts work. All right.
that's sad. Anyway, there's generated text on the right of game, generating bad game pitches and printing them to the screen. So let's see. It's, so, it's a, it's a, it's a, it's a you have, you import tracery. Then you have your little JSON object that describes your grammar. So this is basically the recipe for how to generate whatever it is that I'm generating. In this case, bad game pitches. You can add modifiers if you want. And then you're pretty much ready to make content. Now you hit go and you make a bunch of content. So that's it. The language itself is very simple. It's just using a hashtag syntax to do grammar generation. So here's hello world. So origin is the string greetings world and then because greetings is hashed in hashtags it'll go and Paste in one of the greetings options and that does it recursively so you can go down as far as you want You recursively define symbols. You can use modifiers to change text like do pluralizations do proper a and variations if anybody's done text generation, you know that that stuff is like the absolute devil is like getting all of the proper English syntax. And you can also store and reuse generated text. So if you generate a main character name, you can reuse that over and over again.
So basically what it does is it does text generation.
And it does text generation in a way that's really easy to program.
So this was a dress generator that I made in response to the dress controversy.
I made this in 40 minutes, which meant that I was only 10 minutes late to catch the dress coolness.
But yeah, it generates, you hit the little button and it will generate dress descriptions forever.
But TLDR, tracery is really easy to use, especially if you're in JavaScript.
And people wrote all sorts of nice things about how easy it was to use and how it got them back into programming.
So I put that up online and somebody took it, George Buckingham, and he made this tool called Cheap Bots Done Quick, which because tracery grammars are a JSON object, he was able to run a node server that you would paste your little JSON object in, log in with Twitter, and he would make you a Twitter bot.
So anybody who could type in a five line grammar about making Pokemon insults could have a Twitter bot running every five minutes or so. And people did. We have about 600 of these running currently. Every so often he tells me how many of them are going. Here are a couple of my personal favorites.
There's a hipster cocktail generator, a compliment generator, something that does Mexican literary theory.
think piece generator, et cetera. And then somebody realized, hey, emojis are just another form of text. So we can do emoji generators. So they made emoji Twitter bots. And this was pretty cool. And then somebody posted on Twitter this strange thing. This is a tool that I had made an online visual editor for tracery that people were.
were enjoying. He said, hey, look what I got it to do. Turns out SVG is just another form of text. If you have an HTML page, it will parse that as an SVG object. So suddenly it could make graphics. This weird little thing I made to make Roman comedies was making graphics.
So George went back and we updated Tracer a little bit so now I can make graphics Twitter bots. So there's a tartan generator and circle party and a little one I made to do spaceships and a gorgeous one George made to do soft focus landscapes. So yeah, Twitter bots. But this is the indie game summit so I should talk a little bit about games. You can still use it in JavaScript games. People have ported it to Ruby, Python, twine. A couple people are working on Unity. I don't know how well that will go.
My friend has used it in a number of their games and used it to generate text, boring conversation at dinner parties, surreal greeting rituals for greeting your beloved companions, so like gaze cordially into your partner's secrets and clearing your mind of judgment, say yo.
Oh, there we go.
Okay.
I just have to press go and then it does the GIF.
And then I'm doing some experiments with less experimental games as well.
Like how could you actually use this in other forms of games?
And so this one on the right is a very simple simulator for a hipster restaurant.
And it generates weird hipster recipes.
You can run your hipster restaurant, and every time kale becomes trendy, you can fill your restaurant with like kale pizza, and kale ice cream, and kale soda.
And this is my experiment.
Can I use generated text to make something that is incredibly drab become infinitely replayable?
And so far it seems like yes.
This is one that is making the world's dumbest finite state machine dating sim, dressing that up with procedural text, and it makes regrettable romances, such as cybernetic cuttlefishes.
But yeah, I would love to see people in this room using it for other things that they might want to generate in the game.
So everything in this GIF is being generated by tracery.
The descriptions of the people in the spaceship, the name of the spaceship, and the spaceship itself.
Don't know what else it could be used for.
I've also done some other weird things because anything you can represent as text, you can kind of do with this. And so SVG and web pages as we've seen. Music, there's something called ABC notation which is a text based music format. So I've done a little bit of music generation which is hampered by the fact that I'm dreadful at music. But perhaps someone else could try.
Level layouts, turns out it can make code. Did you know that JavaScript programs can be represented as a text string and then you can put them through eval for risky, risky fun.
It's a good idea. Have your users run that on your server.
But now I have something that can generate programs and can like evolve them on the fly. That could be weird for something. I don't really know what this is for yet. But long story short, this has been yet another example of I'm not quite sure what this accidental little language can do. But I wouldn't have known what it could do without all the users who showed me what it could do. So here are some of just many, many users who have showed me new things that this thing could be.
I just wanted to have a slide that thanks them.
So finally I brought a stack of zines that will teach you how to use tracery.
You can check out tracery.io where I have a whole bunch of links.
It's free and open source.
There's a GitHub link.
Feel free to contact me.
Any questions?
I didn't have a timer so I have no idea how long it took.
Oh, all right.
In that case, cool.
Thank you.
Yes, happy accidents. Next up we have Alan Hazelden who made a game called A Good Snowman is Hard to Build. And he will talk about using puzzle script for level design for that game. Give it up for Alan.
Hi there. So I'm Alan Hazelden. I made a game called Sokobond, a game called A Good Snare Man is Hard to Build. They're both thinky puzzle games that are really hard. If you've played them, maybe you think they're okay. I don't know. But I'm not going to be talking about like puzzle design, I'm going to be talking about the tools we made the levels with.
So most games need a level editor, not just puzzle games.
And generally there's two ways you can go. You can have an external editor, maybe there's a default one.
and it's kind of generic for making 3D models or whatever.
And you'll make a level and then you'll embed it into the game and you'll go, okay, well, run this. Oh, this doesn't quite work. So you go back to the level editor and you go, okay, maybe I'll switch these things around.
and then you go, okay, well I need to re-import it into the game and back and forth and back and forth.
And that can be a bit slow and tedious.
So sometimes you might have a built-in level editor to the game.
You go, okay, here's my level, just hit a key to go into edit mode, like what happens if I try that?
Okay, hit a key, go into test mode.
Oh no, that's not possible because I put this thing here.
Oh, but I need this thing to be here because of this thing.
And it's kind of like, oh.
good to be able to rapidly test like edit, test, edit, test.
But the downside with a built-in editor is you have to make it yourself.
And that can mean it's not as high quality as a tool that somebody else has written.
Or it can mean like you've got editor code.
like seeping into your game logic and weird bugs come up where oh yeah this will work except when you actually make a normal build and oh it's assuming there's an editor attached.
So those are kind of the two ways that people normally do things. What we did for a good snowman is hard to build is kind of flip this idea on its head and we embedded the game in the level editor.
which is not really the way you normally do things.
But it kind of works for us, and the reason it worked for us is because of a tool called PuzzleScript, which is a thing that was made by Stephen Lovell.
who's the creator of English Country Tune, the upcoming Stephen's Sausage Roll, and literally hundreds and hundreds and hundreds of small games that he's been releasing for free over the last 10 years. He's ridiculously prolific. He makes amazing games. And in the middle of it, he just decided to make a tool so that other people could easily make tools. Just like, no biggie. He just does it.
So it's a tool for making 2D tile-based puzzle games primarily.
You can kind of push it around to do things it's not really designed to do, but that's like the core focus and it does that incredibly well.
And then if you want to play around and break things, then yeah, see what can be stretched to do.
It's a web-based tool.
It doesn't require any programming history.
So it's super accessible, super easy to get running.
So, yeah.
So, to talk about how we use PuzzleScript, first I'm going to show you the game that we used it with.
So, this is a game called A Good Snowman is Hard to Build.
It's a puzzle game about being a monster and making snowmen.
So you can see you've got this monster here.
He's just walking around the world.
Obviously he can push snowballs around.
And a snowman that you're trying to make is the canonical snowman, which is three balls, a large, a medium, and a small.
No other snowballs are valid.
You push them around, and obviously the large one has to be on the bottom, the medium one has to be in the middle, and the top one has to go top.
And so we just made Lucy here.
So there we go, that was a snowman that we just built.
And obviously you can hug the snowman, because...
what's even the point of making a snowman if you can't go on to hug it?
And so the other thing you've got if you've got snow is you've got snow in the snowballs, you've also got snow on the ground, then if you push a snowball onto a patch of snow, then the snowball gets bigger. That's just basic logic. So here we can make a snowman out of, we started with three small snowballs and now we've got a large, a medium and a small, and we can build a snowman. And hey, this is Andy. Give him a little hug.
So this is the game that we made.
I made it with the help of Benjamin Davis, who did the amazing art and a lot of the programming.
And Ryan Roth did the music, which you can kind of hear if I stop talking.
So yeah, that's the game.
The tool we used to make the levels was PuzzleScript.
So this is a web-based tool, like I said.
Every PuzzleScript game is a single text file.
You can see it over here on the left.
This is the entire source of the game.
That's 270 lines, but like...
Half of that is levels.
So in fact, the code of the game itself fits into one screen.
This is all the gameplay in the entire game right here.
Because it's a rule-based thing.
You're not like saying, if this case, then do this, and then else this, do this.
It's just like, okay, find this pattern in the world.
Is the player moving into a snowball?
If so, maybe the snowball wants to move in that direction too, I don't know.
So it's really easy to prototype, especially for 2D games that are tile-based.
So here's the game.
This is exactly the same game.
It doesn't look as pretty.
In fact, every image in PuzzleScript is a 5x5 pixel image.
There's no way to make bigger graphics unless you want to do some Frankenstein object which is made up of multiple smaller objects and that gets a bit weird.
Like I said, everything in the game is one text file including graphics.
So right at the top of the file, here we can see the player.
We've got the color of the player.
and then a zero when it's black, a dot when it's transparent, and that's the graphics of the player.
Small snowball, medium snowball, large snowball.
It's pretty easy.
And so that translates into a game where you can move around, you can push snowballs around, and you can make snowmen.
Unfortunately you can't hug snowmen in this version, so it is kind of worthless.
But that's okay because we fix that later in the actual nice looking version.
So the other nice thing about PuzzleScript is that it has an embedded level editor.
So if I press this button, we've got a level editor.
These are all the objects I can put in the world.
And here's the level.
So I can quickly go, okay, well, here's this second level.
A solution I did with this.
But maybe I want a different level.
Maybe I want a level where there's something stuck on this wall and something stuck on this wall.
So now, is this possible?
I don't know.
So I can try and, OK, I need a larger there, and this is kind of awkward.
So this might not even be possible.
Maybe I'll add a patch of snow here and try that again.
So let's go like that.
And so this is the entire code of the game.
I'm easily able to test things.
And it's still impossible.
So I'll move this guy up here.
I'll put a patch of snow here.
I'll add a thing.
here and then I'll get rid of a thing here and that's the right number of snowballs and and yeah that's that's a pretty damn good level so what I can do is I can click this. This is now just some text for the string of the level. I can copy that and go, oh yeah, that's a good final level. That would be a really challenging one to end the game with. But for our purposes, what we can do is just paste it into this text file. We can close the game.
Open up the game and now...
Right, reset the level. Oh, we've got the level!
And because it's just a text file, I can copy it out of PuzzleScript into the game.
The game can just load text files super easily.
And all the levels in the game were just made using that tool.
Test it in PuzzleScript to make sure it's doable, and then import it into the game.
And presto!
So I'll just... Oh god. Actually I don't know what's going to happen because this level thinks it should only have one snowman. So this could like crash when I try and solve it. So let's see what happens. Crashing your game in a talk is the best idea.
So that was Andy over there. Will there be two Andy's?
It's just a generic name of someone. I'm sorry, I still love you.
I'm crying.
Um... ... ... ... ... ...
... ... ... ... I can't overstate the importance of hugging your snowman.
Okay, so yeah, so that was PuzzleScript.
It is super easy to make the levels, it was super easy to test the mechanics of the game.
We actually started making the game and on the first day of development, I had a working prototype with all of the mechanics of the game and like half the levels in the first day.
And I don't know what the rest of the time took.
Apparently the animator needed to like draw stuff like animate some some movement I don't know like seem like a big like the moment really really drew on like I don't know But it was great because public scripts already existed I didn't need to make anything I could just go up This is the thing this is perfect for the type of game. I want to make I'll prototype it and yeah, let's go So yeah, I really, really like PuzzleScript.
It's super accessible, it's easy to make new games, so I used it to prototype A Good Snowman's Hard to Build, but I've also made like a dozen complete games that are self-contained, released for free on the internet.
Each one took between a weekend and a month to make, and so there's things like You're Pulling Your Leg, You're Pulling My Leg.
where you're using pulleys to put mirrors on things and raise them and lower them to redirect the path of light around a cave. Cyber lasso where you're using an electronic lasso that can grab crates and then move them around corners and try not to electrocute yourself. Train braining where you're planning out the route of a train so it can pick up everyone and put them down.
And skipping stones to lonely homes where you're skipping some stones and the ripple from those stones push lily pads around the world and that's all obviously a safe way to transport yourself on jumping onto lily pads that are floating around.
I recommend trying that at home if you have a pond nearby.
So yeah, PuzzleScript is available for free on the internet. Try it out at PuzzleScript.net.
I'm Alan Hazelden. I'm at Jack Nick. That's my website. Thank you.
Thanks, Ellen. Last but not least, we have Omar, who is going to show us a tool that he made to make more tools. So let's hear it for Omar.
So let's hear it for Omar. So let's hear it for Omar.
So let's hear it for Omar. So let's hear it for Omar.
So let's hear it for Omar.
All right. Hello. So I'm Omar Kornu and today I would like to discuss and inspire you to make more of your own tools and discuss some of those hidden benefits. So here are some of the games I worked on. They were all organically designed and built from scratch which meant that we had to create custom tools on the go. I ended up being quite involved with making those tools and this experience led me to create a library that I would like to share today.
So I'm making this free software library called DearIMGUI. It's a simple and portable library to make quick tools in C++. It works on computers, phones, consoles, anything. Now I realize there's probably like five people in the room still using C++. So I don't want to talk too much about the library, but I would like to discuss some of the ideas that might encourage you to make your own tools. So why do we even need to make our own tools?
Games are interactive systems and yet many ready-made tools are focused on what I call altering startup condition.
You typically add object and edit the properties and then you play your game.
So I think those tools tend to make us focus on content creation and level design a little too much.
So I think we need better tools for creating systems, game designs.
And there aren't many tools that are focused on game design.
PuzzleScript, actually, that Alan talked about is doing that beautifully.
And you can actually create a game from scratch, not just levels.
We also need better tools to understand what our games are doing and how they are behaving so we can understand them, debug them, and optimize them.
Games are complex and messy.
I like to think of them as an interactive haystack.
There's like five million things happening inside.
Nobody understands all of it.
You've got thousands of objects, files, algorithm created by different people with different skills, expectation.
So we want to make it easier for everyone to understand what's going on there.
and creating interactive tools to visualize the game logic and game states is a way to share that knowledge. So back to the library the basic idea of DRMGUI is to turn UI and tool making to something trivial. We want to make it a habit to build tool naturally so it's designed to be easy to use. It's low friction. You can start typing code and create new tools immediately.
And finally it's designed to create tools that are always available.
by always available. That's a picture from the game brigador. Some of the tools have been shipped to users. You can press F1 mid game and edit the game properties while the game is running. So the idea is always available is that you have tools that are created directly inside your game. They don't get out of reach when you start working on your console or tablet version or when you play testing the game outside.
all have access to all your game running states. So no run time data is off limit to the tools. You can understand problems as it happens. You can fire the tools and inspect immediately when someone is playing. No need to load another build or editor.
And you can ship those tools to everyone. You can ship them to designers, artists and QA and you can ship them to player if you feel it makes sense there. So how does it work?
is card driven. You write simple code that generates the UI every frame. You can work directly with the data used by your engine in a running game. It's tightly connected there. And it's perfect for creating real time interactive tools. You can use it to tweak parameters, visualize game data, plot stats or create a custom editor. That's a very simple one line use case. You can call one function to edit one of your variable. A simple widget appears.
If you stop calling it, the widget won't appear.
So you don't need to set everything in advance.
Your code flow always dictates how the UI will look.
That comes with a few important and useful properties.
All interactions are processed immediately, as you call the function.
There's no later, no callbacks, or persistent requirement.
So your code can stay compact in only one place.
You can call this from anywhere in your code. It doesn't have to be in a specific spot like an update or draw function. Meaning that you don't have to refactor your code in a particular way.
You can literally start creating tools in the middle of a function. The library comes with a bunch of widgets and functionality to get going very easily. So I won't get into details how to program with it. You can check the code and example on the website. The base idea is that you have that bit of support code that encourages you to create tools.
If you don't use this library you can probably use another or maybe the source code for it can inspire you to create your own tool kit. Whatever makes your life easier. Some of the hidden benefits I think tools are communication and that's exposing live data to your team is a strong form of communication.
You want to avoid a situation where the designer or the artist don't have a clue what's behind the black box of the game. Having to ask programmer to unblock them. This is wasting everyone's time.
So if you give people the ability to look inside the black box and understanding themselves, they will be more productive and independent.
And the more you visualize, the easier it is to tame the complexity of game development.
That's an example of visual and spatial data.
We're just plotting the position of object in a map along with some LOD information, and then suddenly you can see patterns emerging and you can understand things very easily that you wouldn't be able to understand from just looking at the code or looking at the game from the player point of view.
So it gives you a good grasp of what's going on with the engine. And then you can expand that and add the option you want if you want to display a bounding box or any other useful data that you see fit. You may want to create all sorts of gauge or monitoring tools to communicate budgets and limitation. Again, it's very simple code. Usually there's like one line per stuff. You can graph things. It's very simple. Another of the hidden benefits is that I think tools are documentation.
like instead of writing documentation that always out of date and that people can never find, if you write a tool, then it's likely to be up to date and people can play with it and interact with it and therefore understand what's happening. So if you're going to create some new fancy algorithm for like pass finding of physics, writing the tools along with the new code is the best way to debug your code and to document it. Create a tool to interact with the new code and you've got the documentation done here. It's useful for the current you, for the future you and for other team members.
Finally I think exposing that stuff helps team members share a common vocabulary. Like don't you hate it when everyone in the team is using a different word to refer to the same thing and nobody understands what is doing what precisely. If everyone is looking at the guts of your game they will have a better understanding of what is doing what.
advice, just keep it simple. It doesn't have to be amazing. It just needs to serve a purpose. It's kind of like, I encourage you to make the poor man tool basically. They don't have to be pretty. They just need to make your life better, happier and in turn make the game better. They don't have to life a lifetime. It's perfectly fine to make a tool that you throw the next day. If the tool is really easy to make, then you will feel inclined to write more throw away tools and things that fits what you need to do today or this week or this month.
I often have common excuse against tool making. People say we don't have time to make tools.
That weirdly implies that tools are luxury or lost. And I hope I have conveyed that to a few ideas about why they aren't. Some people say I'm terrible at it. I hate making UI, I hate making tools. I say you can try a different way of doing it. Maybe ask your other developers and learn tricks, find a better solution.
My library is one possible solution but there is probably like a million others. Tool making is a muscle you can flex.
The more you do it the better you get. So you really have no excuse. We are almost done. I have 20 few examples of custom tools created using the library.
This is a mini searching tool. You can use it to enter key words or find objects in your scene.
It's fairly simple, fairly trivial, but it's like 20 line of code. So if you need to search for something, it's probably faster to write the code once than to just look in your enormous scene all the time. That's an in game tool to browse texture and run the buffers. So you can look at the footprint of loaded texture. And I mean you can easily catch it when an artist created a giant eyeball texture or something.
is a basic profiler. If you build that kind of thing to be always available then any time someone has a performance issue you can come and have a look at what may be causing it. These are some of the tools created for tear away. They were mostly debugging tools. You can click any object and inspect the state. You can trigger break points to debug the code of certain instances. That sort of things.
It's things that I think are probably given when you use unity but then when you do it in themself you can specialize and add actually exactly the feature you want and present information the way you want. It's really handy when you have to debug situation with kind of thousands of active objects. That's a free game engine called Linux engine which is also using this library. I just want to say don't shy away from making your own engine sometimes. You will most likely fail but you will learn a lot and learning is winning.
game innovation needs people straying away from the main path and creating their own tools. It's foolish but it's also very good that some people do it. Please do it sometimes.
That's the end of this mini-talk. I hope it inspired you to consider making more of your own tools. They can be stored on in-game tools. If you use Unity, maybe look into extending the editor a little more. You need to flex that muscle. Your game design is king and you shouldn't be enslaved by whatever tools are readily available to you.
help you innovate. Thank you.
