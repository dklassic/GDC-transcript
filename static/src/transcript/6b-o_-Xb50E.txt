Hello people. I think we're going to get started. I kind of wanted to mention, if you were sitting in here before things kind of got going and they didn't scan you on the way in, if you would really, really please scan, ask them to scan you on the way out, because otherwise I don't get the review and I don't get a lot of the information that I need to make the talks better for years to come. That being said, I'd like to start. My talk this year Designers are from Venus and programmers are from Uranus.
I kind of get to say things like that because I am a programmer.
And so, it's sort of like Dave Chappelle gets to tell certain jokes and Ellen DeGeneres gets to tell certain jokes.
So, who am I? I'm standing here in front of you guys.
I've been in game dev for a really long time.
I was recently at Blizzard and I worked on Hearthstone.
It was actually my 19th ship title.
I've been in companies from...
garage companies to Sony Computer Entertainment of America, probably the largest one. And I've worked on a game in almost every genre, which is kind of weird in a way. I had never done a card game before, that was interesting. And mostly I've done gameplay and AI, but I've also done design. I've even been lead designer on a few of the projects that I've worked on. And I put them in this order for a good reason. I've always found that AI is sort of...
on the border between design and gameplay, on the border between design and programming.
And in order to do AI right, you end up having to be in both sides.
And this is kind of why I'm doing this talk, because I find myself in many of the companies that I work at as sort of a translator between these two groups.
I would find myself all the time coming around the corner at Sony and finding two people arguing, and I would kind of sit off to the side and listen to them for a while.
very quickly determined that they were just having a communication problem.
They needed Google Translate to come in and kind of help them.
And so I would say, hey, I think what he's saying is this, and I think what he's trying to say is this.
And they would both kind of shake their head and go, yeah, and then walk away.
And that happened so many times that I realized that this is really a problem.
And that, combined with doing a lot of psychology sort of work with AI, I've really started to get a feel for how people work together and that sort of thing.
And it's been part of my job for quite some time.
So, in summary, I'm a seasoned veteran. I've pretty much seen everything.
And I've been exposed to a wide, vast array of work environments.
So, why this talk?
Well, the way that we make games is changing quite a bit.
I mean, the old way, right, was that a designer would write a spec, the programmer would go off and implement the spec, he'd come back eventually and they would playtest it, and it might get repeated.
Maybe. That was kind of how things worked.
But nowadays, that's not even really how we even make games anymore.
A lot of times a system designer will write the doc.
The programmers will then implement a tool that the content designers will use to make the game.
And then the programmers will support both of those designers with tool and feature changes.
And then we keep doing that over and over again until we ship.
And then many times we even keep doing it afterwards because games are online nowadays and we can update them all the time.
Now obviously this is more of a AAA process.
and there's differences if you're doing an indie team or what have you.
But this is kind of how games are done nowadays.
And as you can see, there's a much tighter coupling between the designers and the programmers in the new system than there ever was in the old system.
The other reason I'm doing this talk is because features themselves in our games are changing.
You know, while the disciplines are still in the big three, you know, designers, programmers, artists are how we divvy out our staff.
Game features are not really divided that way anymore.
I mean, even this feature.
That probably could have been drawn by the same guy who programmed it, who was also the designer.
But even that feature, I don't believe, was done by one guy.
And what about that feature?
Is there anybody in this room that can tease apart which was the programming and which was the design on this feature?
As our games become increasingly complex, the features themselves become increasingly complex and they require these cross-disciplinary teams to work super tightly if they're going to work out.
And these two groups can be especially tough to harmonize because they really don't think anything like each other.
So the things I want to cover in this talk are basic differences between the two.
actually working together as far as establishing a connection and ongoing sort of things.
And then some bridge methods that are starting to be used by the industry.
One of the things I did when I do a lot of these talks is I go into Google and I type the thing that I want to think about into Google Images.
And it's cool, right?
Because Google Images, or Google in general, the way that they score things and they bubble to the top is like.
That's the link that the most people clicked on.
So in effect, you kind of get a ask the audience sort of thing when you consult Google on things.
And so I typed game designer into Google.
And that was actually the first picture that came up.
Now, for me.
I don't know if it's different for anybody else.
And that's kind of a cool picture.
And so then I typed game programmer in.
And I got that picture.
And I think it's kind of interesting that.
Even ask the audience, there's a massive difference, right?
When you ask the audience, what's a game designer, you get a concept, you get a powerful drawing of the creative process.
And when you ask what's a game programmer, you get John Carmack.
You get a specific guy.
You get somebody sitting at a desk programming.
And so even the general populace sort of knows there's a very distinct difference between the two.
And so, the process by which these two groups actually do work is vastly different as well.
The design, as you guys all know, is very free form.
It's super collaborative.
It's largely discovered.
It's, you're kind of...
out there in design space looking for the fun combination of rules that give you something special.
And it's very situational, depending on the game, the part of the development process.
There's no real sort of formula for the design process at any given moment.
Whereas programmers are not that way.
Typically their job is much more structured.
they can divvy out tasks and separate systems much more easily and they can divvy out the work much more easily.
They deal in abstract systems and that's sort of their mindset in the total.
And also they're typically a lot more isolated.
They tend to be able to figure out a task, go off and kind of do it and come back for feedback.
That's not the case with...
with design. Typically, you don't have that sort of back and forth. You have group, group sort of dynamics. So if you have a mixed team environment, you can see where this might rub everybody kind of the wrong way. The programmers are going to feel interrupted quite frequently because there's a loud, potentially boisterous talk going on right next to them. And while, yes, occasionally, they're going to be able to give some feedback that might steer that group in the right direction.
For every one of those times, there's probably 10 times where they're going to give some feedback or naysay something that the designers aren't even trying to say we should do.
They're blue-skying over here and they're bouncing stuff around and it's sort of proto-ideas.
And you don't want to naysay a proto-idea, right?
Because that leads to stifling.
And on the same other side of the coin, you know, the designers might feel stifled when in reality they maybe just...
are miscommunicating what they're talking about at any given time.
And so, yeah, I think for certain parts of the development, a mixed team sort of environment works.
I especially like it when you're doing a new feature.
You all kind of sit together for a while and kind of get an idea as to the beginnings of it and the starts of it and that kind of thing.
But then, personally, I think that it's better if the programmers can be isolated a little bit.
so that they can get a little bit more of that deep focus that they need to do their job.
The two groups have very different goals when they're making games as well.
Design is searching for fun, and they're searching for that consistent player contract.
They're trying to find that set of rules that they can limit the player to and see how effectively they can sort of maintain just that contract with the player.
Versus the programmers.
are looking more for performance, scalability, and maintenance of the overall product.
They're not really talking, they're not really thinking about this particular game.
They're thinking about code in general.
I think both sides have simplicity on their watchword, but I don't know that they mean it in the same way.
And I'll talk about that in a little while.
Part of the thing that I wanted to show you guys was on Hearthstone.
the designers, and by designers I mean the two designers, were sitting in a particular spot and right between them was a series of posters that they had up called the design pillars that clearly stated the goals of the Hearthstone design effort. And I wanted to show you guys these. There's game for everyone, keep it deep, make it physical, great flavor, play fast, and win or lose the game should still be fun.
So now if I kind of go back over these again, you'll notice that these are very colorful.
They're very flavorful.
They give you a decent idea as to what Hearthstone's tone is supposed to be like, its overall attitude.
And to a certain high-level extent, you can kind of see the game that Hearthstone is supposed to be just in these pictures.
Now I want to show you...
the series of posters that were sitting on Bob Fitch's desk, the lead programmer.
And these are the programming pillars, in the, seven feet away from the design pillars.
Solve the problems you have.
Fast doesn't mean sloppy.
Keep it simple.
Know how it broke.
It better work.
Leave no tracks.
Play the game you're making.
And use the right tool.
Now, one thing you should notice on these.
is that these have nothing to do with Hearthstone.
In fact, these are the exact, oh excuse me, these are the exact programming pillars that Bob Fitch has used for 20 years.
These are about building tools and about building systems and about working with the other programmers.
Leave no tracks.
And so the difference here is that one group is very much thinking about the game and what it means to make this game, whereas the other group is very much interested in the process and what it means to do the process.
Now, how do these different goals and motivations lead to success?
What is it about performing these goals and motivations that actually give satisfaction down the road?
to these groups. I mean, obviously you can tell they're fairly different, right?
For the designers, fun is fun, right? But if you can maintain a contract and maintain simplicity, you're talking about that game that's easy to pick up and difficult to master.
You've made an accessible game that a lot of people can learn that rule set and really dive into. Whereas the programmers, they've won if they've kept the bug count low.
if they've made intuitive code so that an additional staff that comes in can jump in and help out, and if there's no crunch. That's how they win. And so you can see where sometimes something that the designers want that will actually give them the win is exactly the thing that might cause the programmers to lose what they consider to be the win. And that's a big source of rub, right?
the common thread for the two to win is the word elegance.
But even then I think they're thinking about it in two different ways.
I think when you have an elegant game, that's where you have the minimum set of rules so that you have depth in your game, but it's not so many rules that it's complex.
It's accessible still.
Whereas in programming, elegance means it means the code is clever, but not in an unintuitive way, again.
because that's a strength. But it's clever in such that you get a surprising jump in performance or a surprising jump in optimization of space or something. And so when the programmers say elegance, they mean the code itself is elegant, not the game, which is what the designers are talking about. Again, there's sort of a different tack.
So how do we get these two groups to work together? They're very different people.
And they have to be very closely associated.
And how do we do this?
I think for me, it's all about beginnings.
It's all about when your game first starts, especially with new staff, you have, I like to use a two-part process to sort of jumpstart the process of this connection.
First, I like to call it the pre-prototype.
When the design has been gone on long enough, you've got a nice paper prototype.
You've got a good idea of the rule sets.
That's when you bring the designer in, or excuse me, the programmer in.
And that way you can get everybody on board and on the same page as to what the design is going to be.
You can start the buy-in process.
And more importantly, you can actually, at this point, essentially teach the programmer how your brain works.
How you perceive this design problem, how you perceive what are the important bits and what are sort of not the important bits.
All of that.
this is your time to sort of shine and give him insight into your brain.
I like to do this with as many different types of media as I can.
The paper prototypes work great.
Obviously talking, doing a lot of whiteboarding.
Act it out.
Stand next to each other and act it out if that would make it more clear.
Human beings have a lot of different ways of retaining information and sometimes...
you can give an email to somebody and they will remember it for 10 years and other times you can give somebody a piece of paper and they will read it 20 times and they will still have to pick it up for that 21st time.
They will never, it will never stick.
And so mixed media is super important.
I mean, any grade school teacher will tell you this, right?
People learn in different ways.
And the purpose of this...
interview, if you will, is to explore the boundaries of your game space with the programmer right from the start. It gives him the opportunity to push back on your design, try and find exceptions and edge cases. And it gives you the opportunity to explain how the design encompasses those edge cases and those exceptions. Because at this point, he's trying to determine an abstraction that's going to work well to encode your game design. And at the same time...
those exceptions, those edge cases might be things you haven't thought of. And so it's going to give you clarity in forcing you to verbalize those things to the programmer.
So then he's going to go off, or they, they're going to go off and do the code. And they're going to come back to you at some point with some semblance of a prototype.
the, the, it's, it's, it's time for the opposite to happen.
Now, it's your turn, as a designer, to get into his head, and to see if he got the message, as well as, as well as how he thinks about things.
So now it's time for you to push back on, on his abstraction, and let him explain how his system is going to encompass, I keep saying his, I apologize, how the programmer is going to encompass your, your, your design.
how his abstraction is going to handle everything that it needs to handle.
And again, the same thing happens when you work on exceptions and what have you.
The programmer clarifying these things in his own mind while they talk about it is a very important step.
Part of the reason I'm tripping so hard is because the female programmer from Hearthstone is right here and I'm trying not to be a jerk.
He also has a, they also have a lot more idea about the performance of the system.
How the system is going to play out given all of the things that now, now are known about the program and how it's going to handle data.
And so, this is where the programmer might give you a, a, hey, if you don't have to do this all the time, it would be a good thing.
In fact, let's make some limitations and some budgeting based on performance numbers that we already know.
And if, if it doesn't work, it's not going to work.
It's not going to work.
this is a really good time to sort of start the negotiation process for the interaction between the two camps. Again, it's good for you as a designer to watch out for over-engineering.
The programmer might be making a system that's way too broad to try and grab every possible option. And if you notice this and you say, hey, hey, that's really never going to happen, you can give the programmer boundaries that you're willing to live with such that he might be able to simplify things down at at the system level and actually get some real good gains and again, they'll watch out for trust fails at this point because if you say something's never gonna happen and then down the road you say Yeah, we're gonna do that now like that That's a big problem and be prepared for some sort of strong Negotiations because this is very early in the process and if you say never at that point You better kind of mean it.
So what I'm talking about here is establishing a connection between two human beings.
And this is the standard metaphor, right?
Because, yeah, two human beings can link up.
There is an easy way to even communicate.
But there is signal loss.
The problem I have with this particular hookup is that it's typically more like this.
These are not.
people that really speak the same language or think the same way.
And so you really have to come about it in this way instead.
A lot of programming is more top-down and content is more bottom-up.
I think a lot of systems designers also think top-down and so there is some common ground, but it's a really hard road to do and you really have to be careful and you really should start thinking about things in these terms so that you don't...
Designers love to use flowery language.
We hate seeing the same word used over and over again.
But programmers basically love clarity of language.
It's actually probably one of the reasons why we deal with computers better than people.
Because computers, by definition, are the ultimate example of clear.
clear language. You know, every time you put a semicolon in the wrong spot, the computer will say, wrong. And that starts to sort of sound like a lot of programmers, doesn't it?
You know, like you, you, you, you deal with that entity enough in your life and you, you will become that, you know, like they, they will tell you when you put the semicolon in the wrong point. And so, what we really need to do to establish this connection is, is remember that communication clarity is key.
Vocabulary is actually one of the very few things that human beings do when they form groups to bond.
High school cliques are about forming your own vocabulary.
Human beings do this so that they can feel a kinship with each other and know that they're on the same page.
It's one of the reasons why when geeks get together and we start quoting movies, we feel more connected to each other.
It's because that's our shared vocabulary.
And if you have that one friend in your group that keeps quoting Monty Python wrong or slightly wrong, he doesn't get it.
He's never going to be in the group.
Nobody likes that guy.
And so when you're dealing with programmers, you really have to remember that they are the kings of consistent and clear language because that's what the computer demands of them.
And the more senior a guy is, I think that...
he can get a little wiggle room and he can figure things out.
But the junior a person is, they're still very fresh.
Every time the computer's slapped them, it's still like stinging on their cheek.
And so they're still in that mode.
And when they come in and they talk to the designers, sometimes they want to sting you back.
I've seen entire meetings be derailed by a single antonym.
Some designer in the room will say the word actor when he meant entity.
Some programmer will go, wait, wait, wait.
Are you talking about the entity?
Or are you talking about the battle manager?
And his brain is off in that direction now, trying to find the inconsistency.
It's no longer in the meeting.
And you have to practically apologize to the guy.
No, no, no. I'm sorry. I said the wrong thing.
And that's annoying. I agree.
But it's something you should be aware is happening.
Consistency of vocabulary is something that really needs to be set up in that pre-production phase.
where you set a vocabulary for the game.
And hopefully he'll code the thing using the same vocabulary so that when you talk, the consistency stays.
Now, during the prototype phase, he's going to come back at you with some naming systems that he's made up.
Maybe there's a scripting language, and he's written out a bunch of opcodes.
Or maybe there's a naming system for the assets that are going to be loaded into the game.
I personally as a programmer try to have some flexibility in this.
In the Hearthstone game, I first brought the list of opcodes for the scripting system to the designer and they were all written in a third person.
Like the player who owns this card was an opcode.
So that in the script you could reference the player who owns this particular card in that script.
And the designer at the time said, oh, I don't think about it like that.
that's weird, I don't understand that.
And so I said, okay, take this file.
And there was a file with all of the opcodes that was read in by both the tool and the engine, and that was sort of the text of the opcodes that was used in the tools, because I didn't really care what they were.
And he went through and rewrote them, and I looked at them afterwards, and what he had done was change them all from third person to first person.
Because when he was writing the cards, he saw the script as being the card itself.
saying what it was. So he changed the player who owns this card to my player. And I saw that pretty quickly and I got a good insight into his mind as to why he was reordering these. Okay, when he writes a script, he becomes the card and he writes my script, basically.
And so it was very easy for me then, when I would talk to him, to use better metaphors to sort of get into his mode when we talked.
However, be explicit. Again, this is a clarity issue, right?
And there's certain things that you really have to be explicit about.
One is priorities. Must-haves versus would-be-nice, that's at the bare minimum. I better know which ones you have to have and which ones would be nice. I mean, obviously, there's a priority of the would-be-nices as well.
But post-ship is not a good priority to say.
I want to know if it's a must-have post-ship or if it's a would-be-nice post-ship.
Because if it's a must-have, then it might not be a post-ship feature.
I have to take that into account as a programmer before the game ships.
Otherwise, there's a nasty surprise.
Especially if you want to do some content fairly soon after we ship.
Estimates are another big thing that you have to be explicit about.
Don't give snap estimates.
Because programmers are notorious for remembering them forever.
Ranges are a lot better as well because they show certainty.
If I say a task is going to take me between 15 and 20 minutes, I think you're fairly certain about that.
Whereas if you say it's going to take between one and four days, I'm going to realize immediately that maybe the thing I'm asking you isn't very clear.
Because if you can't tell me within 400% time scale, then maybe I haven't been clear and I need to talk to you more about what's going on.
There's a lot of other types of communication that come up in game dev.
Meetings.
Meetings are a big one.
They run...
They run nasty for most programmers.
I think designers have a little bit better time with them.
I think producers have the best time with them.
I think producers actually, you know, have a bed made out of meetings at home.
And the big reason is that the chunk size of work between the two groups is wildly different.
I think it might be the same, except that programmers tend to have...
a lead in phase and a lead out phase because your brain requires a different degree of focus as well as like width of information that you need to sort of have in your head at once in order to do a software engineering task than a collaborative creative task.
the sort of well-documented programmer works chunk size is about four hours.
And so if you have a meeting in the morning, that might actually kind of shoot the programmer's morning.
And if you then put another meeting in the middle of the afternoon, ouch.
He might not actually get that much done, especially high-focus work that day.
This is one of the reasons why You really need to think about meetings and if they're necessary, try and front load them.
All those sorts of issues.
Also social setting.
Programmers again, you know, they vary greatly.
But in general, they're not as social as designers.
Even here at GDC, I have people come up to me and I'm also another programmer and I can tell you within three words if they're a programmer or a designer.
That's typically just eye gaze is all it takes.
The programmer will walk up to you and go, hey Brian.
And that's pretty high percentage of the time.
They typically don't like being made the center of attention.
And meetings can do that.
I mean, I've seen the single most powerful, confident programmer I've ever met, practically, turn into one of these in a meeting.
Hey, hey, hey, hey.
Defensive, wants people to stop talking.
Ongoing communications are very different as well.
You really should, I like to do it at the start of a team.
I like to say, hey, do you like emails?
Do you like IMs?
Do you want me to come talk to you in person?
Do you like phone calls?
Because different people like different things.
And with programmers especially, because of that work chunk I was talking about, there's times of day where this might be varied.
They might say, after 4 o'clock, please don't come anywhere near my desk.
Send me an email.
I'm busy.
I'm busy.
I'm busy.
and that might change over the course of the project.
But this is something that you really should think about because this is the sort of thing that you can really kill productivity completely innocuously.
And the last thing is feedback and suggestions.
I find that if, as a designer, you open an idea zone, that it makes it reciprocal, it makes it easier to reciprocate as a programmer.
They will also...
be a little bit more open for ideas when the designer comes to them.
I love this question. This is something that Eric Dodds taught me.
I had sort of a notion of this, but this is the most wonderful question there is, right?
When somebody comes to you with some feedback or a suggestion, and they start to say, hey, you know, it'd be really cool.
Don't say, we don't have time for that. Oh, I don't agree with that.
There's a million different ways to answer this question.
But this one, what are you trying to fix?
It does two things.
It shows respect for the person that's coming up to you with feedback.
Because it doesn't say, your idea is dumb.
It says, whatever your idea is, your intent coming up to me is to try and make this game better, and I see that.
But it also potentially digs deeper than just their little description and gives you an idea as to what...
the higher level thing is that they're maybe trying to fix and maybe there is something there.
Maybe their idea is stupid, but maybe the thing that they're trying to fix is not non-existent.
Other communication.
Documentation is a sore spot.
I mean, I don't know that programmers do documentation all that much better, but we definitely try because we make it part of our process.
And I think designers try as well, but they tend to, especially later in the project, kind of fall off the wagon a little bit more than programmers do.
So try and keep your design docs up to date, especially if they're short.
Keep your design docs short.
Our Hearthstone designer was proud of himself because he could get our documentation down to about two pages.
And that was a point of pride with him.
And I applauded him for it when he did it because that takes work.
You know, I've made GDC talks take less and less slides and that's a really hard thing to do to boil something down.
When we talk about design-driven production, the information about how to make this game and about where the intelligence lies is sometimes spread out in 15 different places.
How do I make a new actor?
How do I make a new script for this particular actor?
How do I, what do the priorities on the animations even mean?
All of these sort of process level things need to be documented as well.
And a lot of times this stuff falls through the cracks.
And so you hire a new designer, or you hire a new programmer, and he doesn't know squat.
And it's really hard to get these things to keep going.
And finally, content and scripts.
In much the same way that programmers, When I work with programmers, I try to get them to comment their code.
If I look at it and I say, hey, this doesn't make sense to me, throw a comment in here so that a month from now we know what this means.
When there's a bug.
I do the same thing with contents and scripts.
I put comment opcodes into my scripting languages, and when the designer goes to check something in, I say, what does this even mean?
Throw a comment here and tell me what this means.
The same exact statement as the programmer.
it will help down the road.
And it will also make that communication more clear so both sides can see that things are sort of even.
Bug reports is kind of a big one, because obviously your designers aren't going to be doing real bug reports.
However, they get the pre-pre-pre-pre-alpha of the game.
And they essentially are the testers of the pre-pre-pre-crap-alpha of the game.
And not only that, they're the pre-pre-pre-alpha of the tools.
And so, they end up being bug reporters in a certain way.
And so, try to know that this statement is sucky.
We had a designer on Hearthstone that would love to say this.
And to a certain extent, he was very systemic with this.
He would do this to everything.
If it was his favorite hamburger, he would say, This hamburger is the greatest hamburger ever!
And we used to tease him, we used to say he was a Sith, because only Sith speak in absolutes.
And the problem is that what this statement gives you is a notion that he doesn't feel that...
He kind of feels like this bug sucks and it just needs to go away.
When in reality, yeah, of course it does.
But I need more information if I'm going to do it quickly.
by not having legitimate bug reports and by not sort of being a part of the bug fixing process, it tends to build that us or them sort of thing. When in reality, it's a cooperation.
It's two people working together to try and make the same thing. It's not an us or them.
There's some trouble spots, obviously. Workflow, again, when you're dealing with a lot of tools, a lot of people get...
very early on tools, and they start working with them, and they try to make what they can.
And there's problems. There always will be.
But they try to make do.
They try to work around the bug, and they try to use the tool anyway.
And a lot of times they do that because there's not time to fix them, but a lot of times they just do it because human beings will throw a little duct tape on the hammer and use it anyway.
We're sort of trained to kind of make do.
But my point is, don't do this.
try to tell personal preferences and pet peeves on the current tool sets to your programmers as quickly as you can, as nicely as you can, but as quickly as you can, because if they can improve some of these very basic usability problems with tools and with your workflow, it's going to not only increase your productivity, but it's going to eliminate this nasty little erosion of goodwill between the programmer and the designer.
This is sort of like...
if you're in a relationship with another human being and let's say that person doesn't lift the lid or doesn't put it down when they're done it's not a big thing but eventually you hate them so if you just tell them hey this is a pet peeve of mine could you please and if they're reasonable human being they will go well I could care less I'm just gonna do it and it doesn't take any of my time, bang.
That's the sort of thing that I'm talking about.
Another thing is discovery, and please don't laugh at my picture, try to find a good picture for discovery.
Surprise, asparagus, he discovered that.
Discovery is a necessary evil when it comes to design, and it's not even that evil, right?
We're trying to mine the goodness, wherever we can find it.
But...
this can lead to some pretty hairy changes in the code, especially big changes.
If you can try and work hard to find the big changes early on, obviously that's ideal, but that's not always the case.
So when you come to the programmers with big changes, obviously this is a time for potential strife.
And if you come to them with a foisting sort of situation, that's obviously where there's problems.
But if you come to it as a negotiation...
Hey, remember what we said before?
We have to take that back.
But we're willing to negotiate on this and this.
It makes it less about accept this and don't talk back.
As opposed to, we understand there's a partnership.
We understand that we've had to come back on part of what we said before to be a true statement.
And we're willing to work with each other on it.
Reprioritization is a little bit of, oh, that shouldn't have come up. Oh, never mind. Reprioritization is a lesser evil. I mean, reprioritization might just be there's a demo coming up or somebody needs to see something or maybe an artist needs something quicker because of whatever. And so, these are a lot easier to sort of get into the system. But still, again, try to do it as quick as possible because you don't want to waste work, obviously. Crunch, everybody's on tiptoes.
When you have people that aren't socially gifted, crunch period suddenly becomes a really hard place.
So, I don't really want to go into this too much, but just remind yourself that again, you're dealing with the can and the banana.
This is the time when the wire might even be a little bit frayed, right?
You have to come at these sort of communications knowing that there's a big gulf to be done here.
And these trouble spots are really about trust.
This is the trust part of the relationship.
The workflow, like I said, sort of slowly erodes trust over time, because the tool doesn't really do what I want.
And if I ask him, he's not going to really do what I want.
And I'm going to have just more hassles.
And discovery, again, you're dealing with the contract between design and programming at this point.
And the contract.
Part of the problem that I see with this particular grouping is that the contract is a little bit inconsistent.
Programmers agree on a contract and they actually have to write that contract into code.
It's somewhat calcified for them.
Design doesn't exactly have that same level of calcification.
They can feel a little bit looser with their contract and they have a little bit of an easier time to kind of...
change their contract. Whereas, changes to the programmer's side of the contract are actually somewhat harsh. And this inconsistency, I think, is part of the rub. So, finally, I want to talk about some bridge methods that are starting to appear in the industry. I specifically use a rope bridge on this because it's serviceable, but there are some hazards, and you have to watch out.
and one person with a big knife can kind of cut it all apart.
So first is a technical designer.
This is a person that's gone either direction, right?
You either have a designer who has a lot of programming skill or a programmer that's decided that he wants to go more into the design direction.
And in either case...
What you really have here is somebody who speaks sort of both languages and they're down on the worker side.
And these guys can be amazingly effective at what they do, at not only bridging the gap between staff, but also by potentially not being seen by the other members of their team as being, the programmer is telling me to do this or the designer is demanding this.
they can soften the blow by knowing the language a little bit better of both sides.
However, there's definitely some issues.
They need twice the mentoring and twice the management.
They technically are both a programmer and a designer and if they're not getting both mentoring and both management, you can run into some of the problems that you can with green programmers.
And the thing that we all know, green programmers can cause some severe havoc in a code base.
They can check things in that maybe aren't approved and come in on a weekend with a great idea and just hack it together.
Stick it in the game, thinking that everything is going to be great.
We don't like this even when the programmers do it, and we certainly don't want anybody else doing it, especially somebody that's supposed to be there to help us.
All of these sorts of things, and it's not just sort of rogue behavior.
It's also just...
inexperienced programmer things like poorly optimized code or potentially hackable code on an online game. Things you have to think about. Also again, you have to take care when you do have designers and programmers and technical designers involved because the tasking they might feel like somebody's stealing something from somebody. But they might not know who's supposed to take a particular thing. And so there's a little bit of tap dancing when you're dealing with with cross-disciplinary groups simply because of that.
I also don't think that technical designers should be the main designer.
I think that the main designer should have only the player's needs in mind.
He should be the advocate for the player.
And technical designers, whether they want to or not, are also worried about the performance and the maintainability of some of their stuff.
And that's good.
That's what we want.
causes them to be a little bit more pointed in that direction.
I also think that cross-disciplinary stuff is absolutely the future of some of these features. We just can't have people that don't have both of these things. The art world has already embraced this directly with technical artists who can code shaders to make special effects that are in every game out there, just about.
We're a little bit behind them, but that's the way of it.
But only sort of.
Obviously, you have to deal with some of these issues.
And it's also going to be a culture thing as far as the corporations themselves.
Right now, there is the big three of career tracks.
And people that straddle the fence can sometimes have a hard time getting promoted because if they don't have two managers that know everything they're doing in an effective way, it's going to be hard for them to get promoted.
a design manager, let's say, with a technical designer to really know just how much value the coding work that a TD has put on into a project. It can be difficult for HR in general to even hire one. On the other side is sort of the management version, which is the dual class creative director.
This is obviously a guy who is sort of like a technical designer, except more at the management level.
And he knows enough so that he can push back on both sides.
He can actually be the person that maybe does the mediation and the management for your cross-disciplinary stuff.
And sort of have that ownership clarity that the underling didn't have.
But because he needs to manage both sides, he ends up not really being able to do much work.
And so you have a very powerful person ending up being just a manager.
And this is a classic problem, right?
But it's something to think about if you're going to go in this direction.
So finally, just remember that programmers and designers are very different people.
They're not just different people.
their brains are wired in a very different direction.
And this isn't a bad thing, though.
This is actually a good thing, because the best systems and the best games come from a melding of design and engineering.
Design and engineering's way of thinking is very orthogonal.
They're coming at the issues from very, very different directions.
And this pushback is what causes the systems to be as good as they are.
But because they're so different, you have to build that strong relationship.
And like in any relationship, communication is the heart.
And trust is the soul.
You really have to come at it in this direction, and you have to realize that when you come to a programmer with a discovered task, you may be killing his abilities to succeed at this game.
And that causes trust to be damaged, and it might futz with the entire team.
Cross-disciplinary staff can be super valuable if you can get over the problems.
And just remember, every day.
that we're all on the same team and we all want to make something great.
We want to be something, we want to make something that we can be proud of.
So that's, that's my talk. Thank you.
Is there any questions?
What does it look like right now for those designers who are straddling the fence to get into the industry as a first-time hire?
Well, that's tough, right?
Because you're essentially at that point interviewing for two jobs that nobody knows if you can do.
You know, designer.
I think it's very difficult for...
just being a designer to get into the industry, much less telling somebody that you're a technical designer.
I think if you have put out your own indie game or something or something like that as a programmer, that you could maybe say that, yay, I was the designer and the programmer on this project.
It did pretty well.
Check it out.
That might be an in road.
But shy of that, I think that's a very tough road.
Anybody else?
Yeah.
Howdy.
I love the idea that Hearthstone had a two-page design doc.
Could you go into some more detail about what that looked like?
Like, for example, was there just one line for each mode?
No, it was more like, I mean, probably.
But it was very boiled down to where...
none of the... I mean, the thing is, is Hearthstone itself is a very simple game, right? So, so the design doc for Hearthstone was the very boiled-down version. I mean, you don't have to have the design of all of the cards when you can have a design that just shows what the keywords mean, what the sort of game flow looks like, and, and, and just a few other things. You can kind of...
fully describe Hearthstone very quickly. I mean, obviously, I don't have the two pages where I'd share them with you because they're pretty kick-ass.
Yeah, I'd love to see it if you ever put it out someday. Thanks.
Yeah.
Hi, Brian.
Yeah. Hey.
Well, I am a programmer turned designer, so I'm kind of the other way. What I was wondering if this... I mean, how far do you go before starting to...
look for help with other parts, like for example, the main issue I have is with the art department.
They are like aliens to me, so it's kind of difficult to start talking with them without them just going into really artsy kind of terms.
So go to them and say that.
Say, hey, you know what?
I really need understanding with you guys, and you guys are aliens to me.
Can we sit down and have a conversation and get a good vocabulary going?
Exactly what you just said to me, go say to somebody on the design side and say, Hey, I want to make better games.
And I know that to do that, I need your help.
But right now you guys are speaking Simlish and I don't even know what you're saying.
Okay.
And just, that's how you do it.
Thank you.
Um, so, uh, first, to answer the other person's question, we do have a lot of technical designers at Maxis, and they always start as engineers, because they have to prove themselves as engineers first.
And that's, that's the only way that I've ever seen it done, so I, I would hire, I would go into try and be hired as an engineer, and then switch to design.
My question is, if you're in a state where, because a lot of what your talk is saying is about building this sort of trust from the beginning, if you're in a state where the trust is already damaged, do you have any tips for going back and attempting to repair that?
Yeah, I mean, not to extend the marriage counseling metaphor too much, but literally, you need a mediator.
Until trust is repaired, communicate through the mediator, so that things can be couched.
And obviously, the reason that the trust is broken is because there are some issues there, right?
There's some head-butting, there might even be egos involved, that kind of thing.
And you need to add another person to the equation until things are smoothed out and parameters are set and boundaries are set and that relationship is more serious, right?
And then you can go back to...
to working together. But that's really the only way I've ever found.
But who do you find that is that person, right? Like, who is that person that both sides can put their trust into? And that's probably the hard part, right?
That's the hard part. That's where you need that cross-discipline staff. I mean, I've had the luxury of being kind of that person on...
in a lot of companies I've worked at, I've seen it, I've seen other people doing it.
A lot of times if just the lead designer is, is, is, um, what's the word I'm looking for? Veteran enough, is, is senior enough, he will have worked with enough.
problems that he can mediate a little bit.
But you need that.
You need that mediation.
I don't think that those two people typically can do their workload and repair that relationship by themselves.
Thanks.
If it's interesting for designers to learn scripting to get into programmers' head, since it's all about negotiation, what should designer ask programmers to do themselves to get into our heads?
Well, I mean, that's kind of what I was saying, you know, the start of the process of the game.
In just the description of how the prototype is going to encompass the design, you can hopefully get into that programmer's head by asking him questions like, oh, you did it this way because...
And he might say, well, it's because if I don't do it that way, the performance is one-tenth.
And then you go, okay, now I know why he did that particular decision.
You know, anything from...
you know, just why, but also just how his particular brain wraps around a particular problem.
You know, that's why I mention that process, is because getting into another human being's mind is a very difficult thing to do, and using the game that you're working on as the tool that you do that with is probably the best way I've found to do that.
Okay, thanks.
Hi. So I agree with your experience that the programmers are very much focused on the performance of the code, and the designers hold that space of owning the player experience.
Have you had any, or experienced any success where, early on, by hopefully getting the programmers more into the player experience, because they are creating the player experience, that kind of helps with that communication gap?
And if you have any suggestions for doing that, because...
Oh, absolutely. I mean, personally, I have always loved the notion of feature-based teams.
So when you have a team coming together, the reason they're coming together is not because they're working on a game, as opposed to working on Elizabeth, let's say, for Bioshock Infinite.
The people that were on the Liz team, they called themselves that, the Liz team.
And it was the animators, the programmers, and the designers that were specifically working on that feature.
And I find that by coupling in that feature space and owning a particular feature, you narrow down the amount of information that you need to be sharing, and so there's deeper understanding of that particular thing.
And so you get that closer, that deeper level of communication.
And there's higher buy-in then too, right?
And so there's probably also a larger avenue for...
hey, can you do this?
Hey, could we do this?
Kind of back and forth as well.
I'm an engineer and I've often had either artists or designers come to me.
with a very specific thing that they want.
And everything they say, I want this.
And you're thinking, my response to your, what do you want to fix it question, everything is, I always come back with, what is it you're trying to solve?
Because they often have a very specific idea of what they think they need to solve their problem, but it often isn't the actual solution or the best solution in the engine.
So you always need to make sure that you ask because otherwise you have this miscommunication and everything.
And if you give them what they explicitly ask for, it often doesn't work the way they expected.
Agreed.
Yeah.
I mean, and that's why I tell people to ask that question.
Yeah.
Always ask, you know, what is it you really want?
I mean, don't tell me specifically what you want me to have done.
Tell me what it is you're trying to fix and I may have a better solution for you.
Yep.
Yeah, and in the same vein, if that is the case, then maybe you need to do a little bit more education of your designers because they didn't even know they could do that already.
They didn't understand the engine enough and everything to know what their options were or what they should have done.
Very cool.
So earlier you mentioned the communication between you and the designer, between the third and first person for the scripting. Are there any other really good examples you can think of for Hearthstone specifically of good communication between programmers and designers?
Well, I mean, remember, I was doing all of the gameplay and AI programming for Hearthstone pretty much, and one guy was doing the vast majority of the design of the cards and that kind of thing for the design.
to a certain extent, he was a technical designer, because he was actually coding the script on those cards.
And so there was a ridiculously tight relationship there.
I talked about this in the Hearthstone thing, is that there was a specific mandate to have an intermediate player be the base goal for the AI.
They just didn't want a high-level player, they wanted an intermediate player.
And so I spent a month and a half just sitting with the designer.
trying to figure out what an intermediate player was.
And not only with him, but with other people that were playing, so that we could get that idea.
And then going forward, a lot of times, when I would get a bug, I would come over to him directly, and we would sort of discuss it together.
I found that by including him a lot in the solution to bugs, in...
new features that we were thinking of adding.
Like right from the start, doing that inclusion not only allowed him to know the process more under the hood so that new cards coming in wouldn't have the same bugs or as well as I knew things that he hated.
He's like, well, we haven't even fixed the last time we did this.
You know what I mean? Like I would get that feedback very, very quickly.
I think that it's more just a...
The more tightly coupled you are, the more tightly coupled you should work.
You know?
You should get up out of your chair and go ask that person as much as you can.
Right, yeah, I prefer the personal communication too.
Thank you.
Thanks.
Anybody else?
Hi.
So you tell Hearthstone design doc if only two pages long.
Yeah.
So...
probably programmers in Blizzard, specifically on first zone, have some flexibility.
Like, you don't specify designers, don't specify it's really detailed.
And only if some issue appears, they tell programmers to change it.
Like, if the programmer is flexible, or they have clear specifications, but not written on the page.
like in your work on AI probably.
How many design decisions you made, for example?
Actually, the AI in Hearthstone was largely driven by the design choices that we made.
I mean, everything from the actual techniques that I used to specific game plays that the AI would make were sort of discussed with design.
And it was very experience driven.
So I mean, yeah, it wasn't all written down, but a lot of that was explored, discovered work that was coming in, like, after alpha anyway.
And so that wasn't something I would have ever really wanted written down.
And there was not really time to do that.
It's not like programmer decisions.
It's a result of communication, yeah?
Yeah.
I'm not exactly sure what your question was.
The problem is, as a designer, you cannot describe the feature in all details.
Of course.
In all possible things that might happen.
So, a programmer makes its own decisions, its own...
design decisions when it write it. How you saw it?
I think I see what you're saying. So, what you're saying is that a two-page design basically leaves the door open for a lot of programmer decisions. And in this case, maybe you're right that the fact that he could have a two-page design was because I was very collaborative with him and didn't do that. However, my read on the two-page design document is just that it suddenly becomes something that's legitimate and maintainable, and that you can, like, update.
Whereas if it's 100 pages long, nobody's even going to open it.
That's my point with that.
Yeah?
So I relate a lot to the bit about...
tech designers needing sort of twice the mentoring.
But I'm wondering about the effectiveness of a pure engineer as a mentor for the tech side or a technical designer as a mentor.
Yeah, I mean, there's a trade off there.
Hopefully, if you've got a mentor position, they've been in the industry for a while.
I mean, if they're doing gameplay or AI, they've done a lot of design anyway because there's no way to really do AI without being partial.
in the design space, you know, you're crafting an experience using AI techniques, you know, and that's primarily a design process anyway.
So if you have senior staff, they've either been in games for a while and so they can have a little bit of that, you know, I mean, everybody is not a zero or a one, right?
Everybody kind of is somewhere in the middle.
And so I agree with you.
If you have a very dry programmer, you maybe shouldn't have him be.
reviewing that guy's stuff.
But there's very few of those.
You know what I mean?
They tend to not be managers in the first place, right?
Because managers have to deal with varying levels of their staff.
So.
True.
OK.
All right.
Thank you.
Thanks, guys.
