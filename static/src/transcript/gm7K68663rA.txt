set up here. Okay. Good morning. Welcome to Goal-Oriented Action Planning. As Dave just mentioned, I'm Peter Higley. Um, there we go. Um, skip the slide. My name's Peter Higley. As I said, I worked at, um, Mortimer Productions here. One of the primary AI programmers for, um, our latest title, Shadow of Mortar. Middle Earth, Shadow of Mortar. Supposed to say the full title of the game.
Before I get into our usage of GOAP on that product, I need to give you an overview of goal-oriented action planning.
It's been 10 years.
You might have forgot.
So it started back in 2004.
It was actually developed for a monolith title, Fear, by Jeff Orkin.
It worked out well.
We've used it many titles since.
Most notably, Shadow of Mordor.
So goal-oriented action planning starts with a list of goals.
At least at Monolith, these goals are fixed priority.
We just have a list of goals.
We go top down to figure out which goal to pursue.
Now each goal has an is valid check.
And this is a simple check.
This just checks to see if the goal should be pursued.
The kill enemy goal up there, you'll see.
There's no sense in trying to kill an enemy if the AI doesn't know where an enemy is.
So is valid makes some very quick, simple tests.
to see if the goal should be pursued.
If it should be pursued, the goal declares what we call a desired world state.
I'll get into what this world state is, but it should be obvious.
It's a way of just communicating what the AI, what the goal wants the AI to do.
All right, so the AI achieves its goals with actions, as we all do.
So your AI will have a list of actions.
Now these actions also have is valid functions.
But you'll notice, here I have in the middle column there, each action declares what world state it'll satisfy.
It's basically saying, hey, I'll make sure the AI, if you look down there at the bottom, you have that go to node function, go to node action, I'll make sure the AI gets to node Y.
But before the action can actually assure the system that it can do that, it needs to run this is valid check.
And it'll get the desired world state, and it'll say, oh, you wanna go to node Y?
Let me make sure I can reach node Y.
Oh yeah, I can, great, I'm valid, use me.
Or, no, that's unreachable.
Just don't try to do this action, it's not gonna work.
Another important thing to note here about actions, they can require more world state.
So you'll notice like melee attack up there.
You can't really perform an attack.
unless you have a melee weapon equipped and you're by your target. So actions can say, yeah, I'll make sure I attack my target, but you got to make sure I get there and have a melee weapon in hand. All right. So this world state I keep mentioning. The world state is a collection of variables. Just a finite collection of named variables. And you'll notice the variables carry values. Use node.
that X there, that's going to be a node.
It's going to say, yeah, use this node over here and be attacking character Y.
That Y is going to be a character.
Now, while building a plan, we actually have multiple world states.
You'll hear me call them desired world states for each potential plan.
Because as we add actions to our plan, we're going to build up more world state variables that we need to satisfy.
And it's also the AI always has a current world state.
While an AI is using a node, that use node X for the AI's current world state will be set to the node he's using.
Where are we?
Yes, and one more point here, as you've noticed, goals and actions usually only care about a few of these variables at a time.
We have the whole collection of variables, but they usually only say, oh, I only care about these two or three variables.
The rest are ignored when we're trying to figure out if the world state is satisfied, is the phrase we keep using.
All right, so, we have goals, we have actions.
How do we build a plan?
So we run down that goal list, top down, highest priority first, until we find a goal that says, yeah, I'm valid.
And then we find an action that satisfies that goal, as I've been telling you.
Often that action is going to require some more world state.
Sometimes the goal may require more world state.
The action may satisfy one variable, but the goal actually may say, no, I need three of these variables satisfied.
So we find more actions that satisfy the previous action or that goal.
And we keep repeating until all the world states, all the variables are either satisfied by previous actions or satisfied by the current world state.
We say the current world state's matched.
Now that doesn't always succeed.
That can fail.
And if it does, that's okay.
We still have a list of goals.
We keep going down that list of goals and find the next valid goal and try to build a plan for that goal.
Now, you know, I was saying, oh yeah, we just pick an action.
We don't just.
you know, throw our hand in a hat and pull out an action.
And we use ASTAR actually to build this list of actions.
And, you know, think about this.
List, path.
Really what we're doing is we're doing pathfinding from the goal's desired world state to the AI's current world state.
Now, A star is a way to search a graph.
The neighbor nodes from your desired world state are the list of actions that satisfy the outstanding world state variables.
And of course, the path distance is.
Well, for us, it's a set cost per action.
As you'll hear from Chris, you can actually vary that cost per action.
That's some really, do some fun stuff with that.
But the cost is, the path is just trying to minimize the number of actions the AI needs to take.
And of course, it's A star, we need a heuristic.
The heuristic is just the number of outstanding world state variables.
That's a lot of words.
Let's run through an example.
We have a list of goals, a list of actions.
make sure the slides are all, yeah.
Our AI is a current world state, he has a melee weapon equipped, and he's not doing much else.
We run through our list of goals, we find, oh hey, I have an enemy, let's kill him.
Now, of course, kill enemy requires that the attacking target world state variable be set, so you can see our desired world state is just simply attacking target.
Uh, we expand, we find the two neighboring nodes in our A star process here. We find two actions that can satisfy that world state, uh, melee attack and ranged attack. Um, I'm just going to give them a cost of one just to keep things simple.
And they each require more world state.
So they add more required world state variables.
There you can see range attack says, well, you need a range weapon, and you have to be near the target.
Not on the target, but near.
Melee attack says, well, yeah, you need to have a melee weapon equipped, and you need to be on that target.
But, you'll notice our current world state says we have a melee weapon equipped.
So the melee attacks desired world state actually only has one variable that's not satisfied.
That at target X.
Whereas ranged attack still has two.
Do some complicated counting here.
You find the heuristics are, the heuristic for ranged attack is bigger.
A star always expands the shortest, you know, distance plus heuristic.
Which is going to be melee attack.
We find one neighboring action, go to target, that satisfies that at target.
We have no more outstanding world state variables.
We've matched our current world state.
We have a plan.
We go to the target, we perform a melee attack.
We hope the enemy dies, that's the goal.
Usually the enemy is the player, usually he doesn't die from one attack.
Players don't like that.
So when this is done, the AI just runs through this process again, starting at the top of the goal list and working down until he finds a valid goal, valid list of actions.
It may be the same plan, but we run through that just in case there's higher priority goals or new actions that could be run.
All right, that was a quick.
overview of global interstate action planning. Jeff's papers are great on this subject. You can find them in a predecessor to AI game pro. Anyhow, find them in a wonderful AI book from 2004. You can also find information online. It's been around about ten years now. So there's lots of information. All right. So shadow of mortar. How do we use all this in shadow of mortar?
Well, we were an open world game.
So we can have up to 50 AIs using this planner per frame.
Honestly, we rarely had 50 AIs hitting the planner in one frame.
But we also really didn't throttle it.
So we had to handle a lot of AIs.
And our planner, this is the great, great grandchild, Jeff's 10-year-old baby.
It's seen some changes through the years, but heart and soul, this is GOAP.
I'd like to say because it is.
So those of you who know Go, and even if you don't, you've just heard me talk about using A star to build list of actions and not always succeeding.
not always the most performant planner, but I gotta say, we didn't have too many problems with it.
It really never came up as one of our hot spots, but it did occasionally pop up, and I'll tell you what we did about this.
One thing, this is very Go specific here, we minimized the number of world state variables.
We found our planning costs scale with the number of variables.
You know, we're building heuristics, we are seeing what's satisfied, we're walking that variable count quite a bit.
So, we need to minimize that.
What we discovered is that a lot of these world states, I showed you a lot of world states with, you know, pointing at nodes and targets.
We also had a lot of just Boolean world states.
We had a cower goal.
It would simply say, hey, be cowering.
You know, I want you to cower.
Does that be a variable that would set to true?
We had quite a few variables like that.
Honestly, we ended up with about 40 of them.
They were never true at the same time, so naturally, that's an enumeration.
So we'd fold that variable down. We folded about 40 variables down to one. We ended up having about 10 world state variables we'd build our plans on and That you know that kept our performance good and Another the other large thing. I'm this really mostly what I'll be talking about we kept our plan length short It's a pretty natural thing to you know, you're using a star the quicker you can get to your goal, the quicker you find a path.
So we actually worked to reduce the number of actions we actually had to do to satisfy our goals.
We did this by taking logic and really just pulling it out of the planner when we could.
Well, we skipped a few here.
This is where I'm talking to myself as much as anyone here.
When you work on your AI, you know, whenever something new comes up, you think, oh, I could add this to Planner, how do I do this?
And, you know, I'd like to urge you, it doesn't have to be in the Planner.
You can look to other systems and say, well, maybe this system could support what I need to do, and I don't need to make this Planner a large, complicated mess.
For instance.
Shadow of Mordor, we had several low level systems.
Note, we had a head tracking system.
If you have not heard that yet, you really wanna get a head tracking system into your game.
It adds so much and it's so easy.
Today I'm gonna tell you about our...
are weapon sheathing or equipping and unequipping. Um we really didn't switch between ranged and melee weapons that much but uh you know you have this sword and when the orcs are just walking around not trying to kill anything which you know is not as often as you'd like if you're not an orc um they would put that sword away. Whenever they see something they pull that sword back out.
That's a pretty natural thing to put into a planner, especially a GOAT planner.
It really makes sense.
You throw in a world state variable, weapon should be equipped or weapon should be sheathed.
You throw in an action, sheath, unsheath, weapon.
And it's great.
You just set that variable and the planner figures out, oh, I better do this unsheath action.
And that's good.
But that's another world state variable.
That's another action.
We looked at that and we said, you know, just based on the animation we're playing, we know if the sword should be out.
So we actually took that action and just put it into our animation selection as just a transition.
The planner doesn't care.
The planner cares that the orc is going to play an attack animation.
And what's key there, it's going to play.
The planner doesn't care how long it takes.
It just sits and waits patiently for these low-level systems to say, yeah, okay, you're done, give me another plan.
So, uh, so we actually took that action, moved it into a transition, reduced our plan length by one.
Um, as you'll see from Eric's talk, that actually reduced our plan lengths quite a bit.
Um, we also had a lot of mid-level systems. I call them planner driving systems, because these are systems setting up variables for the planner.
And Again, a lot of systems I'd love to talk about.
Today, I'm gonna tell you about the awareness system.
Pretty early, we decided that our orcs would have just these finite levels of awareness.
The orcs will be alert pretty much when there's something to kill.
They're orcs, they wake up when there's something to kill.
And ambient is the polite term for bored because there's nothing to kill.
And that was great for animation, great for changing walk cycles.
It was also good for player feedback.
If you've played the game, you may have seen red and yellow icons over Ortega's head.
That lets you figure out how that relates to awareness, but you're pretty much seeing awareness.
But it also helped with our planner.
Because we recognized that we would have some combat goals, we'd have some investigation goals.
These goals were only valid when, like combat goals, really only valid when the Orc's alert.
Suspicious, you know, the investigation only when he's suspicious, so.
we actually found what we could do, rather than even hitting those goals and saying, hey, are you valid?
And the goal says, well, what's my alertness level?
No, am I alert?
No, I'm not valid.
We actually could just take that goal list and segment it by the awareness levels.
When our AI changed awareness levels, we would just swap out that goal list and say, hey, you might wanna look, there's some new goals here.
And that worked out great.
That actually was a, to be honest, that was a late addition to our system that gave us just a little more CPU.
And of course, we had high-level systems.
And honestly, this is where I feel like we had our biggest win for dealing with so many AI.
We had several high-level systems.
Today I'm gonna tell you about this investigation system, partly because it started in the planner and we managed to extract it.
Um, so, you know, early on we, we've always had some sort of search behavior.
When a, you can see there's a dead orc there in the, in the middle of the walkway, when orcs would encounter something that's not quite right, they would start searching and we had investigate goal, investigate goal would say, yeah, I recognize there's something not quite right here.
Why don't you go off and do some searches?
Now we're good.
for two or three orcs and the little box levels that we tend to write early on.
If you've played our game we have a few more than two or three orcs and they're pretty close together sometimes. It started looking silly when we'd get 10, 20, 30 orcs all seeing this dead body all going whoa I better search. It looked ridiculous. Naturally and you know this is not news you you put in something like oh I got it or you know well someone else is searching I'm not going to search now.
And that worked great.
Or to encounter a dead body, they'd say, oh, someone else is searching.
OK, I'll let them go.
But we were hitting our planner.
It's the goals they have to determine.
Like, oh, no, someone else is planning.
And to be honest, we still wanted them to react to the dead body.
We just wanted the, boy, I don't know what the reaction for that one was.
But basically, we wanted them to just acknowledge, like, this is not good.
I see he's doing something.
I'm going to move on.
So we actually still had to have our investigate goal go live.
It then would have to hit up these actions, say, oh, should I be searching?
No, someone else is searching.
Maybe I should just look around and hope I find something.
No, someone else is searching.
I don't want to do that.
Oh, I got to just do my react to dead body, but I'm not going to do anything about it animation.
So we're still hitting our planner, and there's a lot of work for 10, 20, 30 orcs.
Instead, what we did is we took that logic, and we just made a whole new system out of it, the investigation system.
It wasn't a very complex system, but it was great, because now when orcs see something that doesn't look right, they...
don't hit the planner, they just tell the system, hey, I see something here, maybe I should be doing something about it.
That system can then just gather everyone and go, oh, well yeah, you're closest, oh, but you're a captain, maybe you should be searching.
You know, it can figure out who's the best person to be doing the search.
It could then, it just basically assigns them a role.
Now our planner isn't bothering with like, oh, is someone else searching?
And what disturbances are out there in the world?
No, our planner is simply saying, oh, I have a role.
I'm lead investigator.
And it can go through the rich set of actions that we have for investigating.
Or its role could just be dismiss immediately.
And it would just do that one single action it had to do.
That gained us a lot.
We all of a sudden now, our planner is only reacting to roles, all the logic of determining who should be doing what was in another system that could handle it much more elegantly.
And honestly, you can see I have three roles listed there.
That watch investigator's back, that was added.
that was added after the system was spun up, it was so easy to add. That was so nice because I could just, you know, add another bucket of, oh, we need people who are watching other people's back. And obviously the goal and action for that is really easy. Just follow this guy.
So it also made expanding the system, not only did we gain CPU, it made expanding the system much easier.
I'm going to conclude on that.
I'm going to urge you all, whether you're using GOAP or not, look at your planners and see if there's logic that you can maybe move out to either lower level systems or higher level systems.
Doing so, I almost guarantee it's going to reduce the CPU load of your AI.
These systems that you'll be moving things to probably will handle that logic quicker, more efficiently.
And you'll also find improving your behaviors becomes easier.
It's, oh, adding random delays is so easy when it's just some separate system.
That's all it cares about, and the planner just sits and waits and doesn't even know that, oh, there's going to be something happening.
So I'm going to wrap up on that.
Got to give a quick plug.
We're actually looking for an AI programmer right now.
So please visit our website, talk to me, talk to, I think, Matt Teitelbaum, my partner in crime on this project.
And we'd love to talk with you about all the wonderful opportunities.
Not to sound too much like HR here, but there you go.
All right, next up, we're gonna have Chris gonna share his experience with Tomb Raider.
Oh, I gotta move this thing over.
Hi, I'm Chris Conway.
I work on the lead AI engineer for Tomb Raider, both the one from 2013 and the one we're currently working on.
I started with GOAP in 2006 when our lead designer came back from GDC and said, hey, I just saw a presentation on this thing called GOAP.
It'd be really cool if we could do that in our game that we were just starting at that time.
And I managed to get it up and running from scratch in just two or three weeks.
It really wasn't that difficult to do.
We iterated on it for a while for that title and things happened and that project got cancelled and then I went to work on something else and came back to Crystal in 2010 and resurrected this code for Tomb Raider which was released in 2013.
Most of the time spent on the AI for Tomb Raider is spent on the maintenance of the goals and actions, creating new goals and actions and making them better.
Not really the GOAP library itself.
That still, written in 2006, it's still about 90% of what it was back then.
So it hasn't changed much, except for a few new features that I'm going to talk about today that are extensions to what we originally had in the GOAP system.
So right off the top, I added the idea of situational costs for actions, which is the idea that perhaps a plan with an inexpensive primary action, like a melee attack, might become expensive if the NPC needs to move a long distance to get there.
So for example, exactly there, the melee attack might have a cost of 1, but because the NPC needs to move 20 meters, the goto has a cost of 20, and the planned cost ends up being 21.
Whereas the range attack, which for whatever reason it's tuned to be more expensive, perhaps because it uses up ammo or something like that, it has a cost of 10, but because they're already in range to do this attack, the goto only has a cost of 1, and we end up deciding to do a range attack when they're at a distance.
So it's something that seemed very natural, very natural extension to GOAP and we use it for almost every plan. It has an effect on it.
It's much better than putting a hard limit on things like attacks, for example, where we say we can only do a melee attack if you're within five meters, and you can only do a ranged attack if you're more than five meters away, because sometimes you run out of ammo, so a ranged attack isn't possible, so I need to run up to do it, or my melee weapon is destroyed so I need to move back to do the ranged attack, and the Goat Planner takes care of all that kind of stuff.
It's also useful when you need to have different variations.
So for example, a ranged attack might be less expensive when I have a machine gun than when I have a bow.
So when I have a machine gun equipped, I'm more likely to pick that action for my attack plan.
The same goes for a melee attack.
Maybe if I'm dual wielding swords, it's something that's very inexpensive, but if I only have my fists, it becomes more expensive so that I want to do it less often.
It's also useful for creating competing complex multi-action methods for the same requirement.
So we have, at least in one of the games, we had the ability of some of our NPCs to fly.
So they would make a choice of, do I want to run to my target to do the melee attack or...
Is it worthwhile to spend the cost of a requirement for the fly-to action is to take off and then of course I need to be in a landed state when I do the melee attack.
And the cost ends up being the total of take-off, fly-to, land, and melee attack.
And it makes sense when they have to fly a certain distance, but if they're very close to their target it makes more sense to just walk there or run there.
Another thing we added was the ability to have motives.
This is something I did on Godfather, inspired by the Sims, where basically they have a set of motives that drive their behavior, like hunger or thirst or I need to be entertained or I need to socialize or something like this.
And we combined that with the planner to do some very interesting things.
So we can use motives to control the goals that we use.
So for example, the investigate goal might be something that they only consider if their suspicion motive is above a certain level.
So maybe the first time you throw a rock, their suspicion goes up a little bit and they just have a reaction to it.
They don't actually plan to investigate it.
And then the second time, they're like, what was that?
Let me go check that out.
And they make a plan to do it.
We also have the ability for actions to have an effect on the motive.
So for example, maybe a successful attack reduces your fear, which means that you're going to be less likely to flee if dangerous things keep happening that are increasing your fear.
We also have the option to...
We added something where we can submit multiple plan candidates to the planner.
So, for example, when you have a usable object, let me skip ahead here, perhaps you have a usable object that says, I need to...
I want to use this object to address my hunger or something like that, and perhaps to do that, I need to do some other things.
Sorry.
So they might say, there are two or three objects that can satisfy my hunger need.
Let me go ahead and submit a plan option for each one of those.
And I'll figure out whichever one is the easiest to use with its requirements and so forth, or the distance to it, or this kind of thing.
That's the one I'll choose.
And that can also be used for combat, you know, if there are multiple targets, maybe I'll submit a plan option for, you know, a target that is far away, which is currently my primary target, and maybe I have a secondary target, and I'll want to consider plans for it and I'll give a penalty to the cost on the actions for the secondary target so that I want to stay with my current one.
So if I'm engaged with an enemy that is far away and I'm shooting it, I want to continue shooting with it.
But if another one jumps right out in front of me, I can do a melee attack on it and it's a much less expensive plan.
So I'll go ahead and switch to the target in that situation.
We can also have the ability for an action to submit different requirement lists.
So for example, perhaps a range attack wants the planner to consider, well, let's think about doing an attack with my bow, which I currently have equipped, or I want you to also consider making a plan with my machine gun, but I might need ammo for that. I'm not sure, you know, it's gonna, I'll let the planner figure that out, and then it'll...
calculate the costs for all of that and determine which one makes the most sense to do right now.
So we're letting the planner take care of a lot of this work that we would normally need to rely on the code to make decisions for.
We can also have the ability for situational requirements.
Jumping out a little bit, this is what I was talking about.
So for example, if they're hungry and they decide to use the dinner table object, perhaps the dinner table object requires that they have food and a drink.
And then the planner will go out and find, how can I satisfy those?
Even though the use object had no idea about food and drink, it knows that the object it's required to use to satisfy its goal requires these other things.
And it's going to have to put together a plan to meet all of those dynamic situational requirements.
So for example, a plan might be.
put together to go to the food server, use the food server to get the food that my dinner table is going to require, go to the bar, use the bar to get a drink, and then finally I can go to my dinner table, I've met all the requirements, I can use it and my hunger and perhaps my thirst will be satisfied.
And performing actions can have an effect on the state of the inventory as well, so the food and drink get consumed when I use the dinner table.
We also might have something where perhaps a ranged attack action requires the machine gun, as I mentioned earlier.
But the machine gun, the ranged attack action doesn't know anything about ammo.
It's going to leave it to the planner to determine that, well, if I'm going to use the machine gun, I need to have a certain amount of ammo.
And that means I'm going to have to go out and, you know, go to a drawer or something like that as part of my plan to use this and acquire the ammo in order to do the ranged attack.
Another thing we added is very important to the process is the ability for parent actions or the goal itself to monitor the child actions that are satisfying its requirements.
So for example, the range attack action might determine, well, I don't have line of sight from where I am right now, and I don't see any cover points where I'm going to be able to shoot my target.
I'm just going to tell the go-to, I'm going to fulfill...
I'm going to push forward a requirement that I need to be within five meters of my target and hope that I'll get line of sight.
But while I'm heading there, while my child action is running, satisfying my requirements, I'm going to continue to monitor the status of my NPC.
And if I get line of sight, I've got to tell my child action, okay, I'm happy.
You're done.
You don't have to go all the way to the target.
I've got line of sight right now.
I can continue.
I can continue with the plan myself.
This also enables the parent action or goal to dynamically change the requirements while the child action is in progress.
So for example, while we're heading towards the target for a range attack, perhaps someone leaves their cover point or they die or something like that, and so we're able to take their cover point, and so now my range attack action can tell, change the requirements that the child go-to action is using, and say, I want you to go to that cover point instead.
This forces actions to monitor their requirements to make sure they're still feasible.
So it's almost like the validity check or viability check is running while the action is still active to make sure in case the requirements are changing that we can still fulfill them.
And it also puts a responsibility on the parent action or goal that if they're going to change their requirements, perhaps they want to consider that it's even possible to fulfill them.
Another important thing is that we have our goal or action have the ability to evaluate and be aware of the current state of the child actions and we may want to decide at some point that the the the the the the the the the the the the the we no longer want to do this.
So for example, when the range attack action is moving to get into range for a range attack, maybe it decides that the target has become injured or dead, and I don't want to do this anymore.
So I'm just going to cancel the plan.
So even though the go-to is the active action, it's the parent action that's monitoring, or the goal that is monitoring the plan and has the ability to make the determination that we should no longer do this.
or perhaps change to a different target, if that's feasible.
The goal or action can use this awareness of the current state of the plan to communicate with other NPCs.
Like maybe when I make a plan to do some kind of attack where I'm going to say, okay, I'm going to go get her, you know, and I'm on my way, I'm going to say, okay guys, I'm going to go attack her and I'm this far away and I'll probably be there in two seconds.
And that lets my friends know.
hey, my friend is doing this, so maybe it's going to affect the way I'm behaving.
It also provides an option for the feedback to the player, because especially with a planning system when you have complicated plans, it's very important to communicate to the player what they're doing and what their intention is, otherwise sometimes they look confused, like why is he doing that?
That makes no sense.
They have to communicate to the player, like I'm doing this because this is my goal.
So by monitoring the state of the plan from the parent goal or action, we're able to provide a place to make that communication.
Another thing we added was the ability to have open-ended actions, you know, where the action remains active.
It doesn't just end the plan after one iteration.
And an example of that is a ranged attack action where they originally intended to take one shot at their target, but if the situation is still feasible and viable.
They're going to have tasks that they perform during this action, like reload, stepping out from cover, stepping back in, aiming, and firing.
And they'll continue to run the action.
This requires maintenance of the remaining cost of the action so that replanning can still happen for the same goal. So yes, I have a plan to range attack and I'm going to keep range attacking as long as it's viable, but I need to provide a remaining cost so that the planner can still make a decision to say, well, you know, I know you're doing this and that's good, but I found a cheaper thing. You can now do a melee attack because somebody has stepped right up.
up to you or they've approached you.
So we still allow the planner to run.
And to do that, we need to provide a remaining cost for the current plan.
The main purpose of this is it prevents us from repeatedly having to construct, start, and finish an identical plan.
And it's just a much more efficient way to go about things because planning is expensive.
But again, if we find ourselves in a situation where we have a better plan for the goal because we've calculated the remaining cost, the melee attack option might come up and replace the current one.
Another thing we added was I started keeping statistics on how successful the NPCs were at doing on their goals and their actions and that provides the opportunity for them to learn from their success rates.
So for example, maybe the melee attack is something that an NPC of a certain type usually fails.
And what we can do is tune the cost of the melee attack to reflect that so that they're less likely to do it.
Maybe they'll only do the melee attack if they're failing all the time if the target is right next to them.
Or perhaps they'll never want to do it except if their other options are unavailable.
For example, if they're on cooldown or they're out of ammo or their weapon's broken or something like that.
And it works both ways, you know, maybe the ranged attack is always failing because my weapon is unreliable or something like this And so now I'm more willing to do the the ranged attack cost goes up and now it's more viable to do a melee attack from further away because It will have a lower cost even with the added movement requirement to do it The statistics generated from the success rates for the plans and the goals and actions can be saved with the game data.
We can save them at tunable milestones.
This is one of the big questions for us is how do we do this?
Do we really want the end game NPCs to be affected by what happened at the beginning of the game?
So we have to make decisions about that.
And also we want to make sure that they're tuned to specific types of NPCs, so they're attached to the GOAP setting.
So an NPC that has a set of goals and actions that are primarily aimed towards ranged attacks, perhaps it'll be different from one, they'll have different statistics from one that has goals and actions primarily for melee attacks.
We also require different GOAP settings for different NPC types because of this.
Yeah, like I mentioned.
OK, and then finally, one of the big complaints from our designers was that the goal list was somewhat inflexible.
It was just a prioritized list of goals.
So I exposed it in their environment.
I created a behavior graph where the goal that they're going to pursue can be selected by a script, by a visual scripting.
So for example, they can add rules that the code doesn't even know about.
Like if I'm in a pre-combat state, here are the things I want to think about doing right now.
If I'm in combat, I want to do things related to attacking and this kind of thing.
And that way I'm not wasting time pursuing goals that are not interesting for my current state.
They can also do all kinds of things to customize when the order that goals are in, you know, or which ones are available.
So, you know, perhaps they only want to converse if the motive for the loneliness is going to drive it, or if the player hasn't done something recently, or if the target has a certain weapon equipped, you know, maybe it's more important to do a certain goal, and they can control all of that from the behavior graph.
And I have a very big slide to show an example of the behavior graph that the designers maintain.
Up in the upper left-hand corner is where it all starts, and they're making a decision there to say, am I in combat or am I in low alert?
And they're pursuing a set of goals, depending on which one of those they're in, and then they can loop back.
They can even loop back onto each other.
It isn't simply a tree.
It's a graph.
And they can go down and finally it ends at the bottom there with the idle.
They'll always be able to idle if they can't find something else to do.
So those are the main extensions to the system.
I was just going to go very quickly over debugging, because it's absolutely critical to any planning system.
Designers tend to force behaviors via scripting when they don't understand what an NPC is doing and why they're doing it.
And they want to make sure that the NPC is doing what they expect them to do.
Scripting is great for demos or extremely linear sections of the game, but situations with systemic behavior are just fundamentally, without systemic behavior, are less interesting and have very little replay value.
So we really want to encourage going away from scripting and allowing dynamic gameplay.
Complex plans can be confusing to observe, that's why they need to communicate.
But complex plans are the exception, not a common occurrence.
This is a fundamental aspect of GOAT.
As Peter was saying, the planner always wants to choose the least expensive plan for a goal.
So some of the common questions designers have while they're looking at the game is what is he doing right now in his plan, what are the actions that it consists of, which action is he on, this kind of thing.
They also want to know, well why isn't he doing something else right now?
you know, why haven't we been able to find something better to do since this plan started?
Then finally, before he did what he's doing, you know, maybe 30 seconds ago, what did, he did something back then and I don't understand why he did it. So I have to provide on-screen debugging for all this kind of thing.
And this is kind of what it looks like in Tomb Raider.
I provide information about the plans and the reasons for why they're doing them.
And I break this down a little bit.
So here, for example, is an NPC who's doing an attack.
And before that, the plan consists of he did a play input action to announce that he's doing it.
He decided that he wanted cover.
So to get cover, he's going to use an object.
So he had to go to the table, flip the table.
He then went to the cover point behind the table and he's doing a ranged attack from there.
That's an example of an attack with five actions.
And then you can see before that with timestamps next to them, he was doing an attack and that ended because he became suppressed.
Before that I fired an arrow into the ground and so he investigated the projectile impact.
Before that he was just idling.
Then below that, I give an example of, here is where we provide the last time we planned.
Here are the things we thought about doing and the reasons we couldn't do them.
This is why we're still doing what we were doing.
Then again, I give an example of, you can go back in time and say, when he decided to do the investigate goal, for example, why did he not choose to do something else?
You can go back and look at that as well.
OK, that's it.
Now we're going to hear from Eric.
Okay.
Yeah.
It's just like that.
All right.
Yeah.
So my name is Eric Jacopin, indeed, and I work, indeed, at the Center for Research of French Military Academy.
First, let me say a few words about analytics, because I'll be speaking of GOAP analytics, and I want to explain first what I mean by analytics.
Data analytics is the process of collecting and extracting pieces of information, meaningful pieces of information, as input for various kinds of decisions.
It's a business, really, and money comes from the processing of user inputs.
Well, yes, of course, in the case of game analytics, users are players, as you can see on the left.
And money is part of the game, yes, right?
But not only, various kind of graphics, such as heat maps, and I refer you to that paper, Beyond the Heat Map, which got published in the now closed Game Developer Magazine, not too far ago.
Okay, what about GOAP analytics, which is the topic of my talk.
Am I going to make money with that?
We'll see.
But most of the time, I'll be showing you graphics.
First, you get to collect data.
I'll be speaking on both free games.
Obviously, you got that.
I'm going to speak of Shadow of Mordor.
I'm going to speak of Fear.
And yes, I'm going to speak from data I was able to get, thanks to.
Chris here from the Rise of the Tomb Raider.
By the way, Rise of the Tomb Raider is in alpha version, it's due later this week.
So the data I got are only from a few slices of the game.
And by the way, also I'll be showing some red circles to focus on some parts of my slides.
I'm gonna do that right now.
So please don't look at how many files, but just compare the columns here.
What we get from fear to Shadow of Mordor is five times more plans in half the time and what we get from fear to Tomb Raider is a third of the plans Yeah, only 16 minutes, but only in the 15th of the time.
So what kind of data you can have?
From here, I was able to modify the SDK because the software development kit for Fear was released one year after the game, 2006.
So I was able to modify it.
It took me some time.
And I produced some data.
Then I put it here, but what you have to focus on here is the fact that I used different fonts and different colors because the data from Peter, for instance, is different from the data from Chris.
So let's first focus on the last piece of information, 2.1.3, 2.1.3 are plan glance.
And the first thing you can do about all this file is just ask yourselves, well, what do my plan glance look like?
OK, here they are.
How long are Go plans?
Well, Peter told you, yes, Go plans are short.
Indeed, they're short.
Most of the time, they're one or two actions, and that's it.
Yes, you can find some actions of length three and length four in both Theore or Shadow of Mordor.
No, no playing of length three in Shadow of Mordor.
I don't remember that.
But that's it.
All right, plans are short.
But despite the fact that RISE is in alpha mode, you can see that Go planning in RISE works already very nicely.
And that I expect from the last screenshot Chris showed that the plans would be even longer than that.
So now let's focus on the second piece of information here, no name, intro and this machine gun guy at the campfire.
What you can do is just gather all the plans from these guys and ask yourself, well how many plans per NPC?
Good question, I'll be using those rectangles in those graphics.
Those rectangles are whisker boxes and here is how they work.
They display a set of value.
The first thing to know is that white line, which represents the medium value.
It separates the set of value in 50% above and 53% below.
In the black line, represent the average.
At the bottom you have what they call the lower fence, which is just the minimum value of the set.
And then of course you've got the maximum value and the rectangle separates again the above and below subset in two.
So now let's get back to that.
There's kind of a waterfall here of all the years, right?
So on the y-axis, you get the number of plans per NPC.
It doesn't go very far, OK?
But it's been decreasing over the year.
So it's 2005 and about in 10 years.
And then you can see decreases also for a rise.
But then increases because I got two sets of value.
Something they didn't tell you is that there are two kinds of plans.
successful plans and failed plans.
For the far right box, I got both plans, right?
Failed plans are plans which have been generated by the planner, but they're not to be executed by NPCs for some reason.
So now we can focus on timestamps plus NPC ID, and we can combine them and make more complex graphics.
That's what I call session castings, okay?
So on the X, you can find milliseconds, despite the fact that I got microseconds, milliseconds, and seconds, and blah, blah, blah values.
On the Y-axis, you can find the NPCs, right?
And here is what they look like.
So what is interesting here is concurrent active NPCs.
You got concurrent active users on web pages, right, for data analytics.
For game analytics, you got concurrent active players, while you got concurrent active NPCs for a go planning as well, all right?
And what you can ask yourself is how many concurrent active NPCs you can get in a game.
So again, whisker boxes.
Here I show all the sessions, all the data I have.
17 files on the top graphic for F.E.A.R., seven for Shadow Mordor, and four for Tomb Raider.
And you can see from the data, from the y-axis, that both F.E.A.R. and the Rise Alpha version are similar.
But it's not at all the case for Shadow of Mordor, right?
It's 10 times more.
the number of concurrent active NPCs for a Shadow of Mordor runs up to 150, which is just amazing.
So now you can ask yourself, why I showed you this one, right?
Because I showed, why you didn't see it in my previous slide?
Because I showed the intro part of the game, which is very linear.
when you play the game, the very first minute, there's only a few NPCs on screen.
So now you can ask yourself, yes, can we see the other ones where you have 150?
Yes, you can, of course.
Here they are.
They don't look the same at all, right?
It looks like it's amazing because if you look at the top left one, you have up to 400 NPCs on screen.
I don't know if you play that game, but it's kind of amazing.
You can go at the top of a fort and look at them moving.
Okay, and one critical thing now is, are they all calling for planning at the same time?
And how close?
So one difficult graphic here, how many NPCs calling for go?
So if you remember what Peter told you, there is a 50 NPC limit, right?
The 50 NPC limit on both graphics is that dashed red line.
The easy thing is the maximum number of NPC calling is blue and the mean, the average is black.
And on the x-axis, it's something difficult here.
It's the width of a time window which slides along all the session files, right?
So for instance, if I take a time window of two seconds, well, I slide that time window along all the session files and I record, I count how many calls for planning per NPC appear in that time window.
And you can see on the left, there is something critical, because it's a thesis.
There is only 0.4 second to reach the 50 limit, right?
You go above the 50 limit after 0.4 second.
In general, in the seven sessions, Peter sent me, it's about two or three seconds.
And it go well above that, right?
It can go up to 70 when it reach 10 seconds, but then 10 seconds is not much a problem for real-time planning, right?
Yeah, I'm finishing.
How fast is Go?
That's a good point.
I cheated here.
I introduced two more games, Killzone 3 and Transformers 3.
They don't use Go planning, they use HTN planning.
But I thought that would be interesting because I got data from that, Orion Bear from Guerrilla Games produced the data and Troyan Fraze when he was at High Moon produced the data for me.
And you can see that HTN planning is way faster than fear.
Okay, no problem.
And way faster than the others as well.
But if you look at the RISE Alpha, which includes, and it's only the Alpha version, right, which includes both successful and failed plans, it's as fast as what is done in Transformers 3.
And I think it's a success, really.
Money.
where does the go power go?
That's the last slide I have here, last complicated graphic.
So on the y-axis you get the cumulative action frequency.
I didn't spoke about that before.
But what you can do is record how many times an action appears in a session file, you know?
And then do that across all session files and do the cumulative frequency.
And what is amazing here is that it suffices only that you get only two or three actions to reach a cumulative frequency of about 20 percent or 30 percent.
And you can see, for instance, I'll take RISE first.
So RISE, there is only two actions which swallow the planning power.
You reach almost 60 percent of the number of occurrences.
And you can see in F.E.A.R. that you only need two actions to reach 50% of the number of occurrences in all files.
So, at random, if you pick up one session file from F.E.A.R., well, there is a lot of chance you'll find those two actions everywhere.
They're for animation purposes.
They reduced that a little for Shadow of Mordor, but it's about the same.
And what I expect here is one rise goes from alpha to beta and then finally the curve here will be the same of the others So it's a kind of 80-20 rules, right?
Which means 20% of the actions are enough to swallow 80% of the planning power Which means, on the other side, and that's where money comes in 80% of the actions swallow only 20% of the planning power.
So some of these actions in ShadowModder almost never appear, right?
It's pretty, I got 33,000 actions, 33,000 plans in all those files, and some of the actions appear only once.
So here is the ratio.
8 actions to produce, to swallow 80% for fear, 14 for shadow murder and 4 for rise alpha.
So goop decision making. Design short plans. I won't say that enough again. 3 actions at most I'd say. Money, make sure the 80% of the action using 20% of the goop power were worth the death effort, really.
Try to use, okay I didn't speak about that, but try to use action costs to influence action usage.
Although that's unsure, but we can speak of that in the questions or later.
Implement planning coding.
Graphic coding exists for polygons.
Why not planning coding?
Both Chris and Peter described many ways of doing this.
I just wrote two here.
Set a limit of the number of NPCs calling for planning.
That's the 50 limit.
And while you're at it, set a limit on the number of NPCs as well.
And then you'll be able maybe to reach simple planning.
Yes, on the right I added that nice green and red.
It's a planning heat map from Rise.
And on the left, it's an experimental graphic from Shadow of Mordor.
So I used many of her references.
Probably the best on analytics is not a computation or statistics book, it's a guerilla analytics which helps you organize all your files.
And I found that very, very useful.
All the graphics I produced with Mathematica.
Yes, I want to thank Chris and Peter for producing those data. Chris is definitely in crunch time and he's been producing and helping me for that. Peter produced videos, gigabytes of data for me. I want to thank Ariane, Alex, Carl, Jean-Francois Gautier and Triumph RISM and Geoff Harkin who answered all my Siri questions for the past four years. And I guess it's time for questions.
Three minutes.
Three.
Three means three questions.
Yeah, about three minutes.
Oh, three minutes.
After conveniently one minute each.
Okay.
Alright.
So, yeah?
Yeah.
Do you...
Me?
Have you thought...
This can go to anyone who's done it, whoever can answer the question the best.
Do you have any systems in place for allocating more complex plans or...
How do you think the process is going to work?
So, I'm going to start with...
So, I'm going to start with the...
Yeah.
I'm going to start with...
The first question is...
Okay.
... the first question is...
Okay.
... how do you think the process is going to work?
So, I'm going to start with...
Okay.
Just devoting more CPU resources to NPCs that the player would be more likely to be engaged with, and then less time for NPCs that they would be paying less attention to.
Does GOP handle that, or have you thought about ways to do that?
Let's each take a turn.
I have a planning frequency that's dynamic for my NPCs.
So the ones that are on screen or near players get to plan more frequently.
The ones that are far away and off camera don't think very often.
Yeah, I'll just go ahead and say shadow mortar, we had systems like that in place. We had timings like that in place for actually for a lot of our supporting systems. And we didn't really, that's actually when Eric first started talking with me. I was looking for that system for our planner and we never ended up throttling our planning, our replanning occurrences. I think throttling the other systems that would cause events to change to cause a plan ended up just naturally throttling the planner for us.
AI ratio for Guerrilla Games Killzone 3 was 5 hertz.
Hi.
I teach game AI.
And one of the things I really don't know is what studios, how much of the back-end solvers and planners they develop in-house, and how much they use from off-the-shelf products.
And if there are anything that you use off the shelf, I'd love to know what those titles are.
It's all you, Eric.
It's all me.
Zero.
All in-house?
Yeah.
Yeah, I can say the same.
Like I said in my presentation, I wrote the Go library, which is still about 90% intact from 2006 in about two or three weeks.
We do use, I'll put a plug out for Babelflux's navpower for navigation.
Even the front end drag and drop stuff that you were doing?
You'd be amazed.
Great.
Can you talk briefly about how you actually organize joint behaviors?
Oh, Ben, yes. Hi.
Between like the orcs, where basically one says I'm going to go investigate, is there a blackboard system that says this NPC is assigned that role, or how's that role management?
Yeah, there's definitely a blackboard system. We actually have...
Oh, hi.
It'd be a lot to get into. We have both a working memory system, which is...
Yeah.
Thank you. I'm not sure how much detail I need to go into on that. A working memory system where we can generate collections of facts and a blackboard system that, yeah, that's both centralized blackboard for all the orgs and, of course, a blackboard per individual org.
On TubeRaider, we have a system that hands out cookies.
Only so many guys are allowed to investigate.
And the way it works is when there's an event that is investigatable, I delay the processing of the event, depending on the distance, so that the guy who is closest is the first one who's going to get a chance to plan for it.
And if he decides to investigate it or react to it, he'll do it.
Otherwise, the next closest guy will give it a try.
This kind of thing.
