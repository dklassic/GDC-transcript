Hello everyone, thanks for coming. I'm super IP to be here today and I'm very happy that you are all here because else it would be a bit weird for me to be here right now. Um before we start, shocking announcement, I need to request that you silence your cell phones because you don't want to be that guy and um I need to remind you to fill in the survey that you'll receive at the end of this talk. Now that this is done and out of the way, I'm going to It's my pleasure to present to you today Assassin's Creed Origin, monitoring and validation of world design data.
But this talk could also have been called how I got to listen to more music while developing this game.
I'm Nicolas Routier, I'm a design technical director at Ubisoft Montreal.
I've been there for 15 years now.
I've worked on several brands, including Far Cry and Prince of Persia.
But for the last seven years, I've been on the Assassin's Creed brand, where I ship Assassin's Creed Revelation, AC4 Black Flag, and lately, Assassin's Creed Origins, which I'll refer from now on as ACO.
So as a technical director in Montreal, I get to work with the content creators, the world designers, the level artists, and with the tools, engine, and gameplay programmers to create the.
world creation pipeline that we'll use to create our game world.
I'm also the person that programmers and content creators will come to see when something breaks.
So you can imagine that I don't get much time to listen to music because I'm always being interrupted throughout the day.
But enough about me.
Why are we here today?
Well we're here because on ACO we were faced with a problem.
Or should I say a challenge.
or an opportunity.
This problem was created by the world that we're trying to make, the scope of the game that we're trying to make, and all the data that goes into that world to create this game.
How do we test all of that data?
How do we make sure that everything is fine and tested?
So we're here today because.
I want to share with you a solution that the ACO team, it's not only me, there's a lot of people involved in this, developed to tackle this challenge.
I think there is something in that you can bring back to your production, no matter the size of the game or the type of game that you're making.
We'll then talk about the impact that this solution add on the production of our game.
As I said, the problem starts with the game that we're trying to make.
So who here played ACO?
Cool.
Thank you.
So for those of you who don't know what ACO is, it's a massive open world game set in ancient Egypt, where the player can explore tombs and pyramids and the full country of Egypt, from the tombs of Giza.
to the beautiful, lush Nile Delta region with its farm and its fields and its dangerous animals, to the beautiful cities of Alexandria and Memphis.
All of this world is filled with persistent, a new persistent AI system.
So as you can imagine, developing a game like this requires the work of hundreds of developers.
Hundreds of developers that create an insane amount of data every day.
And they make this data using new tech that we develop during the production of this game.
So as you can imagine, developing game data and new tech at the same time brings its own challenge.
We also use procedural to create much of the game world.
So because of all these moving parts, a lot of stuff can break often.
And that's the problem we're trying to solve.
We need to know when things break.
So before to dig into the solution that we've developed, I'll explain how we build things and how we break them.
So here is a small village from Egypt with tons of debug data being drawn.
Let's build this.
So first, what we would do is a world designer would come in and start placing buildings.
And then he would place ladders so that the NPCs can go up on those buildings and the players as well.
We'd then place a trajectory all around the location to tell the procedural system not to place any trees inside this location.
We'll then create another trajectory to tell the system to create a road going through this village.
And then it will continue placing gameplay ingredients like the zip lines so that the player can move freely through the environment.
And an artist will come in, start placing vegetation, trees, bushes, and then we'll place A stacks and other gameplay ingredient, light sources, collectibles, and then we'll place all the necessary data for the AI to use this village.
So at the end it's a big mess. So, how can we break these things? I'll give three examples. First example is about the zip line. So the zip line is a fairly simple ingredient. The player jumps on the rope, slides down the rope, ends up at the target position. So let's break this. It's the same set up from a side view. You can see the rope between the two posts.
So let's suppose that a level designer or a level artist or procedural system places a tree in the middle of the row right here.
Well, now we have a problem because the player won't be able to reach the intended destination.
So that's a problem.
This is broken.
What if for level design direction reason or art direction reason we want to make this feel more epic or we want to allow the player to steer across the river? Well, by doing this, the angle of the rope is too high now. So the animation system, the player behavior won't be as fluid, will be glitches, it will impact the player experience. We don't want that. That's a problem.
The next example is about our meta AI system, the persistent AI system I talked about at the beginning. Uh the meta AI system is a system that tells every NPC of the game what it should be doing right now. So every NPC has its own schedule. When does it wake, wake, wake up? Go to work, eat, socialize, and go back to sleep. Every NPC has its own uh schedule, so guards has a schedule. So when you destroy the town you get a reward if you have all the orbs. When you They wake up, they go patrol, they go back to eat, they go to sleep.
Farmers will go work the farmland instead.
You get the idea.
So when the Meta-AI system tells an NPC what it should be doing, it will also tell it where it should be performing that action.
And the where information is in the AI network.
The AI network is a high-level representation of the game world.
It's made by and by-level designers inside the game engine.
um it's a collection of nodes and edges that are linked around the the world and this is what allows us to um have NPCs travel throughout the world even though the player is not there because this is always in memory. So once an NPC is near the player it will still use the AI network to move around so targeting nodes but it will use the nav mesh to move from nodes to that's a very eye level view and super fast overview of this system. Um, if you want to know more, you're in luck because this is GDC and Mr. Shalala5 over here will be talking about this whole system tomorrow, um, at ten, ten AM, so tonight no parties. You have a class to attend. Um, so we will explain the whole meta AI system. So let's take a look at that AI network. This is a RAM part. So this is a RAM part. This is a memory part. So this is a RAM in a fort in Egypt. So you can see here the nodes and edges highlighted in yellow. So if we suppose there's a guard that can spawn inside of this rampart. Suppose it wants to reach one of the pink nodes up in the rampart. So one of this potential position. Uh how you will get to there, it will start by using the AI network edge that is on the ladder to go up and then it will be able to reach one of the guard position. So if the player comes in, the MetEye system will go, alright, let's fight the player and it will take one of the guard and say use the ballista to fight the player. So the ballista here, the uh, basically a turret that the, the NPCs can use. So the NPC will be able to pathfind to these nodes and fight the player off.
when night comes the system will tell alright time to go to sleep and the NPCs will be able to use the network to reach their sleeping positions. All of these nodes as mentioned needs to be on nav mesh. So here we can see in green all of our nav mesh for this location and so all the nodes are above valid nav mesh. This is what allows the NPCs to path find from nodes to So, let's break this now.
Suppose that the level designer or level artist for level art dressing pass or to add cover information for the player, cover objects, add two shield props here right here on this ramp part.
Well, when they added these things and we generate nav mesh, what might happen is that an AI network node might be off nav mesh.
So this is pretty bad because if an NPC tries to reach that node, you'll never be able to because there's no nav mesh leading to that node. So in this case, who broke the system? It's whoever pray- placed the, the shield prop. So it could be a designer or an artist. Um, But maybe the artist or designer that did place that shield there did his work correctly and it did generate navmesh and made sure that the node was still above navmesh. But perhaps a prop modeler in another studio received a bug about this shield prop saying that there is a navigation problem for the player in a certain, when you collide with it in a certain way. Um, So he fixes the collision, checks it in, make sure it's fine, it works well.
It doesn't create any problem for dislocation he's been assigned to.
But this shield is being used everywhere throughout the game.
So now, next time we generate NavMesh, we have the same problem.
So who broke it this time?
It's a prop modeler by fixing a bug.
Now, another way we can break this is, Let's suppose an engine programmer changes or updates the fixes fix a bug in the nav mesh generation system and we end up with no more nav mesh in every slope of the game. Or every stair flag a certain way. Well now we have no path find no valid path on the nav mesh between those nodes. So once again, no one will be able to lose use these ballistas and no one will be able to go to sleep. So who broke up this time? The engine programmer. The last example is about our procedural placement.
To replace our asset, we use Udini Engine.
And what we use it for was placing vegetation, creating roads, and placing cliffs.
The next example would be about vegetation and roads.
So as we said earlier, to create roads, the artist or designer can simply place a spline through the world.
It will create a road, and it will make sure that vegetation is placed next to the road.
and this result in beautiful navmesh that the NPCs can freely use. But as we develop the system, um, it would happen sometime that trees would end up in the wrong location. So this is pretty bad because of course then we generate navmesh and we have holes.
on the in the navmesh because of the tree trunks and so it's bad for AI network because no navmesh is not good for AI network uh and so no one can use this road now. No one can reach their their location. So once again this is broken. Who broke it this time? Could be the tech artist that tweak the Udini rule um to place trees. But it could also be a code error. Maybe it's a build machine that uh didn't load in the right order all the data that was required to process and build the procedural content. So it ended up having trees on the road. And this sometime also happened with rocks. And so in this case this would be very broken. So to recap who breaks things, well it can be content creators as they create their location initially or as they iterate on them or fix bugs. It can be programmer.
it can be the push it all system. So the answer to who break things is everyone. All the time.
For a lot of different reasons. So this is why we need a system to track all of that. We don't want to everyday run into these problems. We want something to find these problems. So usually how would we go around to solve this problem? Well we would give everyone a checklist.
that they need to run through every time they do task X.
Verify this, this, this, and that.
And once you're happy, we're done with the checklist, we check it in, and then we rely on human testing.
We tell the designers, the artists, and QA people to test everything in the location, make sure everything is fine, play every quest that can be in that location, and make sure that they work.
And once we know that everything works, we'll lock the data and make sure that no one touches it again because we know it's fine and we'll ship it. Problem is, this is the village we saw earlier. It's just one of the 500 locations we have in the game. It's this tiny dot over here and these are all the locations that we have in the game. To give you an idea of the size of this world, we have a lot of data in this world. We have a lot of This is London from Assassin's Creed Syndicate, so it's about 12 square kilometer, it was quite a large city. But it's just 10 percent of Assassin's Creed origins. Uh, Egypt is over 120 square kilometers. So because of the scale and the complexity of our data, it's very challenging to have complete coverage using our traditional testing methods. So we add to make our methods evolve.
needed a solution to help us tackle this huge problem. So, let's talk about that. Sorry. So, in a nutshell, it's daily automated testing of world design data. Keywords being daily and automated. So everyday, we have a set of input that are being fed into a data, data analysis system which perform.
an array of tests. And then we output all the information necessary to understand, find, and fix these errors. It sounds very simple, and it is, conceptually, uh but for us it was a game changer. So let's talk about these inputs. So, uh, so, so, so, so, so, so, so, so, so, so, so, so, so, so, First, there's the world data.
This includes all the end place data.
So that's the buildings and the trees that the artist and designer place in the game.
That's the chests that the designer place in so that the player can loot stuff.
The ladders, all the interaction items that the game features.
We then have the procedural content, which is being built by Build Machine and checked into the data.
And the nav mesh as well, which is also being built by Build Machine and checked into the world data.
We don't have code.
It's weird to say that code is an input, but basically the point is that we always need to test with the latest code.
Because what if gameplay code changes?
What if, for animation reason, a gameplay programmer needs to change the angle threshold that we can't tolerate?
This is the point to be at.
Well.
it could be that because of that new animation we need to lower the threshold and so zip lines that were placed in the world and that were valid are now invalid because of that new code. If that happens, we need to find out. And once again, if we change the engine code, if we change the way NPCs path find through the world, well, now we could also break something that used to work, an NPC that was able to reach a location can no longer reach a location because of a code change. So we need to know when this happens.
Lastly, we have our game design intentions.
And the keyword here is intention.
Basically, it's an Excel file listing all the location of the game.
And for every location, we say, what is the type of the location?
What should the player be able to do there?
Can the player fast travel to this location?
What is the type of loot that we can find?
So on.
This is the level design director fills in this information.
And this is what we expect the designers to put in every location.
that's it for our inputs. When we have all of that data we feed it in our data analysis system. This is simply a collection of automated tests uh that run on all that data. Uh but before talking about these tests and giving you examples about them I want to talk about how we write those tests because it's really a cornerstone of uh our entire effort. And that's anvil script. Anvil script is a feature that we have in our uh, game editor tools, which are, which is called Anvil. Uh, it's basically C sharp script, um, that run inside the game editor. And using these scripts, we can query every piece of data in the game. I can access a chest object and know what is the loot inside the chest. What is the mesh of the chest? Where is it in the world? What is its recurrent rotation? And so on.
and I also have access to all editor features and most game engine features. So we can do raycast to query the collision information of the world, we can do shapecast, we can do uh pathfinding test on the AI network to know to make sure that people can reach their locations.
this is some code because it's cool to have a code slide. Um so here we're simply going through a list of location looking for for stuff. Uh we'll talk about that later on. Um these level scripts were written by TDs like myself and my colleagues. So uh we have 3 broad categories of tests and these includes placement metric tests, AI network tests and location tests.
For every test, um, we have a checklist basically for every type of test. Uh, and these tests are objective tests. It's either true, false, pass or fail. Zero, one. Um, every item, every object has its own list of tests and guess what? Computers are really good at this type of test. So, we decided to use them. So, let's take a few examples. First, about placement metrics. So, let's take a few examples. So, let's take a few examples. First, about placement So this is our friend the zip line from earlier. Um we have to make sure that nothing is in the way of the player right? So what we do is we make a big shape cast underneath the rope and we make sure there is nothing placed there underneath the rope that would block the player.
Like a 3. So if we do find a 3, we don't want that, that's a bug, we report an error.
Like I said, we need to validate that the angle of the rope is within the accepted threshold.
So here it's fine, there it's bad.
Super simple for a computer to do.
Just compare two points and you get the angle and you report an error if there is one.
In this case, there is one.
So we do this type of test on.
uh, variety of, uh, of, uh, gameplay ingredients like navigation ingredients, interaction ingredient and, and spawners. Uh, the type of test that we would do on the, on the chest is make sure that it's oriented in such a way that the player will be able to loot the object. For spawners, we'll make sure that there is nav mesh. If it's a boat spawner, we'll make sure that it's over water. Um, this type of thing. In total, we have 22 object types that we test.
And once again, every object has its own list of tests.
So, some of you right now might be thinking, there's nothing new in this.
Like, we've been building worlds before, and we've been successful, so why not just, you know, use the same things as we did before, just use more testers?
Well, let's do some math.
There is 228 ziplines in our game.
Let's suppose that it takes two minutes for a tester to get to the location, load the location first, get to it, test it a bunch of times, and if he finds bug, report the bugs.
Well, this would take one tester a full day of work, so eight hours, just to go through all the zip lines.
And that's once, only one time.
Now the kicker is that From the previous slides, I thought there was 22 object types we test.
These ends up being over 200,000 instances of ingredients throughout the world.
So once again, if it's two minutes to test one instance, then it would take 20 testers two full months to test everything once.
So that's a lot of people to test simple things.
So forget it, it does not scale. We cannot rely on human testing. We need, we need automated tests. Second example is about the AI network. So as we said, we need, we, every uh AI network node needs to be over a valid nav mesh.
very easy to know if they are over navmesh. We simply go through all the nodes and we check underneath them, cast array down 50 centimeters and make sure there is navmesh underneath the the nodes. So here, there are two nodes that are not over navmesh. So that's two errors that we report. We also need by definition, every nodes that are linked by an edge, there needs to be a valid path on the navmesh linking the two nodes.
So in this case, we have four edges that do not have a valid path to reach node A to node B. So here, we have a problem.
Four errors that we need to report.
As we said, every NPC has a schedule. And every schedule, every action in the schedule is associated with a station that the designer places in the world. So, where they should be eating, sleeping, working. Um, so we need to make sure that when we spawn an NPC, you will be able to reach all these potential stations that the schedule will assign you to.
So what we do is we take the spawner, we look at the type of unit that is in there, if it's a guard, we go through that schedule and we make sure that every potential station he would like to use is reachable from his spawner. So here in this case, if the player shows up and we need to tell the NPC to go use the ballista, we will tell him to go to that ballista. The problem is, there's no nav mesh in the stairs. So the NPC won't be able to reach that. So that's a bug that we need to report.
It's super easy for a computer to do this test. It's super fast. And you can do it every day.
But for a tester, it's not super easy to notice that when I did fight NPCs in this location, no one used the ballista and yesterday they they were using it. Uh if your tester are able to give you that information every day, keep them. They're really good. Alright and last example is about location tests.
So remember the Excel file we talked about with all the intentions? Um well this is where we use it. This is a bandit camp in the desert. So in red around the bandit camp you see a trajectory that we call the footprint. Um using this footprint we know that everything that is placed inside belongs to that location. So everything here belongs to that bandit camp.
So if a world designer places a chest inside that tent, inside the footprint, then we know that this chest belongs to this location. So we can then cross reference the information of the loop type that is inside the chest inside the game with what we wanted from the the design intention document.
by doing that we can see that here we found we were expecting to find one high value item but we found zero and we were expecting to find zero rare value items but we found one. So here the designer simply used the wrong loot type and we can just go in and change it.
So, these were just a few examples of a test that we do run on our data. We have much more tests than that. But once we have all these tests and gathered all of this, this information, what do we do with it? Well, we need to communicate it to people so that we can act on it. So, we do that through our outputs, which are, uh, Excel files, emails, and Atlas. Let's take a look at the Excel first. Each test that is done, uh, writes its result into an Excel file.
the excel file contains all the information needed to understand, find and fix the errors. So here we can see the excel file generated while we are going through all the zip lines. So here in the columns you can see the name of the zip line, it's unique ID, is it valid or not? And if it's not valid, we have the error written in plain English saying what's wrong.
And lastly, we have a link that, if clicked, will take you exactly to the location of the error in our game engine.
So this is an example.
It's quite simple.
It's a simplification of our Excel files.
Each test writes its own Excel file.
But to give you an idea, the location test, the output, an Excel file that is over 50 columns, because we do a lot of different tests.
So once we've generated our Excel files, we can then generate an email. And in our email, we create a summary of the information that we found during our tests. We send that email to everyone in the world team. So that's every world designer, every level artist, every managers, technical directors like me, and uh QC members. Here's a snapshot of uh one of the first emails that we we sent using the system. So as you can see it's in 2016. So There's only four object types that we're testing.
You can see the total amount of instances we found in the game world, total amount of valid objects, and total amount of invalid game objects.
This is the summary email.
This is not the Excel file.
So we have a link that will take you to the Excel file if you want more information.
So as you can see, we have 1,000 ladders.
and 75% of them have some type of problem with it. So that's not good. That's another snapshot from later in production. 5 months to store shelves. We have now 18 type of object that we test.
uh we did several improvement to the system but something that is very very cool and turned out to be really useful is that we have the delta with the previous error uh with the previous error count from the day before. So we can see in green which is good uh that we're fixing errors getting rid of invalid um ingredients and you can see in in red the invalid ones so that's bad. We don't want red. Um And uh big columns at the end is uh we split up Egypt in 5 regions with 5 sub teams, each with their own managers and teams of uh designers. And we would assign every error to the region so that each individual team can track how good they're doing. Or bad. Uh you'll notice that we are now have 1300 ladders with only 7 left to fix. So, go team.
last output, uh, we wanted something to visualize our error. Because so far we're generating Excel files and emails. That's a lot of boring text. Um, and not everyone, well managers enjoy text and Excel files, but most developers, they, they're more of the visual type. So we wanted something that we can see visually what's going on.
So to do so we outputted our test to something that we call Atlas. Atlas is a Nintool uh an in-house tool sorry developed at Ubisoft Montreal. It's basically Google Maps for our game world. So with it we can pan the game map, zoom in and look at the data that we have there. But the cool thing is that uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, uh, it's also web house, sorry. Web house, web base, developed in house. Um, the cool thing is that through Envelope Script, we can write to a, to Atlas. So, when we find an error, we can create an icon and put it on the map at the exact position that we found the error at. So, I'll show a quick work, uh, quick video of Atlas in action.
So you can see the game world map and on the left side there's a bunch of layers. Every layer is a gameplay ingredient test. If we turn them on, we'll see the content of these layers. So you can see a few red dots. And if you do click on the dots, we have the same information that we have in the Excel file, so we have the link.
to the game editor.
So if you click that link, it will open up Anvil, our game editor, and it will take the camera and put it exactly where the error is.
So it makes it really simple and fast for content developers to find their bugs and to get to fix them.
So it makes things way faster and way easier for everyone.
It's almost too easy.
And this is pretty damn cool.
You're saving a lot of time and people are really enjoying this feature.
that was our inputs. If we recap we have inputs which are world, world data, code and design intention that we then feed into our data analysis system and from there we create a bunch of outputs to excel, email and atlas. And this is done every single night on a dedicated build machine.
And in between, we fix the errors by going in and fixing the data or code. Um, and then we improve our tests. Make sure that we output more information so that people can fix their problem more easily. But we also add more tests. Cause like we saw, we started with 4 gameplay ingredients and we ended up with 22. So we keep improving the test based on how the production goes. So a few, a bit, a few stats about the system.
this system runs on one build machine and it takes three hours to execute. Most of this time is spent loading the game world actually. Running the test are super fast. Uh we generate 12 reports from there which are in our three broad categories of test. And we test 500 look over 500 location making over 150,000.
pathfinding tests, testing over 200,000 gameplay ingredients, testing over a million AI network nodes and edges, and 5 million procedural assets being placed in the world.
And that's every single day, automatically.
And that's it.
That is it.
That's our solution.
It's simple in concept.
It's simple in execution, but for us, it was a huge game changer and it made a huge difference in the shipping of our game.
And we'll then talk about the impacts and why was it such a big impact on the production of our game.
Well, first water.
It has a big impact because a system like this has several benefits that are not all apparent on the surface, but...
Because it's simple, you don't see them right away.
But once you start using it, it's really a big difference.
So it's been very useful for the quality of our game, but it also greatly improved the quality of our life as we develop this game.
So what are these benefits?
Well, the first one, which is quite cool, is that we ship this game.
with a relatively low number of bugs in the tested systems. And let's be clear, uh, we would never be able to ship this game with the, uh, the same scope, same size, same quality in the same time frame if it wasn't for this system. Um, I'll then talk about how this system changed the way we produced the game before and now, how it gave us quantifiable data and how it led to a smoother debug. So regression.
every game I made there was always regression so at some point, well every week, if not every day, uh so we need to know about the regressions. So basically what would happen before, alright, um a regression would go like this. I would get into work, coffee and end, sit down at my desk, put on my headphones, start listening to some music, and then 10 seconds into a track someone would come to me, bump on my shoulder and go, hey Nick!
Ladders are broken in my village. I don't know why.
All right. Have you read the documentation?
Yes, I did. I did read the manual.
Really? You did that?
Awesome. Thanks, man.
So, I'll stand up, go to his desk, start finding the errors.
I cannot find the errors. Uh so I'm starting to wonder what's going on. But luckily there's another level designers she uh standing by she says hey I have the same problem in my location can you can you help me out please? And so whoo okay nice. It's not an error only in this location it's it's everywhere. So that's bad. Um.
So now, okay, we need to figure out what's going on, so I would ask you, see, have you seen that anywhere? Please go check all ladders everywhere. And then I would need to start invig- investigating looking at if maybe programmers did ch- changes in the ladder, so the, the, the, the, um, player navigation ability code. Uh, I would look at the original ladder prefab that we're placing in the world was, did someone change something yesterday that could have caused this?
So basically I discover the regression at some point during the day, usually very early, and I don't know the scope of the the error until I dig and find the uh the error. But now, what happened is I get to work with my coffee, sit down at my desk, put on my headphones, put on some music, and then I go through my emails. Because I have a daily report by email.
So then I can look, see gameplay ingredients, ladders, plus 500 in red.
That's not good.
So right away what I do is I write an email to my world design team and I say, all right, there is a problem with ladders, we know about it, we'll investigate, don't come see me.
So I know the scope, and so I can take the right decisions and talk to the right people from my desk, listening to music.
So basically I'm proactive.
I'm not reacting to what's going on.
I take the action to fix the problems, because I know I'm on the problems.
The system gave us more iteration time.
So before, when we created the...
we integrated data in the world. Once we integrated all the data that need, that was required for one feature, we would ask QC to do a pass and test that everything is fine. We would give them a checklist. Please go through all of that, make sure everything is okay and try to break it. See, see, see if you can break it. And once we, they report the bugs and we fix them and then it's solid, we lock the data.
because we've been through this pass, we fixed everything, lock it down, we don't want to break it again, we'll ship that, we know it works. But now, with daily automated tests, we're a bit more confident to change things because every day we have tests being executed. We don't have a fixed number of QC pass. So, uh, we're a bit more confident to change things. So, we have more iteration time for content creators because we allow them to change things much later into the production. Uh I think you'll agree that more iteration leads to more quality.
So that's why I'm sure that the system helped this game have a very uh good quality level. And lastly um finding bugs. The system gave us a new ways to find bug. And I'll illustrate this through the wall torch example.
Wall torch is a simple ingredient.
It's just a torch that is unlit.
It's placed up on a wall, and the player can go next to it with his own pocket torch and light the wall torch.
So one day, late into production, very late, late into debug, actually, should I say, we receive one bug by one tester in one location, saying that one wall torch instance.
did not work. The player couldn't reach it. It was just out of reach. Just a bit too high. So the player felt like he could reach it but he couldn't so that's bad. It's a false call. We don't want that in our game. So alright we need to fix it. But the first thing I think when I receive a bug like this is this is not the only wall torch in the game. There's a few of them.
As you can imagine. So we take a look. There's about 700 of them throughout the game.
So usually what we would do is ask QC. Oh alright, cool. We we think this is everywhere. Go everywhere. Look for all wall torches and make sure that they're fine. So once again uh we would do a QC pass and we would do probably only do it once because this is this is long to do.
Um but now what we do is we write the test. We cast the ray down from the wall torch and we try to find a ground into a certain threshold and this is the threshold that we know that the player can light these torches. So if the wall torch is in the red zone we report an error. And now until the end of the project it's daily and automated. So until the end of the project we'll know if someone adds a new wall torch and it's broken and we'll know if we have a regression about the wall torch. We don't need a QC pass anymore for this. The system gave us quantifiable data and every manager in the room will appreciate that because they know that what gets quantified gets managed. So as a TD it's super cool for me because I can know the numbers of errors that are in the game for feature X, Y, Z. So I can go see the managers and tell them you got 500 error of this, we know it's a data error, we've, we know how to fix it, we train the people, it needs to be done. Or it can also tell the managers that, or a manager will tell me that, please train people on this feature because everyone is having problem as you can see. So uh, it gives us the information to take the valid decisions. And it also tells us the, our current velocity. Are we fixing enough of these bugs to reach our target of zero bugs by date?
X. It also led to a smoother debug cause typically in game production most of the bugs come at the end of the production so during debug this is where we find out about all the bugs so this is where we crunch to fix all the bugs um but that's not so fun. Uh but since our system was developed during production we found all of these error during production. So we were able to allow time in our schedule to fix these bugs and we were able to fix them up front. So basically we front loaded the the the debug phase. And this allowed the uh content creators and the QC team to focus on tricky bugs and focus on putting quality into the game rather than going through everything to find the three in the middle of a zip line. So lesson learned.
uh, we, I would like to have this earlier in production next time around. Uh, well, I would like to have this on every production that I work on in the future because I know that a system like this would have changed the way our production would have been done in the past. Like on Black Flag, I know we would have loved to, to have that. Uh, it would also help us not to find lots of bug at the end because throughout the game we can know that we can find these errors as we develop them.
There's a big dangers of false positive though, so as TDs it's super important that we make sure that our tests are accurate, that we don't report false information because if we do so, um, the people on the rece- receiving end, they, they see errors and then they go in the data and they don't find any errors, uh, so we're wasting their time and so they lost, they lose faith into the, the system.
and they'll never use it again and we've built all this for nothing. So we have to make sure that everything is fine. So it did happen. Um and what we learned from this is that we have to test and use someone as a guinea pig to test the test and make sure that the test is accurate.
And lastly we wrote way too many emails. Um Like I said, every report sent its own email and we had 12 of them, so that's 12 email a day for everyone in the world team. So that's, that's a bit spammy. Uh, but as we developed this, we thought, done is better than perfect, let's just get this out so that people can start using it. This is where the return is. Um, so we just put it out there. Um, maybe in the future we should only make one email with all the information or I'll put it to a dashboard somewhere.
So the next step for us would be to add these velocity chart.
Well, we said that we had the delta for a few of our errors reports.
We didn't have it on every report, but it was super useful.
So we would like to have a velocity chart on every of these reports so that we can see if we're going well.
What's the trend?
Are we fixing our things correctly or not?
A lot of you might be thinking right now, why?
in hell are they not preventing these errors from being created? It's a very valid question. We actually had a few slides about that, um, but uh, for time reasons they're gone. Um, even like error creation is super important and we we have a few of these systems in place but even if you have them, errors will show up. Because like we we said like data that was fine on day one might be broken on day ten for a bunch of other reasons. So even if you have a gate, at submit and make sure or at save or addition to make sure that everything is fine, stuff will go through that will be get broken later by another change. So we still need to have a snapshot and test everything.
And lastly, create more tests.
We are testing three broad categories of objects, of features.
We have way more features than that in the game.
So I'm sure we'll be able to expand that and take it to other features.
And I'm sure that you right now in your head, hopefully, you are thinking of stuff in your game, your own games, that you might want to test with something similar to that.
Lastly, I need to say thanks and mention my colleagues who built this with me.
So I need to say thank you to Kevin Coughlin, who's right here, who built this.
And actually, Kevin co-wrote this presentation with me.
So thank you, Kevin.
Kevin will be joining me on stage for the Q&A sessions.
So please have one question at least, so that Kevin has not come all the way here for nothing.
And I need to mention Roland Levesque and Rémi Toupin-Godet, who wrote a lot of the tests that we've talked about today.
So my colleagues and I have been in the industry for a while, and between all of us, we've shipped a lot of open world games.
We're proud that on ACO, our designers were able to focus on the right things and work on the quality of the game.
Never we've been so confident that the system that we tested, at least, we're bug free and that the player won't find any problems with these systems in the game.
We know that the, the, the, our system of daily automated tests was a major contributor to that and it was a huge contributor to the quality of the game and the quality of the life of the people building that game.
So I invite you and your teams to think about how you could integrate a similar system into your pipeline.
Your game and your team will thank you.
We have 12 minutes for questions.
AUDIENCE MEMBER 5 Hi.
Really awesome talk.
Thank you for this talk.
It's awesome.
I had a question.
What would you do if you couldn't run a script that you can easily iterate on in the editor?
What if you had to go through coders, C++, every single time you wanted to add a test?
What would be your approach there?
Well, so I guess the question you're asking is, what do you do if you don't have something?
If you don't have that NVL script, what do you do?
I've got to say that my gut reaction is you need something like that.
Some of the game teams that we've talked to about this, at the very least, they can maybe run Python scripts to parse their XML files, to extract as much data as they can.
But really, the that easy access to the attributes of all the data, and to be able to run those pathfinding and shapecat tests, that's really such a key part of this that you probably want to look at that first.
Thanks.
Just a few questions.
Did you consider, instead of it just being daily, like doing some sort of continuous integration of the tests?
Yep, valid question.
Um, so, um, some of these tests, they rely on data that is being generated overnight on build machines. So we have, we need that data to run those tests. So that's why we need, we, we decided that we only run the tests once that we generated everything and we have all the necessary data. But yes, some of those tests we could execute every hour. Okay, and uh, because the game is so big and you have all these um, gameplay ingredients all over it, When you're testing, you have to interact with the streaming systems, like, OK, we've got to stream this part of the world and then test that stuff.
OK, then we've got to stream this part of the world.
I may have just said something obvious.
I don't know if there was a question in there.
Well, yeah, you have to load everything.
Because when you're doing collision tests, you have to make sure that every collision are loaded.
So we need to make sure that all the collisions are in the game world so that we can find them.
And yeah, maybe just something to make clear, the tests that we run were all on static data, so you're not actually running the game and having the player go through the world.
So you are, when you talked about it taking three hours to run the test, but most of it being loading the game world is because he was loading the whole game world in one shot, and then running all the tests.
And maybe just another thing about the continuous integration question, some of the tests, like the location test, The level designers could run that test before checking in.
So they were able to go, OK, I got this error.
I think I fixed it.
Run the error suite, and poof, yep.
Either fixed or not fixed, and go from there.
So, and you may have just answered the other question I was going to ask.
So all the tests were for what you could test statically.
And I was going to ask a question of, as you progress through the game's plot or whatever, the world state changes.
And I was going to ask, oh, we have to like.
Tested in this world state tested in this world state test, but it sounds like you're not doing something like that Cool. Thanks Hi great talk, thank you. I just want to ask do you have some way to test some Dependency resources. Let's say I change one one feature one content or some I did some code change, but actually, you know, sometimes I think designers or we want to, we care more about how many other contents or stuff in the world will be influenced by that.
Do you have any thought or any test of using this tool to do that?
Thank you.
So I'm not sure I understood the question.
One thing certainly that is nice in Anvil that wasn't in some of the other engines I've worked with is the dependencies are very clear.
There's a dependency viewer that maps out all the dependencies.
You know exactly, oh, on this object, I wonder what depends on it, boom, viewer, you see exactly what it depends on.
But, and again, because the tests that we run, it's all on static data, we know what the dependencies are when we're doing our tests and we can just go from there. I'm not sure that answered your question? Uh, yeah, part of that, yeah, thank you.
Because you have a lot of content shared in the world, right?
So actually you change one stuff, let's say a collision mesh of a letter, but actually it's larger.
So you find the error in another place.
But actually I want to say, oh, actually this is the collision mesh causing this error.
How's, I mean, but when you, will all of the, I mean, will you, let's see, this letter is, we have five letters of these broken letters in the wall, will you get five error reports on the same, in the wall, okay, so that's, okay, thank you.
Thank you.
Hi, I just had one question.
By the time you shipped this gigantic game, how many red dots were left on your map?
Good question. Close to zero.
And honestly just to be very close to zero, I honestly think it was like four or something.
And maybe just an extra little thing, a question you could have asked also is, well, were there ever any exceptions to the rule, right?
Because sometimes we've got these hard and fast rules, but there's this one case that, you know what?
You're reporting an error on that instance, but it's not really an error.
We had the ability to go to that instance and say, this particular test, don't run it.
We know it's good.
Hi.
So I wanted to ask, since all the objects are in some sort of a database, then why didn't you make the QA team able to create their own tests using something like queries or something on the database, using scripts or anything in the real world, like to help them decide on what to test and what not to?
So why don't we allow the QA team to write their own tests? Is that the question?
Yeah.
Yeah, uh, well, um, we, we wrote the tests ourselves because we were a bit lucky, um, we, we're all, all the TDs that I mentioned, uh, we are super confident writing C sharp code, so it would happen that a tester finds a bug and would come to us and say, hey, uh, there's a, like, something, this always breaks.
can you help us out to find it more fast and if make faster or uh can you write a test for this and we would work with them and we would write the the test ourselves. Uh some of the tests are also not in code they're actually data. Uh so uh we there was ways for people to tweak the the data uh to get more information. Cool well if there's no more questions uh thanks for staying until the end.
