So welcome to this talk on cementing your duct tape.
My name is Matthias van Kamp.
This is my first GDC, so kind of bear with me.
I'm a little nervous for the presentation, but I hope you'll enjoy it.
First some housekeeping before we get started.
Please keep your phones on silent and do remember to fill in your surveys at the end of the talk.
We should have some time for questions, but if we don't, room 3022 will be the wrap-up room.
It's just around the corner of the hallway, so you will be able to find me there after the talk.
So first, who am I, and what am I doing here?
I am currently a senior technical artist working on the Total War franchise.
I'm sure most of you have at least heard of the franchise.
It is my fourth year working at Creative Assembly in that position, which makes it my seventh year in the industry.
I've worked on games such as Divinity Original Sin at Larian Studios in Ghent.
I've also worked afterwards on Created.be, which was an educational game using the Unity engine in the web browser.
where kids would do homework as a currency to progress the game's story.
Very interesting implementation.
And then I transitioned to working on the farming simulator titles in Zurich in Switzerland before eventually making it into Creative Assembly as a technical artist.
I've since worked on titles such as Total War, Warhammer 1 and 2.
I've spent most of my time there working on Total War Arena, which who here is aware of Total War Arena that it exists, right?
A fair amount of people.
I've also worked on the upcoming Total War Three Kingdoms.
Before we dig any deeper into Arena, as those who know Arena will know, it was shut down on February 27th of this year.
So I'll not be fielding any questions about the shutdown, but the talk is more about what we learned from its development.
So it's not because the game is shut down that we can't learn from the things that we did on it.
So first an overview of what the talk is going to touch on.
The first thing we're gonna do is define what technical art really means on Total War.
As I'm sure I don't have to tell a lot of you, technical art kind of means different things depending on who you're talking to, what studio you're at, even the people that you work with or the phase of production that you're currently in.
That depends on, your job description essentially changes over time, which is very interesting.
It makes technical artists a bit obscure.
I brought with me some examples as well from the production of Total War Arena to illustrate what we're talking about today and how we used essentially duct tape solutions to then learn from what we did implementing those hacks or what we considered to be hacks but while being aware that they needed to be removed afterwards.
So we use these things as learning processes really.
Then we're going to go over some lessons, things that we in hindsight wish we had done differently.
Obviously, hindsight is 20-20, but going forward we'll implement a lot of the lessons that we learned from using this technique.
Then lastly, hopefully you'll take something away from this presentation.
So, for those of you who don't know Arena, which is apparently a fair few of you, I brought along a video with me that illustrates, there's actually a marketing material that markets our, one of our commanders, Ambiorix, which has a bit of special meaning to me because I'm Belgian and he is a Belgian folk hero.
So that was Total War Arena.
As you can see, it's a MOBA-style RTS, very high action, a bit of a high action implementation of the traditional Total War franchise.
So onto defining what technical art in Total War actually means.
We are a centralized team.
That means that we work on every single project, which also means that our tools and pipelines need to work, at least theoretically, on every project.
That does of course not mean that some of our tools cannot be project specific.
On Total War Arena, as on Warhammer and on Three Kingdoms, we always have specific solutions for very specific problems.
They all have separate branches of the engine as well, so that means that certain engine tools on older versions, such as Total War Arena, which technically is still a branch of the Rome 2 engine.
certain tools will not be available to us that will be available to other projects and then Total War Three Kingdoms being the most modern one had the fanciest tools. So we end up having different solutions to similar but also different problems because the tech is fundamentally different.
We're also a fairly small team, with just four technical artists we supply support for over 80 clients, clients being defined as just developers who use our tools, mostly character artists and environment artists, but also sometimes animators and effects artists.
That's actually closer to 100 now, and that covers roughly six concurrent game projects, so we're working on roughly six projects at any given time.
Our role in that picture is to establish art pipelines and tools.
We build things like exporters for Substance Designer and Substance Painter, as well as for 3ds Max and Maya.
And we maintain the tools that we build for artists and make sure that their content can get from one place to another in the pipeline as smoothly as possible.
We also play a key role in establishing conventions and standards, which is going to be an important thing in this talk later on, but I'll come back to that.
And probably most importantly, tech artists on Total War, and I think tech artists in the entire industry, play a key role as an interface between art and programming.
I think that's the one common denominator that every tech artist seems to share.
where we make sure that when an artist says, we need this, then by the time that request gets to programming, it's actually what they need, not what they say they need.
It's a genie swish kind of thing.
Because it really happens quite a lot when an artist says, oh, I need this particular type of exporter, but then a tech artist gets their hands on it and says, no, actually you don't, because there's a tool that does this for you already.
And that happens quite a lot and that ends up costing thousands of man hours in some cases or gaining thousands of man hours if you get it right.
Into the meat of the talk then, cementing your duct tape. So what does duct tape actually really mean? I'm sure a few of you have wondered about this.
When I talk about duct tape in the context of this presentation, I'm really talking about very quickly implemented solutions.
There's a key difference with hacks, which will become clear throughout the talk.
And also, they prioritize function over form.
It means we need to get the stuff out the door, basically now or yesterday in some cases.
And that means that when we write the code for these things, we are keenly aware of the fact that this code is going to be dumped in the garbage as soon as the content is out.
Going in, that is essentially the key difference between duct tape and hacks, is a hack will tend to survive, whereas duct tapes, the duct tape solution in this context will be implemented with the idea and the prerequisite that it will be removed afterwards.
Basically, the metaphor for that is plug the leak versus replace the pipe.
So some examples that I brought with me today from the production of Total War Arena.
The first example will go into how we made a data change that led to a host of improvements.
Very important to note with that is that a lot of the improvements that we ended up having were not actually planned when we went in to make the change.
What we did do going in to make the changes was just to simplify our data so our artists would have an easier time interacting with it.
What we could never have imagined is that one of the changes, because of the change we made, one of the things we got, not for free but it became feasible, was an entire dynamic UI pipeline, something that we would otherwise never even have conceived of.
So first example then, the variant cleanup.
This is the term that we refer to on Arena during production as the single small data change that we made, which resulted in a big production speed increase, better tools, and eventually automatic UI generation.
Something that I'm sure a lot of you would be happy with having on a production.
So what is a variant really?
So variants, the term variant came from code mostly.
Basically what it does is it describes the parts that make up a unit or an entity on the battlefield.
The reason that these parts are distinct is because in Total War Arena, and in most Total War games, but in Arena more so, these individual pieces can be swapped out.
On Arena we had an upgradable equipment pipeline, which meant that we needed to have systems to deal with the fact that our units would be upgraded.
This also means that our art assets had to be authored to make sure that they would all fit on the same body, for example, if you had a piece of armor that could be swapped out because armor was a separate mesh.
That means also that you have to avoid skinning issues and debug clipping issues, and of course that also means that you need to have the ability to preview what your unit will look like when it gets upgraded, or rather when it equips the equipment you're making for it.
What we saw actually, in part because Arena was running on a rather old code base, was that the pipeline didn't actually allow for us to preview our units being upgraded as they were in the game.
The reason for that is that multiple systems were added over the years, but very little tools were built to deal with the new data.
Total War Arena was actually the first title in a Total War franchise that had a player-driven upgrading system.
The other Total War games do have upgradable equipments, but it's more system-driven, which means that for artists it's less exposed.
For Arena, it was much more integrated, because we had everything from cosmetics to ranked battle achievements.
Rewards that you could upgrade that you could get and unlock new cosmetics for commanders your units could be entirely customized This is a system that we hadn't built before and obviously the implementation for it was kind of done in a straightforward way ironically in a duct tape way So what we ended up with was a system where all of the individual upgrades were actually stored in separate files Obviously, the obvious result of this is that our character artists could not actually preview the unit before it went to the game.
That means that our character artists had a very tough time previewing their content and making sure it didn't clip with the other meshes before their stuff went into the game, and that actually turned into a bit of a nightmare with QA bugs, and we constantly had to iterate our content to make sure everything was conforming to the same standard.
It wasn't made any easier that a lot of the content we used in Total War Arena was also reused from different projects, both previous and current, to ensure that we could handle the content requirements for the project.
Now the reason for this, really, we found, the first question we asked ourselves is, why is this actually the case?
Obviously, we know that it's because of multiple systems were added over the years, but the question we really asked ourselves was, how does the system actually work?
By visualizing this in a flow graph, it became quickly apparent that basically what was happening is the database contained a reference to some external file that the game engine then loaded at runtime and constructed the variant at runtime.
Obviously the obvious upgrade to that, the obvious step forward, would have been to just implement what the game does in the unit editor.
In fact that would have been the straightforward solution.
However, we didn't want to do that.
Instead, we wanted a data change.
We wanted to make sure that instead of upgrading our editor to add more complex behavior to a problem that shouldn't really exist in the first place, instead of doing that, we wanted just to change our data so the data was simpler and the editor required just a very small change to just deal with how the new data was formatted.
So what we did then was to just remove a single column from the database, which was the reference to the visual information, but we kept the key to the equipment.
And then all we needed to do in our variant files, which are XML-based, was add a single attribute in the XML tag that the database could recognize and say, oh, I need to now enable this piece, which was then the proper helmet, the proper shield, etc.
So we visualized how we wanted to do it.
Essentially, we just wanted to cut out that step of the database where the database was loading visual content, because obviously a database is not a visual system.
and instead stored all of the visual information in files that were actually built to handle visual information.
So it became a much more straightforward process.
Obviously, it's easy to say we want to do it this way, but we actually have to find out whether we can do it.
So we spent about a day of R&D, which turned into about three days of code work, which then resulted in a lot of redundant code actually being removed.
I'm sure any programmer would think that's a very good thing.
Our programmers were actually really happy with this change because a lot of spaghetti code could be removed and a lot of edge cases could be handled as well.
And the code became much more straightforward, which resulted in a bunch more improvements over time, which I'll touch on later.
So the question really then was, obviously three days of code work doesn't mean that our data has suddenly magically changed.
What we actually found is that we had about a month of work to change how the content files were stored, because we obviously needed to transfer all of that visual information from the database into our text-based variant files.
They don't just magically update because the code changed.
So how to do that transfer?
Well, we wrote a entirely one-off script.
this is where the duct tape really comes in.
Because this script was, well, basically the ugliest thing you've ever seen, but it worked.
So it transferred all of that content from the database into our variant files, and that one-off change taught us basically how we needed to make that change in the first place.
Instead of going in and saying, let's make a super solid tool to handle this information change, instead of doing that, we said, let's just try it.
Let's prototype that, and just use the actual prototype in production, and just debug the content, and just deal with it.
And by doing that, we actually learned enough about what we needed to do over time to then later turn it into a passive process.
Because by then, we understood the problem space.
We knew what we had to do, we knew the problems that we could encounter because we understood both the data and how to interact with it.
What that actually looks like, if you visualize the before and after, is on the left you see the unit in its basic default configuration, which is what the artists were actually seeing, and then to the left of it, you can see the several equipments for higher upgrade levels that were stored in separate files.
On the right, you see the editor after the change.
Now the only change that we actually needed to do to the editor was to give it the ability to hide certain slots.
That was a very tiny code change, relatively speaking, compared to the implementation change that we would have needed to do to implement database interaction from the editor.
So just by changing how the content was formatted, we were able to add a lot of improvements into our editor.
But again, this was a very small change.
Basically all we did is remove a single column from a single table in a database and moved that information somewhere else.
And while it was a complex change, it wasn't really all that impressive.
However...
What we did get is a host of later improvements that we did not see coming.
For one, our programmers, because the code was now much simpler to deal with, and because the data was now much simpler to interact with, came up with the fact that we, instead of loading every single conceivable part for every unit on startup, which is terrible for startup time, we could now start loading our unit parts on demand, which meant that when you equip an equipment, it's at that point in time that it will actually start loading the model.
That was only possible because our data files were now structured in such a way that the data model was much easier to interact with.
That of course resulted in a bunch of startup time improvements, but additionally, because our data files were now, essentially now contained all of the visual information that a unit could ever have, that meant that because they're XML based, Python became incredibly powerful.
Suddenly, we could do metrics gathering offline, because these metadata files, the variant files, which are essentially metadata files, referenced our models. So, okay, it's basically one step from reading some XML data to then reading the model files to then simulating what a unit would behave like in the game engine, which meant you could measure things like draw calls without ever starting the game up. That also led to ideas for future performance improvement systems because again we understood the data much better now because it was just formatted in a more human-friendly way.
Most importantly though, it also led to the creation of our entire UI pipeline.
So that's pretty significant as well.
What this essentially is, is an example of an accelerator.
It's something that on the user's side is actually a net zero change.
But on the development side, it makes a huge difference.
Because the simplification of data led to a much deeper understanding of it, which in turn led to better processes.
Because these processes could now be informed by this deeper understanding of the data.
That then leads me to the second example that I brought with me today, which is Total War Arena's UI pipeline.
I've referenced it a few times so far, so I'm sure you're all curious to see what it looks like.
So, the problem that we had on Arena was that UI production is quite expensive.
I'm sure this is a common problem in almost any production.
But on Arena, we had a lot of icons.
This is also a fairly common problem.
On Arena, we had hundreds, I think actually thousands, of icons.
Every single equipment in our game, and you have to imagine, when the game shut down, we had four factions, each of which had 50 units, each of which had five equipments, and three upgrade levels.
So you can do the math on that one.
Most of those had unique icons.
On top of that we had things like unit cards, commander portraits. We had I think 30-ish commanders each of which had a few cosmetic skins. So those needed icons as well.
That's a bit high maintenance because content changes, things like character artists changing what a shield looks like, for example, would require the icon to be updated to reflect the changes.
That's really not that scalable.
To give you really an idea of just the scale that this problem has, this is a tiny sampling of the amount of icons we actually have in our game.
These are just all equipment icons, by the way, not commander portraits, not achievement icons, not skill icons, and not unit portraits.
So that really gives you an idea of just how high maintenance our pipeline was.
So again, we took the same approach as we did on the first example.
How is the data maintained?
Well, that question was answered rather quickly.
Basically, a ui artist would go into the game engine, take a screenshot of whatever asset they would make an icon for.
take it into Photoshop, and then after 30 minutes of, actually not after 30 minutes of work, the reason it says 30 minutes is because opening the game engine and the various tools takes some time as well.
So for a single icon, it might take 30 minutes.
For 10 icons, it might take 35.
I'm sure you're all familiar with this type of problem.
But even so, the overhead is quite large and really not sustainable.
So we found this is really not scalable, super high maintenance, and we needed to change this.
So, stepping back then, I think a good way to do that is basically to abstract what you're doing.
We actually asked ourselves, we have a toolbox of stuff, like we have solutions and other projects that have similar problems, and maybe we have some things in place, some pieces of tech that we can scrap from other solutions.
Okay, so we had an existing Python code base.
We had everything from version control to image manipulation tools, the ability to interact with our game data, and just general Python implementations for all kinds of solutions.
What we also had was Marmoset Toolbag 3.
This is where it gets really interesting.
Just a month before we had this problem, or rather just a month before we decided there was a problem, Python 3, I'm sorry, Marmoset Toolbag 3.03 shipped.
It included Python 3.6 support.
Now this became really interesting for us because at the time, suddenly we found, oh, we have this existing code base.
Our artists know how to use Marmoset Toolbag 3, and Marmoset Toolbag 3 has a proven track record of just making really pretty renders.
And now it has a Python API.
I think we can probably do a few things there.
We also had the Substance Batch tools.
On Total War, we used the Substance Automation Toolkit quite a bit, mostly in a headless fashion.
Usually we use this for image processing between various applications.
On Total War Arena, actually the implementation we had for the Substance Automation Toolkit was to get our textures from Substance Painter into the game.
Basically what we did is in Substance Painter, our textures would be authored in the Substance default metalness roughness shading model, but our game engine didn't actually have that shading model.
So we used Substance to transform our textures into a different lighting model.
That sounds counterintuitive, but what that means is because we were under the assumption that our assets would be used on other projects as well.
Basically all we needed to do was to change that process for a different game engine and then our assets would be globally compatible with every project on Total War.
So this is what we use the Substance Batch tools for, so we knew we had a track record of like, we can do something with this.
So the idea then became, why don't we just take a screenshot from an asset that's been set up in Marmoset, pipe it through Substance Designer Graph, and then just put it into the game?
I'm sure we can do something with that.
So, well, basically, yeah.
We had a proof of concept working in less than an hour, which was really impressive for us, which mostly is down to the power of the Toolbag API.
While it's a bit nascent, it is very good at what it does and extremely fast.
It's also production capable- our tool is also production capable in under a day.
That doesn't mean that it was an actual tool.
Again, this is a talk about duct tape.
I don't have a video or a screenshot of what that thing looked like, and I will never show it to anyone.
What I do have is a video of what it looked like a month ago, because I'm going to pretend that this is what it always looked like.
So basically what we did is we built a tool that allows us to set up lighting and camera settings and basically any kind of settings in a single Marmoset scene that then allows us to duplicate the settings in other scenes that already just have a model set up in them.
What that means is you only have to light a single scene, and you can reuse that setup in all of your renders.
Which really, because of the speed of Marmoset, means that your iteration time becomes extremely low.
What you see happen here is commander portraits, specifically for Ambiorix is being used as a test asset.
But for keen-eyed among you, I actually don't know if it's legible, probably not, but the asset in this video is actually parented to a group called underscore ignore, so the pipeline is just not implementing that particular mesh in the render for the other commanders.
but obviously it's useful to have a test asset.
So it's just duplicating the lighting, the render settings, the camera angle, camera position, and everything else for all of those other commanders, which we've posed in the same pose.
Obviously, this also requires that your commanders have the same bodily shape and general proportions.
But basically, what you can do is if they don't, you can just make another template.
and merge in lighting from one template and a camera from another.
So there are various things that you can do to deal with that.
At that point, what you have is a raw render.
Obviously, that can't really go to the game engine.
Sometimes it might, depending on your setup, but you probably will want to do something like transparency, maybe some cropping, maybe adding a frame onto it.
That's where Substance Designer basically comes in.
Any Substance Designer artist will be able to turn that image into something that can go into the game.
Those networks ended up being rather simple.
So why is this really duct tape?
Well, the proof of concept was created and working in two days.
It was a very quick turnaround, and it was designed for single use, and mostly not designed for other work either.
The original version of the tool was so hacky that I actually had to alter the code while a UI artist was sitting next to me.
But we did get the content out on time.
We went from production saying, we need this now, to we have the content in a couple of days.
So that was actually a super quick turnaround.
And we ended up producing 200 assets in a couple of days.
So really at that time, because it was so, not badly implemented, but because it was such a hack, it wouldn't even have been useful on other projects.
In fact, not two weeks after we produced the content, it broke because of some environment thing.
We never really figured out what it was.
But obviously, that's not really the point.
The point is we got the content out and we learned about the solutions that we needed.
In fact, what's important to note about that is really this implementation was only possible because of the data work from the previous example. The reason for this is because our variant data files that I referred to in that I referred to in the first example were now so simplified that we knew how to interact with our data and know and we knew where to find the models that would make up a particular equipment or a particular configuration.
We also knew where to get the FBX files, the TGA files, and everything else from our resource folders to then import into Marmoset.
The biggest challenge by far for this pipeline was not to take the screenshot, it was to get the stuff into Marmoset in the first place.
Because obviously interacting with game data information, you can't directly import some custom binary format into Marmoset, so you have to get an FBX file.
our pipelines were not optimized to provide this FBX file in the first place, but because of the simplification of data we were much more able to create some sort of patched solution that would export those FBXs that we needed. So that was actually really convenient for us. But importantly as well is because we now understood our data much better, we wouldn't have had the idea to make this pipeline in the first place had that not been the case.
And I think that's really the key message here.
So, this tool, or rather the first duct tape implementation of it was used in production while prototyping.
Production work with the tool was actually mostly done by myself with a U-Artist sitting next to me, like I said earlier, me actually altering the code while we were doing the actual work.
But key to that is that actually working with the tool led to a host of improvements later on that we would otherwise never have conceived of.
I think that's a phenomenon that any tool developer can relate to, is you probably have a good idea of how you want your tool to work, but actually working with it usually leads to insights that you just can't have otherwise.
So, this is where also the distinction between it being a hack or it being duct tape really comes in.
If you consider something to be duct tape, at least in the meaning of the term of this talk, is that you are going to rip the bandaid off later.
many quick iterations early on really, and that resulted in a much more robust tool than the Lion, but we rewrote the entire thing from scratch.
Every single line of code was rewritten.
In fact, the original prototype was never even submitted to Perforce because I refused to do that.
But there's a catch.
Everything you just saw is built on one thing, and I really want to see if anyone can guess what it is.
I'm going to give you 20 seconds.
No?
Alright, so file conventions.
Anyone who knows me knows that I'm a naming conventions guy.
In fact, when I went to do a talk in London at industry workshops, which is like a super artistic convention, I managed to somehow amuse 45 artists long enough that they stuck around for a 50-minute presentation on folder structures.
Yes.
So, the reason why I really hammer on this, and I swear I will have something about naming conventions on my gravestone, is that good conventions really make tool development easier.
Any tool developer can confirm this.
Because if your data is all formatted in a consistent way, then the amount of lines that you have to write to deal with edge cases goes from an entire framework just to deal with edge cases to, in our case, we basically didn't deal with edge cases.
We just let the edge cases fail.
Because our data was formatted in such a good way that even at a 10% failure rate, we would just deal with the 10% rather than doing it in code.
It also makes prototyping a lot faster because, again, you don't have to start at a point where you're still trying to get to the data in the first place.
If you automatically know where the data is and how to interact with it, again, by simplifying the data, that's a really good first step.
Your prototyping is going to be so much faster because you can start at the point of your prototype where your prototype will immediately do what it's designed to do.
just maybe not in the best way, but that's why it's a prototype.
But if it has to interact with data and you don't have the data to begin with, then prototyping is just a whole lot slower.
It also makes tools more reliable, because again, if your tools don't have to worry about edge cases and essentially don't implement behavior that will deal with edge cases, it means that the actual behavior that the tool is designed to do will be a lot more reliable, because you can just tell an artist who says the tool doesn't work to format their data properly.
Our conventions really in this case meant that validation was easier because, well, we didn't do any.
It also means that the use of duct tape was a lot safer.
Basically what we did is because we had this reliable database of data, essentially, we knew where to find our models, we knew where to find our textures.
It meant that we could just take a branch or a copy of the original data and do some transforms on it, do some animation on it, make the character pose, but we knew we didn't have to touch the original data.
We just left the original data intact and just made a copy and then worked on the copy.
But because we always knew where to find the source, we could just do that again and again and again and always make sure that we can go back to that source, which meant that our original data, formatted in the way it was, served as a safety net independent of any one tool.
because everything fails sooner or later in every game development process.
And if you have that safety net, it means you can just always go back to the source.
Obviously that's easier said than done.
Good conventions are really hard and they take a lot of work.
So I brought with me three golden rules for good conventions that I hope you'll take home with you.
First one is that good conventions take a lot of work because they require constant evaluation but not constant change.
That's a really important distinction.
What we actually do on Total War is when we come up with a new naming convention or an iteration on an existing one for a new project or a new branch or a new DLC or whatever, we actually sit down in a meeting room and I will stress this until the day I die, there is no amount of work that you can put in a naming convention that is too much.
Because six months down the line, suddenly you realize, oh, your convention wasn't strong enough to deal with this new pipeline.
Well, OK, that's 6,000 man hours down the drain just to transfer those 10,000 assets into the new convention that does deal with it.
Or you build some patched tech to deal with the new change, and then suddenly you have technical debt.
If you just avoid it to begin with, then if your conventions are good enough to deal with whatever you're going to encounter, well, that's going to save you a lot of time down the line.
So good evaluation but not constant change essentially means when you nail down your conventions just do a review.
For us we actually validate the very first submission in a new convention.
The first submission for art in the new naming convention will not go into Perforce until a tech artist actually approves it.
What we then do is one week in we do another evaluation.
as much to see if the conventions are being respected as to see that the conventions actually hold up under the stress of production.
And then we do the same thing a month afterwards, again, to see if the conventions are good, but also to see if they're being enforced.
So it's kind of a two-way street where you ensure that your conventions are strong enough, but also that they're being enforced properly.
This also allows you to nip certain mistakes in the bud really early on while you're still in your prototyping phase to make sure that you provide enough data for your future pipelines all to all work.
An example of what we maybe could have done on Total War Arena was to always export an FBX file with a MAX file just to ensure that any pipeline that might make use of it would have it.
We have plenty of space on Perforce, so there's no reason not to do it.
So in hindsight, we could have always exported an FBX file and we could have skipped an entire step in our prototyping process.
The second, and this is, I think, one of the most important ones, but not necessarily one of the most intuitive ones, is a strong underpinning philosophy.
What this really means is that you have to have something that can underbuild your naming conventions that can be summed up in a mantra.
The three steps that I say there is print it, workshop it, teach it.
Because what we actually did on Total War Arena is we had a half hour workshop where I actually taught the artists our naming conventions, essentially taking them through the steps that I would take to come up with the name for the file.
What that actually resulted in is maybe 10 minutes of a summing up of the mantra of the naming convention, if you will, the summing up in five sentences, and then 15 minutes of actual exercises.
I would give them an image and tell them to label it.
And that actually made it.
It sounds silly, but two years afterward, I hadn't done a single correction to any submission.
sit for two years, which is something that I've never seen before.
So our naming conventions essentially became self-reinforcing.
We taught them how to fish, in other words.
A good example of what a strong underpinning philosophy might be, in our case one of the strongest we have, is call it what it is, not what it's used for.
A good example of in a real world object where that might be the case is if you have a simple Lego brick.
Lego will label their bricks as a 6x2 or 4x2 or a wheel, but they won't say it's a wheel for a police car because it might be on a fire truck.
So that's an important distinction between what it is versus what it's used for.
It's true that for some assets these two things will overlap, but if you keep a conscious distinction between the two, then you'll find that you're prepared for way more use cases because what it results in is essentially a Lego kit that your designers can use, and they're free to change their minds without the fundamental naming conventions and labeling systems.
of your entire repository needing to change to deal with design changes.
This is not because the underlying thinking there is not that we don't want design to change their mind, we want them to be able to change their mind without needing to overhaul our entire repository because for game design it's just as much an iterative process as any other craft.
Lastly, consistent enforcement.
I think this is the one that requires the least explanation.
The only solution we found for that was just make people clean up their own mess.
If they make a wrong submission, just make him fix it, and they won't do it again.
And if they do, just make him fix it again until they stop.
So, we're nearing the, I think, the last third of the presentation.
What we learned, looking back, there are a few things that we learned from this process.
Basically, tunnel vision is the enemy of any production.
It's all about the big picture and your solutions really only make sense in the context of the product that they're meant for.
So what you should do there, this is a really tricky one.
There's not really a golden solution for that.
But what we found is that regular follow-up productions of three evaluations, help basically. The questions you have to ask is do the solution, does the solution still fit the project? Do you really need that asset processor or is your production requirement, has it changed? Does it need to do things that it wasn't designed for? Does it call for a new tool or can you use a different tool for it that's maybe better at dealing with the data?
A good example of that might be that, for example, we could have made our game engine produce the UI icons because it's basically already a renderer, but it would have added a bunch of overhead and it didn't have the render features that Toolbag had.
What we have now instead is a rendering pipeline in Marmoset Toolbag that is compatible with any 3D data, including data that wasn't necessarily meant for the game engine.
So that really gave us a much more powerful tool than I think the game engine would realistically have been able to implement.
It's also important to evaluate your tools in the context of the whole project, because the first question you always must ask is, can the need for this tool be eliminated?
Obviously, a shorter pipeline is always going to be more stable, and fewer tools is always better.
So the question also there is, is another tool more appropriate?
Again, that's the comparison between should we have used the game engine or Marmoset.
Also, lots of things actually do require a proper solution now.
Using a duct tape solution to learn from is, it shouldn't be your go-to solution, I would say.
It's not always obvious and errors in judgment can happen for this, but it's kind of up to your own intuition about whether to use a hack to just get the content out, or rather duct tape to just get the content out, or to go through the motions of just prototype development delivery.
it's kind of really up to the context in this specific situation that you're in.
So, some of the more important lessons are as well, if you do use duct tape solutions, for the love of God, get rid of them.
Because patch tech like this accumulates technical debt very quickly.
These kinds of solutions are beautiful to learn from.
It allows you to look to teach yourself.
the solution you actually need instead of the one you think you need.
Again, going back to the first example where we had an editor that wasn't really equipped to deal with the new data, and the straightforward solution was just implement database behavior.
Instead, we implemented a different data format, which we then used duct tape for, which taught us that, oh, actually using a different data format is much better, much more sustainable.
But very key about that is never ever build anything on top of duct tape tech.
If you find that a hack went in to ship some content, notify production and tell them you can get your content, but you need to give us the time to reimplement this from the ground up because it will bite you in the ass six months down the line.
So going forward then, basically, it's saying the same thing, work out when to remove the duct tape, because you always have to find when is duct tape appropriate and when will production require proper tools.
For the pipeline that we had, we actually asked production, or we told production, you're gonna need to give us time to reimplement this from the ground up because we can give you the content on time, but if we keep this in the production, it will break in two weeks and we're gonna have to keep fixing it.
Instead, if we just reimplement it, it will keep working forever, or well, nothing works forever, but it will keep working for at least a couple months or years.
So basically you just work with the other departments to ensure that you get the appropriate amount of time to rip the band-aid off as it will.
So takeaways of the talk then, nearing the end.
There is actually a benefit.
First key message is that there is a benefit to using temporary solutions.
Not everything requires the proper solution now, and managed duct tape can be very useful.
Again, the idea is that you, going in, realize that the solution you're implementing is temporary and you're going to need to get rid of it.
But the idea is that you learn from it.
You learn the problem space and the solution space.
You learn the actual solution that you need instead of the one you think you need.
So changing production requirements in that context also might mean that a solution is best left as a temporary fix until a bigger system replaces it.
It happens all the time in production when some new big system comes online that suddenly your solution is either redundant or requires a complete overhaul.
The straightforward solution might seem that you just adapt it to whatever the new environment is, but at that point it might be more productive to just step back and take a look to see if you can make a bigger or smaller solution that does what you need it to do more elegantly.
In that context, I think the key message of this entire talk is that every solution is a learning opportunity.
Everything can be done better, but not everything really has to.
It doesn't mean it's not because you want to build a rocket that you have to reach the moon.
It's kind of up to you to determine how big the solution is that you need.
Because it kind of really matters how big the problem is, how urgent the problem is, how soon you need a solution as well.
There's always a lot of factors determining this, essentially, but it's kind of up to you to figure out with production and the other departments to know what your priorities are.
But in that, every step clarifies the problem space, and it really helps you understand a better solution.
It really allows you to come up with new understanding of the data and how to best interact with it.
It allows you to come up with best practices, and it allows you to really understand your own pipeline in ways that you thought you did, but you didn't really.
Then I think also one of the bigger ones is that fewer tools is always better.
A shorter chain is less likely to fail.
That doesn't mean that you must have less steps in your pipeline.
You can have as many steps in your pipeline as you want as long as it's hidden from the artists.
So a one-button solution will always be better.
That doesn't mean that your black box must be the biggest thing ever written.
There is also the same concept applies if you do make a black box.
But in general, if you have a one-button solution, then at least you can debug what's going on rather than ask an artist whether they've pressed a very particular button or checked a box somewhere hidden in a UI panel.
One of the last ones then is to pick your targets.
You should work to eliminate tools, not build new ones.
I think the go-to solution for a lot of problems is, oh, we can build a tool to do this really easily the next time around.
And I think that's a pitfall that a lot of tech artists and a lot of tool developers easily fall into because you get caught in the joy of making tools and you end up making tools for their own sake.
And if you find yourself doing that, just stop.
a shorter pipeline is just always better.
And a data change, as we saw in the first example, can just be way more effective than any tool.
You should just always question whether data is being treated by the tools that are meant to treat it, and whether data is being stored in the format that the data was meant to be stored in.
In our case, we had visual information being stored in a largely binary database, which are two formats that are inherently incompatible.
And lastly, build safety nets.
System independent structures that don't fail, such as good folder structures and naming conventions, will help you ensure that you have something to fall back on.
It will allow you to treat your content in different ways and just try out new pipelines without ever needing to consult an artist.
because you will have the content available to you.
If you already have that repository of FBX files, it means you don't need a max installation to get to the model data.
That is very relevant for any tool developer and very important.
So these system independent structures that are very slow moving and therefore hard to break will serve as your safety net and ensure that you have something to fall back on.
A few great resources then that really helped me make this talk and really helped me build the tools actually was the first one I want to point out is the GDC 2018 talk from Michael Malinowski, Practical Approaches to Developing Forward-Facing Rigs, Tools, and Pipelines.
Was anyone at that talk in this room?
Yeah, so it dealt with the plugin factory design pattern.
This is probably the most prolific design pattern that we currently use on Total War on technical art tools because it is by definition extremely good at dealing with edge cases.
So I highly recommend you check out that talk.
It's freely available on default.
Second, I think really obvious, just look up the Wikipedia definition on technical debt because it's got so many external links.
It obviously is kind of like, let me Google that for you, I know, but it's also, it's just a very relevant, still a very relevant definition.
It stems from regular software development, not just game development.
And it really helps people who don't necessarily understand what technical that is, or maybe think they do, really come to terms with the various concepts that go into it and help you understand how to deal with it as well, because obviously over the years.
As software development has aged, various techniques and tactics have been developed to deal with it.
Then lastly, there's an article on breakingthewheel.com, video game art pipelines.
That's actually a really good article that does an incredibly good job of breaking down how to identify bottlenecks in your asset production pipeline.
It uses the same principles that were used on like factory pipelines and factory production lines to identify essentially the slowest part in your production and ensure that you can prioritize properly which things you need to optimize first.
So that did a very good job of describing that.
With that I just want to thank everyone for listening and you can contact me on the email address here.
We have some time for questions.
Thank you.
Thanks.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
So yeah so for questions you can go to the mic.
Also I have business cards if anyone wants to contact me later.
Hi.
I have quite a few issues in our studio with managing these Band-Aid tools.
And the biggest pushback I get about either removing them or promoting them to something a little bit more permanent is there's a fear of the time cost that it's going to take to do that and the risk that's associated with it.
How do you convince people to buy in toward making that leap of faith in either direction?
I get the right allies.
It's a bit political, but for the variant cleanup, it actually took me roughly a month to convince the various key people that would end up making the call that we actually needed to do this.
I did that at the time by actually writing up a big Word doc.
explaining like, this is how we should do it, and these are the things that we would get in return.
And then you just list out all of the things that we, all of the problems that you encounter as a result of this not being a thing yet.
Various bugs are always good.
Like if you have like a thousand bugs that basically could be avoided.
by implementing this new system, then it's kind of, at that point, it just becomes a numbers game.
So you can just hit someone in the face with a big number and say, look, this is costing us a ton of time and money.
We should really do this.
It is difficult, though.
It's just getting the right allies.
Thanks.
Thank you.
Thank you for your talk.
I have a question regarding how do you catch the errors in the conventions?
Do you have scripts or CI or something?
Yeah, so that's a good question.
On Total War Arena, by the end of the production, we actually did have a script that would go through our entire folder structure and catch any errors.
But I think in general, that's really hard to achieve because of various concerns in terms of there will always be edge cases.
I think the best, so the way we actually do deal with it is to just do periodical evaluations.
If you do an evaluation the day of the first submission, then one a week after the first submission when more stuff has gone in, and then a month and then two months afterwards.
And if you catch things that have been done wrong or if a particularly egregious number of mistakes have been made, then you can just do your periodical evaluations at a higher frequency and keep doing them until people get it right.
But again, there it's just important to trust in the area leads to enforce those conventions for you, cuz you won't have the resources or the time to do it yourself.
Thank you.
Great talk, thank you.
Thank you.
Sounds like you've put a ton of time and thought and energy into naming conventions.
I'm curious, do you plan on publishing the work that you've come up with in that specifics, like those conventions as well as the presentation you gave on getting people to buy into it?
Yeah, so quick note, the presentation slides will be available on tech-artists.org.
But for the naming conventions thing, I think so.
I think we are kind of looking into publishing our mantra, if you will.
I think our mantra for Total War was actually, call it what it is, not what it's used for.
Labels have weights, so shield is bigger than shield small, so small comes after shield in that sense.
Not every shield is small, but all small shields are part of a shield group, kind of that consideration.
And there were some other things as well.
We summed it up and we actually did print it out on a poster, so it's possible.
I'll try and see if we can publish that somewhere.
Thank you.
Thank you.
Hi, Matthias.
Naming conventions are outmoded, fight me.
So, sorry, could you repeat that?
Naming conventions are outmoded, fight me.
Why do we continue to encode metadata into a fixed string of a given length when we should be putting our assets in an asset database and doing proper meta-tagging that we can dynamically update over the process of the entire project?
Sure.
I would agree if we had the resources to build a data bank.
Well, we are looking into building one, but if you as a developer don't have the resources to build an asset management tool, which many don't, because that kind of thing tends to be a mammoth task, then naming conventions are your first and last line of defense.
So I absolutely agree that they're outmoded if you have the resources to deal with that kind of system, but if you don't, then they, I think, are your only fallback.
Thanks.
Thank you.
All right, I think that brings us to an end.
Thank you.
