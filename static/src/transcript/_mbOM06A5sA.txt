Hello there! Welcome to my GDC talk slash bedroom, where today we're going to talk about custom tools. So, let's get started. Alright, first a little bit about me. Who am I? Hi, I'm Brett Taylor. I got my Master's in Cognitive Studies from Columbia University. I've been making games for about the last 12 years or so. And my history, I worked at Arcadium for about three years.
Then I went indie, I made a game called Lionlight, that did pretty well, released that in 2017.
And most recently I'm actually a developer at Playdead, designing and doing stuff on their Untitled 3rd game.
So yeah.
All right, so this talk basically split it up into four parts.
First, we'll talk about what is a custom tool.
So we'll define what custom tools are.
Then we'll talk about level editors.
So I've made a lot of level editors in my years of development.
I've got a lot of experience with that.
And that's a very specific type of tool as well.
Then we'll go over like when when does it make sense to make a tool and then finally we'll finish up with code shortcuts for Unity so if you are developer in unity I have a ton of code shortcuts that I've sort of amassed over the years that will make development life for you easier And actually I've got a link in there so you can just use them you can download them Free on the internet to make games better and faster. Yeah So, you might be asking me, what is a custom tool?
That's the right question.
So the way I would define it would be it's some sort of a code or system that saves time for the designer and or the programmer.
So it's specifically about saving time, something that helps optimize the process and make the game faster.
And also like throughout this talk, I'm gonna like I sort of use the term tools a little bit loosely Like as I'll like say a level editor is a tool but the level editor has like things within it. Yeah Yeah, this talk is specifically about saving time and energy. It's not about making the coolest possible tool. It's about yeah, it's about Making our games faster and more efficiently And like not wasting as much time. Yeah And specifically, this is about design tools.
So there are like tools for bug profiling and stuff like that for production or programmers.
But these tools, the ones I'm talking about, mostly for the designers to add content into the game.
Yeah.
All right, so let's talk about sort of the groove or flow state for the designer.
So let's say that you save 20 seconds 12 times a day.
That's a quantitative...
You can say like, I've saved this by making a tool.
Would that time be worth it?
You know, like that's four minutes a day.
But you're not just losing those four minutes.
You're losing sort of like being in the groove as a designer.
So when I talk about the value of making certain tools, it's not just about the time saved.
It's about like staying sort of in that flow state as a designer.
And that's really important.
So you can't just say that you're saving four minutes a day, because you're not just saving four minutes a day.
You're sort of staying in that state, and you're able to work more efficiently.
So a groove state is sort of like when you're creating, and you're not interrupted and bothered by things.
But it is relatively easy to interrupt this groove state.
So let's say that's you. You're Kuzco.
You threw up my groove, he says.
So those would be the obstacles that waste time.
So our goal is to stay like Kuzco in the beginning of, if you've seen the Emperor's New Groove, him in that musical number.
We wanna be like that as designers.
Maybe less selfish, but dancing that much.
Yeah.
All right, let's talk a little bit about Bob Ross, who I personally love.
He is a time-saving role model of mine.
So he makes oil paintings.
He's got this show from PBS back in the 90s where he would complete these paintings.
Each show was about like 22 or 23 or so minutes, and he finishes an entire oil painting.
And he does that by using a lot of shortcuts.
He has said that this is the lazy man's way of painting, which I strongly disagree with.
I don't think that's true at all.
This is the smart person way of painting.
This is the efficient way of...
and making stuff where you're like not wasting as much time.
So like for instance, making stones, making these stones, you take a filbert brush, you put light color on one side, dark color on the other, and you just basically touch the canvas a little bit, you don't really have to do much effort at all, you just touch the canvas and a stone will just appear.
It's magical. Doing it that way, it's so much faster, it's so much more efficient.
And he's got like all sort of like little, you know, shortcuts like that.
So I'll put tools on sort of a spectrum of small tools all the way to pretty big tools.
So a small tool, because I'm using the term sort of loosely, but I'll just sort of call it tools in general It's just like things to save time. So here like this tool would be a reusable code snippet So let's say it's something that returns a random boolean, which is generally not a function afforded by most languages, which is strange to me I don't know why that doesn't exist To big tools like let's say an entire level editor. That's way robust. This is something that I made like 10 years ago I'll get into that in a little bit. Yeah so We've got designer tools, so that's something that helps the designer add content to the game.
And then programmer tools, so like the reusable code snippet, that would be...
Or like it could be a library or something, just something to save the programmer time.
So they don't have to keep reinventing the wheel, that's sort of what programmer tools are more like.
And this talk is specifically about the designer tools, it's more geared to that.
Although at the end I'll give you some Unity code snippets for those programmers out there.
So, types of designer tools, we could have things like a level editor, that's a pretty straightforward one.
Something that, the tool would be like something that highlights an issue with some content in like a layout.
Visuals, like that help, you know, you can see the little check boxes, check marks there, and I'll get into this image a little bit later.
Yeah, it helps you like organize your content.
Or, you know, if you're making like a branching narrative or something.
Yeah, this is Inky.
It's a text editor for that.
So it would be a tool to actually make the content to put into the game.
Okay, so part two, let's get into examples of level editors, which is something that I like. Level editors are fun.
So, Scalia. Let's talk about this.
This is the first big game that I ever made.
It looks like this.
This is what the level editor looks like as you're editing it.
This is my first level editor that I actually made.
I made this back in college.
It was heavily inspired by Braid.
The game itself was very inspired by Braid as well.
So, Braid was like manipulating time.
So, I was like, oh, what if you can manipulate space?
This is way back in like 2010.
Basically right after Braid came out.
Anyway, so the Scalia level editor was obnoxiously over the top.
The game itself was about a half hour long, and this level editor, it was ridiculous how robust and sophisticated this was.
Yeah, it's too much.
So the outcome of that, it cost me roughly estimating, I'd say, about three months to make the level editor on and off over the course of a year or so.
And the payoff was not that much, honestly, compared to had I just hard-coded the level layouts with text files.
So the payout wasn't, like, the amount of functionality I put in it really wasn't that worth it.
But that said, I was young and I learned a lot.
I made this in processing also, which was a ridiculous decision.
But I learned a lot in the process.
Let's talk about Linelight, so the game that I released back in 2017.
So this level editor, a bit...
I learned a lot from the Scalia level editor in terms of what not to add.
So the Linelight level editor...
Yeah, so actually I'll show you here.
It looks basically like this where you can move around.
And like, you're playing the game, you can turn the level editor on and off.
You can just click and drag these streets.
They automatically reconnect.
So it's very easy to rapidly iterate on ideas and stuff.
So I made the level editor after, I sort of started the level editor after I've hardcoded enough levels to decide that the game was actually worth pursuing in the first place.
And that I needed, basically that I needed the level editor.
I didn't make it until I knew that I actually needed it.
So it started out this delightful hardcoded, like I had to say exactly where the pixels were of the elements in the screen, and eventually over time...
I made the editor out of it.
But I started with the hard-coded version.
With Scalia, I didn't do that.
I made the level editor first, and it had a lot of features that I really, just didn't really need, because I was so swept away by Braid, and I wanted to copy that, which, again, I learned a lot, but it wasn't the most efficient way of doing things.
And then I learned and applied those lessons to Light Knight.
So the outcome of this, roughly over the course of a while, I'd say maybe it was about a month development, kind of tough to estimate that, but the whole development cycle of LineLight was about a year and a half.
And the payoff for that was tremendous, like the rapid iteration time was absolutely fantastic.
This level editor was great.
It was great.
Yeah. And I, because I made the features as I needed them and I kept it really streamlined.
You can even see actually that I'm using like the default GUI system from Unity.
But I was like, I started with that and I'm like, oh, I'll make it pretty after I get it to work. And then I realized it's working now. No need to make it pretty.
So that's sort of like a little lesson that I had there, which it sounds really, it sounds really like almost not even worth saying, but it really is because I was, I was so close to making it look legit, like a legit level editor.
but I didn't need to. It wasn't worth it.
Having it look sort of ugly like that, and kind of hard-coded a lot of it is, it was fine. That's all I needed to actually finish the game.
So I didn't have to make it polished.
So the map editor for Limelight is probably equally sophisticated, if not more, and there were a lot of features to this, which I added gradually over time.
And I'll show you another map editor that I have that's based on this.
I'll get into some of those details with that.
Here's one thing that I made, maybe like two or three years ago or so, Designer Flags. Oh no, actually no, sorry, this was from Linelight.
I made this for Linelight Levels and I brought it over to another game that I worked on.
So Designer Flags, these are the five Designer Flags.
This is just a system that I have.
thought up and I wanted to use.
So each level is flagged, like it's got a flag of one of these icons basically, and you just, you tap the icon to change it, cycles to the next one, pretty straightforward.
And it's baked into the editor, so when you look at the level itself, like I look at the level, I can toggle the level names on and off, and I can see like if it's, you know, if it's a testing level, if it's just an idea for like a level or a puzzle or something, if it's something that's in progress, as you can tell from like the little shovel guy, if it's a good level or if it's a great level.
And, I actually love this system. It worked really, really well.
And it was especially great because levels would constantly be in flux.
I would be rearranging things just all the time.
And knowing, like having each of the levels flagged as something really helped guide me.
And I didn't have to remember what I thought about the level or what I knew about it.
It was already there for me, which was great.
So, I'll start with the outcome for that.
Honestly, yeah, that cost about five hours total.
And the payoff was really just outstanding.
It was great for those designer flags.
All right, so prop display.
So this is a similar thing to the designer flags in that it shows some stuff on each of the levels in the map.
And it shows what's in each room.
So like each of the boxes, level room, I use this synonymously.
And my goal is to visualize linear progression.
So it shows what the mechanics in the room itself are.
So you can see here at the top, we've got flipper, you start here, this is the beginning.
We've got flipper, flipper, flipper.
Then we—ignore the purple—then we get enemies, enemy, enemy.
Then flipper plus enemy.
Okay, so then we've exhausted those.
Now we've got a key, that's a new mechanic.
Enemy in key, enemy flipper in key.
So this was, I wanted to like visualize like how I was compounding mechanics on each other because that was an important part of the game.
But I ended up not really ever using it, which surprised me a lot because I thought it was going to be beneficial, but it just didn't, it didn't pay off.
Yeah, it just wasn't useful.
So that cost me about like three and a half hours or so, roughly.
And there was really no payoff. So that wasn't worth it so much.
But you know, that's part of the learning process.
making this.
Bouncemeister. So before I get into like examples of the game, I'll just show you what the game looks like.
So you can, you've got, there's one character, Jetta. You can switch between characters.
So now we're Plunga, so you can plunge down and you get some extra height. This game was inspired by Celeste.
I made this about like a year ago or so. Anyway, so that's what the game looks like. It's a side scroller.
Here's the map editor. So it's, I copied and pasted pretty much the entire line light map editor.
and I fix things around to make it work for Bounce Master.
So the rooms, as you can see, you can drag them away and then connect them back to each other and they'll automatically connect in the editor.
It also highlights issues with the layout.
So you can see this, well, yeah, so there's pink lines on the edges there if it's not connected to something.
So that was really useful for me as well.
And also, like, you can see how the colors are clustered together if it's part of a specific cluster.
So I could...
make these layouts because there were several of these worlds, so I could drag things around with them pretty easily.
That was really useful.
There's also extra features, like if...
Once I had enough levels, I needed to start searching by name, so if you hold down the shift key and you start typing the name, it'll filter out all the levels that don't have that string in their name, which is great, it just hides them.
A little feature that I eventually added was, if you shift-click, it'll just select all rooms that are connected to the one that you've just clicked, which is actually surprisingly useful.
And a bunch more, like little dude ads and stuff, to make this map editor useful.
So, the room editor. Let's talk about the room editor a little bit.
So, here's a room, a Bounce Meister, and this is actually what the editor looks like when I'm making levels.
It uses the Unity Editor.
So Linelight, it's baked into the actual game itself.
It's baked into the, you know, like you could play it in the production, like the release version of Linelight.
But Bounce Master uses the Unity Editor.
It's got some advantages.
It already exists. Unity Editor is already out there.
So I didn't have to add things like undoing and redoing.
LineLight didn't have that because that's just not worth adding on my own.
But this had it, which is super useful.
And especially useful is selecting multiple things and moving and scaling them all together.
That's really useful. Unity Editor already has that built in.
But there are some disadvantages, obviously.
Um, uh, yeah, it's first off a separate window to play the game versus edit the game.
Um, which I didn't really like because it made everything smaller.
Um, uh, because there's just, you know, more windows, less screen real estate.
Um, and also, like, I had to invent very specific workarounds to, like, work with Unities, like, how their editor works, um, in ways that I wasn't used to, you know, sort of working.
So, let's talk about the room editor, some of the features in the room editor for Bouncemeister.
Snap to grid. This was awesome. This code is hilariously not complicated. It's very simple.
So yeah, the snap to grid is exactly what it looks like. It snaps things to the grid.
Auto-rotating spikes. This was awesome. I wanted this for a long time, and I'll get into this specific example later, but when you drag it against a surface, the spikes will automatically rotate to match that surface.
It's nice.
This is gonna sound ridiculous, but I had to add a feature that would auto-expand the hierarchy.
Cause you can tell here, this takes about seven seconds.
I have to click once, twice, three times to open up the level itself, like in the hierarchy.
And then in the code, anytime a level is loaded, Automatically would expand the hierarchy to exactly what I knew that I wanted it to be so that would save me all those clicks zero seconds zero clicks that actually saved a lot of time and a lot of headaches because I want to see what's in the What's in the level itself without having to click?
In the actual game window, so that was really useful You can do that also you can like auto expand the hierarchy how you want in unity cool Tons of keyboard shortcuts.
Not going to go through all of them.
A simple one would be these keys right here.
These just corresponded to jumping between levels.
You can see up there, a little tiny, there's the map there.
So I'm just like using these to warp between levels that are adjacent.
And I have like a lot of, maybe two dozen keyboard shortcuts.
I'm not going to go through all of them, but there's a lot.
So we've also got gizmos that show mismatched room connections.
So you can see right here, this line that's drawn, that's where the other room's opening is.
So I can see if I'm looking at, I can see there's just a mismatch right there.
So that made it...
I didn't have to keep switching back and forth between levels to like, or like exit to the map editor to see if they were misaligned.
I could just do it.
I would know already, it'd be displayed right there.
Next, we've got Music Story, another game that I worked on.
This is right after Limelight.
I didn't release it.
This just stayed in a prototype stage.
But I'll show you a little bit of the video of it and then we'll talk about the solutions to the challenges that I had.
Yeah.
You can make choices here, so you can choose to look or ignore.
You can be nice or mean, I'll be nice.
Okay, so anyway, so you can see that the music, the text comes in each of the notes, each of the syllables actually, the text will come in from each of the notes.
all the text in the entire game is set to music.
So this was an interesting challenge.
I wanted a frictionless system to compose and connect, like to marry branching story and music.
I'd never even conceptualized branching music before, so I had to figure out how to make that work.
That was a very difficult challenge.
Because I wanted this as frictionless as possible.
I want to be able to add content really, really quickly.
And not have to like worry about like setting specific timestamps. That would been like a nightmare Because I did that initially and it was just so time-consuming And it was it was difficult to add content. I wanted to just get my thoughts out as quickly as possible. That was my goal So the ultimate solution that I came up with for that This is Record Producer. This is like the first, I think I wrote my first like thousand or so songs in this software here. It's like from the 90s, super old.
But anyway, yeah, so I wrote it in this. It's a MIDI editing program and I had stamps, so you can see like the little flags there. I read in that MIDI data into the code directly and I synced that up with, so I used Inky, which I mentioned earlier.
Inky to write the actual branching dialogue and then it you see you see like the little hashtags that like specify They they sort of connect the music and the lyrics together that system. I was able to write content very quickly Considering that it was branching music, which was still weird to think about If somebody can make a cooler better branching music a sort of thing that would be that'd be pretty cool But I didn't need to make it sophisticated like I could have made an actual branching tree sort of thing like with an editor I was very tempted to honestly, but that wasn't worth my time but it would be cool for that to exist.
Alright, let's talk about Combii.
So you tap to drag the tiles, and then snap together.
The goal is to connect all the colors, all the same colors together.
You can do intro levels, and I guess it gets a lot more complicated.
I think the grids get pretty big, but that's how to play the game.
So with Combi, it's a mobile casual game, and we wanted over a thousand levels for the game.
But we only had like two or three weeks to...
Like our time frame for making the game was about three weeks.
Which is pretty ambitious, to make a thousand levels with...
And I was also the only developer on it.
And the game itself was too complicated, like the merging and stuff to make procedural level generation.
So I had to do them by hand.
I would spend like two hours making levels, and it just blew my brain up.
I couldn't function after that.
So I eventually made an editor for my phone.
This is what the level editor looks like, and this was absolutely outstanding.
So the steps to make a level with this system.
So first you would just hit New.
It would generate a completely random level, potentially not even solvable.
A lot of them were not solvable, and that's my job to figure that out.
then play through it, and then I could edit manually.
You can see here, paint, so we can click to add a tile, you can remove them as well.
And then save and tag it, save the difficulty.
And ultimately, each level cost about 45 seconds on average for me to make, including the extremely difficult levels, which would take a couple minutes to solve.
A lot of them weren't even solvable.
Like I would play through these levels that were not actually solvable, and I didn't know if they were.
So, which means that a lot of these levels I was making in less than 10 seconds.
So I would make levels after waking up, I would make levels on the subway, before I went to bed I would spend 10 minutes making levels, etc. etc. So I was able to make a tremendous amount of levels that really fit into my schedule. So this tool enabled me to make levels, and it was actually a lot of fun to make them too, without losing my mind by sort of fitting into my life a little bit better. So...
The outcome of that, it cost maybe about three days total to make that editor.
Tough to estimate that, but about three days roughly.
And the payoff was my sanity.
I literally found it was hard for me to have conversations with people after I'd been making levels for that long.
So this definitely helped.
Chapter 3.
When to make a tool.
When?
Let's find out.
So my advice, hack in the content first.
Get the actual content working, get the design, and get it playable.
And then once you've got any bit of content working, once you're able to play it, then you'll have a much clearer idea of what tools you actually do or don't need.
Making the tool in advance, unless the design is like iron, like it's just like locked in, hacking it in first, for me has always, always been the right move.
So, you know, for instance I showed earlier with Line Light I just hacked in how the streets were laid out.
I didn't make any level editor, I just wanted to test if the game was a game at all in the first place.
Which eventually became the Line Light level editor, which was great.
You might be wasting more time than you realize.
So my advice to all you folks out there, identify what your preferences are first and challenge them.
So like let's say that you're easygoing, if you're not really bothered by repeating actions a lot, you don't really mind it so much, it doesn't affect you.
So identify that. Or are you sort of on the other end of the spectrum, which is a little bit more like what I am, I'm efficiency fueled.
Or like the moment I think of a tool I'm like, oh that would be so cool to build it.
Identify sort of like where you think you might fall on the spectrum most of the time.
So let's say that you're easygoing.
So my recommendation would be, look at your process critically to see how much are you actually waiting for, let's say that somebody has to compile or you're waiting for something, and how often are you repeating actions. So some specific examples would be if you're renaming or editing files in bulk regularly, if you're doing this more than once a week.
This is a really funny one that I found for myself.
It makes a big difference, moving my mouse or my eyes really far distances.
Because my monitors are set up, like, you can kind of see it here.
It's pretty, yeah, it's like the gap is fairly wide.
And there were moments where I would have to look all the way over there and then down there.
And I also have to move my mouse between those two.
And that's just, it sounds silly, but it really does, it interrupts the designer's flow.
But just looking out for things like that.
If you're waiting, every time you edit a code, it'll take 15 or more seconds to recompile.
There probably is ways to save time.
There's probably ways to cut that down that might be easier than you think.
I would say challenge your complacency.
That's my advice, basically.
And yeah, honestly, saving time might be a lot easier than you think.
Saving the first 30 or 40% of time, shaving that off for a lot of tasks might not take that much effort at all.
So give it a shot.
You might be surprised.
Let's say you're more like me, efficiency fueled.
Nah.
My recommendation is try hacking in the content first instead.
So this is the opposite of what I did with Scalia.
I made the tool first.
But my recommendation, hack in the content first, get that to work, and then once you've sort of got that, then you can make the tool.
Because the design is probably gonna change.
And the more specific a tool you make, the higher chance that tool has to becoming obsolete.
Which brings us to the sunk cost fallacy.
So if you've made a tool that does XYZ, it's actually hard to, it'll be harder for you as a designer or a developer to cut or change that feature, the XYZ feature.
Even though you should cut the feature, like subconsciously you might be inclined to not, to leave it in because you've got the tool to make it, to make stuff work.
But for the game, it's not the right decision.
So you can avoid that by like not making the tool first.
So let's say you're like this.
My threshold for investing in tools was basically how annoying it would be without one.
And that's sort of the equilibrium that I've sort of fallen into over the last five or six years that I've been using.
And so first I'll try to live without a tool.
I'll have in the back of my mind, somewhere in the back of my mind that this is inefficient, but I would go without it.
and I would increasingly potentially think, this is really annoying.
And I might become complacent with it over time, maybe, but sometimes not.
Sometimes it would stay annoying and it would stay in the front of my head.
At a certain threshold, once I'm annoyed enough, I'll ask myself, okay, so how long would it take to make the tool?
And would it save me time, ultimately?
So the time it costs to make the tool, would it save me more time?
And groove as well.
So example of this annoying thing, spike rotation, which I mentioned earlier.
So in Bounce Meister, how to rotate a spike, the original way of rotating spikes. You drag that out. Let's go over to the Z and we've rotated it. Oh no, that's 90. No, I think 90 is left or negative 90 is left.
Okay, if 90 doesn't work, then I would try negative 90 because I always get those two confused. Still get them confused.
I don't know how. Still getting confused.
Okay, so no, but like left is 90.
So I would put in 90 and it was actually negative 90.
So then I would remove the minus.
And it's for every single spike you see down here.
There's just a lot of spikes in each level.
So this is a ton of spikes.
It was a mess and it was really time consuming and it was goofy.
And it irritated me a lot over a longer period of time.
So I put up with it for weeks working on the game.
Then eventually I was like, OK, OK, OK.
What would be the easiest way to speed this up?
The absolute simplest way. Answer.
Okay, I can hit ctrl-r to rotate the spike 90 degrees, because I know I'm never rotating it by anything other than 90 degrees.
It's like everything is just, you know, orthogonal.
Okay, how long will that take?
It took me 15 minutes to put that in.
Excellent. That was so much quicker.
And that's what it looks like.
That's the right thumb.
Yeah. It was better, but it was still clunky.
I actually made it like a day or two using this before...
I was even fed up with that, because it was an improvement, but it still wasn't good enough.
So then I finally asked myself, okay, how long would it take for me to make auto-rotating spikes, spikes that rotate as you saw when you touched a surface? Okay, maybe about two hours. Okay, do I want to program that? Yeah, I absolutely want to program that. At this point, I'm so frustrated. Yes, I want to get this thing in. That's my answer. Yeah.
There it is. It's beautiful, right?
That took me an hour and a half.
It took me 90 minutes to add that.
And it saves so much time.
It's so much better.
So the manual rotation, let's say it took like, you know, 10 seconds or so.
And I lost my groove a little bit each time.
And like, that's, you know, if you actually add up the time on that, that's roughly three hours a month.
Because I'm rotating spikes at least 50 times a day.
This is a conservative estimate.
So just time-wise, that was three hours a month of lost time.
And I mean, I added this thing in one and a half hours, which is like crazy.
Outcome, 90 minutes, pay-off is.
Awesome. It was great. I was really happy with the outcome of this one.
It's a good custom tool.
Here's another example of a tool that I made for misaligned rooms, rooms that are slightly off.
So you can see right there, when we zoom in, those rooms actually don't match up.
They don't match up.
So like if you move into one, you'll like actually hit the, your butt will hit like the floor of the next room.
And that was a problem because it's really tough to see.
So I added a feature that would highlight these errors.
So if the map looks like this and you hit a button, it'll show like a little, it'll just highlight that.
So you can see, oh, okay, I need to, I need to fix that.
Which is very useful for the designer.
I asked myself, do I want to add this?
The answer was no.
I didn't really want to, it didn't bug me enough.
So I didn't add it.
I never added it.
I never put it in.
And I continued to be slightly bugged by the fact that I do this manually each time.
So this ideally would prevent human error, but I never put it in.
Is there a right answer for either of these, the spikes or the highlight in the errors?
There's not really a right answer.
It's messy.
Like, yeah.
So, incomplete tools. What about tools that we don't finish? Which I have a lot of.
So, as I mentioned at the beginning, our goal is to save time. It's not actually to make an amazing tool.
As fun as that might be, it's ultimately about saving time.
So, to illustrate that, Lionlight's map editor had a ton of bugs, which included...
Instead of double-clicking to open up a level, the framerate was so low that you would have to click up to ten times.
You just smash the mouse to open up a level. For every single level.
Also, some of the boundaries were wrong when it displayed the levels, so I actually wasn't sure.
I couldn't really trust them. That was a problem.
And every time you connected levels, you still had to open each one individually and like manually jimmy things around. All of that could have been automated, but I didn't fix those issues because I didn't actually have to. I was wasting time, but the time that it would have taken to fix them might not have balanced out the time that I actually ended up wasting.
When I ended up taking the code and repurposing it for Bouncemister, actually at that point I did fix the bugs because I was already in it, so that made more sense, and then I didn't have to deal with those things in the future.
So, you know, it's not necessarily the right answer.
So, last but not least, we have my Unity shortcuts.
Obviously these are Unity-specific.
These are bits of code that I've copied and pasted into every new project that I've made, and I continually add to them over time.
I've got game-agnostic code that makes things a lot faster and easier for me as a programmer and developer.
And if you're not working in Unity, and even if you are, you can use these sort of for inspiration as to ideas of how you can possibly save time.
So I have a link to it, right? Oh, that's complicated. Can we, uh, okay, that's better.
Alright, so go ahead and go to that link up there, cut.ly slash gdc2020tools talk.
Yeah.
Uh.
Yep, that's where the code is. You can download it.
Uh.
Alright, and I'll keep it up on the screen for the rest of the, um, rest of the talk.
Um, alright, so, uh, here's one.
Reloading the scene every time the script reloads.
Projects will often break when you recompile them in Unity, so if you make a change in C Sharp, the project will...
Like, things will just be broken when you come back to Unity.
For larger projects, it's kind of inevitable.
Um, uh, but this...
Literally, that is the code right there. That's all the code is.
You have to put it in a class, of course, that exists somewhere in the scene.
Um, but, uh, this prevents you...
This prevented me from having to stop and run the code after every change.
This would reload the scene, so every time I make a change in the code and I come back to Unity, it'll automatically reload the scene.
Um, instead of me having to hit the play button twice, which...
takes 10 seconds at least.
So that saved me at least 10 seconds for every compile.
And for larger projects it saves me more, because I don't have to, like, snap the whole thing and rebuild it.
Um, yeah.
Snap to Grid, which I already showed you earlier.
This is the code for that. For the rectangles it's a little more complicated.
But, um, for just the positioning of things, this is all it coded.
The code is, it's extremely simple.
Um, and useful.
So I also have some various structs that I bring into each new project that I...
I've got like a common folder filled with different structures that are useful.
So for example, Color255, ColorHSP.
So ColorHSP, of course, allows me to make colors in hue, saturation, brightness.
It'll automatically convert it.
Same thing with Color255.
So if I'm using ColorPicker.com, which returns a range from 0 to 255, but Unity takes it from 0 to 1...
For the longest time I would actually manually do the calculations, dividing the values by 255 after I got it from colorpicker.com, but I just made a color 255 struct eventually, which was very easy.
So you'll say new color 255, pass in the values from 0 to 255, and say adopt to color.
So that saved me a bunch of time.
And it seems like, like these are things where it's like, well, why don't you just, you know, use the regular color feature, or like, say like divide by 255 in each of, you know, when you construct it.
But that, that does take time.
And I spent actually years doing that.
And it ate up enough time where I wanted that, I wanted that little shortcut.
And this was so easy to make.
This is in the code up in the link up there.
Yeah.
And so for HSB, same principle, hue, saturation, brightness.
It's awesome.
I also have another example of a struct, vector2int, which I use all the time.
It's so weird that this doesn't exist.
So if you know vector2, those are floats.
But vector2int is exactly what it sounds like.
It's ints instead of floats.
I literally use this for every single grid-based game.
I don't know how this isn't built into default math libraries.
I use it all the time.
It's great.
And that's in the code as well.
Cool.
So GameUtils, it's just a file that has a ton of utility functions.
It's a static class that exists in all of my projects.
And it's got tons of common functions that are game-agnostic, but you would use frequently for Unity editing stuff.
Like parenting and resetting a transform.
So instead of saying, you know, parent, and then calling setPosition to 0, setRotation to 0, and setScale to 1, this does it all for you.
So you just say GameUtils.parentAndReset.
Transform, passing the two game objects.
So, uh, sizing a sprite render by pixels, it's weird that, very strange to me that that doesn't exist.
Um, but this lets you do it.
Um, setting the UI, the alpha of a UI graphic, so you just say game-utils.
Set UI graphic alpha.
Things that I'm surprised are not featured already, but it's just a library that looks into them.
Also, yeah, so Unity, after they modified their particle system, you have to manually cache the particle emitter.
It's like a whole thing.
Anyway, so this, Game Utils will take care of it.
It'll do it under the hood.
Yeah, so the Game Utils will take care of that for you.
So if you want to change the emitter color or stuff like that with the particle system.
So, and that's also in the code up there.
Also, yeah setting the editor camera position so there is a there's a function to call for that As well as like there's a there's a function to call for the copy pacing things to the users clipboard But I always forget what it's called. I always forget what the name of the function is It's like I don't remember honestly what it is. It's like something like universal Universal cache or something like that, but it doesn't it's not the word clipboard. I don't think anyway So if I ever need to use that feature I'll call gameutils.copytoclipboard because I remember what that's called.
So that's like a little time-saving thing.
It just calls the other line of code.
It's just, it calls another line of code, but I can't remember what that one is.
So that actually does save me a bunch of time.
And yeah, we've also got setting the editor's camera position, which I used in Bouncemeister, which is very useful.
Et cetera, et cetera.
There's a bunch of stuff in there.
Check out the code.
Mathutils, which is similar to gameutils, except you'll never guess the difference.
It's easy to guess.
So this has things that are like math related or numbers or like related to primitives.
So returning a random bool.
So instead of having to say random, like zero to one, if that's less than 0.5, that's a random bool.
So you just call mathutils.randombool.
It also can merge two rectangles, things like that.
I've got a lot of rectangle functions in there.
Rounding something to a specific amount of decimal places and doing that.
Doing sort of like, this is weird, Vector 2 doesn't have these features built in, like absolute values, max and mins of Vector 2s, but this lets you do it with them. So if you need to like absolute value of Vector 2, so that's all also in the code up there. Useful stuff. So to wrap things up, one global piece of advice I would say avoid generalizing. I alluded to this earlier, um, like it might be tempting to make a tool that you want to repurpose for other things.
Don't. Make it specific to your game. Make that tool specific to your game.
I made the map editor for LineLight extremely specific to LineLight, and it did exactly what I needed it to do.
And I was able to take that code, and with only a couple of hours of dev time, make it so that I could use that for BounceMeister, the other game.
that I made that I needed a similar feature.
Making them global, it's just not going to be worth it.
Just don't do it.
And it's okay that tools feel unfinished and incomplete.
That's totally fine.
Your tools, I guess, will probably feel about as finished as your games feel.
Because, like, does your game ever feel finished?
It's like, there's always more stuff that you can do.
So that's totally fine.
Get used to it.
And it's totally okay to make mistakes.
I do it all the time.
Yeah, that's just learning.
Part of life.
Yeah, other points.
So good tools are designed to keep the designer in a flow state, sort of keeping them in the groove.
So it's not just about saving time, although that obviously matters a lot too.
So it's sort of about both of them.
My advice, again, look at your process critically to see if you're wasting time.
If you're efficiency fueled or if you're easy going, maybe you're wasting time by waiting or doing a lot of repeating actions.
Take a look at that.
I noticed that I was, even just the color 255, adding that saved me that little bit of time.
Or if you're efficiency fueled, if you want to make things the moment that you think of them, maybe back off and hack it in first.
Yeah, if you have any actions, perfect opportunity for a tool.
But if you're trigger-happy to add tools, try hacking it in next time instead.
Also, it's great to leverage your programmer's enthusiasm and interest, because there were things that I would leverage on my own, things that I wanted to make, and it was a lot easier to make them.
And I was able to make them actually more quickly.
So that's not even unique to tools, that's sort of just like a general piece of advice, I guess, on a team.
If the programmer wants to do something that's...
don't necessarily do it because they want to do it, but it's a good reason, if they're interested in it, leveraging that interest is actually beneficial.
Happy teens, yeah.
Also, you're awesome.
Yeah, so that's my talk.
Thank you so much for your time.
Again, we got the link of things, there it is, of code, Unity shortcuts.
I'm Brett Taylor. You can email me if you want. If you've got questions, concerns, other things to say, brett at mydogsare.com Tweet me. That's it. Yeah.
Thanks for watching my talk.
I'll uh...
I guess I'll see you later.
Ah.
Got my hair.
Adios.
