I'm just super thrilled to give this talk today, Shading the World of Anthem.
And I need to give you a little bit of backstory to help you understand why.
For the last three years, I've been giving talks about writing shaders at the Tech Artist Boot Camp.
and each talk I would give examples of shaders that you could write and show and kind of break them down and show how they worked.
But I wasn't able to show anything from the game that I was working on because Anthem hadn't shipped yet.
But now that it has shipped, I can actually show an audience like you guys some shader examples from our actual game.
And that just feels super cool to me.
Before we begin, something that's really important for me to point out about this talk is that I'm the one here giving the talk, but I actually represent hundreds of really talented developers back home in both BioWare Austin and BioWare Edmonton, who worked really hard to make this game.
So while I'm going to show a lot of the work that I helped to create, I don't want to take credit for any of it, because it was.
a massive collaboration from the whole team.
And I especially want to call out the contributions of my colleague Nick Sadler, who was a fantastic shader artist on the project as well.
And with that, let's jump right in.
Just as a brief introduction, I'm Ben Cloward, and I've been a technical artist and animator in the video game industry for 20 years now.
These are some of the projects that I've worked on.
I also helped to create some software that's part of Max and Maya now called Shader Effects.
I don't know how many of you are familiar with Shader Effects and Max or Maya.
So I helped to work on that project as well as shipping these games.
And now of course, for the last three and a half years, I've been working on a little project called Anthem.
Can I see how many of you have played Anthem?
Alright, fantastic, maybe a third of you.
For those of you that aren't familiar with it, I wanna play a trailer.
So we'll just take a minute to watch that.
You are the chosen few, protectors of our world.
This is your time.
Fire!
Out there, you will fight the unimaginable.
Feel the power of your javelin.
It's precision.
Rely on each other.
Unleash your power.
Thank you.
So the first time I saw this trailer was at a company meeting on a screen maybe three times this size and when it was done I was just like, yeah, I'm fired up.
I want to go blow some things up.
Anyway, so as you can see from the trailer, Anthem is a...
The most recent adventure game from Bioware.
You're in a squad of up to four players.
You put on javelin armor and you go out into the wild to have amazing adventures with your friends.
So, we ran into a lot of challenges in the process of developing this game.
And when I originally gave this talk, to the tech artists at BioWare.
I have this slide here, and it just had bullet points with three of the challenges we ran into.
And they were like, no, no, no.
Bullet points in a list do not do these challenges justice.
We want you to separate them out and put them in like a triangle shape and just really emphasize how hard these things were.
because they're not just individual items, they actually multiply on each other.
So the first challenge was that we had a lot of diverse environments.
So we had swamps and jungles and weird alien interiors, and I'll show you some examples in a minute.
So we had a really large library of assets to support all of these different environments.
On top of that, we have a dynamic weather system in the game.
So any time while you're playing, the clouds can roll in and it can start raining softly and then rain harder.
So all of the assets in all of our diverse environments also have to support the ability to look wet and rained on at any given time.
And being a dynamic open world, we also have our day and night system, so all of our assets also have to look good under any lighting conditions.
So these aren't just like three individual challenges, but they kind of compound on one another.
So for each of these, I have a little demo video that I want to show you.
And this first one is an illustration of some of the diverse environments that we have.
So you can see we have rocky terrain and really weird looking alien interiors and jungles.
The list just goes on.
So you can imagine building lots of different types of environments require creating a very large asset library to be able to support this kind of variety.
really neat experience to be able to go to work every day and look at artwork like that and feel like, oh, I get to participate in this.
I get to help our environment artists build this amazing work.
Next, I wanna show you a video that shows what our dynamic weather system looks like.
While you're watching this, I wanna just kinda tell you that shader artists are weird.
And the reason for that is, you know, this is a game about getting in a javelin and going out and destroying things and fighting monsters and having a great time.
And here we are as game developers and what are we doing?
We're staring at the cement.
A few years ago, I took my kids to the zoo and I had my camera with me.
And my kids were all excited about looking at the animals, you know, oh, giraffes, lions, tigers.
And because I had my camera, I was looking around and I was like, ooh, there's really neat material reference here.
And so I had my camera pointed at the brick wall and a guy came up and tapped me on the shoulder and he was like, buddy, the monkeys are over there.
So anyway, you can see in this video we have the dynamic weather, the clouds roll in, you can see the little raindrops on the cement.
I have it sped up a little bit, but the puddles will grow dynamically over time.
And then you can see the rain ripples in the puddles.
And then the storm stops and the clouds dissipate.
and you can still see the rain ripples, but then they go away and then the puddles start to shrink.
And I have it sped up because I didn't think you wanted to sit here for 10 minutes just watching puddles dry. But yeah, that's how our dynamic weather system works and I'll get into that a little bit more later in the talk.
And then we also have our day night cycles.
And our day and night lasts about an hour of real time in the game.
And so I have this sped up 60 times.
So you only have to watch it for a minute.
But you can see that the sun moves across the sky and the shadows change.
And this was especially a challenge for lighting artists who had to be sure that the lighting looked correct at all times of the day.
They had to create nice looking cloudy sky, but then also.
a sky at night.
And when the sun goes down here in a minute, you'll see that the stars will come out, and you can see the moons go by, and it's just really beautiful to look at.
One of the things that I did to contribute to this is I wrote this shader that has the bioluminescent bacteria in the water that you can only see at nighttime.
So yeah, those are some pretty big challenges.
And I know these aren't necessarily things that are new in games, but they are really neat to be able to work on.
And I was excited to be able to participate in a project with time of day and dynamic weather and all kinds of fun challenges like that.
It makes it exciting to go to work when you have hard problems to bite off and chew.
So here are a couple of techniques that we used, or that I used, when faced with any particular challenge.
So I'd have an environment artist or the art director come to me and he would say, or she would say, I need a shader that does this.
And so I would go down these steps in order to create that.
First of all, I would go out and collect reference, either photos that I took for myself or images that I found with Google Image Search.
And I would bring them all together into a big reference library, and then I would work together with the person that asked for that particular asset to identify some key elements that represented the essence of what that effect was.
And just as important as identifying what we wanted to go into the effect was identifying what we wanted to leave out.
Because if you go out and look at reality, it's infinitely detailed.
And we just can't push that kind of detail.
And so you have to kind of draw the line somewhere and say, well, we can do this and we can do this, but we can't do these other 300 things that we see.
You really have to identify what you're not gonna do in addition to what you will do.
And then I would go about creating a shader step by step, trying to mimic each of these key elements that we had identified from our reference material.
So what I'm gonna do for the rest of the talk is I'm gonna walk you through three example shaders that were created for Anthem.
And I'm going to show you how those steps applied of collecting reference material, identifying key elements, and then building the shader step-by-step to replicate the elements that we saw in the reference.
So let's start out with lava.
So, as I said, first of all, we collect a reference, and here are some images of lava that we were able to find and bring together.
We used a lot more of this, a lot more images than this, but these are just a few examples.
So what we needed to do then, once we had our reference images collected, is identify some key characteristics that make lava what it is.
So let's take a look.
First of all, lava has these really interesting folds and wrinkles when it kind of piles up on itself and it hardens into these really unique shapes.
Secondly, you can see from the images that there's a really nice contrast between the areas of really molten lava, where it's really hot, and areas where it's cooled.
And then finally, there's this really beautiful gradient between bright yellow and orange and red, representing the different temperatures of the lava.
And not displayed in these images, obviously, but we also collected reference video of lava moving, and it has this really irregular way of oozing that we were gonna try to replicate.
So it also, in addition to being able to collect reference, it's also very beneficial if you can send some people to actually take photos of the real thing.
So we had some of our environment artists go on a photogrammetry trip to Hawaii.
Lucky them.
So they spent 10 days capturing images of all kinds of things.
And you can see here they're taking pictures of the lava flows.
Now, they didn't actually go to any real flowing lava, and so they kind of left that part up to me.
We weren't going to put our artists on top of active flowing lava.
but from what they captured with the photogrammetry and the images that we created, we were able to put that together and create something convincing.
So from the photogrammetry, I was able to derive some really nice source textures.
So you can see here we have our base color, our height, normal ambient inclusion, and smoothness.
And these all came from the photogrammetry assets that the environment artists created from their trip to Hawaii.
All right, so let's dive right in and create a shader.
Now, in the previous years when I've given these talks, I've been using the Unreal Engine, but at BioWare, we use the Frostbite game engine, and I love working in Frostbite because it enables us to create some really amazing-looking effects.
Pretty much anything that we can think of that we get from the reference images, I'm able to replicate in Frostbite's shader editor.
So here you can see I have my two base textures.
This texture at the top is a packing of the base color and the height.
And then the second texture is the normal, the ambient inclusion and the smoothness.
And I'm just passing all that data into my lit root node.
And so let's take a look at what that looks like.
So this is the lava that we're looking right at right here in the middle.
The rest of the environment here is just so that you can kind of take a look at it in context.
But this thing that's going diagonally down the middle is what we're gonna be looking at for this example.
And you can see that it's just this static lava that they captured from the lava fields.
And there's a lot more work that we need to do on this effect to make it what we wanna see.
So the first thing that I wanna do is figure out where in the lava I wanna put the molten parts.
And so to do that, I'm gonna start out by sampling the height mask.
So here I've got the height mask, which was in the alpha channel of my base color.
And I have this node down here called linstep, and this is very similar to smoothstep, but it's linear, and so it's a little bit more optimized.
And what that node does is it remaps the range between two values that I specified.
And then I'm gonna invert it.
This compliment node is like a one minus, it flips it.
And the reason I wanna do that is because the height map is bright where it's high, and I actually want it to be bright where it's low, because I want the lava to be in the cracks.
So after applying the height map, now you can see I've plugged my height map here into reflectance.
And the reason for that is I'm gonna use the reflectance channel temporarily just to get a debug view of what that mask looks like.
So here is our reflectance view, and you can see I'm starting to create the mask that will determine where the molten parts of the lava are gonna go.
And just using the height map, it's kind of blurry looking, and there's not enough detail there.
I wanna add some more details and make it look cooler.
So I'm going to...
Go back to my shader.
And what I can do is I had a lot of detail in the ambient occlusion and smoothness maps.
So those are coming from right here.
So what I'm going to do is take those maps and adjust them a little bit.
I'll adjust brightness and contrast, invert them, multiply a little bit to brighten it up.
And then I'm going to add those masks together with the mask that I already created for my height map.
And that's going to look like this.
So you can see, using the smoothness and ambient occlusion detail, I'm able to pull in some more detail and make it look a little bit more interesting.
The next thing I need to do is take that mask and map it to my color gradient.
So this is a gradient that I created based on the reference images, just kind of color picking, kind of a darker red, orange, leading up to a yellow and then almost white at the hottest part of the.
the gradient.
All right, so I'm going to take my mask here and use that as my coordinate to look up into my small gradient texture.
I'm able to store this.
In the previous slide, this gradient looks really big, but I'm able to store it in an image that's only like 32 by 4 pixels, because I don't need a ton of detail, because it's a nice, smooth gradient.
All right, so then I plug that color detail into my base color and also my emissive color, and I end up with something that looks much more like lava.
But we're not quite there yet.
There's a couple of things still missing.
First of all, I wanna mask out the lava so that it's not as bright on the edges to kind of mimic the fact that it's gonna be cool on the edges but more hot in the center.
And so I created another gradient image that just goes from black to white to black again.
And then I multiply from one side to the other, it's going black to white to black again.
And then I multiply my mask by that.
And I'm able to get an effect that looks like this.
So here's what it used to look like.
And then when we apply that mask, kind of masks out the edges so that over here, I'm not getting hot lava, but I'm mostly isolating that to the center of the flow.
All right, now there's one more thing that I need, and it's probably obvious.
Like, you've been staring at this lava, and you're like, why isn't it moving?
It's supposed to be flowing, right?
Lava flows.
So that's what we're gonna add next.
And we're gonna do it with a flow map.
And I'm not gonna spend a lot of time going into what a flow map is, because at last year's GDC, Abel spent his entire talk talking about what a flow map is.
But just really briefly, what you do with a flow map is you stretch the UVs of a texture along a specific direction, and that direction is defined in the flow map.
And then as the UVs become too stretched, you crossfade to another texture, which is also stretching, and you kind of ping pong back and forth.
So one texture is stretching out, and then you fade to the other one, and it's moving.
And this one, while you're seeing this one, this one pops back.
But because you're fading back and forth, you hide the pop.
So that's what flow maps are.
And in this case, I'm gonna use the flow maps to make the lava flow faster in the center and slower on the edges.
I could just scroll the UVs so that it all would move uniform, but I don't think that would look as nice.
And so we're gonna use a flow map instead.
And so here's my graph that sets up the UV coordinates to sample my two textures.
So I have my UV1 and my UV2.
And then I also have this logic here that's gonna set up the math to blend back and forth between the two textures.
So here's my graph as it was.
And now it becomes a little more complicated because I'm having to sample two textures, both of the base color and of the utilities.
And so this node right here is what I showed on the previous slide of the logic that I was using to set up the UVs for the flow map.
And then for my flow, I'm using this same gradient down here that I was using to multiply the brightness, so the black to white to black.
And that's gonna make it flow faster in the middle and slower on the edges.
So then we end up with something that looks like this.
So you can see that over here on the edge of the effect, it's hardly moving at all, but then the lava in the middle is flowing faster.
All right, and that is the lava effect.
And I have a little video here that kind of shows this example plus a couple of other ones so that you can see in context what this effect looked like.
I also, I didn't show this in the shader itself, but I also added some controls that would allow the environment artists to control the temperature of the lava in various places along the flow.
So in the...
In one of the shots you could see that it was really red looking and then in other places it looks really warm and that's because they were able to control at each point along this flow how hot and how cold it was.
All right, let's move on to the next example.
So now we're going to talk about the dynamic weather in the game.
And so, as with the lava, we needed to go out and capture reference.
And this is, yet again, more evidence of how weird shader artists are.
Here I am with my camera, standing in the rain, taking pictures of things with raindrops on them.
So, you can see that from the reference images, Hard surfaces have rain that hits them and it kind of rolls off and runs down the side.
Porous surfaces, the rain soaks into them.
After it's been raining for a while, puddles form and the puddles have ripples.
And so these are all the kinds of things that we want to try to imitate as we create the weather for our game.
So as I said, the next thing that we do is identify these key steps.
So we're gonna talk about creating wetness, creating rain drops on the horizontal surfaces, rain drips on vertical surfaces, and also puddles.
So let's jump right into it.
First, we're gonna talk about wetness.
So when surfaces get wet, what happens?
If the surface is porous, The liquid is going to soak into them and it's gonna make the surface look more saturated and darker.
And if the surface is impermeable, the water is gonna pool on the surface and make it more smooth.
So this shader function is doing just that.
I have a mask down here that's determining how wet the surface is gonna be.
And it's also using this term called impermeability to figure out what should happen.
And I also have this term here, the drop and puddle mask, because we know that it's gonna be 100% wet if it's puddle or if it's a raindrop.
So then I use that value to determine the final base color, the smoothness and reflectance.
Smoothness and reflectance are fairly straightforward.
I can just blend between the current smoothness and the smoothness of water based on the mask that I created.
and the same with reflectance, blend between the current reflectance and reflectance of water based on the mass that I created.
The base color is just a little bit more involved.
Here I'm blending between the base color and my adjusted wet color based on the mass that I created.
And in order to create the adjusted wet color, I use this desaturate node with a negative value, which actually makes the color more saturated.
I know it's called desaturate, but if you pass a negative value into it, it actually saturates.
And then I have this multiplier here, which is darkening the color.
So this is the wet color and the dry color, and I get my final color based on where the wetness shows up.
All right, next I want to show raindrops.
And there's a really important principle that I want to talk about with this slide.
And that is, it's really important to do as few texture samples as possible in your shaders.
The more times you sample a texture, the more expensive it is.
And so here I have four different maps that I need in order to create my raindrop effect, but I wanna figure out a way that I can pack them all together into a single texture so that I can just do one texture lookup for the entire raindrop effect.
So my normal map has three channels, and I know that I can derive the Z component of the normal in the shader, and so I really just need two channels for my normal map.
Then my second map here is temporal offset map.
And every drop here, I don't know if you can see on the slide there, but every drop is a different shade of gray.
And I'm gonna combine that with time.
I'm actually gonna subtract it from my time value so that when the drops are animated, they happen all at different times instead of all at once in sync.
And then I have two masks here.
One mask is for my animated drops, and my other mask is for my static drops.
And if I put my normal map in my red and my green channel and my temporal offset mask in my blue channel, that leaves me one channel left and two masks.
But in this case, the really nice thing about these masks is that the data doesn't overlap.
So the animated drops fit in between the static drops.
And so what I can do is adjust my animated drop mask so that it goes from .5 to one, and my static drop mask so that it goes from .5 to zero.
Does that make sense?
So I'm packing the two textures together into one single channel.
So when I'm able to do that, then I can take all this data and put it into one texture, and then just use one texture sample to create my effect.
And so here's what my shader graph looks like for creating the raindrops.
This up here is multiplying by two and subtracting one, which is a standard operation that you have to do for a normal map.
To switch it from your texture, you're storing your data from zero to one, but in a normal map it needs to be negative one to one.
And so I expand that by multiplying by two and subtracting one.
And that gives me my normal multiplied by my mask.
And there's the normal that I need for the drops.
So let's talk about how the mask is created.
Here's the blue channel, which is my temporal offset mask.
And as I said, I subtract that from time.
and then I take the fractional value of what's left.
And what that does is it gives me time that proceeds from zero to one and then jumps back to zero to one and then it's like making it into a loop.
And with that temporal offset mask, it makes every drop loop at a different time.
Now, there's something really interesting going on here, and that is these two nodes that I'm using to expand my normal map, that's exactly what I need to expand and separate out the two masks that I packed together in the same channel.
So I had one that went from .5 to one, and the other one that went from .5 to zero.
And with this times two minus one, now I have one map that goes from zero to one, and the other map that goes from zero to negative one.
And so it's really easy to just add a single saturate node to get the one mask because then I throw out the data that's less than zero and I just have the mask left over that's from zero to one.
And then for my static drops, I multiply it by a negative one because that data is from zero to negative one.
So if I multiply it by negative one, I flip it over and then I saturate that and I have my animated drop mask.
So I'm able to share these two nodes that unpack my normal map in order to also unpack my animated and static drop mask.
So then I combine those two masks and I multiply them by this other mask down here.
Now this is my world space normal with my Y component.
facing up and also a factor that I pass into this to determine like is it raining or not.
And so then I'm able to multiply my map by that and I get my drop mask out and my normal map out.
And my result looks something like this.
You can see on the top of the surface here, I've got drops and some of them are static, some of them are animated and I don't get any drops here on the side of the object.
All right, let's take a look at puddles.
Now, I know that puddles have been a kind of a controversial topic lately, but we're gonna talk about them anyway.
So, we wanted puddles to form all over the map.
and we're able to procedurally decide where to put them based on a noise texture.
And this particular shader that I'm showing here is for our props, but on terrain we actually used two of them that were scaled differently and combined with each other so that the tiling was much less apparent.
But I wanted to show kind of a simple example so that it was obvious what was going on.
But basically this is projected from world space Y.
Down here for puddle size, one of the neat things about the Frostbite engine is that I'm able to really easily pass in parameters from outside the shader that the engine is controlling externally.
So in this case, this wetness parameters red channel contains a value from the environment system that is the accumulation of water.
And what this does is the game is keeping track of how long it's been raining, and the longer it rains, the higher this value gets.
So it's basically controlling how big the puddles can be.
And then I remap these two values and pass them into my LensStep, which again is remapping my texture color.
So the puddles start out really small in the areas that are black, and they grow over time as my wetness red channel value gets higher.
Then, I also have another y up value here that's masking so the puddles only appear on up-facing surfaces.
And I have some logic up here in the shader that's controlling what the normals look like in the puddles.
I have one node that does the wind ripples and another node that does the rain ripples.
So then I add those together and I blend between the current normal and the puddle normal.
and here I pass out my puddle mask and my normal mask for the puddles.
Now, if you've attended my talk two years ago, I actually went into a whole lot of detail about how these drop ripples were created.
And in that particular talk, I was using the Unreal engine, so you can see this node graph looks a little bit different than the other ones that I've been showing, and that's because I built this example in Unreal, but it's basically the exact same thing in Frostbite.
Because I talked about it back then, I'm not gonna go into a whole lot of detail about how these ripples are created now, but please check out the talk that I gave two years ago on the vault to go into more detail about how these ripples were created.
So I take this ripple logic, and then I duplicate it four times.
You can see how that's happening here.
And the reason that it's duplicated four times is if you're just doing it like this, there's no possible chance that any of these ripples can overlap each other.
And that's really what we wanted to do.
And so I needed to do this effect multiple times with different time offsets, different speeds, different positions and scale offsets as well.
So when all of those are combined together, you get an effect that's much more convincing.
So here I have my four ripple nodes and I combine those normals together and then I pass them out.
Now, if you really want to get a lot of detail on creating weather effects and rain and puddles and ripples, I recommend you take a look at Sebastian Lagarde's blog online.
It's absolutely amazing.
He goes into all kinds of scientific detail about what surfaces look like when they're wet, how they change.
And he's got all kinds of references.
And it's just really, really useful material.
So here's what our puddles look like.
And in this particular video, I didn't actually capture it long enough to see the puddles grow.
But you can see that they do have the wind ripples and the rain ripples.
And we get puddles on the up-facing surfaces of terrain and objects that are flat.
All right, so I talked about how to create raindrops, and I talked about how to create puddles, and we talked about wetness.
So what this graph is doing is it's combining all of those effects together.
So this node here represents the drops graph that I had previously.
This node here represents the puddles graph that I had.
And then down here what I'm doing is I'm making the world kind of wet overall.
So...
This multiply here is like a value of .6, and so everything in general gets about .6 wet after it's been raining for a little while.
So I know that my drops are 100% wet, my puddles are 100% wet.
And then everything else is about 60% wet.
And I combine those together, and then I run that through my wetness so that we can create wetness where there's a puddle, where there's a raindrop, or just in general for 60% of everything.
And so that's how our weather effects are created.
Now this is a really simple example.
We actually made the liquid look different on different surfaces, so it works differently on rocks and it works differently on hard surface objects and it works differently on terrain.
But this is a fairly straightforward way of illustrating some of the things that it does.
All right, and here's kind of a montage video showing what it looks like on different surfaces.
So here are some ruin walls. You can see the water kind of flowing down the sides.
The puddles with the wind ripples and rain ripples.
Also water flowing down the sides of rocks.
And you can see droplets on hard surface objects.
And this was so much fun to do. I just absolutely loved figuring out how to do all these things.
All right, let's move on to water surfaces.
We had tons of water in our game.
I think our environment artists decided early on that they really liked the way that water looked and so they were just going to put it everywhere.
So we ended up with all kinds of water.
But I'm gonna go over kind of the basics of creating a water shader, and then we'll show some examples of the variety of water that we had.
So here are some images that we collected kind of as reference to figure out what water looks like.
And these are some of the key elements we identified.
So water has ripples on the surface.
It changes color as you go from shallow water to deep color.
It also changes opacity.
It's really transparent when it's shallow and it gets less transparent the deeper that you go.
Then it has really nice looking reflections and it also has refraction.
So this is what we start out with.
We start out with just a completely blank slate.
We have a flat plane here, just a solid gray color, and we need to create a shader that makes this look like water.
So I'm gonna start off with the surface ripples.
And you can see here I have a normal map that looks like rippling water, and I'm using three of these, and basically these are different sizes, and I'm scrolling them at different rates across each other and combining those together.
Now I need to step back and tell a story here.
I gave my talk for my wife maybe two weeks ago, and when we got to this slide, she said, wait a minute.
She said, a couple of weeks ago, you and I were on a date, and we were taking a walk down by the river.
This is the River Walk in San Antonio, for those of you that are familiar with it.
And you pointed out the water to me, and you said, isn't that beautiful water?
It has small ripples.
It has medium ripples.
It has large ripples.
And I thought you were being romantic.
She said, you were doing research, weren't you?
It's really easy to get into trouble with your wife when you're excited about things and you're out on a walk, so be careful.
Anyway, so what this network is doing is it's combining three different sizes of ripples together.
And we also have this control here that blends between, this blue color here represents a flat normal, and we're able to use ripple one suppression, these are values that I can pass into the function, ripple one suppression and ripple three suppression to control how much of each of those I'm blending together so that I can get more big waves or more small waves.
And so here's the very simple start of my shader.
The ripple normals are in this node, then I use this node to transform them into world space because that's what Frostbite wants.
And then I just pass that into my root.
And I get something that looks like this.
So it's not water yet, but you can see that the ripples are sort of trying to approximate something that might become water if we do a little bit more with it.
All right, so the next thing that we want to do is use some depth.
So I add this depth node, and what this does is...
Surfaces below my water that are really far away, and I can specify a value for how deep the maximum is, that will appear white.
And anything that's really shallow or right next to the surface of my water will appear black.
So in this case, I'm just gonna start out by passing that into my base color and I get something like this.
So you can see that it's sort of white down here where it's deep and black up here where it's shallow.
So that creates a mask for me and then I'm able to use that mask to do some interesting things.
So the first thing that I'm going to do with it is blend between two different colors.
I kind of have this light green color where it's shallow and then this sort of darker blue color where it's deep.
And that gives me something like this.
So I have my darker blue color here and my lighter green color here.
But I can also use this mask for opacity.
And so in this case, I'm just going to take my depth opacity here, and I'm going to pass it into the opacity on my root node.
Now, I'm adding a value of 0.2 because I don't ever want the water to become completely transparent.
Even at the edges, I want it to have a little bit of opacity, so I add a value of 0.2 there.
And so where I started out with this, when I use my depth for opacity, I end up with something that looks like this.
Now, there's nothing amazing or fancy in my shader that's creating those caustic patterns dynamically, so don't kind of get that idea that I'm doing something amazing there.
The caustics are a completely separate effect that we project using an environment decal.
But they are there to illustrate the fact that you can see through the water, and it's more transparent where it's shallow, and then as it gets deeper, it's less transparent.
All right, so there's still a little bit more that we need to do, and the next step that we're gonna do is add in some reflections.
So this node takes my world space normal, and it generates reflectance and smoothness values.
Now the smoothness values are pretty much constant.
I think I just passed in like a value of .95 or something like that.
But for reflectance, what I want is to use a Fresnel term.
So the water is more reflectant at a glancing angle, and then if I'm looking straight down into it.
it's less reflectance, so that's what that's giving me there.
And so this is what it looked like without the reflectance, and then I add in the reflections.
You can see that I get really nice reflections out here where my water's at a glancing angle, but as I'm looking down directly into it, I get less.
All right, now there's one last thing that's missing, and that is the refraction on the water.
So I'm gonna add in one more node here which does refraction.
It takes my tangent space normals and does a screen space distortion effect.
And this also has a Fresnel term in it so that I'm only getting refraction when I'm looking down at the water and not when I'm looking across it.
I wanna get reflections looking across it and refractions when I'm looking down.
And so this is what it looks like without the distortion or without the refractions.
And then when I add that in, I get something that.
Looks pretty nice.
Now we got some water.
We've got reflections, refractions, depth-based opacity, and depth-based color, and then some nice ripples on the surface.
And these are all of the elements that we put together to create basic water.
We did all kinds of water for this game, like I said.
So I would start out with this, and then the environment artists would come to me and they would say, can you make it look muddy?
Can you make it look like somebody poured antifreeze into it?
Can you make it really swampy looking?
And so we created tons of different kinds of water, and I put together this video montage to give you some ideas of some of the different looking water effects that we're able to achieve in the game.
All right, we're almost done.
So let's just go over a couple of takeaways.
The first one is that collecting good reference is critical.
And if you can sneak in a trip to Hawaii, that's good too.
Next, it's important that when you create or when you collect your reference that you identify the elements that make this thing what is it.
You boil it down to its essence and figure out what is it that I'm going to try to imitate in my shaders based on the reference.
And like I said before.
it's almost as important to identify the things that you're not going to do as to identify the things that you are going to do. And you need to figure out things that you can leave out to save on performance.
because you can't do absolutely everything.
Early on in the production of our game, we had a lot more complicated looking weather, for example, and we found that we just couldn't run it and we had to simplify things a lot.
So the examples that I showed you were the more simplified versions of what we started out with.
So it would've been a lot better to do that up front, but that's not how things turned out.
If I've done my job today in my talk, hopefully all of you are thinking, man, shader work is super cool.
How can I get into this?
Like, if you don't write shaders, how can I start learning this?
And here are a few things that you can do to get started.
First of all, take a look at other games.
When I was in the process of working on this, I loved playing games like Horizon Zero Dawn and Spider-Man.
Just by show of hands, how many of you have been to 10 or more talks about Spider-Man at GDC?
Okay.
Yeah, but anyway, I loved looking at other games and figuring out what they were doing.
You can do Google and YouTube searches for tutorials on writing shaders.
You can download Unreal for free, for example, and get into shader writing that way or use shader effects in Max or Maya.
And most importantly, just do it.
Identify something that you want to try to imitate and just give it your best shot.
And I talked about finding a book to read.
These are some of the books that I learned how to write shaders with, and this was maybe 10 or 15 years ago.
But this knowledge is all still very relevant to writing shaders now.
So if you wanna get started, it's really great to grab a book.
A lot of these books are available for free online now.
And so that's my talk.
I have my email address here and my Twitter handle if you wanna give me some direct feedback.
And I really appreciate all of you for coming and listening to what I have to say today.
So thanks a lot.
And it looks like we have about five or 10 minutes for questions.
So if you'd like to ask a question, feel free to step up to the mic, and I'll do what I can to answer.
Go ahead.
Hi.
Hello.
I'm sorry.
I may be missing some information, so just want to confirm that.
For your rain drops maps, they are not normal map, and temporal offset mask and three masks.
Then you said that you package them to the one map.
So as I know, like the RGB channel only three channels.
So how could you package all maps in the one map?
And like when you withdraw the normal map, you make sure it's the correct normal map.
Sure.
So a texture can have three channels, or it can have four channels.
You can have red, green, blue, and alpha.
And so the static map and the animated drop map were both packed into the alpha channel together.
OK, so screen or overlay together in the alpha channel?
Right.
OK.
And then the second part of your question was about the normal.
Yes.
So if you put the red in, or if you put the x component and the y component of your normal map into the red channel and the green channel, then in the shader, you can reconstruct your normal.
Now in this particular example, I just kind of, didn't do that to make it cheaper.
But if you want it to be technically correct, you can do the math to derive the z component from the x and the y, because the normal is supposed to be normalized.
That math has a square root in it, which is kind of expensive.
And so I just skipped it in this effect because I didn't think it was necessary.
I just assumed a value of one for the...
for the z component instead of calculating it.
OK, OK.
So actually, you use the blue channel to package one map, and then the alpha channel packages the rest two, right?
That's correct.
Thank you very much.
You're welcome.
Over here.
Hi.
You mentioned your first pass on the weather stuff wasn't performing enough to ship, and you had to optimize it a bit.
Sort of along those lines, do you have shader LODs or per skew shader control, high, medium, low?
Yeah, yeah, absolutely.
And those are the kinds of things that I took out of these examples, just so my graph didn't look like a pile of spaghetti.
For the shots of my graphs that I was showing here, they're really simplified down.
But we have a node that controls quality, where you can, it has a low, medium, high, and ultra pin, and whatever you pass into each of those pins is what gets compiled as the shader for those quality settings.
How often do you have to use that, like what percentage of the materials in the game need a cheaper version?
Um, that's a hard question.
I use it as often as I can.
because you want the game to be much more performant on each of those levels of quality.
If there are things that can be left out without absolutely killing the image, then we want to do that on the lower quality levels, for sure.
So you do it ahead of time instead of waiting for engineering to come to your desk and?
I've never had engineering do that to me.
I usually do it myself because we work in kind of two passes.
So we'll do a look dev development pass and get things looking the way that we want them to and then we'll go back and perform a performance pass.
And really that just involves, you know, using.
Razer on PS4 or PIX and just kind of seeing how much things cost and well does it does it fit in my time?
And if not, you know, how can I make it faster?
Cool. Thank you. You're welcome Hello. My question is more on the organizational bookkeeping as you're putting together these growing libraries of shaders. So you mentioned you have environment artists come to you and ask you for a new effect or you have these extensive different types of water and I struggle personally to where I'll...
go down the path of wanting to create more and more like master materials.
So do you have any certain cutoffs that you try to keep to to determine whether you want to combine two setters together or keep stuff more separate?
That's a really good question.
In the case of water, we don't have the ability to pass.
external parameters in to adjust it.
And so every time the artist wants something new, I need to create a new shader.
And that's one of the reasons why all of those water nodes were created kind of modularly.
I had one for reflection, one for refraction.
Because I could just take those and put them together to create a new one fairly quickly.
Yeah.
Yeah, for some of the other assets, like vegetation, or rocks, or that sort of thing, we had one really large shader, but then you could tick boxes to turn it on and off the features that you needed.
so that the shaders didn't get out of hand in terms of how many of them there were.
The artist could just pick, I want the rock shader, and then they could check the boxes for the features that they needed.
Even with the master shader for the rocks, is there a certain cutoff to where you don't want to have 20 plus exposed parameters for them to go through for easy use?
Yeah, absolutely.
I don't have a silver bullet for you on how to decide how to do that.
But definitely something to consider.
Yeah, yeah, absolutely.
Thank you.
I'm interested to hear more about the optimization pass.
Did you optimize it yourself, or did you ever hand it over to a graphics programmer to kind of hand optimize it?
No, none of our shaders were touched by graphics programmers.
Sometimes they would say, hey, in general, this view is too expensive.
Go and figure it out.
But optimization of the art assets is generally the domain of the tech artists at our studios.
And so the graphics engineers would say, hey, tech artists, figure this out.
But they wouldn't actually get in and tell us how to do it.
It was just a matter of isolating a specific view or direction that we are looking in the game.
And if it's not running at 30 frames a second here, or actually faster because we had to account for characters and VFX and all kinds of other things.
I think our target was like 25 or 28 milliseconds.
If it was over that, then we would just run that specific frame through Pix or Razor and identify targets of opportunity to produce.
All right.
Thank you.
Mm-hmm.
Yeah.
I've already tried to packing extra information to a normal map channel, but with DX5 compression, I cannot avoid compression artifact on normal training.
So could you tell me what kind of compression setting did you use?
Yeah.
So in the case of this rain texture, it's a 512 by 512.
And because it's used on every asset in the game, we did not compress it.
So this texture is stored uncompressed.
Oh, I see.
Okay, thank you.
Oh, hello.
Nice talk.
I'm interested in doing the refraction.
Did you do it in the screen space, and did you use the depth map to assist the pickup of how to resolve the resulting angle of the light vector?
Right.
So one of the things that's interesting about our engine is that, yeah, it does this distortion in screen space.
And what I really would like to have is something where the surface of the water is not distorted and it only distorts what's underneath it.
But unfortunately because this is a screen space effect, it gets applied to everything.
And so that's why it was really important to do the fall off or the Fresnel so that it only showed up when you're looking directly down.
What was the second half of your question?
I was just wondering if you used the depth map to assist in that pickup.
So I used the depth map to determine how much distortion to apply.
So the deeper the water it is, the more I would distort.
Is that what you're talking about?
OK, so it is an approximate term then.
Yeah.
Very nice.
Thank you.
All right, last question.
I was actually wondering about that depth map myself.
Is that a screen space depth map for your water depth?
Or is it actual, like from the top, how deep is the water down?
Ah, so yes, it is a screen space effect.
Did you run into any issues with the fact that different angles would produce a different depth touch?
Yeah, and for that I had to multiply it by a Fresnel term to isolate it so that you'd only get it when you're looking down.
It had to be adjusted, yeah.
Gotcha.
Thank you.
Good question.
All right, thanks a lot for coming, everybody.
