All right, let's get this party started.
And we have no audio.
Oh, oh, thank you.
Good morning, everybody.
I'd like to welcome you to my first ever GDC presentation.
So I'm a little nervous.
Thank you for coming at this ungodly hour.
So my name is Michal Mach.
I started my career in the games industry back in 1999 as a 3D modeler on Mafia, the City of Lost Heaven game.
Luckily, our company had only one animator at that time, and they thought I could have potential.
And I was probably decent, so I became a lead gameplay animator on Mafia II.
After that, I helped Vatra Games with the Silent Hill Downpour, and in 2011, I joined the Naughty Dog's Kennel as an animator.
So, what physics animation means to us?
It's anything animated while physically simulated.
The most common implementation of physics animation is a ragdoll simulation.
Basically, every game today has it in some form.
We were already using ragdoll when characters die, but we wanted to experiment further and see if we could use it more creatively.
We don't want players to notice when the physics animation is running.
Fitting the character and natural look and feel is number one priority.
I'd like to show you what did and did not work on a few examples from our games.
But why bother with such a risky thing like physics animation when we have an army of animators, right?
We could just brute force it.
And it's because we were planning on abandoning the environments made of boxes, right angles, and perfectly vertical walls.
Physics helped us with blending out of already massive amount of animations, and sometimes allowed us to fully simulate something that would be otherwise a chore to implement using the old ways.
We wanted our characters to react more believably to whatever was happening to them.
Our characters have incredible level of detail and we wanted to match the same level of fidelity in animation.
We also wanted players to be able to interact with the dynamic stuff, more physics, ideally everywhere.
And because it's fun.
But first things first, our games are running on Havok.
So I'm going to use terminology specific to this physics engine.
Although most of it applies to other physics engines as well.
Let's start with rigid bodies.
These are the objects roughly describing geometry of our characters.
Each rigid body has joints associated to it.
Rigid body has its mass or weight, friction, restitution or bounciness, and inertia tensor.
Inertia tensor describes how difficult it is to rotate an object around any given axis.
Basically, the higher the inertia tensor, the more stable the object is.
Linear damping reduces the linear movement of the object over time, and angular damping performs the same to the rotation of the object.
Rigid bodies can be connected by constraints.
For organic forms of life, we mainly use two types.
Hinge constraint limits rotation in the joint to one axis, typically used for knees and elbows.
Rectal constraint is the more common one as it behaves similar to majority of joints in our bodies.
Unfortunately, both types of constraints don't behave too realistically unless we set up limits for them.
Limits are kind of difficult to set up.
Every person has different natural flexibility so it's hard to decide what is the sweet spot.
I prefer more restrictive limits to prevent characters getting stuck in weird yoga poses.
or this one. Trust me, I have seen these exact poses in our game before.
This particular one can happen when you have too much friction on your rigid bodies.
And also make sure the limits are not too restrictive, so the characters do not look like they are just taking a nap.
Now we have max friction torque, and it simulates friction in joints and tendons surrounding them, so the rigid bodies will not flop around freely like in the video on the left.
set max friction torque to 20% of the mass to start out.
Finally, to be able to animate a ragdoll, we can use constraint motors.
Then the regular constraint becomes a powered constraint.
Motors try their best to match our animation pose with maximum motor force, but we don't want them to overshoot the pose, and that's why we also have motor damping.
Another tool we have is ability to limit how fast the motor tries to recover the animation pose if something pushes it around.
So the right side is low speed and left side is high speed.
And finally, we have a motor tau, which is basically motor stiffness.
You won't see almost any difference, but you can totally feel it.
So yeah, that's it.
That's all the parameters I usually tweak while I'm setting up the regular.
There's so many parameters and all of them are kind of connected.
Changing one often influences others too.
So, please, read the manual.
I know it's boring, but after endless hours of tuning random numbers, I gave in and read the most interesting sections.
Also, check out demos provided with your physics engine.
They show off features in nice, simplified form.
And if you have your own custom physics engine, talk to your programmer and ask him for how stuff works.
OK, here are some basic rules I wish I knew when I started.
Don't try to imitate real life.
Reduce mass of your rigid bodies by 10 to 20% for each bone going out from the root.
Check for unwanted collisions.
The chest area is so congested that it's really hard to see what's happening inside.
And now you can start testing and tweaking.
Scale inertia tensors should you need to stabilize disproportionately sized rigid bodies.
and be patient.
It takes time, a lot of time to set everything up.
But don't be too patient.
I'm talking from my own experience because one day I was wondering, why is our ragdoll so floaty in the game?
It was perfectly fine in Havoc debug tools, but super floaty in game.
Maybe something was lost in translation?
And I spent hours, well, maybe even days, tweaking damping on rigid bodies, and I felt like it's way, way better than two days ago, but I still wasn't satisfied.
So I went to see our physics programmer and asked him for help.
and he checked the game code and he was like, oh yeah, yeah, yeah, it's hard-coded.
So make sure you are allowed to change the parameters you are trying to change.
Anyway, how do I test my ragdolls?
I start throwing them around, basically, with the mouse.
That's the advantage we have as game developers.
Body should unfold itself into a natural-looking pose if limits, restrictions, and friction and everything is set up properly.
The human body is soft and squishy, so tone the restitution down.
As I said before, I like to keep limits on the restrictive side.
So if I put this guy's hand on his chest, it naturally slides down next to his body.
And make sure you have correct friction on your rigid bodies.
This guy's leg could get stuck on the other leg if the friction is too high.
And you might get that taking a nap pose.
And what I also like to do is this sitting test.
I think that characters should be able to sit next to a wall, but it looks so cool and dramatic when it slowly slides down.
Okay, now it's time to test the regular in the real gameplay.
By the way, when I was doing this, for some reason, the dead bodies get reappearing every time I respawn the character.
Yeah, we are spooning in Uncharted 4.
So, basically, when I'm playing, I'm trying to find out how often I can see a bad pose.
This is the friction on the legs.
And this is my arm test.
The chances to see a broken ragdoll are much higher when the characters are moving fast and hitting a collision.
so it was all physics and the limits basically held the character from breaking.
And one more.
As you can see, I spent some time already there, all the weapons.
Anyway, so we tested our ragdoll, if it's flopping around properly, but now it's time to animate it.
And when we talk about animating rigid bodies, we talk about their states.
Keyframe rigid body, which is drawn in blue color, is 100% driven by animation.
As you can see, I'm trying to move it with the mouse, but it's not possible.
We use keyframe rigid bodies for pinning hands or feet to other objects.
We usually disable collisions on keyframe rigid bodies so they won't kick the other objects to the moon.
Next is powered or animated rigid bodies.
They are drawing yellow.
This one is also driven by the animation, but this time I can move it around by applying impulses or by colliding with other objects.
By the way, notice how the Drake's screen left arm is flailing around.
That's because it's not powered.
And that is the third and last possible state of our rigid bodies.
Unfortunately, it's also yellow, but don't worry.
I won't be showing unpowered rigid bodies in my presentation.
Okay, so I mentioned rigid bodies, and let me briefly explain how we can do that.
We use so-called animation controllers, and the first one is Powered Constraint Controller, which we call simply motors because it uses the constraint motors I talked about earlier, and it's also shorter.
Havoc recommends this controller when animating dead or dying characters.
It's because it's working in local space, so it cannot keep the character from falling without using additional tools.
But it produces pretty realistic results, thanks to its local space nature.
So if you move one rigid body, it moves all of its children with it.
Unfortunately, we were not able to match an animation pose without using really stiff motors, and that tend to overshoot and vibrate.
By the way, the vibrations in the video are slightly exaggerated, so you can see them better.
And the second animation controller is a rigid body controller, which we call keyframe controller.
It is very different from motors because it is manipulating velocities of individual rigid bodies to match an animation pose.
Havoc recommends this controller for live characters because it works in world space and therefore can keep them from falling.
Due to its world space nature, it has this kind of IK look.
So if you move, for example, the upper arm, the hand tries to stay in place.
You can see the similar effect in the head as well.
But it's incredibly easy to match an animation pose.
And the controller is very stable.
Let me show you both controllers again, side by side.
I also marked the key differences between controllers for you.
It's going to be important later.
And so we have this physics terminology over, and let me finally show you some examples.
Yeah, I know I promised Uncharted 4, but let me start with the first game where we ever used our current technology for the first time, and that is The Last of Us.
So this scene is towards the end of the game where Joel saves Ellie, spoiler alert, from being killed by fireflies.
She's under anesthesia and therefore she's unconscious and Joel is supposed to carry her away from the hospital.
It was supposed to be a very touching moment, so Ellie's arms and legs should be moving, but not too much, you know, so it doesn't look comical.
I checked YouTube, hoping for at least a few helpful videos.
But I was really surprised when my search returned tens of thousands of results.
Yeah, there was one playlist that was 469 videos.
It was crazy.
Okay, back to animation.
We already had this sequence at the beginning of the game where Joel carries his daughter Sarah.
So we decided to reuse his moveset, but we had no time to create animations for Ellie.
One idle and one run-forward animation had to do it.
Let's see it.
Yeah, it looks pretty solid, no?
I mean, at least body is pretty solid.
It's not moving at all.
Yeah, this was not shippable.
We needed a solution that could get away with limited number of animations and provide proper reactions to Joe's motion.
So physics, right?
What can possibly go wrong?
And there we go.
This is our initial setup.
As you can see, Ellie's torso and left arm were fully keyframed and not simulated at all.
We simulated only the right arm, head, and both lower legs.
We encountered a problem with our asset building pipeline, though.
Our characters can have only one ragdoll, so we had to hack in this additional ragdoll for Ellie, just for this sequence.
Okay, let's check how it turned out.
Yeah, it's not very emotional, is it?
So yeah, we tried both motors and keyframe controller to drive the Ragdoll, but yeah.
Okay, he's dead.
So we tried both, motorist, keyframe controller.
Motorists worked great until players started changing direction.
Increasing their strength wasn't a solution because we needed those limbs to be loose.
And keyframe controller felt better, but loose limbs had this weird linear motion in them.
Keyframe controller is, after all, linear, right?
It's in world space.
So, okay, we needed to decide between motorist and keyframe controller.
How could we keep using motors for nice follow-through in Ellie's limbs, but stabilize them without increasing the motor strength?
Is there a way to cap acceleration in joints?
And we got this revelation one, and that is that standard approach is to use motors or keyframe controller for animating rigid bodies.
But Yaros, our physics programmer, had an idea.
Maybe we could try both controllers simultaneously.
We had no idea if that's going to work or not, but we gave it a try.
It was a delicate balancing act between the two controllers, but it worked.
We used motors with enough power to apply the animation pose, but lowered their tau stiffness to minimum to make them very soft and let the limbs flop around.
And we used keyframe controller.
It functions as some kind of stabilizer, preventing vibrations and forcing the rigid bodies to keep the animation pose when the character is not moving too much.
But Ellie still kept breaking during quick directional changes.
and we wouldn't be able to ship without Revelation 2.
And we knew that Ellie is parented to Joel's spine, so Yaros tried to decompose the animation pose to two components.
Local acceleration, which is acceleration of Ellie's pose, and parent acceleration, which is acceleration of Joel's spine.
And now, the key thing, we can limit how much player's motion we apply to Havok rigid bodies.
We are finally able to cap the crazy accelerations we were getting when player was changing directions rapidly.
And this is from the ship game.
I think it is pretty decent for just one frame pose.
Anyway, so what are the key features of our regular driving method?
We are motors and keyframe controllers simultaneously.
By changing weight between motors and keyframe controller, we can achieve different results.
And by the way, we can change those weights per rigid body.
And we can also cap acceleration spikes by limiting parent acceleration.
And how the keyframe controller works.
For you with coding experience, it might be easier to just read this.
It's a bit simplified because I'm not a programmer, but the key principles are there.
We take local acceleration, sprinkle it with parent acceleration, then we add a little bit of velocity gain and try to match the velocities and rigid bodies.
And if the final pose is still not matching up, we can finish it up with position gain.
And we take the resulting linear velocity and set it back to our rigid body.
And we do the same for angular velocities.
All gains and limits are exposed to our script.
And this is what animator sees.
By the way, this script is based on Lisp or Scheme.
And our programmer, Dan Liebkoll, gave a talk about it here at GDC back in 2008.
And it was called Adventure in Data Compilation.
So all is good, I call it a success, but we found out that we need one more ragdoll for Ellie.
This scene happens before the hospital one, but Joel is saving Ellie again.
This time it's underwater.
And we needed slightly different parameters for our ragdoll.
Much higher damping on Ellie's arms and legs to simulate water drag.
And also we needed to keyframe or animate different set of rigid bodies.
It was the right time to move the ragdoll definitions to DC script.
So I wrote a Python script for Maya, which exports the main parameters of ragdoll rigid bodies and their constraints.
Later on, we decided more parameters, we added more parameters for Uncharted 4 so we could change, for example, constraint limits on the fly.
And what are the advantages of having ragdoll in script?
We didn't have to touch the asset manager.
The default ragdoll is still part of the skeleton, though.
And I don't have to build it again should I need to add more ragdolls.
I can just duplicate a few script lines, change a few numbers, and compile it.
It's a matter of a few seconds instead of minutes, although I ended up saving a few extra Maya scenes as references for more sophisticated setups and exported regular settings from there.
which means that further tweaking of numbers in script rendered my Maya scenes obsolete, and we had no tools to sync them.
But honestly, this tool would be pretty easy to write.
We just never really needed it.
Bigger problem is that most artists are scared to touch the scripts.
We have eventually decided to move everything ragdoll-related to DCScript and started calling it ragdoll profiles.
So these are the building blocks of our regular profiles.
And this is the real script.
This is the regular definition I exported from Maya.
There is like hundreds of lines, so I collapsed the block of text down.
The regular definition is hooked up in the profile here.
Here, I specify joins that are going to be keyframed.
You know, you remember those blue rigid bodies I showed you before.
And this one is interesting.
Here I specify collision layers for my rigid bodies.
The script says that they don't have any collision by default, but I added a set of rigid bodies that can collide with other ragdolls and with the environment.
I can add as many sets as I want.
And this is our baby.
I defined three different keyframe controllers and assigned them to three different sets of rigid bodies.
It means each set can be animated differently in-game.
You will see later why.
And now I'd like to show you the real beauty of our setup.
I can just duplicate a handful of lines in script, change a few parameters, and I have another possibly totally different ragdoll behavior.
But watch, I can duplicate this one again, hook up regular definition with different motor settings, and I have another profile.
So what are the advantages of regular profiles?
I can go nuts and create many profiles very quick.
I'm not limited to one character.
All of them work as long as the characters are using the same skeletal hierarchy.
And here's the big thing.
I no longer need a programmer to be able to test regulars in game.
I have all profiles in debug menu, so I can test the ragdolls anywhere I want, and possibly even where I shouldn't.
Underneath all the bravado, you're just a sad little boy with delusions of grandeur.
Oh, by the way, I can't pass.
Shit.
So long, Nathan.
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Nathan!
Now that you have a pretty clear idea how we animate ragdolls and how we set them up, I can finally show you the best stuff we did for Uncharted 4.
And we started with ragdoll vehicles.
I mean, ragdolls in vehicles.
So we started prototyping vehicles when The Last of Us was still in full production.
It was a great proving ground for our animation controllers and mainly for testing of the parent acceleration limit.
There's no better test than hitting a wall at 40 miles per hour.
Of course, designers chose a car with no roof, so we can see every little detail.
Well, no detail at all, actually.
Let's see.
Yeah, it looks terrible.
We could probably add some lean additives to simulate reactions to vehicles, angular changes, but most likely it just wouldn't cut it.
Because we were planning on having some wild off-road sections on Madagascar.
So let's see how Regdalt handles it.
Yeah, it's way better.
Jake's chest moves independently on the car seat.
Nothing is breaking, even when the car is swinging wildly.
Let's see how we pull it off.
Setup is actually pretty simple.
Lower body is fully keyframed, and we simulate it on the spine, head, and arms, up to hands.
Keyframing hands ensures that they won't leave the steering wheel.
Collisions are interesting.
We don't have collisions on anything but spine and head.
We let it collide only with the seat and the steering wheel.
We were initially scared of letting the character collide with anything in the vehicle, and we were ready to solve it with different limits.
But to our surprise, spine's interaction with the seat's collision looked very natural.
You will see it later.
And to make your life easier, I crunched some numbers from all Uncharted 4 ragdoll profiles and tried to translate them to clear visual form.
I call it heat maps.
The color legend is simple two-dimensional diagram.
Vertical axis is strength and horizontal axis is stiffness.
I colored the rigid bodies so you can see how the keyframe controller influences the simulation.
Remember that keyframe controller works in world space.
Joints have their own colors and they are displayed as those little dots connecting rigid bodies.
I remind you that motors work in a local space.
And finally, the greyed out stuff means that the connected rigid bodies are keyframed.
So how do you read the picture?
For vehicles, we used strong but soft keyframe controller for all simulated rigid bodies.
It means that the ragdoll can follow the simulation really well, but rigid bodies can be moved away from the pose, even with subtle impacts and changes of momentum.
Animation feels pretty soft overall.
Next, we can see that Spine has super weak motors, but on the stiffer side.
They can barely support it.
Having soft spine allows for nice compression in the spine.
Although, it needs to be held by strong and stiff arms.
Otherwise, it would compress too easily.
It's actually interesting how much the strong arms influence the final result.
They make Drake look like he's fighting the steering wheel.
The side to side swings are wilder and have more natural angular motion in it.
On the other side, the weak arms make the side-to-side motion feel too linear thanks to the majority of influence coming from the keyframe controller, and the right side feels too mushy and lifeless to my taste.
Driving 4x4 should feel wild and exciting.
And let me demonstrate the effect of parent acceleration limit one more time.
The red volumes you see in the video demonstrate an animation pose before simulation.
This is how our characters would be moving without physics.
And so what the parent acceleration limit can do for us?
It prevents transferring too much acceleration to our ragdoll and therefore breaking it.
A real person would be thrown against the dashboard with these impacts.
Also notice how Elena's spine bounces off the seat when they collide.
Thanks to this feature, our ragdoll can handle anything.
But it doesn't mean it's always the best tool.
Ragdoll is good for small bumps and realistic weight shifting.
But we use full body animations with no ragdoll for the hard hits.
So while I'm watching it, I'm going to put, yeah, so start the hard hits.
And by the way, our programmer, Edward Pereira, is going to talk about off-roading in HRF4 in this same room today at 2pm, so you can learn how he pulled off the physics of a car and stuff.
Oh yeah, I was driving recklessly a little bit.
Let's talk about something entirely different, and that is player climbing.
One of the main goals for the climbing mechanic was to give players a very analog and organic feel.
The same feeling the real rock climbers have when they search for the next handhold on the sheer rock face while balancing on their feet.
It looks like a ballet.
Our characters were always climbing these perfectly flat vertical walls, but we wanted to move away from that.
We wanted to climb slabs and overhangs, and when the overhang becomes a roof, Jake swings his legs and powers through that section thanks to his enormous upper body strength.
And when he's not climbing these impossible rocks, you can find him hanging out.
on a big-ass truck speeding through the countryside of Madagascar.
And to do all that, you need a crazy amount of animation.
Just to make the player reach for the next handhold requires dozens of reach poses.
Basically, every cross-section on the spiderweb is a pose that has to blend well with all of its neighbors.
In the game, they constantly blend based on player's input.
And once the player reaches the next handhold, we played a short transition animation.
It's really hard to keep all animations consistent, and we kept seeing a little hitches in player's motion.
We thought it's a great opportunity to physics simulation, to smooth everything out.
And this was our early prototype.
Notice how the left side is quite a bit noisier than the right side where the ragdoll is running.
And this was recorded from the latest build.
As you can see, our animators did an excellent job and animations blend much better.
But can you tell which side has the ragdoll running?
Okay, hands up who thinks it's the right side.
Wow, 15 people, 20?
Yeah, you are correct.
It's the right side.
I'll show you why.
Yeah, there is this very, very subtle difference.
The ragdoll has this nice, subtle overlap to Drake's butt.
And the character on the left side just kinda eases into a pose after each move.
You would totally feel the difference on the stick though.
It feels very different.
Here, I slowed it down for you so you can see better the difference between animation drawn in red and final result.
Everything is happening so fast that you can barely see a difference, but you can totally feel it while playing.
and setting up the climbing radar was a real challenge.
I wanted to crank the softness in Drake's body up for added momentum and nice overlap, but I had to be careful not to introduce hyper extensions in his arms.
Basically, everything was tailored to the worst case scenario, and there was climbing on dynamic objects.
Here we have the heat map again.
Hands and feet are keyframed to ensure proper contact with the environment, and also notice that I keyframed the forearms as well.
We needed arms and upper body to be super strong because they carried most of the body weight.
Spine was pretty weak to allow the overlap, and legs were almost unaffected by the keyframe controller, but were powered using motors and joints.
You can clearly see that the upper body is firmly controlled in world space thanks to keyframe controller.
And its effect tapers down towards the legs and the legs are animated by motors almost exclusively in local space.
And here's our test for the climbing ragdoll.
Drake's body reacts naturally to impacts coming from the truck, moving the lower body in a nice springy fashion.
I'm going to let it run one more time.
Basically, every time the truck does this big bump, it shakes the body nicely.
It does this.
Think.
Okay.
But we had some really sharp corners in our game, and the ragdoll got sometimes stuck on invisible collisions.
So we tried to disable the ragdoll collision, and we saw no side effects.
Occasional clipping is way better than this.
And this is my favorite part, it's the hang climbing.
Player can climb or jump to a hang position under totally arbitrary angle.
This is how our early prototype looked like.
Yeah, it's pretty terrible.
It's basically just a blend into a hang pose.
But before we committed to creating millions of different landing animations, I gave the ragdoll a try.
I created a new profile with super loose lower body and Drake swings around properly when he lands in hang position.
But I quickly realized that this profile looks great when Drake is just hanging, but it felt too loose when Drake tried to actively do something.
So I created a new stiffer profile for hang reaches.
The thing is, we switch ragdolls in code based on player state.
So no ragdolls most of the time, driving ragdolls in vehicles, climbing, and now hang climbing.
But we had two profiles for one hang state.
And I got an idea to use our animation event system, which we simply call EFFs for enabling and disabling ragdoll profiles.
We like scripts, so it's just a text file with similar syntax to XML.
But it's really simple, and most of our animators have been using it already for triggering events like weapon reloads, particle effects, and sounds.
And I was excited. I couldn't wait to test it out.
I recorded a slow-motion video of Drake jumping down to a hang and moving side to side.
Next to his feet is a debug drawer with the name of currently active Rango profile with its blend value.
Stiffer ragdoll fades in every time I press the left analog stick, and when I release it, the looser version takes over again.
If I go side to side, these two profiles keep blending in and out constantly.
And Drake's momentum carries over each move, so I can make him swing more and more every time I change direction.
It feels very organic.
And if I was doing left and right, left and right, basically those two profiles would be constantly blending in and out.
So.
Sequencing of ragdoll profiles gave us full control over when and which ragdoll profile to use with frame precision.
We can also control how quickly ragdolls fade in and out.
And yes, we can blend between ragdoll profiles seamlessly.
This started the ragdoll revolution.
Ragdolls started appearing everywhere in the game.
But it also gave animators more responsibilities because once the ragdoll profile is enabled, it's going to keep running until you turn it off again.
It was extremely difficult to safeguard all possible transitions.
And we kept seeing players running around with the ragdoll enabled all the time.
No, no, don't worry, it's fine.
Yes, so to fix this, we introduced a simple rule.
Game keeps the ragdoll profile running only if the currently playing animation contains a ragdoll event.
This feature still allowed a seamlessly sequencing of different ragdoll profiles, but it also made sure that we don't run ragdoll where we don't want to.
You know, no ragdoll is better than broken ragdoll.
and correct weighting between keyframe controllers and motors was crucial for hang climbing.
Arms were holding almost the entire body weight.
It quickly tapers down towards the spine and it has almost no effect in the legs.
It's used only to stabilize vibrations.
Motor forces and stiffness were cranked up in the spine to hold the pose of the lower body.
The stiffer ragdoll is just a slightly modified version of the looser version.
More of the body is held in place by the keyframe controller and also the legs go to similar treatment to lift them up more.
By switching to a stiffer profile, we are basically simulating muscles putting more work towards reaching the next handhold.
Unlike the regular climbing ragdoll, this one had collisions enabled and I'd like to show you why.
It's because the hang climbing doesn't mean the player is just hanging down free of any obstacles.
In this case, Drake's whole upper body would sink into geometry should he have no collision.
The side effect is that his chest can push the dynamics objects around.
And I'd like to show you one more video demonstrating how seamless the transitions between hang climbing and a regular climbing are.
I also poked the cage with the mouse in this video so you can see how everything's reacting naturally.
Somebody should make a game where players are finally allowed to do this type of stuff.
Okay, now onto a more explosive stuff.
Every Uncharted had a chase sequence.
And of course, Uncharted 4 is no different.
Mad Max came out no long before we started working on our chase sequence.
We loved how the crashes were staged so well.
Perfect angles, perfect motion and timing was really amazing.
But how could we achieve similar thing in a video game?
And we started with animation.
We decided to have a maximum of two people per vehicle.
We had to account for each character being killed individually or together.
And no, they don't just freeze at the end of animation.
We physicalized them so they keep moving without being animated, which is actually not entirely true.
I did this test to see how we could animate characters without actually animating them.
When I kill the guy, he plays a very short death animation and then blends into one single pose which he holds using regular motors until he stops under the stairs.
I learned how critical the pose is for smooth rolling motion.
Arms need to be close to the body, legs pretty straight.
The more the shape resembles a cylinder, the better.
Also, proper friction on the regular played a big part.
I used all this knowledge many months later when I was begging a programmer to implement this.
You know, you need a lot of arguments to sell the idea to a programmer.
So let me show you my death animation again.
Notice the cylindrical rolling pose.
And this is how it's in the game.
It worked pretty well, although Ragdolls have a really hard time to keep the post intact when they hit the ground at 50 mph.
One little bump on the ground and the post turns into a mess.
We used a similar system for off-road vehicles.
So, how do we animate the vehicles?
The convoy vehicles are following a set of splines based on what the player is doing.
It's all scripted by our awesome designers.
And once the driver dies, or the vehicle is damaged enough, we trigger a death.
We disconnect the vehicle from its spline.
We store its last moving vector.
And we play the animation along the stored vector using the keyframe controller.
Yes, even vehicles are running physics animation.
We use pretty stiff keyframe controller, so the simulation matches the animation the best it can.
And why are we running a physics animation?
So we can animate our vehicles until something really bad happens.
And it happens sometimes that our object hits a small bump and moves away from the pose.
We measure the distance between rigid bodies and the animation pose every frame.
And when the error distance becomes too large, we fade out the keyframe controller.
It normally doesn't happen because after a small bump, the keyframe controller cannot recover the animation pose easily.
and only a major collision could stop animation from playing.
And the major collision is usually a player smashing everything with his car, which is the biggest advantage of this system.
We always get a better performance than just letting the vehicles explode randomly, and it's pretty safe to use.
As a bonus, the keyframe controller snaps the animation to the ground for us.
The only thing that I don't like about the system is that the objects might jitter a little bit when they are being pushed too far away from the animation pose.
But the keyframe controller haven't turned itself off yet.
But I think we could fix it if we were given more time.
Ok.
And we have this epic cinematic moment when you take over the jeep.
Yeah, even the truck was animated with physics animation.
Okay, now onto the boat chase.
It's an opening sequence of our game.
Drake and his brother Sam are being chased in their little boat on a stormy sea by guys on speedboats and other guys on big boats, and they throw mines at our poor little boat.
You should play it, it's really fun.
So, the sea is really bumpy and our little boat is widely moving up and down and side to side while Sam is in the back of the boat trying to shoot the guys.
I tried to simulate the bumps by baking into animation, but you could tell that Sam's body is not moving in sync with the sea.
This video is from Final Game when we ran physics on Sam.
We keyframed Sam's hand and feet to pin them down to the boat.
And we let only the right arm collide with the boat to prevent clipping when he's aiming.
Sam's aim poses didn't have any instability baked in.
So I let our animation controllers work really hard and simulate it for us.
Sam's whole body has pretty soft keyframe controller, while motors were basically holding the animation pose for us.
I stiffened his right arm a little bit more in world space using keyframe controller so he could aim better.
And did the same for the head so it's not bobbing around.
We wanted Sam to feel sharp and aggressive and not sleepy.
Similar to the Jeep, we disabled ragdoll for the big bumps, where the sand falls down to the ground and used it only for small bumps and weight shifts.
It was super easy to implement with our animation event system.
And this sequence is a prime example of how we used ragdoll as a really simple post-processing tool.
Drake is being dragged behind the truck on a rope and going really fast, and he's desperately trying to reach it.
You can steer Drake side to side.
You can make him climb the rope up and down.
All this is happening on a pretty bumpy road.
So his legs kept clipping the ground quite a bit.
We tried to use a rag doll to fix it.
The profile is super simple.
Everything except his legs is key framed and the legs are trying to match the animation 100%.
By the way, I zeroed friction on them for better stability.
Let me step through a few frames to give you a better idea of what was happening.
By the way, the big blue ball in front of Drake is a special collision for simulating him breaking boxes and fences and other stuff with his head.
So as you can see, not much is really happening.
It's just a subtle adjustment, nothing big.
Until now.
Look how deep under the ground this lake is.
But you won't even notice until you see the debug draw.
This is my last example.
First, let me explain what in-game cinematic is.
It's a sequence in a game that looks like a cinematic, but it's in some way interactive.
In this case, the jeep is dragged by a wild river while spinning around and bouncing off the rocks, but player can still steer it a little bit.
Again, something out of animators control is moving our characters, and we'd like our characters to be reacting to what's happening to them.
So we naturally reached to physics.
It was towards the end of production, and we already had nearly 40 different ragdoll profiles in the library.
Thanks to our EFF system, it was super easy to pull off.
So we run the classic vehicle ragdoll on both characters at the beginning of this scene.
But once the vehicle lands in the water, we switch to a custom ragdoll.
It's a slightly modified version of Sam's ragdoll from the Bullchase.
And this is where it transitions to other gameplay.
Look how far Elena's body is from the animation pose.
I drawn a yellow outline around her body so you can see it better.
It took me less than 30 minutes to create a ragdoll profile and hook it up in the animations.
We also used ragdoll in the following epic cinematic moment.
See that Sam is running ragdoll?
Well, all characters are running ragdoll.
It's because the jeep is still kind of steerable on the rocky face.
So we don't know, we cannot just bake the reactions into the animation.
Now it was the hang climb and...
Now you can see that Sam is praying for more ragdoll.
It's like very, very subtle details, but it makes a big difference when you see such a detail seen visually and something is a little bit off.
So none of the stuff I show you today would be possible without stable frame rate.
Luckily, our team has some of the best programmers and artists in the industry, and they were able to optimize the game 100%.
But nothing was perfect.
It was really difficult to synchronize all procedural animation systems in the game.
Animation blending, IK step, physics step, we were quite often working with obsolete data from previous frames, and Jaros, our physics programmer, had to write some complicated predictive algorithms to fix that.
Unfortunately, this is way beyond my expertise, and you have to ask him should you have any questions.
I also found out while I was preparing this GDC talk that I knew quite a lot, but still very little about our system.
I've learned so many important details, which I had no time to learn during production, but now I'm ready to make everything in our next game better.
And that's it.
Thank you.
Thank you very much.
Okay. Any questions? Yeah. Hey, how's it going? Great talk, thank you. I'm curious if you've used this system in a purely combat context because it sounds like a great way to get better performances in like a fist fight. But physics in combat as a designer really scares me so I'm wondering if you guys have tackled that. Physics in combat? What do you mean by physics in combat? So if I get like hit in the sternum versus the left shoulder. Oh, I see. So like hit reactions. Exactly.
uh, we used a ragdoll only for death reactions and we used additive animation for, for, for the, for the, like, those little hate reactions. But we, yeah. We are experimenting with it. It works. It works. But not yet. Not, not in, in iCharlie4. Okay. Uh, so, uh, so, uh, so, uh, So Havoc provides you the preview for ragdoll setups and other physics object designs in Maya, but assuming since you have all the DC script and EFFs, did you end up using those previews?
I assume the in-game previews were more convenient and actually reflecting the final implementation, but...
Yeah, I basically used the debug tools in Maya only for previewing limits and frictions in the joints.
And then I went to our game and we have all the tools to test Regal there.
So, yeah, as I expect, only limited use then.
Yeah, yeah.
But those Havoc tools made my life easier when I started setting up the Regal.
They are really, really nice.
Okay.
Had the same experience, so thank you.
Yeah.
Sure.
Okay, anybody else? Uh, I put some business cards on each side of the table so feel free to take them and you can just email me when you are fresh and not overwhelmed by the amount of information. And if you want, come close and we can talk about stuff.
