My name is David Santiago.
I'm a principal technical artist at Insomniac Games, working with procedural systems and pipeline.
And there have been many talks by Insomniacs at GDC this year.
And if you missed some of the ones earlier in the week, I'm sure they're recorded.
And I will be mentioning some of the upcoming talks during my presentation.
Before I get started and run out of time, I want to make sure to thank everyone in Insomniac Games for their support in preparing this talk.
And I want to thank Insomniac for being such a great place to work.
And Insomniac is hiring.
So visit our booth on the show floor to talk to people about openings.
Here are some of the current openings.
I can show this slide later.
And we do, I believe, still have openings for a rigging intern in both studios this summer.
And I'll be at the booth on and off the next couple days.
So I'm going to talk about a game that some of you might not have platinumed yet.
And I might reveal some secrets of the game that have already been published in every language online.
So a show of hands.
So I do really want this information.
Who hasn't seen any Spider-Man open world content at all?
OK.
So I will be sure to play the video, even though it stopped working.
I will just get out and play it.
How many people have not played the game?
All right.
Well, that's pretty much all the information I need.
So if everybody else plays the game.
So how did it start?
And how do we plan on making this game?
Let's jump back a few years.
There was a meeting where Brian Inahar, a creative director, revealed the next game that Insomniac would be making for the PlayStation 4.
And I actually wasn't at that meeting, but I heard that people freaked out.
I remember the moment I was told, you're gonna be working on Spider-Man.
And I was like, what?
We're doing Spider-Man?
You're kidding.
And it was hard to believe, but I was very quickly convinced that's what we were gonna do.
So I was being tasked to help build the city using the technology I first developed on Sunset Overdrive, creating ground buildings and markup, but for Manhattan.
And now that's a little more real estate to cover, but I had a plan.
I reviewed Brian's announcement presentation, which set the game's pillars and goals for every department.
And it was a mind-blowing amount of content to create in a relatively short amount of time.
And then in 2016, the public rumors started that, oh, there's a Spider-Man game coming.
And fans started sharing their expectations online.
So E3 2016, we opened on a shot of the city.
transitioned to this street with traffic and pedestrians and hot dog carts.
And we cut to this card and people got excited.
And while I'm on this card, I'm reminded to thank Marvel Games and Sony Interactive Entertainment for their support.
And most importantly, I want to thank my family and the families of my co-workers for all their support and enthusiasm as we threw ourselves into making this game.
So the 2016 E3 crowd, they really erupted when we cut to the shot of Spider-Man there, and then he starts swinging down the city.
But now for all of us at Insomniac, this was real.
And the quality bar, the minimum quality bar, was set.
So from the start, we worked to make sure that all of our demos ran real-time on PS4 hardware.
And from the beginning, we had a strong plan which actually got us to this 2016 E3 reveal.
But that plan wasn't yet strong enough for the challenges of the next two years.
And speaking of that, Brian Inahar, the creative director, has a talk pretty much right after this, 11.30, in the South Hall, so you might want to catch that.
But my talk today is about the procedural systems and how we integrated them into the pipeline as part of that plan to meet the challenges.
So this is that video that last week didn't play, and then it...
stopped, started playing, and now it's not playing again.
So let me play this real quick.
If you are able to see it.
Do I have to put it over somewhere else?
Do I need to quit the other presentation maybe?
Let's close that.
All right.
So since it's not.
So for those of you who hadn't.
seen anything. So here is Spider-Man swinging through the open world.
Don't need to play too much of this. I think you'll get it.
All right. Let's move back to the presentation. It's great when, with PowerPoint.
Shift F5.
All right, so let me give you an overview of my talk today.
So we're going to talk about what the open world planned content was for procedural content, what the challenges would be.
I'll give an overview of the procedural systems that we, well, most of the ones, some of the ones we used on Spider-Man.
I'll describe our original pipeline plan and how the project evolved as production happens and how we updated the pipeline to handle it.
I'll mention some late additional challenges we met to finish the game, and then most importantly, what we learned.
So, here is our Marvel Island of Manhattan.
But what is Spider-Man?
What is in this game?
So it's an open world game of approximately six kilometers by three kilometers of designed playable space.
And we have the nine districts of Harlem, Upper East Side, Upper West Side, Hell's Kitchen, Midtown, Chinatown, Greenwich, Financial District, and The Raft, and Rikers Island Prisons, and Central Park.
There are 544 roads and 1,202 alleys.
Those are mostly fictitious alleys.
There are actually very few of them in Manhattan.
Over 8,300 distinct buildings in 3,250 edifice prefabs.
And an edifice, it contains the contiguous buildings or structures within a block.
More than 350 different types of storefronts which are uniquely customizable.
More than 3,000 crimes, more than 3,000 vignettes.
And I think there's a story, missions, and a hero.
So how will we do it?
Well, to make such a large game, we knew automation and procedural systems would be used on a really large scale.
And Insomniac Games is not a big company.
I mean, I think during Spider-Man, we're about 250 in the entire company, and we're always working on multiple titles.
So we knew that automation would be key, using macros, scripts, et cetera.
And then procedural systems.
So what are procedural systems?
They are methods for creating content algorithmically rather than manually.
And so data flows through a set of operations that manipulate the data based on parameters, attributes, and other input.
Now, this is not real-time procedural.
I mean, there's always some small real-time procedural systems.
But these are procedural tools to author content.
And our goal is, as much as possible, to create a procedurally authored open world.
Pow!
It's a Marvel talk.
You kind of have to do something like that.
And I just thought of that like two weeks ago.
So hand crafting is very important at Insomniac Games.
Designers and artists hand craft the game experience as much as possible throughout the entire game.
And procedural systems are a tool to help author a lot of content quickly and give the artists and designers a big head start.
So the goal for Spider-Man was to procedurally generate an open world early in production to give the designers and artists the rest of the remaining of our production time to polish the game.
And our target was 80% usable procedural content.
And I'll have more on that later.
So we started with a foundation of systems and tools from Sunset Overdrive, and we had to augment that foundation to create the basic tools and systems for Spider-Man.
Sunset Overdrive, we built roads on terrain and placed a relatively small set of props and traversal markup.
And there was a building system to help block out areas of the game, but the buildings on Sunset were so unique that it was just more efficient to construct it by hand at that time.
So we had a plan for what main procedural systems we needed.
So I'm going to be using this east up orientation for the island throughout the presentation.
So it fits our aspect ratio better.
And so hopefully you get used to it.
It took me a while to get used to it, because we weren't working this way either.
So at the time in pre-production, the planned procedural systems included ground system for terrain, streets, sidewalks, some decor and integrated markup, buildings with markup.
a traffic system for pedestrians and vehicles, and a first pass of propping the open world, really spamming the props out there.
So step one for the ground system are roads and alleys.
Roads and alleys define the city.
Everything is dependent on their placement, size, and lane configuration.
Now a big hint for this talk, dependency is very important.
So from these lines and curves in Editor, we will generate the streets, sidewalks, gray spaces, and the seawall around the island.
Ground modifiers affect how the environment is constructed.
So this yellow overlay is the contents of our ground modifier zone.
Now, these are additional curves, polygons, or volumes that cut, deform, modify, add materials, et cetera, to particular areas of the game.
There was also an analogous design modifier zone.
This is the ground modifier zone, a design modifier zone to affect design content, such as crimes, traffic, bot navigation, et cetera.
So we're not going to generate a giant model for the ground.
We're going to make models for each streaming region.
So our open world is cut into square tile streaming regions, 128 meters on a side.
I must say it about 128 meters on a side.
No, it's 128 meters on a side.
So if you see here, there's some double lines.
I mean, they're not important, but it's an interesting detail in our system.
They indicate a history of scaling and offset of streaming regions for various reasons.
And we actually preserved that history so we could validate content to make sure that it was fitting into its appropriate streaming region.
Now, there are very few actually scaled regions in the final game.
And mostly, they're on the coastline just to reduce the tile count, just make it a little bit bigger.
We can fit the content in there.
And you'll notice that Riker's Island and the Raft Prison do not have streaming regions, but that's as far as procedural systems are concerned, because there is no procedural content in their final version.
Tile ID, so each region has a tile ID, which is a map location from AO1 to X48.
And each tile hierarchically contains all the zones for its open world content for that region.
And you can notice that lonely tile in the top right corner there, that's X48, and it's our test region that was there throughout the entire game.
So here is a procedurally generated ground.
It's typically 16 models per tile, so that each is a manageable size for physics and other systems.
And this is actually a debug version of the ground, which is why it is not complete in some areas.
And you also see remnants of Rikers and raft up on the top there, which was later completely handcrafted.
Also note that Central Park's ground was hand-authored to fit the character of the park in the area allotted.
So eventually all of those manual iterations of Central Park were procedurally processed in order to integrate them into the game.
The last part of the ground system is kind of actually the beginning of the prop system.
It's where we add some ground details, lane lines, crosswalks, per district materials, and such.
And we also do a little first pass of street props, such as manhole covers and sidewalk props, such as traffic and street lights, and a few things like trash cans, trees, just to fill it out for designer testing.
So when they're swinging through the city, oh, don't hit that tree.
on to the building system.
So, buildings were constructed from primitives such as boxes, cylinders, and polygonal volumes to define the outline of the floors of a building.
And then these simple buildings are then processed by the procedural system to instance assets from several building kits onto the faces of the gray block.
And then there were roof models that could be sized and tiled to fit a roof, or a custom roof model would be created automatically if the procedural system couldn't make it out of pieces.
And then some rooftop props were automatically added to these building edifices at this time, so things like the HVACs and those water towers.
The procedure system also added all the markups, swing hint volumes and various types of ledges, ledge paths for traversal.
And then as we were laying out all these buildings, we noticed that any time we changed the streets, we might have to change the buildings.
Some talks related to this.
Doug's talk, Concrete Jungle Gym, the building traversal in Spider-Man.
That is tomorrow morning.
And tomorrow afternoon, a programming talk about our tools, our in-house tools, editing with immutable data by Ron.
So our building tool was originally designed with a recalculate markup only mode.
So if a building was hand modified or if it was completely built from scratch, our system could automatically read that edifice prefab, generate the markup.
And that markup was always optimized by joining all segments to minimize the number of curves, minimize the markup actors.
So that's pretty much the building system.
And onto traffic systems.
So from the road, pedestrian and vehicle traffic were procedurally generated.
So as far as the pedestrian traffic system, the first thing we did is we placed static pedestrian volumes on sidewalks.
And so those volumes just populated the sidewalk with a certain density of pedestrians, and they were.
They would just be standing there to start with, but then they could get promoted to the pedestrian system to actually walk around.
So after we placed those volumes, then we would create a network of paths that would connect from corner to corner.
So corner to corner along the sidewalks, corner to corner across the street.
Then we would integrate any paths from other assets like bus stops and subways, because they had their paths that we have to come up the stairs and around the subway or around the bus stop, around the bus shelter.
So those had some built-in curves.
They would be integrated into the pedestrian system.
And finally, we'd integrate any hand-authored paths.
So there was a lot of hand-authoring of paths, which pretty much just curves through parks and plazas and maybe some other spaces.
So those were all integrated together.
And then they would generate the pedestrian traffic nodes that the actual gameplay system would use.
And that would include the correct traffic phases for each link, so that when the light turned green, they could walk across.
And when it was red, they would hopefully stop.
Actually, it would turn yellow, and they would speed up and run across the intersection.
Except sometimes, they'd just stop.
So we had this debug with the color of the faces to make sure things was all working correctly.
And the pedestrians, as they reached each node, they could decide on whether they wanted to cross the street or just turn around the corner and go down the sidewalk again.
So now on to the vehicles.
It's very similar to the pedestrian traffic system.
But first, the parking and driving lanes had to be chosen from a variety of the lane templates from each street size.
So each street could randomly, if it wasn't assigned a specific template of number of lanes and direction.
And then the crosswalks from the pedestrian system became the stop lines for the traffic at the intersection.
So just like we populated the sidewalks with pedestrians with volume, we used volumes to populate the parked cars in the parking lane.
The only difference is we had to create multiple volumes to avoid bus stops, hydrants, alleys, and other exclusion areas where you shouldn't be parking your car.
We also created a network of the directional paths that would take a vehicle from intersection to intersection, and then at the intersections give them the legal or desirable turns that they could make.
Then we would integrate the alleys as limited paths.
So if it was a drivable alley, so see back in the distance there, those magenta lines, those are alleys.
And they come into and they are integrated.
And I will talk a little more about their limited use later.
And then we would create the traffic nodes with the corresponding phases and links to other nodes.
And the lane markings based on the traffic pattern would then get applied with the prop system.
So here you can see the route choices.
So these are two.
Well, there are two lane one-way streets that are crossing each other.
And that lane on the left, which is actually the right lane going down, I don't know if it's southeast or whichever way it's going, but they have the choice of turning right into either of the lanes or going across the intersection.
And the other lane has no choice.
They're only allowed in this traffic situation to go straight across the intersection.
Now, here's a more complex area with pedestrian vehicle paths.
And so it's multi-lane streets.
So these are avenues.
And so it gets a little more complicated as to what people can do.
If you look at that lower intersection in the middle there, you can see that all the lanes that have the green light, so they can turn two lanes right into that one-way street.
And the other ones can go straight across.
And then when the traffic phase changes, that left-turn lane going from right to left, they're allowed to turn onto that one-way street.
And then here, the pedestrian traffic for that area, you can see the hand-authored paths through that plaza there.
And yeah, pretty much all they had to do was draw those curves so they intersected a procedural path, and they would automatically be integrated into the system.
So now the decor system, which is pretty much props and decals and then some ped prefabs, which I'll explain in a minute.
So we procedurally optimized placement of the street props, such as manholes, skid marks, tar, asphalt patches, and such, and sidewalk props, which included street lights, traffic lights, mailboxes, hydrants, trees, and on and on and on.
Now also pedestrian prefabs were part of the system.
So pedestrian prefabs were things like bus stops, subway entrances, hot dog carts, sign spinners, cab hailers.
So those were assets with integrated actors that could be promoted to pedestrian behavior.
So say people are waiting at a hot dog cart, they would wait there and then they could be promoted to walk along the path or flee from a crime if necessary.
So whenever there was an encounter, the pedestrians would go into a flee mode.
And then we could also integrate any hand-placed pedestrian prefabs, of which there were also many.
They need to be integrated into the pedestrian prefab system in order to populate the game appropriately at the proper times.
We also did a little bit of procedural lighting.
And I'm not going to talk any more about that, because today at 2 PM, X-Ray is going to be talking about our procedural lighting tools.
So also in our original design, our tools already had the sophistication required for the garbage and debris propping of Act 3.
Maybe I should act.
How many people made it to Act 3 of the game where there's stuff everywhere?
All right.
So the challenge there was to make it look like there was litter and debris everywhere, but not block any path needed by vehicles, pedestrians, crimes, vignettes, missions, et cetera.
So that was a little tricky.
And I know there has been much interest in puddles in the last nine months or so.
Those blue circles, they're procedurally placed puddles.
If wetness reaches a certain threshold in the material, which uses a random seed, a puddle is placed in the world and active during rainy atmospheres.
And then it will splash and ripple and such.
So at this point, we had all the tools to place the props.
Now, imposters.
Fairly early in pre-production, it was decided that imposter generation should be part of the procedural systems since we generated a lot of the content that would turn into an imposter.
So here's an overhead view of the imposter version of the city, and it contains every structure.
Now, impostors are low-res representations of every structure in the city, and we generate a simplified model from the high-res geometry in an entire edifice prefab.
And then we use that simple model for our impostor generation to project textures and make an atlas.
And then we populate the impostor zones with the correct updated impostors so that we can put them in the right kind of containers for optimizing memory and such.
And then we can procedurally regenerate them when ground structures, materials, or lighting changes.
So pretty much we're generating imposters over and over again.
And here again are all the imposters and showing that the entire city is always present.
Whenever you see a shot of the city, it's pretty much all imposters.
So at most, only 12 zones are ever loaded high res.
And even most of those zones are going to be in their lowest LOD, which is very similar to the content of an imposter.
So that's it.
We've designed and implemented all the systems we need to create open world Manhattan in less than a year of pre-production.
And now we can generate all the procedural assets, let the other teams polish it up and generate impostors, and we're done.
So it's party time.
It's party time.
We can just sit back and make the game, but the design team, I don't see the design team at the party at all.
What's going on?
Well, just as we felt like we were going to be able to handle all the challenges for the open world, the designers wanted some procedural system love.
So we had some new challenges.
The first set of challenges were dynamic encounters.
The dynamic encounters are crimes and vignettes.
Now we placed 29 different crimes procedurally throughout the world, and 25 different vignettes were procedurally placed using different rule sets.
Another challenge at that time from designing gameplay was additional desired markup, now that we were getting some new hero moves and bot navigation.
So an example of the rules required to place a crimer vignette, like a jetpack mission or jetpack crime.
So what we do is for a jetpack crime, I have to find a roof in the city with 64 square meters of combat space available that was within 40 meters of two other rooftops with 64 square meters of combat space available, which were within 20 meters up and down from that original rooftop.
And there was a clear path from each roof to each roof so I could put in nav.
and then also so I could put an app from each rooftop down to the sidewalk or down to the alley below.
So the system would run through the world, find all those possible places, based on the buildings that were currently in the game, and then based on the density that was required or desired for each district, it would place all of those crimes, or in this case those jetpack crimes, and create all that markup for the actors and the bots.
So.
If we're going to procedurally author all that content with all those dependencies and have it be handcrafted, we need to figure this out and make a pipeline.
So we have to think about that crime and vignettes are dependent on the environment.
And changing a road or alley will affect contiguous blocks defined by those roads, and therefore everything in those tiles.
So buildings, crimes, et cetera.
And even changing, moving a crime can affect nine tiles, depending on its complexity, because crimes drive prop placement.
We want to avoid.
props or static props in the world where there's going to be a crime.
And then changing a building will affect traversal, crimes again, lighting, and audio.
Did I mention audio?
Audio wants procedural help.
So just to start with, audio, we generate some procedural systems to generate the reverb volumes for audio and also be able to distribute audio at appropriate locations throughout the city.
And speaking of that, tomorrow, the auto team designing the bustling soundscape.
So Alex and Blake will be presenting on audio for the game.
Now back to our story and all of this stuff.
That's a lot.
A lot of procedural systems, a lot of rules, a lot of dependencies.
So we need a plan.
And that is to create a pipeline that completes procedural content in phases that we can iterate, approve, and lock content for all the hand crafting.
Because we're going to go from this to this, it's just going to be a little more complicated.
So we got Houdini.
So although Houdini from SideFX Software is our main package of choice to develop and manage our procedural systems in production, the algorithms can be implemented in any software package.
And in fact, we have plenty of code for generating procedural content that is independent of Houdini or any other third party DCC software.
Now, here is a circa 2016 implementation of our open world pipeline involving procedural systems.
And it's a very simplified diagram without every possible error or box, because it's just unreadable.
And it's broken into roughly three phases.
So in phase one, it's the main world layout, where predominantly designers place roads, rough out buildings to find park areas and mission spaces, and so forth.
And then we move on to phase two, where the majority of procedural content is authored.
And then finally, phase three, the polished stage where the procedural systems will just help finish the game.
And let me quickly point out that imposters and lighting data are being calculated during every iteration of each phase.
And during phase two and three, audio and UI data are also being procedurally generated as well, so that the game is always playable in its most updated state.
So here's the first phase.
The first step is designers layout curves to define the roads.
Well, actually the very first version of the city was from an illustrator drawing of a map for our Manhattan.
And the procedural system could ingest that image and then create the curves and polygon primitives in our editor.
The procedural system would also randomly place rectangular box buildings in different zones to block out the city, and it would actually read color data that the designers put down in order to vary the range of building sizes for the different areas.
So once they got that to a certain state, we were just gonna work just in the editor.
So the designers would modify curves in the editor to redefine the roads.
And they could specify road directions or dominant direction if it's a multi-lane bidirectional street.
Road width, and the road width was from outside of sidewalk to outside of sidewalk.
Street width is from curb to curb.
They could alter curb height, lane configuration, and so on.
So initially, only the main avenues were specified.
And the procedural system automatically chose street sizes, directions, and lane layouts for all the rest of the streets.
So we just told it something like, we want 70% of the streets to be one-way streets.
And 70% of those should be one traffic lane with one parking lane.
And then the system just went through the city to create workable traffic patterns.
And we got those alternating one-way streets, as you might expect.
But as time went on, the designers would specifically choose sizes and lane configurations for many of the streets to accommodate story and chases and such.
But I would bet that most of the streets' sizes and directions are determined procedurally.
So also to start, we had very few alleys.
There were some blocks that designers knew they wanted to break up.
But until we had buildings in place, it didn't really make sense to try to place alleys.
So then, using those road curves, just like I kind of talked earlier, we procedurally generated the ground.
less, just like that.
So then the designers placed the perimeters to define the buildings in this first phase.
So the rough elevations and profiles are created, and procedural systems can modularize the buildings using those basic architectural sets.
And then it would apply the markup.
So now designers could swing through the city and test out their space.
So is swing traversal possible, is desired.
Silhouettes and changing urban landscape lead you along the desired paths.
Do we have the correct variety of density and shapes for the different districts and neighborhoods?
So there was another talk here at GDC that actually went over all those decisions.
The one thing to keep in mind is that this early in production, Spider-Man did not have his complete move set of web zipping and parkour or point launching.
I mean, it was some pretty basic stuff.
So we were trying to improve this layout with some limitations.
So as we iterated in this first phase, there obviously should be an arrow back to road curves.
And then also, as separate buildings were used to fill a block, the procedural system would automatically create the alley curves in between them.
And you might ask, why do we actually need the alley curves, instead of just saying, well, the space between buildings is an alley.
Well, again, some of them are drivable, used for crimes and chases.
And they can be even used by regular vehicles, as well.
Their street is blocked by a crime or a vignette.
So they could take a detour down an alley.
We would also use those curves to inform the procedural systems for changing the ground surface, props, lighting, audio needs, et cetera.
So after this first phase, we should have the streets pretty much done and the rough buildings can drive our next phase.
Phase two is where the bulk of the work for our procedural systems happen.
And there should be arrows going from each block to any previous block, because any change based on a dependency requires some reauthoring upstream.
Now remember, all of this is iterative, and as possible, if nothing is breaking the pipeline, we will generate everything in this phase based on all the changes to keep the game updated and playable.
That last bullet is very important.
It means that during this phase, artists and designers should not hand author anything that a procedural system generates.
They must use the controllable parameters and inputs to the procedural system to affect change.
If they don't, they're at the risk of losing work.
So here is what we call the art polyline pass, and that's the opportunity for the environment artists to replace the primitives in the designer zones with multiple polygonal volumes to further define the shape of the building.
And the artists could also specify the architectural sets that they wanted to use for the building.
In this phase, the artists could also modify or delete the alley curves in saying that they didn't want a drivable alley there.
And then we could recalculate the ground for them.
And in reality, this diagram, this phase two represents two almost identical phases that we call the two stages of environment modularization passes.
Now, iterations of the environment arts first modularization pass would yield the structures with their final layouts and shapes.
But the architectural styles and propping could change in the next stage, the next round of phase two or phase three.
Now after this phase, that we're, uh...
We should have accurately, at the end of this phase, I guess, after the end of this first stage of phase two, we should have accurately placed and approved the pedestrians, traffic, vignettes, crimes, props.
And accuracy is within the scope of our procedural system design.
So the goal was 80% completion using procedural systems.
So that means that 80% of procedural content would be ready to ship or completed to 80% so that art and design would have at most 20% of the work they would traditionally have.
So that means it's something that used to be a week of artist time, should be a day of artist time, five weeks, one week.
So what we're trying to do is generate content to rules and metrics and cull to ballpark, but not to final spec, because the manual polishing passes would take care of the final adjustments.
So at this point, phase three, design has approved everything, and there's art sign-off after the second round of phase two, and every team is hand crafting their parts of the game.
And the procedural assistants will just update things like markup, imposters, lighting, audio, et cetera.
And there should be plenty of production time to develop procedural assistants to add any new traversal, or markup, or crimes, or vignettes.
And then we can also start working on optimization and validation tools to improve performance and help find bugs.
So this pipeline was created to work within a specific plan.
And that plan is to develop the island uniformly through several stages of completion.
And we need to lock the rough map layout and structures and define the key spaces before we can work through any detail.
And so we've got to start with the island-wide systems.
So again, we're going to finalize these roads in the map layout.
So oh, this was, yeah.
This was like a little clip showing the changes throughout the production, after pre-production.
But it's OK.
It's not that interesting.
So the generated ground, then we'd have the generated grounds, which would find the key spaces and landmarks.
So we're gonna work one district at a time, adding detail and iterating on dependencies within that district to bring it to the next level of completion.
And that was fine in our pipeline design.
So as long as we worked through the island district by district, maintaining uniform levels of polish, we could treat each district kind of as its own island.
And because of the unique attributes and established boundary conditions for each district, we already were handling the shared edge tiles in a special way.
So for example, here is Greenwich District in phase two, stage one.
So at this point, we've gone through phase one, so we finalized the roadmap and the rough buildings to find the silhouettes and traversal spaces, and they've been converted into prefabs of instance architecture for the whole city.
So now phase two, stage one, art does its first modularization pass.
They finalize the shapes of the buildings.
Artists are assigned neighborhoods.
Each artist is assigned a neighborhood.
They do their stuff, they work through the district.
Then a district is a level completion where we can run our procedural systems to place the crimes, vignettes, and props.
And art moves on to the other districts to do their first stage one of phase two.
But we found as artists worked through the neighborhoods and districts, they needed to adjust roads and alleys for the character of the space.
So the placement, direction, or size of a road or alley in one district will affect traffic flows for multiple districts.
So we might have to change even more roads.
So that leads to a domino effect of changes.
And that brings us all the way back to block one of the flow chart.
Also, due to different milestone missions, story development items, not only were different districts at different stages of completion, but one tile next to another tile, one could be in rough and one could be in polish.
But in order to place our majority of our content, a tile has to be completed in environment's arts first modularization pass and gain several approvals, and that wasn't happening.
So there was too much work here and not enough work here, and that smooth progression was upset for our development.
Now it's not that the procedural systems couldn't regenerate the content, but manual work could be lost.
So for example, adjusting an alley, just adjusting the alley width in one region could affect many surrounding tiles, such as the UV continuity around the block, because a block could span many tiles.
Proper prop placement, proper prop placement?
It's a tongue twister.
Proper prop placement and the placement of crimes and vignettes in that alley or vicinity.
I never messed that up when I was rehearsing.
So that created a domino effect beyond what we imagined.
Now, honestly, we or I, I expected it to happen at edge or coastal tiles where there was minimal gameplay content, and I knew those would get neglected and fall behind.
So there were just a crazy amount of dependencies.
Every tile's region's content is dependent on at least its neighbors, and best case, they're in production in parallel.
So not only are districts being developed to the different levels of polish, but the individual tiles as well.
And there was new content for dioramas, missions, demos, and other test areas that were all over the city.
And so things like adding a median, marinas, more rooftop features, they required at least update of additional markup for the hero and bot support.
And we also relocated several story-related locations.
And I was personally a little bit stressed and frustrated that we kind of weren't sticking to the pipeline that we worked on.
So what do we do?
We get the leads together, and we figure it all out.
Now, it didn't happen in a day.
Several meetings on different topics with the right team members over several weeks, at least.
And some growing pains were had by all.
I mean, we needed to know the targets and goals for art, design, and gameplay.
One of the main systems, the ground, buildings, et cetera, are going to be at a level of completion that we can move on to everything that all the other processes depend on them.
And then when is work on a tile, neighborhood, or district going to be at a stage where additional polishing of the art, crimes, missions, et cetera, will not affect any downstream processes?
Because then we can more confidently hand off work to the next procedural system with less fear of having to go back up the flow chart.
And then at some point, we'll get to our final imposter's lighting, audio, and UI, and we'll be done.
Speaking more about how we work as a team, Jason, our environment lead, has a talk tomorrow, Case Study in Empowering Your Artists.
So, knowing what everyone needs to finish their work, we make a new plan for our procedural systems.
And where possible, we branch the dependencies so that each tile region can be independently edited as much as possible.
Then each procedural operation should be modularized based on its dependencies.
So for example, traffic lights.
Traffic lights are really only dependent on the roads and the sidewalk corners.
Once we know a direction of a road and where the corner is, we know exactly where to place a traffic light.
So at that point that we have all of its dependencies set, that's when traffic lights or anything with the same dependencies should be placed in that module.
Mailboxes, for example, they have additional dependencies such as avoiding alleys, bus stops, crosswalks, things like that.
So anything with those dependencies should be in its own placement model.
Better rules.
So we also need some better rules to catch the corner cases, always lots of special corner cases.
We want to get these rules so we can definitely exclude the invalid content.
Now, we don't need to be 100% accurate with our placement of content, since we know there will be hand crafting passes.
But we do want to make sure that at least 100% of the planned procedural content is in the game.
We will place things to metrics, and then we'll indicate assets that are in the ballpark, but with which we are less confident of their proper placement.
Because it's easier to try to place these 160 crimes out there and know that every people have to adjust them and put them in the right spot, other than just saying, oh, I can only place 120 of them, and then relying on the artists and designers to count and remember that they have 40 more crimes they need to place, and placing them in the appropriate areas.
So this system for verifying confidence of placement, it morphed into a validation system that was applied later to a lot more content, whether it was procedurally generated or not.
So bringing order to the city.
Bringing order means getting the teams on the same page.
and as many contiguous tiles to the appropriate level of completion for our new modular process.
So originally, each district was a set of contiguous tiles.
Well, now it's like, I don't care.
Just give me some contiguous tiles so we can work through this game.
And the new procedural processes that preserve additional hand crafting would be interleaved with the artisan designer work.
Now, that's easier said than done, but we got it done.
Then came a few more challenges.
So we had some wall crawl issues on some new assets, especially some of the new storefronts.
So we needed some additional ledge path markup and wall crawl collision added.
And it had to be added by the procedural system because it was particular to which buildings, kits, the storefronts were added to.
Also a little bit late in production, a little bit late in production, we implemented the act system.
So we knew that Spider-Man was gonna have these acts and different situations and times of day.
But what was later in production when we created this system of overlay zones that would control the state of the world at different times of day or weather conditions or different acts.
So that way stores could be open in the day, closed at night, closed during Act Three.
There could be different groups of people out and about depending on these situations.
And we could modify what was in the city in Act Two and Act Three, such as all the garbage and different vignettes.
So that solution was proposed in October 2017.
We designed it in December 2017.
I went on holiday break.
And then our implementation was completed in March of 2018.
And then the content was complete, well, before we shipped later in the year.
So there were also some late mission space updates that required reauthoring of art, traffic, and open world gameplay in several areas.
And I was pretty happy with how the new systems handled it.
And then did I mention we did audio?
So we had to generate a bunch of custom audio collision models to match the visible textures that were being presented by a material.
And that was significant in Central Park.
So lessons learned.
Wow, I've talked really fast.
So we already knew this would be the case.
A strict workflow is best, but we need flexibility for production.
We want to lock procedurally generated elements with their dependencies as soon as possible.
As soon as something's locked, we're done with it, we can move on.
We also want to hierarchically modularize the procedurally generated content to reduce dependencies.
So that's what I was talking about.
the traffic light.
Once we know the dependencies to place that traffic light or any other content that has the same dependencies, we want to do that, then we can use that as that might be a dependency for other props or other content that would come later.
So modularizing it will reduce the number of dependencies.
If you have all the props in one module, then you've got every possible dependency going in there.
You don't want to over-define the goals of our procedural system modules.
Now, you don't need to create the perfect rules to place something.
First, it takes a lot longer to make the perfect system.
I mean, I think it supposedly takes an infinite amount of time to make the perfect system.
And then second, if you only place something with strict criteria, you're not going to find that many locations that meet the criteria.
So again, it's like I was saying before, it won't be out there in the world to be nudged into place.
It'll be something that will have to be hand added later, which takes a lot more work.
So it's easier if something's there to say, oh, I'm going to just nudge this to a good location.
Also, the perfect rules, or a lot of over-defining your goals is increased constraints and constraints for dependencies.
And we're always trying to reduce dependencies for each stage of procedural authoring, because we know things are going to change.
So we want to have a limited number of dependencies, so it's a limited number of changes.
Now we can create procedural systems that preserve manual work.
So once hand-authoring has begun, we want to change to a mode where proceduralism is applied appropriately.
So whether it just maintains the hand-authored work, or it augments it or processes it in another way.
Also, compound dependencies should be split into separate processes.
Now, a compound dependency is when a single asset has distinct sets of rules for placement or has a significant level of branching in its rules.
So for example, say we have a crime that can be placed, it needs to be placed, or can be placed on a road, and we want to place it in the middle of a block or in an intersection, and then we just orient it with traffic, but then also that same crime can be placed on top of a rooftop.
Well, we don't want to have all the rules for placing that.
We don't want all the rules for placing that crime in one module.
We should separate it out.
So OK, once we have the road dependencies, we'll place those crimes with that there.
And then once we get to the point where we have the billing dependencies, we'll place that same crime based on those rules.
So those are the compound dependencies.
And then again, compound dependencies, they limit your options for a single asset and will increase dependencies for all the assets.
If you have compound dependencies in this big network, then it's going to create unneeded dependencies for the neighbors.
We want to tag procedural content.
Well, we want to tag everything.
But knowing if something is procedural means you can confidently regenerate it again and again without destroying any manual work.
Now, this can be a little bit tricky since an incorrect workflow can allow an artist to prop out around a procedurally placed instance without creating any indication of the dependency.
So for example, an artist can augment a procedurally placed vendor cart, and they put additional items that are outside of the proper hierarchy.
So the procedural system has no knowledge of any of those additions, and so if it decides, oh, I'm gonna move this vendor over here, it's a better location, well, you might end up with floating soda cans and pretzels in that spot, because they're not within the correct hierarchy.
So that particular simple case didn't happen, but there were some similar cases.
Also, knowing if something is completely procedurally authored means that it might benefit from some handcrafting.
So it's like, oh, that's just in its procedurally generated state.
Let's see if I can customize it to its specific location.
We want to procedurally validate as much content as possible.
We want to find content that is not placed as metrics would dictate.
So for example, a spawn point is inside of a building that doesn't have an interior.
So we want to delete, nudge, or modify automatically only when we're absolutely certain of the result.
So if that spawner is no longer usable in any way, we know we can delete it.
But if it could be usable outside of the building, we'll try to adjust its position as defined in our system's rule knowledge.
And then if we can't be confident of that procedural adjustment, we need to indicate the possible issue for the artists and designers so that they can make the decision.
Now, what we did for many of those cases for dynamic elements is we put those assets in a state where they would not build or spawn unless someone got around to hand modifying them.
So later in production, the procedural system was a lot smarter about placing all the breakables and throwables for crimes, as we had to do it over and over and over again.
So the procedural systems were actually doing a lot of that work.
And we would put those assets that we couldn't find a proper location for in this state.
So we learned a lot of things that we can do better.
And this afternoon, Elon has a technical post-mortem.
But overall, I think we were satisfied.
So repeating myself, the original goal was 80% of procedural content would be ready to ship or completed to 80% so that art and design would have at most 20% of the work they would traditionally have.
Now we exceeded those 80% goals, but all that additional time went into additional iterations and additional handcrafting of content and polish.
There was no leisure time trying to get this out the door.
So now that you know about the dependencies and what has to happen when we change the ground, I'll tell you that that road curve zone was locked in late January 2018.
And the last procedural change to the ground occurred in late June 2018, a little over two months before you could get the game in stores.
I'd like to thank you all for coming.
I really talk fast, so there'll be lots of times for questions.
Thanks, Sony Interactive, Sony PlayStation, Marvel Games, SideFX Software, Jeff, Hannah, my advisor, and everyone at Insomniac Games for making this such a great experience, a great adventure.
And now I will open it up to questions.
So there's microphones on either side.
All right.
I can throw up those job openings if you like.
Hello.
OK.
I worked on We Happy Few, and we have a procedural system, a much smaller system, but with similar structure.
And one of the problems we met is communicating with the artists the consequences of a change into a handmade tile, because there are clearly, as you said, dependencies between a handmade tile and the procedural generation around it.
It was really hard for them to imagine all the consequences of simple change.
So my question is, how did you explain what could be the possible consequences?
Because Houdini is not that simple, it's a complex pipeline.
Well, so at first, you know, there's always a little hesitancy for the artist to give up this generating of, you know, authoring their buildings, you know, they want to make their buildings.
But as soon as they saw that they could just change the shape and then boom, and it would instance all the stuff for them, they're like, oh, oh, I like this, I like this.
So they, I mean.
Sure, there were some bumps in the road, but they started liking that they would just do their polyline work and get the structure they wanted, and they could instance geometry, they could test it, it could go through the whole pipeline.
And then later on.
I mean, it took a little bit, but they had to, they did have to learn and kind of trial and error as far as what they could change and what they shouldn't change, what could be preserved and what wouldn't be preserved, different things about how to, it just, I mean, it's particular to your pipeline, but how you do overrides, so what things could be override, what things can't be overridden, just all those little details of the dependencies in the hierarchy in your data structure.
just things that have to learn.
And I mean, we had a small team, so a really small team.
So getting everybody up to speed, especially for the open world, it was.
Overall, not that challenging.
I mean, we just had lots and lots and lots of iterations.
And they learned when they should just stay with the procedural systems and when they're gonna cut it off.
So sometimes at some points, right, they would just say, I'm cutting this off from procedural systems at all.
And I'm saying, and our system would say, okay, fine.
And you, that means you have to do everything.
And that would be fine.
Okay, thank you.
Yeah, you're welcome.
There is so much going on in that city and I can see from your talk that you used impostors and you used lot systems, but I've noticed that your buildings are made of different blocks and as you go through the city they change LODs of like small pieces, not the whole building all together sometimes. And I'm just wondering...
How did you manage having so many objects?
And what are the decisions you had to make to make the procedural system handle so many objects in a performant way?
Oh, well, for the procedural system, every building, there were only certain building sets, building kits, that would be used by the procedural system when it was originally authoring the city.
And each of those building kits had required pieces, right?
And all that stuff, the artists, environment artists, designed the building kits.
And then they would export an entire building kit at a time.
And the appropriate pieces would be put into the procedural system's library.
But then they had all these auxiliary pieces they could use later when they wanted to polish it.
So as far as the procedural system, it knew about a certain set of pieces with different architectural styles, but it didn't.
It had no other knowledge other than their dimensions and if there were special offsets or things like that.
And then it would just, based on metrics, you know, place them on.
So the procedural system didn't have that much knowledge.
And then later on.
When they did things by hand, they could actually kind of, they can quickly replace architectural styles on their own or put custom pieces or things in themselves.
Now as far as all the content in the game, how we, it was a lot of content in the game.
I don't know if there's anything else to your question about how we managed all those models.
I mean, everything had LODs, and that was, there was all these requirements to how you would have to author everything.
I guess one thing with the imposter system.
So the imposter system could actually see an invisible LOD in the model if it was available.
So if there was a possible lower resolution state that we didn't want to be in a standard LOD, we created a special one that the imposter system would see so that when we took those prefabs of buildings and simplified them to make a single model, we would use that even more simplified geometry.
Thank you.
Hi, great talk, great game by the way, thank you very much.
I wanted to ask about the iteration time.
Like how long did it take to regenerate all the city?
How long did it take to regenerate like one block or one area?
And were you able to do it runtime?
For example, in the editor, generate and see immediately change, or did you have to reload the editor, reload the game?
The artists had tools in the editor that they could, if they did a new polyline of a building, they could say regenerate this building and regenerate the building or regenerate the imposter.
There were some things that they could do.
It wasn't like real time.
It would have to get processed in the background and then it would pop in for them.
So it took a minute or something.
But most of the stuff, they would get it to a certain completion and then it would run through the whole procedural system at some point just because there's so many dependencies.
And then you don't know who has what checked out.
So there's.
And there's a whole thing with permissions and when you can run changes and when you can check things out.
Yeah, I'm forgetting.
I want to forget about that.
But we could actually regenerate the entire open world overnight.
And in the early in production we were, because there were so many rapid changes.
Let's see.
So the ground system, it would first process to create a sparse set of data that would actually describe what the UV continuity needed to be and where the materials were defined.
I don't know if you noticed, but every single district has different materials for its asphalt and for its sidewalks.
That's fun.
And so all that stuff, there was a pre-processing time of about an hour to create that sparse set of data.
And then each tile itself, about 16 models per ground tile, would take, just for doing the ground and creating the associated data that other steps would need, took about a couple minutes a tile.
But if we ran it all together, so that's about five hours or generation or so.
But overnight, it was not.
But then all the other processes, pretty much to process things around the whole city, like to do a processing pass of saying a crime placement or things like that was 25 minutes.
Not bad.
So every time you would do something worldwide, I mean, I would probably, everything has all of its dependencies.
So processing the whole world for something, probably about 25 minutes as far as a placement pass.
OK, thank you.
One of my questions is the same, so it's good.
Question about your tile states.
So you have probably, I'd say you have different acts and things like that, so tiles could be in different states.
How did you solve this with imposters?
Do you have multiple imposters as well for your?
No, no, it's just one set of imposters.
And we had this thing that we calculated lighting at a distance, so there actually really was some lighting out there that would light those imposters based on.
the captured probes and such.
And memory footprints, was it also taken into account when you placed things?
So that's the thing.
The impostors were put into the zones in order to preserve appropriate memory footprints.
Because we were, it gets technical, we were making sure that we were stacking these things tightly next to each other in one location in memory so we could have them all in.
Then all of a sudden you go to an instance interior and they're gone.
But say you're an instance interior that has a view out the window, then certain of those impostor zones that are visible have to be on, right?
So.
All that stuff was how we packed them.
And when you had a tile for a tile lot, did you, for example, had a fixed budget of memory you could use for a certain tile to place things?
So yeah, every artist knows their tile budget for stuff.
I mean, at the end of the game, they've got it up as they're doing stuff.
And they go like, oh no, what am I going to take out?
So and then the procedural systems, as I would process things, I mean, we optimize lots of things.
optimizing LODs, optimizing collision.
Yeah, there's just a lot of things we tried to do.
So every tile had a fixed budget.
Every tile has a fixed budget until we break the rules for some reason.
Yes, because the nile next to it has a little bit less.
You can take a little bit more.
No, no, we didn't treat it that way.
It's only if this has to be in this tile, because a lot of gameplay actually depends on this, and the open world has to be in this particular state.
OK, thank you.
Yeah.
Hi, my question was related to something that you just brought up in the previous question about the file locking and working between different artists.
You know, kind of run into that as soon as you start to scale, you have these problems between authoring assets.
And then as soon as you introduce a process of procedural generation there, my head's kind of spinning.
So.
Just my question around that, what was your process for coordinating all that together?
And are you also on top of that, do you have kind of like a meta tool that is over the top of all these processes and tools that you use to coordinate between people? Or was it just knowledge of the process?
I message them and say, let go of that tile.
No.
Yeah, that's what I was wondering.
No, no.
Well, there was some of that.
But no, we generated all sorts of data caches based on the state of the world at different.
pretty much every day.
So people are supposed to check in their stuff when they go home.
And whether they did or not, because we actually grabbed that data per tile, we would just, this is the latest state of the tile as it's checked in, and then we would create that cache data.
I mean, so x-rays here.
But we would create that, you know, we could do it every day, but as often as we needed to have an updated state to run the processes we needed.
But as far as perforce and checking dependencies or having a watch daemon that's checking to see, is this ready for me to go?
It's just people were supposed to be done at certain amounts of time, and then the processing would happen.
And if they weren't, well, because at the end of the pipeline, we were.
able to sort of run everything in parallel, tiles in parallel, then that's how we would treat it.
So then that updated tile, I would process that tile and its neighboring tiles.
Or I have that tile inherit its neighboring tiles properties.
So the procedural systems would use its neighbors instead of what was originally authored in that tile, just so it would all blend in.
Yes?
Does it work?
Yeah.
I have a two-part question.
First part, how did you deal, if you had to, with complex intersections, like five-way intersections or very close together intersections?
And how did you deal with, if you had to, overpasses and underpasses?
The bridges and stuff.
So, the system would, if it knew about the street itself, it would try to figure out a solution.
So you'd have cars going right through each other.
And then we would...
dedicated, well, it was just one of our production support guys who did a bunch of technical tasks. He would go through and clean up those intersections. So I would, I mean, so it's another part of this process that you could just go through and kind of hand author in a different way in our editor and then it would get processed by the system and then added to this system and then preserved. So anything that was, like, so a crazy intersection where it's like, oh, we can't support those left turns there, because they're going to cut into other traffic.
We don't have enough traffic.
We only have two traffic phases, east, west, north, and south.
So is there a way we can make it work?
So we have to exclude this from being happened.
So we're going to delete that path.
And they would author the ones they needed.
And then we knew it was manually authored, and that would be preserved.
And then that's how that stuff happened.
And the same thing with overpasses.
So.
Grand Central Station, I mean pretty much to author any path, you just draw a line and then you give it the little metadata which was mostly by naming convention of what you want it to be and then my system automatically integrated it in.
Okay but did you have like roads going over each other or was it 100% 2D?
No, the Grand Central Station has that raised deck, and of course we also had the bridges.
So for the bridge, pretty much they authored, they clicked on the ground here, and they drew a line, they went click, growing up the bridge, and then they clicked, and they made it come back.
The cars go up the bridge, and then they turn around in the middle and they come back.
Okay, thank you very much.
The pedestrians actually go down the subway, they go under the street, and then they come out the other side.
Anyone over here, yeah.
Yes, thank you for the talk.
So did you have any art-driven rules, for instance, in terms of color palette, color variation, or illumination of certain parts of the town?
I guess yes, yes, art drives it all.
So we had a lot of, there was a lot of, there's a lot of vertex paint driven stuff and vertex color.
So like something like the puddles, so in the wetness of the streets.
So that was all built with by building the vertex colors into the models themselves.
So that was already static.
But then artists could go through and vertex paint and so create this other cloud of colors that could modify all that.
And if it was on something on the street, the optimum thing to do was actually read their vertex paint, integrate it back into the street.
So they can control it that way.
As far as lighting and lighting direction stuff, I mean, pretty much, I mean, you can.
X-rays talk, but pretty much the only thing was that was any alley lighting.
But pretty much we were just placing this stuff out there.
But yeah, the rules include any artistic choices that we could follow.
All right.
Thank you.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi.
Hi, OK.
In last year's talk of Sunset Overdrive, your colleagues suggested hex grid for organizing and streaming a large procedurally generated city.
But it's very inspiring and very useful to us.
But I noticed that you go back to regular square grids.
Yeah?
Can you tell me the story and the reason behind this?
OK.
So the hex grids were originally designed because our procedural system was going to use a pre-made set of puzzle pieces in order to do all the roads and layout.
But once we started having all the crazy elevations, it was impossible to have a fixed set of pieces to do all the work.
So we used the procedural systems to make all custom streets.
And so a hex grid actually allows you a lot of flexibility when you're using those pre-created pieces.
I mean, New York's sort of built on a grid.
So it, I'm going to close this.
New York's sort of built on a grid.
So using the grid system for streaming regions kind of just made sense.
The hexes did not make sense for doing New York City.
I get that.
Thank you.
So we can move to a wrap-up room.
And if you could tell me where that would be.
Tell everybody where that would be.
