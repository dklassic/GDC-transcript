Alright, good afternoon and welcome. Quick reminder, as usual, please silence your cell phones. If you could please fill out the evaluation emails at the end, I'd very much appreciate that. Thank you all for coming. I realize it's, you know, 4 in the afternoon on Thursday. Hope you've all had your coffee. I'll try to keep things moving along at a brisk pace. So my name is Matthew Gallant and I work on combat design at Naughty Dog. To give you a little background about me, I'm from Montreal. I've worked in the game industry for about 7 years.
and these are some of the games I've helped ship. I've worked on the combat design for the campaign mode in Starhawk. I did the combat design for the infected encounters in The Last of Us. And most recently, I was in charge of core combat design for Uncharted 4, Thief's End. So my talk today is going to go over what we learned during this game's development.
In particular, I'm going to try to give you a sense of ideas roughly in the order that we tried them, with all the intermediate steps, like warts and all, to give you a sense of our own learning curve as we develop combat for the game.
Today, I'm going to be discussing my own work, but also the hard work of everyone on the combat design and AI engineering teams.
So I want to give a quick shout out to my teammates.
I'm really glad to have an opportunity to shine a light on all of their hard work.
Shout out as well to our effects artist, Nikki, who took this cool group photo.
So this talk's going to be in two parts.
In the first part, I'm going to start by talking about combat design in the first three Uncharted games.
Then I'm going to move on to our design goals for Uncharted 4.
What did we want to try that was new and different?
I'm going to talk about our fundamental AI technology.
What did we already have and what we were kind of building off to try to achieve those goals?
And then I'm going to talk about some things we tried early in development that didn't work.
Then in part two, I'm going to talk about the solutions we actually shipped with.
I'm going to talk about some evergreen AI techniques, some things we've done for a few games now that have just always been really useful for us. Some limitations of our current system, things we'd like to improve on in the future. And then I'm going to close with some conclusions and takeaways. So Uncharted 4 is the fourth game in a series, obviously. So that meant we started development with certain assumptions regarding approaches to combat design that had worked well in the past.
we inherited the engine from The Last of Us, which had just been overhauled to take advantage of the power of the PS4.
So in the first three Uncharted games, the macro combat flow was very tightly authored.
Designers relied heavily on zoning NPCs, limiting the area that they're allowed to move and fight from.
So that green cylinder you see on screen, that's the debug display for an NPC's zone, and the NPC will only fight from that area.
It was therefore up to the designer to identify key positions and strong areas in the layout, and to make sure that the NPCs could cover the player's progression through a fight.
Zones also helped NPCs to spread out evenly across the entire combat front.
Some NPCs can be zoned to the left, some to the middle, some to the right.
This helped prevent the NPCs from clumping up, and it gave the appearance that they were using the space intelligently.
So here's an example of a fight from Uncharted 2.
I'm going to have the debug on so you'll see the NPC's zones show up as those giant cylinders in the world.
Make sure that actually plays.
Okay.
So in this fight, there are several NPCs assigned to a zone that is centered on the player.
And the zone actually moves around the player as they move.
This type of zoning forces the enemies to charge the player and keeps the pressure up no matter where the player moves in this big room.
Further back, we have two NPCs that are zoned to a large region around the staircase.
They're guarding the exit.
So this zoning does two things.
Firstly, it helps establish a front for combat, kind of a consistent direction of threat.
And secondly, it aids the player navigation if the last NPC they kill has them facing the exit to the next area.
Finally, we have one sniper NPC assigned to a tiny zone at the top of the staircase.
he's only allowed to fight from that specific position.
The designer knew that this was the best sniping position, you know, it can see most of the map.
So effectively, this zoning is baking the level designer's intention and knowledge into the combat scripting.
Zone assignment doesn't always have to be static.
Designers can also set an NPC zone dynamically in script, allowing them to change the zone based on the player's movement.
So in this fight, the player is pinned down by a turret and can choose to flank it by advancing left or right.
If the player goes left, then the NPC with the purple zone stays on the balcony.
And this sets up the player to shoot him from cover.
However, if the player goes right, then that same purple NPC is assigned to a different zone.
He jumps down and takes cover on that electrical box.
And this sets up the player for a cool propane tank kill.
So this is a really great fight, but it shows that the combat designer had to micromanage exactly where the NPCs would move based on the player's movement.
That's a lot of manual scripting.
So we can also assign new zones to NPCs as a fight progresses.
In this fight, the NPCs in the back are scripted to move up and advance on the player when the armored shotgunner dies.
This improves the pacing of the fight and keeps the pressure on the player.
So these tightly authored approaches to combat design worked really well for those previous Uncharted games.
However, we knew we wanted to try some new things in Uncharted 4, and that might make us want to re-evaluate some of our approaches to combat design.
Whereas the previous games were fairly linear in general, we wanted to explore much larger layouts in Uncharted 4.
This is a screenshot from Madagascar, which had these massive vehicle-scale spaces that you could approach from any angle.
It's not quite an open-world game.
We referred to it as wide linear.
And our scripted approach to combat design would struggle to account for all the ways that the player could approach this fight.
Nathan Drake's climbing ability is one of the things that makes the Uncharted series unique.
We really wanted to push that aspect further in Uncharted 4 and give the player lots of opportunities to climb during combat.
Of course, that meant having these vertical combat spaces requires NPCs that can reason well in three dimensions.
Another new feature was skippable combat, which means that you can leave some combat spaces in stealth without killing any or all of the enemies behind you.
This isn't a new feature in games, but it was kind of new to the Uncharted series.
From a design perspective, this meant that we had to come up with all sorts of interesting mechanics so the player couldn't escape these encounters trivially.
And from the AI perspective, this made it even more important to identify important positions, like the exit.
We also wanted to support a full stealth loop.
In previous Uncharted games, this usually only went one way.
Combat started once the player broke stealth, and the player could never go back to fully sneaking.
In Uncharted 4, we wanted to give the player the opportunity to break line of sight and regain stealth, forcing the enemies into search behaviors.
Fortunately, we had some experience with this loop from The Last of Us.
NPCs are fairly expensive in our engine.
We've always had a tight limit on how many you can spawn at once.
Next-gen hardware meant that we could double our maximum count from the PS3, going from 8 to 16. So we wanted to take advantage of that. Of course, having this many NPCs meant that it was incumbent on us to give them all somewhere to go and something to do. We also had the minor goal of reducing the overhead for combat design.
Hand-authoring every combat setup was a work-intensive process.
And it was also fairly error-prone.
If the player did something that the designer didn't expect, then the scripting might fail to respond accordingly.
So we wondered, could we reduce the amount of scripting required for combat?
So with these goals for Uncharted 4 in mind, I want to give you a brief summary of our existing AI tech.
This should give you an idea of what we were working with to try to achieve those goals.
So I'm going to give you the quick version, but if you want a really in-depth look, I recommend listening to Travis McIntosh's GDC talk from 2014.
It's called The Last of Us Human Enemy AI.
It's free to watch online.
You can just Google for it.
A lot of what I'll be saying in the next couple slides is really just a more in-depth, it's covered in much more depth in his talk.
I see a few people photographing that, so I'll let them do that.
So skills and behaviors are the building blocks of our AI.
Skills are a prioritized list of high-level concepts like panic, combat, melee.
Each skill determines internally whether it wants to be on or off, and then the highest priority skill takes control.
Each skill also has a state machine inside of it.
For instance, combat skill has an open combat state and a cover combat state.
The same skill handles both.
When a skill makes a decision.
It pushes behaviors onto a stack.
Behaviors are reusable low-level components, such as move to a point or shoot from cover.
Behaviors are then the interface with the locomotion controller that actually moves the NPC around and interfaces with the animations.
Now we'll go over the level markup we had for the NPCs.
So here's a combat layout as the player would see it.
And here's our nav mesh.
NavMesh is hand placed by the level designers, and it defines where the NPCs can stand and run and just do normal traversal across.
You can also see some special green NavMesh polys in the bottom left corner.
That's Stealth Grass, a mechanic we added in Uncharted 4 to help the player hide from enemies.
We wanted the NPCs to be able to take the grass into account when navigating, either intentionally avoiding it or intentionally moving through it and searching it.
Traversal action packs, or TAPs, allow the NPCs to traverse using special animations.
These include jumping up and down, jumping across a gap, vaulting over cover, stuff like that.
So TAP animations are authored with an intro, a loop, and an exit.
And this allows them to be placed with flexible heights and lengths.
NavLedges are a new markup for Uncharted 4 that indicate connectivity between climb edges.
This is really cool new tech that allowed the NPCs to leverage some of the player's climbing animations.
Unfortunately, it was mostly for the buddy NPCs to allow them to climb with the player.
The enemy NPCs generally didn't climb unless we had a really compelling layout reason to let them do it.
So our engine takes all of this hand-placed markup and automatically generates these posts.
Posts are discrete points in the world that the AI are going to evaluate.
They're going to use to evaluate.
Sorry.
they are going to evaluate to determine where they want to fight from. So in this screenshot you can see several different types of posts. Green is an open post. Orange is a cover post. There's a couple of them kind of back on the right. Teal is a perch post. You can see those on the edges of the cliffs. And purple is a climb post. Those climb posts are mostly for the buddies. So skills use post selectors to choose the best position to fight from.
Post selectors basically give a score to each post based on various criteria. Then they select the post with the best score. These criteria can include can the post see the player, what's the NPC's path distance to the post, is the post in the NPC's zone, etc.
Some selectors reject posts entirely, others are more fine grained and they give the post a score between zero and one. And then all those scores get multiplied together to create the final value. So here's an example of post selection in action.
So here's an NPC, he's in cover, he's shooting at the player, and then he decides he wants to advance on the player. So why did he pick that position to advance to? So if we zoom in here, the text is probably still too small to read, but these posts are all green because they're scored very highly for the, uh, advance skill. Like they're close to the NPC, they've got the target lined up just as they want it. Uh, actually the reason that leftmost post won out and was actually selected.
is that this NPC is a rifleman, and riflemen like to be a little further away from the target.
So that left most post was the chosen post and was the most ideal of this kind of set of really good options for advancing. Then as we move over to the right here, we'll see a bunch of posts that were technically acceptable for the advanced skill, but they were rated really low. Uh, they're really close to the target, they're really far away from the NPC, uh, they're much closer than a rifleman would want to be.
So these are technically acceptable posts for the advanced skill, but they won't be chosen because obviously there's much better candidates out there. Then as we zoom out, we can see some posts that were just rejected entirely. They effectively have a score of zero. So these include things like covers that are facing the wrong way or covers that can't see the target. This NPC is advancing, so we don't want to pick covers that are behind the NPC. He's advancing.
So all these posts just got rejected entirely at some point in the post selection process.
And it's actually really useful to have post selectors that are just this course. They can just accept or reject things. It's conceptually much easier to write them and uh they really kind of let you narrow down on exactly the kind of posts you want. So this NPC reaches his post and then he's going to keep fighting from cover and he's good to go.
Okay, so here's the fun part.
Here's some things we tried early in development that didn't work.
So here we've got an NPC that's been assigned to a zone that covers this ruined building.
It's the sort of thing we did all the time in the previous Uncharted games.
It's not obvious, but this NPC's standing in the open because he's actually completely broken at the moment.
Why is that?
Well, this NPC's in combat skill, and combat skill does post-selection around the target's position.
target being the player. However, in this massive layout, the player is really far away.
And for performance reasons, NPCs can't do post selection across the entire layout. The post selector is limited to a 25 meter radius roughly centered on the target. The post selector checked every single post and declared them all invalid because they're outside of the NPC's zone. Without a post, the NPC doesn't know how to move or what to do. So it just defaults to just standing there.
Now obviously this isn't a terribly difficult problem to fix from a technical perspective, but it does reveal a pretty fundamental design flaw.
We have a mismatch between our scripted zoning and our systemic post-selection.
So if we can't use zones in these large layouts, we'll need a new system to help the NPCs spread out and intelligently occupy space.
We want them to spread out horizontally, like across the combat front.
And we also want them to have layers of depth.
We want NPCs at short range, mid range, long range, et cetera.
Our first naive attempt at doing this without zones was to strongly enforce the desired weapon range in the post selector, really enforcing that the pistols have to be at short range, the rifles have to be at mid range.
We hoped that this simplistic logic would be sufficient to avoid the NPCs clumping up.
Unfortunately, trying to keep NPCs at their ideal weapon range can make them extremely unstable.
The player can move very quickly in Uncharted, so the distance to the target is constantly changing.
These NPCs can never settle into combat positions, because their desired weapon range is always telling them to reposition.
So this naive approach was a blunt instrument.
If we wanted to evaluate good combat positions, our approach would have to be much more nuanced and complex.
So we started trying some more of these sophisticated approaches.
Again, trying to move away from the idea of having to rely on these scripted zones all the time.
We wanted to see if we could identify strong areas in the layout programmatically.
So we tried two approaches for this evaluation, connectivity and vantage.
We already have the navmesh markup that the AI used to navigate.
And we can use that to generate a map of the layout's connectivity.
Could we use that information to identify relevant features, stuff like pinch points and doorways?
If the player is in a building, could we send an NPC to cover each one of the exits?
Unfortunately, when we started running this logic on more of our layouts, we found that connectivity couldn't consistently produce useful information.
While it could handle manmade structures pretty well, like houses, connectivity struggled to detect anything useful when we ran it on big organic spaces like this one.
That slide's really dark.
It also struggled in our wider vehicle-scale spaces.
There just aren't enough important nodes on this spiderweb of connectivity.
So connectivity was an interesting idea, and it might have worked pretty well in our previous game, The Last of Us, because its layouts were generally tighter and narrower.
but it wasn't a good fit for Uncharted.
Vantage was another kind of programmatic evaluation, and we developed it to try to fix a problem with watchtowers.
Let's say we designed a layout with a watchtower, and we put a sniper up there to shoot at the player.
If the player took cover, then the sniper NPC would determine, I can't see my target.
I need to reposition.
But in repositioning, he would jump down off the tower.
That's terrible.
So we needed some way to make the NPCs prefer elevated positions, even if those positions can't currently see the target.
To do this, we tried to evaluate combat positions using this concept of vantage.
So in this screenshot, you can see the player in cover on the right, and a strong elevated position on the left.
How could we make NPCs like that position, even though it can't currently see the target?
So to evaluate Vantage, we gathered all the NavMesh polys in a small radius around the player.
The borders are a little uneven because of the NavMesh triangulation, but this orange area roughly represents where the player could move in about three seconds of movement.
Vantage does a raycast to each of these positions and counts how many of them a given position can see.
So in this screenshot, green raycasts are clear and red raycasts are blocked.
You can see that the elevated position on the left has clear line of sight to more positions around the player versus the other lower position being tested in the top left.
This means that the elevated position would have a higher vantage score, and the MVCs would thus prefer it.
So we tried these two programmatic approaches to identifying strong layout positions, but they kind of both had the same fundamental problems.
Firstly, they couldn't consistently produce good results in every layout.
We have a pretty big variety of layouts in Uncharted 4.
We could tune these algorithms to work well in one, but then those same tuning values would just totally fail in another kind of layout.
And then we'd maybe retune there and go back and forth.
It just never worked consistently everywhere.
More fundamentally, we were making the mistake of trying to reverse engineer high-level decision-making.
The level designer had already created a level with combat in mind, and had purposefully designed certain areas to be strong.
We were then throwing out that knowledge to try to achieve the same results programmatically.
Wouldn't it be smarter to bake the level designer's intention right into the layout?
Programmatic evaluation also limited the designer's ability to make each encounter feel unique.
If the NPCs fight the same way in every layout, then we run the risk of every encounter feeling the same.
The designers need more control, more knobs, if they're going to craft setups that feel truly unique.
So I'm gonna come back to all of those issues in the next section, but for now I'm going to move on to search.
So I mentioned earlier that one of our goals for Uncharted 4 was to allow the player to re-enter stealth from combat.
To do this, we needed to develop a new skill to make the NPCs search for the player after they'd snuck away.
So our first version of this skill used heat to represent how recently an NPC had cleared an area.
The initial heat was seeded from the player's last known location.
Areas would heat up when unseen, and the NPCs would cool them off again by clearing them out with their vision.
So you can see in this screenshot that pink means hot and blue means cool, just like real life.
So I'm gonna let this play out for a little bit.
So you can kind of get a sense of the loop here. The NPC picks a hot position that's nearby, goes and clears it out. Once they've cleared that out, they pick the next nearby hot position. NPC just faked us all out and went off camera. Then he decides he wants to check on top of that plateau.
So the heap-based search looks pretty cool with the debug tools on, because from this perspective, it's easy to understand why the NPC is choosing these points to move to.
But it's quite different when you experience this behavior from the player's perspective.
So heat search has three main problems.
In heap-based search, NPCs change directions in unpredictable ways.
Without seeing that heat information, it's really impossible to find a pattern in the NPC's movement.
There's no consistent line of motion.
Doesn't look very human.
And it feels really bad as the player when the NPC you're about to stealth kill just turns around and busts you.
If the player can't predict where an NPC might move next, then the player can't plan their approach in stealth.
It robs the player of the ability to do clever things.
Secondly, heap-based search does a poor job of spreading out the NPCs.
They tend to bunch up, going after the same clusters of hot nodes.
If all the NPCs are searching in one area, then the player can just hang out in another area without feeling any pressure.
Thirdly, it tends to pull the NPCs towards the nooks and crannies on the outside of the combat space.
If there's a little pocket out there that can't be seen, heat's going to accumulate in there and eventually draw an NPC to go check it out.
we'd much rather keep the NPCs near the center of the map, near the strategically important positions, like the exit.
So all of these symptoms come from the same really fundamental problem, which is that we designed search skill based on the perspective of the NPCs searching for the player.
Counterintuitively, that was completely wrong.
And again, I'll explain why that is in the next section.
So if we think about authored and systemic as two ends of a spectrum, we came into Uncharted 4 on the far left side of that spectrum, with the design philosophy of the previous games.
Highly authored, tightly controlled by the combat designers.
And then in the early days of Uncharted 4's development, we swung pretty heavily in the other direction, trying to develop approaches that were just highly systemic and relied much more heavily on algorithmic evaluation.
Ultimately, we felt that we had oversteered away from authored content.
Our reversion to scripted combat was robbing us of an element that made the previous games play so well.
We started thinking, was there a middle ground that would let us avoid the drawbacks of the highly scripted approach?
Could we get the best of both worlds?
So onward to part two of the talk, where I'll be talking about the things that actually worked.
So I'm going to start by going over the new tech that we developed and actually shipped with. It's just one bullet point on this list, but this is the biggest section of the talk. So far I've talked a lot about zones. And zones are really a blunt instrument. A designer assigns a zone to an NPC and the NPC uses that zone to modify their post selection. Could we make a more nuanced version? So we developed a new concept called a hard point. It looks like a zone.
but it's an object that exists in the world independently of any NPC.
NPCs can be dynamically assigned to a hardpoint, and they will fight as if it's their zone.
And I'll explain why that abstraction is so crucial.
A hardpoint has five properties.
It has a name that can be referenced from script, it has a region that limits where the NPC will fight from, it has a minimum and a maximum number of assigned NPCs, and it has an enable-disable toggle that can be controlled from script.
So here's an example of how hardpoints were used in one of our encounters.
The green hardpoint on the left covers the strong elevated position in the tower, the yellow hardpoint covers the open field that has good lines of sight to the rest of the layout, and the teal hardpoint in the back covers the exit door.
It has a minimum assignment of one, because we always want to keep one NPC there to prevent the player from sneaking out too easily.
So this debug shows the actual region for each hardpoint.
I just had it off before because it's kind of hard to read.
But this is the actual extent of each hardpoint, defining where the assigned NPCs are allowed to fight from.
So in this example, these two NPCs are assigned to a hardpoint on the bridge with a minimum assignment of one and a maximum assignment of two.
So they're happily fighting from the bridge and holding down this position.
But when reinforcements spawn behind them, the new NPCs are going to take over that hardpoint assignment.
And this frees up the initial two NPCs to push up on the player.
So this reassignment happened just completely systemically, just by respecting the min and max counts defined by the designer.
It would have taken much longer to achieve this kind of dynamic handoff with just a purely script approach.
Picking which NPCs to assign to each hardpoint is handled by a code module called the hardpoint coordinator. It makes selections based on various criteria, such as distance to the target, weapon type. It also generally tries to avoid assigning the NPCs backwards. It always looks better when NPCs can move forwards to their objective. So I mentioned earlier how we had some goals for combat. Things like spreading out the enemies and creating layered combat.
with NPCs at different ranges. I also showed what happens when an NPC's skill doesn't match their zone. So our solution to all three of these problems was to implement combat roles. But before I talk about roles in Uncharted 4, I first want to talk about the ghosts in Pac-Man.
Bear with me. So each ghost has a different role and fundamentally these roles were designed to achieve the exact same kind of design goals.
My information on the Pac-Man AI, by the way, is based on the excellent article, the Pac-Man Dossier by Jamie Pittman. It's on Gamasutra. So shout out to Jamie for letting me use some of his diagrams in my talk. So the red ghost Blinky is very simple. He just pathfinds to Pac-Man's current position and constantly moves towards him. Blinky chases the player from behind and pressures them to keep moving.
path finds to a position two spaces ahead of the player's current heading.
So this simple behavior creates a cool dynamic where Blinky closes in from behind and Pinky gets ahead of the player and cuts them off.
It's actually really impressive to achieve that dynamic with such simple behaviors.
Clyde is the least threatening ghost.
When he's far away from the player, he acts like Blinky and chases to the player's current position.
But when he gets too close, he pathfinds away to one of the corners of the maze.
This makes Clyde bounce back and forth, keeping a somewhat consistent range from the player and effectively defending his corner of the maze.
Finally Inky.
Actually, I'll get back to Inky later.
For now, let's go back to Uncharted 4.
So the three core combat roles in Uncharted 4 are Engagers, Ambushers, and Defenders.
These are the three layers of combat, an ascending order of distance from the player.
Engagers are simple.
They approach and attack the player's current position.
They can move wherever they want and perform typical NPC combat behaviors.
Ambushers do this.
They pick a position to take cover, and then they wait for the player to move their way so they can pop out and surprise them.
we dynamically generate ambush points 20 meters away from the player along the navmesh.
An ambusher claims one of these points and moves there to take cover with the intent of anticipating where the player could move next.
The reason for this behavior is that during our play tests, we often notice that the player would be fighting in one area, they'd be having a good fight, things would be pretty well paced and things would be good, but then if things got too hot and they needed to disengage, they'd run to a different part of the layout and it would just be completely empty.
Ambushers help the space to feel fuller because as the player moves around, these ambushers will suddenly pop up, pop out of cover and engage them.
and it keeps the pressure up on the player.
And then defenders are the NPCs that are assigned to hard points.
They will not leave their hard points, but they will do their best to get line of sight and take cover within their assigned area.
So how do these three roles compare to the Pac-Man AI?
Well, Blinky is an engager, because engagers chase the player's current position.
And Pinky, Pinky's like an ambusher, because ambushers head off the player's future position.
Clyde is a defender, because defenders keep their distance from the player, and they hold down their corner of the maze.
Clyde's a little bit of a stretch, truthfully, but it's similar.
All right, what about Inky?
So Inky is considered the most dangerous ghost due to his erratic, unpredictable behavior.
To determine Inky's movement, create a line between the player's position and their current heading.
Then take the red ghost Blinky and mirror Blinky's position across that line.
That is the position that Inky will chase to.
Sadly, this weird behavior has no equivalent in Uncharted 4.
So you remember earlier how in large layouts we had a mismatch between our scripted zones and our post selectors?
Well, having roles fixes this issue.
Engagers want to fight at the player's current position.
So they do their post selection centered on the player.
Ambushers do post selection around their ambush point that they've been assigned to.
And defenders do post selection around their hard point.
Therefore nobody has the problem of trying to do post selection outside of where they're allowed to fight from.
Earlier I mentioned that we had a code module that assigns the NPCs to the hard points.
We have a similar code module called the encounter coordinator that's responsible for assigning NPCs to roles.
assigning roles to NPCs. For instance, we have a limit on the number of engagers. An NPC can request to be an engager, but the coordinator gets to decide who actually gets that role. It selects the NPC with the best rating based on various criteria. Again, stuff like distance to target, line of sight, weapon, et cetera. So here's the nitty gritty of how this role assignment actually works.
Let's say we have a group of 15 NPCs we need to assign out.
Well, first we assign NPCs to each hard point, up to each hard point's minimum.
That's absolutely crucial.
We absolutely want to get the minimum for each hard point as the first priority.
After that, we assign a certain number of NPCs to be engagers.
So that number X is actually defined in a script file called the global combat params. I'll talk about that file more in just a minute. For now it's usually about 2 or 3. So pick 2 or 3 of those NPCs that are close to the player and they'll be the engagers. Then we pick another number of NPCs to be ambushers. Again, that number Y defined in the global combat params usually about 2 or 3. So pick 2 or 3 NPCs to be ambushers.
Then from the remaining NPCs, we assign them to hard points up to each hard point's maximum.
And then if we have any NPCs remaining after all that, those NPCs default to being engagers.
We don't actually want that step 5 to happen.
If that happens, that's kind of a fallback.
That means that the encounter will have more engagers than the designer was intending.
So actually, if we ever hit that step five during development, a big warning appeared on screen letting the designer know that they had to increase the limits on their hard points or start adding new ones.
So here are those global combat params I'd mentioned.
These params are tuning values that we can customize per encounter.
This allows us to have systemic combat behaviors while still giving the designers lots of control to customize each encounter and make it feel unique.
So this slide with the source code is probably a little hard to read unless you're really familiar with Lisp. So I'm going to go through some of these individual combat params on a separate slide. So global combat params. We control things like, as I mentioned, the number of engagers and the number of ambushers. We also had to define a time delay to replace an engager. If the player shot one of the engagers and killed them, Do we want a new engager to be assigned immediately or do we want to have a little bit of delay on that? That would impact how hard the NPCs push up on the player in a given encounter. We also define the snuck away distance for stealth. How far away from their last position, not from the player's last known position do they have to move before the NPCs consider them to be snuck away and then lost and then they go into search behaviors. This tended to be something we tuned kind of per the size of the encounter space.
We had a timer for the NPCs advancing from cover to cover.
We had a timer for how long until an NPC was throwing grenades.
We also had a timer for how long until we sent out an NPC to flank the player.
We also controlled the minimum flank path rating.
So that meant, like, how good does a flank path have to be before an NPC will choose to use it?
If you reduce this threshold, the NPCs might choose bad flank paths, but it'll make them more aggressive, and they'll push up on the player much harder.
And finally, we had the minimum and maximum number of shooters, which kind of presents an interesting design question about limiting the NPC's desire to shoot.
So if you have 10 NPCs that are all allowed to fire at once, then 10 NPCs are 10 times more dangerous than one NPC.
And we don't want to scale combat that way, because it creates combat that starts out really hard and then gradually gets easier with every NPC you kill.
Instead, we want to limit the number of NPCs that can fire at the same time, usually capping out at about three or four.
This gives us leeway to use more NPCs in combat without greatly scaling up the difficulty.
However, we need to disguise the fact that some NPCs are intentionally not shooting.
So I'm going to let this video play out for a little bit.
I thought this video had sound, but it doesn't.
So we tried to make the handoff between NPCs being allowed to shoot as smooth and as seamless as possible.
And I think it turned out pretty well.
So what's the logic behind this?
So shooter is also a role, but it's orthogonal to the other roles.
Engagers aren't necessarily shooters and vice versa.
Only NPCs that have the shooter role are allowed to shoot, and then they give up that role when it's time for them to reload or if they lose line of sight, et cetera.
This allows us to artificially limit the amount of gunfire towards the player without making the NPCs look bad.
Here's a still view of that handoff in the previous video.
The two NPCs circled in white have the shooter role and are allowed to aim and fire.
And then two NPCs without the shooter role just hunker down and cover, waiting for an NPC to give up the shooter role, but they look just fine while they're waiting.
OK, getting back to search, let's talk about what we shipped with for our search solution.
So our solution for search was to have the designers mark up the levels with spline loops.
NPCs use these spline loops as a guide in search and will flow from segment to segment being dynamically reassigned as they move. They're allowed to deviate a little from their splines if they want to check out an interesting feature or go search behind cover or look down the edge of a cliff, stuff like that. Otherwise they stick to the splines pretty closely.
So these authored loops helped fix some of the issues that heat search had.
Firstly, NPCs maintain their line of motion better, which makes them look more natural, and it also makes their motion more predictable for the player, enabling the player to confidently plan for stealth kills.
These NPCs aren't gonna suddenly turn around and just bust them.
Secondly, the NPCs stay near the spline loops.
And because the loops are authored by a level designer, we can choose to only place them near the interesting parts of the layout.
This avoids the problem the heat search had with NPCs wanting to go comb the outer edges of the layout where there wasn't much going on.
And thirdly, we limit the number of NPCs assigned per spline so they never bunch up too much.
Actually, having two NPCs on the same spline can facilitate some cool performances, like having the NPCs check in with each other.
or they can pair up and search together for a little while.
It's really useful.
How about the NPCs that are assigned to hard points?
How can they join in the search?
Well, we don't want them to just abandon their hard points, so they're not allowed to go walk along the splines.
Instead, we modified the concept of vantage to instead test what points the NPCs can look outwards from while staying on their hard points.
This gives them a good behavior for search that doesn't pull them away from the area that they're supposed to be guarding.
Finally, here is a quick grab bag of evergreen AI techniques, the stuff that we've carried with us for several games and they've always been really useful, so we just kept using them in Uncharted 4.
So I mentioned that we had a script file called the global combat params.
It was actually named this way in contrast to the just combat params that are set individually for each NPC.
In Uncharted 4, all of our enemy types are actually running the same fundamental AI.
We use the combat params to create the distinct enemy types, snipers, shotgunners, heavy weapons, et cetera.
This setup is extremely useful because it's flexible and extensible.
Let's say you happen to have one combat setup where you need a rifleman who doesn't take cover.
You can define a new combat param as a child of the default rifleman and just toggle the Boolean that allows taking cover.
we actually ran into a situation really late in development where we wanted to create an armored grenade launcher.
We were able to do so easily by combining some elements of the unarmored grenade launcher and some elements of the regular armored NPC.
We mashed those together and created a new combat param that just worked right away.
It was great.
We actually have a nice synergy between some of our classic enemy types from the previous games and our new concept of combat roles in Uncharted 4.
We made it such that shotgun NPCs are just always engagers, so they're always able to push up on the player as they please.
On the other hand, snipers are just always defenders.
We set them up with a hard point, with a strong position, good lines of sight, and then they just snipe from that area.
In a way, it's a more systemic version of the sniper with the tiny zone that you saw in that video from Uncharted 2.
So combat in the Uncharted series is at its best when the players take advantage of all the traversal abilities available to them.
We really want to disincentivize the player from just hunkering down in one place and playing it like a cover shooter.
So to gently suggest that the player should keep moving, we have the enemies throw grenades.
Grenades are the gentle suggestion.
This is managed by a simple module called the grenade director, and it just tracks how long the player remains in a certain radius.
If the player leaves the radius, reset the timer. But if the timer runs out, request an NPC to throw a grenade. Grenade thrower is a role and the NPC with the best clear arc is chosen to take that role. So here's how it works in practice. Player remains in the same radius for too long. The timer meter you see counts down. An NPC is chosen to throw a grenade. Grenade gets thrown. And the player is gently suggested to move.
So flankers serve the same purpose.
Push the player if they've stayed still in one place for too long.
Flanker is just another role that an NPC can be chosen for.
And their job is to get behind the player while avoiding line of sight.
We had a very similar skill in The Last of Us.
And for that game, we tried all sorts of complicated logic that involved calculating the exposure along the entire path.
In the end, we actually had much better results with a much simpler algorithm, and we carried that approach over to Uncharted 4.
So we used the combat vector, which is that weird yellow oblong polygon.
It's oriented from the player's position, players at the bottom of the screen.
So it's oriented from that position towards the average direction of threat of the enemies.
So flankers use a pathfind that makes moving through the combat vector more expensive.
So that's a really simple behavior, but we've had really great results with it in all sorts of different kinds of layouts.
It's just a great all-purpose kind of behavior.
Accuracy ramping is a tuning value that I highly recommend.
So from the time they spot the player, NPCs have to ramp up to full accuracy over time based on their distance.
This gives an advantage to players who wanna stay agile and keep repositioning.
They'll have a chance to move from cover to cover without taking too much damage.
Players who just turtle up in the same position will not receive this benefit.
So you might recall that we had a special kind of post called a perch.
They were the teal posts that we generated on the edges of cliffs and stuff.
So I'm going to play this video to show why they were necessary.
So perches are a special type of post that we generate on the edges of cliffs and over thin railings.
They allow the NPCs to play custom animations that lean further out and help them aim around and downwards.
We found that without them, the default aiming animations really struggle to deal with these complex 3D climbing spaces.
And now I'd like to briefly talk about some of the limitations of our current systems and things we'd like to improve on in the future.
So the scoring of post selectors.
has a lot of magic numbers, has a lot of handwritten distance curves, and it takes a long time to tune these values in a way that works in every layout.
And once these criteria have been tuned, it's really impossible to go backwards and discern the thought process behind them.
I really don't have a good solution for this, but I wish we could develop this weighting, the weighting in the post selectors, in a more transparent, methodical way.
The logic for generating ambush points is not very smart.
It simply looks 20 meters away along a navmesh.
So in this screenshot, the player's at the top of a cliff, and the navmesh distance doesn't take into account the steep drop.
These ambush points at the base of the cliff are technically 20 meters away, but their positioning below the player isn't very useful.
Fortunately, we had a simple workaround.
In this encounter, we set the number of ambushers to zero using the global combat params.
but in the future I'd like to develop a more, a smarter heuristic for generating ambush points. And finally there's a combat balance problem that we struggled with and you'll see it in this video.
So the player can snipe an NPC with a pistol from about 50 meters away. This is because we found over and over in our playtests that players expect the guns to hit the center of the reticle no matter what. Unfortunately, this limits our ability to make short range weapons.
And it makes chipping away from NPCs at long range very effective. Any time we had a really good, effective playtester who was playing on the higher difficulties, this is all they'd do.
we did do a couple of things to mitigate this strategy. We added damage wobble on the camera and secondly we have an accuracy floor for the enemies. So even at extreme long range there's a limit to how low their accuracy will go. Ultimately though I still consider this to be kind of an OP tactic and it's one that I'd love to find a more holistic solution for. Alright, in conclusion.
Through Uncharted 4's development, we explored both extremes of this spectrum, a highly authored approach to combat design and a highly systemic one.
Ultimately, we landed somewhere in the middle, and I think that gave us the best of both worlds.
My suggestion to you is, early in development, try to figure out where your game should land on this continuum, and be cautious of the extremes.
And now here are four things that I hope you'll take away from this talk.
Takeaway number one.
don't reverse engineer high-level decision making.
Take advantage of your level designer's knowledge.
Unless you're making a completely procedurally generated game, baking designer intent into the layout is often better than trying to reverse engineer it algorithmically.
Takeaway number two, design NPC behaviors from the player's perspective.
When we made Heat Search, we were thinking about searching for the player from the NPC's perspective.
In a sense, it's like we were designing fun for the NPC.
It's better to start from the player's perspective.
What experience do you want the player to have?
What decisions do you want the player to make?
Then design your NPC behaviors accordingly.
Takeaway number three, author roles, then assign NPCs to them programmatically.
Deciding where to draw the line between the authored content and the systemic behaviors can be really tricky.
The approach that worked for us was to have the combat designers outline the desired roles for an encounter, but then allow code to select the NPCs that were actually going to fulfill those roles.
This is a great way to handshake between these two parts of the system.
And takeaway number four, if you have a large number of NPCs, then only a few enemies should get to directly engage the player.
In that case, the outer ring NPCs need a goal other than also shooting the player.
Or are they all going to look like young kids playing soccer?
All going to be chasing the ball.
It can be useful to think about it spatially.
If an NPC shouldn't chase the player, then where should they be standing?
That's it.
Thank you very much.
I have a little bit of time for questions.
If you want to come up to the mics, I can take your questions.
Hi, my name is Matt from Insomniac.
I'm just curious, the one with the chipping away with a pistol, the obvious solution I would think of would be reduce the accuracy of the weapon.
Like, did you try?
Yeah, we had a kind of minimum deviation on the first shot of the pistol.
But anytime, you know, you see the reticle, and I guess from one perspective you can think, well, the shot's going to land anywhere in the reticle, that's fine.
Often from the player's perspective, that's, I had 80% of the reticle over that NPC's head, and I fired, and I missed. These guns feel sloppy and terrible.
And often, actually, if NPCs...
playtesters felt like they couldn't rely on the guns, they just went crazy with melee.
They just loved meleeing because they felt, at least that's reliable.
When I hit square, I know what's gonna happen.
So ultimately, that was a concession we had to make.
We had to make it so that the first shot, center of the reticle, no matter what, and then that kind of, unfortunately, had the knock-on effect of this kind of unfortunate long-range behavior that, yeah, I don't know, something we're still trying to fix.
Okay, thank you. Thank you.
I'm curious about what kind of iteration times all of these different approaches took before you came to the ones that really worked well we had kind of the Luxury of being able to do a fair bit of this in pre-production So it was before we really got ramped up, before we actually were making all the layouts for the game.
It's funny, actually, in a way, when we started heading towards production and were making more than our couple of handful of test layouts we had, when we started seeing the real layouts the game was going to have, that's when actually a lot of the issues fell out.
And we had to really think on our feet and come up with new stuff.
So I would say, hopefully, a lot of the things I said up there, we tried and we didn't work.
We didn't spin our wheels on them for more than a week or two.
Some of them maybe longer, but that was kind of our loss.
We had the good fortune of kind of landing upon our solution of hard points and roles within the early period of actual production.
And that let us go forward confidently with all our layouts we were making during production.
Nice.
Thanks.
I guess I'll go over here.
For when buddies were involved in combat, did they take on some of the roles the enemies had for ambushing and engaging or how did you balance that?
I didn't work as much on the buddy NPCs. Actually the biggest thing, like combat with buddies didn't turn out to be that hard.
We kind of gave them a target, we gave them tons of melee behaviors to help the player, that's kind of something that's...
I didn't cover it all in this talk, but as a whole other complex system is melee.
So combat tended to be pretty decent.
That's not a very interesting answer.
Actually it was stealth that was a lot harder with the buddies and that was something that obviously we were sensitive to and we tried to push a lot harder on.
And we worked really hard to make sure that not only did the buddies never get you busted, but also they never...
as much as we could, walked in front of an enemy, or we did all sorts of interesting looking, we did like a future exposure map to detect where we'll be exposed and keep the buddies out of those. But actually their combat behaviors were very simple. Generally it was the biggest section of the game where you had two buddies with you was Madagascar.
kind of fortunately that had really big spaces so it actually gave us a lot of leeway to account for them trying to find good positions as well. I think we would have struggled to have two buddies through the whole game and through some of the tighter encounters. I feel like I'm kind of rambling at this point. It wasn't generally that hard and they didn't use the same behaviors.
For the Minimax Shooters manager, did you ever run into cases where a player just got really close to a certain AI that wasn't able to shoot because he couldn't get a token because it was being blocked by other AI that were shooting from farther that weren't as critical to the current engagement encounter that he was experiencing and the AI just kind of either stood there or ran away or maybe meleed, but it felt strange that he decided not to shoot?
So we didn't typically run into that.
We do do some prioritization so that closer NPCs get the shooter role more readily than further NPCs.
I can't remember the exact details, but we may have done some things as well.
It's like if the player directly engages with an NPC, we really prioritize giving up the role.
We also kind of fudge it with giving up the token.
Like I mentioned, you give up the token when you reload, but we actually.
if you count the bullets, they're not always completely consistent about like how many bullets they should do before they reload. We sometimes say, no, this, this NBC really needs to shoot, just let him shoot. Don't, he technically needs to reload right now, but he would look really silly if he did so. So, so we did some fudging like that and then, yeah, as I said, prioritization based on distance, which really helped.
So something that struck me when you sort of moved from more authored to more systemic and landing in that gray area Was the NPCs more or less communicating with one another they seem like they're all making sort of their own autonomous decisions And like the sense of tactics sort of emerges from it But there's elements like because he's suppressing, should I be more likely to flank?
Or because this grenade thrower just got selected, is this a great time to become more aggressive?
And the NPC's talking to one another, even through a manager.
Did you experiment with any of that?
And did you get any good results?
We did things kind of along those lines.
One of the skills that I didn't go into super high detail on was that advancing from cover to cover skill.
and that will do things like, okay, this NPC is going to be advancing from cover to cover, so this other NPC should lay down suppressing fire. Or, um, I forget the other things you mentioned, but like, when you talk about flankers, we only send out a flanker if there are enough other NPCs doing interesting things, putting pressure on the player. We try to pick a flanker who's not already doing something interesting. We try to pick someone who's doing something kind of boring or sitting in cover somewhere and can't do anything better.
Okay, pick them to be the flanker.
So some of that kind of fell out from that, but I'm not sure if that answers your question.
Hi, I was just wondering about how many engineers were sort of supporting the prototyping phase of these different systems?
Five, five or six.
Very, very small programming team, very lean.
I mean, it was kind of the people you saw on screen.
Part design team, part programming team.
really small. I think that looks like it. If anyone has any other questions feel free to grab me and we can go to the wrap up room. Thank you very much for coming.
