So, hello everyone, my name is Matthew Harris from Criterion Games and welcome to Vehicle Feel Masterclass, Balancing Arcade Accessibility with Simulation Depth.
And if you think that's a lot of words to fill on one slide, then you're going to love the rest of this presentation.
During this talk I'm going to discuss Criterion's vehicle design philosophy and how we build vehicle handling that is both intuitive but deep and masterable.
This talk isn't a set of hard and fast rules to follow to make the perfect vehicle game, as all games are different, but it's more a sharing of our processes and guidelines that we follow throughout development, with a view to both inform and inspire.
Hopefully you'll find some useful learnings whether you're new to vehicle design or if you've just shipped your seventh Forza title.
So before I get stuck into the presentation, I wanted to briefly talk about Criterion Games' history.
Originally set up in 1993 as Criterion Software, Criterion developed the Renderware engine, and started making games in order to show it off.
Early games such as Trickstyle, led on to the incredibly popular Burnout franchise, and then on to Need for Speed Hot Pursuit and Most Wanted.
After over a decade of working on racing games, we started to lend our vehicle expertise to DICE, where we worked on vehicles in Battlefield 1, X-Wing VR Mission, and most recently, Star Wars Battlefront II.
As for myself, I joined Criterion five years ago on Need for Speed Most Wanted and worked on this selection of titles.
At Criterion, we encourage cross-discipline skills as much as possible, and so over my career at Criterion as a programmer, I took special interest in game feel, particularly in the design of vehicle handling.
This proved incredibly useful, as understanding how to tune and design great vehicle handling as a programmer meant that I could work closely with our designers to deliver great game feel.
And that's why I'm a programmer standing here giving a design talk.
Okay, so what am I actually going to talk about today?
As you might guess from my background, this is going to be a technical design talk, and it's aimed at taking you through the key parts of Criterion's vehicle design philosophy.
Along the way I'm going to talk about the key differences between arcade and simulation games and how each type balances accessibility with mastery and depth.
Then I'll move on to the simulation itself and discuss our physicality-first approach to designing vehicles and how to identify where the play in our vehicles comes from.
After setting up a physical simulation, we add accessibility through the input layer on our assists, which are critical to providing accessibility without reducing depth.
Once the vehicle is controllable and satisfying, we need to feedback the vehicle's handling via the camera, and I'll talk through some key concepts we use here.
Throughout the majority of the talk, I'll be using motorsport racing as the context, as it provides a great variety of examples.
However, in the final section, I'm going to show how our design philosophy can apply to a very different type of vehicle, the Starfighters in Star Wars Battlefront II.
One important thing to note here is that the whole talk is focused around the handling side of game feel.
Things like audio, VFX, sense of speed and force feedback are very important to game feel, but you could probably do entire presentations on those, so I won't be talking about those today.
Let's start with a discussion on arcade vs simulation.
When thinking about the term arcade, I don't mean a game genre like top-down shooters such as Geometry Wars.
I'm talking about a particular set of game design decisions that lead to a particular arcade feel.
Games that have an arcadey feel tend to focus on intuitive controls that are readily apparent to the player, make compromises on realism for the sake of fun, and often have a multitude of game mechanics that the player is trying to balance against each other.
Simulation games, on the other hand, are trying to replicate a real-world experience and so tend to have a control system that's about immersiveness first and aims for a high degree of realism and believability from its gameplay and handling.
Simulation games tend to have fewer game mechanics than arcade games as they tend to focus their gameplay around controlling a realistic vehicle rather than one with weapons and boost.
Different design decisions can lead to a more arcade or simulation feel for your game, so in the next slide I'm going to try putting a selection of motorsport games on a sliding scale between arcade and simulation.
Let's start at the simulation end of the spectrum with games such as Forza Horizon, regular Forza and iRacing.
These games are focused towards delivering a realistic simulation of motorsport with their gameplay entirely around racing lines, cornering and drafting.
They tend to have most of their assists off by default but will often give the user the option to turn on accessibility options such as help with braking or steering.
Simulation games tend to end up with quite a high learning curve but are very rewarding for players who put in the time to master them.
As we move towards arcade-style games, we have a subcategory in the middle of Simcade, which are where hybrid games such as Forza Horizon and Need for Speed live.
These examples aim for a Hollywood realism tone, where things are a bit more over the top but still within the realms of real life.
Players are doing exaggerated drifts and massive jumps, but in cars from real manufacturers.
There are often additional challenges added on top of racing in Simcade games, such as extreme weather in Forza Horizon or weapons and cop chases in Need for Speed.
Finally, we get to the arcade-style races, which tend to go for a heavily stylised or even cartoonish tone.
Arcade-style races tend to have a large variety of game mechanics, such as drifting, boosting, stunts and weapons, in which the players have to learn in addition to racing.
For this reason, the racing gameplay tends to be quite accessible for new players, but still provides plenty of depth for players who really want to get the most out of the game.
So when comparing arcade and simulation, the arcade-style races have a variety of gameplay mechanics on top of cornering and speed management, such as weapons, stunts and boosting.
Simulation races have fewer mechanics for the player to focus on, but have a simulation focus towards realism, and their aim is to make cornering and racing as satisfying as possible.
Arcade is generally more accessible and fun, whereas simulation is harder to get into, but offers a more serious take on racing competition.
One key thing that is consistent across all these games is that the player has to input controls at a satisfying cadence.
The actions per minute for simulation games and arcade games are actually pretty comparable.
For a simulation game, the player focuses all their attention on their racing line, trying to tap, brake, and turn at just the right intervals to nail that corner.
Whereas in an arcade game, the player divides their attention between drifting around corners but also boosting and firing weapons.
Although some people might see arcade-style races as casual and simple, in fact they have a wider variety of game challenges for the player to focus on than in simulation games.
So when deciding where on this scale you're aiming for your game to be, you should consider a number of factors.
What sort of players are you targeting your game at?
Are they serious sports fans that demand realism, or are your players more interested in fantasy fulfillment?
How serious and realistic is your game tone?
If you're planning on having lots of mechanics such as boost and weapons, then you'll likely fall more on the arcade side of the spectrum.
Balance the number of mechanics and complexity of the simulation against your assists in order to achieve a sensible rate of actions per minute.
How much effort do you want to spend on your physical simulation?
If you can't put much time into physical simulation but you're trying to build a realistic motorsport simulator, then you might end up with boring and shallow gameplay.
Do you want your game to be accessible by lots of players, or are you focused on an experienced target market?
If you're building an arcade or simcade racer, you'll likely need some assists to help keep the input frequency at satisfying levels.
Once again, these aren't hard and fast rules, but you should have a strong idea of where you want to sit on this spectrum.
Don't try to have it all, otherwise you risk building an overly demanding and complex game.
At Criterion, our approach has been to combine what we see as the best of both worlds between arcade and simulation.
We start with physicality and build a realistic, physically based simulation.
Then we build assists on top of that, which makes the simulation more accessible and allows the player to focus on more things at once.
Our designers then very carefully balance physicality and accessibility in order to get a balanced experience that hits our aim of easy to learn but hard to master.
Criterion has used this type of approach since Need for Speed Hot Pursuit and has worked well for us ever since.
Okay, so the next part of the vehicle design philosophy that I'm going to talk about is the physical simulation of the vehicle.
So, we see the physical simulation as the foundation that allows us to build a game with deep mastery and rewarding challenge.
In this section I'm going to start by talking about how the context of our game affects the elements we might want to simulate, and then go on to compare different physical simulations of car dynamics by using approaches that mimic real-world physical effects.
We ideally want to pick parts of the simulation that will add play to the handling, giving the player multiple things to balance and learn in order to achieve their goal.
Before starting work on your physical simulation, it's important to consider your game context.
This is because we see the context as a set of requirements on your physical simulation.
Think about if your environment is wide open or enclosed, how might this affect the desired behaviour of a vehicle?
Also consider what the player's goal is when driving the vehicle.
Are they racing, performing stunts, or are they just trying to get from A to B?
If getting from A to B needs to be a challenge, then maybe your game is about complex traversal.
Here's an example of a racing sim, Forza Motorsport.
The vehicle is on a wide road and will encounter long curved turns and the player wants to win the race through precision driving through corners and drafting behind other racers.
On the other side of the racing spectrum, we've got something like Burnout, which is set mainly on urban roads with some tight turns and some jumps to navigate.
The player could be racing against other vehicles or could be doing stunts to win a score attack mode.
There's still a focus on cornering here, but also on boosting and stunts.
Destiny's Sparrow is a great example of a transport vehicle.
It's primarily designed to go across open terrain, but the player will often pilot it down narrow corridors, so it needs to deal with both.
The main player intention here is to get to their target without colliding and slowing down too much, but it's a lower pressure than the previous examples.
In Uncharted, the jeep provides some light puzzle mechanics when trying to navigate up rocky mudslides, and the challenge to the player is in picking an effective route up the mudslide while trying to keep the tyres in a state of grip.
Each context has its own requirements from the vehicle.
If we change the context, we should re-evaluate the vehicle and see if it still suits it.
One example of this would be the Sparrow in Destiny, which I really enjoyed driving as a transport vehicle, but when they introduced Sparrow Racing, I didn't feel like the vehicle lent itself to racing very well.
As a timed special event, this was fine, but if they wanted to build more of the game around racing, I'd hope that they would retune the vehicle to fit that context.
During production, it's also easy to forget about updating a vehicle if the context shifts during development, particularly if that vehicle has shipped before.
We built the speeder bike for Star Wars Battlefront 1, and because it shipped in that game, we made the assumption that it wouldn't take too much more work for Star Wars Battlefront 2.
However, the new game's map topography, coupled with some tech debt, ended up meaning we had to rework it entirely for the sequel.
Vehicle and environment are complementary to each other, and changing one may require changing the other.
So for this next part of the talk, I'm going to use motorsport racing as a context.
Although my examples could apply to all racing games, let's think of this as somewhere on the Simcade part of the spectrum, such as Forza Horizon or Need for Speed.
There's an expectation from this context for realism, so we need our simulation to be based off of real physical effects and allow the player to play with grip and acceleration.
There needs to be enough depth to the simulation for each vehicle to accelerate and turn differently, so our simulation needs to be detailed enough to support this accurately.
There's an added benefit that if we use a realistic physical simulation, we should be able to use real-world tuning data, such as engine or tyre metrics, as a starting point for tuning our vehicles.
Let's start with a trivially simple model in order to illustrate why detailed physics models are needed.
This is so basic that very few gains would be served well by this physical model.
It uses a simple frictionless rigid body with a single force and torque applied at the centre of mass to move it.
The result is vehicle motion that is flat, unrealistic, and not enjoyable or interesting to drive.
It's very abstract in the way the forces are simulated, so we should take some inspiration from real world vehicles in order to improve it.
In the following slides, I'm going to go through how a more complex physical simulation could improve the physicality of our vehicle.
I'll start by looking at a list of real world systems from motorsport vehicles, and then I'll pick a couple of those to go into in more depth.
We'll look at the powertrain, and also tyre friction.
Finally, I'll conclude this section with some footage from Need for Speed Most Wanted in order to show off physicality in a shipped game.
So here are a handful of real world systems that we might want to simulate to add more physicality in play to our vehicle.
This is an exhaustive list, but it should give you an idea of the sort of physical effects you might want to consider.
In the following slides I'm going to go through engine, transmission and tyre friction.
The engine and transmission are key parts of the powertrain, so I'm going to refer to them collectively as a powertrain system.
Let's look at an element that we would like for our complex physical model, the powertrain.
The purpose of the powertrain is to transmit energy from the engine into the wheels.
In this case, the engine provides energy to the clutch, which passes it through to the transmission and then to the differential and wheels.
At first glance, you might think that we could just tell the wheels to start turning at a set speed and we get the same result.
However, the powertrain has an important quality.
It is a feedback loop.
The engine provides torque to the wheels, however the wheels will resist movement.
Not just because the wheel itself has inertia, but because the wheel is in contact with the ground and needs to overcome the inertia of the whole vehicle before it starts to rotate at an optimal speed.
so we get resistance feedback through the whole powertrain.
This means that some of the energy is used to overcome this inertia, affecting the amount of energy that is actually used to drive the vehicle forward.
So if we decide to model these parts of a car, we should look into each piece and see what we might want to put into our simulation.
For example, your engine simulation could need authorable torque at different operating RPM, as well as the inertia of the engine itself, and supporting that feedback mechanism that we just talked about.
Your clutch might want different operating efficiencies at different RPM.
Your transmission could simulate numerous different gear setups and how long it takes to change between them.
Finally, your tires should apply force in a realistic manner via tire friction, which I'll go into later.
So we've gone away and implemented an improved powertrain.
So let's look at what that actually gets us.
Let's compare the simple model with the new complex powertrain version using speed-over-time graphs.
On the left, we have the simple model which has a very uniform acceleration profile.
Comparing that to the more complex powertrain, we overall see a more curved acceleration profile indicating that we get more acceleration at the beginning of takeoff than we do when we're nearing top speed.
You'll also note that there are small bumps in the graph which represent the gear changes.
Due to the simulation of the transmission, we have multiple gears that are more effective at providing acceleration at the lower of their working speed range and then starts to tail off as the vehicle's speed approaches the next gear's working range.
Even just looking at a vehicle driving in a straight line, this simulation has added much more complexity and interesting physicality than the simple model.
Next up, let's have a look at another system, tyre friction.
So looking at this diagram, we have the wheel hub with hubcap for illustration in the centre and the rubber tyre around the outside.
The section at the bottom of the tyre is slightly flattened under the load of the vehicle and is called the contact patch.
The blue lines represent the tread and wall of the tyre and will show how it deforms as the wheel moves forward.
The green dot is a specific point on the wheel hub, and the red point is the corresponding point where the tyre touches the ground via the contact patch.
Now as the wheel hub rotates clockwise, if we look at the green point on the hub, it's moved a small amount.
This means that the wall and tread of the tyre stretches between the green and red points.
The elastic force of the rubber tyre now tries to spring back into its rest position, moving the red point on the tyre surface towards the left, even though it remains in contact with the ground.
This applies an equal force back onto the wheel hub, which pushes the whole vehicle forward slightly.
This happens continually until the vehicle is travelling in a speed which matches the rotational velocity of the tyre.
Now that we understand the physical behaviour we're trying to simulate, we need a simulation model.
The dynamics of how much force is applied under what conditions is incredibly complex, and there are many models that can be used to simulate it.
In this case I'm going to use the Pacheco model.
In the Pacheco model, the formula takes the rotation speed of the wheel and relative velocity of the road.
The slip angle is the angle between the direction of the ground velocity and the direction of the wheel hub.
The Pacheco formula produces two forces.
The longitudinal force, which drives the vehicle forward, and the lateral force, which turns the vehicle.
During acceleration, the road speed is lower than the wheel speed, so we get longitudinal slip, which maps to a particular force in this graph.
The right-hand side is when the vehicle is accelerating, and the left-hand side is when it's braking.
This red graph is the lateral force applied under a particular slip angle, so represents the turning force applied during cornering.
What's interesting about these graphs is that each of them has a peak, which is where the most effective acceleration or cornering behaviour is found.
This is what gives us the effect of playing with the limits of grip.
This means that the player has to try and hit these peaks in order to be as effective as possible during a race.
This adds a lot of depth and mastery, but let's look at what this actually results in.
So let's have a look at how the physical simulation ends up looking in the final game.
Pay close attention to the way the chassis of the vehicle rocks back and forth during gear changes due to the simulation of the drivetrain.
Watch how the body rolls to the side during corners due to the simulation of tyre friction and suspension.
The depth of the simulation shows through and gives the player precise control and physical play to master.
So, now that we have our physical simulation sorted, and we've got an accurate, deep simulation of the desired vehicle, we should look at input and assists in order to give the game the feel we want and get the balance between arcade and simulation that we're aiming for.
In this section, I'm going to talk through drifting, which in case you didn't know, is where we force the rear wheels of a tyre to brake traction so the vehicle drifts sideways in order to maintain momentum whilst in a turn.
Drifting is something that is possible but tricky to achieve in real life, so in Criterion games we apply several assists to help players achieve a long, satisfying drift.
So I'll use that as an example in the following slides.
Let's start by thinking about the input layer.
This is effectively the control mapping and any modifications you might do to those control inputs.
These control inputs are then sent across to the simulation where it turns the wheels or drives the engine in the simulation.
However, the important point to take away here is that you have assists that might work on either side.
For example, the input layer level assist might be to detect a particular button combo to trigger drift mode, and a simulation level assist might be to apply increased physical damping whilst in this drift mode.
So we know where we might put our assists, but what do we want to achieve by adding some?
Once you've got your input layer communicating with the simulation, you'll have something playable and you can then review it and see what needs to change.
You might find that the input complexity is too high and you might want to reduce it.
It could also be to reduce the simulation feel and move towards more of the arcade side of the spectrum.
You might want to take existing forces or effects in the simulation and emphasize them, such as making drifts last longer.
A detailed simulation can also bring unwanted side effects, such as extreme slowdown on uneven terrain, or even collision hitching.
This might be something you want to target with assists.
It could also be something which conveys the game state back to the player in a more intuitive or obvious manner so that the learning curve is easier.
Even though most of these examples are for your intended default experience, you could also use assists as accessibility options to make your game playable by a wider range of players.
Now that we've decided what we want to achieve through our assists, let's look at some of the different types.
I've divided assists up into five categories.
Player Intention, Driver, Physical, Real World, and Feedback Assists.
I'm going to talk through each of these in the next few slides.
These aren't hard templates, but more a thought exercise that might help you think what parts of the game to target.
When we were building the drift mechanics in Need for Speed, we took our simulation, which had realistic drifting behaviour, and used assists to make it more stable, easier to sustain, and maintain more of your speed than in real life.
To get this to feel great, we use multiple types of assists to achieve this, and I'll use drifting as an example when talking through these categories.
The first type of assist is the player intention assist.
This is an assist at the input level which looks at the player's input and tries to work out whether the player's intention is different from the normal mapping.
It can look at the current simulation to provide context for what the player's intention might be.
An example is using a brake tap to enter drift.
If you're driving straight ahead and tap the brake, then you probably want to slow down.
If you're turning heavily when you tap the brake, you probably want to enter drift in order to turn more aggressively.
Next up is the notion of driver assist, which can simulate the experience and muscle memory of a professional driver.
An example of how this is used in drifts is in balancing your torque.
When you're drifting in a real car, the tires are trying to twist themselves to match the direction the vehicle is drifting, and the driver is able to feel this through the steering wheel and adjust accordingly to extend the drift.
On a console pad, the analog stick doesn't really lend itself to this, so we emulate this behavior by re-centering the steering input so that zero input equates to keep drifting at this angle rather than meaning straighten up the wheels.
This is absolutely key for a controllable drift and gives the player the level of control an Ace driver could achieve.
We also apply physical assists, which are forces that we apply directly to the vehicle's physics simulation.
We take existing qualities of the simulation that we want to feel hyper-real and emphasize what's there.
We want to look at the forces applied by the simulation that are hindering the effect we want and counteract them.
For example, if you're in a deep drift, a component of the tyre friction is opposing motion and slowing the vehicle down.
We want our drifts to maintain speed around corners, so we calculate the magnitude of the frictional force slowing us down and reapply that force in the direction of the vehicle's velocity in order to minimize the speed loss, or allow our designers to tune how much speed loss they desire.
Real-world assists are where we might simulate part of a vehicle which is available in real life, and we can manipulate it to achieve the desired effect.
For example, we might want an anti-lock braking system to allow players to brake effectively without having to carefully tap the triggers.
When we start drifting, we can turn off ABS to allow the back wheels to spin and lose traction, entering the drift quickly.
When we detect that the player is trying to exit the drift, we can then turn ABS back on in order to allow fast acceleration out of the drift.
Finally, we've got feedback assists, which don't actually affect the handling, but are assists which help the player understand the simulation better and show UI to help guide the player.
Wherever possible, we feedback the simulation from real-world sources like the strain of the engine or the squeal of the tyres, but feedback assists are specifically things you wouldn't see in real life.
An example of this is the Forza braking line, which looks at the upcoming turn and highlights the line red if your tyres are going to lose traction and you want to slow down.
Seeing as assists can influence both the controls and the physical simulation, getting the feel of them right is just as important as tuning your physical simulation itself.
Depending on how you engineer and tune them, you could end up disguising all that great simulation work, so here are a few tips to bring out the physicality when writing assists.
Firstly, try to tune them to be as subtle as possible while still achieving the desired effect.
It's often easy to have very strong stabilisation forces which help the player effectively, but wipe over all your great simulation work.
Rather than switching your behaviour on or off based on a binary condition, try to fade them in or out over some parameter, even if that parameter is time.
This means that it is less obvious to the player that they're being assisted and adds some nuance to it.
Think about where the optimal assist strength is and allow the player to gradually learn how to find the perfect balance, giving it depth and mastery.
The game should feed this back to the player in order to allow them to tell if they're doing better or not.
Also, as a programmer, try to make sure you add in plenty of helpful debug visualizations in order to help your designers understand the systems by being able to see what physical effect their parameter changes have and tune them as well as they possibly can.
If possible, set up auto tests for your vehicles and their expected top speeds, accelerations, etc. as this can help catch unexpected changes or your physical effects affecting vehicle performance.
We had an issue on Most Wanted where a vehicle artist adjusted the size of a wheel and this affected the top speed of the vehicle, but thankfully this was caught by an auto test and fixed quickly.
So, we've got our physics and our assists working nicely together.
Now we need to feed this back to the player effectively through camera behavior.
I wanted to start this section off with a phrase that we use a criterion a lot, camera is handling.
It doesn't matter how great your simulation and assists are if your camera doesn't feed it back to the player well.
A stiff or loose camera can massively change the feel of a vehicle, so should be considered part of the handling.
We have the same designers that tune the handling parameters on a vehicle also tune the camera parameters because they are so intrinsically linked.
There are two fundamentally different approaches you can take when starting to think about vehicle cameras.
One is a camera-led system where the player input turns the camera, and then there's a layer that interprets the camera direction and passes that through to the vehicle controls.
Alternatively, a vehicle-led system is where the player input controls the vehicle directly, and then the camera follows the vehicle as a separate system.
Camera-led systems usually match the shooter input paradigm with aim and pitch on the right stick.
Generally it allows the player to point the camera accurately at something, but at the loss of handling feel and precision.
This can be good for games where the primary vehicle gameplay is aiming and shooting a weapon, and the driving component is secondary.
An example of this type of camera is the Mk5 tank in Battlefield 1.
This video shows me rotating the camera separately to the vehicle using the right stick, then holding the left stick forward in order to move towards where the camera is pointing.
There's an intelligent layer that decides how to move the tracks of the tank in order to make it point towards the camera, rather than direct control.
One problem with a layer like this is that it can add some ambiguity, which means you can get some unexpected motion, particularly when trying to reverse a vehicle with camera-led handling.
Vehicle-led camera are usually the default option for racing games and usually match a driving input paradigm, where steering is on the left stick and the camera follows the vehicle's motion.
This gives a more direct control feel and can allow greater driving precision and camera feedback but makes it harder for the player to quickly move the camera to look behind them.
These types of cameras are often accompanied by a look behind camera button in order to compensate for this.
Here's an example of one of the transport vehicles that Criterion worked on for Battlefield 1, the Armoured Car, which we decided should use a vehicle-led camera for best game feel.
At Criterion we almost always use vehicle-led cameras due to the precise handling feel we require from our games.
I'm going to continue this section by looking at vehicle-led cameras in more detail.
So a good camera should feedback important game state to the player, such as camera angle while drifting.
It will respond to player needs, ensuring that the camera is focused on what the player needs to see and doesn't obstruct line of sight.
The camera should sell physicality by using the physical simulation to complement the motion of the vehicle.
So let's look at a rigid camera, which is locked behind the vehicle and points directly down the front of the vehicle.
This is a camera with no behaviour and this is the simplest possible starting point.
The vehicle's position is effectively locked on screen, which means that any of the physicality from the simulation is shown through the background of the scene rolling and pitching as the vehicle drives, which can be quite disorientating and makes it difficult to focus on game objectives.
To improve this, we should start by conveying the motion of the vehicle by moving it in relation to the frame of the screen.
If the vehicle is in a deep right turn, we'd expect that the camera would lag behind slightly and the vehicle would shift to the left of the screen.
In order to achieve this, we use a sprung camera system, whereby we set a target point for the camera to tend towards, but allow some motion in all directions, with a force pulling the camera to the target position, proportionally to how far away it is from the target.
We can tune this per axis to allow for certain behaviours to convey differently on screen.
For example, we might want lots of sideways motion when turning, but less forward and backward motion when accelerating and decelerating.
In conjunction with pulling the camera towards a target, we also point the camera at the look-ahead target, which is fixed in front of the vehicle and shows the player where the vehicle is heading.
It's also sometimes worth considering using velocity extrapolation on your look-ahead target in order to make your camera look into turns and keep the player's focus near the centre of the screen when turning.
Let's take a look at what that looks like.
So note throughout all these videos, the physical simulation and handling are identical.
All we're changing is the camera.
So, as you can see, the vehicle is much more dynamic on screen.
You can actually see the sides of it, as well as the motion of the vehicle when travelling over bumpy terrain.
There are three key parameters we use when tuning this type of camera.
The most important one is convergence, which is how far we move the camera towards the target each sim frame.
The higher the value, the tighter the camera is to the back of the vehicle.
Then we have momentum, which accelerates the camera in the direction it's already traveling, and damping, which is used to stop the camera overshooting the target and resulting in oscillations.
In order to demonstrate the different types of feel that different convergence parameters can get you, here's an example of strong convergence.
Notice that it's very similar to the rigid camera example.
The vehicle isn't moving too much on screen, it doesn't feel very physical.
Switching to a weak convergence, we see a lot more motion in the frame.
The vehicle feels dynamic and alive.
However, because the convergence is so weak, the vehicle appears to be pointing off screen during large turns.
This can make it tricky to control as you can't see where you're going.
In this situation, we could either tighten up the camera or add velocity extrapolation to our look ahead target so that the camera looks towards the vehicle's direction more effectively.
The camera also needs to sell the physicality of the vehicle and feedback what the simulation is doing.
A good example of this is the landing camera, when the vehicle comes off a large jump and then hits the ground so hard that the suspension bottoms out.
We wanted to convey this with a large camera movement that doesn't obscure the road ahead for long, but still sells that impact.
We use some camera shake when we land.
Plus, this is a good example of how momentum and damping forces affect the camera to give it an exaggerated behavior when landing.
So if we don't do anything special to the camera, the Sprung camera still gives you some feedback.
This isn't too bad and you could probably ship this, but let's go the extra mile and try and improve it.
Let's add some camera shake on landing, when we detect that all four wheels are on the ground after travelling downwards quickly.
This camera shake that I'm about to show you is 30Hz in oscillation in pitch and roll for 0.5 seconds.
This helps a little bit, but we can do better.
Let's reduce the damping on our sprung camera so that the momentum term carries it further downwards than the target, giving us a much better sense of the impact.
This should make our impact much more impressive, exciting and physical.
So, how does our Battlefield 1 work stack up to the camera requirements we set ourselves earlier?
Well, we feed the simulation back to the player by using the camera convergence to affect the vehicle's position on screen, allowing the player to tell the turning radius of the vehicle.
The camera responds to player needs by looking into turns, letting the player see where they're going.
We sell physicality by giving special attention to the landing camera, making the vehicle feel extra heavy and solid.
Here's another look at the armored car, illustrating all those previous points, but also gives you a chance to hear the audio treatment and see the VFX, which adds even more on top of our handling work.
So, in this final section, I'm going to show how we applied these principles when making Starfighters in Star Wars Battlefront II.
When we started looking at what we could bring to Star Wars Battlefront II, we decided on the overall direction of wanting players to feel like an ace pilot, and give them that fantasy when controlling the Starfighters.
After playing some Battlefront I, we felt like we could help improve the handling significantly, and we wanted this to go alongside a game mode that was much larger scale than in that game.
This is the original fighter squadron mode from Battlefront 1, where players fought in X-Wings and TIE fighters above the surface of planets.
The main shooting mechanic here was to hold left trigger to lock onto anything within a wide cone in the middle of the screen and right trigger to fire.
Shots would then be auto-aimed as long as you had a lock-on.
You may also be able to tell from this video that Battlefront 1 used a camera-led handling model, where the camera moves first and then the vehicle catches up.
So when we started to look at how we could improve over Battlefront 1, we looked at player feedback. Players really enjoyed getting to play out their Star Wars fantasies, plus the gameplay was very accessible to a wide audience. However, there was a general feeling of lack of depth around the auto-aim shooting, that it was difficult to control and the starfighters felt too much like toys on a string, or when players really wanted manual roll control.
So we took each of those points and made sure we focused on fixing them, with aiming closer to that of a shooter, handling that felt precise, and a camera that showed off the physicality of the vehicles.
And of course, roll control.
This was a great chance for us to apply the vehicle design philosophy when designing our Starfighters.
Here's some gameplay of what we ended up with on Battlefront II's Starfighter Assault Mode.
The cruisers are down. Scanning for additional defences.
So as for reviews, we got a lot of good responses around the Starfighter work we did, with critics highlighting the handling and shooting being a huge improvement over the first game.
So now we know how it turned out, let's see how we used each section of the vehicle design philosophy during development.
When looking at our balance between arcade and simulation, we looked at our target market which consisted of both fans who were casual gamers and wanted an accessible experience, but also hardcore players who expected something more like a flight sim to live out their pilot fantasies.
We ended up deciding to balance this by having intuitive pitch-in-your-controls like you might find in an arcade-style game that give players full role control and allow players to execute their own invasive manoeuvres rather than having them triggered as cutscenes on the D-pad like in Battlefront 1.
We also decided to go with a shooter input paradigm with flight and aiming on the right stick as it would be more intuitive to players coming from a shooter background and also match the rest of the game.
However, we know that anyone expecting a flight sim style control setup would find this quite jarring so we made sure there was an option to remap the analog sticks fully.
When thinking about how we were going to simulate our starfighters, we looked at the real-world analogue of fighter planes, which were the original inspiration for Star Wars' dogfighting scenes, which is why in Star Wars, X-Wings bank into turns like planes, and crashing Star Destroyers fall downwards.
Thinking of fighter planes, we looked at airfoils, which is a thing that keeps planes in the air, but also gives secondary effects such as altitude loss when turning.
We decided this didn't really match with what we expected from a starfighter, so we went with a simple anti-grav simulation instead.
We did however one that banked turns from a fighter plane, so we simulated this with a horizon steering setup where the controls remain locked to the horizon, but the starfighter banks on screen.
We used a simple engine thrust force instead of a more complex prop or jet engine, as we didn't feel like we really needed the play of airflow in space where there isn't any air.
When in a heavy turn, the aerodynamic drag of a plane can affect how aggressively it can turn.
We ended up doing something similar with an air brake that allowed experienced players to pull the air brake when turning to get a temporarily reduced turn radius.
Even though there's no physical justification for it, it ended up feeling right, and it was something that we investigated in a prototype and playtested it until we were convinced we wanted it in production.
In order to get the feeling of bank turns, we used horizon steering, which is quite a simple concept, where we have two separate frames which represent an orientation.
In practice, this could be a matrix or a quaternion.
The control frame stays flat when the player yaws, which means that it points in the direction of flight, following the pitch of the starfighter, but allows the yaw of the ship to be expressed in the direction it appears to the player on screen.
When the player turns left and right on the stick, the control frame stays flat against the horizon, but the vehicle's body frame is rolled into the turn, giving the feeling of banked turns we wanted.
Looking at the video on the right, you can see the Starfighter banking, but the camera is staying flat, allowing the player to intuitively control the fighter's direction.
If the Starfighter was pitched up, then the Starfighter would rotate on this newly oriented horizon, so if we were pointing directly upwards and started turning left or right, we would end up pointing downwards in the local pitch horizon, rather than fading to the world's horizon.
So let's move on to the camera.
Initially, we wanted to work out whether we should use a camera-led or vehicle-led system.
We initially thought that a camera-led system would allow for the precise aiming that we wanted.
However, this was the system that Battlefront 1 used, and that didn't have the sort of precision that we'd hoped for.
Using a vehicle-led camera instead would allow us greater flight precision, which was one of our initial goals, and improved physicality.
For that reason, we opted for a vehicle-led camera, which is a sprung camera, in a similar style to what we did on Battlefield 1.
So thinking about the approaches we learn about in the camera section, we've got a vehicle-led camera that looks into the direction of travel and allows the Starfighter to move significantly but predictably on screen.
One problem we encountered while authoring Camera Shake on Battlefront 2 was that it was really hard to aim while the camera was shaking.
This seems pretty obvious because you're aiming down the camera, so of course shaking it makes things harder.
However, we wanted to try and find a way to convey the same camera shake feeling whilst maintaining aim precision.
Conventional camera shake works by rotating the camera around its centre point, pitch you're rolling by X degrees, which means that if your focus point is in the distance, it moves a lot on screen.
To combat this, we rode an orbit camera shake system, which would shake the camera by moving it laterally as well as rotating it, keeping the camera pointed at a particular point far away towards the horizon.
This meant that things in the foreground, such as the vehicle, would move around on screen, but distant targets we were aiming at would remain stable.
In this video, keep an eye on the pillar in the distance.
Notice that the pillar, crosshair, and vehicle are all shaking around significantly.
When we move over to the orbit camera shake, only the vehicle is shaking, meaning that the player feels like they're being buffeted around but can still aim effectively.
It's easy to imagine blending these two effects together to allow our designers to tune just how much shake they want for near and far objects, but in our case we opted for distant aim stability due to our game's focus on shooting.
Seeing as we have a strong sense of up in our levels, we found that players would end up upside down quite frequently, even if they weren't using the roll control.
In order to help alleviate this, we added some auto-rolling, which would kick in when the sticks are centred.
The idea being that return to centre is a player intention to fly straight, so if that's always accompanied by rolling to the horizon, players won't find it too obtrusive.
It's also a smaller, more subtle force when you're almost level, again trying to be as unobtrusive as possible.
We also have a small 20 degree window when the starfighter is inverted where the auto-roll never kicks in.
This is to allow players to fly upside down when they intend to.
All other angles tend back to the horizon.
It's also worth mentioning that we anticipated more hardcore players of our audience would prefer to have total control over orientation, so we added a toggle to turn auto-roll off in the settings.
After getting the starfighters to handle quite nicely, we looked at shooting.
We found that it was incredibly hard to hit a moving target by pointing your ship towards another.
As an illustration, let's think about aiming towards this TIE Interceptor.
Firstly, our maximum targeting range was around 800m, which meant that ships could end up quite small on screen.
They were also travelling at up to 120m per second, and also the lasers in Star Wars have a travel time, so you need to lead your target.
These factors combined to make unassisted aiming incredibly difficult for our players, so we needed to add some assists.
One of the main assists we added was the auto-aim cone, which is a cone in front of the player which retargeted the gun barrels to fire the laser shots more towards the correct target position.
In theory, it's quite similar to the Battlefront 1 approach, except that we gradually fade the effect in and out rather than switching it on and off like in Battlefront 1.
In the case of this diagram, we've got the player aiming ahead of the target, and we have a predicted position of the target, which is the yellow dot, which is where the ship will be by the time a player's shot gets to it.
We show a reticle on screen of this position so the player knows where to aim.
This is a type of feedback assist because it's providing extra simulation data to the player via UI.
If this predicted position is inside the aim cone, then we shift the gun barrels towards this perfect predicted position.
However, we fade it gradually based on how far into the cone the predicted position is.
This means that if the player's aim is quite far from the target, they only get a little bit of help.
But as the crosshair gets closer and closer to the target reticle, they get more and more of an assist, until they're inside the reticle which guarantees a hit because it's fully assisted.
This makes the effect subtle enough that players don't notice the shots diverging from their crosshair, but they hit a lot more hits than they would otherwise.
It also gives a nice feedback loop of getting gradually more and more hits as your aim improves, rather than the old approach that was either hit or miss.
The aim cone helped a lot, but the feel of putting your crosshair onto the predictor reticle still felt quite fiddly.
Players were constantly overshooting, making a lot of correctional inputs.
The main reason for this is that the targets are constantly moving, so instead of the player trying to aim at a particular static point, they're actually targeting an ideal angular velocity as well as an orientation in order to keep up with the moving target.
We decided to reduce this complexity by introducing sticky targeting.
This was inspired by one of the aim assists seen in Destiny, where they pull the cursor along with the enemy when the enemy strafes left or right.
Effectively, we want to drag the cursor along with the target, and to do so, we take the linear velocity of the target in world space, and then transform it into the player's local space angular velocity.
This target angular velocity can then be mapped into the input layer.
We can effectively work out how close the player was to achieving this ideal input and then fade the value towards this ideal in a similar way to how we did it with the aim cone logic.
We use the aim cone to fade the effect in and out and we only apply the sticky targeting when the player has non-zero right stick input which means that we only help them aim when they're trying to aim.
This ended up working really well as we'll show in the next demonstration video.
In this first part, sticky targeting is off.
You can see that the player is making a lot of jerky correctional movements to try and aim at the enemy.
This is resulted in most kills only happening when the enemy is travelling in a straight line and makes for an easier target.
This next video shows the contrast when we turn sticky targeting up to maximum.
The aim point is super stable when locked onto a target, but the player will be able to feel the cursor is being dragged along with the target, as in this case where the cursor follows the target flight path exactly.
Then this last part shows the tuning we ended up shipping with, where the player has much reduced correctional input, but it's still subtle enough that the player doesn't notice that they're being assisted.
So, overall, we ended up with a hybrid vehicle-shooter experience that we're really proud of.
We used a simplified physical model, but with the control options for highly skilled players.
We used a vehicle-led camera to allow precise handling, and then layered on assists to help our shooting feel precise and satisfying.
So we're pretty much at the end of the presentation now, so I'll just summarize some of the key points we discussed today.
Games should balance simulation depth with arcade accessibility in order to achieve intuitive controls with challenge and mastery.
Build your vehicle for the context it's intended for, and retune if the context changes.
Think about how deep your simulation should go, look at real world vehicles for inspiration, and decide on what parts would add to the depth to the player experience.
Build assists to make the game more accessible.
Balance the amount and strength of the assists depending on how many game mechanics the player has to interact with, ensuring the input frequency isn't too high.
Consider camera-led and vehicle-led cameras.
Allow the physicality of the vehicle to be conveyed through the camera and give the player the feedback they need.
And that's it, thank you very much.
Any questions?
Hello, great talk, thank you very much.
Thanks.
I've been working on console vehicle systems for a very long time, but recently been asked to help out with PC.
I was wondering if you had any input or thoughts about digital inputs that are more prevalent on PC controls versus analog sticks and joysticks.
Yeah, so the question was thank you the question was about digital inputs versus analog inputs and console versus PC So there are a couple of a couple of big things there. So firstly if you're using Keyboard to input then you kind of you've only got on and off inputs So one of the things that we do for both console and PC is we have steer rates. So it's kind of Fading in and out our input in terms of you don't just turn to maximum input you kind of will fade in and out We use that for our console pad inputs, but we also use it for our PC input in terms of if you hold down A, then it will gradually fade towards that, which helps a little bit.
One of the things that we did for Star Wars Battlefront II is that we had A and D would control the roll.
And one of the things you can do on a pad is because you have an analog input, you can effectively balance the rolling against the auto-roll system.
So if the auto-roll system is trying to level you, then...
you can kind of balance it like quarter percent left input to kind of keep you locked to the particular angle which is totally impossible to do with just A and D.
So we had a separate kind of input mechanism on PC which is if you were holding down A and D at the same time then we use that new concept to say just lock wherever I am so you could kind of say A to here and then both of them to just lock in place. So we tried to come up with new mechanisms that would suit PC better than on pad.
Hi, with Simcade Racing Games that you were talking about, how do you approach handling and assist when you're tuning vehicles to be understeery versus oversteery?
Okay, so thank you.
The question was about understeer versus oversteer.
I think it depends on what you're trying to get out of your key experience.
So in terms of if you want your vehicle to feel quite heavy, it's often nice to have a slightly understeery vehicle where you'll kind of...
even if you're steering at maximum, you might not be able to make that corner, and then you encourage your players to brake, turn into the corner, drift around.
So I think a lot of most wanted handling was a little bit understeery, but then it encourages you to really kick the back out and get into a nice big drift.
Whereas if you want...
If you don't really want your game to be about drifting and you want it to be very much like a little bit more along the lines of like F-Zero or something, where it's pretty much I want complete control over the left stick and I don't need to be drifting at all, it's just maximum responsiveness, then you'd probably have something that's way more oversteering and is going to kick into turns really aggressively so you have full control over there.
That's kind of how I do it.
In the demo, when you had the landing camera, it would bottom out and hit the ground on the landing.
Was it colliding elastically with the ground, or was it just zeroing out its velocity and then the spring force was putting it back?
So the question was about suspension bottoming out.
So we have, on Battlefield 1, we had four regular sort of Raycast suspension wheels, and then we had a rigid body as well.
So...
When you completely bottom out, we detect when it goes above a certain threshold in the suspension, like it's more than 80% compressed, and we'd count that as being bottoming out.
Oftentimes we'd find that the...
the actual rigid body would collide and we'd need to try and smooth it as much as possible.
Sometimes you get a little bit of collision hitching but in general we want to try and keep that maximum 20% of the suspension very, very rigid in terms of the suspension force that it applies back.
you still get the effect of you've pretty much bottomed out the suspension, but you still remain in that 20% to try and keep it floating off the ground effectively, stopping the rigid body from actually colliding.
So yes, we did get some collision hitching and hitting the ground, but we tried to minimize it through a very small amount of very, very strong suspension at the top of the suspension ray cast.
Does the camera itself hit the ground?
So it's not.
So technically, with the stuff that I showed in the presentation, it's possible for you to tune the camera so that it would like lurch below.
So the momentum would keep it going.
So it would keep going down.
So if you had a massive momentum term, it could potentially go all the way down below the ground.
However, even if you did tune it like that, we have another separate system, which is a capsule collision system that basically says, hey, if you're going to collide with the ground, kind of push yourself out and resolve it in a way that won't actually go through the terrain.
So we have another system on top of that to protect against those sorts of issues.
For the auto-aim systems you talked about on the Starfighters, did you do anything different for projectile convergence on something like the X-Wing versus the TIE Fighter where the projectiles are spawning from different points and colliding, basically coming from different angles?
The TIE Fighters are very straightforward, the X-Wings are coming from the outer wings.
Yeah, really good question.
So this is about, you're not actually shooting from where you think you're shooting from, you're shooting from, you know, like gun barrels at the edges of the wings, it's more complex than just being far away from the center of the vehicle.
It's also far away from the center of the camera.
So one of the most difficult vehicles for this was Slave 1, which is like a massive vehicle and the gun barrels are right at the bottom and we needed the camera to be up here.
So if you've got the camera way up here and the gun barrels down here, you'd be trying to aim along where the camera's looking, and the camera, the gun barrels would effectively be pointing up.
So what we found was there was this really weird behaviour where if you were trying to aim at something that was quite close, your gun barrels would be pointing, like, up 40 degrees or something.
So you'd be like, I want to fire here, but then all your missed shots are actually going up in the screen and it looks really weird.
And that's actually a very difficult problem to solve because...
You either say, I want to shoot down the camera center, or I want to shoot accurately from where the gun barrels actually are.
So what we did was we did some, we kind of fudged it a little bit by looking at what your target is in terms of, I'm shooting towards this guy over here, so I'm going to try and fade it so that my shots will...
will always hit him and try and make it so that if he's really, really close to me in terms of like if he's right up in the camera and the vertical deviation from where the gun barrel is actually pointing would be very aggressive and would give me that effect of shots going off into the sky, then limit it to a particular set angle.
Alright, and did you also have to account, were you using that in combination with the prediction points so that if the player was trying to aim in front of a moving, a target that's moving laterally, that it would have to predict in front of them where the shots could converge to?
Yeah, so we did all of our calculations based on the predicted position.
So we know where you're trying to aim, and we would aim towards that point, so we'd use that to fade in and out.
Just one more, actually sort of a comment and suggestion for people if you're working on racing games or vehicle dynamic systems, I'm not sure about the UK, but in the United States we have a sport called autocross that people do in parking lots and you set up cone tracks and stuff.
I would encourage you to take a look and see if there's that sort of an activity in whatever city you live in, because driving a real vehicle at the edge, you develop a different intuition for the way a lot of these systems work.
And the vehicle dynamics programmer that I worked with, he and I would go out on weekends and participate in championships and stuff, and it was great fun, but it also really gave us a better, you know...
fundamental just intuition and understanding of the way the vehicles work when they're really at the edge of the performance envelope which most people never experience. I mean even if you're go-karting or you're doing other stuff there's different you know ways of weight transfer and when you actually lose control what happens when you spin out and those sorts of things. So just suggesting if people are working on those systems see if there's like a SCCA or Porsche Club or BMW Club or anything in your area and you know participate in those sorts of things.
Yeah, definitely.
Like, actually getting real experience with vehicles is super valuable.
I think whenever we were trying to do a new type of vehicle, we would try and actually go and drive something similar.
Unfortunately, we can't get World War I vehicles, so we couldn't actually drive any of those.
But it's super valuable, and also it works the other way around as well.
I found that playing a load of racing games throughout my life made me really good at go-karting.
I mean, not that good, but, you know, quite good.
For the thing you were talking about a moment ago with the shooting the guns from not from the camera.
Yes.
Did you do anything to handle where there is an object between the gun and the target, but that same object is not between the camera and the target?
So we didn't do too much, sorry, this was about if there's an object between the gun and where the target actually is, so it's kind of obstructing.
We didn't do too much of that, mainly because our situation, like...
The situation of the game is mainly aiming at a starfighter which is over here, and I'm kind of going through a tunnel maybe is the most geometry we tend to get in between things.
We didn't find that players had that a lot in Battlefront 2.
I'd say if you were doing a first person shooter then obviously you can just position the gun right up against the wall and you get that situation a lot.
In which case...
I think you'd probably use something along the lines of doing raycasts from the gun and being like, well, if that's obstructed, then fire the bullet here instead of where I think it should go from the camera's point of view and decide which is most applicable.
Thanks.
Cool.
If there's any more questions or anyone wants to catch up afterwards, grab a business card or something fun, then come and grab me afterwards.
Thank you very much.
