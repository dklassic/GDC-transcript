Hello everybody. Thank you for coming. My name is Dan Moskowitz. I'm the lead gameplay engineer on the new SimCity and I was also the lead engineer on the editors for Spore.
I've been working at Maxis for over seven years. I was originally drawn there by Will Wright's 2005 GDC video where they showed the prototype of Spore and I just thought anyone that, any team that's willing to make something that crazy, that's the place I want to work.
So Maxis is this wonderful place.
It's filled with a lot of brilliant people.
And I've learned a lot during my time there.
And one of the things that I've learned most of all, and that's what I'm here to share with you today, is a particular philosophy about game development.
It's a philosophy based on building simple systems and then discovering the fun that's inside.
So let's get started here.
Oh, hold on a sec.
Let me just get online.
This will just take a second.
Oh, you know what?
So let me just wait a couple minutes, and then I'll try again.
OK.
All right, so what can you do but laugh, right?
As you all know, our game had a really rocky launch, filled with server and connection issues.
And while most of my contribution to the game happens after the login screen and after the front end, as a member of the team, I apologize to anyone here that experienced frustration.
I know it was really frustrating for a lot of people.
And as fellow game developers, I hope you can understand that the first few weeks after launch were like an emotional roller coaster for the team.
We created this game which people really loved and were attached to and then were frustrated by the inability to log in and play.
And for those of you in the audience with rotten tomatoes or anyone that wants to talk about offline or online only requirements, I would happily direct you to our PR guy over there.
So I'm not here to talk about that.
But what I am here to talk about is sandbox games.
So this is the kind of game that SimCity, the category of game that SimCity falls into.
And I looked around for existing definitions of a sandbox game.
And a lot of them referred to an open world specifically, or made reference to a game character.
So here's a definition that I came up with.
I would define it as a goal-free exploration game where the fun is derived from discovering how the game mechanics work.
And I like this definition because you can literally apply it to sandboxes, you know, like plastic shuttles and buckets and sand and gravity.
It's no wonder we have one of these in every single playground across the world.
When you're a little kid and you're just learning the mechanics of the world, it's this perfect place to try scooping and digging and smashing and building.
And when you're discovering these mechanics and you're building these pathways inside your brain.
and you're building up a mental model of how the world works.
And it's really fun.
And I believe that sandbox computer games give you that same experience of wonder and discovery, but with completely new and novel mechanics that aren't possible in the real world.
So here's four examples of sandbox games.
SimCity 2000, Minecraft, Bad Piggies, which my three-year-old kid is crazy about the sandbox mode in there, and World of Goo.
And each of these is built on top of some novel mechanic, like map-based simulation, or springs, or physics construction sets.
And some of them do have goals built in, but all of them are built around the idea that the fun is about letting the player experiment.
By trial and error, you slowly build up a mental model of the underlying systems that make up the game.
And the fun for a lot of players is to get to a point where.
their mental model of the game is strong enough so that they can run a little simulation of the game in their own head, and then predict the outcomes of their actions.
The other important property of many sandbox games is that they're composed from simple parts.
So these small pieces are the building blocks of the game, and each one's encoded with some relatively simple behavior or some relationship to the other pieces.
But when the player can freely assemble them together, and play with them in a game world that contains this novel mechanic, that's where the magic happens and where you discover these incredibly rich and sometimes surprising behaviors.
So to me, this is what's exciting about game development.
And as a programmer, the process of creating the rules of a new universe and populating it with some simple pieces and then discovering what they all do when they're mixed together, that's fun and that's where I find enjoyment in my work.
So if you're building a sandbox game, you need a novel mechanic to start playing around with.
And as far as this talk goes, I can't really help you come up with that.
That's up to you.
That's the defining characteristic of your game, but the key is to start with something simple.
For example, World of Goo started as a one-week student prototype with nothing but the word springs to inspire it.
And there's plenty of examples of interesting mechanics that spawn from game jams, physics, shadows, the fourth dimension.
The important thing is that there's just enough richness.
to the mechanic that it creates a big enough possibility space where you can start exploring.
And once you've got something that you can play around with, then you're in a position where you can experiment and start discovering the gameplay inside, or like squeezing the most juice out of it.
And Maxis has a history of creating these kind of games, so today I'm going to talk about some of the things that I've learned about making sandbox games over the past few years, with plenty of examples from the new SimCity.
And my hope is that...
I present this information in a way that's useful to you, so that you can come away with some practical advice that relates to your current game development challenges.
But first, I'd like to talk about our novel mechanic.
And that's the one we used to create SimCity.
And it's a bit more complicated.
It's a simulation engine called Glassbox.
Glassbox was developed by longtime Maxis veteran Andrew Wilmot.
And it allows developers to quickly create completely data-driven simulations with thousands of objects interacting.
It also has a nice architecture for gameplay engineers to plug in code, to control the movement of agents, or to drive graphics based on the simulation, or to add hooks for scripters to send events to the UI and to the code.
It's also fast in that it's capable of handling thousands of objects, or units, and tens of thousands of agents.
And now this talk isn't specifically about Glassbox, but it's about how we used Glassbox as our novel mechanic to create SimCity.
But in order to give you some context for some of the things I want to talk about, I'm going to give you a quick crash course in Glassbox and some of the terminology around it.
And if you're interested in more information, there's a much more in-depth deck about Glassbox that's on Andrew's website from our GDC talk last year.
Okay, so Glassbox is a resource-based simulation engine.
Resources are the basic currency of the game, so they're essentially variables.
They're defined as integer values with a fixed capacity, and they can be stored inside various simulation objects, like units, or agents, or maps, which I'll talk about in a second.
They can be tangible things like people, or coal, or parked cars, but they can also be intangible things like money, or pollution, or electricity.
So, units are the basic building block of a simulation.
So, in SimCity, they tended to be just buildings, but they could be anything, depending on what you're building.
And for example, some of the disasters in SimCity, like the tornado was actually a unit that moved around and ran a simulation.
They use rules to change their simulation state, so that's what our scripters are actually authoring, a bunch of rules.
And their state is defined by the resources that they contain.
So, for example, here's some examples of three units.
We've got a house that has some people and some cars, and then a water tower that's got 75% water, and then an oil power plant that's filled with oil and has some workers in it.
So maps represent resources in the environment.
So things like forest or pollution, they're just essentially a grid of integer values.
So for SimCity, that was our grid size, but it's totally variable.
Here's just an example of what a map might look like.
So the water table from in-game, we were using the map value there to tint the terrain so you could see where water is in the game world.
This is just a quick video of using one of our debug tools to paint ground pollution into the ground.
So you can see the ground pollution going up and then the texture underneath there is reflecting the state.
Texture on the terrain is reflecting the state there.
We can also use maps to distribute various effects like the location of forests or puffs of air pollution.
Here's a picture of a forest of trees that's being distributed by the underlying forest map.
So rules are the verbs of the simulation.
They allow for scriptable simulation behavior.
And if I had to compare the rules scripting language to something else, I'd say it's most like an assembly language where you're simply moving information from one register to the next.
It's a declarative language, so there's no looping, but there's certain ways you can chain and branch rules together so that the scripters can create simple logic.
And each rule is an atomic operation, meaning that When a rule is tested, all the statements in the rule must be able to succeed for the rule to be run.
I'll show you an example of that.
Today I'm just going to focus on unit rules, but all sorts of different entities in Glassbox can run rules.
So here's a simple rule. This is an example rule from our smelting factory in-game.
This is one of the things that the players can put down, and it converts ore and changes it into alloy.
If we look at this example rule, it's tested at a rate of every two SIM ticks.
And it applies one time and it takes 10 local or in, which means to subtract it from the local or resource, and then it produces 15 alloy.
So if the unit has less than 10 or, the rule won't run, or if the unit doesn't have enough room in the alloy resource bin to produce 15 alloy, it also won't run.
So this is the most basic kind of rule.
It just does a simple resource conversion at a constant rate.
If we wanted to get slightly fancier, we could add a line that writes out 100 pollution to the air pollution map and also trigger a success event which can send a message to the game triggering a pollution effect and you can see it coming out of the smokestack there.
From a different angle, here's like a debug representation of that map and it's writing out air pollution to the nearby cells on the air pollution map.
Getting even more fancy, you can add a fail event which can send an alert to the game and the UI system which in turn can turn on some messaging about the state of the object in the UI.
So that's a brief overview of the simulation units and the rules and I want to talk about the simulation agents as well.
So agents or transactions are the main way that information is transferred around the simulator.
They can be created by units and like units they carry resources.
Because there can be tens of thousands of them, they don't run any simulation rules and when they're created, they're given a particular plan to follow.
So they're always headed toward a certain sink or destination.
For example, a rich person walking to find shopping might be headed toward a very specific sink like the Wealth 3 shopping sidewalk sink.
Here's just an example.
This is a person.
He's an agent.
He's carrying some resources.
He's a Wealth 1 guy.
He's not sick.
He's got a little money and he's headed to work.
And then here's an example where we've got three factories.
They each have that work sink on them and then you can see the tiny little circles up in the corner are some people walking to those specific sinks.
Another example is an agent carrying water.
And since this is an unpolluted city, it's not carrying any germs.
But if you pollute your city, it might be carrying some germs.
And it's headed toward a water consumer sink.
And most buildings in the game consume water, so they all pretty much have one of these sinks on them.
And the behavior of a specific type of agent is controlled by a transport handler, which is custom gameplay plug-in code.
The obvious handlers that we knew we'd have to create for SimCity were the vehicle and the pedestrian handlers, which turned out to be quite complicated and ended up having an engineer dedicated to each one for the entire length of the project.
The vehicle handler controlled behaviors such as the global routing, changing lanes, passing, dealing with traffic lights, stopping for pedestrians, emergency vehicle behavior, and so on.
and the pedestrian handler controlled behaviors like stopping at crosswalks or walking into buildings, avoidance of other pedestrians in a crowd, and also some emotional behaviors to give the players some storytelling, like grouping together or stopping to talk to each other, even though it didn't actually mean anything in the simulation.
But throughout the course of the project, we ended up discovering...
Some other uses for agents and implementing some different unexpected types of transport handlers.
This pipe handler was a simplified version of the vehicle handler.
It used the same routing system, but had some additional tweaks.
And we ended up using that for power and water and for sewage, but as well as some more interesting hidden things, which I'll show you a little bit later.
We had a radial handler, which was literally that, this agent spread out in a radius wave front and it transacted with any sinks that the wave passed.
And then also we had a signal transport, which was essentially a timer that the scripters could use, where they would send out an agent and it would stay out there for a fixed amount of time and then come back and transact with that same unit so they could kind of delay a message using that.
Here's an example of a unit rule creating an agent.
In this case, this coal power plant is testing a rule every 16 SIM ticks.
It's using 10 coal and putting...
It's taking 10 coal out of itself and then putting 10 power into an agent and writing out some air pollution and then sending that power off to power consumer sync.
Also playing a little sound.
So that's the end of the Glassbox overview.
And it should give you some context for the rest of the talk.
So now what I'd like to do is share...
some lessons learned from making sandbox games at Maxis, and I'll go through them one by one with some more examples.
And while these examples are specific to SimCity, they're general enough lessons that I hope you could take them back with you and improve your development process or avoid some of the same pitfalls that we fell into while making SimCity.
And of course, some of the best lessons are learned from failure, so hopefully by sharing these stories, we can all fail a little bit less together.
So the first learning I'd like to talk about is to determine the granularity of your game.
So what do I mean by granularity?
Well, let's say you've figured out how your game mechanic is going to work, and you've got some kind of prototype going on, and now you're in a position where you can start playing around with the pieces.
So for example, in World of You, you know, roughly how many interactions...
does the player need to complete a compelling level?
You know, is it 20 or 200 or 2,000?
And in Minecraft, you know, how big are the blocks relative to the player?
How many resources do you need to collect to craft something?
Or how many blocks might it take to create some shelter in the game?
Or how large does the grid need to be, or the world need to be, for the vehicle creation in Bad Piggies?
So these are the kind of questions that we were asking ourselves in the very early stages of SimCity's development.
And I think it's a critical first step to ask these kind of questions because so many different decisions hinge on their answers.
So one of the first questions we had to address was the size of the play area.
We ended up going with a two kilometer by two kilometer space, which is equivalent to the medium sized city in SimCity 4.
And we chose this for a few different reasons.
And one, we wanted to be able to have a richly detailed simulation where every person and vehicle could be represented as an agent.
and every building could run its own simulation rules.
And this isn't a typical open world kind of architecture where we can just unload the people in the vehicles once they're a few blocks away from the camera.
Each one of them was holding some specific resources that were important to the state of the simulation.
So, you know, while we didn't necessarily have to render them, we had to keep them active, and we had to keep them going toward their destination.
So that said, bigger is always better, and a lot of people wanted bigger cities, obviously, but the other pressure is that Maxis games, especially SimCity, are fairly mass-market.
So our min-spec machine is more in the range of your dad's computer rather than a top-of-the-line graphics card and CPU.
So there were some trade-offs to be had because of this.
The other thing we needed to figure out was...
the level of detail that we need to simulate our buildings.
In SimCity, buildings fall into two different categories.
There's the ones that the player places themselves, and then there's the ones that the sims spawn.
On the left, we've got RCI buildings, or residential, commercial, and industrial.
And to create these, the player marks out zones, and then the simulation spawns them automatically.
And on the right are the buildings that the player places down themselves.
We call them toys internally on the team.
And these are the buildings that provide city services like fire stations or universities or bus terminals.
And we knew that we wanted to be able to compose the buildings up of smaller parts, but we weren't sure at what detail.
And at one point we thought that skyscrapers were actually going to be, you know, stacks of units that each one was actually controlling, simulating 20 floors of the building, but we quickly backed away from that because it was just getting too complicated.
So however, we did want the toys to be made up of different parts.
Where the fantasy for the player was that they're getting this collection of toy pieces that they can kind of dump out on the table and then assemble, you know, their amazing fire station or their amazing power plant.
So that was one of the motivations there.
And for this specific thing, the design motivation was already there, because in previous SimCities, you had a budget slider for your city services.
So slide it up and you could pay more money for the effectiveness of your medical system, for example.
And we wanted to take that slider and break it down into a fun way so that you could construct buildings out of parts, where each part costs you a little extra money.
So more of a granular way to deal with that issue.
in your city. And we had no idea how many parts would be fun or how detailed they needed to be.
So we started prototyping. And these are some early prototype pictures of a water pumping facility and a coal power plant. In the middle there's a palette for the parts of the coal power plant that we were building. We had three kinds of generators, two kinds of smokestacks, a power transmitter, a coal supply lot.
a cold drop-off port, and two kinds of conveyor belts.
And it let you build this awesome simulation of a power plant with all these moving parts, but the problem that we found pretty soon was that it would fail in all these complicated ways.
Your power production could be stifled because you didn't have enough smokestacks, or the thing would overheat and catch on fire, and it just wasn't that much fun, or it would've needed way more UI than we had time for to make it fun.
So we soon realized that we were going down this complexity rabbit hole and we eventually discovered some key learnings about these things.
We found that in order to strike a good balance between functionality and customization, each building that you plop down had to function 100% on its own and the modules you add must only supplement this functionality.
So we realized this, after we realized this, it became a lot easier to develop and design the different toy buildings, but we had to go through this process of discovery first.
So here's a video of placing a large hospital down and adding some parts to it.
This is with the recent game.
Oh, that's loud.
So this hospital, you know, by default can handle 100 patients and then you can put patient rooms down that just simply add to that capacity.
and a bunch of other parts as well.
You can put an ambulance bay down, and what that does is literally just gives you one additional ambulance that can respond to injuries.
A few other things I want to point out, in this picture, this hospital that the player made is made up of eight parts.
But there's a very simple hierarchy here, and you can see that with the yellow lines.
In the base module, which is the first thing that you plop, is doing the bulk of the simulation.
But in the simulator, it's connected to all the other modules, and that allows them to run rules which can share resources or operate on each other.
Another picture of that.
Here's a wind farm, so you can see this relationship between the base building and the windmills.
The windmills actually produce the power, and then the base building has the rules that transmit the power.
The other thing that we came up with pretty early on, which the art team really needed before they could go all out creating content, was determining this eight cubic meter granularity for the buildings.
We also came up with a simple snap point system that allowed for the artists and the designers to set up male and female snap points so they could determine and give the player valid places for these things to attach.
So here's some examples of the various ways we figured out the granularity for SimCity.
The process of figuring this stuff out is gonna be different for each game, but in my experience, you wanna sort out these kinds of details and questions as early as you can because...
Determining your granularity informs all sorts of other decisions about content.
The scope of player interactions and the complexity of the simulation.
So the next lesson is all about discovering fun patterns in your game and then exploiting them and reusing them over and over.
As we were experimenting with Glassbox and playing around with the simulation, we started discovering certain patterns and things that were relatively straightforward to implement and went along with the grain of the simulator.
And a lot of these had to do with the use of agents.
So we knew we were going to use agents to represent people and vehicles, but we soon discovered some other uses for them, and I'll show off some examples.
This was an early attempt at using radial agents for power transmission.
And the windmills would create a radial agent carrying power, and then it would deliver that agent to any of the buildings.
that had the power consumption sync.
And it wasn't very realistic, and it's not what we ended up doing for power, but we ended up using this radial handler in other ways.
For example, when you plop a park or a town hall, this video, we actually send out this radial wave of happiness.
And it's not just an effect.
that's actually an agent that's transacting with all those buildings, giving them a little bit more happiness.
And happiness is what eventually causes buildings to go up in density.
So here's another example of a transport handler.
This is the pipe handler that I was talking about earlier.
So it's a simplified vehicle handler, and it doesn't have any notion of lanes or the agents blocking each other.
It's just using the raw routing.
This is a video of a small city powering up.
Did you know that all the dynamic lights on the building are driven directly by the power resource inside the building?
Also in this example, there's only one source of agents, which is the power plant, but there's hundreds of sinks.
But we discovered that we could flip that around and reverse that and create a sewage system.
So every time a building consumes some water, it produces sewage.
So here's a video of where we're plopping a sewage output pipe.
And here there's hundreds of sources of agents and only one sink.
Put that down.
There goes the sewage.
And that actually sent out a little radial wave of sadness about that.
And what's happening here is when the sewage agents get to this output pipe, they're actually writing ground pollution into the ground right there.
So it's a way of concentrating that ground pollution rather than, if you didn't have it, all the houses would write out the ground pollution themselves.
And they were playing some effects when that transaction happened.
You can actually see, you know, visualize the poo.
So...
So we also discovered, aside from just power, water, and sewage, there were some other ways that we were using these pipe agents.
We found that we could use them as a call and response system.
So I'm going to show some videos that have some debug stuff on, and this is usually invisible to the player.
But in this video, a building's catching fire in the back there.
And it's going to send out, there we go.
So that is an invisible fire alarm agent.
and that's transacting with the fire station and then that bouncy ball is a timer that's delaying the sending of the fire trucks. There we go.
Fire truck's going to go out and we're going to see another house catch on fire near the bottom and send out another alarm.
So you'll see that each fire station garage actually has its own sink for this alarm so that it can send out its fire truck.
We ended up using this kind of pattern, this call and response pattern, for almost all the civic buildings.
Ambulances responding to injuries, or police responding to crime, and so on.
This is another example of how we used it for the RCI buildings.
This is an RCI building that's opening for business in the morning, and it's sending out a call for workers.
So the workers come in there, and then it sends out, now that it's open for business, it sends out a call for shoppers.
And then the shoppers.
There we go.
Now some people are going to go shopping.
And when they do go shopping, they get converted from their car or their person into the signal timer.
So there, the shoppers are actually represented as these bouncing balls.
And when they come back down, we're going to send them out with happiness.
So here's that same pattern, but in a medium-sized city.
And I kind of wish we had shipped with some of this debug stuff in, because I just love watching the complexity.
that's going on here, when all these different buildings call for workers and call for shoppers, and you can actually see what's going on in the simulation.
So anytime you see the blue bouncy balls, those are shoppers that are currently shopping at a building.
And one final example that pulls this all together, this is a meteor strike disaster.
So if you watch closely, you can see this initial radial agent that's triggering houses to panic.
So they're turning out their lights, and they're sending people out onto the streets.
And then the meteor strike will happen here.
Boom.
And that sends out a wave of heat that's then causing a bunch of houses to catch fire.
And each of the houses is actually spreading heat as well with these little red radial agents.
So that's how fire spreads in the game.
a disaster, there was a fire truck and...
Okay, so, um...
So yeah, it's...
Yeah, so as you're exploring your core mechanic, just always be on the lookout for patterns like these that just work or that just feel right, and then latch onto them and reuse them as much as possible.
And you might find that you only need a handful of these to actually make a great game.
So the next learning is that it's really important how you're gonna figure out how to scale your sandbox game.
Building a sandbox game is especially tricky when it comes to performance, because you have to constantly be thinking about.
the absolute worst case.
It's easy to fall into that early game performance trap, thinking that you don't have performance problems when everyone's workflow involves starting a new game from scratch.
And we had to take some careful measures that performance would hold up on large cities.
So for example, it was almost never OK to just loop over all the agents or all the units.
We had to bucket them into different sinks and operate on them that way.
And for the routing, we had to round-robin through all the different sink types and then only propagating the navigation information for one of those per frame.
And when it came to tracking performance, it was really important that we set up proper metrics on a variety of cities.
Over the course of the project, we actually ended up with a pretty cool automated system for building cities and tracking frame rate.
and memory metrics.
The gameplay team added some hooks to all the player tools like zoning and road draw and plopping buildings so that when they're invoked, they spit out a command to the console and then you could build up a city and then copy and paste all those console commands into a test script, allowing us to procedurally recreate the city.
And this was better than simply loading up a saved game because if the simulation changed, we wanted those changes to be reflected from the very start.
And then we created a variety of cities, an empty one for baseline comparison, a small city and a target city, and then one for graphics performance that had background cities.
And we used that one at different zoom levels and also with the simulation pause and unpause so that we could isolate different CPU or GPU differences in isolation there.
So, and after that, our infrastructure team built up automated tests that would create these cities and measure frame rate and memory and collect this data as graphs and metrics on a webpage.
And this was really invaluable because when you're working on a simulation, one tiny tuning change can ripple through the entire game, spiking up the number of vehicles or pedestrians, or at one point, doubling the number of sewage agents that, you know, from a simple tuning change.
So it was really vital to be able to keep tabs on this stuff on a daily basis and be able to look at these graphs and go back and forth and see, oh, you know, something crazy changed on Thursday.
So even when we solve for the target case, there's still this pretty big collection of worst case scenarios.
You know, it's possible for the player to intentionally build worst case traffic jam, where they don't put any public transit, and it may not function well as a city, but it still needs to perform on your CPU.
And on the other hand, you could build row after row of high density, residential and commercial skyscrapers, causing thousands of pedestrians to roam the streets because they choose to walk instead of drive.
So I remember once loading up one of the cities from our internal population leaderboard and being shocked to discover that there were 68,000 pedestrian agents live.
So we had to do something about that, but changing the simulation wasn't really the right place to do that because we had to keep the integrity of the simulation going.
But what we ended up doing was, you know, if there was a certain, over a certain threshold of vehicles or, you know, that were stuck in traffic or pedestrians that were walking around.
We started picking and choosing ones to teleport to their destinations.
So, you know, it was a good trade-off between performance and keeping the simulation without sacrificing the simulation integrity.
Okay, so the next lesson learned is about exploring your game and your mechanics in a breadth-first way.
So, what do I even mean by that?
Well, I like to think about our gameplay effort as falling into four major categories.
There's the code driving the core mechanic, so that was Glassbox in our case, coupled with the simulation rules, which are the data.
And then we've got input and output in the form of player tools and feedback.
And these arrows represent relative effort spent in the four areas, so I made the core mechanic ones longer since you generally start there.
So in my experience, it works best to slowly build up in layers.
You want to do a breadth-first search through the possibility space of your game.
So for example, you might add some data to the game simulating criminals appearing inside of buildings.
And then you find that you need more feedback.
How does the player even know that a criminal's inside a building?
And now you've got a problem that the player knows about, and they want to solve.
So you give them some tools to do that.
And you just kind of go through this little bits at a time.
And, you know, don't go out too far on a limb.
And maybe at some point along the way you realize you actually need to add a feature to the core mechanic, but by this point you'll have justified that need for that feature because of actual gameplay experience.
And I think that's a key learning, is that you always want to justify your development effort based on real user feedback and based on gameplay experience.
So what are some of the dangers of ignoring this lesson?
Usually it involves wasting time and effort.
on things that aren't important.
So on SimCity, we did this a few different times.
Once was with our player tools.
Coming off of Spore and the building editors, we had this idea that we wanted the building construction to feel extremely creative and physical and tactile.
So we ended up going pretty far down a hole with physics-based manipulations, with springs connecting the pieces, being able to stack them up and so on.
So here's a video I saved from a couple years back.
when I was working on this stuff.
It was pretty cool and it was fun to work on, but it ended up being completely irrelevant for a number of reasons.
For one thing, it didn't make sense, given our eventual snap point granularity, for a building to be at some non-right angle.
And also, while we didn't know it at the time, players wouldn't actually be spending a very high percentage of their time editing their buildings.
It turned out to be a relatively quick operation, like buying an upgrade.
with less a degree of creativity than we originally thought.
Another black hole we went down was related to the simulation rules.
And we did this a few different times, but here's a good example.
As we were getting the basic RCI simulation up and running, we thought it would be a great idea if we could tune the exact hours that each building was open regardless, or for each wealth class.
If you had an office building where you could have the janitorial staff show up at 6am, and then the middle managers show up at 9am, and the executives could pop in for an afternoon meeting.
And we tried this, and it created a lot of rules and tuning variables that turned out to be quite a nightmare to deal with.
Pretty soon we realized that this was a terrible idea.
It spiked the rule count and the complexity.
The tuning folks balked at having to generate so much extra data per building, but most importantly as a player, you didn't even notice this happening at all.
So, and by the way, what we ended up doing is having a 6 a.m. to 6 p.m. work shift for all the buildings, except for two exceptions.
There were buildings that ran 24 hours a day, and also special ones that were open late at night, like nightclubs and things like that.
So that's really all that we needed to create that feeling for the player.
So the lesson here is to resist focusing too much effort on one part of the game in isolation.
Resist the temptation to delve too deeply into one facet of exploration until you're sure you're on solid footing with everything else.
So the next lesson learned is about balancing the effort that goes into code versus data.
I found that in my experience working as a programmer, there's this delicate balance between the amount of effort that you put into engineering a system versus the amount of effort that the client of that system, whether they're an artist or a designer, puts in.
So in a perfect world, there's this ideal amount of back and forth going on.
The engineer implements an initial first pass, and then the content creator goes off and plays with it for a while, and they say, I got to this point, and now I need this feature.
and you just have this nice iteration loop, nice tight iteration loop.
And part of me feels like this ideal balance comes from simply having respect for each other's work.
You know, when these collaborations work well, you're in the zone as a team.
But if there's not enough communication or people's goals aren't aligned, it can go sour.
So I've seen how it can go bad if the balance is off.
And I've watched engineers completely over-implement in isolation.
creating features up front that they think might be needed, but all it ends up doing is bloating the code and introducing complexities and complicating the process for the content creator.
And on the other hand, I've seen content creators go off into a silo and attempt to just make do with what they've got.
But this can have negative side effects as well that are just as bad.
They'll end up stretching and bending the system in ways that it was never designed to handle, causing performance problems or data bloat that could have just been solved with the addition of some simple feature if they'd just been in better communication with the engineer.
Here's an example from SimCity where I think we actually struck a good balance.
For some context.
In the game, pedestrians and vehicles are agents.
They're carrying information.
And one of the challenges that we had was that when an agent actually arrives at a building, it commits the transaction.
So it's dumping the resources into the building and then it's gone.
So there's this disconnect between the player's fantasy of what's happening versus what's really happening in the simulation.
And one of the ways we got around this was to create a little animated vignette of people moving around the building, doing some behavior.
giving the impression of activity when the building was in a certain simulator state.
So here's a quick video showing off some sims constructing a building.
And the only real simulation that's happening here is that there's a timer that's constructing the building, and every time you see the building lift up, that's actually just a simple resource changing, you know, increasing.
All the movement of the people are just set up by an artist.
So building this vignette system was one of the first projects given to one of our new gameplay engineers and since we weren't sure what the scope of this feature was going to be or how often we'd need to use it, I suggested that we just start small and take tackling the immediate problem at hand with the least amount of work.
So the simulation was in a pretty basic state back then but we knew the buildings were going to need to construct and it was looking pretty dull at the time so I thought that would be a good starting point to work on this.
And it turned out that the minimum amount of work is pretty much what you'd expect.
It's a list of points for actors to walk around and some simple tools to set that up.
But once that was done, we took a look at now, you know, what are all the vignettes that could now be created just using simply this code.
The artist was off to the races, filling out content throughout the game where they could.
And while that was going on, we could now look at what vignettes we still couldn't make with the current code.
An example of something was the garbage pickup, where the agent's movement had to be relative to the garbage truck and relative to the trash can, so they could walk back and forth a couple times.
And this would, you know, this required the ability to add, the ability to specify a point relative to some object.
So, that's what he worked on next.
And this cycle continued.
And this example isn't that complicated, but my point is that you want to tackle these kind of problems in a way that you're consciously facilitating this back and forth between code and data, as I've found that it produces the best results.
And here's just a nice video of a couple vignettes toward the end of the game.
Here we have a baseball stadium and a soccer field.
and they're running a bit more complicated data.
They'll also scale up and down the number of people, depending on how many people are actually, how many sims are actually at these parks.
So in order to discover interesting patterns inside your mechanic, you've got to be able to see what's going on.
So this next lesson is about exposing as much data as you can, be it debug draw or whatever is available, and playing and developing your game with this information overload enabled, and then picking out the pieces that are important that way.
So for SimCity, we relied heavily on various debug draw modes to expose what was going on.
This is just an example of a water tower running a rule that's subtracting water from the surrounding water table.
This is the debug mode for the vehicle transport handler, so it's showing off the destination of all the vehicles, there's little hovering disks above them, and then where those open sinks are on the buildings, and the colors of the sinks and the destinations all match up.
It's also showing some of the simulation state at the intersection, so the traffic lights and the splines that vehicles are generating to make their turns.
And this is a picture of the zoning system internals.
You can see that the streets are broken up into these eight meter parcels to match with our snap point granularity.
And the green outlines around the buildings represent the claimed space.
So as our team of scripters began to ramp up, creating more simulation and new behaviors, it became harder and harder to understand what was actually going on inside the simulation, especially in larger cities.
And this was pretty scary, because it made us question some of the earlier choices about granularity.
Maybe we were making the simulation too complicated.
So at one point, very early on, I wrote some code to simply print out the amount of garbage next to each building, data-driven way to do this, so that a scripter could fix a bug with the garbage system.
We already had plenty of tools to inspect the simulation state, but the simplicity of being able to see a single system represented in isolation, that was a big win, and that was something we hadn't really done before.
So we immediately saw the value of this and latched on to it.
And it eventually turned into this data layer system that's in the game today.
This is the way for players to expose specific about a particular slice of the simulation.
This is actually what the garbage layer looks like today.
It's a way for the player to just turn on a mode and just see what's happening.
only with garbage in their city.
They can see the amount of garbage, and they can see the garbage trucks, and they're called out where those are.
There's a whole bunch of different data layers that you can add, you can turn on.
So here's a really early video.
This is the first time we tried representing data as bar graphs.
So the height of each bar here represents the number of people in the building.
And the yellow buildings are industrial, and the blue are commercial.
And this is like at 6 p.m. when everyone's going home.
And you can see some pedestrians walking home and filling up the green bars, which represent the houses.
Of course, there's stuff on fire, too.
I also just love looking at the early stuff, fond memories.
And here's an example of that population layer today, running on a big city.
So you can really get a sense for the movement.
of information and agents that are flowing around your city.
Another good example is with our vehicle and pedestrian transport handlers.
We had a debug mode where you could see this color circle above the agent telling you which type of sync it was headed towards.
And when this was enabled, it immediately exposed all kinds of meaning behind the agent behavior.
And when you play with this on, you'd kind of discover interesting things that were going on, or even bugs.
And we tried to find opportunities to expose this data to the player.
in surprising ways.
And one of the ways we did that was with this Mad Libs style sentence that we would come up with based on what we knew about an agent.
So, you know, we knew he had a unique ID, we knew he was headed to a certain destination, and we knew what resources he was carrying.
So, you know, this guy is going to toy work wealth one, which essentially means a city job as opposed to a RCI job.
So we could come up with these mad libs, so walking to his poorly paying city job.
So this is how we just, you know, a little fun joke for the player where you could click on anyone and get this little sentence about them and that would actually tell you something about what's happening inside the simulation.
So as we built up the game and the feedback in layers, it took us a pretty long time to discover what information was actually important to the player.
The core loop of the game had to come together enough until we were able to realize what to expose and how to expose it.
So the takeaway from this lesson is that having lots of visualization tools at our disposal during development helped us to debug and helped us to digest the simulation and what was going on.
So, you know, put as much of that stuff in as you can.
And the next learning is, and this is I think one of the most important learnings for a sandbox game, is to don't seek out complexity.
It will find you.
And I realize it's a pretty general statement, and it could be applied to a lot of games, and even just to software engineering in general.
But I can't overstate how completely evil complexity is in the particular case of a sandbox game.
As you're working on the game, especially once your team is bigger, there's this tendency to want to just take what you've got and add just one more layer of complexity to it.
And this happens when someone's working on a feature in isolation without the context of the rest of the game.
But the thing you have to realize is that once you take your simple pieces and you let the player compose them freely, that in itself is a complexity explosion.
So you know, complexity is going to rear its head during your game's development whether you like it or not.
So don't give it a head start by over-designing the individual pieces.
I find it's good practice to constantly ask yourself, you know, what could I remove from the game?
Or if we didn't do feature X, you know, what else might we be able to improve?
And I like this quote.
that I saw fly by on Twitter a couple months ago, Ambition Limits Polish.
For many games, and especially those at larger companies, there's this one resource that's completely fixed, and that's the amount of time that you have until you have to ship.
So is the new feature that you wanna add so important that you'd be willing to sacrifice polishing what you've already got?
The fire simulation is actually a good example in SimCity where we made this mistake.
Early on in the project, we chose to fully implement this part of the game so that we could get an idea of the effort that it took, from scripting and from engineering and art and so on, so that then we could schedule out the rest of the game.
And we really went down a rabbit hole with this.
This was about a month of work for 12 people, like, you know, a couple years back.
I managed to capture and save this little video.
And here's all the crazy things that we were doing in this video.
We had little agents instead of a vignette of people that would actually, when the fire truck arrives, it would actually create a unit there and little people would walk back and forth.
that were actually transacting with the house, reducing the fire.
The number of people that actually came in the truck were based on the number of people that were working at the fire station at the time.
There was this dispatch tool and patrol markers for the fire trucks that you could plop down.
And we just went way overboard on this.
And in hindsight, it violated two of the other learnings I've already mentioned, which is breadth-first exploration and also the granularity.
But hindsight's 20-20.
And at the time, we just didn't realize the ridiculous scope of the game that we were trying to make.
So there was a lot of pressure to demonstrate how cool this single system in isolation would be.
But the problem is you can't really look at a single system in isolation.
You have to look at it within the context of the rest of the game.
So when we took a microscope to the fire system, it just made us feel like there wasn't enough there and forced us to make it more complicated.
So just be careful of that trap.
So one thing I like to think about is like, you know those moments where someone comes up to you and asks you for a feature request.
And sometimes it's trivial and easy to implement.
You go ahead and do it.
And otherwise, it's clearly outside of the scope of the current system, so you can say no.
But for those times where it's somewhere in between, if you're trying to decide whether it's worth the bang for the buck, I would urge you to consider taking complexity and future effort into account.
You know, you might add the feature.
and be the hero, and then a month later you realize you actually spent quite a bit of time, more than you thought, that's gone into that feature with bugs or iteration or just some tool change that confused people, some human element to the problem.
And if you hadn't actually implemented that feature, it's as if you magically get back all that time and effort spent, which would have gone to other things.
So, I'm not suggesting that you just go around saying no all the time, but I think as an engineer, it's important to keep in mind that saying no is one of your tools and sometimes it's a really powerful tool and if you think it's in the team's best interest to not go down a particular path, you should speak up and make a case for that.
So toward the end of the project, it became apparent that our scope was so big that we were standing on the edge of this giant chasm of possibility space and for better or worse, no one person on the team could even explore the whole thing, or not in the time we had left.
And of course we had a whole team of QA testers exploring the game as well, but there was just so much that you could do, and so many ways to combine all the pieces.
So that was a bit scary, and it felt like the team and QA were able to explore up to a certain point before ship, but then in a matter of days after shipping, well after servers were working, our combined players came along and just blew that exploration out of the water, finding little oddities and problems at the edges of the simulation, many of which we're addressing right now with patches.
So...
I hope the takeaway from this particular learning is that you all go back to work next week and rip a feature out of your games.
So here's the list of all the learnings.
SimCity is such a complex and layered game that early on in development, it felt like we were pushing this boulder up a hill.
For a while, the depth of the simulation wasn't there, and the feedback wasn't good enough.
and we couldn't even demo the game without literally standing next to someone and telling people what was happening inside their city.
And as time went on, the simulation got stronger and the UI improved and we reached this magic moment where we felt like the boulder finally got to the top of the hill and then started rolling down the other side.
And we'd have people play the game and instead of being utterly confused, they were telling us obvious things that we needed to fix, like this tuning isn't right or I need more feedback about which buildings are on fire and that kind of thing.
So we got to this point where instead of us pushing the game up, it started telling us what to do.
And I think the good goal of any sandbox game developer is to try to reach that magic moment, that point in your project, as soon as you possibly can, as early as you can.
And I hope that some of these learnings will help you get there sooner.
So thank you very much.
I also just wanted to thank the team at Maxis.
Everyone worked really hard to produce the game, and they're still working hard on updates and fixes, because we really care about the game.
We really care about our players.
One thing I just wanted to show you quickly, before we do questions, is a video that was put together by one of our engineers.
This was the engineer Richard Shimaka.
He was working on the data layer system.
And he made this video to show off the data layers system.
But I think it shows off a lot of cool things in the game.
So if I can actually get it running, quick time.
Awesome.
There we go.
Where are you?
This is people leaving school, giving education to all the different houses nearby.
This is the garbage layer with the garbage trucks picking up garbage.
And this is that population layer. People are going shopping and going to work.
These are buildings that are being constructed and going up in density with happiness.
Alright.
Okay, so we have time for a couple of questions.
Go ahead.
Yeah.
I just wanted to ask about how much the element of randomness comes in when you're doing the sandbox games, especially with SimCity.
Because one of those things you showed there was the customers going to a shop to purchase things and then going home again.
It kind of looked like as soon as they got that request to go to a store, they would leave their house.
And so, because there was five houses next to each other and they all left at the same time.
Yeah.
and all left the house at the same time.
So it didn't look like there was any randomness in that particular transaction at all, which seemed somewhat immersion breaking in that probably people wouldn't spend exactly the same amount of time in a store.
Is there a reason for that?
Like would that have taken too much, like to update them at different times?
Is that kind of too much work?
I think it came down to like a complexity issue or would people even notice that this was happening if we varied that amount?
So the tuners actually had the ability to set the time that people were in a shop or in a cultural building.
So they could set that differently for each building.
But what we ended up realizing is that we had templates for all the, you know, there's like 27 types of RCI buildings.
And we ended up tuning most of the stuff inside those templates for the different wealth and density and then the three different types of buildings.
Hi.
Were there any patterns that emerged when you were developing the different systems that surprised you, that either you thought needed to be changed because they were wrong or sort of revealed something about the workings of a simulation of a city?
One thing that was kind of cool is that the way that our routing works, when people go out and look for a job, they're actually going to take the first job that's available.
And one thing that was cool about that is you'd actually get businesses on the corners that were the most successful.
Which just because you know the way that you had your your residential and your commercial and your industrial laid out, the patterns that would emerge from that would actually cause certain buildings to work better in certain places.
So I think that you know, that's one of the things you don't really realize at the first time.
few times that you play, but after a while you actually start developing strategies to game that behavior, which was really cool.
I should also mention that there are some cards floating around that will actually give you a free copy of the game that Charlie brought, thank you Charlie.
And people are distributing them back there, so when you leave, grab a card and you can go on to Origin and just type in a code and get SimCity.
Oh, they look like this.
So.
A quick question.
Sure.
Do you know if Glassbox is deterministic in the simulation sense?
So there's only a couple of places where there's randomness in Glassbox, in actual rules in the simulation.
A lot of the non-determinism comes from the behavior of the agents, which are just controlled by gameplay code.
So they could have, so each.
agent transport handler could be implemented with the deterministic behavior or not.
And most of the vehicle and pedestrian ones were not deterministic.
So you could get slightly different behaviors each time.
Okay, thanks.
Yeah?
So, during development, which of the systems was the trickiest to debug?
Sorry?
During development, which of all the gameplay systems was the trickiest to debug?
The trick is to debug.
I'd have to say the guy implementing our vehicle system, this guy named Alex Harkness, is an amazing programmer and just did a really great job with it.
But man, that was a very hard system to get right.
One of the bugs that we would find is that you'd get gridlock.
And you could get gridlock for a million different reasons.
Something would go wrong or some flag wouldn't be set on the traffic light or something.
So that bug just kept coming up, and every time it happens, it's like, it's death to your city.
So I'd say that was probably one of the most complicated systems on the game.
The other one was the zoning system that spawned the buildings, because it had to do a lot of pre-caching of data in order to efficiently decide where to put these 27 different classes of buildings that were trying to spawn all the time.
Okay, one more question?
You said about feature requests to programmers, how you've got the option of saying no.
How do you counter that with the example where you had that little bike with all those like, you know, like we had a slide where, you know, the designer's going to do it anyway and it's going to overburden the system.
So how do you counter the, sorry, I've got to say no with them just, I'm going to do it anyway?
I mean, I feel like it's different team by team.
On our team we...
tended to just talk about it in a pretty civil way.
So there were certain things that people wanted to do that if we had done, we just never would have shipped, or we wouldn't be able to support big cities.
So that was part of, I think that the engineers were pretty strict about performance because it was a pretty obvious case that you could make, like, okay, can you do that?
Can you have a whole city of tiny, tiny buildings all doing that same thing?
So you can always come up with this worst case situation.
So rather than just designer putting their foot down, it was more of a collaboration.
OK.
One more?
Sure.
At which phase in the development did you guys really feel like the boulder had started rolling down the hill?
And how did you keep the vision, how did you keep the eye on that before you got there, before your players told you that?
I mean, we were always trying to get there.
I think that when that ball crossed the threshold was probably in October of last year, so pretty close to the end of the game, where we just had enough of everything in so that you could have a coherent gameplay experience across all the different systems in the game.
So that's the thing about, and I'm hearing stories about previous SimCity's developments went the same way, where you're just picking up all these pieces one thing at a time and then...
you get to this point where you reach this threshold and the game just feels like it came together.
So it takes a lot of work, but I've also heard similar stories for people doing sandbox games where until all the little pieces start to lock down, you can't tune the outer pieces because one change early on can really have these ripple effects through the game.
Yeah.
Okay.
So thanks everybody.
