Right, I'm John Engold. I'm the narrative director at Inkle, we're most famous for our game 80 Days, which I'm sure you have at least heard of, but I'm not actually going to be talking about 80 Days particularly today, so Sid Meier's still available.
I'm going to be talking about our other big game, which was called Sorcery.
Hopefully you've heard of it, hopefully you've played it, so this talk will make some kind of sense to you.
If you haven't, I'll try to be clear, and Rock Paper Shotgun called it their RPG of the year last year.
So at least...
somebody thinks that it's vaguely worthwhile and worth talking about.
In particular, I'm going to be talking about the last two parts of it, which were sort of open world games, but only sort of and kinda.
And that sort of and kinda is really what I want to get into, because I think that's the most interesting bit.
So Sorcery is actually four games adapted from a set of paper game books written by a UK game designer called Steve Jackson in the early 80s.
Now it's a really interesting series.
I read it when I was a kid.
I read it when I was about 10.
And the first one is an absolutely straightforward normal paper game book.
So you read a paragraph.
There are some choices.
You pick one.
It tells you what paragraph of the book to go to.
You go to that paragraph, and so you go.
It had a kind of cunning spell-casting system, but broadly, it was a very straightforward book.
But Steve is not that kind of designer.
He's the kind of designer who likes to break things and confuse people and create puzzles and tricks and traps.
And so as the series went on...
the books had more and more weird twists to them.
So maybe in one place you had to reverse the numbers on the paragraph to find a special secret.
Or maybe in another, every time it ended in a seven, there was a rule you could apply.
And so you'd be learning information and breaking the format of the gamebook.
As a kid, reading that, that totally blew my mind.
It was incredible, it was magic.
And our series, which we started about 30 years later, has also evolved, but in a slightly different way.
So in case you haven't played it, and in case you have, I'll just sort of take you through that evolution very quickly.
So sorcery is played out on a map, like a nice fancy map, and you kind of journey across it having adventures.
And part one, which looked like this, was very linear.
but quite branching.
Now, linear is one of those words that's massively overused and no one ever really knows what it means, so I'll be clear.
I don't mean linear as opposed to non-linear.
You didn't get bashed on the head and have crazy memories coming in weird orders.
I mean linear as opposed to circular.
You always go forward, you don't walk around in circles, you can never go back on yourself.
That's a defining feature of this particular book.
But as you walk forward, you're always seeing specific content, you're always seeing detailed content, you're meeting people, you're talking to people, you're having adventures.
having interesting encounters along the way, but what I do and what you do might be very different because of that branching.
So as you can see, there's a rough sketch of what our journeys might be like.
We hit some beats, we miss, we share other beats, we don't share other beats.
But in general, when players played it, they kind of didn't like it.
They found it was a bit too short.
I guess basically what they said was, we felt like the missed content was wasted content.
Okay, fair enough.
So for part two, we wanted more people to see more stuff, while still allowing people to just charge from beginning to end if that's what they wanted.
So we kept that linearity for players who wanted that linear experience, but because it was set in a city, we added a little bit of an ability to loop around, revisit streets, sort of case the city block, and really farm out all the content in that game.
If you've played it, you'll know there's one other mechanic to help with that, but that's beyond the scope of this.
But those loops were handcrafted.
They were added really late on in development.
We had written most of Sorcery 2 while still coding Sorcery 1.
So the way that we built it was extremely fragile.
You'd be in a street corner, and it would literally say, well, if you haven't been over here, you can go over there.
If you haven't been over here, you can go over there.
If you haven't been over here, you can go over there.
So we had quite a few places where an odd number of paths would collect at a point and it was possible to loop around and get stuck.
If you know the Bridges of Konigsberg problem.
And I'm pretty sure there's at least one of those still in the shipped game.
But it doesn't matter because it's got a rewind mechanic.
But it's not properly built.
We hadn't actually solved any problems at this point.
So then we went off and we did this 80 days thingy, and that was fine, and it was great, and it gave us a bit more freedom to muck around, which was cool.
So when we came back to Sorcery 3, we wanted to solve that problem properly.
Now, Sorcery 3 is set in a wilderness, and the story is you're searching for these serpents all over the map.
So it really doesn't make sense at this point to disallow backtracking.
If you've got all the way over here, and you've missed one, and it's there.
than saying, sorry, you can't go and find it.
That's the fighting against every aspect of what the story is telling you to do.
So we built this one in a completely different way.
From the ground up, we built it to make every single location infinitely revisitable, and ensure that the player could never get trapped because they'd been in and out so many times that there was nothing else they could do.
The paths go all over the place, the heat map is essentially irrelevant, that diagram is a total fake, actually players just scribbled around and did whatever the hell they wanted to, and there's even a fast travel system in there.
structurally looks like the heat map of an open world game, right?
So when we shipped it, we said, hey, it's an open world game.
But we felt kind of wrong about that because it isn't an open world game.
And I'll come to that in a moment.
In terms of actually making this thing, we relied on a trick that we stole from 80 Days, which was the what happens in Vegas stays in Vegas rule.
This is a wilderness full of isolated villages, so if you happen to burn that one to the ground, or make that one get eaten by a dragon, or set for whatever else you might do...
The people here don't really tell the people there, look out for this guy, he's a maniac.
So that makes us have less to deal with in terms of consequence.
But...
For part four we bunged all of that together and put you in a city.
So it's very clockwork, part four, there's this little citadel and you're running around inside it and the characters that you meet have memories, they talk to each other, they generally remember everything that's going on.
So this really is the most complicated game we've ever made, even though it looks substantially smaller than Sorcery 3 and a lot of the reviews said meh, it's not as interesting as Sorcery 3.
That's not true, it really is, but maybe it's a more refined kind of taste, I don't know.
Anyway, so...
Over the course of 35 years, take that Sid Meier, we've been on a journey from straight choosing our own adventure, what I'm calling authored branching narrative, because it's branching, and crucially, everything in it has been put there deliberately via this circular narrative that we had in Sorcery 2 that support loops.
It's not quite linear, through to this open world free exploration game.
So we've been moving forward along this spectrum.
And this spectrum, it has one big problem with it, which I hope at least some of you are already thinking.
I hope I haven't charmed you sufficiently that you're not thinking it.
The problem with this spectrum or slide is it's a complete load of nonsense.
there is no spectrum from authored branching narrative to open world games.
Authored branching narratives are nothing like open world games.
Open world games are completely different.
And that was why we didn't want to call part three an open world game, because it breaks every single rule of a traditional open world game.
In case you don't believe me, I made a little list of differences.
I don't really want to read it all out because you'll get the joke quite quickly, but Open World Games, infinitely revisitable locations, but they're largely empty or generic.
It's another hut, it's another riverbank, it's another town, it's another blacksmith.
Authored branching narrative, every single location is detailed, specific, individual, there's no generic content in there at all.
The same applies to characters, characters repeat themselves in open world games, they never repeat themselves in authored branching narrative games.
The last two points are really important, in an open world game you can stumble and discover things, you can find things out of order.
You can't do that in an authored branching narrative game.
And crucially, grind.
Grind is a standard component of any open world.
Grind in an authored branching narrative is a meaningless concept.
It doesn't make any sense.
You cannot have grind in a game book.
Like, what would you do?
It would say, right, stop reading now, go away and jump on the spot for 20 seconds and then come back and carry on reading the book.
There is no mechanic for that.
So, when we came to design part three, and then carried over into part four, what we were really trying to do was make an authored branching narrative, just like we'd done before, that survived despite being located in what was superficially an open world.
Well, that's too much.
Actually, what we really did was a narrative which copes in an open world.
You can still break it quite happily if you enter the little wilderness portion.
Go here, go back, go here, go back, go here, go back, go here, go back.
It won't look like an author-branching narrative anymore.
But I don't think anyone's going to do that.
And if they do, I think it's your fault, not mine.
Sorry.
This is why I think it's a sort of open world, but I also think it's a better open world, because I'm very happy with it, I'm very proud of it.
So I'm going to tell you how we did it, and if you work for Ubisoft, you can give it a try.
or not, up to you.
It kind of relies on two core components which are sort of complementary.
The first one is this.
I just had a crack at Ubisoft, but I'm actually not really talking about Ubisoft games because there are two kinds of open world out there anyway.
There are mission-based games with sandboxes which are utterly linear and the sandbox element doesn't really feed into that linear at all, really.
Except via vague upgrading.
And then there's open world Skyrim Witcher-type games where there's a morass of quests and sub-quests that you can drop in and out of at any time.
And that's the kind that I'm talking about.
And this is our first rule.
We don't use quests, we use encounters.
So, what do I mean by that?
Right, the traditional spine of an open world game, as far as I know, I haven't worked on one directly, and I've been out of the mainstream industry for about five years, so maybe you guys are doing crazy, amazing stuff now, but I don't think you are.
I think this is what you're doing.
You meet someone, you go somewhere, you get something, you go back to the person you met, and you get a reward.
Amazing. Brilliant.
So, for example, because we need an example.
So I wrote this talk and I sent it to the GDC supervisors and they said, you need to use examples from sorcery because, you know, people will like that.
So I went through the whole of sorcery, that's a million and a half words of content, and I looked for a quest that had that shape and I couldn't find one.
So then I played the Witcher for about 10 minutes and I found one and I nicked it.
So I'm going to be really mean to the Witcher because actually it was really well written and I did enjoy it but I'm going to make it look stupid.
So there we go.
So here's a quest which is roughly a quest from the Witcher.
You meet someone, you meet a peasant and they say there's a wolf in the woods.
It's probably a werewolf because it's the Witcher but whatever.
So you go to the woods and it turns out there's a wolf in the woods.
So you get the wolf's head because we're gritty.
And you take it back to the peasant and you drop it on his table and he says, Okay, am I supposed to cook that?
And you go, knock yourself out.
And he says, well if I'm going to eat a wolf's head, you can have my chicken.
Have my chicken. I say, thank you very much.
We've told a little story.
Fantastic.
Okay.
So, obviously, this is highly problematic from a narrative point of view.
The first problem being it's kind of dumb.
But there are some proper problems.
There are some actual design problems here.
Firstly, why is this peasant not doing anything about this?
Why is he sitting in a corner of his house looking miserable, waiting for me to show up and help him out?
If I go hear about the wolf, do nothing, bugger around, buy lots of stuff from the local blacksmith, play Gwent for three hours, why doesn't the peasant care?
Why is he still sitting in the corner looking miserable about this?
Well, okay, as a player I know why.
It's because the quest structure is waiting for me to activate step two of the quest.
But from the narrative point of view...
I've got no options here as a player. I just have to suspend my disbelief.
I have to say, yeah, that guy's a character, but only when I need him to be a character.
When I don't want him to be a character, he's a rock.
And that seems like a shame.
And if you do that in a text game, everyone says, you guys are rubbish, that's a bug.
This is useless. Nobody forgives you in a text game. It's not fair.
In The Witcher they do, and fair enough, it's a beautiful world and they have a lovely horse and sunshine and things, and that's fine!
But, um...
Well, let's try and do better.
Thirdly, why are the woods empty if I go to the woods before the peasant?
And that sounds kind of petty in a big game, but I did do this in The Witcher.
I went to the Bog of Prickly Marsh, or whatever it is, and there was nothing there.
And so I thought, OK, fine.
I went there because it had a fun name.
And a bit later, people kept dropping little hints that I might want to go to the Bog of Prickly Marsh.
And I thought, no, I don't need to go there.
There's nothing there.
And then eventually I didn't know what to do, so I went there and there were these three witches with baskets on their heads and all this crazy stuff.
And I thought, oh, I was actually confused.
I was as confused as when I first played Assassin's Creed and I got my first mission.
And they said, do you want to do this thing, yes or no? And I said, no, I don't want to do that.
And they said, we'll come back later when you do. And I was like, no, you...
And finally, the most important one, really, from a narrative point of view.
That stuff is all forgivable, really.
But why does no one else in this world care about the flipping werewolf?
because the problem with the quest structure is it starts with this peasant.
It has to because it ends with that peasant, but that means that nobody else can tell me that there's a wolf in the woods.
They're not allowed to.
The game rules deny it completely.
The only thing they can say, and they'd say this in The Witcher, is, oh, there's something dark and strange somewhere nearby, to kind of give me a sense that maybe they know.
But then after I kill the wolf, they're still saying this, and frankly, that just describes the world of The Witcher anyway.
So.
We kind of thought about these problems.
But the fact is that Sorcery 1, the one that no one liked that much, that was too short, actually solves all of these problems anyway with what we call an encounter.
So that's a term that comes from game book design, but it also comes from basically from D&D.
And the idea is you're in a branching narrative, they reconverge, so maybe you come from the left path, maybe you come from the right path, you hit this encounter, whatever it is, it deals with it, it does it.
And then off you go.
So specifically, I'm going to the woods, I come from a path where I know about the wolf, I come from the path where I don't know about the wolf.
Either way, there's a wolf, I do that thing with the wolf that I'm probably gonna do, and then there's no wolf anymore.
Fine, that's an encounter that resolves the wolf problem.
Now, obviously that doesn't give us our quest narrative.
So how do we do that?
Well, we make two encounters.
So if I was building this storyline in Sorcery, here is what I would do, and I'll take you through the thought process, the design process that we use to build every narrative beat in that whole game.
So there are two encounters.
There is the peasant's house, and there is the woods.
So what can I do in the peasant's house?
Well, I can meet the peasant, and he'll tell me about the wolf.
Fine.
I can go to the woods, I can encounter the wolf, I can kill it.
Fine.
Okay, what else might I do?
Well, I might go and meet the peasant, but I've already seen the wolf, because I might have done these things in the other order.
I might have gone to the woods first.
So if I meet the peasant, and he says, there's a wolf in the woods, I might say, I know, I've seen it.
I might say, I know, I've killed it.
I might say, do you mean this wolf?
Here's its head.
And he goes, well, that's a bit sudden, but thank you very much.
Equally, I might go to the woods and encounter a wolf, and I might run away.
That's a pretty reasonable thing to do if you're in a woods and you see a wolf and you haven't been promised a chicken for killing it.
You might just think, I'll leave that behind.
So the player is already able to bounce between these two scenes.
Maybe the peasant tells you about the wolf, you go to the woods, you choose to run away, you go back to the peasant.
Oh, we should probably catch that.
Okay.
So I revisit the peasant.
And I say, sorry, saw your wolf, didn't kill it, haven't really helped you yet.
The peasant might say, well this isn't very good, you're supposed to be a witcher.
So all right, I'll encounter the wolf again.
So maybe I kill it, we've covered that, fine.
Otherwise maybe I run away again, because, I don't know, maybe the wolf's really big actually.
So I go back to the peasant house.
But we need to close this narrative arc off because it's turning into a bit of a farce at this point.
So, okay, maybe the peasant has disappeared.
He's given up on me.
That's good because that means this house has no longer got peasant in it and I don't need to worry about him anymore as a narrative designer.
And I go back to the woods.
There's no sign of the wolf.
He's curled up in his hole, happy.
And I just find the peasant's chewed hat.
lying on the ground.
And there we have another ending for our narrative arc.
Wolf's head or peasant's hat.
Those are our two outcomes.
And maybe I can sell the peasant hat for like three gold pieces in the market.
Fine.
And this is how we build sorcery.
Basically, you start with a basic quest and you start just sort of chucking the plot backwards and forwards between the two, filling in the sort of possibility space and finding endpoints.
So is this mega complicated to do?
Are we like super geniuses for pulling off this incredible feat of narrative design?
Well, look, it's not as easy as building a quest.
I knocked out what the peasant's house encounter looks like in a flowchart.
If you've ever heard me talk about narrative design before, you'll know I think that flowcharts are for office managers.
So if you enjoy this, I think there's something wrong with you.
But broadly, the red box is a content.
The blue boxes are conditions, and it just kind of drops through from top to bottom.
So I go in.
Is it my first visit?
Am I revisiting?
Is my patient?
Is my patient?
Is my peasant impatient?
Is the peasant gone?
Whatever.
Bosh, bosh, bosh, bosh.
And then either I leave empty-handed, perhaps having increased his level of impatience, or I get his chicken.
Remember, if he goes off to kill the wolf in the woods, then he's left his chicken behind, so I can just snarf it anyway.
So if the chicken is important...
I still win.
How do we actually build this thing?
Well, we don't use flowcharts at Inkle.
We use code.
There's no point calling it anything else.
This is Inc.
This is actually Inc. 1, which is the version before the version that we open-sourced, which you can play with yourself.
But that's...
Taken from Sorcery 4, where we have a bottleneck outside the chamber where the Archmage, the super villain of the series is, and you can arrive here on your own.
You can arrive here on your own with only one arm, which is significant because then you can't cast magic.
You can arrive in the company of a black-clad ninja who may or may not be your lover, with a girl who can turn invisible when she closes her eyes because she's grown up drinking the milk of the Snattercat.
with a small little demon thing that also stops you casting spells, which is a convenient confluence of logic, or nobody, or a combination of the two, and possibly with the body of a person that you accidentally killed on the floor here as well.
And all of those states are handled by the green things.
The green things are little logical conditionals, and they sit on every line of text, and pretty much every option, the options are the red star things at the bottom.
saying, if this logic thing is true, this is allowed.
If it's not true, it's not allowed.
So we just switch things on and off, depending on the context.
The interesting thing that I want to point out as well is at the very, very bottom of the slide, there's one option with no green things, one option with no logic, which is ready myself.
Now, speaking as a writer to a room of people who may be writers, ready myself is a rubbish option.
I'm at the end of a four-part adventure, I'm outside the Mount Doom location of the whole story, and I choose ready myself.
Well, that's nice.
So it's a little bit above brush my teeth as a thing to do before preparing for a final battle.
But we have to have it because I have no idea what circumstance you're arriving in this location in.
I've got no idea what combination of factors you've got switched on or off.
and I need to make sure you've got something you can do.
So that's a kind of fallback option for players who have had the most dull experience in the world, who have just wandered into this location, no idea what's going on, haven't prepared.
Well, at least they get to ready themselves.
That's nice, isn't it?
That is in the game as well.
So to describe what this principle really is, we call it defensive logic.
That's our in-house name for it.
So the idea is we build every encounter in a completely ad hoc way.
Every single scene is written to cope regardless of the game state.
We make no assumptions about what you know or what you don't know when you get to the peasant's house, when you get to the woods, when you get to the Archmage, whatever.
We will cope with things like the player not knowing that the Archmage is in that room.
even if that's probably impossible to generate, because it's much harder for us to work out what states are possible and impossible than it is to just cover the case anyway.
And generally speaking, as the game expands, you start to hook things back together and things that were impossible become possible.
and then finally you ship the game and your players find that things that you were sure were impossible are in fact possible.
And if you've caught it, they think you're magic, and if they haven't caught it, you patch it because they're right and you're wrong.
The way that we do defensive logic is just with preconditions.
We shove logic, those little green things, on pretty much every line of text, on every action.
We just constantly guard the story against going the wrong way.
So if you're going to talk to Flanker the Assassin, every single time you do that, it'll say...
Have you got Flanker? Are you sure you've got Flanker?
Have you still got Flanker?
It's like my mum when I go out of the house when she's staying with us and she's saying, have you got your keys?
Have you still got your keys?
You really need your keys now.
It's defensive logic.
It's making sure that absolutely, definitely you don't lock yourself out.
And then finally we have a fallback.
That's the ready myself option.
It's the what happens when nothing can happen.
And in general our principle is that fallbacks should be competent, but they shouldn't be interesting.
The main use for a fallback in reality is for when a player does that thing of going backwards and forwards and backwards and forwards and backwards and forwards and backwards and forwards and you don't actually want to reward that player, you want to just get out of the way as fast as possible.
Whatever reason they're doing that for is their business. The story should just shut up for a while Interestingly, that's probably less important for a game like The Witcher.
In Sorcery, we cannot have a blank location.
If you're walking from here to here, across a path or something, we have to narrate every step of that journey because text is all we've got.
In The Witcher, you can probably just travel in silence for a while.
You may not even need fallbacks.
If you enter an empty hut in The Witcher, it's just an empty hut.
You don't need to have Geralt say, I looked around the empty hut and thought, oh, nothing here.
So that's how we build our encounters.
Now, encounters are critical, and breaking away from the quest structure and moving towards the encounter structure allows us to tell narratives which the quest structure sort of implied, like the peasant and his hat, but didn't actually support or allow.
So our system has already beaten the Witcher system in that we can give you multiple ways to play the same plot and get the chicken at the end.
So, when I said that I thought it was better, it's because I think it's better.
But, there are still problems to solve, and that's why we need the second thing, which is state modeling.
So, in a normal open world game...
The player's knowledge of the world and the state of the plot are both outputs of the quest system.
So that means if you want to know, does the player know something, you just look at the relevant quest and say, have you got to this stage yet?
Like, should I put the witches in Crinkly Bog Manor Marsh?
Well, has the player hit that stage of the quest?
Do they know about them?
If so, yes, otherwise no.
And that's very robust.
It's very simple.
It's very clear.
You know where all the information is.
It's in the quest system.
We can't do that.
Actually querying encounters to work out what you've seen and what you haven't seen, what you've done, where you've been, is horrendously complicated and kind of breaks the point of ad hoc design anyway because you want to make your encounters, like your peasant encounter, in such a way that you can come back to them three weeks later, having completely forgotten how they fit into the rest of the game, and add more fiddly stuff.
or cope with another consequence, or handle the fact that you might actually have a companion with you now, or all of this sort of stuff.
And you don't want to break queries being used elsewhere in the game by adding that complexity.
So what we do is we model all the plot and all the player knowledge outside of that with a separate system.
And hopefully you will enjoy what the system looks like, because it looks like a state machine.
And again, hopefully some of you are saying, ah, that's a quest, isn't it?
You've just said you don't do quests, and you put quests right back in again.
So my job for the next 30 seconds will be to convince you that this is not a quest.
But it looks a bit like the quest.
So here's our state machine for the wolf.
and it tracks the wolf plot.
So to start with, I know nothing about a wolf.
Then I know about a wolf, then I've seen a wolf, then I've killed a wolf, and finally I've cut a wolf's head off.
The peasant, being a human being, is worthy of two state charts mapping the two things that the peasant can sort of move through.
I can meet him.
I can hear about the wolf, and he can be grateful that I've killed the wolf, fine.
Or he can get impatient, he can go, and then I can find him dead.
But I'm asserting that these are definitely not quests in disguise.
And the reason for that is really simple.
The trees are not player targets.
I'm not presenting these to the player, in fact the player will never see them.
And I'm not saying you're supposed to max out every single one of these trees.
In fact, they're probably mutually exclusive.
They are not quests.
They're not there to provide the player with a goal.
They're there for me, as the narrative designer, to work out what the bloody hell is going on from moment to moment.
So, how do we use them?
Well, we have one particular thing which makes them super useful and I think is quite clever, and that's that the way we design the state machines is one, there's one important rule which is that states always imply their previous states.
So if your current position in the game is this, I've seen the wolf, I've been told about the wolf, and the peasant's getting impatient with me, what that really means is this.
I know about the wolf and I've seen it.
I've met the peasant and I've been told about it, and the peasant's getting impatient with me.
So every state in our state tree is a high watermark.
It says you've got this high, and everything below it is also true.
And that's really powerful, because it means that if you want to set a state, you just set a state, and all of this stuff comes in for free.
And if you edit that state chart to add a bit more granularity, perhaps the peasant has hinted about the wolf, and then the peasant has told you about the wolf.
You can do that without breaking a single query in your game.
Because if you're testing, well, have I heard about the wolf?
I'm still covered, because I'm just adding stuff into the detail of the high watermark.
If you imagine I'm just adding another division between what I want to test and what I don't want to test.
So in practice, what that kind of means is we query states, we say, have you reached this state?
Do I know about the wolf?
Yeah.
Have I seen the wolf?
Yeah.
Have I killed the wolf?
No.
Fine.
Easy.
And more often, we test between states.
So we say.
Am I between having been told of the wolf and having killed the wolf?
If so, that means the player is expecting there to be a wolf in the woods.
And I can use that to change the way the narrative says, you know, how you enter the woods. You're expecting a wolf to be there.
Similarly, is the state between having met the peasant and the peasant having gone?
If so, it doesn't matter what the exact state set up is at all.
If I've met him and he hasn't left, I think he's at home.
It doesn't matter if he's impatient or not impatient.
It doesn't matter if he's happy or sad.
It doesn't matter how many times I've tried to steal his chicken from him under his nose.
If I've met him and he hasn't gone, then I know he should be at home.
And so this gives us a really quick, really light touch way of assessing logical situations.
But we still have lots and lots of granularity.
So I can test for exact combinations that I want.
And I'll demonstrate that in just a moment.
One more point just to really get this idea in.
When you're changing state.
We use this command in Ink, which we've made, which is called moveToState, and it doesn't do anything if you've already hit the state.
That's kind of a high-watermark idea.
So if I move to knowAboutWolf in this example, nothing happens, because I already know about the wolf.
I don't edit the sort of highest states because I've just earned the lowest state, it wouldn't make sense to.
But if I move to the state peasant found dead, then it whoops through this state tree and now I'm expecting the peasant to be gone as well.
So if somewhere else in the story it says, do you think the peasant should be gone?
the story will still report true because, hell yeah, I just found him dead.
Of course I expect him to be gone.
So I get that state for free.
So what these really are is they're not quests.
They're state trees that depict the causality in your game.
The thing that caused the thing that caused the thing that caused the thing.
And that can be player knowledge or it can be plot events.
And they let us capture an enormous amount of complexity.
For example.
I've been playing the game for a while, and this is my state tree.
So the question that I put to you is, what's the current state of the story?
What has happened to the player to achieve this?
So the wolf's head has been cut off, the peasant has told me about the wolf, and the peasant has been found dead.
So what's happened?
Well...
The peasant told me about the wolf, but I didn't do anything.
He became impatient.
He went out to go and kill it.
I found his body, and I killed the wolf in revenge.
That's a narrative that did not exist in the original Quest example that I started with.
It just wasn't there. It wasn't possible.
Is that emergent procedural storytelling?
I don't know. It's made out of little pieces that fit themselves together.
But it is a unique narrative to me based on exactly what I did.
And you don't get that in any open world games.
So I think that's incredibly exciting.
And I also think that diagram is incredibly simple.
There are what, 10 states there?
13 if you count the null states at the beginning of the tree.
That is not a lot of information to keep track of.
But the subtlety that it stores is, I think, quite exciting.
And if you've played sorcery and ever had those moments of sort of, wow, it's really listening to me, magic, that's what's going on.
There's just lots of little state machines futzing around in the background.
Cool, so I've raved about how we make our things, and that's all very well and good.
And I want to talk a bit more about the benefits and a bit more about the costs, because of course this approach has both.
But I won't bore you with repetition, so I'll talk about some of the unexpected benefits.
The important thing to remember is we didn't do this because we're super clever and we had a big idea.
We didn't theorize this.
We built Sorcery 1, we built Sorcery 2, and then we built Sorcery 3 as close to the previous books as we could possibly manage.
We used encounters because we'd used them before.
Because we didn't want to make a completely different game and surprise everybody.
We wanted everyone to think, oh, it's just Sorcery 1, but with backtracking.
Which is kind of what they thought.
But having built it that way, we saw a few things emerge from that design.
The first is my favorite.
It's the most important.
It's the one that I think that really elevates this, which is plots can start in different ways.
That's impossible in The Witcher, to my knowledge anyway.
I haven't seen their tool set.
In particular, anyone in the world can tell you about the wolf in the woods.
Anyone.
any single individual in that village can say, there's a wolf in the woods.
We move your state to now you know about the wolf.
Okay, well what if you then go and talk to the peasant with the chicken?
Well, fine, we've covered that already.
You walk in, he says there's a wolf in the woods, will you say, I already know.
I haven't been there, I haven't seen it yet.
We've actually covered that eventuality already because we're tracking the player's knowledge separately from the encounter itself.
the encounter just copes, because we did it in an ad hoc defensive way, so that it would cope.
So I can add in during the writing process, at any point, warnings about the wolf.
I can put this near the beginning of the game if I want to, for some people who find a certain thing.
And I can do that freely, I can do that in the beta testing stage, and it's utterly robust.
Well, not utterly robust, but it's quite robust.
Secondly, to develop that idea, we use our state trees to drive the plot forward.
So in Sorcery 4, on your way to the Archmage, the big barrier are these things called the Throbin Doors.
And to start with, you've never heard of them, and this is their state tree.
So firstly I've heard of them, great.
Then I know that they're locked.
Oh, what a surprise.
Then I learned that only sorcerers can open them.
Luckily, guess what my job is?
Then I learned that they're locked by spells.
Intriguing, OK.
And then I learned that they require counter spells to open them.
And then the player goes off and finds out what those counter spells are, and we've got a lock and key system.
Brilliant, go me.
But.
As I wander around the world, several characters in this world, pretty much all of them actually, can give me a clue towards the puzzle of the Throban doors, and whatever I do, whoever I help, they will always give me the next clue along.
No one will ever just tell me the answer, no one will ever repeat a clue I've heard before.
They'll look at what I've got, and they'll give me a nudge along.
Fine. Really simple.
You might say, that's cheating.
How does this guy here know that they're locked by counter spells?
How does this one know that there are doors?
Shouldn't people know what they know?
If the player rewinds and goes a different way, shouldn't they get the same dialogue from that character?
No, obviously not.
That's a stupid idea.
To be a little less glib, it's necessary in an ad hoc game.
When you get to any given point, we have absolutely no idea where you've been, what you've seen, who you've talked to.
There might be someone with a critical piece of clue information who you accidentally blew up from the outside of his house without thinking about it, and you never even met.
We support that kind of thing, so we cannot put key piece of evidence in only one place.
Or if we do, we have to do that incredibly carefully.
And I'll mention that again in a moment.
So, okay, cool.
The other thing that it gave us was simulationist gameplay-ish sort of thing.
We're obviously not a sandbox game, and we don't pretend to be.
But there's a couple of places where we've managed to do sandbox elements, which has been really exciting.
So in Sorcery 3, there's this guy who is the Sun Serpent.
Water is his kryptonite.
Once you learn that, you can look at the map.
And any river, lake, or pool, if you go there, there'll be an option to drop the orb that he's trapped in into the water, and it runs the fight a wet Sun Serpent encounter.
I think I said earlier that encounters are often locations, but they don't have to be locations.
In this case, that particular fight is an encounter that we just plug in wherever we need it to be.
It's got a precondition that says, do you actually have the orb with the sun serpent?
If so, here's the option to drop it in, do the fight, and then come back.
If any of you have been using ink, that is a tunnel.
It just uses a tunnel.
It blobs off and does it, and then it comes back again.
A beta tester also pointed out that they wanted to be able to throw it into the mouth of the water serpent Because the Sun Serpent and the water serpent are like these star-crossed lovers who can never be together Isn't that tragic? Doesn't that make you well up inside? So we added that and that was a lot of fun That isn't really an example of simulations gameplay though because we wrote a bespoke little piece for that. Whatever. I just like it Another example along the same lines, there's a section of Sorcery 3's map, it's actually a third of the entire map is a lake.
It's actually just one location in the game, with a coordinate.
the player moves from an identical lake location to an identical lake location to an identical lake location, obviously that would get quite dull quite fast, so what we do is we have a big bag of encounters and we just pull from it to give them content.
And by doing it that way, we can balance it.
We can balance the drama against the quiet moments.
If they're really tanking on stamina, we can give them a rest.
If they're doing well, we can give them a monster.
We give them a fight with the water serpent, but we make sure we do it when they're far away from land, so it's a bit more dramatic.
Even better, we have a bag of content for when they're swimming, a bag of content for when they're rowing, and a bag of content for when they're in a boat with a grumpy ferryman.
And because we have that, that means that the player can jump overboard at any given time.
We just switch them to the swimming content.
But they can also push the ferryman out of the boat and then end up in the rowing state and row off.
And we can do that anywhere on the map because we just flip from one encounter to the other using our system.
We just say, what state are you in now? Okay, have some swimming content.
Cool.
So simulationist gameplay, if you think about it, means that we can start to have strategic gameplay.
So in Sorcery 3 and 4, we started to add new mechanics, adding a level of strategy.
Now strategy, you don't normally get strategy in choose-your-own-adventure type games, because the player has no way of predicting what's going to happen later based on what's going on now.
Normally, strategy is reserved for the other talk that I've mentioned too many times already.
But we do have some strategy.
In Sorcery 3, if you've played it, you'll know that there are time beacons.
That's what they look like, it's like a beam of light, and in the light, the wilderness wasteland reverts to how it was a thousand years in the past.
when it was lush and green and full of villages and things.
And these beams, there's seven of them on the map, the player can position them in an entirely analog way.
So you can push them around wherever you like, lay them across the map, then you go down onto the map, you walk, and you walk along, and if you cross the boundary, you change into the other period of time.
So if you point your light at a village, you can go down and you can walk there.
The narration of the game handles the boundary transition by looking at what kind of environment you were in before and where you are now.
So it might say something, if you are walking along the top of the map there, it might say the dusty plain sort of breaks with a few blades of grass, which push up between the stones and suddenly you're in a field of flowers in the sunshine.
And you get this liminal transition, but that's basically procedurally generated.
We can transition from any environment to any environment.
And I wrote a transition for all of those, and I don't know if all of them are possible, because I didn't bother to check, because it was pointless to bother to check.
It's an analog system. Maybe there's a time you can go from the forest to the marsh.
Maybe there isn't. It took about 20 seconds to write. It doesn't matter.
Strategically, that means that the player can do some quite cool things.
They can say, that area of the map looks dangerous.
I'll put a time beacon on top of it, and then I don't need to walk across it.
I can use it as a bridge.
We have several repair the bridge type puzzles as well.
And if you shine it across the lake, the ferryman that I mentioned earlier, he's in the past.
But if you go outside the beam of light, well, he's there 1,000 years in the past, and he vanishes, so you fall into the water.
which is a great platform that the player set up for themselves.
I'm not sure that counts as strategy.
In Sorcery 4, we implemented disguises.
We had a small number of them.
You can be a monk, a merchant, a guard, or a guard captain.
We hid them in a couple of places, but we didn't really think too hard about where we put them.
They change how all of the characters in the game relate to you.
So merchants give better prices to other merchants.
Guards will let guards into the guards hall.
Everyone's scared of monks, that kind of thing.
The game just copes with everything, and we didn't need then to balance or check the logic.
And we put it out in the world, and players started to form strategies, optimisation strategies.
They'd say, well I'll go over here and get the monk uniform, which lets me scare that guy, but then I get this one and I change into a merchant, and I go over there and I buy the thing, and then I go back here and I get the guard uniform, and then that gets me into the mess.
And we'd go, knock yourselves out, fantastic, whatever.
Is there a better strategy? I don't know.
I designed this game, but I don't know. I don't care.
It allows for interesting strategic thought in a narrative context.
It's good enough for me.
Which, if you think about it, leads on to the next unexpected benefit, which is emergent solutions.
What I described with the disguises is just an emergent solution.
We ended up with more of those than I would have liked.
both in Sorcery 3. The first one was the no beacons all serpents run.
So it's really important for the narrative that the player uses these time beacons because it turns out that they have a cost but you don't know it at the time.
But some players managed to get all the way across the map without using them and killing all the seven serpents along the way.
We didn't think it was possible.
I've never even done it myself.
We had to patch in a new ending to cover it and then sort of give those people a reward into book four.
But those players weren't done.
They then found Ebran, the god of gods.
So in sorcery you can have a god.
The gods are a bit weird.
They tend to commentate slightly on what you do.
We put in Ibran simply as a joke about Brian Henderson from Curiosity.
He was supposed to turn up, moan about the fact that he had no power over anything at all, and then go away, get on with his life.
And he was supposed to disappear, but some players got Ibran, managed to get to the end of the game before he left, and had him in Book 4.
which I didn't even know until we'd written most of book four and then one of the beta testers quietly asked about it and I thought, oh no.
So we added Ibran as a proper companion character who unlocks some special, some particularly fun easter egg special content towards the end of the game.
So, costs.
We've got this wonderful new system for building open world games.
We're going to revolutionize narrative in a fully authored yet procedural way.
The future is our oyster.
Bob's your uncle.
What are the problems?
Firstly.
Okay, it's a benefit in disguise, but unpredictability.
You really don't know what the player has done at any point.
You can't know.
You can't really guarantee anything.
For example, do players know enough of the plot?
In 80 days, do you know why you're going around the world with Velia's fog?
It is possible to get through the entire of 80 days and never be told why you're doing this.
And I must admit, I break my own rules here.
About halfway through, we just stop testing this flag because I'm sick of dealing with it.
And about halfway through, it's assumed that Fogg might have just mentioned it idly off-camera to Passepartout.
Because, of course, players know why they're going around the world, even if Fogg hasn't explicitly told them.
But there is a nice kind of point in Venice when Passepartout can still be bumbling around in the state of some confusion, thinking his master might actually be a spy or a drug dealer or something.
You can get around that.
You can, of course, still use bottlenecks in your map.
80 days doesn't have any.
Sorcery 4 has quite a lot more plot points we want to hit.
So we did use bottlenecks.
A nice trick is often to use like pairs of bottlenecks.
So in Sorcery 4, when you go into the citadel, there are two doors, and then to the inner citadel, there are three ways in, and then to the higher encampment, there are two ways of doing that.
So there's still choice, there's still variation, there's still strategy, and then you just trap both of those bottlenecks with whatever it is you want the player to know.
So when you get into the citadel in Sorcery 4, there's this crazy old beggar who catches you for plot reasons.
That's sort of a running joke, there's always a crazy old beggar in sorcery all the time.
And so he will catch you, whatever you do, although again, towards the end of development we found that if you get stung by bees and rescued by monks, you can dodge the crazy old beggar, so we added that as a plot thread as well.
So you can actually complete the game without a crazy old beggar, which is kind of a feature for a sorcery game, but not very many people found it.
It's just fun.
In general, the major encounters can still be forced to happen, but interestingly, often with varying causes.
So players might say, well, this thing happened, but it happened for a different reason.
To me, that's quite exciting.
That's quite interesting as a direction.
And it's very different than what the Witcher is doing, right?
The Witcher has the same cause, but you often choose the ending.
So this is kind of the other way up.
The second big cost, and if you're working in any kind of big studio, this is almost certainly the most significant cost to you, is redundancy.
You just have to accept this if you're going to go down this kind of design.
Almost all of the content you make will go unseen by any given player.
Someone who plays 80 days once will see about 3% of the game's text and not see any of the rest of it.
And if that hurts you inside, go write a Twine game.
Sorry.
But, all of your content will be seen by someone.
Even the most obscure content will be seen by someone.
Everything will be found by someone and that person will appreciate it.
And the fact that there is content that people don't find makes the content that they do find more precious to them because they know that it's special.
So again, I don't see this as a cost, but if...
Then again, I don't do voice recording for every line of dialogue in my game.
I don't do motion capture for every argument that people have.
For us, variant dialogue is very cheap, which is convenient.
And I don't know if you can read the tiny stripe in quiet, but I'll let you read that for yourselves.
Finally, bugs.
Obviously, there's no dodging it.
If you use this kind of system, you have more logic.
You will have more bugs.
You'll have to find them.
They are harder to find because you can play in more ways.
The flip side is they're actually a lot easier to fix.
Almost always, by the time you've found a bug, it's completely obvious what the problem is.
You just forgot to put a precondition on an option.
99% of our bugs are someone says, Flanker's just appeared.
I wasn't traveling with Flanker, but now I can talk to him.
Well, we drop in, we add a condition, the problem goes away.
Not all bugs are like that, as it says.
Sorcery 3 we shipped with about 15 serious GameStopper fatal bugs which destroyed people's adventures.
Luckily, Sorcery has a rewind mechanic, so you can actually ship a patch, rewind back, and play on.
But not all problems get caught that way.
One of them was that the water serpent only appeared once.
There was a bug with the way that the bag of lake content was offering up encounters.
The water serpent wasn't revisitable, so various people saw it, ran away from it, and then spent days and days and days and weeks of game time scouring the whole map trying to find this serpent, which could never appear again.
And that's a bit awkward and a bit unfortunate.
Good news is, for Sorcery 4, we got some more testers and we had fewer bugs, so that was nice.
And obscure bugs aren't really hit by that many players anyway.
So I think there's probably a trade-off there, but then again I don't have to answer to any shareholders or, for the moment, to any external QA departments.
And that's it. I can't think of any other costs. I think it's great.
So for our next iteration at Inkle, we announced this the other day, we're moving on to a game called Heaven's Vault.
It's a graphical game. It's an open world game.
It's not quite a Witcher game in that as you travel the open world, you go down into locations, which are their own little hubs, and then come back again.
So it's structured more like Mass Effect than like The Witcher.
That solves a few problems.
You can't be halfway through a scene and then just leg it out the door.
But you do have quite a lot of freedom to explore around.
The actual construction is a mixture of content that you can only do once, and content that you can do in any order, and places that you can revisit that expand over time.
So hopefully, we don't have to do too much logic everywhere, but we'll have a few places which are very, very clever and responsive, and then a few places which are kind of set pieces.
We're doing it with graphics, not prose, which means procedural events like the sun serpent orb example that I gave are basically impossible because we need to ensure that they fit with the geometry and that's harder to ensure, but procedural dialogue is well in.
Our two sidekick characters have an enormous bag of things they can talk about.
They're all guarded by preconditions which say things like, is this relevant to what you've been talking about before?
Is it something you saw recently? Is it something you're thinking about?
Whatever. And they'll drag up these conversations as you move around, go through them.
So we're using a lot of, again if you're ink users, we're using a lot of threads to sort of pull in content from different places.
And finally, it's all about player knowledge.
The whole construction of the game, the whole unlock tree of the game.
We don't really have an inventory.
It's all, what do you know?
Where do you think you need to go?
So there will be hundreds, thousands, I don't know, paths through the game's various discoveries.
But I'm pretty confident that because we have our high watermark knowledge system, that so long as everything you do pushes something forwards, everyone will eventually reach the end that I need them to reach.
And hopefully I don't even need to worry about that too much.
I just need to make sure if there are any...
I ask this in every talk.
If there are any mathematicians in the audience, it's basically an inductive structure.
So long as everywhere has the ability to add one, you will eventually reach any number you need.
Well, in our case, as long as every scene has the ability to push something along somehow, you will eventually move forward and reach the end of the game.
You might go a long way, you might go a short way.
And as they say in film, we'll fix that in post.
And that's it.
Thank you very much for coming.
I really appreciate it.
I know I was up against Firewatch as well.
Thank you for listening, and we've probably got a couple of times for questions.
Cheers.
Hey.
Hi.
I can reach this.
With the stuff you're saying about bugs and hardly found paths and stuff, have you guys looked into doing some kind of programmable...
algorithmic traversal of the thing so you can find the edge cases by just like iterating through every single possible combination?
Sure, so the question is basically have we built what they call a pad basher like an automatic player?
Yeah so for Sourcery we didn't and I wish we had and mainly it was because the code base was quite old and the map traversal was hard to automate and we were up against deadlines.
We're doing a lot more of that for Heaven's Vault.
I already have in my prototype, one of the first things I built was something that just bashes through content.
It's been invaluable in finding places where the flow dies.
What it can't find is places where the flow contradicts itself.
One of our biggest issues is always continuity errors.
So somebody will...
We've been showing a demo to the press in the last couple of days, and one of our wonderful journalists walked up to the outside of a great, beautiful...
and she pressed the conversation button and our archaeologist said, I think the tomb is buried underground.
That kind of thing.
And a pad basher can't catch that.
But any automation you can do is obviously helpful.
So yeah, we are definitely interested in that.
Hi.
Hi.
Does your system use probability at all?
Like you'd go to a place and you have like a 90% chance you'd get this state and a 10% chance you'd get some other state?
Right, so the question is do we use probability in our designs, like that classic D&D role for whatever.
Actually, we don't, and that's kind of stylistic, I think.
I guess I always feel as a writer that at any given moment when the player makes any kind of choice, I know what I think the best thing to happen at this point is, and I'm more interested in that, and I think my audience is more interested in that, than one option which is okay and one option which is less fun.
So I would always rather make sure that every action has a good response, rather than try to come up with multiple responses, all of which are kind of okay.
I understand the attraction of probabilistic games, but I think they're probably better suited to things with repetitive, or generic, or repurposable content, rather than things where I have specific encounters that I wish to give you.
So our equivalent of it is really that when you say something to someone and it says, do you know this fact? If so, talk about this.
Do you know this fact if you talk about this?
Because although that's totally deterministic, in practice it's random because I have no idea how many players will know, be in this state, how many players will be in that state, how many players will see this stuff.
So that's our take on it.
Probability, doing probability just feels like you need to write more for no actual extra gain, but whatever your view may differ Thank you. It's probably time Sorry, actually that's bang on 11, so we better stop I'll go to the wrap-up space upstairs if people want to still ask questions. Otherwise, yeah Thank you very very much for listening. Cheers