I've somewhat ranted a little bit about this in the past and that I think design and AI are very linked.
I think that what I want to rant about is sort of codifying that a bit.
So, oversimplification is bad, right?
I've even had other rants where I've said, AI that oversimplifies how it looks at you is pretty stupid.
If it reacts to everybody in the same way, that's stupid.
And likewise, if companies don't have a rich enough model of me, I think that's pretty stupid too.
And it doesn't matter what model they use, right?
I think a lot of simplified models are pretty dumb.
So the problem is humans love to bucket things.
They just love it.
We're classification engines and it just sucks.
Programmer, artist, designer, producer, these are buckets.
And they're not very good ones, especially because a lot of us are mixtures of these things.
Even games do this though.
We have tanks and DPS and whatever.
Although a lot of the better RPGs recognize that the combination characters are some of the more interesting ones to play, right?
But in real life.
You have dedicated career builds, and you have a severe penalty for respec.
And if you do do quests outside of your main line, you're sure as fuck not gonna level up.
So what I'm saying is that there should be a big five of developer skills.
And I'm not talking about personality-wise, I'm talking about actual sort of skill set-based spec of what you do as a human being in the thing.
So now programmer, designer, artist, producer are sort of buckets of skills.
and instead of an AI programmer, you're a mix of them all.
And I'd also recommend having some optimal specializations within each.
So if I'm rated P7 AI database, that means I'm a seventh level programmer with AI and database specialties.
D1 means I don't really have much design space in my head.
AI audio means I'm probably the audio guy for the company and PR6 remote means I've got really high producer skills and I've specialized working with remote teams.
So let's do this.
Here's an AI generalist.
Now this graph, instead of pointing at an entire team, points at a single person.
He's a P7 AI D6 A2 PR1.
It means he's an almost 50-50 programmer-designer split.
He has some good art tendencies, and he has a slight notion of organization.
I would call this guy a textbook senior AI programmer.
This is kind of what I look for when I'm interviewing a senior AI programmer.
AI specialist.
Here's a different mix.
P8 AI D4 systems A5 animation P3.
This guy has.
He's a really high-level programmer, but he's also a pretty decent artist who specialized in animation.
And he's also a systems designer.
And he has quite a bit of organizational skills.
He probably loves working in heavy AI animation systems, especially with IK or mocap.
And he even has the organizational skills necessary to handle the heavy asset notions that you have to do when you're dealing with that kind of stuff.
And I know all of that by reading that thing.
I don't even have to, like, look at his resume down there.
It doesn't just work with AI programmers.
Here's a bunch of tech artists.
P7, GraphicsD2, AA, P2 is probably a shader programmer.
Just by looking at that, I can tell you he's probably a shader programmer.
Here's another one.
P3, D6, UI, A7.
This guy's still a tech artist, right?
He has an A7 artist, just like the guy above him had an 88, but he's half the programmer.
But he could probably design and implement the entire UI system for your game all by himself.
Here's an exact similar guy, except he doesn't have that UI specialization.
My guess is this guy's probably a lead artist of some form and has had to wear many hats over the years, or he's a prototyper or an indie who's by simply not having a lot of people around has had to have a lot of hats on and has had to do a lot of things.
So stop the oppression of the pure disciplines.
It's not helping us.
What the fuck is a technical designer or a creative coder or an advanced experience developer?
Those are meaningless garbage ways to try and show a blended discipline skill set and they don't give me any actual information as to what you do.
I spend the entire time talking, I could spend two years talking to you and not exactly know what a creative coder does because 90% of people have a different definition of that.
So the other thing is is that we should have these different skill buckets so that if you do improve other parts of your skill set, you actually get recognition by the company.
And you can actually get raises and bonuses and level up based on any given skill set.
Like if you need to improve your art skill sets for a particular game, or your design skill sets for a particular game, you get the recognition of doing that.
As opposed to like, I'm sorry, you're a programmer, and the guy who's reviewing you only knows how to review programming, so tough noogies, you didn't get five more programmers under you, no cheese for you.
And finally, I think this should really help start breaking down the discipline walls, because goddammit, we are all a mix.
And just like in real life, stop the oppression of purity.
Let's go for it.
Thank you.
I didn't expect going after Brian, so my slides kind of suck.
Since I'm Canadian, I want to apologize.
I'm not talking about any one of you.
If you feel targeted, see it as motivation.
If you don't, but know someone that should be targeted, try to mentor them.
So basically, I want to bash the gameplay programmers that let themselves go.
So let's start with a little story of a little boy who wanted to be the very best the world has ever known, Ash Ketchum.
A lot of programmers start their careers trying to be the best and want to learn so many things, but as they work on games and go from milestone to milestone, I feel like a lot of gameplay programmers let themselves go, whereas engine programmers try to be a bit more structured.
I wish gameplay programmers would continue using the broad range of data structures, algorithms, and focus on efficiency in their designs.
A lot of time we take the shortcut saying, oh, but I need to be flexible and revise my game because the game designer wanted this change or that change.
I feel like those are excuses.
A lot of programmers stick to only STD vectors or the equivalent in their game layer.
That's kind of crappy, and I think we owe it to ourselves to at least know when to use other containers, and if your gameplay layer doesn't support them, I know a lot of game engines only support dynamic arrays for gameplay programming, take the time to try to learn how to extend the language and create new containers if you need to.
Also keep an open mind, there's not only utility systems, or there's not only finite state machines.
Try out stuff, try behavior trees, planners, whatever you need to try, and experiment with them.
Lastly, I'm trying to go fast for the other guys.
Here's a quick book recommendation, because yesterday Rez said that...
Maybe 50% of juniors you'll interview will have a hard time during the technical part of the interview process.
And that 10% of the more experienced programmers you'll be meeting will have a hard time.
Well, keep in mind that it's very likely that this 10% is already working for another company, and that 10% might be your co-worker.
So you can suggest them, like, a quick shortcut, a book like this.
It's a...
like crunching through algorithms and data structures so you can really quickly practice some computer science concepts that you knew when you came out of school that you might have forgotten over the years.
So just try to be a bit better with that.
And honestly, read books.
Buy the Game AI Pro.
Buy AI Wisdom.
Just try to be more...
Curious. Also, try tricks. There are so many things that these books give you that can be implemented in like a half a day just to play with concepts. So do it. And try to find better ways to improve these tricks that you read about. Also, if you think of something great, contact Steve and write an article.
Also, most of you guys studied this, so just try to work on it.
And gameplay code, it's just an excuse when the code sucks.
You guys can do better, so focus on being better programmers.
And also, premature optimization is evil, but doing things right is what we should aim for.
Yeah.
Game designers now.
Try being independent.
I've seen so many game designers telling me, well, I have no idea if my game design is fun or not.
I need to see it in the engines.
Don't.
You should try to be able to prototype your own stuff.
There are so many engines now, like Unity, even Unreal, that you can just download and learn how to script quite easily.
And if you can't prove me that your concept is fun with a cube, it probably won't be fun with the super expensive mocap animation.
And it's also 2017.
What are your tools?
Word, PowerPoint, and Excel?
Come on, you can do better.
And with Excel, it's quite easy to learn VBScript.
So you can automate some of your spreadsheets and try your concepts within Excel.
This will allow you to have quicker iterations, and it's easily shareable with the other people on the team.
And like I said, there are so many game engines that are.
easy to play with and to script, so even some stuff as simple as Blockly.
Our Prime Minister in Canada programmed the game.
It really sucked. You can probably do better, but it's there and it's easy to do.
Also, don't be scared to use paper design.
You can play Dungeons and Dragons, your game, and just sit at a table and use turn-based methods to test out your gameplay.
So just do it.
All right, hi, everybody.
My name is Mike, and I have a beef with magic.
We're all probably fairly well exposed to science fiction here, so I'm sure you've already heard this clich√© quote, any sufficiently advanced technology is indistinguishable from magic.
This is due to a certain Arthur C. Clarke, and since Brian did me the courtesy of already breaking the F barrier in this rant session, fuck you, Arthur C. Clarke.
I quit hitting the wrong button there.
Magic is bullshit.
And I'll give you an example of why I'm saying that.
So we have here a couple of high school graduates.
They're deciding what they want to do for their institute of higher learning, and they're trying to figure out where to go.
So where are we going to send them?
Well, we have options in the United States, colleges like MIT or Caltech, and I don't know how that got in there.
We're sure as fuck not sending them to Hogwarts.
And the reason for that is because we study computer science.
Algorithms are not magic, okay?
Solving bugs are not magic.
This remote apparently is magic.
Software is a science, and that has a very significant implication for us, which is that superstition is irresponsible.
Here's another quote for you that I'm sure we've all heard at some point or another.
I don't know, let's run another build, maybe that won't happen again.
My opinion is that this shit has to stop.
So this here is an interesting screenshot.
This is a debugger, Microsoft Visual Studio in 64-bit mode debugging the disassembly of the Guild Wars 2 game client.
And I have one question for you.
Does this scare you?
Because it shouldn't be fucking scary.
This is our bread and butter, this is our lifeblood, this is the tool that gets us our job done.
Never be scared to keep asking questions, because science itself is predicated on questioning.
And that means that if you ever stop asking questions, you're basically dead.
Computers don't run on magic, which has an interesting implication.
Our questions have answers, and we should go out and find them.
So here's another inspirational quote.
Witchcraft to the ignorant, simple science to the learned.
This is due to Lee Brackett in the 1940s.
This is a much less popular quote than the Arthur C. Clarke one, but I think much more reflective of how we should be thinking of our practice.
So, this guy here is a magician, and this is a computer scientist.
Let me leave you with one question.
Who do you want to grow up to be?
Thank you.
So, looks like we are doing kind of the same rant here.
So, my rant is called Garbage In, Garbage Out.
So, yeah, I'm a programmer.
I might be putting myself in a bucket here.
I take random designs and turn them into computer code.
And you know what, computers don't process very well.
Well, they don't process nonsense.
They just don't care what you feed them with.
So you might have heard of Charles Babbage, the father of the computer himself.
Well, guess what?
He knew about this.
Somebody asked him once.
Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?
I'm not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.
Well, at least I suppose that's how Charles talked, because that's so ancient that there's no recording of his voice.
Like, 1864.
So, some people still don't get it.
I said, you said no French, sorry about that.
Putain de merde.
So here's an example.
This is from the development of this week's title about being a top model.
And yeah, I worked on pretty awesome games.
We had a basic dialogue scripting system with some variables for a good measure.
I remember telling the narrative designer to go easy with that system.
We had no budget, no time to check for consistency.
What do you think happened?
We let our players two options.
In the story, you wander around in luxurious gardens, and at some point, one dialogue lets you date the gardener.
Because everybody loves romance involving gardeners.
And there was another dude you could date later, a taxi driver that would drive you around to your model stuff.
So that made a total of two choices.
Two choices, thus two possible combinations for which we had dialogues authored.
In the end, you could either be dating the gardener or dating the driver.
We're covered, right?
Right?
Well, no.
Provided with these options, the computer performs very advanced computations and deduces four possible outcomes.
Granted, you can be dating the gardener or the driver, but you can also date nobody, or worse, be polygamous, because the computer just doesn't care about morality.
So.
We discovered that we were missing dialogues for this at the very last moment, the evening before uploading to certification.
We had to patch during the night, fingers crossed, hoping we weren't breaking the entire game.
So I just want to make up for this to my former colleague, Martin, if you hear me someday.
Sorry, man, I know I oversimplified things.
Six years after release, we had our first user review on Metacritic, and it appears to be from a total fan of yours so you rock, Martin.
Here's another example, this time from the early stages of the development of Dishonored 2.
So let's take a guard.
He's called Michel because we call all our guards Michel.
That's the way it is, don't ask me why.
Michel is patrolling when suddenly a player enters his field of view.
So at this point, Michel starts fighting for his life and calls for help from time to time.
And during pre-production, we only had placeholder speech, so our guards barked, aperu, which is French for, let's have a drink.
The goal of these barks is to bring other guards at hearing range to the fight, not to the bar.
So let's say we have another Michel in a room nearby.
The other Michel hears the call.
and joins the fight, barking Apero in return.
On paper, this looks fair and good.
We agreed on this design, and I innocently proceeded to implement it without the shadow of a doubt.
Now guess what happens when you stress the system with more guards, and the player vanishes right in the middle of that fest?
Well, this is what happens.
There's no sound, but they are shouting Apero, Apero, Apero forever.
Because the computer just doesn't care about doing the same thing over and over again.
So let me sum this up.
So it's crystal clear for everybody here.
If you take nonsense and put it in a computer, well, it just blows up plain and simple.
It stops to respond or loops forever or crashes or worse, just pretends everything's fine until you find out that your save file is corrupted.
So the outcome is rarely fun.
That's the curse of our craft.
My point is, often the germs of failure are already present right at the design phase.
So we need to be consistent as early as possible.
Also our responsibility as programmers in our buckets is to invest time in proper error checking to prevent nonsense creation in the first place.
It's always best in the long run.
So please, every time we fail at doing so, a programmer somewhere has to pay back with a small amount of time and a considerable amount of sanity.
And if you don't do it for me, at least do it for Charles.
Thank you for listening.
Guns, shooting, cover systems, sniper AI, grenade throwing, enemy detection systems, damage systems, tactical planners, animation syncing to have realistic and gruesome kills, blood splatter effect systems.
I'm done.
I love working in AI, but I'm really sick of game AI having so much focus on combat and killing.
And it's the same shit that we keep redoing in every game.
Enemy AI is where their sole purpose is kill or be killed.
Gameplay mechanics and verbs only focused on combat.
The thing is, the only thing that evolves is us trying to make things look more realistic.
And it's actually kind of disturbing because I've started to get JIRAs with full-on blood splatter reports showing me how we can make our kills even more accurate.
So either my testers are equally getting bored, or there is a bigger issue at play here.
Now, some of my personal favorite games from the past year tend to have minimal amounts of combat and focus a lot more on socialization.
But on the flip side, I also really do love watching horror movies and action movies, which made me start to think, well, what's different?
Why am I okay with watching movies with combat, but I really dislike combat-based games?
Well, it comes down to the NPCs that we're developing and the gameplay interactions that we give to the player.
Characters on TV have a lot of depth.
They have conflict between each other.
They have ups and downs and we really care about them as they progress through their stories.
They fight, they love, they grow.
We care when they get hurt and we cringe when they make bad decisions.
But we can't actually do anything to help them because it's TV.
Games, on the other hand, have this great opportunity because we can actually interact with them.
But honestly, I rarely give a shit about any of the NPCs in our games.
They're too simple. They're designed to either protect someone, kill someone, or roam around in a big city like a zombie.
In short, our NPCs are lacking empathy and intelligence.
And this is what makes us really care about characters in cinema and TV.
I'm going to call this artificial intelligence.
as I would like to see some actual real interaction, socialization, and memorable moments that I can experience with the NPCs in our games, from developing love and relationships to hate and jealousy.
So here are a few examples for inspirations.
First off, if no one actually mentions Facade, Prom Week, and Versu, at least once in every AI Summit, then GDC will totally crash and everything will go wrong.
So...
For those of you who are new to the AI Summit, you are going to see these games mentioned at least once every year.
And the reason is because these games, these are great examples of social simulation games where the player's actions actually changes the relationships between the NPCs.
Now what pisses me off though is that we haven't actually really progressed all that much since these games came out.
What I wish is for AAA to please just copy paste one of your thousand combat systems that you've already developed and actually put some of your AI developers on some interesting socialization models.
Because what was done in these games are fucking brilliant and I want to see more of them.
Next off is Generic Shooter X.
A friend of mine once told me that when he was working on one of these games, he wrote some really interesting barks for the characters.
And basically, there's this rare moment where one of the NPCs is idling with his gun and he looks up into the sky and he goes, I hate my job.
And then he basically starts saying, this goes against everything that I believe in.
I'm only doing this for my family.
And I was like, oh, that's really awesome.
There's a great back story for one of these NPCs.
But let me guess.
There's nothing that I can do in this game except kill him, right?
Yeah.
Is there an actually family that I can go to?
Can I help out his family?
No.
Can I convince him maybe to join me and stop doing this horrible job?
No.
Because he was programmed with just one generic enemy AI behavior and nothing will actually change anything he does, which is sad.
Next, Shadows of Mordor was amazing, and I'm pretty sure everyone in this room has raved about their Nemesis system.
For once, we had a game that left us with NPCs worth remembering.
The game celebrated my losses, and it made me hate these NPCs, which was amazing.
I had an actual emotional connection to the enemies.
Now what pisses me off here is that when this game came out, everyone was like, oh, we're totally going to make a better version of this, just wait and see.
It's been two and a half fucking years and we haven't seen anybody actually build upon this amazing system.
However, yesterday they did announce the sequel, so hopefully we will see a little bit more.
On a happy note, finally, finally, last year, the last Guardian came out, and I have to say my interactions with Trico was one of my favorite AI moments ever.
What I loved was that interacting with Trico was actually a pain in the ass compared to most companion AIs that do everything that I ask them to do.
It felt like training an actual animal, which made the AI feel so much more believable.
I've probably never felt so attached to an AI character in a game because of its realistic, flawed, and loving behavior, so I hope that we develop more AIs like this.
And finally, everyone in this room, if you're involved in AI, you should be watching Westworld.
It has been one of my favorite television shows in the last year, and basically in the second episode, there's this beautiful quote.
Anthony Hopkins says, it's not about giving the gamer what you think they want, the killing, the garish things.
The players don't actually want that.
They come back to the game for the subtleties, the details, that they imagine no one has noticed before, something that they've fallen in love with.
They're not looking for a story that tells them who they are.
They already know who they are.
They're here because they want a glimpse of who they could become.
And I love this moment because to me it represents everything that I wish that we were doing with our games.
Actually having meaningful interactions with the NPCs, not just through violence.
So, in conclusion, what do I want to see more of in our games?
I want to work on the empathetic side of AI, on artificial intelligence.
I want to actually care about the characters in our games.
I want to find new ways of interacting with our games instead of new ways of hurting each other.
Combat and violence is easy, we've been doing this years, and honestly it kind of feels cheap when you throw this into your game because we know it works.
So please, let's invest more time instead into finding new and interesting mechanics, tools, systems, and AI to make games that feel new, innovative, and optimistic.
Thank you.
Hi, everyone.
So my name's Rez, and I'm going to continue what appears to be this year's trend in terms of complaining about bad practices, basically.
So how many of you have had this experience?
You're writing some system, you're coding something, you have to dig into some system, maybe you haven't seen that system before.
And your immediate reaction as soon as you look into the code for this other system is something like this.
Maybe it's this.
Or what I tend to see more often is something like this.
We've all had this experience, right?
We've all gone in and you look at some system, you're like, fuck man, the physics system is shit in this game.
Or the x system is shit.
Whatever that system is.
Hopefully it's not the AI system.
And so...
The problem here is that these are basically broken windows, and that's a term that I like to use for this.
There's these broken windows that exist in our systems.
The term broken windows, as far as I can, to deal with this kind of stuff, was a term coined by James Q.
Wilson and George Kelling sometime in the early 80s, 82, I think.
The idea is that there's a broken window, and as soon as you have a broken window, it crosses some psychological threshold that now this building is garbage and whatever, we'll just let it fall apart.
And that happens in our code constantly.
How many of you have had to deal with that, right?
Where it's like, oh, fuck it, we'll just add another three functions in here.
I challenge you to do this when you get back to wherever it is that you work.
Do a global solution search for the word hack and see how long you weep.
I did that once on The Sims 4, and it was enlightening.
So don't live with broken windows.
Why are we doing this?
We should not live with broken windows.
This wisdom comes from The Pragmatic Programmer by Andrew Hunt and David Thomas.
Everyone should read that.
If you're a programmer of any kind, or possibly even a designer, you should probably read this book.
It's a great book.
So why do we do this?
Why do we live with this?
I mean, I get it, right?
There's deadlines.
There's bosses.
So you kind of get into this mad coder mode, right?
And you just want to get stuff done.
But I'm here to tell you that the dangers of this are very real.
I worked on The Sims Medieval, and I can tell you that there was one particular file in there, and this was only one example of the atrocities that were there.
And there were good parts of the code, but there were also sim.cs, which was 13,000 fucking lines of code!
No one could find anything in this file.
And we would just keep adding stuff.
It's fine.
The class was actually bigger than this.
It was split across multiple files.
What kind of monster does this?
The answer is all of us.
We were all guilty of it, because it's like, just put it into sim.
Just put it into sim class.
It's fine.
On The Sims 4, we wrote everything.
So we're like, maybe we should not do this again.
It was actually bad enough that it was one of our things that we talked about, of like, let's not have this terrible sim class.
And we didn't. It was much more manageable.
We used components and all sorts of the fancy CS and architectural terms, but we had to be diligent.
And I will admit this, because I'm bashing on the code right now, I will admit that I absolutely added about six or eight AI-specific functions into the Sim class in Sims 4.
And then I'm like, wait, I'm being an idiot, and then I created an autonomy component and added everything in there.
But we had to go back, and sometimes we had to refactor stuff, sometimes we'd have to fail code reviews and say, no, what are you doing? Put this where it should be.
had to be super diligent.
Now, the complexity issues can rise.
I'm shocked this animates correctly.
The complexity issues can arise, right?
And these are other types of broken windows.
And that's already been touched on by people who came before me and various people around.
That if you're AI, you have this super complicated AI that's using this Monte Carlo tree search across a neural net of some Bayesian logic and does all this crazy shit.
But if your AI is indistinguishable from RAN, then what are you doing?
Or to quote Steve Rabin, why are you employed?
One of my other favorite things, this is actually a pet peeve of mine, is the swap argument.
And I don't even know why this is an argument.
People will argue about this shit.
There are basically, there are a couple ways you can do swap, right?
There's the one above, which is the XOR style of swap, which is fancy and sexy.
And then there's a lower one, which is a temp variable.
Like, who uses a temp variable?
Oh my god, four bytes.
People love this method and they hate this method.
And they're like, why are we creating this temp variable?
And since we've broken the assembly language barrier, you're not.
Like this is the actual disassembly of it in 32-bit mode.
And we're not using a temp variable because we have this thing called an optimizer.
Oh, but XOR is faster!
Well, no, it's faster six out of...
It's faster four out of ten times.
Right? The VAR swap is faster six out of ten times.
In just ten random tests of ten million that I did.
But really, ten million swaps.
What are we really comparing here?
We're comparing, like, look at this top one.
How much are you really saving?
Why are you optimizing this?
Why is this even a conversation?
And, I mean, at this point I'm just going on a tangent, right?
And I'm basically just yelling at you guys and all that stuff.
So probably I should just stop and have some kind of zen moment.
And I know it's all a balance, but for God's sake, please don't live with broken windows.
Thank you.
I gotta ask, did you do an architectural diagram for Sims?
What was that?
Did you do an architectural diagram for Sims?
Did I do one?
Yes.
Did everyone do one?
No.
Yeah.
Yes, I did.
So in the 1970s, there's this thing called the AI winter.
And before that, apparently there was huge investment in AI technologies.
And I've just learned recently that apparently we're out of our AI winter.
we are apparently inside an AI spring, according to Google.
And of course, if it's on Google, it must be true.
According to John, and I'm going to screw up his name here, I think it's G'Andrea, we're in some kind of an AI spring.
I'm not entirely sure what kind of AI spring he's talking about, possibly this one, or maybe he meant just a really early spring.
But regardless, everyone's talking about ML.
Now maybe this is a spring for John.
I mean, after all, he's the head of machine learning for Google.
And maybe I should be excited that we're all talking about machine learning.
Until I get this question.
I mean, really, about machine learning is a pretty big field.
And now, of course, I would really appreciate that there'd be a For Dummies book.
And of course, then I had to Google to see if there was a For Dummies book, and yes, there is.
Machine learning for dummies, that's how far we've come.
I'm gonna get that from my parents.
But for me in games, and despite a big increase in the number of cores on our consoles, I'm not feeling that spring.
That red line, by the way, is the increase I've seen in AI budgets.
Now, I'm not against machine learning.
I mean, there's some use for that in our games.
I mean, it is cool.
But it's not something that I feel particularly enhances my games, and I do think you should experiment with it.
But what I'm saying is I'm not seeing a translation between the increased interest in AI to a commitment to the resources, either in terms of people or in terms of real support.
But there are rising expectations.
So there is a little bit of hope, at least in the AI game dev community.
I've never seen so many reviews actually start to mention AI, at least in positive terms.
And our top reviewed game for 2016, apparently, was a simulation game.
And maybe we're getting away from all those combat games after all.
Now, the nice thing about those reviews, if you go back into them, is they're not just talking about how good the game is.
They do talk about the AI, and they do talk about gameplay.
But here's the brutal truth.
Unless you're willing to give me some of those cores, and support me by sending me to conferences such as this one, and give me time to build the right AI system, then you know that awesome machine learning feature you were looking for?
Yeah, that's not gonna happen.
Yeah, I admit it, I'm holding your AI hostage.
I'm not asking for the whole pie, just like my piece of the pie.
I mean, you can keep the GPU, rendering programmers, but maybe for us in-game AI, it's not quite spring.
Maybe it's just slush season.
Hello everybody, my name is Ben Sunshine Hill.
It does say these are Ben Sunshine Hill's slides, though. I guess that was meant for me.
Glad to know who you are.
So, I'd like to start with a small disclaimer.
In previous years, my rants have been fairly silly and light-hearted.
This year's rant is a little angrier, and so I want to apologize to anybody who finds it overly severe, and assure you all that it comes from a place of abiding friendship and respect.
I wouldn't bother saying these things if I didn't think you could benefit from them.
It's also not going to be a very funny rant, and I don't apologize for that.
The title of the session is Turing Tantrums, not Let's Giggle at Cat Pictures.
Oh yeah, just one.
Onward.
So, I was reading an article the other day, rereading an article by Jeff Orkin, the article where he first introduced goal-oriented action planning.
For a lot of us AI devs, it was the first exposure we really had to automated planning.
at least outside a CS class on stacking boxes with a robot arm.
It may not have been new, but it was new to us.
And in the article, Jeff lamented how the architecture and player experience of game AI had been basically unchanged for the better part of a decade.
Well...
GOAP didn't take the world by storm.
Even in the article, Jeff said that the results weren't quite as good as he'd hoped.
And about the same time, behavior trees started to gain traction after they were used so successfully in Halo 2.
And here we are, more than a decade down the road, and guess what?
We're still using behavior trees.
And yeah, sure, I know.
They've come a long way since then.
But look, suppose that you were starting on the architecture, the AI architecture for a new game, and you told your team, you know, I really liked the AI in Halo 2.
We should do it how they did it.
They'd say, sure, behavior trees.
Modern BTs look a little different, but yeah, it's a solid approach.
In contrast, suppose that you were starting on the renderer, and you told your team, you know, I really like the graphics in Halo 2.
We should do it how they did it.
What do you think they'd say?
Oh yeah, the incredible graphics of Halo 2.
We can use those newfangled vertex shaders.
Oh, and the accumulation buffer for all the bloom we're going to do.
They would laugh at you, because we threw out all that crap.
when we found a better way of doing it.
And then we threw out that approach too, because you don't write a renderer like it's 2013, let alone 2005.
I am truly dismayed by the stagnation I see in game AI's core technology base.
I think it is killing game AI as a creative discipline.
I believe we are killing game AI as a creative discipline.
I believe our model of what is and isn't possible is ossifying.
And by this we, I include you.
We've all twisted that knife.
No? Let me refresh your memory.
Some designer has come to you with some idea she has, some way in which the AI could serve the game.
And you've chuckled in that avuncular fashion and patiently explained to her that in game AI, many things that seem straightforward are actually quite impractical.
You've said, I will do what I can for you, but you have to understand that fundamentally, this is not something that AI can do.
And I'll go further.
I think it gives us a little thrill.
Not just how condescending we get to be.
That's old head.
No, I think we get off on gaping at the limits of game AI.
Of AI.
Because it's this grand mystery, right?
Intelligence, cognition is so innate to our everyday experience, and yet we cannot describe it or explain it or reproduce it.
We try, we fail, but, you know, there's joy in the attempt.
And joy in the retelling of the struggle.
Well, no more.
I deny you that pleasure.
I rip it from you.
You are not worthy of that joy.
For 10 years now, you have worshipped at the altar of transparency, of authorability, of convenient, elegant mundanity.
You have mistaken what is known for what is possible.
You have mistaken what is easy for what is practical.
And your self-serving pronouncements of what is possible and what is practical have become the walls of your kingdom, a very comfortable place where you're never asked to do things that you don't know how to do.
You spend your days and your energies on debuggers and user experiences, sharpening the pencils of development.
You are a friend to your co-workers and an enemy to your craft.
And your actions, regardless of your words, argue that game AI does not matter, that it cannot matter, that what it is now is all that it shall ever become.
Which means that in 10 years, the player experience of game AI will probably be pretty much the same as it is now.
How do you feel about that?
Does it content you?
And if not, what are you doing about it?
What are you doing to save game AI?
Because let me tell you, nobody is coming to save us.
We've seen to that.
Peter Molyneux is maybe the last game designer to come try to save us.
You know, I've said a lot of shit about Peter Molyneux over the last few years, so let me also say this.
His showmanship, his fabulism, his assurance, his idealistic assurance that if something ought to be possible, then it will be possible, have done more to put game AI on the map and keep it on the map than all you jerks put together.
But now it's up to us.
If game AI is to be anything more than an offshoot of tools programming, we need to build it into something worthy of notice.
And the first step to that is getting over our ideas of what is and isn't possible.
We must do things we don't know how to do.
We must create experiences we thought were not creatable.
I didn't say it would be easy, but look.
Either you truly believe that game AI has already achieved its apex, or you believe that it has unrealized potential.
If it's the first, I have nothing to say to you.
But if it's the second, well, no time like the present.
Time to go home, put down the behavior trees, and fucking get to work.
Thank you.
All right, so after this brilliant talk, I will just ask you, if you want to innovate, fine, but don't leave the players out.
So AI is evolving fast, and I am biased because I'm working on the Watch Dogs brand, but we see it all around us.
And yes, Westworld is awesome.
So now we have self-driving cars and smart cities and big data and robotics and machine learning.
And it's fascinating and inspiring.
And it makes us dream of a future where artificial intelligence is everywhere.
But we as game maker, we want our AI to follow the same path.
We want newer, smarter, more capable agents.
And we think AI will help us reaching a new paradigm, as well as in any other industry.
And it's true.
But it's easy to be lost in all this novelty and great advancement of technology.
It's easy to get deep in how your AI can learn and create new things and fulfill its needs and completely leave the players out of the equation.
We are game makers.
We make games as art, as experiences, as entertainment.
Our goal is to create an interactive world for the players to experiment in.
There are no games without a player.
Games that can play themselves without players are not games, they are simulation.
I just said it might sound really obvious.
It is.
But easily forgotten when we make AI.
So let's say I tried to simulate a town.
I have all those AI agents that have all these needs.
Like real humans.
They can eat, have a job, go see a movie sometime.
They have family, friends, co-workers.
Sounds great, right?
Sounds like I've given my agents roles to live a fulfilling life.
Yeah, maybe.
But is it a great game?
No, it's not even a game yet.
It's a simulation, and the players live outside of it.
So, like, no player will dare give a crap that your agents can eat an apple and evacuate it later.
Well, unless it's part of your gameplay.
If the players must collect feces to, I don't know, create compost and make plants grow, I mean, it might be relevant.
But otherwise, not that much.
In other words, players don't care how smart your agent is.
They care how well your agent interacts with them, how smart your agent looks to their eyes, how well your agent sells its fantasy.
So we are making virtual worlds.
Robotic engineers, self-driving car makers, big data analysts, they are dealing with real-world problematics.
They have constraints that we don't have.
We create the constraints.
We make the world.
Your AI should care about your game constraints, not reality's ones.
How many times have I heard fellow developers say that this is a design problem, not a technological one?
And it's true.
But then, why do I see so many developers making their own AI system before even knowing what the design of their game is?
Before knowing what it is that their AI is trying to solve in the first place, and with what constraints?
If I put a self-driving car in space, it would make no sense to expect it to behave as it was designed to.
So the next time you try to simulate life or create a smart agent that can learn the alphabet, ask yourself what you're trying to solve with it.
Sit down with the designers and see what sort of AI answer best the needs of their game.
Otherwise, you won't ship a game at all, just a beautiful tech demo.
Thank you.
Hi, so for my rant, I'm gonna talk about how you can't procedurally generate novelty.
So, you know, the Mandelbrot set is beautiful and we can zoom into it, but after five or 10 minutes, you sort of grow bored of it, even though you can zoom into it forever.
But we do have great success stories in video games for procedural content generation, like Speed Tree, where you can make beautiful scenes and such.
But, you know, if we want to create lots and lots of novelty, well, the trees kind of all do look alike.
We have No Man's Sky, which promised that we could go to millions of planets, and actually No Man's Sky uses SpeedTree.
But we really would love to go and see all these new creatures we've never seen before, and first couple times, it's amazing.
A couple, like a month or two ago, someone looked at the data files for No Man's Sky, and they use a constructionist approach, and this is the Triceratops model, and that's So they have eight heads, five bodies, six tails.
And you can see that there's 240 different combinations you can see there.
And then when you put different paint jobs on them, you put a belly paint job and a top paint job, right?
You can get to about 10,000 different variations of it.
Now if we look at something like the, try and figure this out, well it doesn't feel like we saw 10,000 different things, right?
There's a spectrum of novelty, from the weakest where we are, we've seen it, oh we've seen something like it, and mildly interesting, and then wow, and then holy shit, I've just seen something amazing.
So really, we don't care that there's 10,000 creatures, we care more like how much novelty there is.
So Rabin's novelty number is the number of wow and holy shit items that you actually see.
So when I look back at this, I'm feeling like, uh, I think the number is six.
Right, it's just not as what you thought it may have been.
Borderlands, amazing game, of course, has a lot of weapons, right?
And they use the same constructionist approach where you can have all the different pieces and such.
And it has so many different guns in this game that the Guinness Book of World Records has certified it.
And I know what you're thinking, like the official Guinness Book of World Records?
Yes, that Guinness Book of World Records.
They've certified it as having over 17 million possible guns.
And then Borderlands 2 came out, and it has even more guns.
But Randy Pitchford of Gearbox actually said there are enough where it doesn't matter.
Because saying these high numbers is kind of silliness.
Your clever algorithm is not going to make infinite content.
Well, yeah, because what you really want is infinite novel content, right?
So it's not going to do that.
Your clever algorithm with n novelty will make something like n novel content.
And this is something like the Kolmogorov complexity.
I figured out how to pronounce it by checking the internet.
But that's like descriptive complexity, algorithmic entropy, program size complexity.
Really, you're only going to get the novelty that's in the original code that you put there.
It has to come from somewhere.
Maybe you could scour the internet for novelty, but you have to put it in there.
And like SpeedTree has been around for 17 years.
17 years of development, of refinement, adding novelty to it.
And so it is really good.
So no clever algorithm is going to give you this infinite novelty.
I think when it just comes down to it, you have to make the novelty.
So that's my rant.
I'm just going to leave that guy up there for a little while while I take a drink of water because it's just fascinating to look at. It's the face that makes it.
I am covered in spoons.
Okay, now it's starting to get creepy.
We have talked a lot about procedurally generated content, the craft of it, the effect of it, not only here in the past two days, but actually in these halls, and it's a kind of thing that is being discussed a lot more lately, let's face it, including by Steve, imagine that.
And you know what?
Steve's right, kind of.
Um, procedural content isn't a magic bullet.
It isn't going to be that one thing that just penetrates right through and, and, you know, solves your game and gives you all of that novelty.
But that's actually not what procedural content a lot of times is used for.
It's use case.
Really.
It's a little bit more like this where you really need to spray a lot of content around your world because of design, you know, and, and, and asset pipelines and stuff.
So you just want to fill your game full of lead.
Unfortunately, of course, a lot of people think that, well, you're just going to burn the place to the ground, or at least drop very bad bombs in places, and so certainly designers and others get kind of defensive about the use of procedurally generated content.
But be that as it may.
What do we do about this, though, if it's not a silver bullet?
And it seems to have some use.
So here's my advice, AAA studios, seriously, just stop wringing your hands about, you know, oh my gosh, should we do some procedural, you generate content, we got a budget for this, you know, indies, indies, stop pouring over blogs and articles and message boards and Reddit and say, how do I put PCG in my game?
How can I make a game that does this?
Seriously, just, you know, stop.
Academics, God, I love so many of you.
You're so many of my great friends, and you do amazing work, but stop researching PCG.
Just seriously, stop tormenting yourself, enslaving your grad students, and chasing the whole EP value in the name of academic research about PCG.
All of you, just stop doing all of those things, and instead, just do the damn procedural content already.
No, I'm serious!
By way of anecdote, I just came off a contract where I was working for a company called Pixelmage Games on a game called Hero's Song.
We made it to Steam Early Access, had to pull it because of some business concerns and whatnot, but it did see the light of day for a while there.
And the thing was, a massive amount of the game was PCG.
For example...
Big breath...
We did procedural world gen where we made continents and had many different biomes with rivers and lakes.
And we did it through the generation of tectonic plates that moved and created elevations.
We had moisture levels and wind movement that blew things around that gave us those biomes.
And our worlds were massive, 10,000 square kilometers to generate a world.
I mean, they looked kind of like this, and every single one was different.
They were really cool.
You could say, oh, look at this, this valley here.
We did procedural terrain across that.
We had grass and rocks and dirt and trees and all sorts of things, even flowers lettered around the world.
And that was all based on whatever biome you were in.
We could actually even blend between biomes as you walked across the world, gradually transitioning from grassland to plains to forest to mountains.
procedural civilization placement in those worlds that the civilizations had capitals and cities and towns and villages and even small camps littered about the place. And we had hundreds of them in those worlds and it was all based on the size of the civilization. What kind of coverage were they? Were they a global civilization or were they just regional?
What preferences did they have for biomes?
Because the dwarves were in the mountains and the elves were in the forests and the goblins were over here.
Land feature preferences.
Did they want to live next to lakes and rivers or along coasts or out in the middle of nowhere?
And what kind of neighbors did they prefer to live next to?
That all factored into where we placed civilizations in our world.
And so you can actually look at the map and see all these little...
This is my debug map, by the way.
All the little colored dots of, hey, look, those are cities and towns and villages and everything, and these guys are over here and these are over there.
We did procedural history generation on these civilizations, where we could have wars and assassinations and alliances and trading pacts and creation of epic items and loss of epic items.
That is important, by the way.
And this was all based on proximity to the habitations, the friendliness of the civilizations to each other, the ebb and flow of relationships over time.
And speaking of time, we simulated 10,000 years of history when you generated your world.
Where's Tarn? Are you here?
Tarn Adams, I love you brother.
And no, we weren't copying your...
Okay, a little.
We did procedural road generation in those worlds, then, between the habitations and even to points of interest in the world, like dungeons, so people could find them easier.
We had different sizes of roads.
Some of them were huge, between capitals like the King's Road, and some of them were just paths going off to camps and dungeons and whatnot.
And those were, of course, based on the proximity, how close we were to these cities, what were the friendliness of the civilizations.
Allies had roads running between them, not so much to your enemies, because that's dangerous.
And then of course we used the biome traversal costs.
You know, you don't want to run a road through the mountains unless you have to.
And then, so if you look carefully, you see the little black lines.
We had roads all over the place, networking across these massive worlds of ours.
The cities were procedurally generated.
We had all sorts of different types of buildings.
I think we had 25, 30 different types of buildings, and we placed them procedurally in a place where we knew that there was going to be some sort of habitation.
And it was all based on the town size, the racial preferences for the types of buildings that would be in this racist city.
And then we had to work around the terrain features.
What if there's a river running through here?
We had to place them procedurally around the river.
The buildings and the dungeons themselves, the building shapes.
And yes, we actually had multi-story buildings that conformed to the exterior shape.
Building interiors were procedurally generated with the placement of objects in buildings.
The dungeon interiors were all procedurally generated. No dungeons were ever the same.
Not just modular rooms were gluing things together, but they had nooks and crannies and obstacles and everything in the dungeons so that they were all completely unique and you didn't know what was coming next.
But they looked real.
The population of the world was procedurally generated.
The creatures that were in it, the humanoid creatures as well as the animals.
Town inhabitants.
When we created those towns with those buildings, we staffed them.
Objects that were littered around the world, crafting items, loot, all sorts of interesting things you could find.
And all of that was based on what biome you were in. You would find different things in different places.
The influence of the civilization. While I'm in dwarf territory, therefore I'm probably going to see a few more dwarfs.
And what the neighbors were, well, we're kind of near goblin territory and they might be invading.
Oh look, there are some.
And then the rarity, are they something that's common or a little bit uncommon, rare, or are they something unique?
And then we'd also space them out so that not all of the difficult stuff was right next to each other.
All procedurally at runtime.
Names. Everything in the world had a name, not just the characters and the cities, but geographic features.
You could have a forest that had a name, sometimes more than one, because different races called it different things.
Mountain ranges, etc. had names, and they were based on designer-created templates that we would sort out by race, sub-race, gender, whatever.
We could just...
like one example of that template right there, a prefix with the little apostrophe and first and last and suffix, so you could have tens of millions of unique names, and just using that template, for example, you could get things like this.
How do you even pronounce it?
A.I.
Dave Markmaster, A.I.
Steve Rabindude, and A.Lisha Ladeck, wow, what are the odds?
Cool. Anyway, procedural dialogue in this game.
Now, we had text instead of VO, so we could get away with a lot more here.
We had greetings, friendly, neutral, hostile, whatever.
We had taunts. We had barks.
We had information about the world that the characters would say, not only to you, but to each other.
And you could hear worldwide information, regional information about the town, or even just local dynamic events that were happening.
They may just tell you about it.
Some of it was generic, a lot of it was racially specific.
They sounded like that particular race.
They had their own speech patterns, et cetera.
And we used templates to create these so that they could insert information like race, gender, name, class.
They might call you by name, they might call you by, refer to your race, they might refer to each other by their class, whatever.
And we filtered it by all of the above, including the disposition.
They're going to say completely different things to you if you're hostile compared to friendly.
all filled into those templates.
Procedural information about the world that was constantly being generated at runtime using what was going on in the world referenced by the generated names in the procedural dialogue so you could actually hear things like, we've heard reports of knolls to the southwest.
And if you went southwest, damn it, you're gonna run into knolls.
They were telling you about this. There are goblins attacking the east gate of the city. The orcs are massing in the forest north of the river. They would fill in all of this information.
Items in the world, information about the items in the world, using the game world information referred to by the names in the procedural dialogue with varying degrees of specificity.
What do I mean by that?
The magic tome of amazing AI is rumored to be lost far to the west.
Well, that's not terribly helpful, is it?
But as you get people who know more and more about this situation...
they would actually add more specificity to the point where you would get to something along the lines of the magic tome of amazing AI is lost far to the west in the dungeon of Moscone near the Californian city of San Francisco where it is guarded by a horde of AI programmers and that was the god-honest truth because they knew it was in the world and they were signposting the player hey there's something interesting over there in Moscone and it's guarded by a lot of AI programmers That was all procedural.
We even had quests, procedural quests that were constantly being generated using the procedural items, placed in the procedural dungeons, in the generated world, using the names and referenced by the dialogue.
So we had all of this stuff, all of this procedural.
I did a lot of it just by myself, and there was two or three others on the team that worked on various portions of it.
My point is not necessarily to brag.
Okay, well, it was actually really kind of cool.
My point is this, we did all of this in one year.
And that's on top of me actually doing the regular game AI that I had to do for combat and for moving around and whatnot.
And by the way, all of the characters knew how to respond to detect and process all of this procedural information.
How did we do this?
We didn't write a thesis, we didn't do years of research, no hand-wringing, no scouring blog posts, or pleading for advice on forums.
We just looked at the problem one at a time, we thought about it for a little bit, and said, well, let's figure this out.
And then we just did it.
Because it's just programming.
So, again, I'm not here to brag about this.
There is a bigger message here.
I'm here to pump you up.
about the fact that, you know what, you can do this also.
You don't have, there is no such thing as an expert in PCG.
I'm serious.
Stop all of the hand-wringing and researching and just do it.
Because it might make things kind of better, spraying some content around your games.
And if you still don't believe me, if you still believe that you can't do it in your studios and in your games, I know a guy might be able to help.
Thank you.
