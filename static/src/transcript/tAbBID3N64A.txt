All right, everybody.
Welcome to this, the last talk, in the last hour, the last day of GDC.
We have deployed smooth jazz to keep you resolute in the face of almost certain boredom.
By the way, if there's a seat closer to the middle from where you are, you can kind of squeeze in.
We can get more people in, unfortunately.
There sure are a lot of you here today.
I was kind of hoping there wouldn't.
Today we are going to talk about dialogue in games.
A really simple way to do dialogue in games.
A really easy way to make writers very awesome.
This game, this talk is not really about code.
It is not really about programming.
It is about enabling writers.
And I don't mean like by handing them the scotch, although God knows I've had to do that often enough.
By the way, if you are the sort of person who freaks out taking lots of notes in every slide, taking a picture, feel free to take notes.
But the slides are all going to be up on the Valve website probably by Monday.
So there is no need to take pictures of every slide unless you really want to.
This talk is about our system for tracking lots and lots of facts about the world, and then picking one rule from a gigantic database full of lines based on criteria for all those facts.
It's a system that we've used in Half-Life 2, Team Fortress 2, Left 4 Dead, Portal 2, Dota 2, all of our games.
Most of my examples are going to be from Left 4 Dead 2, just because it was easy for me to capture video, but it's the same tech in all of these games.
And we realized after the fact you can use it to drive some things that are not speech, like animation and sound.
You will see a particular scene that will tip you off as to what other games uses this for for animation.
But really this talk is not about code. It is about writers. It is about empowering writers.
It is about a way to approach tracking state in the world in a way that enables writers to do what they do best, which is making your character say things that are interesting.
It is as much as possible a system that is simple, general, efficient, and friendly.
That is three things, not four.
I am firmly of the belief that simple and friendly are the same thing.
Because if a system is simple to use, people will use it.
If it is simple to build, you can maintain it.
If you can build a complicated system, you can only do simple things with it.
You have to build a simple system to make complicated things.
And why stand up here and talk at you for an hour about talking?
Well, there have been a bunch of really cool games in the past couple years that have done cool and interesting things with dialogue, dialogue states, state, you know, tracking the player, tracking what you've done previously, communicating, character, or just being really fun.
Personally, I really enjoyed each and every one of these games.
So if I can show you how to make similar games, then hopefully you will, and I will get to play them.
My ulterior motive.
When I mean contextual dialogue, I am referring to any kind of like state or character, speech or behavior by character that seems to be aware of what state the world is in and what the player has done previously.
In the early days when games were nothing but dialogue, this was pretty easy, but games got complicated and so did dialogue pretty quickly.
RPGs have the notion of conversation trees, but you know, you may occasionally have a character who wants to remember things like the fact that you blew up his hometown three missions previously, you know, might respond to you differently based on that.
So you have to start throwing explicit flags and closing off branches of trees.
It gets really unwieldy if you have a bunch of stuff.
Some games don't have conversation trees, but they do have characters who bark to announce their state.
Stealth games are a con- canonical example of this, because it's an important part of the game mechanic.
The player needs to be aware of what the AI knows about the player, what the AI is thinking, where the AI is going to go next.
It's actually how you play the game.
A great example of this, I think, is, once again, Batman.
I love this game.
There's so much good stuff in this game.
Among the good stuff in this game is one particular kind of AI guard, who is so explicit, so clear in what he is thinking, that it's like he was tailor made for doing presentations.
Target deployed smoke to escape. Target is now moving.
Huh?
Smoke.
Target was a negative. Just blew the crap out of an extinguisher.
Target is moving this way.
Target spotted above us. In my...
Target is lost.
Move to locate!
So it's really, but you can see like it's, this is how the AI tells Batman how to play the game, right?
The game is all about manipulating where the guards are moving.
It really is a good game.
I played it for like 100 hours.
Other games use it as an artistic or a narrative device.
Bastion has an omniscient narrator who responds to everything the player does with some kind of specific speech.
This is not because the player needs to be told what he is doing, but because that's what the game is about.
It's about storytelling.
It's about creating the world through your actions.
That's the game lets you know that it's paying attention.
Sports games somehow create tens of thousands of possible utterances from I don't even know how many lines.
And a sports game is a really highly dynamic situation, right?
They've got all these different teams and players in the field.
You can't just handle this by a gigantic cascade of if-else.
Your brain would probably melt.
And modern RPGs track an absurd amount of state.
Think about all the stuff that Skyrim and Mass Effect remember about what you've done.
Not just to control character outcomes and mission outcomes and conversation trees, but also so that townspeople can remember that you are the elf mage that saved the town from the demon horde just a few missions previously.
It's how they create the feeling of a living world.
It's how they create the feeling the world actually responds to your actions.
I have no clue how all those...
Oops.
PowerPoint fail.
Well, while I'm waiting for PowerPoint to respond, I have no clue how all those games did their stuff, but I can tell you how we did our stuff, and that's what I will be talking about.
Assuming PowerPoint gets back to me.
Worst nightmare.
We'll move on to the next slide that I haven't got up on screen.
Our system, as much as possible, designed to be simple, uniform, one way to track all the state of the game in one place.
one way to find the right line for every possible circumstance from a gigantic database of circumstances, and as much as possible, a way for writers to be able to create the rules database themselves.
I'm going to reboot PowerPoint.
Restart the program, please.
Do not recover my information. Cancel.
So how's the fish?
All right, where are we?
Slideshow from current slide.
And we're back.
Team Fortress, for example, a multiplayer game where you can play one of nine different character classes.
We wanted a mechanism in this game where you could hit a button and speak in your character's voice.
If, for example, I am a soldier and injured, need medical attention.
I can push a button and have the soldier say it in his voice.
It's not just for role-playing purposes, although that's kind of the largest purpose, but it's also for international play.
If I'm in the United States and I push the button, I will hear my soldier speaking medic in English, but if you're in Spain, you're going to hear him speaking in the localized voice.
It's a way for players to play across international lines, to communicate simple orders and ideas to each other, and have the localization system take care of it for them.
There are other characters who have to automatically announce their state to the player.
That is so that if, for example, I'm next to a medic character and the medic is ready to heal me, I know that.
And I know it even if the player has failed to actually push the button or spoken over his headset to remind me.
And we also have a contextual dialogue button where you put your cursor over an object in the world, push a button, game tries to figure out what it was that you wanted to say about that thing.
Help me capture this bloody thing!
We also use it to communicate rivalries between individual characters.
It's part of the role playing in the story of the game.
The engineer is a spy!
The scout is a spy!
The spy is a double agent!
So having finished the orange box and Team Fortress and all that, Valve did something kind of...
valve.
We really were not ready to go on and make another huge game straight away.
We were a little bit crispy.
And we figured, okay, how about we take everybody who rolled off the project, put them on little teams of like four or six people a piece, and each of them comes up with some interesting design idea, some piece of code, some feature that maybe we can put into our next game.
Do something risky.
You know, if it doesn't pan out, you only spent a couple months in it, eh.
But if it is cool, then it can become a feature that we use from then on.
One of the teams asked themselves...
what can we do to improve companion characters in our games?
What can we do to make people like Alex Vance seem more real, seem like they're aware of their environment, seem like they have memory?
So we took a bunch of Half-Life 2 art assets, banged together a couple of characters, had a programmer and an artist record some voices, and created a project called Two Bots, One Wrench.
for reasons I will not describe.
I was going to say, by the way, here, seen for the first time ever outside of Valve, some internal video.
I am told that Jeff Keighley, in his Portal Last Hour app, has already shown this video.
So here, for the second time ever, outside Valve, to Botswana Branch.
Starting up, how can we make characters aware of the environment?
You can do all kinds of crazy code, but we only had a couple months.
We're like, what's the easiest, simplest way we can do this?
And we thought about that system that we had in Team Fortress 2, where you can put your cursor over an object and say something contextual about that object.
Well, we said, okay, how about we just tag every single object in the world with a string name, like its class name, and then each of the characters in the game, each of the robots that we made.
automatically pulls his field of vision every few seconds, like you are pushing that vocalize button.
And if it finds an object there, it pulls a string name off the object.
It goes through its database, tries to find a line matching the name of the object.
And if there is one, it says the line.
Super brain dead simple.
A laundry car.
There's a laundry nearby.
This heater appears to be broken.
Anyone want to see me break this cinder block with me yet?
Anyone?
A shoe? Someone's gonna fucking miss this.
Danger. Flammable materials.
Look at me, that does sound dangerous.
Look! Tiny spoons!
Oh, there's more. Not done yet.
So this is literally all the code that you need to do that.
It is not even code.
It's barely even a script.
It's a text file in Notepad.
You've got these rules.
Each of the rules has a list of criteria, like why am I being polled?
Oh, I've seen an object.
Am I being shot at? No. What am I looking at? And there's the name of the object.
If the writer wanted to create a new rule for a particular kind of object, had some funny thing that occurred to him about a shoe, he would put in a shoe rule. If not, the rule would not play.
All it takes to add a new line to any object in the world is just like four pieces of text right there.
Having characters babble whatever pops into their head is well and good, but we have two of them and we would like them to talk to each other.
Once again, what is the easiest, simplest, laziest way that I could possibly implement that?
You can have all kinds of ways to handle conversations.
You can have an entity that binds the two characters, you can have a scripted sequence, you can lock both of them down.
Sounds like a lot of programming to me.
You know what's a lot easier?
Doing the exact same thing we did before.
Every time one character says a line...
He creates an event, dispatches it to the other character, except this time the parameter, instead of being the name of the object, now it is the name of the line that has just been said.
Second character looks in his database, tries to find a line corresponding to the thing that was just sent to him, and says that line.
When he's finished, he may have a line of his own, send it back to the first one, back and forth, implementing conversation in like three hours of code.
Oh, PowerPoint.
And we've crashed.
All right.
While PowerPoint is restoring, I will send a video over to the other screen.
Now.
Sorry.
I'll show from current slide.
Danger, crane overhead.
Caution, you're an idiot.
It won't be so funny when you get crushed by a bloody crane.
What kind of monster locks a traffic cone in prison?
It's unconscionable.
It doesn't even make sense.
Do you know who sat at this desk?
Who?
The warden.
No!
It's true.
A wooden plank.
They were trying to keep something in.
Or out.
Well, it is a prison, mate.
Yes, probably in then.
Oh, that's a rather shabby crate.
Oh my God, it's horrible.
Ah, I accidentally looked at it again.
Stop looking at it!
Ha ha ha.
Incidentally, the Redbot Richard Lord, the same artist who did the original Wheatley voice that you may have heard on YouTube.
Right.
So it's great to have characters babbling at each other, but you know what conversation really needs?
It needs running gags.
We needed some way for characters to remember what they had said to each other, to said to themselves, and what the player had done to them.
Once again, what is the easiest possible way that we can do this?
Well.
We have this notion of every time a character says a line, it's evaluating all these criteria about the state of the world that we passed in from the function.
What if, along with all the other state in this function, we also pass in a table that is stored in the character's head?
We can just have the writer store arbitrary variables, just a name and a number, and it can update that.
So the first time this robot sees a barrel, it's going to go through its database, it's going to find that first line.
And then it's going to set that scene barrels parameter to one more than it was before.
So the next time it sees a barrel, it's going to go through the same thing except the scene barrels criterion will match for the second row.
Don't fail me now, PowerPoint.
The second row and play the next line.
And that way you can get a whole series of lines about an event.
All right.
Switching to emergency backup laptop.
you And we're back.
All right.
That is all the code it takes to do this kind of memory mechanism.
Right?
You see that first rule there for no scene barrels, the first time the character sees a barrel, he's going to play that rule.
Then it will set that scene barrels criterion to one more, play the second rule.
That one has the additional criterion there.
And then when that's finished, it's going to increment that state one more time, and then send a trigger back to the other robot.
Fast quantities of urine.
Ooh, I very much doubt that.
Do you doubt it enough to go stick your head inside?
Look out, another urine barrel.
This heater appears to be broken.
We've got to get out of here before we freeze to death.
Another broken heater. The entire system must be down.
This is the type of bottle that I'm afraid might contain a bit of urine.
What is wrong with you?
After we finished that project and kind of overcame our laughter, Left 4 Dead was going into production.
And we realized that Left 4 Dead, again I'm showing you examples from Left 4 Dead 2, but it's the same tech.
Left 4 Dead is a game that would really benefit from this.
And the thing about why, if you haven't played it, it's about four human survivors, you and your friends, against a zombie apocalypse.
It is a game that is designed to have high replay value.
There are only about five campaigns that ship with them, about one hour long a piece, but every time you play the game, it's different, because an AI director throws different situations, different characters, different enemies at you each time.
But you can see why this means that we couldn't have pre-canned audio unlike environmental triggers.
For example, Nick the gambler cannot say the same line about the hunter zombie every time he sets foot in the warehouse for the first time because the zombie may not be there.
It may be a different zombie.
You may have seen the zombie earlier.
Nick may be dead.
Moreover, because you're playing the same mission a bunch of times, if you played the exact same line at the exact same location, it would be rapidly very tiring.
And as I mentioned, the game is about getting to safety, but not everyone makes it.
We needed some kind of system that could cope with characters being dead at certain points in the game and try to figure out, what can I say with whoever happens to be alive?
Here's a little bit of what I mean about having variety in the game.
This is the exact same point in the exact same mission, but two different playthroughs.
Okay, here's the plan.
First we look for supplies.
Then we start the Midnight Rider finale.
It's all kinds of fireworks, smoke pots, and lights and shit.
That chopper pilot can't miss it.
So we gotta set up to rock, and then fight zombies.
This is the best day of my life!
Okay, here's the plan.
It's been a long time since I've seen the Riders, but if their finale is the same, that'll signal the chopper pilot.
We just need to start it.
Coach, that is the stupidest idea I have ever agreed with.
Then let's do it. Everybody grab a weapon and let's go!
In addition to canned conversations, we also needed a way for AI characters to call out things they saw in the world.
Things like ammunition caches and weapon caches are in a different place in the world and on every play that we put weapons differently.
It's part of the replayability.
And if you're playing with human friends, your friends will tell you, oh, there's a weapons cache over here this time.
But you may not always have three human co-players.
You may have robots in their place.
The game is designed to fill out your team if you're playing alone.
So the robot players needed to call these pieces of information out in the same way.
And once we did it for the AIs, we realized it's pretty fun to have the human-controlled characters talk automatically as well.
It helps the role-playing.
We have guns here!
Smoker!
Nice shot!
I hear a jockey.
Jockey!
Jockey!
Jockey!
Reloading.
Kill the clown!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
I got a boop!
And finally, Left 4 Dead is a game that tells its story through in the environment.
There's not a lot of cut scenes or scripted sequences.
The story of the zombie apocalypse is told through the environments that you move through and the objects you come across.
So the best opportunity for characters to express themselves, for us to have character moments, was to have them interact with and talk about the environment as well.
Elephant ears, funnel capes, corn dogs, man these signs are bringing back some memories.
Hey, can we stop and make some cotton candy?
Seriously.
Holy shit, guys!
Candy Land!
I wanna ride one. Just one.
Just let me ride the Screaming Oak once.
Man, when are we ever gonna be here again?
Well, looks like we're going through the tunnel of love, people.
No hanky-panky.
The air duct of love.
I found a burger tank in this place.
I'm gonna be a one-man cheeseburger apocalypse.
To get this kind of scale, it is imperative that your writers are the ones doing your writing.
You want to give your writers tools, not homework assignments.
In a lot of games like this, what happens is the AI programmer, while making the AI, asks himself, hmm, well, at what moments would this character like to say something?
Let me try to guess all the times a character would speak.
I'll put code hooks in for that, give the writer this big spreadsheet and tell her, fill this out with things the character could say.
Well, this reduces your writer to filling out Mad Libs, which is not writing.
It also means your programmer is the one doing the writing.
And the intersection between good programmers and good writers, while non-zero, is pretty small.
It's kind of Verner Vinge, really.
So as much as possible, you really want the writers to be the ones driving when lines get said, what are the circumstances, what are the specific cases that need specific lines, what are the general cases that need general lines, and so on.
Here's how we did it.
I should warn you, the system is incredibly simple.
It is brain dead, face palm, why didn't I think of that symbol?
That is the point.
The system evolved by accretion.
It wasn't designed from the ground up.
It was we had this one thing in Half-Life and then we added something and added something.
If we had designed it from the ground up, there's no way we could have come up with something as simple.
Here's the general idea.
Got a big database full of rules.
A rule is a list of criteria that have to be met about the world, like which map I'm on, how many players are nearby.
Each rule associated has a response.
It's just the thing that happens when the rule matches, like a line playing.
When you want to say a line, you build up a query of all the state in the world.
You take all the state in the world, you find the rule that best matches that state.
When you find one, you send that response over to the character.
Character says the line.
You have achieved dialogue.
A glossary for the words I'm about to throw at you.
When I say context or fact, it is just a piece of state about the world, like my hit points.
Query is a bunch of those all together, all the state of the world.
Criterion is a single thing that has to be true about the world, like my hit points R5.
A rule is a bunch of those together, and the response is the thing that happens.
To think about the way that we assemble these queries, programmers are used to thinking of the world as a pile of facts, strewn hither and yon.
If I'm going to play a line about a character when he's in the cave and he's got a number of allies nearby, I'm used to calling all these member functions and looking at data things and knowing where to find these things.
So a few problems with this approach.
One is it's not discoverable.
It's hard to know what information is available to you to pick a piece of behavior from unless you kind of put it there yourself or you've read the docs or something.
Secondly, it's kind of a palaver to get in the individual piece of information.
If I want the name of my ally, I have to know that I have the current player object from which I call the ally function and I get the thing.
Thirdly, kind of a mess, right?
Way easier to think of the world as a flat list of facts.
Every time you want to do a query, you just pull all that information into one place.
It's always there.
It makes it way more discoverable.
You can just look at the query and see what information you have available to write a rule from.
You don't have to go thinking very hard about where you're going to get this information from.
Sure, you have to do a little bit of extra work to pull all the information together in the first place, but I'll show you that's actually not that much more work, but it is so much more usable.
It is absolutely worth it.
So let's think about how we build up these queries.
An individual fact is a piece of state.
My hit points are 57.
It is just a key value pair.
It's a name and a value.
The name is a string.
By the way, when I say string in this talk, I do not mean that you should use a const char star like a noob.
I am assuming that you have some kind of in-turn string representation, some kind of symbol table.
I'm just using the word string to mean some kind of human, readable, unique identifying number.
A query is a pile of those together.
It is not usually meaningful to have the same key appear twice in a query.
Hit points cannot be both 50 and 80.
So really, it's a dictionary.
It's an associative array.
We have typically queries that are hundreds of items long because we pull together all the possible state of the world every time we query the database.
That is so that if our writer wakes up in the middle of the night with this brilliant idea for a line that can be said when the zombie is on the merry-go-round next to the ice cream machine for the third time, you can.
You can add this line without having to ask the programmer to inject any additional state into the query.
It's just always there.
For performance reasons, we have a couple of key names that are in every query and every rule.
You'll see why in a sec.
We call them the concept, the general idea being said, reloading, I'm hit, and who, which is the person speaking.
It makes no sense to play a line if you don't know who's talking.
To build a query, you start with the function that decides it wants to speak.
For example, let's say we have our on hit event function.
This is the thing that starts the events in motion.
It creates this query object.
It starts filling out the first fields in the associative array based on the parameters to the event.
And then it calls into the base speak function.
It starts to pull together information about the world.
The first wad of information we get is about the player.
Let's say it's Nick in this case.
There's a bunch of stuff that we can procedurally calculate about Nick that might be relevant for a line.
For example, his hit points, his ammunition, who's nearby.
We simply go through all the member functions, all the state on Nick, pull it together, add it to the array.
Then we take any of the arbitrary memory numbers that may have been stored on Nick, the things that the writers may have just given arbitrary names to and triggered from roles.
These two are pulled from Nick's memory and added to the array.
We do the same thing, pulling in data from the world, both procedural information, like what map are we on, which allies are alive, have we encountered the crazy hillbilly, and so forth, as well as, once again, writers can store arbitrary state on the world.
It's just a key and a value.
Take all these sources of information, you merge them all together into one gigantic table.
This is your query.
It's also natural to think of dialogue as a pile of rules.
We're used to thinking of like, well, in general, if the henchman sees Batman, he says, oh, look, Batman, unless he can kind of barely see Batman, unless he works for the Penguin, unless he works for the Penguin and the Penguin is dead, unless, you know, unless, unless, unless, unless.
It's really natural to think in terms of general rules and specific exceptions and exceptions to the exceptions and exceptions to the exceptions to the exceptions, kind of like a pyramid.
To this end, we represent each of those exceptions as a criterion, which is just a function that tests a fact, like, is the speaker bill?
Are hit points between 30 and 60?
In computer sciences, it's a predicate function, but in practice, we don't really use function pointers for this kind of thing.
I mean, you could, but there's not much call for it.
A rule is a pile of those together.
All the criteria in a rule must match for the rule to be considered a match.
If a criterion mentions a key name that isn't in the query, like there's a killed five bunnies criterion, and the query doesn't even mention bunnies, the criterion is considered a fail.
And because multiple rules may match a given query, like if you see a zombie on the merry-go-round, you're going to say, oh, look, a frolicsome zombie in the merry-go-round.
But the, oh, look, a zombie line will also match.
So you have to have some way to pick the specific rules over the more general ones.
We tried a bunch of different scoring functions.
As always, the very simplest one imaginable was the one that worked best.
The more criteria a rule has, the more specific it is, the higher it scores.
Let's walk really fast through a simple example of how we might match a single rule to a query.
Let's say this is our query.
Nick has been hit in the circus, he's partially injured, he has two friends, and he was hit by a zombie clown.
Let's think about all the rules we might have in the seven rule database.
First one, has Nick been hit? Yes. Passes.
The next one, the concept criterion does not match. Fails.
Next, the health criterion doesn't match, fails.
Next, there's a more specific criterion.
Does he have at least one ally?
He does, passes.
Next, are we in the circus?
Yes, we are.
Was it a clown?
Yes, it was.
Was it a clown in the circus?
Yes, it was.
So here are the rules that have passed.
To start with, we've got this one, which has only two criteria, and this one has three.
So we can reject the first rule. It's not specific. It won't play.
Up to this point, each of these rules has a score of three. They each have three criteria.
So to this point, the engine would randomly pick from any of them to say a line here.
They're all equally specific, and we'd get more variety that way.
But in this case, we have one line that is more specific.
It has a higher score. That is the one that will play.
The response is an arbitrary payload.
It's whatever happens.
There's not much to say about it other than that it's OK to have a bit of intelligence in your response.
What we have here are a number of different minor variations in the same line that are all considered the same response.
The game will randomly pick between them.
Saves us the effort of having 12 parallel rules for the same notion.
You can also have responses that disable themselves, that move sequentially through a series of lines.
It's totally cool to have arbitrary logic in your response, however you implement it.
Let's think of a simple example of how we handle write-back in conversations between characters, one of those convos at the beginning of a mission.
Every few seconds, a character just asks themselves, do I have a line to say?
That's what we call the idle talk.
This rule will match if that's happening, and there are at least three living survivors, and the person speaking is Nick, the gambler, and he hasn't said this line before, and he's in the swamp, and he's in the start area.
All these things match.
This rule will match before it says a line.
It's going to write some state back to Nick's memory.
In this particular case, simply that this line has been said, and then that Nick is speaking so that other characters don't talk over him.
You can set an expiry time in some contexts, if you like.
That's how you can prevent successive lines of a running gag playing too close to each other.
Then we will play the response.
There's three lines in this particular response.
We'll choose randomly between them.
If the first one plays, Swamp's Going to Ruin My White Suit, after it's finished, the then clause there will send this concept over to Rochelle, the TV producer.
She'll check her database to see if she has a reply to that.
And she does.
She'll say her reply.
And then after that, it sends an event back to Nick the Gambler and back and forth.
could have come out differently.
Second line could have been played.
After he says, these swamps don't agree with me, the follow up goes back to Nick.
It creates the illusion that he's saying one longer line rather than having a back and forth conversation.
That way we can bail out of the conversation if we need to.
After he said that second line, once again there's two choices.
He happens to pick the first one, then the reply at the end of that line goes over to the mechanic.
Mechanic checks his database.
He's got a line, and so on.
This is a brain dead simple way to create branching conversations of as many different branches as you like with a minimum of effort.
Because as you saw, each of these individual branches is maybe five lines of text.
In addition to sending a reply to a specific character, we also have a way to ask all of the characters nearby, do any of you have something that you want to say?
For example, let us say that Nick is badly injured and he's unhappy about that.
Not dead yet, but not exactly healthy.
After he finishes saying this line, it's going to dispatch that ally dying concept to any character within earshot.
He's going to ask every character, do you have a reply that you want to say?
Rochelle does not.
Ellis has kind of a general reply, but coach.
Coach is different. Coach is a coach. He coaches people through their difficult times.
He has a whole bunch of really specific lines for the particular case of there being an injured ally.
And if Coach happens to be alive and nearby, he's going to be the one with the highest matching response.
Come on now, put it behind you. You good? You good?
In addition to those general replies, he also has specific ones for specific characters.
Hey Nick, at least you dressed for a funeral.
Come on, Alice, you got it in you.
So he could play those specific lines, but he still has the general lines.
We play them one out of 60 times for the sake of variety, but moreover, if we had picked up an entirely new character and dropped her into Left 4 Dead, if we had picked up Zoe from Left 4 Dead 1 and put her in Left 4 Dead 2, Coach would still have something to say to her.
Even though we never recorded Zoe's specific lines for Coach, he would still just fall back to the general case, and we would have created the illusion that they had known each other the whole time.
It's also important to remember that every time we do one of these follow queries, it is de novo.
If Coach mentions his favorite rock band, and the reply goes over to Ellis, Ellis is not going to look up his line until Coach has finished speaking.
The reason for this is, let us say that Coach mentions his favorite rock band.
But while he's saying this line, a zombie interferes and starts chewing on Ellis.
In this case, we do not want Ellis to reply with some banal line about a rock band.
We want him to say, oh my god, a zombie is chewing on me.
So there are ways that you could have like a scripted conversation object and interrupt it and so on, but it's way easier if Ellis doesn't even look up his reply until Coach is finished speaking, then the reply that he chooses will be contingent on the criteria of the world at that exact moment.
And at that exact moment, the not in danger criterion is no longer true.
So the conversation simply self-terminates by virtue of its criteria no longer being that.
That means there's no cutscene entity that grabs both characters, there's nothing to lock them down, there's no kinds of cases where people get involved in this big speech, and a dragon comes and sets them on fire halfway through, but they can't do anything because they're talking to each other.
It is also helpful, if you have long speeches, to cut them up into little pieces, where the character says something, and then sends a follow-up to himself, to himself.
That way, if you have these long monologues, they can automatically bail out if something happens.
It also means that you've blurred the line between code and content here, usually a good thing.
It means writers can do work that otherwise they would have had to have waited for programmers to do for them.
Less dependencies, less merge conflicts, no compile time.
Typically it's easier to edit and continue script than code, right?
Oh! A leprechaun!
It's a doll. It's just a doll.
Bloody hell.
This prison is a bloody minefield of possibly urine-filled containers.
Alrighty, let us think for a moment about the machine writer interface.
How do we make humans interact with this crazy system?
There is a bit of prior art here, by the way.
A programming language called Inform 7, designed expressly for the purpose of writing text adventures, which I am now supposed to call interactive fiction, has this very mechanism of rule books, of general rules being overridden by more specific ones.
By the way, this is actual source code.
This is what the source code for a text adventure looks like.
Inform is designed to have a language that resembles natural English as much as possible.
This kind of suggests as to how intuitive this concept is for the sake of writing stories.
A programming language that exists for the sole purpose of creating dialogue has this very idea.
Moreover, when designing the mechanism for writers to get their dialogue into the system, assume that your writers are smart, right?
Writers are smart people.
If they were not smart people, they would be vice presidents of marketing.
And smart people know perfectly well what works for them.
Mark Twain did not have to be told by his editor to either purchase or throw out a typewriter.
So let's think about different ways that we can specify these rules.
You could just write the script directly.
Our script language happens to be the recursive descent language.
It's kind of human readable-ish.
I mean, I guess I could write some lines that way, but it would be really painful.
Better to have more comfortable tools.
For example, you can always have a more natural language representation of the rules and parse from those into your script.
This is pseudocode, but you can see how each of these individual rules has a pretty mechanical representation.
in the corresponding script.
Similarly, in Form 7, remember, this is not English.
This is a parsable computer grammar.
If you have a parsable grammar, you can always do a syntax tree transformation, turn English rules into script rules.
Or you could use Excel.
On Dota, we have a bunch of characters who have specific rivalries.
When Tidehunter kills Kunkka, he has a specific line to say.
The writer on Dota happens to like Excel.
You know what?
That's fine.
We have a script that exports from Excel into our in-engine script.
And it's actually really convenient because then we can use the same Excel spreadsheet to export from the same Excel spreadsheet exports not only the script that the engine loads, but also the paper script that the actor takes down into the recording booth and reads from.
It's one stop for all the data.
We also could build visual tools.
I've lost screenshots, but one summer I spent a few weeks building this complicated visual system that had nodes and arrows and things.
See, here I fell into the trap that I was mentioning earlier about thinking about your particular writers.
When I designed this thing, I was not thinking about my writers.
I was thinking about writers.
And I asked myself, what do writers like?
Writers are creative people.
Creative people are visual.
Visual people like bubbles and arrows and things.
And I spent all these weeks building this thing.
And then I showed it to our writers.
And they were like, what the heck is this Fisher-Price toy?
Because our writers, and I forgot this, were DBAs in a previous life.
And for them, the most comfortable interface was Fox Pro.
You know, works for them.
They built a relational database, stored all their lines.
It actually worked fantastic.
This is how we handled like 10,000 pieces of dialogue in Left 4 Dead.
And it was great for them.
They were comfortable with it.
The point of this is do not design systems for arbitrary hypothetical writers.
Design them for your writer that you have in your studio.
She is just down the hallway.
Ask her what she wants.
She's the only one that you have to make happy.
It's also possible if you have a scripting language in your engine, like Lua or Squirrel or whatnot, you can always use the script files as a way of loading data into the engine.
I don't mean to say that you're actually going to write the database itself in script, but like the whole, you know, you could have like a script add rule function that sends the data over to the C++ core, which parses it and stuffs it away.
If you're designing a system like this, you must have a way to debug it.
Here are some tools that you would pretty clearly need.
Some non-obvious ones.
You want a way to figure out where individual facts come from.
For example, if a query comes into the system and it has a line about, or one of the facts in the query are, the dragon has been slain, and you're like, but the dragon has not been slain.
Why do you think it has been?
You want to figure out what's setting that fact.
If you have a whole bunch of rules matching, you're going to want to print out which ones match and what scores they had so you can figure out inversions.
You want to be able to put your cursor on any object in the world and say, if you were to speak right now, what would your context be that you add?
And it's really helpful to have a way of dynamically hot swapping your scripts.
So it really speeds up your iteration.
You won't fool me again, leprechaun.
What have I?
What?
A lubricant machine.
brain's private reserve of urine.
Shhh.
A longstanding fascination with funny robots.
All right.
That is all of this for how you can make your writer's lives easier.
We will have a moment here to talk about the programming, the guts of the system.
It's time to go off into nerd time.
Before we begin, allow me to remind you, this is not a relational database.
This is not the kind of thing that you can represent as an SQL query.
If it were relational, every criterion would be its own column, whether a rule actually cared about that criterion or not.
You would have all these null fields, and that is neither efficient nor convenient.
Computer scientists would say what you have here is a monadic lookup database.
It's a bunch of rows.
Each row has exactly one key and one value, except the key is a complex predicate function.
It is a tuple of predicates.
each of which has to be true for the whole rule to match.
What does that mean?
It's a whole bunch of functions that all of them have to return true.
Think about how we can implement this.
All right.
Query is a list of strings and variants.
It's an associative array.
When you go to query into the system, you take all the sources of data.
You load them together.
You do the big copy, the associative array merge.
You end up with one gigantic dictionary.
That's your query.
Then for each rule in the database, and for each criterion in that rule, you look up the corresponding factor in the query.
Does it match?
Rule survives.
If it does not match, rule rejects.
Sort the survivors, return the highest scoring rule.
That's your speech.
It works.
It works in cubic time, also pronounced as you're fired.
So we can do better.
Step one, sort the criteria and your rules and the facts in the query alphabetically.
Now you don't have to search back and forth in the query.
It's really obvious if a fact is missing from the query that the criteria needs.
You don't have to do all those hash searches.
A little bit better.
Cubic, quadratic time.
You're still fired.
Let's do a little bit better.
We can skip the merge step.
You don't have to do that gigantic memory copy.
When you're doing a query, it's only important that theoretically it's as if you had all these arrays merged together.
So, if you simply store pointers into your data sources in parallel when you're doing your search, it has the exact same theoretic result, but you don't need to actually copy the arrays around.
It speeds things up a little bit.
You can partition your rules hierarchically.
If, for example, you always know that every rule has a criterion on who is speaking, you can chop up your big table of rules so that when Nick talks, Nick does not query every rule in the system.
No, no. Nick only queries his own rules.
And then you can further subdivide that by what map are you in, what concept is he trying to say, and so on.
If you do not want to have this set of hierarchical subdivisions, you know, each partition having multiple other partitions, you can also hash.
You can take speaker and concept and map and whatever else you like, concatenate them into a string from the criteria, hash that string, and then use that string to pick a bucket.
So you will have one bucket that contains both Rochelle saying, I'm reloading, and Nick saying, I'm hit.
That way, you can divide your speech up into however many buckets you want.
You can chop up your rules by region of the world.
Let us say that you have built a globe-trotting European adventure.
Well, you're going to have quests that take place in England and quests that take place in Spain.
I'm certain the Spain quests are fantastic, but when you're in Spain, you do not need to even query the dialogue that is pertinent only to England.
So why load it into memory?
You can chop up all of your dialogue into multiple databases by region.
See, super simple.
Databases by region.
You're always going to have to have global ones, like, ouch, I'm hit.
But if you're in the King Arthur map, there's no reason to even test the Italy rules.
There's even no reason to load them into memory.
You only have to load the ones for the partition.
Similarly, when you are assembling the query, when you're pulling together the facts about the world, you don't need to pull in the Italy facts when you're doing a query in England.
You can store your sources of fact in separate regions of memory.
And once again, you're only pulling in England when you're in England.
Next optimization, sort your rules by decreasing number of criteria, by decreasing score.
If a six criterion rule matches, there is no need to test the five, four, three, two, one criterion rules.
You know that you've already found your winner.
So by simply sorting them in descending order in each partition, you can speed up your query significantly.
The next optimization, you can speed up the individual comparison of each criterion.
Like, is name Bob?
Are hit points.
I have found that almost every single criterion in a game can be represented as an interval on a number line.
Each one can be like a greater than, less than comparison.
For example, hit points is obvious.
Are zombies greater than five?
Well, it's still an interval.
It's just an interval between a number and infinity on the other side.
You can even represent a string comparison as an interval on a number line if you do not use strings but symbols like I told you to.
Then each string becomes a unique integer and integer can be compared instantaneously.
By the way, you will notice that even though we're doing an equality test here, I'm still doing it as greater than or equal to and less than or equal to.
That is so that each and every comparison can be represented with the exact same instruction stream.
You can store like the type of a comparison of each criterion and say, okay, this one is equals to, this one is greater than, this one is less than, but now you've got all these additional branch penalties.
If you cook everything so that it is always greater than less in comparison, it's always x between a and b, then you can always do the exact same comparison.
You're always doing the exact same assembly.
You dramatically reduce the branch penalties that you're paying on each criterion.
You can get each test down to less than a nanosecond.
Moreover.
If you're on a discrete number system, which any computer is, especially with floating point numbers, you can always turn a strict greater than comparison into a greater than or equal to comparison by adding epsilon.
Epsilon here is not like some vague, ill-defined small number.
It has a very specific meaning in the terms of floating point numbers.
this number being exactly one bit higher than this number.
You can also compare floating point numbers on the integer unit to speed things up significantly if you know what you're doing.
Bruce Dawson knows what he is doing.
So if you go follow that link to his blog, you will learn all there is to know about comparing floating point numbers quickly.
Next, you can go off and do some crazy math in mad science land.
You've got all of these different number line intervals.
You've got n many of them.
It defines an n dimensional space.
Q is somewhere in your n dimensional subspace.
How do you find Q in subspace?
Or you can do it as a spatial search with a BSP or an archery or sort your criteria or use principal component analysis to cluster your rules or eigenvector.
You know, don't.
I've tried this, this way lies madness.
It is not even any faster because all these data structures that I have tried involve chasing so many pointers across large regions of memory that you actually just end up blowing your cache.
If you use the hierarchical partitioning method, you can get it down so that you have a constant time lookup into a bucket of about 12 or 24 rules, even across like a 10,000 rule database.
Once you've done that, it's like 100 nanoseconds to test 24 rules.
It's perfectly fast.
If you are Google and you have gigantic data sets, you can always re-implement the back end as something faster, but the interface will be the same anyway.
So start simple.
Simple is what works.
One other corollary of the system, it is purely additive.
If you have mods, if you have user-generated content, you can add new content simply by adding new rules.
You don't have to go back and change the old code.
If you're always packing along all the world state in every query, you don't have to actually write code that adds new state to the query if you want a new, more specific rule.
So if a modder wanted to add a new character class to a game, then all they would have to do is add new rules pertinent to that class, and even to the other characters for how they respond to this class.
In summary, all this is is a pattern matching engine.
It's a big database of criteria about the world.
It's a big pile of data about the world.
You find which rule matches the criteria the best.
It is super simple, and that's why it works.
You want to, when you're performing your query, to build the context at runtime from all the state that you can possibly gather.
The more state you can throw at the system, whether you think of a rule that needs it or not, the more specific your rules can be when you finally realize that you need them.
You need some kind of follow-up mechanism.
When one character finishes speaking, it triggers a query on another.
It's much easier if you do this without having to glue both characters' feet to the ground.
It is helpful to have some kind of write-back to the world.
That's how you create conditional branches, so the system becomes Turing-complete.
So you create running gags, memory.
It gives you a lot more flexibility.
But most importantly, It has to be something that your writer wants to use.
The person creating dialogue in your game is your writer, and the whole point of the system is that it is convenient for writers.
The more creative writers are, the more easily they can iterate, the more autonomous they can be, the more writing they will do.
And the more writing they will do, the better dialogue you will have.
Special thanks to everybody who helped me rehearse, came to my talks, gave me slides, everyone at Valve except Doug.
And I actually brought it in on time, so are there any questions?
All right, let's go with this microphone first.
Hi, one of the issues that I've heard a number of people raise for these kinds of dynamic dialogue sequencing systems is that writers want to see how dialogue might flow.
So they want to see all the ways that things might come before and come after the line I'm writing now to make sure it always.
presents the character the way I want it to be presented.
Do your writers express that desire?
They did, which is why I decided I was going to go build a visual tool.
It turns out that what my particular writers wanted was actually an SQL query.
But it is absolutely possible to build a visual tool.
Just ask your particular writer what she wants before you build something, because it's not about writers, it's about your writer.
Okay.
Stage right.
So I'm trying to wrap my head around how you would implement it from an audio perspective.
What middleware do you guys use?
Or do you use middleware to get your audio loaded in?
I'm sorry, I didn't hear.
What do we use?
Do you use audio middleware to get this stuff implemented?
How do you load?
The voice files are like waves or MP3s.
And we have a custom tool that just glues them together with animations so that when the scripting sequence decides to play a character, he plays the animation and says the line at the same moment.
There's really nothing special about it.
It's just a sound file.
So you're just dynamically loading packages at level load?
Yeah.
When the level loads up, we just load in the WAVs.
By the way, if you are partitioning up your rules by region, you can use that as a hint for what lines you need to load into memory.
very cool, thanks. Stage left. Uh, hi. Good talk, thanks. Uh, I had two questions. One, did anybody ever ask for an or? Uh, I mean, I know you can do rules, um, and simple is good, but I was just wondering about that.
Yes, you can have an or.
The easiest way to implement or, actually, is just to have two different rules, right?
Two different rules that both match, and they'll play the same line.
Even if you represent or in the interface in the friendly script specification, I recommend that's the way that you implement it internally, because it will make the branching a lot faster, and make the testing faster.
And then the other thing I was wondering about is with writeback, did you ever get sort of artificial shortening of the number of criteria such that something else that had more would win out unintendedly?
As I mentioned, we tried a bunch of different scoring functions.
And in our system, actually, it's possible to give different criteria different weight so that some of them score more for a particular rule.
In practice, we used it very little.
You can see it's really obvious for how to implement it.
It's just we never actually needed it.
OK.
Thanks.
With that prototype you were showing with the robots running around the sewer It seemed like there was a lot more going on than just the audio Because they were pointing at the object in question and they were playing specific animations and so forth So I was just wondering what was going on there. Yes Can actually use my question and answer slides. This is fantastic Yes.
So, you can trigger entire scripts rather than just animation and speech.
Rather than just playing a WAV file, you can actually take the facts that were presented in the query and bind them to parameters of a script that plays.
So, in those cases, we had an actual script for the robot.
It wasn't a sound file.
It was like turn, play point animation, bind to thing.
And the things that he was turning towards were the same parameters that were used for the voice query.
Thank you.
Stage left.
Hey, great talk.
You explained that when the criteria are looked at, you pull information from games, objects, or states.
I was wondering, do you ever run into problems that, like threat problems, or that you have criteria that just flip in one frame?
Like for instance, when an entity is shooting, is that only like on for one frame?
But then when you evaluate the rules, you know, that bit is not on your thread or on your frame.
We have a single-threaded dialogue system, which solves a lot of those problems.
But for things that are transient, like shooting, you want to store not, is he shooting this frame, but when is the last time that he has shot.
Has he shot within the last quarter second?
And that can count as the same kind of thing.
It gives you a hysteriasis in your query.
OK, thanks.
Yeah, trying to think how to phrase it.
But do all of the key values evaluate to some Boolean state?
Each criterion evaluates to a Boolean result.
That's what makes it a predicate function.
In the fact, the key is any string, and the value can be any kind of number, string, whatever variant type you want, as long as the relevant predicate function.
takes that type as its parameter, but the predicate has to return true or false.
Okay. Was there ever any desire to add something with more weighting to it, or more individual state per key, or would that defeat the purpose of key principle?
Just add more keys.
Stage left.
Doug says he's sorry, but he was really sick, that he missed your thing on Monday.
Aww.
I was just wondering about Left 4 Dead is primarily a multiplayer game, and so I was wondering is there a concept of a host that plays and then propagates like the sound files and what sound files to play across the network, or do all the peers play them individually and it might be random or might be different, I guess.
Are you asking, like, is all the logic run on the host?
Yeah, or can the clients themselves play different dialogue to what the host hears?
Do people hear differently?
In our implementation, it is completely client-server.
There's a left-footed server.
The clients are all done.
They're just telling what the server tells them to do.
And the server is doing all the logic.
Now, you can see it's actually not hard to implement it in a peer-to-peer way, to have the clients independently pick lines.
So now you have the problem of they may pick different minor variations in the line.
You have to find some way to resolve those things.
We didn't, because we're client-server.
right? One more? Oh, uh, sorry, sit right. So if you're doing, uh, the responses to someone else's line and you have a number of characters that can all respond to the same line, um, and the logic is per speaker, how do you prevent them all from responding at once?
So when we do the then any query, it's like querying all the nearby characters to ask, you know, which of you has a response.
It finds the highest scoring one.
Because all the characters are being tested simultaneously in that any query, we only pick the highest scoring one.
If they're equally scoring, we'll pick one at random.
Because it's really kind of the character who has just said the line, who's querying the neighbors to make them speak.
Stage left.
A great talk, by the way.
Thank you.
With all this dynamic content, some lines are going to get played a lot more than others.
I know Valve does a lot of data tracking to see how much of the game gets completed and such.
Do you have any kind of metrics for that for how some lines that are ultra-specific get played more or less often than others?
And what was feedback on that?
Do we have a database that stores how often each line gets said?
Yes.
Do I ever look at it?
No.
Ha, ha.
Ha.
Ha.
Stage left.
Hi, I'm actually coming from the other side of the fence in that I am actually a writer.
So thank you so much for making this, you know, this code and this tool that makes people like mine's job easier.
But I am wondering, you know, in that you've taken the time to sort of help the writers out with their job.
How can writers help you out with your job?
How can writers, you know, go and meet the programmers midway to, you know, to make your job easier?
Well, for one thing, simply thinking about dialogue in this way, in terms of a series of general to more specific rules matching state about the world, it's a lot more convenient than having to think of a whole bunch of explicit code hooks that are all super specific.
Moreover, being clear about what is a useful workflow, because at the point that I made, smart writers know what works for them.
If you're clear about what works for you, then they can actually build the tool that works for you, as opposed to simply guessing.
Thank you.
If there are no further questions.
And I have the prerogative of playing the last slide of GDC.
I have been waiting for this for days.
Smooth jazz will be deployed in three, two, one.
