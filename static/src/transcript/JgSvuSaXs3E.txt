So hi everyone.
Welcome to this talk about data-driven gameplay effects on For Honor.
Before we begin, I'd like to remind you to silence your phones, and also to please fill out the evaluation at the end of this talk.
So my name is Aur√©lie Lechevalier, and I'm a gameplay programmer at Ubisoft Montreal.
I've been working there for about five years now, and I've worked on Rainbow Six, Child of Light, Shape Up, and For Honor.
So I'm sure that many of you have played For Honor.
Come on! Yes!
But for those of you who don't know, it's an online multiplayer combat game.
It's a fighting game, competitive, and let's watch a small trailer.
So what are the modifiers?
Modifiers are contextual gameplay effects.
They serve to change the stats or the behavior of some of the entities in our game.
So our fighters can apply status effects on their opponents.
In our campaign, we wanted each of our bosses to feel unique and different.
The feats are abilities that the player can unlock and activate along the course of a match.
And finally, the gear directly modifies the character's stats.
So what's the problem that we were trying to solve with this, with the modifiers?
Essentially, all the systems I've talked about are all very similar.
They're all trying to affect gameplay in very similar ways.
And originally, the system was developed for the feats.
And so the feats, we knew that we were going to have about 72 unique feats, but we weren't sure what was going to go in those feats.
So we needed to make our systems be very open and data driven and allow for experimentation.
So here was how we did it.
Basically entities in our game have a handler and that handler manages a list of modifiers and those modifiers contain effects. Effects are gameplay blocks written by the programmers that go and change something about that entity.
So The effects that you're going to need really depend on your game.
But for us, this came into five major categories.
So modifying stats, disabling capabilities, adding tags, removing modifiers, and creating new effects.
So let's go over that.
So modifying stats, only by a certain percentage.
So that's how we did it.
We come from a base value, and then we want to change it by a plus or minus some percentage.
So in this video, we will see the berserker activating the run faster feat, and so after that, they're gonna run faster, about 50% faster.
This is one example.
So capabilities are actions that the entity can do, like going on a ladder, doing an attack, dodging.
By default, all the capabilities are set to true, but the modifiers can come and disable them.
So in this video, we'll see the Peacekeeper, and the player is spamming the dodge input.
But we don't want the character to be able to dodge too often, because that would break the game.
So at the end of her dodge, we apply a modifier that disables her dodging capability.
So despite her pressing that button, she can't dodge right away.
So adding a tag, these are labels that say that the entity has a certain property or status.
Examples of these are being in stealth mode, being stunned, or being uninterruptible.
So in this video, we will see the warden throwing a stun bomb at his own feet and stunning himself.
You'll notice that the UI gets hidden, and there's a post effect that makes it harder to see what's happening in the game.
This is done as a modifier.
So an important feature for the system to have was being able to remove active modifiers.
For example, when we heal, we want to remove any poison effects.
This is exactly what you'll see in this video.
The Orochi is going to activate his poison feat and poison the Warden.
The Warden then runs to the nearby capture point to get healing and remove his poison effect.
And finally, the system can create new effects.
So this allows modifiers to spawn other modifiers, to create areas of effect, or to create attacks that come from nowhere like the poison, which ticks every two seconds and is treated as an attack.
So in this video, we'll see the Conqueror, which has a feat that allows him to heal every time he blocks.
He doesn't block, nothing happens, he just gets hits.
And then we see that there's a modifier that gets applied for 1.5 seconds after he manages to successfully block.
These are examples of all of our effects.
So what we've seen so far is only half of the equation.
The second pillar of the modifier system is context.
So context is whatever is happening in the game right now.
This is important because we want our modifiers to be able to react to the current state of the game.
So context for us came in two parts, duration and conditions.
So duration is a very simple concept, but it's very powerful because many of our effects are temporary, so it was a feature that we needed.
And changing their duration can drastically impact the gameplay.
For example, the length of a stun is the difference between life and death.
And the second part of context is conditions.
So we're able to attach conditions to our modifiers and those conditions are able to have checks on the game state.
When the condition is met, the modifier is considered to be active and thereby it's applying its effects.
When the condition is not met, then the modifier is inactive.
It's still there, but it's not applying any effects.
Now what's cool is that we can combine these conditions.
with logical operators like and, or, and not.
So for example, our capture points by default give one point per second while they're captured by a team.
But we have a modifier on them that says...
that has a condition saying if it's captured and we have a player in the zone, then we double the amount of points that we give.
So our modifiers can also be applied on other entities like the capture points and NPCs and interactive objects.
So some of our most common conditions on For Honor, I'm going to go through two of these.
One of them is the action state condition.
So this is whatever the player is currently doing.
What movement state are they in?
And what's really powerful about this one is that we were able to check the clip type that they were currently doing.
So their animation type that we saw in Katana if you went to the previous talk.
And so this gives us a whole lot of detail on what the player is doing.
And it's easy, it can be dynamic, so it's easy for designers to tweak.
So in this video, we will see the Lawbringer.
And he has a modifier that makes him uninterruptible while he is reviving a teammate.
So that condition is on the revive action.
So we can see that he didn't react to getting hit, but when he stopped doing that action, then he can have hit reactions.
The second major condition that we use is the attack condition.
So the attacks are really the core of our game.
So it made sense for us to have something, to have the ability to check details about this.
So we can check if we are doing or receiving an attack.
We can check the attack properties, or if it's a specific move, and we can check the result.
So was it a hit, a block, and who did I hit?
So back to our conqueror.
This is not a video, this is just a screenshot.
And this feat, actually the block feat, is a little bit more complex than I showed in the previous video.
What happens in reality is that we have three modifiers for this feat, and we want to give different amounts of healing back according to what type of attack the player blocked.
So if we blocked a light attack from a player, we want to maybe just give him 10 hit points.
But if he blocked a heavy attack, maybe we want to give him 20.
And if he blocked something from our low NPCs, our soldiers, then we want to give very little, maybe just 2.
So one last thing.
I already hinted at it previously, but just to be sure that it's clear.
we can apply modifiers on other people as well.
So the modifiers are on the entity, but there's times where the entity interacts with other entities.
For instance, when I'm doing a revive or when I attack somebody.
And this provides an opportunity for us to apply modifiers on that other person.
So an example of this is for the poison effect, which you already saw, but let's show it from the other side.
I activated my feet and now, the person that I hit has a modifier that's making them bleed over time.
All right, so.
So now that we've seen what the system can do, let's look at what this means in terms of production.
So the system was very versatile for us because the conditions and the effects are all modular blocks.
So we can combine and reuse them in interesting ways to create complexity.
So let's take, for example, I have a damage boost effect.
And if I combine it with an on capture point condition, then I've got a sort of defender feel to my modifier.
I can reuse this exact same effect with a low health condition and now I've got a sort of last stand, maybe berserker effect.
And finally, if I use this damage boost with a condition that says that my attack was blocked, I get chip damage.
So this is very powerful and it actually enabled us to create generic effects.
I just have a damage, speed, and healing instead of having a damage when low health, damage when bleeding, and then having a whole bunch of if conditions inside the code.
What's even cooler is that because all of our systems use the modifiers, when I add a new effect or a new condition for one feature in one specific case, all of my other systems can benefit from that.
So then all the designers can reuse this and we don't have to add extra code.
So this is actually great for content creation, because we reuse the options that were already created.
So most of the time, when someone comes to me and asks, oh, you know, we need to do this new feature.
I'm like, you can already do it, and it's awesome.
I don't have to do anything.
They can work by themselves.
It's perfect.
Which brings me to designer autonomy.
Since this is all in data, the designers can create this autonomously and they don't need to go through a programmer in that long loop of requesting something, waiting for the programmer, having it tested.
They can bypass all of this.
This allows them to iterate very easily.
They have lots of power to test ideas and to test variations of their ideas in a short amount of time.
What's more, if they change their minds, They don't have to, like, it doesn't need to go through that whole pipeline again.
They can change it themselves and it's much less risky to test.
So this was very, very scalable in terms of programming for us.
Because once the base is done, so you have the handler that's able to manage effects and conditions, all you have to do is add new gameplay effects and new conditions as your game progressively gets more and more complicated.
Cool, so now that you understand the concept and what it means for production, let's take a look at implementation and go a little bit deeper into that.
So there's two parts really, there's how the setup looks in the data and then there's what happens at runtime.
So let's say that someone comes to me and they're like, yeah, I need this new feature and the first question I ask them is where does it start?
Like who is the one that's applying this effect?
These are all examples of the origin, that's the concept, the name that we use for this.
Modifiers are used as a service by all of these systems.
And when a system wants to apply modifiers in the game, in the data, they have to be able to reference a modifier data file.
And so, we made these modifiers, we chose to make them as separate data files.
to make it easy to track in the Perforce, in the history.
So we're able to see the history of the file, to track bugs more easily, and to see why certain choices were made, because we always have a change list associated to that.
So here's an example of what it looks like in the data for our designers.
So unfortunately, I don't have a really nice tool like the Katana guys, but it's coming, it's coming.
So for now this is all in the property grid, but here we have an example of multiplying the revive other speed, so it's how quickly I'm reviving somebody by, and we're doing a minus five percent on the amount of time that it takes.
So the effect type that we choose for the stats here is from a dropdown menu, and this is created by the programmers.
This is an enum in the code, and so what's nice about this is that as programmers we have control over this.
We can choose what's the best way to implement something, and we can make sure that we're not duplicating effects.
We can keep them generic.
You'll also notice that.
We try to make it easier for our designers to read all of this, because sometimes in the property grid it can be a bit hard to read.
So we provide a little summary at the top of the effect so that they don't have to go and dig deeper.
All right, so now that you've set up the data, let's see what happens at the runtime.
So the handler, the handler's job is to handle requests to activate new modifiers.
So once a new modifier is activated, it makes an entry for it in its list of entries, and it's going to update all of these entries.
So at the update, it's gonna check if the conditions of the modifier are true, and it's also gonna check the duration.
So when the duration expires, it's just gonna remove that modifier.
So what does the entry look like?
Basically, we keep the start time, so the moment at which the modifier was applied.
We track its origin, where it came from, if the condition is true or not at this frame, and a pointer to the modifier data.
So, then once we have that, how does the rest of the code check for the modifiers?
So, I call these queries, code queries, and they really depend on each effect type.
So, for modifying stats, the sort of accessor and query I'm going to make is compute the modified value.
So, how much am I currently modifying my attack by, for instance.
For capabilities and for tags, what I want to check for is just is it enabled or not?
Like is this capability disabled?
As soon as I find one modifier entry that says that it has that effect, I can return.
Same for the tag.
And then for removing a modifier and creating a new effect, these are actions.
So they have to be triggered somehow by an event.
In our case, that can be once we activate the new modifier.
So when it starts, it can be when the condition becomes true.
Or it can be even ticking, just like the damage over time, which ticks every two seconds.
So let's look at a concrete example in the code.
So for the blinded, the stun effect, you saw that the HUD gets hidden.
And so in the UI update, we can just check if the player has the tag blinded, then I hide.
So this creates a query, which is really not a fancy query.
It just goes and asks.
to the handler and the handler is going to go through all of its entries and if it finds an entry which condition is true and Which has the effect blinded it's going to return true. So that's the sort sort of how it looks like So I want to take a tiny bit of time to talk about feedback because our players don't necessarily know that all of this is happening and we need to communicate that to them.
So the modifiers need the feedback hooks to be able to show what's going on underneath.
So we have three types.
The most basic one is alive.
So alive is very simple.
It's as soon as the modifier gets created, as soon as that request is made, and it disappears at the end of its duration.
So we would say start alive and then end alive.
If the modifier is conditions, then we have the active feedback hook.
So this is as soon as its condition starts being met, we say start active, end active.
And then there was a sneakier one, which we didn't find immediately.
This was effects applied.
Because sometimes I want my cool effects to only happen when my modifier actually changed something in the gameplay.
So let's imagine that I have a damage buff, but then I never hit anyone.
Well then it's not very cool.
Like my modifier didn't actually change anything in the game.
So I want maybe some special effect for that.
And what's really cool about this effect applied is that we can send a callback to the origin system.
So in the next video we will see that in this case we want to give a callback to the feat system so that we can have some feedback in the HUD as well as on the player's sword.
So this is a feat that heals the player every time they kill an NPC.
And we can see that we have...
feedback both in effects on the player and in the bottom left in the UI.
So the players have effects and sound and all this cool stuff, but us developers, we don't really get anything.
we need to be able to visualize the system as well, even without the pretty effects and all of that.
So debug display is really crucial to this system.
We have two versions.
The first one is the light version.
And as we can see, it's unobtrusive, it's easy to understand, and it's not too detailed.
And as the programmer who worked on the system, I always kept it active.
And this really made it easy to spot minor bugs, like modifiers that never end, if someone forgot to set their duration.
the conditions that are never met.
And it was good for designers, uh, for them to check if their modifier was even on the entity, you know, that they were checking because they might be like, oh cool, I'm going to start this modifier.
But then it, you know, they're like, it doesn't work.
And I'm like, well, did you check the debug display?
And then they're like, oh yeah, it's not even on the player.
So then their problem is higher up somewhere else.
And finally, we have also this debug display.
So this is way more detailed.
This is more for when you get a mysterious bug at a tester's desk and you are not sure exactly which version of the data they have.
So what's interesting about this is that we show both the data, so exactly what was set in the modifier, all of the effects, all the conditions.
And we also show the runtime info, so the origin, the duration that's left, and whether the condition is currently being met or not.
But it's a little hard to read, but it's okay.
So I want to take the rest of this time to talk about challenges because that's really where we can see interesting and new things happen.
So, there's three areas that I want to talk about.
It's in terms of data, what did this entail, for effect stacking, and for programming.
So the first issue that we encountered was usability.
And the property grid can get a little bit complicated and usually it's not so bad for the modifying stats effect that I showed because it's always one specific effect.
But the complexity in the usability really rose when we added creating new effects because all of a sudden there was more layers in there.
So that was a little bit harder to read.
And then another issue that we had was for standards.
So originally, since this was only used by the feet, there was one designer associated to this.
And so he had his own standards.
And then when other designers started using the system, because, well, it was very powerful, so different features were like, ah, we should use the modifiers.
So then more and more people started using it, and that's where we had.
a lot of data duplication so some you know the modifiers were always meant to be a little bit more generic but sometimes we were creating the same effect many times in different files also the naming conventions well there were none so this is pretty much each designer did whatever they wanted which was okay it's just we wanted to keep that as clean as possible and of course the more data you have the more the harder it is to enforce these standards.
So I'm going to talk about that a bit after.
The other problem we had was when we had duplicated data, how do we feedback it?
Like we needed our feedback artists to go and plug their feedback on every single modifier file.
It was very easy to miss some and it hindered prototyping because when we created new cool effects, well they didn't know where to plug in the effects, so we weren't able to visualize as well what was happening.
So this was also a challenge.
So our solution, something that we tried, was called the status effects.
So what I've shown up till now, the effects are contained directly inside the modifiers.
And then the effects is, the effects, sorry, effect, effects, the effects is plugged in on that file.
So what we did is we extracted all of the effects and we put it inside a different structure that we call the status effects.
And the idea is that all the modifiers could reuse that.
And the status effects were supposed to be set up just once in a very generic way.
So damage, boost, you know, very standard.
And then they were to be referenced by all the modifiers.
So we were hoping to see less duplicated data, more consistency in the standards, and yeah, all these great things.
And then the effects could be plugged directly on the status effect instead of each modifier.
So the question you might be asking yourself is how do we share these status effects if we want different percentage values?
Like in this case, if I want my low level shield to only give a plus 5%.
and I want my super heroic shield to give plus 50% of defense, let's say, how can they share that data?
Well, what we ended up doing is having several levels of power inside our status effects.
So the lead designer, the designer would set up all of these levels and then the modifiers would reference a specific level of a modifier.
So was this a success?
Sort of, sort of, it's not perfect.
So it actually worked pretty well for some designers, mostly like the designer who helped me make the system, it was very clear to him.
But I think we didn't actually do a very good job at teaching other designers how to use it.
So there was a bit of a problem there and I think better tools would have helped with that.
So for the designers that understood it and used it, it worked fantastically well.
For the feeds, what you want to see is only 20 status effects and 100 modifiers, that's the ideal.
But for the designers who weren't using that, it ended up just being an extra layer of complexity for them.
And they didn't really understand why they needed that.
So, mixed.
The next topic I want to talk about is how to stack effects together when you have effects that are coming from so many different origins.
So at the beginning we were doing it very naively.
We were adding up the stats modifications together.
So if I had a modifier that said plus 40% damage and then another one that said minus 15% damage, my total would be 25%.
Makes sense, right?
First problem we encountered was busting our limits of OP.
This was way too powerful.
We quickly went into that realm.
So the first thing we introduced was a min and a max.
Pretty standard, right?
And so what's interesting about this too is that we had different mins and maxes by stats that we wanted to be able to modify.
Because maybe I want to be able to revive someone a thousand percent faster, but I never want my damage to be more than like 200%.
So it's interesting to have this ability of changing that.
Now the second more interesting problem that we had was how to deal with different origins.
So let's say I'm playing the campaign and I've got a boss that does 10 damage normally.
But I'm playing the campaign in easy mode.
And let's say that means that he does 80% less damage.
So that would be two damage.
But now, if he activates a feat that gives him plus 50% damage, how do we stack these?
So the naive way would be minus 80 plus 50, which is negative 30, which is seven damage.
Now that's kind of weird, because my boss was hitting at two, and now he's hitting for seven?
Like, what was this, you know?
So we had to do something a little bit different.
What we ended up doing, and the correct way that we wanted the system to work, was to apply the 80% first, and then the 50%.
So that gives us two, and then plus 50% free.
So this led us to introducing the concept of core versus external modifier origins.
So core was the gear, the campaign, and the AI archetypes.
It's anything that's really intrinsic to the character and that's not going to change along the course of the game.
And for external, that was the feats, the boosts, and the missions.
These are dynamic.
We want, these can change, and we want our players to know about them.
Which also leads me to feedback again.
We did not want to feedback the core modifiers, but we wanted to feedback the external ones.
Because the player needs to change their play style when that happens.
So we need to, again, communicate that.
So was this concept a success?
Yes, yes it was.
So it worked well on the player side.
They understood when they needed to change their play style.
On the data side, this also enabled us to reuse the same status effects and even the same modifiers because we were able to do that.
And it made it easier to balance the campaign and the gear because we didn't have to worry about the relative power of modifiers.
However, it also made the code a little bit more complicated because we had to handle two layers of stacking.
And it made it a little bit harder to predict the behavior of modifiers, because the same modifier applied by two different origins could have different effects on the game.
But with debug display, this was all right.
So for programming.
One of the major challenges was the API.
Making your code easy to use for programmers is just as important as making your data easy to use for designers.
They might have to add their own effects.
And the thing is, these modifiers were getting called a bit all over the place.
We have so many different types of effects.
And even though each effect is checked generally just in one place in the code, well, every time you add a new one, that's an extra code.
So at the beginning, our code to compute the modified value was about seven lines long, and this was really horrible.
And it included computations of the plus and minus, and sometimes we were like.
getting the computation wrong.
So we did a big pass on the API, we created a separate modifier utilities file that handles all of our basic queries in a very clear way and concise way.
And the idea is to encapsulate the complexity as much as possible.
So data-driven is always a challenge for programmers because we don't like giving up control.
And I understand.
But in this case, in general, it worked out very, very well for us because the effects were always checked in one place.
And it was not very complicated what each effect was doing.
So generally, it was fine.
The one case where it was problematic was when we were trying to compute.
the amount of bleeding that was going to happen.
And now, this seems like a silly example, but it's, like, this function to compute that little red bar is like 100 lines long.
Because we have to go through all of our modifiers, and then check inside their status effects, and then check each of their effects, like, okay, is this a looping attack?
Oh, good, that's a poison effect.
But then you have to go back and check how much time is left on my modifier.
and then you have to add all of those together.
So this was a bit inelegant, and I hope that it's bound to happen if you have to go and peek inside that data to do things.
Another note on the poison and damage over time effects.
So we realized that we were gonna need to add an extra feature to our modifier system.
So let's say this enemy here is really mean and he's applying damage over time and he's like, ha ha, now you're poisoned.
So I start bleeding, two damage, two damage.
And now he gets a damage boost.
So like I said, the damage over time is treated as a normal attack.
So how do we figure out that normally that the damage boost would be applying on the bleed?
but that wouldn't feel good because it's over time.
So 10 seconds after, if he gets a damage boost and I start bleeding more, I'm gonna be like, what happened?
It's really hard for the player to read that.
But we still want the damage to apply if the boost happened before the bleed.
So what we ended up doing was introducing the concept of snapshots.
So each effect can say, oh, I'm going to require a snapshot.
And we're going to store that in the modifier entry.
And we take it when we activate a new modifier.
At the beginning of that, we're going to take a snapshot of the current modifiers affecting the attack of.
the attacker and the defense of the victim.
And then when we go through that attack code, we're gonna use the snapshots instead of the current modifier state.
So optimization.
As you might have noticed, we do polling on this system.
And we have about 3,000 queries per frame.
because of all our different 200 soldiers and then eight players.
So that can be a bit much.
So we had to optimize it, especially at the end, of course.
So the first thing that we did is have a maximum amount of entries per entity type.
So our soldiers, we don't really need them to be complicated.
We gave them a maximum of six modifiers.
But our players, well, they can have a lot of stuff happen to them, so they have up to 30.
This was good, but it wasn't enough.
So we added a bit field.
So basically, every time I activate a new modifier, I update a bit field saying what effects I'm currently changing.
So if I add a damage boost, then at the damage boost bit, I'm going to say 1.
And then that's how it's going to work.
And then once I do my query, I know exactly.
what I'm looking for, like I'm looking for damage, and I can immediately check right away if I have that one there or not.
And if I don't have an effect that touches this value, I completely bypass the query.
This made us save about 80% in performance, because it also makes sense since not all of our entities can react to things.
Like we don't really want to have a...
revive for our soldiers.
That's not something that's important.
And instead of having to add specific checks in the code by effect type, being like, oh, if it's a revive and I'm a minion, don't do it.
Don't do the check.
Like this query, this bit field allows us to bypass that no matter what, because they won't be affected by that.
So to recap, the things that went right.
Modifiers were used everywhere.
This is cool. All of our systems were using it. It was a centralized way for our game designers to input content into the game.
debug info was so, so important. It allowed our designers to really visualize the system, not just our designers actually us to like we it was a it was super useful to understand what was going on.
Ownership I think was key as well. I was the only programmer on the system and I was working very closely in collaboration with a designer.
We really tried to make the system appropriate for the needs of the project and their workflow.
And finally I think that the reason it worked was because it was so simple.
Our effects are generally not very complicated, and we didn't do like node driven things.
We didn't let our designers shoot themselves in the foot.
Because when it's complicated, then it's so much harder for everyone.
It's harder to optimize, it's harder to debug, and you end up, if it's too complicated, you end up having to do a lot of the data yourself, whereas here they were really independent.
So the modifiers, these are our numbers, there was about 60 used for the fight system, 200 for the feats, 40 for the gear, and 200 for the campaign.
And we had an extra 200 that were used just for prototyping.
So things that could have gone better...
The modifiers were used everywhere!
So sometimes modifiers were not the best solution to things, like especially things like friendly fire in campaign.
There's a modifier on each of those soldiers saying, I'm not gonna damage my allies.
No, no, that's way too much cost.
And it's something that we know is always gonna be true in campaign.
It would have been just a lot easier to do it without going through that.
There are also cases where, you know, if they take no damage and you push them off a cliff, like what happens?
Had to be careful with that.
In terms of testing as well, so generally since the system was pretty simple, there were really few bugs.
It was really nice.
But when there were bugs that I would introduce, I would usually, like no one would know.
And that's a little bit sad sometimes.
But, uh, so I'd realize I'd be like, this hasn't been working for two weeks.
And, you know, everyone's like, oh, cool, cool.
Uh, so, so really like, uh, testing it could have been a little bit better, but sometimes it's hard to, to know the difference between like a 24% and a 26%.
So that's where debug tools are, are really useful.
And yeah, just knowing the system since it's used everywhere. It's good if we try to share that responsibility like each designer can try and know their system really well and just check that it's fine, you know, every once in a while.
And finally, in terms of usability, it was still hard for our designers to, to like see the data, to set up the data itself sometimes, like they'd get too absorbed into the property grid.
And then like sometimes they would do loops.
So, yeah.
So this brings me to the future plans.
I'd really like to have a dedicated editor to help with the setup of the data and the debugging as well.
An optimization that would be nice is for permanent modifiers.
Basically right now, our gear is always there during the course of the game.
You can't change it at runtime.
And it takes up 18 of our 30 slots, which is a lot.
But if they have conditions, we need to keep them as runtime entries.
But for those that have no duration and no condition.
we could just store them somewhere else.
Just considering still that memory was really a scarce resource for us.
So I'll try to find a way to do that.
The status effects, we want to evaluate them and make sure that.
there's still what we want to do.
I think one of the things is that right now every effect needs to go through a status effect and that's not necessarily very useful when you're creating new effects because you're usually referencing a specific effect like I want to create this specific area of effect or I want to apply this specific modifier.
So maybe there's something to rework there.
And then I'd like even more debug display for our testers, like seeing exactly how much the total of the modifications that's happening, like what's the final state, you know?
So to conclude, I think this system was really empowering for our designers.
It gave them hope.
They were like, oh, maybe I can prototype this by myself.
And they were all excited, and they went in their corner and jammed.
And that was really, really nice.
They were enthusiastic about their work, and it led them to iterate more and experiment more, which ultimately, I think, created a better game.
So thank you.
Is there time for questions?
I don't know.
Yes?
OK.
One?
OK, cool.
Thanks.
Yes?
I went to the previous talk, and he had the simulation as deterministic.
And so it would backstep because of inputs and everything like that.
I'm going to assume that had a huge effect on your modifiers.
Because of damage over time, it has to be backed out and then recalculated and backed out.
Yeah, yeah, yeah. That's a great question.
So actually we were really lucky because there is a history buffer for the modifiers as well.
They're all stored in a deterministic list.
So when we go back in time, we just go back to that stage and then...
So we revert the health, we revert everything.
But all the modifiers had to be kept track of and everything and then you had to maybe change which ones are applied.
Yeah, yeah.
Wait, can you repeat that?
Well, I mean, because the timing of things are things.
So somebody, so you find out that somebody applied and hit a button that caused an ability that removed a modifier.
So the modifier you'd already calculated, turns out it didn't happen in that frame because now it's been removed and that changed anyways.
No, no, that's a great question.
So since it is in a state.
when we roll back to a previous time, everyone's gonna be in the right modifier state.
So if it turns out that that modifier got removed, then when we roll back, it's still there.
And then we can re-simulate all the steps and come back to the same conclusion.
So we were so lucky with that, with the way our simulation was made.
As gameplay programmers, we almost didn't have to ever think about those sorts of cases.
So it just kind of worked for you?
Yes, it was great.
Thank you.
Yeah.
Hi, you said you had problems with testing.
Yeah.
Did you do any unit testing?
Unit testing.
So we're actually starting that.
Yeah, we're, we didn't do any yet.
And I think that could have helped like so much really, especially when the system, you know, became more complicated, like all these different origins and the stacking and all of that, that could have been so useful.
So I think it's definitely something that I want to add.
Okay, and I have another short question.
Because of these handlers and these arrays and bit masks and so on, have you considered using an entity component system to actually code the whole game, which would have solved all of your problems?
What do you mean?
So I would have to explain what an entity component system is.
Yeah, we can talk about it after.
Yeah, we can talk about it.
Because we use entity component system already.
Okay. So that's why.
Okay, I'll talk to you after.
Yeah, cool.
Hello, I have two questions about the modifiers.
Several years ago I developed a similar system before.
I made two, I think it's a little hard.
One is some effects, depending on the resource you use, the entity you use.
For example, some boss, some monster is very big, very tall, and some is very small.
And if you, the same modifier will attach or same particle in special bone, but the two different monster have different skeleton.
So, how do you deal with this?
Another question is, how to say?
If two, for example, if two daughter modify, take active in the same entity, and then do the same thing, and the same thing will complete with each other, for example, then play the same animation, or change the same parameter of matrix.
Yeah, okay, I see what you mean.
Uh, yeah, so most of our effect types, they stack nicely.
I forgot to say that.
But, so basically we tried to avoid that problem.
So when we disable capabilities, it's always disable them.
So the capabilities means that you can't go into a certain animation.
So it's always negative, so it doesn't matter.
The same for like tags.
Basically we don't have any conflicts except for the modifying of stats.
So adding percentages together.
But we don't have effects that conflict otherwise.
Okay, thank you.
Well, actually there was a slight version of that, you know, when we were...
What happened is we had a health regeneration and the damage over time at the same time, and that was really hard for the player to read and understand.
So that's why we introduced the concept of removing modifiers.
So that way I can say, as soon as I start healing, I remove my damage over time.
So we sort of bypassed it.
Okay, thank you.
It was kind of curious how you handle balancing all of your effects across from each other for your designers because I didn't really notice any system for actually like looking at in bulk multiple items and like stacking them up and all that and I know I could never get our designer out of Excel because of that very reason.
Yeah, that's a very good question.
How do we handle balancing?
So we don't have an official process, but basically we try to get designers to talk to each other.
It's really that simple.
So they really do talk a lot.
It's nice.
Because yeah, we have the gear.
Yeah?
Excel hammer?
Yeah, OK.
So there's also an Excel version of adding these modifiers to help visualize.
all of the different levels. So for our gear for instance, we, you know, it can be hard for a designer to like keep track of opening each data entry and being like, okay how much is it? So they can actually export that and import it back in Excel where they have a pretty good view of it.
But then for stacking between different types, well, we just we ask them to talk to each other.
Hey, great talk. I'm currently using a similar system, even if it's a bit less evolved.
And my question is, have you ever encountered the issue that you have a modifier that turns a feature on and off, that enables something or disables something, and then the assets that you need for this feature needs to be baked or cooked in the game. So, since it's all data-driven...
Did you have to manage this in a special way or not?
I mean, do you see my point?
I think I see it.
Do you mean like in terms of, for instance, like effects and sound loading?
Yeah, or animations or voices.
So that's actually something that we have to work on as a team, because right now we load a lot of things.
But there would be a way to do that.
The thing is it does.
We try to load only what is currently used in the game, but it's all through references.
So if we have something that's pointing towards that effect, it's going to be loaded.
But right now the problem is we load all the parent things.
You just reference everything so you don't have the problem.
So for instance, the feet right now, even though you can only equip four in game and you can't change them, we're still loading all of them for all of our characters which points to a lot of effects and sound data.
But we're planning on removing and only loading the ones that we need.
So that should help a lot.
Thank you.
Yeah, okay. Well, thank you.
