Good day.
Hi, everyone.
So if we could start off with some housekeeping.
First of all, if you could turn off your cell phones for the next hour, just mute them or whatever.
And at the end of the talk, I'm going to ask you this again.
But if you could answer the feedback email that GDC sends through to you.
OK, with that, let's get started.
Hi, I'm Claire.
I'm from Sony.
I work out of London, and I work as a senior online consultant.
So mostly I work with first party titles.
And occasionally, I'm lucky enough to work with some indies through our strategic content or ex dev teams.
So what is this talk and what isn't it?
First of all, this talk is for generalists and indies, people without network experience.
At the end of this talk, hopefully you should know all the things you don't know about networking.
And you can take maybe one or two of those topics, and you can research them in your own time and find out what you need to do for your game.
Okay, so the first rule is everyone connects.
Even if you are making a single-player title, you will be connecting to platform services.
So, we're going to go through a bunch of stuff that you can do in a single-player and a multiplayer title.
First of all, you need to leverage the power of the platform.
If you're on Steam, if you're on Xbox, or if you're on PlayStation, there is a whole range of services that are provided to you for free to use and abuse.
Now, the difficult part about networking is actually to make it cheap, to make it scalable, and to make it fast.
OK, so the other thing I love about networking is with a little bit of networking, you can actually do really powerful features.
But these are the kind of things that a designer can't necessarily come up with themselves.
And that's where your technical expertise in networking is really going to help.
And if you're an indie where you've got multiple of this stuff in your head, that's kind of a superpower.
So, let's start off with trophies. Traditionally not thought of as a networking feature, every title has it. Now, the interesting thing about trophies is that they're stored on the server and they're shared. So, this is a water cooler moment that you can create. This is a shared social landmark.
So without writing any real network code, you already can have this common reference point.
And you can say, hey, your friend has already achieved this trophy.
Or you can highlight activity that's going on in the game.
It's a very simplistic example, but it's a good example of how a traditionally non-network library can be used for networking features.
Leaderboards are perhaps one of my favorite little hacks and usages.
High score tables were kind of the first reason we invented save states and persistence, right?
They're the first long-term data store that we started doing in games.
But then once we took those same leaderboards and we made them online, they're now shared online persistent state.
And that's really exciting.
That is a world view we all share.
Now, the cool thing about leaderboards is, first of all, find out if your platform has fixed or flexible leaderboards.
Fixed leaderboards can be a bit of a pain in the ass because they require pre-setup.
And flexible leaderboards, you can do all sorts of things like create leaderboards on demand for challenges and features that are hyper-specific.
then the really cool thing is your leaderboard data does not need to match the UI you display.
So let's say I get a score of 100.
Well, if instead of posting 100, I post 1,001, then that 1 can be used to represent that I played a rogue on that particular mission.
And I can surface that data up.
And as long as a good score is a higher number, the leaderboard will still function.
You are responsible for always displaying your leaderboards.
So that's a really cool little hack.
And using the least significant bits, you can pack a lot of data in, and that can give you a much more interesting leaderboard.
The other thing you can do is you can put a simple checksum in your leaderboard score posting.
Now that sounds like a bit of redundancy, but by putting a simple checksum bit in, you will avoid a lot of the hacks that happen on PC leaderboards and mobile leaderboards where they do large-scale score posting.
And if your score has some intrinsic little bits to it, like some custom code that's yours, it's very easy to pick out when someone's posting 999999.
It's a simple example, but I like it.
The other thing is most modern leaderboard systems have a binary data attachment.
Now that score trick I mentioned is still super useful because when you retrieve a page of leaderboard results, you're typically retrieving a page of scores, whereas the binary data stuff...
It's typically a separate follow-on call.
So that binary data is really handy because you've got the shared persistent state.
That binary data could be a challenge, it could be a ghost, it could be the particular loot you finished it with.
There's all sorts of things you can do with that once you've wired it up and supported it and exposed it up to your designers.
and plan for leaderboard bugs because you are going to have them.
Find out what your platform's policies are in regards to fixing a single leaderboard entry, fixing multiple entries in bulk, or potentially resetting the leaderboards.
Have contingency plans in place because I guarantee you, you will have to fix some leaderboard entries.
So this is the most basic example.
Pretty much all of these platform features that I'm talking about and these social features are built on REST APIs.
This isn't complicated stuff, but it's a good starting point.
So Curl is something that's going to be available on pretty much every platform you ever work with.
And before you write a single line of code to hit a new web API, you really should look at just poking it with Curl and figuring some bits out.
Now, as you move on from curl, you can look at tools like Postman, which are a suite of curl-like tools to do automated testing or bulk calls.
Now, Postman is just one example.
There's a whole suite of REST API stuff out there.
As we get on to real-time networking later in the talk, I will mention Wireshark again, but I'm going to mention it here because you can use Wireshark to debug REST-style calls and to look at the actual payloads that are being sent.
But that's a very simple example where we're posting some JSON data through to an endpoint.
Now, there's a big gotcha here about memory allocation and runtime performance.
Most web tools and most of these RESTful API sets and libraries that are written are not written with performance in mind.
So especially when they're parsing XML or JSON and those kind of things, they'll often do a lot of runtime allocations.
That'll cause you big performance issues with your garbage collector.
So it's worth looking for a gaming-specific alternative library or just analyzing in your profiler what your networking libraries are doing, because that can cause you a lot of problems.
OK, but now here's a really simple Unity example.
That's a very small amount of code to actually post a screenshot.
to an endpoint.
So that's posting some binary data to a web endpoint.
And that's really powerful.
So really, you need to look at what platform and middleware is available to you.
You don't want to reinvent the wheel.
Because if you actually go behind the scenes of what this is doing, if you look at it like a C++ lib, you'll see multi-part form processing, where you've actually got to split up this data, can be actually quite a headache.
Okay, so let's use Pixel to go into our next little bit on real time.
Now, sockets are something I find a lot of people get scared off by, but they're actually really simple as a concept.
A socket is the basic tool we use in real time networking, where you set it up, you get it to listen, and then you loop it.
And now listening is a blocking operation, and that's kind of where our problems start.
We'll get back to that in a sec.
There are three kinds of sockets you can get, well, really two kinds.
TCP or the standard internet socket that you'll be used to.
This is where there's a lot of overhead to ensure the data that you're sending is arriving and is definitely being confirmed.
UDP is much more low level and faster and generally what you want to use in games.
Of course, the old joke with UDP is I'd tell you a UDP joke, but I don't care if you get it.
But as you move into games, you'll probably find that you want to use some flavor of UDP like reliable UDP.
In this case, it'll have a bit of extra helper functionality that's added in by a library or some middleware to allow you to do, say, reliable UDP packets so you know they've been delivered or allows you to do in-order packet delivery.
You can set this on a per packet basis, which is really handy, because if you're sending all of your traffic as in-order, reliable UDP, you've kind of lost all the benefit of working in UDP.
So it's worth thinking that that comes with an overhead.
WebSockets are super cool.
If you're doing anything with mobile, or if you want a companion app, there's a whole bunch of functionality there.
If you're doing your game and you're maybe deploying to console or something where you might not always have access to the build, so let's say you're taking a build to PAX.
and you've got a shipping build, because you don't want all your debug stuff in there, you can actually put a little HTTP server in there that's doing a little TCP socket.
And you can connect from your laptop, and you can do some basic turn on stuff and debugging stuff.
And that's really handy.
So web sockets have a lot of hidden uses.
And all they really are is a TCP socket with a few standards wrapped around them, so they are a bit safer, because the browser's a bit concerned about security.
And as I said, the gotcha with sockets isn't so much sockets.
They're actually quite easy, and you should just play around with them.
You'll pick them up very quickly.
The gotcha is concurrency, and obviously every programmer who's ever worked with concurrency knows the overheads that comes with.
You've gotta think about your mutex locks, and you've gotta think about how you're dealing with your memory, and how you're gonna stomp on top of each other.
The good news is if you're working in C Sharp or a modern language, there's a lot of tools that really help you out.
with concurrent programming.
C++ is getting better as well.
OK, so the most common kind of real-time networking you're going to come across is actually one of the most complex.
Implicit networking systems or object replication systems are the Unity or Unreal default. So this is when you go into your Unity networking tutorial or your Unreal networking tutorial, and they'll tell you, let's make an object networked.
and they hide away a lot of the complexity.
The first thing to realize is object replication is actually quite a complex technique under the hood, and it is very state heavy, and it is a bandwidth hog.
The most common mistake I see newer network programmers doing is replicating everything.
Only replicate what you need to replicate.
So, a classic example is let's say you've got this object in your scene that has a whole bunch of state and scripts and everything attached to it, but all you really care about is how it moves about in the scene.
It's better to parent another object to that or to have a hierarchical relationship or if you're able to replicate, say, just a single component, that's the position component on the object, because so many times I've seen people basically replicate the entire complex state of this object and all they cared about was how it moved about in the scene.
was the position.
So that's a classic problem.
The other big gotcha I see with replication systems, catches people all the time, is often a zero, a null, or a default value won't be replicated.
This sounds like a weird edge case, but you'd be amazed how many bugs I've seen come up from that.
The other more classical style of networking, and I'm going very simplistic here as an introduction, is sort of input only.
So this is when you're saying, I've pushed a button, and I'm sending that button across the network.
The first bit of advice is don't send the button.
Make it abstracted out.
So I am pushing.
I choose to accelerate at this time, and you timestamp that.
The first implementation you can look at this is a lockstep implementation.
What this means is we gather the inputs from every single client, we look at them and we go, okay, we can move to the next frame.
Now that sounds really basic, but it's super reliable.
It has no weird complexity to it.
You can always ensure it's fair.
And outside of some horrible lag spikes, which is where you're going to get your main problems, like when the lag spikes up to 500, 800 milliseconds, most of the time your latency is going to be sort of around the 200, 300 range.
And you can easily hide that in your game if you're dealing in a turn-based or a slower action game.
So as I say, it's very low bandwidth, it's very performance, but it is sensitive to spikes.
And it's worth looking at if you can rewind your state.
Because that gets us onto alternative facts.
Now I could do a whole nother talk on this, but the laws of physics, I'm afraid, cannot be broken.
The speed of light is a thing we actually have to deal with.
It's worth realizing that even computers in the same data sensor talking to each other add significant overhead.
So the first thing you want to do is think about not what is the truth, but what the client sees as the truth. Whether they think they hit the target.
So some common techniques you'll come across in research, for instance if you're doing a shooter, you should look at relative target aim systems. There's some very good talks on that where basically the the concept is rather than caring about where I shot the bullet out, and doing a simulation that all the clients agree on on whether or not I hit, I'm saying, do I as a client think I hit?
Or I'm saying, I'm shooting relative from my position at this angle.
Now, obviously, this is open to cheating and exploitation, and it's where a lot of this hitbox problems come, and it's where a lot of gaming of lag and stuff comes in.
But it is a good technique, and if you want to make a performance shooter, it is really one of the basic techniques you're going to use.
Also, smoothing or correction.
Remember how I was talking about lag spikes?
In the old days, you'd get a situation where you're playing Quake or something, and you'd get your character sort of jumping about the level.
And that was because there was no smoothing or correction.
These days, when we get lag spikes and the truth drifts away from our alternative truth, we need to kind of sort of bring those together without the player noticing.
And so we do that over several frames using...
smoothing techniques and correction.
Also, if you look at a lot of libraries, they'll have some kind of projectile motion option available often, and this will basically do a lot of this smoothing and correction for you over the network, and it'll handle a lot of the negotiation.
All of these topics are worth investigating individually if you think they fit your game, but most importantly, I would say if a library offers it, Take the libraries or the middlewares offer as a starting point because there's a lot of really good code that's been written out on these areas.
And you can always replace it later with your own.
Which comes me to my final topic in the real-time section, rolling your own networking.
Please, please don't do it until you feel very confident in networking.
A much better approach is to mix and match.
You can start with an object replication system doing 100% of your networking.
And for a lot of smaller games, that is actually sufficient.
But then what you can do in the engine is you can say, okay, first step, I need to.
and my game state.
So you go off and you take some Post-it notes and whiteboard it and document it, and you understand at any given time in your frame what data really matters to you.
And then you decide what data you need to send across.
And you may find that there is some data that you care about more than others.
And in those situations, you can basically say, for this particular object, for this particular class, I'm gonna not use object replication, but I'm going to write my own implementation for that.
Usually, talking directly to the middleware, because the middleware will have some kind of exposed layer for low-level calls.
And that's very, very handy.
Then the next question is, can you rewind and replay?
First of all, this is a cool feature if you have demos, right, if you can actually save off the game state and a later time play back the game state.
That's a cool single player feature anyway.
But if your network code, if your game at a basic level supports this.
you're in a really great state for networking.
There's a lot of advanced techniques that open up to you.
Everything from service state verification to rolling back the state when you're doing host migration.
There's a lot of cool stuff that comes up if your game supports a rewind and a replay state.
And that's no networking code.
So if you're a confident coder, that's a good place to start when you're trying to optimize your networking.
And different channels, some platforms will offer you, or some middlewares will offer you the option of prioritizing your traffic.
That's a big win a lot of the times, where you can go, okay, I really want to prioritize this above this.
So for instance, voice channels are something we usually put on a very low priority, or if you're doing a VR game and you care about the player's position a lot, but you might not care about their exact fine-grain motion tracking until they're right up close.
Okay, so because we can't change the laws of physics, the best thing we can do to help networking is to send less data and to do more with that data.
So the first thing you can do is throw away data you don't need to send, right?
So in the classic shooter situation where you've got eight players battling it out, but there's three players across the map.
Rather than simulating the whole physics and everything that's going off where those three players are fighting, you can say, I don't care about those three players, update their position once every second, and if there's things like rocket explosions and gunfire going off, just tell, just as custom networking calls, send off the fact that there are explosions and rocket fire going off in that general direction.
and that's a much more optimal way to handle that particular situation.
You'll find a lot of cases where you can just throw away huge reams of data that previously you were just sending by default.
C++ unions are a very basic topic, but I find too often in networking because people haven't come from a performance critical background or a memory critical background.
they might not realize how much using an int32 or an int8 would suffice will actually cost them.
And in a situation where you can actually use a C++ union or many other languages equivalent to bitpack a structure, you'll get a lot more bang for buck.
You know, if you're sending something every single network frame and you're sending maybe eight instances of the player's data, right, because it's an eight-player game, and you're able to shave 16 bits off that, you'd be amazed how much that all adds up.
So the next thing I'd say with compression is we're not talking about writing a better zip program.
What we're talking about is writing domain-specific compression.
So if you have UGC, for instance, where people have a custom hair color, instead of sending a full RGB value over, you might just have a selection of colors that you're sending over that can be compressed right down.
or you might move your custom colors to say a hue saturation value space, decide you only need to see increments of hue, decide when the value is too low that you just throw away the hue.
There's a whole bunch of cool stuff you can do.
And if you're interested in some more advanced compression techniques that will really help your networking, I highly recommend the Google Compress Ahead videos as a good introduction to a wide range of networking techniques, of compression techniques.
Okay, social features, one of my favorites.
We'll use Vertex to go into this one.
Okay, messaging.
This is top of my list.
We have all heard the story of playing a game and finding a message or a present from a loved one or someone you haven't spoken to, right?
We've all heard that story that tugs the heartstrings.
The vast majority of messages players send in your game are going to be yo.
They're going to be simple, don't really care.
But out of that minutiae of messages, you're going to have some really, really special moments.
And every single platform has an option to send sort of messages with a bit of binary data to another player for free.
with no server on your side.
So why not use that?
That's a really powerful thing.
When you can attach a bit of binary data to something like this, you can build whole systems around messaging.
You can not only send someone a message, you can send them an item.
You can send them a challenge.
You can send them all kinds of stuff.
Messaging is a really, really powerful system, and especially if you've got a smaller indie game that doesn't have a huge player base, it doesn't mean that everyone has to be online at the same time as well.
It's, I really am a big fan of messaging.
Forums and communities, one of the things everyone who plays your game has in common is they play your game.
Wiring in communities or wiring in platforms, forums into your game is technically not as hard a task as it sounds.
Many times there'll be helper libraries and tools that'll assist you in this.
And when those social tools are brought into your game, your players are much more likely to engage around the game.
A very 90s concept I like is shout boxes.
Yes, the shout box may just be you going to your players, hey, look at this thing that's happened or whatever.
And it could be an RSS feed on your personal website.
It could be on Dropbox.
You know, there's all sorts of places.
Or you could put it on a platform data store.
but you could also maybe allow your players to use the shout box.
There are a whole range of ways you can approach that.
And with the gotcha of moderation, if you are relying on platform systems, you can rely on the platform for moderation, and that's a big win.
Because if you have to take on the moderation task, it can get a bit daunting.
You may be fortunate enough that you're making an 18 plus game, and you say, oh well, free speech.
But for a lot of people, moderation becomes a very big topic.
So if you use the platform services, moderation gets taken out of your hands and you don't have to worry about it.
Help, share, sharing, right?
In this day and age, everyone is taking photos and videos of your game.
The first step is make those photos and videos look good.
The second step is don't send them out into the wilderness like these files to be lost forever.
Give them some metadata.
You know that photo was taken when they had a hammer equipped and they were on level five and they were fighting this monster, right?
You can pack all that data in.
You can put it in the image as well, but you can put it in the XF data or the metadata of the image.
Another thing that's becoming a trend that hasn't surfaced up a lot, but more and more we're talking about temporal tagging in videos, where you're able, when you're recording a video, to say, at this moment the player scored a goal, at this moment the player killed an enemy, and actually tagging that in the...
VTT track of a video.
And that's very interesting because all of this data that your game is generating goes out, and then you can use platform services, or you can even hook up to YouTube or Images API and stuff and actually pull the stuff back into your game and sort of show the community all the cool stuff that is happening around your game.
Now, you don't have to go the full Final Fantasy level, but we all are kind of prompted at the top there, and we kind of suck at taking photos.
And if you give players help, if you, when they post, they don't see this white box, but you've primed the social pump with a personalized message that says, I know you are fighting pirates on the sea.
And in your pirated game, you know, you actually get your copywriter to go, yaar, and do that, you know, flavor text.
That's very cool.
Also, if you look at AI captioning, I'm not suggesting using AI captioning, but it's a good inspiration point because you can see the stuff they're doing just from an image.
You have the frustum, you know what's in the camera's view, you know what the player was locked on when the photo was taken.
You can do a much better job of captioning that image and making a story from that image than any AI algorithm can do at the moment with just a basic image.
Config in the cloud.
So patching is really hard, but changing a config is easy.
So you can store a JSON blob in, again, like Dropbox, or your own server preferably, or a platform data store that has some basic balance values in, right?
So this means that if you discover an enemy is too overpowered or a particular level needs a tweak, you can just update this JSON and very quickly push that out.
That's a very powerful tool as you rebalance on the fly.
You can also unlock or trigger events, so a special Halloween event or a Christmas event, using this kind of config.
A big gotcha is no execution.
I know some people try sneak lure or something in these kind of systems.
It's a bad idea.
The reason why we're so careful with patching on platforms is because this kind of injection point can be where your game gets broken open.
in a horrible way.
Some other gotchas is make sure the game is playable with whatever local version of the config the player may currently have.
Don't rebalance the entire game on the player mid-mission.
Think about when you're going to update those configs.
And it's worth having a versioning system and noting that in your save files and such like that.
Because you'll get situations where players pull old saves to new machines or maybe a new save to a machine that isn't 100% updated because they've still got the save data installed, but they've put in the disk and they've never connected to the internet, so they haven't pulled that stuff down.
So there's a whole range of stuff around there that you want to think about.
Platform data, oh, I love platform data.
You can do so much with a bit of binary data in a store that you can access, and it's 10 times better if you're not paying for the storage.
It's a big bonus feature if you can take this dump, you dump it on a server, and you can get your friends' data dumps.
The moment you've got that, you've got, again, the shared persistent state that I love talking about, and you can, first of all, check if you have atomic access to that.
So some of these data store systems will provide atomic access functions.
So for instance, if you want to get a number and increment it, they may have a low-level function that allows you to do it, that's very efficient, and it means that you're not stomping over each other.
If you don't have atomic access, be very aware of when a player is getting data from that, who owns that data, so you don't get a situation where multiple people are writing on top of each other.
So that's a good thing to look at if the particular data store you're using has some atomic access functionality.
Now with this basic binary data, it doesn't sound super exciting, but you can build an entire trade and loot system out of this.
You can build a basic auction house. You can build seasonal events.
You can do your mission editor and user generated content.
by putting stuff in there.
And you don't even have to go as stream as a full level editor, even if you're, let's say you've got a customization system where your character's picking particular loot and stuff.
You can just upload the person's gear, their current loadout to that, and then you've mimicked the blizzard armory system in your little game using platform data.
And all of this won't cost you a cent.
So it's super, super powerful.
Player signs and Dark Souls messages is another obvious one that's not hard to do.
And I think that also adds a lot of vitality to a lot of games.
I know it's a commonly used function now, but I think it's still a powerful one.
Online saves.
So online saves, our basic promise here is never lose progress.
That's the key headline here.
So the first thing you want to do is some basic sanity checking on your saves.
Be assured that you always have multiple saves in your game.
Whenever you're pulling down a save, you've verified that you've got one or two save files that are good, so you're not overwriting anything.
Don't have a monolithic save state, right?
When you're doing online saves and when you're syncing this kind of stuff, it's very good to think of it in a version control mindset, right?
So first of all, if you can break this monolith up to, for instance, if you're tracking how many monsters they kill, break out the monster killing bits to the story progression bits, right?
Because if you're doing a story-based game and I'm on chapter five on one machine and chapter four on another, yeah, clearly I want chapter five, but maybe I was killing just a lot more monsters here.
Now, this is down to a design decision and you need to decide for your game what's the right, whether you just let them take whichever monster kills the highest, whether you just add both in.
You've got to figure that out for your particular game, but you need to make these intelligent decisions about how you merge data.
And if your save data has a delta, like you know what's changed between each save state, it makes this kind of merging behavior much easier.
Obviously, as you have more backup systems for online saves and as you open this up more, it is a bigger exploit potential for cheating.
So that is worth thinking about.
And as a fallback, whenever online save data goes wrong, always ask the player.
Make it their decision.
Okay, so getting together is one of the hardest topics because as you're a smaller developer or if you've got a smaller community, hell, even AAA titles worry about getting enough of their community together to play.
So the first thing is we all love your game, we all play your game, that's what brings us together.
So your community features need to be in your game.
So think about the journey from stranger to acquaintance to friend, and how you can enable that.
The first step is to think about when are we going to play.
If you can have functionality in your game that helps other players decide when they want to play a game, that's extremely useful if you can highlight that.
Another hack I quite like is IRC chat.
So Frozen Synapse did this quite well, and I've seen a few other games do it, where they've basically just put some IRC client code into their game, and they connect up to a chat room on AfterNet or Freenode, check the policies of whatever IRC server you're using.
And then you have a community chat in game.
So even when people are playing the single player, maybe they're playing the multiplayer and they're still in the middle of a match, but you're matchmaking or whatever.
It's a basic route for people to see the rest of the community and to sort of hook in.
And maybe someone is struggling with the game and they can just go in.
And yes, the chances are that there's going to be some toxic chat in there or it's going to totally derail and stuff.
But that's.
not your problem, you can do community management and stuff like that.
On the purely technical side, getting IRC in is a cool function to explore.
And that brings me to my next topic, social APIs.
A lot of the stuff I'm not mentioning here is the smaller stuff.
It varies platform to platform, whether you're on Google Games, whether you're on Steam, whether you're on PlayStation.
There's little features, social APIs that every platform has.
It's really worth reading those and putting them in the game.
Even if your game doesn't end up using them, doing the technical implementation for these features tends not to be very hard.
It gives the designers something to work with, something to put in.
And Platform holders love it when you use their social API stuff and they will potentially give you a bit more of a leg up.
And the other cool thing is a lot of these features are often overlooked.
So when someone goes into some section of a social functionality on a platform that's not widely served, they're much more likely to see your game.
So that's a big feature.
Events and calendars, again, that's becoming a more common API we're seeing on platforms.
And that's a big helper for your community to get together and to gather.
So social matchmaking, matchmaking's a hard topic, it's a really tough topic.
There is a way to think about matchmaking that's much more open, and that's around social matchmaking.
So this is how do you make that journey from acquaintance to friend, right?
So stranger, acquaintance, friend.
Whenever I have a match, whenever I compete against you, it is a story, right?
The first time, it's not much of a story, the first time the story is simply, oh, I beat you, you were really heavy on the rockets, I had really good aim, right?
Not much of a story, but the next time we match up, you can say, hey, do you know you played this person on Friday?
Oh, yeah, you beat them, but they were really favored rockets or their aim was really good.
And you can start telling the story.
You can start building on that.
And as you save this relationship up, There's more data there to do storytelling.
And if you're the kind of programmer who's into narrative and procedural storytelling stuff, there's some very cool stuff you can do there.
You don't have to save this on a server.
You can save this locally.
Obviously, if you're saving it on a server, there's more functionality you can do with it.
But even saving locally, it's very powerful.
And graphs are really your friend here as a data structure.
Don't go mad with some crazy graph in API.
Graph data structure is literally node edge node, right?
It's the simplest thing.
And you can make graph operations really efficient when you think about it in a memory sensitive way.
Again, that's a whole nother talk, but graph operations are really cool.
And if you're interested in how you can do nifty stuff with your matchmaking and build these shared stories.
So the next time I play against a stranger, they're not a stranger, they're an acquaintance.
And maybe then we have like three games over the period of a week, and we maybe start chatting, or we maybe start, you know, interacting more.
And if a friendship is built around your game, That's very powerful and friends remember that.
They remember how they meet and they often go back to the game and that's how you build real fans.
That is a very powerful networking feature.
Also, spectating matches.
If someone I know is playing your game and I can watch in on that, that's again another way to sort of bring that stuff together, especially if you're doing this with acquaintances, because it's a way to just sort of see, oh yeah, that person that beat me two games ago is playing up against someone else I've played against or playing against a friend.
Very, very useful.
Invites.
Okay, so invites could be as simple as a phone text message to someone saying, yo, you want to play this game?
But it can be a handcrafted message, and that's the really fun and interesting bit.
So the invite is the thing that lures someone into your game.
Most platforms support Attaching an image and some text right and again. This is a basic rest API So you can actually do some really cool stuff rather than sending generic test and check text and generic image You can actually select a specific image for your invite and you can generate specific text And if you want to do some cool stuff with the programmatic images, this is a really cool opportunity.
Now the first thing I want you to do with your invites, after you've thought about that, before you even touch the networking libraries, is I want you to make your game boot up using command line arguments and go straight to a level.
Go straight to a particular match-up case.
Skip all the menu guff.
Now, once you have the command line functionality in place, it's much easier to integrate the invite system of whatever particular platform you're working on.
And so when someone loads up this invite, they go straight to the game.
They skip loading the menus.
They skip a whole bunch of guff.
And that can really speed it up.
Because every time you do anything with matchmaking, We care about if matchmaking is 10 seconds or 15 seconds or 30 seconds or a minute.
We really care about that.
But we don't often talk about, oh, matchmaking was only one minute for me, but then I had a five-minute load screen.
There is a whole path.
there, a whole journey that you need to go through.
And it's not something that's easy to retrofit.
So it's really up to you to handle that as early as you can.
And really, death to the Dell Lobby.
There's so much more interesting things you can do with the lobby.
And if you can skip the lobby altogether, you're in a much better situation for your networking flow.
Okay, matchmaking.
Concurrency is king.
Everyone worries about concurrency, from small titles to very large titles.
Concurrency is one of your key cost factors that you can use to determine, but it's also one of your key success metrics with networking.
And it's the thing that smaller titles really struggle to get that critical mass for matchmaking.
So your peak concurrency is probably going to be just off after launch, but be very aware that your game may be much more active on the weekends, you may have Tuesday as your most active game. Think about what regions are active and how you can action that and improve that for your community. Give the community actionable information, right? If you say to people, find out.
5,000 people are playing the game.
Great, I feel awesome.
Well, that information's kind of useless to me.
But then you tell those same people, six people are playing the game.
Well.
I'm bummed out.
What are the chances of me finding a good match?
That's not actionable information.
What's much more useful is to tell your players, hey, did you know Tuesday 7 p.m. is our most active time?
Or, hey, do you know your friends currently playing single player, you know, like bring them in?
Or, hey, this match with someone that you know is ending soon, like here's the score, right?
Maybe go spectate it until the end.
There's loads of cool, actionable information you can give the player.
Drop-in is queen.
If concurrency is king, drop-in is queen.
The factor with drop-in is based on your session length and based on your concurrency numbers, drop-in becomes either not a really critical feature or an absolute must-have.
If you've got low concurrency numbers and your session time for a game is, say, 10 minutes, What'll happen is people will get matched up, they'll go into that game, and if your matchmaking cues are slightly longer, they're much more likely to jump straight back into that game, straight back into the cue, and get matched up very quickly.
And so you'll have these bursts of activities, and you'll have this cascade effect, which means sometimes your matchmaking can be 80% of your session time.
So you can get some really bad behavior if you've got a longer session time, especially if you've got a strategic game where session time is say 30 minutes.
You can get into really black hole with that.
So drop-in becomes extremely useful.
The other big gotcha is unless you are supremely confident about your concurrency numbers, one bucket.
Just have a quick play bucket, shove everyone in it.
If they want to do custom games or whatever, let them use the invite functionality for that.
Put in other social tools for them to do those custom games.
Every time you add another cue or another bucket for your matchmaking to go in, you drastically increase the matchmaking time.
And it could be that you actually have a fairly active community, but they're going into different queues.
And the other problem is you may have a game mode that players don't enjoy as much as other modes, but because the matchmaking times are faster, they go into those modes.
And then your premier mode, or the mode that you think is the most fun, actually suffers because people are going into 1v1, say.
So that's a big functionality there.
Okay, so jumping straight onto servers, Pixel again, very shocked because servers are quite shocking.
I fucking love my cats, I'm sorry.
So peer-to-peer.
Peer-to-peer is extremely complicated, okay?
But it is the default option.
And the reason it's the default option is because it keeps things cheap.
Peer-to-peer is going to always produce a sub-optimal topology, right?
Unless you're a one-to-one, there's going to be a situation where things are not the best, okay?
But the existing frameworks for peer-to-peer multiplayer are very powerful and well-written.
Nat Punchthrough basically relies on a third party server somewhere doing that for you.
So if you're using, for instance, platform matchmaking, they've got a server doing that, but chances are you have to rely on like a Steam server or PlayStation server or Microsoft server or a Unity offer an option for it as well to actually do that for you.
So that's something you have to consider.
And the other thing is, going back to that sending less data, it's very important in a peer-to-peer situation where if you've got eight people playing a game together, don't send all data to all peers.
Throw away data as much as possible, right?
Because if you have to propagate data to all peers, you can get into some pretty horrible situations.
Now the cost of this.
is if you've got partial game state shared between all your peers, and you get into a situation of host migration, or you get into a situation where people who hold key parts of your game state drop off your mesh, you can end up in a situation where you're like, how do I recreate the state?
Again, a bit more of an advanced topic, but it's worth knowing that that's a black hole you can fall down.
It sounds like I'm really dissing peer-to-peer.
I'm not.
I'm advising you, it's technically complex, it comes with a lot of compromise, but for most titles it is the correct solution because it's cheap and it's very easy to end up in a situation where you might as well put two dollars in an envelope and send it to every player playing your game.
So it's to be avoided.
Sorry, it's to be used.
So Tiny Sewer.
The first thing about servers is I would say a very small server can be very powerful.
You can write a simple C++ or Node.js or Golang server that does some basic REST API functionality.
This can do all the kind of stuff I've been talking about with platform services, but even more, right? It can be really powerful.
A Raspberry Pi scale server for most smaller indie games can serve most of its needs for basic, low...
low cadence networking.
That's very powerful.
And you can later move that small server to the cloud and such, but it's a much lower commitment.
The other thing to think about with this kind of server is that if it's providing additional functionality, sort of premier functionality, If it's down, can people still play your game?
Because if the server goes down and all that suffers is some social features in your game, but people can still play the core experience, you're in a very good shape.
However, if the server goes down and it hinders gameplay in a significant way, you're basically in a DevOps situation.
So that's worth thinking about.
The other thing is, when you write a small server like this, you should be writing tests and restart scripts and stuff.
Even if it seems a bit overkill for your small application, it's really useful.
I have an app on my phone which pings my home servers and stuff, just a few small ones and some actual proper servers as well.
And so when a server goes down, my phone just buzzes.
And if the server doesn't come up in a bit, I call home and I'm like, what's happened?
The cats have chewed the network cable again.
Right.
replace that. So it's good idea to have these tests and restarts. You'd be amazed at how many times to fix a problem on a server we just restart it and we just restart it because putting in the engineering time to fix it is Expensive.
Infrastructure.
So now to go from that small server, to go to a situation where you are spinning up game instances on demand, running game logic on the server side, is really shifting from a battery to a power grid.
You're now in the infrastructure business, right?
And running game state server side is expensive as hell.
I know it sounds really appealing to say, oh, I'm just gonna run Unity on my server.
or I'm going to run Unreal on my server, you can run up some big server bills that way.
It may be the right option for your game, but be aware it will cost you a lot of money.
And the moment you go into that situation, you can't use platform networking typically.
You have to have a standalone matchmaking solution.
You have to manage spinning up your own instances.
Your bills can spike horribly.
And your DevOps becomes a lot more complex.
But there is a bit of a trap door getaway if you're PC dev.
If you're PC dev, player servers are kind of awesome because you just provide a server executable and you say to your players, hey, do you mind running my server for me?
And you'd be amazed at how good players are doing that.
The big caveat is you've now lost control of your servers.
Piracy is much more likely.
And you may have a whole secondary market.
The thing is, if you've got an indie game and it's competitive, no one's going to run better servers than your community.
They're going to spend out the wazoo to make sure they get no latency.
So PC servers and player-run servers are actually a good sort of trapdoor exit if you really care about performance and you're willing to make those sacrifices.
The other thing I want to mention is local for development, which is you need to run your infrastructure locally, especially as you get to a more complicated structure, something that runs over multiple instances and stuff and uses a bunch of different servers and technologies, and you need to document.
what that setting up your local system is.
You know, how do you run Cassandra locally?
You know, what is your particular LAMP stack?
There's probably like 20 different pieces of technology you've installed locally.
And you need to know what that is, because you're going to onboard another programmer at some point, or your machine is going to break, and you're going to need to move to a new machine.
And that's usually going to happen when you're having server trouble, and you don't want to be in that situation.
The other thing I'll mention, and I can do a whole nother talk, in fact, I have done a whole nother talk on this, configuration outperforms single threaded.
So in the modern infrastructure of networking, we have a tendency to go wide, to have a lot of server redundancy, and to use a lot of complex middleware.
And often, this is the correct solution, but.
many times a single threaded C++ server can drastically outperform these broader implementations.
If you Google that, you'll find a bunch of interesting talks around it.
But for one example, there was a graph.
a processing situation where someone found an old laptop would run at orders of magnitude faster than a full-scale, like, multi-instance AWS deployment with the top-tier professional graph processing software, and this was something a guy had written in C++ in, like, a weekend, because there's overhead in communication.
So that's an important topic to look at as well.
One of my favorite stories to tell is there's actually a AAA title inside Sony that deploys pretty much one server and then one server for redundancy for a pretty major title.
And that's because of that cost of single threaded configuration that outperforms single threaded.
OK.
So cheaters.
You're going to have cheaters in your game.
It's a given.
State verification is really good if you can do some basic checking to see if the state they've gotten to is valid.
Building peer trust, if you have multiple peers and you're able to communicate between those and find out who's the bad peer, that's a common technique.
Replay verification, if you've got the functionality to play back those replays I mentioned in the past, that's a really solid technique for detecting a lot of behavior.
Machine learning.
Machine learning sounds like something only a really big company would use, but you'd be surprised at the tools and services available out there at the moment to basically use machine learning to detect aberrant behavior.
And then the worst case, figure out what your worst case is.
You shh.
You shouldn't have credit card numbers, but you might have embarrassing karaoke videos that people don't want leaked.
So moving to the cloud, everyone who is aware of cloud stuff, AWS shat the bed yesterday.
And that was fun, because that was in the middle of a big game launch.
It is someone else's machine.
It will typically be more reliable than your machine, but it is someone else's machine.
Moving a small server like the Raspberry Pi instance I explained earlier to the cloud is actually very simple and I would encourage it as your first foray into cloud computing.
But building up infrastructure is much more.
Complicated. Compare service providers. AWS is kind of the default choice but you may find that Azure or the Google offering will actually be better for you and if you're talking to the sales people of these particular platforms you would be amazed the deals you can get.
So understand what that platform offers you, because what they're offering you isn't hardware.
They're not offering you computers.
The cloud offering is really about the tools and services they're providing, like AWS's Elasticsearch, for example.
OK, and DevOps, I've mentioned already, which is a huge cost.
So in conclusion, REST APIs and platform features really are the key thing to look at.
They're the bread and butter stuff.
It's not super complicated.
And they're basically free to get in.
There's a lot of core social functionality, networking you can get into the game, that isn't a huge headache.
Real time, again, start with the basic middleware provided stuff, optimize later.
And servers, if you're going small scale, it's not a huge headache.
If you're going to the infrastructure, it's pretty big.
Find two things in the talk and follow that up.
So as I say, you will be getting a feedback email.
Pixel and Vertex ask kindly that you fill it out.
And with that, if any of you want to come to the microphones and ask questions, or if you want to poke me on social media, my Twitter is there.
Thank you very much.
