Hello everyone, this is Arvi Teekari and I'll be talking to you about the game Baba is You and specifically the rule system and the rule parsing system of Baba is You.
This is the kind of a virtual talk as part of the GDC talks.
If you hear some kind of white noise on the background in some situations, I'm unfortunately recording on a computer that apparently just randomly starts.
doing something really heavy on the background.
I have no idea what it is and the fans are very loud.
So I don't think I can do much about that.
I hope it won't be too distracting.
Also, if my eyes kind of linger somewhere else and I'm looking at the camera in some situation, don't worry, I'm just looking at the slides.
I need them as a kind of a reminder.
So I'll take a sip of my tea and let's get started.
All right.
So if you haven't played Baba is You or don't know at all what I'm talking about or what the topic is about, then don't worry. I will start the presentation with some introductions. I will explain who I am and what is Baba is You. After that, I will go to the actual topic, the rule system of Baba is You and the rule parsing system of Baba is You. I will tell what it is, how it works, what kind of phases it has gone through, and finally, I will explain some...
obstacle and problems with the system, kind of complications that I'm faced with the system right now and earlier in development. And finally, I'll just kind of gather my thoughts with some conclusions.
Let's get started.
Part one, introduction. So who am I? As mentioned, I'm Arvi Teikari, also known as Hempuli on the Internet.
Hempuli.
I'm a game developer from Helsinki, Finland, and I started making games as a hobby in primary school.
I had already been interested in making video games in kindergarten because my cousin had a Super Nintendo and my brother also played a lot of video games, and Super Mario World on Super Nintendo is probably the kind of thing.
biggest singular thing I can remember from my childhood as being kind of an inspiration to start making games.
So in primary school a schoolmate asked me if I wanted to make games and showed the program GameMaker to me.
And we started making games together.
But the problem with GameMaker was that it has its own scripting language, the GML.
And since I was a primary schooler, I had a pretty low attention span and I didn't understand English very well.
So having to learn the scripting language turned out to be kind of a big roadblock. I just didn't have the patience to really get into it.
And also it was very slow to learn it because I didn't understand it. I kind of had to learn by trial and error.
So eventually...
Another schoolmate showed this program called The Games Factory to me, made by Clickteam, which was actually pretty popular in Finland during that time, in like 2002 or 2003, and a lot of kids using it.
And it was cool in that it didn't require any scripting at all.
It had a purely visual interface with its own kind of visual coding, like conditions or event system.
And because everything was on a list, even though everything was still in English, it was way easier for me to start learning it because the kind of trial and error approach was much more doable in there. And also I was kind of slowly learning English on the side as well.
And I stuck with the Games Factory and eventually moved to its sequel or successor called Multibidder Fusion. Multibidder Fusion turned into Multibidder Fusion 2 and right now it's Clickteam Fusion 2.5 and 2.5+.
Although I stopped following the progress at Multibit Efficient 2 because I was so used to that program and I've been using Multibit Efficient 2 ever since.
And basically all of my games that I've put online have been made in Multibit Efficient 2, including Baba is You.
Also, in 2010, I participated in a physical game jam for the first time.
I had already participated in Ludum Dare.
online jam and liked it quite a lot and because I didn't really have that many friends or any friends that were interested in game development except on a like very surface level it was still a very kind of nerdy thing in my mind at that point. It sounded super cool to be able to go somewhere else and meet other game developers that I know over the internet.
So I went to Sj√∂vde to No More Sweden.
Don't worry about the name, it's not like an anti-Sweden game jam, it's organized in Sweden.
The name is more of a pun.
And I had a super nice time.
I got hooked in the game jam experience and later went to Nordic Game Jam in Copenhagen and both those two kind of became my staples.
And they became a very important part of my hobby because they involve a very nice sense of social interaction and prototyping.
Working fast and not really worrying about bugs, all of those were big pluses for me.
And this game development hobby eventually turned into a commercial job. I made a company, Hempuli, in 2015 and released my first commercial title in 2015 as well, called Environmental Station Alpha, and then later in 2019 I released Baba is You.
I also worked on the game Noita in the Nola Games team, although with different tools to some extent.
I'll check my time at this point.
Okay, looks fine.
Well then, so for Baba is You.
It's a block-pushing puzzle game following in the footsteps of Sokoban, which might not have been the first block-pushing puzzle game, but kind of sets the genre in stone.
The idea is that it's a grid-based, usually top-down, not always top-down game, where you have some kind of blocks you can push around, and you control some kind of a character that is locked into the grid.
And in the very classic Sokoban-style game, You have boxes and you have slots for the boxes and the idea is that you have to push those boxes to fill every slot.
And when every slot is filled with a box, you win the level.
And in the past couple of years, this genre has kind of seen a, I don't know, like renaissance or something.
There have been a lot of games in the genre that take this basic concept and twist it in really interesting ways.
I've been super into this kind of, I generally really enjoy this concept of...
taking a simple idea and then just kind of taking it into different directions and seeing what happens.
Especially Steve and LaVell with their puzzle script and other games have been a very intriguing kind of approach into this block pushing system. And in Bala is You the gimmick, the twist to this block pushing system is that there are usually three word rules.
that govern how the game works, that dictate what happens in the game.
And the neat thing is that the words that make up these three-word rules are also pushable blocks in the game world. So not not only are there like rocks and other things you can push around, there are also words. And because they are pushable you can rearrange the words and make new rules so you can change the rules of the game as you play it. And that is kind of the the very core of Baba Is You's gameplay and the thing that makes it interesting.
I created Baba Is You originally in Nordic Game Jam in Copenhagen in 2017, which is why I mentioned the game jams in the first place. The Nordic Game Jam has usually a very loose theme, you don't really have to follow it that carefully, but the theme that time was not there.
And I for some reason concentrated very heavily on the not part of the theme.
I kind of started thinking of how in logic you can have some concepts, an x, and you can reverse its meaning by saying not x. So you can kind of change the meaning of things with the not.
And this mental logic concept combined with these block pushing games I had played over the years and some other puzzle games Such games as Steve and Sausage Roll, Snake Bird, A Good Snowman is Hard to Build, Braid and Corrupt And I kind of pondered up on those puzzle games.
I had wanted to make a puzzle game for a long time, but had always had some problems with the implementation and ideas.
And eventually these concepts in my mind kind of amalgamated.
into this idea where there's a top-down block pushing game where there's a pool of lava and the lava is obviously hot and there are blocks of ice and the ice of course melts in the lava. So if the ice comes in contact with the lava the ice melts But as you can see here, where is my cursor? There's my cursor In this mental concept you could state ice is not melt to make the ice not care about the lava.
This sounded kind of a dubious idea at first.
It sounded like something that would run into implementation problems or wouldn't be very interesting to play with.
But the nice thing about game jams is that it's very easy to just go and try out something and see if it works, make a prototype and throw it away if it doesn't.
So I decided to prototype Ba Ba Zhu.
And over the game jam, the idea kind of progressed.
For example, Whereas originally I had had this concept of lava being hot by default and ice being meltable by default I decided that it's actually in more interesting if lava and ice are nothing by default But instead you have to state lava is hot and ice is melt separately So that like nothing in the game world has meaning unless there are rules applied to them I think that's a pretty cool concept and I went with that And, uh, Baba Is You ended up winning the Game Jam.
It was voted the best game of the jam that year.
And, uh, because of that, and because of encouragement and, uh, persuasion from other game developers, I decided eventually to, uh, make a full game out of it.
And, uh, I worked on Baba Is You for almost exactly two years, from 2017 to 2019.
And over that time it also won some other awards and was in some events.
The most notable award was probably the IGF, Independent Games Festival, Excellence in Design and Best Student Game Awards in 2019.
And in March 2019, sorry 2018, wasn't the Independent Games Festival as you can see here.
I said it wrong.
So in March 2019 the game was released and it's been fairly successful, so that's also cool.
Yay. Anyway, I'll check the time. Here we go. Let's move on to the actual... No.
I'm forgetting something. Yeah, so because I've only explained Baba Isu's concept only by words, kind of in theory so far, I have some pictures to kind of indicate how the game works so that it's easier to grasp what the game is about in case my explanation was too fast or too difficult. Not too difficult, too confusing, too bad.
Anyway, so here we have two pictures indicating the basic gameplay of Baba is You.
So here we have the creature Baba.
As you probably guessed, the name Baba is You in itself is already a rule.
It means that this creature, Baba, is you, the player, so you control Baba.
And here, let's assume that Baba is you, the rule is somewhere out of way.
Here we have wall is stop and flag is win.
And we have this wall of wall and then the flag here.
And Baba needs to reach the wall, needs to reach the flag because...
In Baba is You, you win a level not by pushing blocks into marked spots, but instead by having something that is you touch something that is win.
So if Baba is You and flag is win and Baba touches flag, then the level is won.
And, uh, I'll have to take some tea, sorry.
And here, Baba cannot reach the flag because wall is stopped.
Baba cannot move through the wall because wall is stopped.
Wall is solid.
What Baba can do is, or the player can do, is break the rule, the wall is stopped rule, to misalign the words so that wall is no longer stopped.
And as you can see here, Baba can walk from here, there.
and move through the wall and reach the flag.
That is kind of a very basic way the game can function, how the puzzles can function.
As another example, here, let's assume that Baba, the creature is somewhere not seen, but like existing.
There's the rule, wall is top again, flag is win again.
Now Baba is you, the rule is also visible.
There's again, the kind of square of wall.
that Baba cannot move through.
You could solve this situation in the same way as before.
You could break the wall is stop rule.
But if we, for example, assume that the wall is stop rule is somehow located so that you cannot change it, then what you can do is say, wall is you.
You could replace the stop with you, but you can also do this, wall is stop, wall is you.
And make the wall the player character.
In this situation, Baba.
would no longer be you and Baba would be nothing anymore.
And instead, the world would become the player.
And then, uh, the.
this cartoon or comic series doesn't really indicate movement very well, but here the wall would move to the right a couple of times and reach the flag because they would now be the player character and since when something that is you touches something that is win you beat the level, the level would be won in this situation. So yeah, that's the basic functionality of the game. There's a lot of complications later but that's the basic gist of it. Anyway, uh...
Yeah, let's move on to the actual topic.
So, the rule system of the game.
So, there are all these rules, but...
But the game needs to somehow translate those rules that exist in the game world into some kind of a format that it can understand on a code level, in the game logic level.
And because I hadn't seen any other game do anything like this.
I felt that I needed a pretty novel solution for this.
Also, because I was making the first version of the game during the game jam, the first version had to be very simplistic and quick so I just made up something. It was a very crude solution but it worked.
I was pretty happy with it so I had to figure out some quick dirty solution fast.
And since after I decided to make a full game out of Baba Is You, the rule system evolved a lot over the two years of development.
There were several rewrites and rebalances and re-whatevers over that time.
But the basic structure of the rules stayed the same.
So while in-game the game kind of has a list of rules, which it kind of... what is the word?
consults to find rules, to check what rules there are and there are three components that make up every rule, that are at the basis of every rule. So these three basic components are firstly the object, which means a baba, rock, wall, flag It could also be called subject, but I kind of like object because I call the things that actually exist in the game world objects as well.
An object basically indicates which thing, which object does this rule apply to.
What is the target of this rule?
Then there are verbs, for example, is.
that act as kind of connectors between this first type and the third type of words in the rules and they kind of modulate the interaction between the first and the last words. They kind of indicate how the third word affects the object.
And depending on the verbs.
They can do different things Finally the third type quality Which is basically you For example or move or push or win Which is effectively the kind of effect that is applied to the object In some situations some verbs might also accept other objects as a kind of connecting thing so you could say Baba is you, flag is win, rock is push, wall is stop, and so on.
So you could connect object into a quality.
But you could also say, Baba is wall or Baba is flag to create a kind of a transformation effect.
And in that case, it would be the verb connecting two objects.
So there's some kind of flexibility there.
But still, those three parts of the rule are always there in some form.
But there can be additional components, as you will see in just a moment.
So, as I alluded to, during the gameplay, the game logic basically works, is built around the game asking different kind of questions from this list of rules.
So it will go through the list of rules in different ways and check, like, which objects does this rule apply to?
what rules does this object specifically have?
Or does, if I have this rule, does this specific rule apply to this specific instance of this specific object, that kind of stuff?
Or what kind of qualities are connected to a verb or what kind of objects are connected to a verb?
How does the, what kind of things is the verb modulating?
And then the rule system tells it, hey, OK, I have this rule.
Do what you want.
And then the game logic tries to interpret those rules as it best, as well as it can.
And I will next be explaining the kind of structure of the rule-forming process, the rule-parsing process.
And Most of the rule parsing logic is implemented in the Lua scripting language and I'm pretty sure that a lot of people who watch this talk already know what Lua scripting is and know what tables are, but I'm going to explain tables quickly to just kind of just in case someone doesn't know what Lua tables are or wants to get like a refresher or something.
So Lua tables are basically databases of key-value pairs.
So there's some kind of a key, which is if you think of like a shelf with boxes, the key is kind of the notes on the box that it's kind of ID, it's identifier. It can be a number or a string, so you could have a shelf of boxes.
where the boxes have names or numbers and then you can find a certain box using its name or number.
That is the key. And then every key is connected to a value and the value can be quite a few things.
Basically these are the boxes in this metaphor.
So the box or the value can be a number or a text string.
It can even be a Lua function. It can be another table, a sub table so to say.
So there's a lot of flexibility in this system and that is that makes it really powerful but also kind of...
susceptible to certain kinds of bugs and errors.
And I think some people are not huge fans of Lua in general or the Lua tables because they are so arbitrary, but I personally really like it how the Lua table can in a single structure do many different data structures from other languages. A table can be an array, it can be a list, it can be other more complex types of databases, just in the same thing.
And I've even drawn this small MS Paint diagram to explain the idea of a table.
So, here's this box is table and later on when I explain things, if I have these kinds of boxes, these are the tables.
And within the table we can have, for example here, with a key 1 or slot 1, we can have the string A.
Or in slot 2.
Well, value two, we can have the string hello.
Or with the key hello, we can instead have the number three.
Or we could have the string hello be the key and the value be also hello.
Everything works or whatever works.
Here's also the key foo has the value function and the function can then be defined, or the key bar.
has a subtable which in turn contains other key value pairs.
That's the basic structure.
It's neat in my opinion.
So how it actually works, how does the rule forming, the rule parsing part work?
The initial problem is of course, that we have a level with a lot of words and the words can be in all kinds of configurations.
There might be.
There might be jumbles of words, a huge mess.
There could be a single word somewhere, there could be just... whatever.
Some of these words might form valid sentences that can make rules.
You can already see here vertically, Baba is you, or Rock is push.
But then there's stuff like, is grass you, which is just nonsense, or there's just water, which doesn't do anything.
or wall is, which is almost a working sentence but doesn't work. And the solution to the problem of how to handle, how to make these objects that are words into actual sentences that the game logic can use, lies in having doing multiple passes throughout the level and throughout the these potential sentences.
And I will now go through all these passes in a kind of a slightly abstract way.
So the first pass means that the rule logic tries to find all words that could be the first word of a sentence.
And because for some game designers, some simplicity reasons, all rules are either from left to right, I think this is your left to right, or top to bottom, and they have to be in a straight line, they cannot do L-shapes or curves or whatever.
Basically, when checking which words could be the first word of a sentence, the game only has to check, is this...
Sorry. Is there something above or to the left of a word?
If there's nothing to the left or above a word, it can be assumed that it might be the first word of a sentence.
And the game then adds all these potential first words into a list, goes through them, and checks how many other words they are linked to.
In other words, how many words are below them or to the right from them. That's right for you.
And in this situation...
The game only cares about just finding words.
It doesn't care about what those words are.
And because, as mentioned earlier, the basic rule structure always has at least three components.
The object, the verb, and the quality.
any sentence or word, kind of lines, strings of words that have less than three words can be discarded outright.
So here we can see that Baba is You Rock.
It's four words. That's fine. That works. Let's add it to the potential sentence list.
It doesn't matter if it works or not.
Then there's Rocky's push, Easygrass U, again, who cares if it works? It looks fine, so let's go with it.
And Flag Has Win also has three words, it's more than one or two, it works.
water or wall lava or wall is are all discarded, they don't get long enough.
Technically the game even tests if this is might be the first word in the sentence going in this direction, but obviously because there are no words here and is cannot be the first word of a sentence then it's just discarded. Anyway, these potential proto-sentences get get to go forward to the second pass.
And in the second pass, the game kind of goes through these sentences a bit more carefully and tries to figure out kind of roughly if they might be sensible rules.
And here, something called word type becomes very important.
Every different...
Every different type of word has its own ID number.
For example, baba, the object, has type 0, verbs like is have type 1, and you, qualities, have type 2.
And in this second pass, the game kind of...
starts from the first word and goes from there and checks using a certain pretty complicated logic actually if the words follow this like if the word types follow a Certain well logic. I guess I repeated myself there and Even in this situation there might be some cases where the sentence doesn't actually make sense But if it follows this certain logic it will get past this second pass To give an example, in this first image we had BabaIsYouRock, which passed the first pass.
In the second pass, the game checks, okay, BabaIsYou, yeah, that works, there's type 0, type 1, type 2, everything is fine.
Then it finds Rock and thinks that, okay, no, Rock cannot follow You.
Let's discard Rock.
And then it says, okay, BabaIsYou works.
we'll use that, rock is discarded.
And it does the same for rock is push and flag is win.
Flag is win also is type zero, type one, type two.
So it gets the pass.
But if a word is discarded in this situation, it still has a second try, because it could be that sometimes a word that is discarded because it doesn't fit a certain rule might fit another rule on its own.
So for example, In this case, if there was Baba is U, Rock is push vertically all the way through.
When Rock is discarded, the Rock would still form a valid rule with Rock is push.
So it's important that when the game checks that Baba is U, Rock.
Okay, Rock doesn't work with Baba is U, let's remove Rock.
That it returns back to Rock to notice that, hey, okay, Rock is push is a valid rule again.
So it kind of, yeah.
There's that.
needs to be some safety there so that accidentally rules being next to each other don't kind of cause each other to not work or something like that.
And as mentioned earlier, there are some other word types that were added later that complicate this process enormously.
The second pass is probably the most complicated part of this rule parsing.
system because of those extra rule types.
Anyway, so here we have Baba is you, Rock is push, Flag has win, which go to the third pass. I'll check the time Okay And in the third pass This kind of in this situation the rules are finally evaluated fully to see if they actually kind of make sense and in this situation Instead of just checking the word types, the game checks which words allow which words to follow them.
So for example, flag has win worked in the second pass because it had the correct word types.
But in third pass...
Has doesn't allow qualities like win after it. It only allows other objects. So you could say Flag has Baba, but you cannot say flag has win So in the third pass this flag has win rule gets disregarded and removed or discarded I guess as As we can see here and so In this example picture, flagAsWin got removed.
We were left with just BabaIsYou and RockIsPush.
And these two sentences, now that they were verified to work, they are then transformed into a format that the game can understand and the game logic can use in the actual in-game functionality.
and they get added into different rule lists.
For example, there's a kind of a global rule list that has every single rule in it, but there are also object-specific rule lists so that if I want to see which rules does Baba have, I don't have to check every single rule.
I can just check from like a Baba-specific list.
It's nice.
And before everything is done, there are some extra steps.
So finally, before the game is happy with the rules, it needs to do some complicated shuffling related to conditional words, which is a kind of a special word type that I will cover more later.
And it will have to make sure that the words are kind of in their own respective groups. Also more about that later.
Also, the game needs to handle rules that might kind of create other rules because there are some rules that don't really do much in themselves, but during the parsing process they get divided into other rules.
A good example is all is you or all word in general because all is you basically just means that every object in level is you.
So instead of just saying all is you and having hard-coded special code for all, The parsing system divides all is you into baba is you, rock is you, wall is you, flag is you and so on.
And then same happens with the not baba is you. Not baba means that everything that is not baba is you. So here rock is you, wall is you, flag is you, but baba isn't you or baba is nothing by default with this rule.
There are also rules that might disable other rules.
Again, with the not word, we could say Baba is not you.
And this takes priority over Baba is you and disables Baba is you.
So in this situation, after parsing the rules, we need to go through the rules again to see these situations where some rule needs to be marked as disabled.
Some people have wondered if this Baba is not you type thing depends on the order of the rules somewhere.
So that's.
whichever is first takes priority.
But because Baba is not you, would not do anything on its own if it had kind of lower priority, I made it so that these disabling rules always have higher priority than the rules they disable.
And finally, there are some visual things like throwing particles around, playing sounds, changing the color of the active rules and marking disabled rules, stuff like that.
It's not really relevant for this presentation, but it happens.
Okay, so then as for the kind of how the rules are stored in this list that I've mentioned a couple of times.
So after parsing the rules, when they are added into the rule list, what is the format they use so that the game logic can understand them? This has been a very long process to get right.
As mentioned earlier, I did a really quick implementation at the Game Jam originally.
and it has required at least five iterations and at least three almost full reworks to get this stuff working properly.
And it's still not working properly for multiple reasons that I will cover in the obstacles area of the talk.
So basically I just started with a simple system, augmented and added to it as needed, and eventually, inevitably, it became too bloated.
It had too many corner cases, too many hard-coded special things, or I wanted to add some extra feature that was just impossible to bolt into the existing system, so I just had to decide to rewrite something, either the whole rule system or just a part of it, and then start a new iteration.
So the first iteration of the system was very simple as mentioned.
There were basically all the rules were just three words long at maximum.
I only had to check if a rule has three words and if they follow the object verb quality or object verb object system. And if they follow that structure they had no fewer no more words and the words follow this logic then it was guaranteed that it was a working rule.
So that was very nice.
And parsing, yeah, parsing was very simple, same for the formatting.
Here's actually a diagram showcasing how the rule was formatted in the list, in the kind of Lua table that is the rule list.
So here's the global rule list, which is a table, and within that table, there's the rule subtable.
This blue thing is the actual rule as its own kind of box of things.
Uh, some car horns outside. And within this rule, there was just the, like, the base rule.
Base rule as three words stored.
in a table. So in this table in slot one There was the first word, baba, in slot 2.
There was a second word, is, in the third slot with a key, 1, 2, 3.
Third slot, there was the word, you.
In fact, I made a slight mistake with this picture.
This orange subtable doesn't need to even exist.
Like, just inside this blue rule subtable, there can just be three slots with three words, and that's it.
But then I added new words that complicated things enormously as mentioned earlier.
So I added the word AND and conditional words.
To start with AND, AND basically lets you bundle words of the same type together so that they can be grouped and it's kind of faster.
You don't have to repeat the same thing multiple times in different areas.
When it comes to its normal usage, it works pretty simply.
For example, you can say, Baba and Rock is You, so you make a group of Baba and Rock, and they are both You.
Or you can say, Baba is You and Move, so you make a group of You and Move, and then Baba is both of those.
And the nice thing about these is that...
The same with all earlier.
I can just divide baba and rock is you into two different rules.
Baba is you and rock is you.
And with baba is you and move, I can just say baba is you and baba is move.
And it's the same thing.
I don't really have to kind of do any special logic for the and except in the rule parsing phase.
Once the rule is parsed, I can still use the same data format because it's just the same thing in other words.
But with these conditional words, things changed.
So the first conditional word was on and the conditional word as the name implies added some kind of a condition to the rule so that not every object had that rule, but they instead had to fulfill some kind of a requirement to get that rule.
And the first, yeah, as mentioned, the first conditional was on, which meant that the requirement was that For example, Baba on grass is you meant that if Baba is on the same tile coexisting with grass, Baba is you. If Baba is not on grass, if there's no grass on the same tile as Baba, then Baba is not you. And these first conditional words have required these parameters. So in this case, on is the conditional word and grass is the parameter, Baba on grass is you.
But I think the original version only had one parameter possible, so you could only say baba on wall, baba on grass, baba on kiki, kiki is another creature in the game, is you, or push or whatever.
But I very quickly wanted to add the and functionality to these conditional words, so you could say baba on grass and flower is you.
The problem with this is that because the conditional only applies to this single rule, I cannot do the same thing as here where I would divide the rule into multiple things that kind of together handle the AND, kind of take care of the functionality of the AND, but instead I had to add new functionality to account for the AND. And because there could be an arbitrary number of objects or parameters for the conditional, this could be Baba on grass and flower and wall and flag and kiki and rock and blah blah blah blah is you.
I needed to make a system where a rule could contain an arbitrary number of parameters.
And the first implementation of this system was very naive.
I think my logic was that I wanted to keep the rule kind of...
the order of things within the rule, this kind of what is in slot one, what is in slot two, what is in slot three, and so on, in the same order as they were in the actual sentence, which meant that I made a distinction between rules that have conditionals or don't have conditionals.
Rules that don't have conditionals would still follow almost the same format, so that there would be the rule list, there would be the actual rule, subtable, and in the subtable there would be on slot one the object Baba, on slot two the verb is, and on slot three kinda the quality with some differences I will explain in just a moment.
And if a rule had conditions, conditionals...
then the structure would be different.
In slot 1 would be the object again, baba, but in slot 2 would actually be the conditional, because in this sentence baba on grass is you, the on is the second word.
And in slot three, there would be a subtable that contained all the parameters.
So if I had just Baba on grass is you, then in slot three would be a subtable with only one entry.
So in this subtable in slot one would be grass.
If I had Baba on grass and flower is you, then slot three would contain a subtable where in slot one would be grass, in slot two would be flower.
And then...
Slot 4 would contain the verb as usual or not as usual but like would contain the verb is and slot 5 would contain the quality you And uh To keep kind of parity between these systems, even though they had a different amount of slots used I wanted to make it so that slot 3 would always be a table no matter what the format No matter whether the rule had conditionals or not So in this non-conditional rule, I had to make it so that slot 3 is still a subtable.
It just contains only the quality and not grass or flower, but the U and nothing else.
And this system, as you can imagine, was very awkward because it meant that...
When testing if a rule exists, I had to actually do very different things.
For example, if I wanted to see what the verb is in a sentence, I would have to check if the rule has three or five components and check either slot two or slot four, depending on that.
And if the rule had only three words, I would have to check the subtable in slot three in a different way than if it had five components. So the ideal way to do this would have been a system where the structure is the same no matter if the rule has conditionals or not. But well, I think this worked for a moment for me and I was happy with that but eventually I had to rewrite it completely because I wanted to add more conditionals.
I wanted to add more conditionals with parameters such as near where baba near grass is you means that if baba has grass somewhere around baba then baba is you or phasing where if baba is looking at some grass then baba is you but I also wanted to add conditionals with new types for example lonely which doesn't take parameters but works more as a kind of a prefix So you could say lonely Baba is you.
So Baba would be you only if there's no one else on the same tile as Baba.
And as you can imagine, this old rule system couldn't accommodate.
First of all, originally I assumed that there would be only one conditional on.
I didn't take into account other conditionals at all.
But also this system was way too rigid to work with the lonely system at all.
So I had to...
Well, I had to just like...
break everything and rebuild it. And after this third iteration, I found a system that I will show in the next on the next slide that has basically worked as it is until now or to this day. But there have been some reworks, some polishing, some even pretty substantial like underlying work, but the format has mostly stayed the same afterwards.
Yeah, yeah, like there have been more exotic rules, more exotic words that have required extra work in the rule parsing system But the formatting has been spared mostly Okay So here's a nice diagram, very simple, very easy to understand diagram of how what the rule formatting rule looks right now so Even though you probably don't need any explanation, I'll go through this system briefly.
We still have the rule list table, and within this rule list we have these different rules in their own sub tables.
Here's rule one, here's rule two, they both contain the same stuff, I just didn't draw the same boxes within rule two.
In rule one, there are three compartments that contain different information.
there's the base rule compartment that contains the same thing as in the first iteration just kind of the in slot one baba is slot two is in slot three you the kind of object verb quality or object verb object structure.
Then the second compartment is the conditional compartment which contains all the conditionals the rule has.
And because there can be an arbitrary number of conditionals, for reasons I will talk about in just a moment, and because those conditionals need to be able to have potentially arbitrary numbers of parameters, these conditionals need to have all their own subtables.
So here in the conditionals compartment, conditional one has its own subtable, inside which on slot one is the type of the conditional, on in this case.
And on slot two, there's the parameter list, which is its own subtable.
In this example, the conditional one, whoops, is of type on.
And in slot two, it has only one parameter in the subtable grass.
But for example, if we did the baba on grass and flower is you, then there would be again, in slot one, grass, in slot two, flower.
And there could be several of these conditional sub tables and they would look pretty much the same.
If there's a conditional that doesn't have parameters like lonely, it would still have the same structure but the second slot sub table would just be empty and treated as such.
There's also the conditional never which is done for disabling rules.
It's kind of a special case.
And the third compartment.
is storing the IDs of these words. Basically it's like a reference to the in-level objects, the words as the player sees them visually in the game. These are needed because, for example, when the rule becomes active and I want to display some particles or change the colors of the words, I need to be able to somehow refer back to the words from this, uh, formatted rule list.
So then I just looked into, look into this word ID, sub table, go through these and do whatever I want to do all of those.
And then for example, like slot one might refer to Baba.
slot 2 might refer to is as they appear in the level.
I'd say it's a pretty nice system, it works pretty well right now.
But then...
As I've been alluding to, this system has its own problems.
There are a bunch of issues with the system because I've been adding a lot more stuff over time.
The game has become a lot more complicated over time.
And certain new word and rule additions have made parsing everything way more complicated, even if I have this pretty stable structure.
And here I will go through some examples.
So as the...
rule system became more complicated, the amount of possible word combinations increased, the complexity increased pretty much exponentially, and some of the words I added were really cool, but well yeah complicated matters even further, they made it even more difficult to make a stable nice rule system and right now I don't think a stable nice rule system is even salvageable.
Here are some examples.
First of all, there's the word not.
Not does the same thing as I mentioned at the beginning of this presentation.
Not turns the kind of meaning of a word to the opposite.
I gave some examples of where not is used and in its basis, it's pretty simple.
But the rule system needs to be able to parse something like not baba, not on, not grass, is not you because not can go into many different places and the rule system needs to be able to understand.
what it does in all those different places. Also as a kind of a gimmick I wanted to add multiple negation so not not not baba is you needs to be parsable as well. Then there's chainable conditionals. So as mentioned here there can be multiple conditionals in a single sentence and you can do this for example, by saying Baba on grass and near wall is you.
And technically you can chain those forever.
Baba on grass and near wall and facing Kiki or something is you.
And I don't think this system works perfectly right now.
I think there are some bugs with it even now.
I need to work on that.
I want to work on that.
It's still a pretty simple system.
It just requires making the parsing logic a bit more involved.
But.
It's not the worst, but it's still more complexity.
Here comes a spoiler.
I'm sorry I forgot to warn you about this, but in the game eventually you run into letters that can form words, and these words can be used in sentences.
For example...
B-A-B-A is you is parsed as Baba is you.
W-A-L-L is stop. Well, wall is stop.
Or B-A-B-A-I-S-Y-O-U is Baba is you.
And the letters are probably the single most complicated and complex system in the whole game because...
They have a lot of corner cases, they have a lot of complex... a lot of, like, kind of very difficult parsing quirks to them. For example, there's W-A-L-L is stop.
Is this wall is stop or is it all is stop?
Right now, the game needs to be able to understand both of those and add both of those into the rule list.
And it actually does. That one works.
in B-A-B-A-I-S-Y-O-U, the game needs to be able to understand the limits of the words, to detect where the words end and where the next word begins.
If there's an A-I word somewhere in the game, there's a valid object, the game would have to understand that.
There's Baba is you, but there will also be AI here that could form its own rule somewhere.
That becomes very, very, very complex.
Then there are stacked rules.
So you can put two rules on top of each other in some situations.
Basically in the game you just find a way where you can have two blocks on top of each other.
And if those blocks happen to be words, then you have two words on top of each other.
So for example, there's the situation Baba Kiki is you, which needs to form both Baba is you and Kiki is you.
Or you could have Baba Kiki is you move, which should form the rules Baba is you, Baba is move, Kiki is you, Kiki is move.
Basically the game needs to go through all the possible combinations of those words and form all the valid rules.
And this is again extremely complicated, especially when combined with some of these other things, such as the letters of the chained conditionals.
To give an example, here's BABA ON EAST GRASS U EAST MOVE.
I drew a little diagram to show how this...
jumble of words should be interpreted. So here, on is and grass you are on top of each other. So in total there are five words seemingly, but two of the words are duplicate or like multiple words.
So there are three different possibilities for how this could be interpreted and all of those should be interpreted correctly. The rule system should get three rules out of this instead of just one or two. So we can have BABA ON GRASS IS MOVE. So BABA ON GRASS IS MOVE. Pretty simple.
Then there's BABA IS, so the second option.
And after this, actually, both grass and you are valid options to come after is.
So there's Baba is grass and Baba is you that should both come out of this mess.
And this, yeah, this gets super complicated. There are totally, like, many situations where it doesn't work right, but it's a very cool concept. I like that it's in the game, even though it causes me some sleepless nights.
And finally, as a fairly tame example, there are ways to combine rules so that two different rules share some words. So for example, there's I guess this computer made a noise There's Baba is grass and rock is push So this should work form the words or the rules Baba is grass and rock and grass and rock is push. Right now this actually bugs and the game only forms the rules baba is grass and rock and rock is push because it doesn't realize that grass and should be included when doing the rock is push check. I'm going to try to fix that but right now it's a problem and there are some with letters for example there are some similar issues that are way worse.
So those are some of the complications I've run into.
Some of them I've solved, some of them are still to be solved, some of them are solved partially but create endless amounts of new work. So for some conclusions from all of this, let's see.
I still have a couple of minutes of time.
The conclusions I've come to when working on this system is that it's futile to attempt to make a perfectly parsable system or parsing system without simplifying something. The system as it is is way too complicated to ever make it work perfectly. Maybe someone dedicated their whole life to doing that or there was like a huge team they might be able to do that, but as it is I have to admit that I'll either have to remove some of the more unstable elements or...
...accept that there are going to be some oddities there, some things that don't work as they intended, maybe some bugs that become features or some things that I just acknowledge that, okay, that doesn't work, no can do.
And at this point, I do realize that, for me, including words that felt fitting or cool into the game...
took priority over the stability of the system. For example, those letters, they add a lot of complications into the rule parsing, but it's such a cool thing, it's such a nice exploration of the themes of Baba is You that I absolutely couldn't leave it out. And there are many other examples of that, where I kind of took a larger bite that I can chew because I felt that I needed to have something in the game.
Yeah, I've even mentioned to myself there like especially letters are like that um And i'm kind of happy with that in some situations because in the bass game If I knew that there was some problem with a certain rule or certain parsing thing or whatever, I could design levels so that I don't showcase those.
I try to generally make all the systems as dynamic as possible.
I didn't want to make some rule that only works in one specific situation and then I just try to hide from the player that it doesn't work at all.
There's some specific...
Sorry, some specific examples of that as well, but I mostly try to make everything dynamic.
But even still, if there are situations where some rule might be kind of arbitrarily not working, I still have the option of...
not giving the player the tools to break the rules in that way, to kind of see the weaknesses of the system, which was kind towards the players, I feel, and also saved me some extra work.
But we are releasing a level editor for BaBaSU later this year, at some point. I'm working on it right now.
And the problem with the level editor, especially because it has level sharing, online level sharing, there are going to be people trying all kinds of wild stuff, and even if I spend all the time from now on to the release fixing things, all the quirks I know, people will inevitably find something new that doesn't work, or that is funky, or...
Yeah, so eventually I'll just have to admit that, okay, some things are features, not bugs, and people may use them in their levels, or I'll have to say that...
Please don't do this. I know it doesn't work, but I cannot help it anymore, or I don't have the energy, willpower, or something to fix it.
It's a shame, but it happens.
And then finally, as the final point, a quick thing.
There were some words that I wanted to add throughout the development, but I didn't because I kind of felt that, okay, this is maybe too much, too much work, more work than it's worth.
And one specific example is the if word.
It would be super cool to be able to say something like Baba is you if Rock is Push to create like if clauses because it could increase the kind of logic nuance and elegance of the system a lot. I've seen people make stuff like Conway's Game of Life in Baba is you and I'm super happy about the stuff like that and I want to support those kind of endeavors and I think the if word would have done that.
But at the same time, I feel that if I added the if word, I would have to make the following sentence actually parse.
Lonely Baba near grass is you, if rock is on flag and facing right.
And as you can see from my onomatopoeia in there, that would be terrible.
I wouldn't want to be in a situation where I would have to make sure that all those possible combinations of words actually work in the game system.
So.
if stays out for now. I have some ideas how to implement it in a more simplistic way, but as it is, it's kind of out of consideration. I have to fix other things first.
All right, so thank you very much for listening to my babbling.
I hope you enjoyed, I hope maybe you learned something from this, maybe you didn't learn anything but it was still intriguing.
If you watched it until the end, I hope you didn't have a super terrible time, even if you didn't enjoy what you were watching.
I'm sorry if that happened, but to be honest, it kinda isn't my fault if you watched the whole thing through, maybe.
Thanks a lot. Oh no, I'm about three minutes over time, but...
Thanks a lot to the GDC staff for organizing this virtual talk thing.
And yeah, I think that's it.
Thanks for watching and take care.
Remember to wash your hands and watch other presentations also from this virtual GDC presentation.
Rigamarole. Thank you.
