Ladies and gentlemen, PCG Shotgun.
Let's welcome them.
Thanks.
So when Dave told us that he wanted us to come up and speak for 60 minutes about procedurally generated shotguns, I didn't really think we'd have enough time to fill all the content in.
So we're gonna go, each person's gonna talk about different types of shotguns and how to procedurally generate them.
So I hope you guys all know what you were prepared for when you came here and take lots of notes.
So I'm gonna introduce our first speaker, Mitu, and Mitu's gonna take it from there.
I guess I will. Go for it.
All right, thanks Tyler.
Hi everyone, so, where are my slides?
Are they here?
Here they are.
Okay, cool.
Hi, okay, so, hi, I'm Mitu.
So, I do a few things.
I make games as the tiniest shark.
I'm a member of faculty at the NYU Game Center.
I'm also Chief Creative Officer at Spirit AI.
So this is actually the second of three talks I'm giving in the, just the AI Summit this year.
So some of you may have seen my talk yesterday on Reactive.
Storytelling through agent-driven design.
And I'm going to talk about some of the work that I've been involved with lately, sort of touching on some elements of that, so apologies if you saw that talk.
But also, I'm also doing other work kind of at the opposite end of that spectrum.
So, and I've been thinking about this as a spectrum, actually, so this idea of agent-driven stories versus story-driven agents.
So, there are quite a few of us on this panel talking about various kinds of procedural generation of characters, and so I think part of the reason I'm going first is to frame that work with some definitions and some tips for sort of working at both ends of that spectrum.
So, firstly, sort of why should we even tell?
those kinds of procedural character-based narratives.
The boring but true answer is replayability, longevity, et cetera.
The more interesting answer is that I think all procedural systems are kind of driven by a philosophy.
It's an opportunity to discover a certain knowledge space.
And there's lots of opportunity for very thoughtful, very nuanced stories to be told.
So procedural narratives can allow us to explore and unpack the philosophy of an entire story space rather than just one story, of course.
So let's go ahead and start with some definitions.
So what I'm calling agent-driven stories are those which are based around simulating the interactions of lots of agents, which can tell us something about that particular world, through having the player interact with them, etc.
And the way that stories are told in that particular world is through a mechanism of noticing, really.
So that's kind of the mechanic.
sort of noticing how agents are set up in opposition to each other, which ones are different from the others and why those particular properties might matter in the context of that particular world.
So agent-driven stories rely on lots of agents.
The storytelling comes from noticing.
So these agents are supposed to be moving, they're not animating for some reason, but that's fine.
Let's imagine all these agents moving and they're all moving differently.
So I wanna talk about some Proc Gen considerations given those.
sort of psychological strengths, right, the sort of mechanics of noticing.
On the other hand, there are also what I'd call story-driven agents.
So those are agents which have been crafted to know a lot about a particular story space.
The way that you learn about the story space is by interacting with that particular agent through some kind of dialogue or even some other set of interactions which act upon that particular agent.
Again, my animations are not working.
Imagine one of those agents is like super huge all of a sudden because that's the agent that you're really interrogating.
Okay, so that's kind of the spectrum of types of character AI.
So those of you who saw my talk yesterday on telling reactive stories in an agent-driven world, I sort of talked about what I'm doing at this end of the spectrum, the agent-driven stories end of the spectrum, as the tiniest shark, which is where I'm working on a game which is called Little Invasion Tales.
So Little Invasion Tales is a small city building and citizen management game all about defending your citizens from alien attacks.
I've also previously worked on a game called Redshirt, which was a kind of bleakly Machiavellian social networking simulator.
So and that world was really set up through the mechanics of noticing, right? So noticing that characters behave differently because We don't really understand people, right?
Like nobody really does.
We don't have a complete model of human behavior and the best we can do is express a particular point of view.
So the limits that we impose on a sort of system that we create are expressive.
They have something to say.
And we need to be cognizant about what we're actually saying.
We need to be conscientiously reductive when we're designing character-based games.
So, for example, in Red Shirt, the space created was kind of about using people as pawns.
And so a lot of the attributes that characters had were kind of, you know, in that sort of negative space.
So they had things like vanity, fickleness, bigotry, etc.
That was like the world.
And those were the attributes which set up characters in opposition to each other.
Then, on this side of the spectrum at Spirit AI, we're building tools in middleware to help people write story-driven agents.
So, M Short just gave a talk in the Narrative Summit more about what we're doing, so I'm not gonna go into it, but we basically made an SDK and a set of tools for helping you create characters which are more deeply expressive.
One particular demo we have is about interacting with a robot who you're interrogating, and the system is able to sort of improvise off scripted dialogue.
that you've defined for it, and it has an agenda.
So it uses sort of a space of knowledge, like a knowledge space that it has about its own world and uses that to let you interact with it.
So I think that those types of two sort of procedural character-based narratives affect writers and designers in different ways.
So I think that one of the opportunities we have is to sort of bring writers more into the fold of sort of creating these sort of story-driven agents.
So with story-driven agents, the shift moves more towards writers.
So and one of the real things I want to sort of impress is how do we as humans if we're making character AI or Just in general as humans How do we find out more about each other and our agendas like you know as real humans?
Generally, we do it by talking to each other right we sort of ask each other things we converse about our opinions Even when that's difficult in recent times especially.
So language is super important to humans.
And with Little Invasion Tales, I've tried combining instances of language into an agent-driven story, which is basically the talk I gave yesterday.
One of the missions that I'm trying to accomplish with Little Invasion Tales is bringing sort of a wider audience into the fold of understanding procedural narrative and kind of what happens, like the fact that we, look at agents interacting and we have an implicit narrative that arises out of noticing those interactions, but actually making that explicit through text and voiceover. So using language to help us notice.
And so, also related to that point, so this is, you know, I've already touched on how Redshirt worked. And also, Procedural characters sort of need to be expressive about their world.
So again, in Little Invasion Tales, they're expressive about their particular world through talking to each other.
So the system in Little Invasion Tales for passing knowledge between characters is one that's inspired by the system in Left 4 Dead.
So it's basically like a query system and characters can share knowledge between each other but also be able to trigger all kinds of actions as well.
But also I want to point to besides language, what are some other solutions, particularly if you're at the end of the spectrum where you're making agent-driven stories.
So one of my go-to solutions to try and hit that sweet spot, which I've enacted across both Redshire and Little Invasion Tales, is letting the player just...
see the process of character creation, like using character creation to help us notice, right?
Letting the player fiddle with sort of sliders and variables so that they can understand what the underlying model is.
So character creation is a form of communication.
This is the character creator from Little Invasion Tales.
So the last thing I want to say is that I'm really interested in what we can come up with when we bring both sides of the spectrum together.
What kinds of procedural, character-driven narratives might be possible then, right?
So again, my animations are not working, but let's just imagine these floating and becoming one and other things that the animation is supposed to do.
So yeah, imagining.
what would happen if we had a system where we had lots of agents interacting in the world, interacting with each other according to the underlying social model, but then you could interrogate some of them, right?
So you'd have a few of them which you could interrogate more deeply and find out actually what is their agenda within this world, so using the mechanics of noticing and using the mechanics of language.
So, yes, there we go.
So the little agent which is supposed to be animating is saying, see how I act in relation to my world, talk to me about what my agenda might really be.
So that's it. So that's my sort of set of definitions.
You can see what we're doing at Spirit on the sort of language-based interaction in North Hall from tomorrow.
Thank you.
Hello everyone. I'm Tanya Short and I'm going to give you some tips for maximizing the impact of your generated personalities. I actually hadn't heard Mitu's talk before just now, but I think you'll see some interesting parallels.
So yeah, if you're generating personalities in your game, you're first going to need to pick a reasoning, a motivation, and then a behavior, which is what a character does and why they do it.
So now you have a generated personality, congratulations.
But is it an interesting personality?
Does the player understand what that personality is?
Are the connections between the reasoning and the behavior actually satisfying to discover?
That's the goal.
Normally we would assume that reasoning drives behavior, because that's how we experience our world.
Not only does science actually have a few factoids and studies that disprove that, but you might want to consider the opposite for your game.
In Moon Hunters, for example, the player's behavior, such as being nice to everyone, was then measured and determined what personality trait was assigned to them, such as compassionate.
sort of retroactively explaining their behavior through their motivation.
And from the player perspective, they can encounter each of them, or both simultaneously, depending on how you frame it.
Even if your engine is starting with reasoning and then going into behavior, it might make sense for the player to see it the opposite, see it at the same time, because to understand the simulation, the player has to understand both the cause and the effect, even if a given action is both a cause and an effect.
In human-authored media, it's common to start with the behavior and never show the reasoning.
It's common to advise show, don't tell, which means displaying a behavior and allowing the audience to interpret the personality according to their own internal lens.
This is more natural.
This is how we encounter real people in real life.
Getting to know someone is about interpreting their behavior or their reasoning from their behavior.
But most procedural personality games up until now have gone the other way.
They tend to tell the audience about their personality traits and their reasoning, and then later on display the behavior, at which point it's the player's gameplay to notice.
and interpret what the algorithm is actually doing with that reasoning.
The advantage of this approach is that AI systems become core to the gameplay.
Noticing is the gameplay of understanding the systems.
And this is great when you're worried that maybe your behavior will seem rather random because now the players have built their own model of reasoning.
However, that can result in a lot of information for the player.
Many procedural personality systems, such as our beloved Dwarf Fortress, and games I have worked on as well, tend to expose a lot.
And as our audiences become more accustomed to procedural content, maybe we won't need to expose as much to convince them it's not random.
But part of the problem is that compared to other procedural content, procedural personalities are very subtle, because in real life, even, personalities are very subtle.
They are abstract, they are invisible, they're fourth-dimensional, they take place over time.
And even if you lean on well-known archetypes, people will still need to pay attention to see the pattern.
You can't rely on instinct the way you can with physical attributes, like hair color or height or gender.
I was stunned when I joined the Age of Conan system design team because I had played the game for a month.
And after playing for a month, I joined the team and I looked at their scripting engine and I found a beautiful, modular, elegant version of a Maslovian hierarchy of needs for these monsters that I had been slaying and observed no such thing.
Every single character first would seek safety, and then seek shelter, and then seek food, and companionship, and self-actualization.
Yes.
Even though the internal design team's motto was combat, combat, combat, and correspondingly, most of the players just killed everything.
But the real problem here was that there was no way as a player I would expect that to be the case, and there was no sign to the contrary.
There was no reason for me to expect that reasoning was going on.
and there's no communication.
So they had this beautiful system, which I used a lot for designing boss fights and things.
But this living, breathing world aspiration kind of took them into this wasteful use of energy for years, developing a system that didn't need to be there.
So if you do hide information about your personality systems, it can really help to be obvious about it.
As in Civ 6, which came out recently, you can see some coy hints about what's hidden.
When something's hidden, it's very obvious.
This encourages further experimentation and exploration by intriguing the player.
And that's part of why we're being really up front about hidden villager personalities in The Shrouded Isle, which is a game coming up published by Kit Fox Games.
The discovery of those personality traits.
becomes a player goal, which is then very satisfying to, or intrinsically satisfying to discover, as if you're getting to know someone in real life.
So in addition to not hiding your whole systems, you might want to look at what kinds of personalities you're generating, because in games like Crusader Kings II or others, more extreme personalities are easier to notice.
When you have subtle traits like irritable, not only is it harder to see, but it's also harder for the character to express through your various gameplay systems.
For example, Roth, it's easy to imagine what a Roth person might do on a battlefield or in political negotiations, but irritable?
Does that really have a meaningful gameplay impact?
Probably not.
And finally, when you pick traits, even if you're going extreme, extreme passivity might still be hard to see.
You might notice that in The Sims, it's not just that shyness, for example, makes someone avoid conversation.
Avoidance is just really hard to see.
So instead, having specific behaviors for each extreme is important.
Even in real life, of course, when people are shy, they don't actually cover their face and maybe withdraw awkwardly from every conversation.
But if you don't do that, it just looks like a lack of behavior rather than an active behavior.
Arguably the most successful personality type in King of Dragon Pass was the trickster archetype.
And I believe that that's because they clearly stood out among an otherwise reasonable panel of people.
They were the one that really caught your eye when you were playing.
In short, it's a risk to hide almost everything in procedural personalities, because there's no good reason for players to assume that there's any complexity there.
Of course, if you go too far in the extreme, everything becomes a bit silly.
But even if you don't get silly, players might still be laughing because...
Well, it's natural.
Authored characters have the advantage of immediately reading as human.
All gameplay systems in authored games tend to support the notion that this character's personality is natural and it's expressive.
Whereas in a procedural game.
you tend to have overtly intellectual gameplay.
You tend to be having system-driven gameplay in which the players are actively exploring the logic, not leaning back and submissively suspending their disbelief and becoming immersed.
Your characters are symbols of people in this kind of gameplay.
They're not real people and they're not even like authored people.
Exploring procedural systems and the chaos of simulations is kind of the opposite of immersion.
I mean, even if you do achieve immersion and portray drama, the player has to internalize all of your systems in order to reach that point where they can look past all the numbers and the spectrums and whatever and see humanity, which takes time.
And during that time, chaos and surprise is almost guaranteed in system-driven worlds, which makes comedy even easier.
So when you're designing your player experience, just keep in mind that things will be a little bit funny anyway.
A third tip for maximizing your impact of procedural personalities is that if the same event produces two contrasting reactions in characters, it's much more economical.
You can learn much faster about both characters than if you're relying on each of them acting independently.
So in this example, if a character dies and one character laughs and the other one cries, you're learning something about both of them without needing to set two different contexts.
And in fact, as in redshirt, you can more quickly process a whole crowd of reactions.
If you have a crowd of 10 people, imagine trying to keep track of each of those 10, each doing their own separate activity, versus five of them crying and five of them laughing, which tells you not only about each one, but also their relationship to each other.
And finally, I recommend changing your procedural personalities over time rather than setting them static at the beginning.
Because people change.
That's natural.
They change for so many different reasons that players will justify almost any transformation.
We've told them enough kinds of stories.
We're used to seeing people get stronger over adversity, or weaker in adversity, or getting stranger.
So as long as the player is given a before, a trigger, and an after.
it's probably enough fuel for them to build their own pattern of why the change happened and what it means to them.
I just want to take a moment to note that when I reached out to David Dunham, a designer of King of Dragon Pass, he actually explicitly warned that these risks can be overcome.
And it's true, there have been procedural personalities that have been subtle and dramatic, and they're great.
But the reason I give these risks is not that they're bad, it's that we want to engage with these risks intentionally rather than discover them halfway through production.
So I recommend being...
careful with your subtlety and otherwise maximizing the impact of your procedural personalities.
Thank you.
Okay, so I'm Tarn Adams, the co-creator of Dwarf Fortress with my brother, and I'm going to talk about, I mean, I was invited on an AI procedural generation panel and I came up with the most naive thing you could do.
I have AIs making stuff, so this is a discussion about that.
So here we have...
just naively, we have procedural generation.
You have some sort of algorithm that's going to make something.
You have an input.
You have a random number generator.
And rarely in practice does it actually turn out that way.
We massage our results.
We add a lot of algorithms.
You can put your sort of personal touch into it.
And it can get out of control.
Sometimes you have to throw things away.
But in the end, you have.
A lot of levers once you've made your final sort of algorithm when you're thinking about generating any type of content.
And it's great to have all of those levers available, because when you have an AI making something, you can just swap in personality traits for your initial state.
You can bias your random number generation with these traits to sort of restrict the output into what could be created by this agent.
You can think in isolation of an agent creating things as just a restriction of a general algorithm, although in.
in practice you'll find that they do much more.
What am I talking about here? Making anything really. I mean you could have simple crafted items you could think of like Diablo type stuff or furniture.
Visual artwork, and you don't need to actually generate very good assets, but anything really, location maps, stories.
You could think of AI behavior itself as being a result of a procedural generation algorithm, if you want to be reductive about it.
But really anything, anything you want in this talk.
And they, they think about.
the knowledge of the world, what things have happened, what sort of locations there are, also their relationships to people.
You can put anything at all, their personal beliefs into these objects they create, but coming from Dwarf Fortress, you might think I'm talking about like, generate your whole world and then you can make a game too, or whatever, right?
That's not what I'm saying here with...
With events, these could be handcrafted.
This could just be one small generator that exists in a completely handcrafted game.
You just have to systematize things.
So, and specifically with events, when I'm talking about things that happen, those could be things that the player does.
We're talking about in-play generation, after all.
and we have the AI agents running around doing things.
But you can take your, if you have an IP or something, or just some back story that you've written, you have your books and video logs and so forth, but along with those, you can create a skeleton, just a skeleton of what happened in a systematic way, homogenous with these player events, so that they can all relate to each other.
You can use the same functions to generate objects.
that tie the player events in with backstory events and so forth.
And you can systematize larger groupings if you want to reduce something down to just, say, the biography of this person even though it contains many events.
So, more importantly, I guess for things like emergent narrative, you can also take your outputs and turn them into inputs.
You can think about things that other people have made.
Your agents can think about things that the player made.
They can think about their own stuff.
They can think about other people's stuff.
And so let's do some examples.
So simple example is the player is elected mayor of a city.
You know, this is any game where that could happen.
Someone could make a statue, you know, a commemorative statue.
It's a very simple AI thing.
You'd need to say that the AI doing this, of course, this is their profession or something, they know how to make statues.
but they know that this event happened, they created it.
Or they could try and systemize something, systematize something a little more personal to them, like their belief in the value of friendship.
They could write a book about it.
That doesn't mean like generating the text of the book or anything, they just create this in-game object that stores data.
This is kind of the, one of the biggest takeaway of the talk is the more data you store in your objects, the more little gears you have to bump against each other to make emergent narrative.
So you actually store the data inside the, book, and then it can be used.
People, like most naively, could create copies of objects. People would understand that they're making a copy of a sort of a statue of the player if they're just making knockoffs for some reason. Or they could be reviewing the book.
They can talk about it. They can think about who is the author of this book because that's stored in the book.
They can think about what do I think of the value of friendship?
What do I think of the writing style? Because those things are stored in the book object.
And it also allows you to do exposition.
If you have data in the objects that your agents have made, then you can speak to other events that have happened.
It's sort of a way to indirectly propagate information by scattering things around the world.
It's difficult to get the player to suck in this data stream, right, of there's so many things going on.
It's the exposition problem kind of.
Both of the previous speakers have gone into a little bit.
And this is just carrying a little data in your objects lets you do that.
It also lets you have reactions to the objects that make the world seem more alive.
So if someone doesn't like the player, they can see that the player is related to that object.
They don't need to care about this mayor thing, but just the fact that that piece of data is in there allows a reaction.
And the same thing if you don't like the...
value of friendship, you could burn all the books and hunt down the author.
But more subtly, you could just learn the basic existence of that event, so you can propagate knowledge through these indirect objects.
And you can also change people's minds.
This is, it's kind of the sort of...
I don't know if it's the holy grail of personality, but it's, like Tanya said, changes gold, making things that actually seem like a character arc, where someone would pick up this book and learn the value of friendship, finally.
Could be something that happens.
I mean, in Dwarf Fortress, we have people propagating books around and sort of pushing philosophies one way or another, just like this.
So for the last bit here, we have...
The game, there's the game.
Your player has done things in order, right?
I mean, it's simple, you have these events, they're systematized, their location, what the player did, if there was someone else involved.
We also store reasons and circumstances to the extent that we know them at all, so that people can think a little more deeply about the game objects.
And as I said before, you can have your historical objects stored the same way.
This is not necessarily a procedural history, but just if you're doing some kind of comic book game and you have 20 back issues, you could make a systematized version of them and be able to refer back to them and have sort of...
content emerge from that.
The same goes with future events can be stored the same way.
So you have some kind of psychic prediction or prophecy that's supposed to be met.
And then when the AI crafters come along thinking about these things, they can start to do stuff that's almost literary, right, at this point. I mean, it's not going to be high art or anything.
But you can start to draw allusions to past events, and you can start to use literary tools, like substituting, say, the player, whatever happened there to the poor red thing that didn't seem to make it to the end of the game, in event B.
Could be something similar that happened in history, and then when someone makes a statue, they could sub out the antagonist with the antagonist from the past, but show the player.
the player defeating the antagonist from the past, and then the exposition, they'd kind of either explain what they did, or at least what they were getting at, so the player doesn't have to guess that these things have these values, they can just be told about them.
Unless, I mean, there's something to be said for not telling them everything.
In any case, we have finally...
you can introduce your conceptual objects into this sort of thinking.
So in Dwarf Fortress, we have, say, 40 intellectual values that people have in different degrees numerically.
And you could give.
the basic events, like this, say, this reconciliation that maybe happened at the end here, could have friendship tagged with that simple event.
Just a simple table of events linked to conceptual types.
And that's, I mean, it's basically a symbol, right?
So we have this book of friendship, then, doesn't need to have text.
It could just have a simple set of friendship-related events that the person wrote about the player.
and they just need to describe them somewhere, say that the player was involved, and somehow involve the, in the exposition, say that the symbol of friendship was involved, and that's an allegory, right?
So you can do any sort of artistic literary type you can think of.
can be involved with fairly simple systems.
I mean, there's not too many objects here, but you just, kind of what it says on the tin when you go to Wikipedia and read about allegory, right?
some just simple concepts that you link together to produce these things.
And you don't have to produce the text, right?
I mean, that's the thing.
You just need to produce a description, allow the person to say what's going on, and then allow people to react to it and be changed.
So this book of friendship...
might actually describe events of this, these fictional events that the player didn't actually do and then someone could come up to you and thank you for teaching them about the value of friendship and you wouldn't know what was going on until you found the book.
So, yeah, that's it. Thanks.
APPLAUSE All right, who here likes math? It's about to get really gritty, so buckle up.
My name is Zach Aikman. I'm the technical director at 17-Bit.
If you haven't heard of us, 17-Bit is a medium-sized indie studio based in Kyoto, Japan, with a satellite office in Seattle.
Our first game was a turn-based strategy game called Skulls of the Shogun.
But more recently, we released a 2D space shooter called Galaxy on PlayStation 4 and PC, and right now we're working on adapting that game into a mobile version to be released later this year.
As lead engineer on Galaxy, I was responsible for developing a number of different systems, but the one that I had the most fun with, and the one that I'm going to be talking about today, was the system for generating procedural levels.
We made the decision halfway through development to switch from handcrafted dungeons to procedural content to put more of an emphasis on the parts of the game that really shined, namely combat.
And so just to help put this talk in context, here's a top-down view of a level in Galaxy's early prototyping days.
All the rocks, camera boundaries, the decorative objects, enemy squads, all that stuff was hand-placed.
And we realized that this was not gonna be a feasible approach for generating a lot of content with a team of our size.
And in this animated GIF of how levels were being built procedurally near the end of the project, explaining everything that goes into this would be pretty exhaustive talk, not one that we have time for today, but I want to touch on some of the main points and the takeaways that we learned from them.
I'm going to go out on a limb and assume that most of you are somewhat familiar, or at least vaguely familiar, with cellular automata, popularized by Conway's Game of Life.
Using a simple set of rules that gets iteratively applied to each cell based on the state of its neighbors, you can generate incredibly complex, self-sustaining patterns.
Here we see two examples of cellular automata, one very simple and one very complex.
But with the right rule set, cellular automata can also be used to generate very organic looking cave-like structures.
As soon as I saw this image I knew that cellular automata were going to be used in Galaxy's Dungeon duration in some form.
But obviously there's more to building levels than just generating geometry.
A cavern of this size would pose serious problems when it comes to placing points of interest and guiding the player through the level.
So instead we opted to use cellular automata to generate chunks of a level and then stitch those together into a contiguous path.
This first animation shows a room-sized automata being refined from its initial seed into the cave-like structure over the course of several iterations.
And the second animation shows how we were able to control the spaciousness of a room by simply seeding the starting pattern with more or less living cells.
So in the end, we wound up using cellular automata patterns as a basis for room creation.
The generated rooms were then overlaid with additional layers of metadata using a custom tool that we built.
Designers could place spawn points, squad patrol routes, deco and lighting data, et cetera, to be applied to the cavern after it was generated.
And initially, we tried storing the seeds for the automata and generating the caverns at runtime.
It seemed like the most cost-effective way of storing a whole lot of room data with just a handful of seed values.
But this turned out to be an inefficient and unnecessary step.
What we gained in storage space we lost in processing time, because it can be kind of expensive to run, you know, ten iterations in every single room on a grid that's, you know, 64 by 64.
It really starts to add up.
So a better approach was to instead store a run length encoded version of the generated pattern.
Run length encoding is especially efficient at storing exactly these types of images, which have little to no variation in the interior of the cell.
So once we had these cavern cells, we still needed a way to stitch them together into a cohesive level.
And we knew that we wanted levels to occupy a certain amount of rectangular space in the game.
And we also had to fix the cell size that worked well for the amount of content that we were trying to place inside of each room.
And furthermore, the cellular automata chunks had been engineered to accommodate orthogonal exits for north, east, south, and west, and we didn't want to deal with diagonal exits or some sort of hexagonal connections between cells.
So we experimented with a number of different approaches for building level layouts within a fixed region, including BSP trees, minimum spanning trees, and other well-known algorithms.
that you'll use a lot in Proc Gen stuff.
But nothing really seemed to fit with our unique constraints, so I attempted a slightly less orthodox solution that doesn't exist in the Proc Gen toolkit.
My coworker has suggested Z-order curves as a potential solution for connecting the interior rooms of a generated dungeon.
And zero-order curves are functions that map multi-dimensional data to one dimension while preserving the locality of those data points.
So as you trace through that curve, all the rooms that it connects are nearby each other, but you can sort of walk the path using a single index instead of worrying about two-dimensional coordinates.
But they're also recursive, as you can see in this image.
The higher-order curves are composed of lower-order curves, which makes them scalable to grids of any size.
And zero to curves were too jaggy for our use, but being clued into their existence led me to find another kind of space filling curve that was much more amenable to our constraint of connecting rooms orthogonally.
Hilbert curves maintain the mapping of 2D to 1D space that we were after, but do so orthogonally, allowing us to connect rooms with north, south, east, and west exits.
So imagining that we want to fill a four by four grid with dungeon cells, this is a Hilbert curve that could be used.
The h value represents the distance along the path starting in the top left and ending at the top right.
And then that can be used to control things like difficulty ramps, the probability of finding treasure within a room, you can increase that probability as the h value goes up, all sorts of things like that.
And the math for converting Hilbert curve indices into 2D coordinates is extremely simple and pretty fast, which means that you can use them interchangeably very easily.
But the most glaring problem with this approach is that all Hilbert curves look the same.
Even if you rotate the curve, players are going to pick up on the pattern after just a few playthroughs.
So our solution to the problem was to generate a higher order Hilbert curve than was actually needed and then use a sampling kernel of the desired size.
So by sliding this kernel around and sampling the path, you can get different layouts from the more complex Hilbert curve.
This really couldn't have worked out better for us.
It was kind of the perfect approach that we stumbled upon.
The higher order curves contain more detail and thus more variety.
And if you rotate the curve, you can get even more combinations of paths.
So using Hilbert Curves was a non-traditional approach that worked out better than we expected.
I'd never even heard of Hilbert Curves being used in game development before, and it was really gratifying to try to implement a technique that I'd never seen used elsewhere and have it actually work.
And I've talked about Hilbert Curves in other settings like GDC, which has led to two other games utilizing them for their own level building needs.
and seeing someone else implement your algorithm is not only really rewarding as a developer, but it also leads to incremental improvements, which you can then fold back into your own project.
Hilbert curves are definitely not a perfect solution, nor are they even a good solution for most games, but they fit our needs really well.
So I wanna shift a little bit from level generation to talk about how we made the enemy units in Galaxy feel more alive.
This is funny, because I'm gonna touch on something that Me Too mentioned in her talk, serendipitously, I guess.
So frequently during combat, enemies will fire off little quips and exclamations, things like, I see him when they spot the player, or help, I'm under attack if they need backup.
And we call these interjections barks.
But getting these barks to sound organic and non-repetitive was a really interesting challenge, one that we solved by looking to Valve's Left 4 Dead series.
So Alon Ruskin at Valve gave a fantastic presentation at GDC 2012 about the contextual dialogue system that they built for Left 4 Dead series.
I'm not going to rehash the entire talk, but I can't recommend it highly enough.
It's a really interesting, really detailed, and very easy to follow explanation of how they laid out their dialogue system.
But the gist of the approach is that your engine maintains a global state of world facts that are constantly updated as the game state changes.
Facts are really nothing more than key value pairs that track things like how many enemies have been killed or how long has the session been active.
Additionally, many other local states are stored containing facts unique to a particular entity in your game.
For the player, this might include things like how many bullets are left or how much damage has been taken.
And your writers will then author all dialogue triggers as piles of rules or queries.
And these rules can be as specific or as generic as you'd like.
For example, if the level has been active for more than five minutes and the player has less than five health and an upgrade item is nearby, then play the dialogue line just in time.
And the contextual system will always try to find the query with the most number of rules matched, which allows you to write dialogue that's as specific or as generic as you need it to be.
Alon goes into much more detail in his talk on how to best store these facts and rules and how to optimize your query functions and other interesting topics like that that really matter about the implementation.
So again, I'd encourage you to check out his talk or his slides if you're interested in those details.
But despite the versatility of this approach, our implementation suffered from a few problems that I wish we had been better about addressing, and I'm hoping I can pass on some of those lessons to you.
One is that the sheer number of rules and facts that you can generate can lead to an overwhelming amount of content.
I think in Left 4 Dead 2, they said they had 10,000 lines of dialogue, which is no small amount of content to manage.
And for a large team with a dedicated writer who's regularly working in your tools and is really involved in the project, it may not be an issue.
But for a small team like us, it was more of a burden than it was worth.
We also neglected to write an adequate system for bug testing rule queries.
Many of those queries can grow to be really complex, and if you don't have a system in place that allows you to easily manipulate the world or entity fact state tables, it becomes a really tedious process to try and track down errant lines of dialogue.
and this was the one that hurt us the worst, I think.
We had a really bad content pipeline.
Due to the way that certain game data in Galaxy was edited and stored, we had barks defined in both Excel spreadsheets and Google Drive spreadsheets.
And rebuilding the barks data consisted of downloading the Google Drive spreadsheets and running an access database merge on multiple sheets.
To make matters worse, the merge was handled by a Unity tool which relied on a certain access plugin that only ran on the 32-bit version of Unity and certain versions of Access, and it was an extremely brittle pipeline that could have broken at any point in time when we upgraded Unity or Access.
Thankfully, it did not, and we made it through the project, but it's not something that I would do again.
Thank you for listening.
That's it for me.
If you have any questions, shoot me an email or app the panel.
Come grab me.
Thanks.
Bye.
We've got the clicker on the top.
Cool.
Hey everybody, my name is Luis Krul.
I'm a senior technical artist over at SetFX.
We make a software called Houdini.
And this is a pet project of mine that I'm going to be sharing in a little bit.
So I was in game development for about ten years before joining software development.
And I still have that itch to make games.
So this is my kind of little love child.
So this talk is about me and then I have a little bit of content from Antonio Liappis that is over at University of Malta and I'm going to talk a little bit about how we met and basically how that relationship evolved.
So what we have is a little project that I came up with where I want a procedurally generated first person shooter at triple A quality and this is part of my other talk later today on the AI crackpot so you can see how weird and awful it is.
But this is the kind of first steps towards that and I wanted to show kind of where we are in the process and I think we're gonna get really close to the realization.
So we have a small team, we wanna be building triple A content, and we wanna basically have as much proceduralism and as humanly possible, and it needs to be a multiplayer competitive FPS.
And we worked in, like the team, everybody has kind of that frame of mind and that experience, so that's why, if we're gonna put proceduralism into some game, that's the kind of, that's our jam, so it's like, that's our muscle memory and that's what we know how to do.
Um, so the way I like to think about proceduralism and AI is like in TechCart, we have proceduralism as this little black box of inputs that basically the artists will drive and they'll, they'll kind of draw little volumes and everything.
But if you shove AI into that, now we basically have something that can just pump out content really, really, really fast.
So that's where we want to get to.
Um, so I started to think about this project and then I went to, uh.
a conference. There's like a ton of academics and they're all talking about procedurally generated and all these cool ideas. And I was like, let me just shoot a blind email out into the ether and then see what shakes out. So I basically shot out to procedurally generated Google groups and was like, hey man, we can run this project. Anyone interested in helping me out? This is what I'm kind of going for. And then Antonio actually came back and he was like, hey, I have this thing called the sentient sketchbook and we can just make maps. And then it's a web-based API and then it basically just starts by randomly basing.
nodes around and then continuously evolving based on constraints and all of that is kind of data driven and it works really well. So I started kind of playing with it a little bit and seeing what how far I could get to it. And so here's a little bit of the the kind of process to where you have like the random initial seed and then you kind of start evolving based on rules and constraints that I define as an artist. The web API had a little bit of less what than what we needed so he was just super nice and was like tell me what you need because I was like he.
kind of craved that actual AAA side of things, and he was like, I want to see this academic stuff being used in context, and I wanted to use academic, so we kind of met in the middle, and he actually started giving me kind of custom executables that I could use.
And we made some modifications, so the first one is the ability to have second floors to our maps, which is kind of something unique in procedural content generation.
He gave us something I'm gonna talk a little bit about later, which is like further evaluation of the data, so I can tell where choke points are, where dead ends are, where cross ends are.
and then being able to lock down the entrances, which is really crucial for me, and I'm gonna talk a little bit about that later.
And then just being able to, like procedural systems tend to, and he talked a little bit about it, where you just, the walls kinda creep in and it'll try to fill up as much space as possible and it's very maze-like, so that's the opposite of what you want on a first-person shooter.
You want these big, nice, open areas that you can kinda run around and kinda connect together.
So he basically added another constraint, which is I can control the degree of how many walls get placed.
So the output data that I get from the system is ASCII so much like the Dwarf Fortress stuff.
So basically we have a little text that is E is for entrances, I get basically stairs or jump pads in my case, and then spawn points, weapons, I can specify a lot of things on basically where I want things to spawn and how many of each I get.
So that basically I have a little Java wrapper, I have a Python wrapper to a Java executable that just have a bunch of parameters I can create.
Ideally we can kind of extrapolate this up and then make more rules and kind of build this out.
And then basically I can just make as many maps as I want to.
And yeah, the additional output data is.
I have the original map and then he can also, as well with the maps, I can get choke points, dead ends, and crossroads.
I'm not using this currently, but for like, as you people want to kind of start using this, this is super kind of crucial data that you might be able to use.
So making sense of the data.
So first, like the ASCII stuff is really hard to read.
So first I wanted to translate the ASCII data into 3D.
So I just kind of built a grid and then I just color coded it so I could see what the hell is going on.
So now I can see the entrances of everywhere and then the blues is where the jump pads are gonna be so we can go from one map to the other one.
And then the reds is where the weapons are gonna spawn and then the greens are where you're gonna be the spawn points.
But then I can make really cool single rooms, but then we get to the point again, that's like how do you stitch this together?
And then the traditional methods again fell short because they're really built for dungeons to where you kind of have the spidery vein of things growing.
We talked about like adding teleporters to the end of the rooms to kind of connect it together to try to get a flow.
But where we landed is actually, just let the designers come up with the top-down map, and it takes them like five minutes to build it, and then they can just explicitly say where the entrances of each rooms are, what sizes they are, how it all connects together.
And then I can take each of those individual rooms and then run through the system.
So it's kind of a backwards approach to procedural content generation, which is actually working out really well for us.
So traditionally, people will pre-make the rooms itself and then kind of procedurally stitch them together.
We're doing the opposite, to where we're pre-making the kind of high-level flow of the map and where we want the rooms to be, how we want the exits to go.
And then the inside content, it doesn't really matter for us it's like, that's where the flavor's gonna come in.
So the way it works is I take that.
a top-down map, I bring it into Houdini, I just parse the data, and then I can isolate where the exits are, I can kind of get a little bit of a height variation, I can calculate the dimensions, and know where all the door placements are.
I can then run that through the generator that I can then get as many variations as I need, then now they're all color-coded, I get the rooms back, and then I just kind of do some basic extrusions, and then I isolate the rooms, I Boolean them together, and then I actually place the game objects.
And these are the results.
So right now we're at the kind of white stage map and we're kind of taking production as we would in a regular game development.
So first you have like a white box and then we're gonna start arting out.
The whole thing is gonna be procedural but we wanted these safety spots to just kind of reality check where we are and be like, okay, does this feel fun?
And before going all the way, just like you would in a regular game, just does the system works before I kind of make all terrain and everything procedural and everything looks beautiful, is the game fun?
So we actually got to the point now that.
It's actually pretty fun to play, and you can kind of get it in Unreal.
And we had some bots in there, and it actually feels like a real game, which is something that I'm super excited about.
And actually the designer that I'm working with, at first he was kind of like, yeah, okay, procedural, like I want complete control, and now after seeing this stuff, he's like, okay.
I can see with the force from the tree, and I think this is possible, and I think we can do this.
So I'll be again at 1 p.m.
I'm gonna talk about the kind of massive vision of what this project could be, but I just wanted to share the kind of interim step of where I am, and yeah, that's all I got.
So I'm gonna go deep dive on a very small topic.
So everything that is procedural is pseudo.
And I want to talk a little bit about how pseudo-random generation, you need to treat it as your friend and not your enemy.
So everyone, show of hands, everyone knows what pseudo-random generation is, right?
So here's the question.
Raise your hand if you've used an actual random number generator.
Actual random, not pseudo.
Ah, and the hands shrink.
So the thing about computers is, we can't actually make true random generation.
We have to use pseudo.
But you can use pseudo to your advantage.
You can create experiences that use the pseudo nature of random generation to ensure that these experiences that people get that have some sort of random entity in it can be reused, reutilized, and kind of taken advantage of as your players and designers.
So I don't know if you guys have recently heard, in 2014 there was a group of Russian hackers who went on to a whole group of these Novomatic casino machines.
And they were able to record data of those machines, watch them play multiple rounds.
And through doing so, they could actually figure out what the current seed was and know when the next big win was gonna be.
So there's this current big rush of casino companies all over the world getting rid of all these old machines because their pseudo-rando generators were just too pseudo and not random enough.
In games, we don't really care so much about that.
I mean, if someone can figure out potentially what a seed is, if they could reverse engineer, hey, this is a seed that causes this interesting experience, that can be a positive thing for a player.
It's something where they can intentionally choose a seed or kind of direct the seed generation to make something interesting and experience for them.
So I would guess probably many people in many situations, they use the wonderful trick of setting your OS time as your random seed.
Can I see a show of hands of who has done that?
Yeah, okay, so that's the quick, easy, dirty trick.
It ensures that it's somewhat random and you're not gonna get the same seed.
And that's great for something if you just need a quick, dirty, random result.
But there's a lot of times when you actually wanna do a random seed that has value for the player, can be reutilized, or the player can choose which seed they want.
So there's a couple different options here.
One of the most common is let the user input a seed.
So this is something like Dwarf Fortress, like Minecraft.
Put in a number, put in a string, I convert it to a number, and that's the seed we use.
This is great because it allows you to share it with someone else.
Hey, you know, check out seed PCG shotgun on Minecraft.
I was gonna share a photo of that and it's actually a really boring start spot.
So like, sorry.
But the idea is like you can take a really cool, hey, you know, put in my name and see what happens and let's run around in that world.
And it becomes a shareable random experience because you can recreate that exact random generator and pass it on to someone else.
Also, if you do this, you don't actually have to tell them about their input.
You don't have to say, hey, I'm going to share a seed, write it in, and this is what it is.
I'd love to see some games, and I don't know if there's any examples of this, so please find me afterwards, where you actually use something like the character creation.
to determine the random seed. So if someone puts in their profile name, that becomes the seed generator. It's the same thing as I just showed with the Minecraft seeds or with Dwarf Fortress except you're not implicitly or explicitly saying to them, hey, this is your random seed. What makes this really interesting is it essentially creates a cheat code base for your player base that they can discover as they play.
Like, yo, I just found that if you put in the name Yossarian, it creates this really awesome level and it's this very special space and the first room has the best gun in the game.
It creates this really interesting conversation among your players because they're looking for seeds and they're trying to discover seeds through this input system that are really interesting.
I'd also love to see within this loading screens.
You have a lot of now we can do interactive loading screens again without being sued.
So do something interactive with your loading screen.
and take that input and make it become a random seed generator for any content that you have coming after that loading scene.
You can also take a seed and break it into its sub-elements.
So if you have this 12-digit number, you can take that 12-digit number and each number can actually be a specific chunk to place into a level map.
So like Luis's example.
Each one of those rooms could be like, okay, we're using room format 1, room format 2, and you actually take the seed number and switch it out like that.
What's really nice about that is then you can treat your seed as a flexible number or flexible string.
So rather than it just being this big long number that you don't do anything with, you can make small adjustments to it.
You can take this, switch two of the digits, and you still have the general layout that's been defined, again using like Luis's example of like a hand-generated flow.
But now you have two different formats have changed.
And then within the internal elements of each of these rooms, you still have a lot of individual things that are using this seed to decide what items drop, what characters are there.
So you can get some bit of consistency across the full experience, but then have small shifts to the random generation without completely regenerating the whole system.
Now, you can also, this is quite popular, is taking seeds from many values.
A lot of games such as No Man's Sky, you're generating a galactic space, you know, a whole galaxy.
In order to do that, you need a lot of seeds.
And the best way to do that is to take XYZ data.
Take your X, take your Y, take your Z, concatenate them together.
That's a unique random seed that will only be available for that item.
So when you generate a planet, you generate a star, you can use location data, you can use color data.
Someone color picks or it's randomly generated colors, you use the RGB data to create a seed through those multiple pieces.
You can also use a user ID.
So many of us, if you're developing anything for mobile, developing anything for PC, possibly with console, I'm not sure how, but if you can get a specific user data ID, something that's unique to the user, you can then use that as a random seed.
Create something where there's a random data for them that is actually not random for them.
It becomes a static experience for that specific player.
So this is again like a UDID, a MAC address, any type of information that you can pull that's unique to that player.
Assign that as a random seed, and that actually becomes a seed that's no longer random for them.
So if they have a first level that's generated, they always get that same first level, but they're the only one who ever gets that first level.
No one else will experience that level or that space or that specific combination of random generation because it's locked to them.
And that brings me to my last point is the idea of a lifetime seed.
So.
We've all experienced random generation, we've all played games with random generation.
Every time you play a game, every time you go through that replay, it's a new random experience.
But using something like the user ID seed or a lock seed to each individual player ensures that even though we have randomness across each of our experiences, those experiences are unique to us and we will always experience those same results.
This, again, will create a wonderful community involvement where I can talk about my experience, I can talk about, hey, you know, the purple potion in this roguelike always kills me.
You say the purple potion always gives you health, but it always gives you health.
Every time you replay, you don't have to drink that potion and wonder what it's gonna do this time.
It is specific to you.
And I'd love to see games do this with map generation, with character generation, with anything with a procedural system, because then you create consistency across the replays, across those experiences, and it gives the community an opportunity to kind of talk about their specific seed or kind of their specific space that they have, and they get the feel ownership to it.
It's unique to them.
they know that that one random dwarf or that one random character in red shirt always shows up for them every time, but no one else gets that character.
So it gives them more authorship and more ownership to the random generation instead of feeling like full random craziness.
And that's it for me.
So thank you, everyone.
So we have two or three minutes.
We're going to do a little fun activity here.
Each one of us is going to go through and kind of talk about a game that we absolutely love, but would love to see have more procedural generation.
Does anyone want to volunteer to start?
I would love to see a procedural layer of any kind added to Princess Maker 2.
I always wanted to see Xevious with procedural levels, because it has like the weird little eagle you find on the ground, like a little bit through there, and you're like, what is this doing there?
But it would be more like a cultural exploration of a randomized civilization that I guess you're also blowing up at the same time, which is kind of sad.
I'm really a big fan of music games, so Rez would be my top choice.
Like, Rez has some procedural elements to it, but it's more music-generative, reactive and generative, but like more procedural instruments or synthesizers or patterns and things like that. I think it's rich for that kind of thing.
I'd love to see a game like Oregon Trail have procedurally generated characters or personalities.
Like, start from here, get to here, long travel experience, but with actual more personality that's procedurally generated.
I'd love to see Mega Man being done procedurally, to where the weapons are procedurally generated on the bosses, and then the levels are procedurally generated as well.
So I'm going to cheat slightly, and I'm going to point to a game that I'd love to bring together those sides of the spectrum that I defined, right?
Like a version of Papers, Please, where you have these procedurally generated characters coming up to you, and then obviously you're looking at their documentation, etc., but then you can...
interrogate them further and find out more about their sort of motivations and have, I can imagine that being a game where sort of you know the context of the world is set up through noticing the differences between the different characters but going deeper on that so I think that'd be. Awesome and that does it for us for time I guess some of us will be in the wrap-up room and Dave will say some words so thank you guys.
