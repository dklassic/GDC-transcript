Big hand for Ozzy, he's doing a great job.
And then, yeah.
So yeah, the joke is that Jeff finally passed the baton over to Oz, and it's great, and we're looking forward to kind of the next few years of GDC.
So my name is Luis Kruel, and I'm a senior technical artist at SideFX.
SideFX is a software company, and I'll go into that a little bit later, but welcome to my talk.
This is a great crowd, I'm super excited to be here.
What I'm gonna be talking about a little bit, I'm gonna talk about the definition of proceduralism.
It's kind of like a weird buzzword right now to where it's kind of like PBR and there's people think that it's a magic silver bullet and everything can be solved with proceduralism.
Then I wanna talk a little bit about how we roll out a procedural tool system.
And basically you're gonna start out by basically building tools for you and then you're gonna move on and building tools for others and then you're gonna start building tools for everybody.
And then there's kind of mind shifts that change when you kind of hit each of those stages.
My background, so I was in game development for about 10 years, and then recently I switched to be a software developer, and my job is exactly the same.
So basically before I used to write tools and maybe like 10, 20 people in the studio to use them, and then every now and then I would get an email and be like, hey, this is broken, can you fix this?
Come to my desk.
Same thing happens, but now it's just the whole industry, which is awesome.
So I write tools, and then the tools get built into Houdini, and then everybody can use it, and then they'll still email me with broken stuff, and I'll go to fix them, and I'll go visit them.
and help them, so it's an awesome.
It's done a really great job.
And this is not a Houdini sales pitch, so I'm gonna try as much as possible to kind of keep it up here, to where as a procedural software system, you could implement this in anything with scripting, but just kind of like at a high level.
I'm gonna mention a little bit of Houdini, but this is not like entirely about it.
So what the hell is procedural content generation?
And then some people call it PCG, which is procedural content generation.
There's some talks in the AI Summit that I'm gonna be immediately after, so there's this weird kind of.
misconception of like, what is this and how does it work?
If you're familiar with substance, which most people here are, that's proceduralism.
So it's basically you're writing little algorithms to make content.
And that's the simplest of it.
Like I would even consider auto-rigging proceduralism because you're basically just writing procedures to build content at the end of it.
So this is a couple of examples.
So Brad Smith.
He's an awesome artist, used to be a Naughty Dog, now it's at Epic, and then he just does a bunch of substance designer stuff, and yeah, we're building art with these little node networks to kind of make content.
And then Magnus Larsson does the same thing, but instead of using 2D, he does it in 3D.
And that's where Houdini comes in.
It's the same kind of workflow, it's just you're working with nodes, but instead of doing 2D operations, you're doing 3D operations.
So this is the only Houdini.
slide that I'll show just for people that are not familiar what it is.
The same operations that you would have in any other software like extrusion, creating primitives, beveling, so it's all basically nodes that you just drop down and then you would use it like you would. And then the nice thing is that it's non-destructive because of the procedural nature.
So you can kind of go back up to the level, the top level, change the input and then everything would just kind of calculate itself and update it. So here I just have a simple sphere.
and then I have a cube that I can kind of boolean them together, move them around, and then at any point I can go into that chain and then change the inputs.
So this is a super, super basic tool, but you get the idea of if you're kind of familiar with what Substance is to Photoshop, Houdini is to any other kind of 3D software app.
So at least now you guys have some context of what I'm talking about.
The other thing too is, There's different types of proceduralism.
That's where some of the confusion comes from.
So there's like offline proceduralism, which is like the Substance and Houdini thing that like basically we're building things offline and then we're just baking static meshes that go into a game engine.
There's load time proceduralism, which is kind of like Minecraft.
That's like while the game is loading, things will get generated and then they'll get baked down into static content.
And then there's runtime proceduralism, which is kind of like the Vive and the Tilt Brush to where people are sweeping curves, and then as they're moving their hands, a proceduralist kind of taking that curve input and then doing things to it and placing a ribbon around it.
For this talk, I'm gonna focus mainly on the offline, because I feel that's the most relevant for kind of game development as a whole.
Sure, some people might be already kind of going into the runtime and the load time, but for like 90% of the population, I think that the trick is just.
how do you automate your pipelines and how do you make them a little bit faster.
So I'm hoping that out of this talk, you guys can get at least enough ammunition to where you can go back to your studio and be like, hey, this is something that we should at least think about and kind of further explore a little bit.
So why should you care?
Do you like crunch?
Have you ever crunched?
Have you ever lost work because someone came back and it was like, yeah, the art is final, but design had changed, we play tested and it played like crap.
So we have to go back and we have to change it.
And then you just have to eat that work and you just have to rebuild everything.
And then you have to cut stuff because you just couldn't have enough man cycles to build something because the idea was too big or there was just way too much work to be able to pull it off.
So the idea with proceduralism is that then you try to minimize all of those.
You're still gonna have crunch probably.
You're still gonna have a little bit of lost work.
But the idea is that if you have a kind of automated pipeline that you can change the input in the beginning and then kind of have things funnel way the way through, ideally you're minimizing all of these problems.
So the first misconception is that procedure content generation is this weird ball thing that indies do for rogue-likes with procedural dungeon generation.
Sure, that's also true, but that's not exclusively what procedural content generation is.
And then on the flip side, people say procedural content generation is this thing that you need a whole development team for, so like you have the snowdrop engine that you have like volumes that you can push and pull and buildings generate and then the whole cities get generated automatically.
So there's this, they're both true, but they're also both false.
So the scope is so big.
that don't get too hung up on the definition of it, just kind of figure out how can I apply this to me, don't look at too much at what other people are doing, just use it as inspiration, but try to kind of frame it in your own problems that you're trying to solve.
So the usual evolution that I see in kind of different studios, and it's kind of fun to see where the stages of development of kind of adopting proceduralism is, usually you start with one kind of champion.
that is like, I have a crazy idea, and I used to say that I have this crack smoking idea that is just like off the wall, and I'm gonna pitch this for this whole crazy system, and then they'll do it, and they'll pull it off.
And then now people start to notice, and they're like, holy, that actually worked.
And then you're gonna have a few people kind of gathering around them and being like, okay, how did you do that?
Can you build this something slightly different?
Can I use your tools to do it?
And then those people start using it, and that's gonna be like the badass team of the studio, and that's the hard problem team.
And they're basically like the wizards.
And then ideally, you'll be able to distill that out into a production at large.
And that's the really hard part, is basically kind of going from this kind of small team agile movement to a big engine deployment kind of level.
So I'm going to go through each of these stages and kind of help you through, at least know what you're going to run into and kind of how to muscle your way through or just understand what the problems are going to be.
So we'll start with proof of concept.
So this you're gonna see is a lot like just regular tool development.
So you just identify the problem, figure out how to make time to fix the problem, and then you fix the problem.
So how do you identify the problem?
Walk around.
And this is like if you guys are tech artists, you know, just walk around the tool, the studio, and figure, like, talk to people, and walk around.
And then the one thing that I would say is for proceduralism in particular, find out what's boring and repetitive.
Because I'm gonna talk a little bit about this, but some people are scared of proceduralism, and they think that, that's gonna displace their jobs.
But the idea here is you're taking things that no one wants to do, they're kind of just shoveling assets through pipelines, and then all the boring and repetitive things and all the little bottlenecks are the perfect candidates to be automated.
Because if something is so repetitive that basically the artist can just shut off their brain and then just do, oh, I just, yeah, I click this, then I click this, then I click this, and then I move this file to here, and then I bring this file over here, that should just be automated, and that's a perfect candidate for you to hit.
The other thing too is understand the art flow.
So people joke that I say that you have to basically talk to robots, or talk to artists, and then build robots that will replace them.
That's not true.
But the idea is that you do talk to artists, and then you figure out what the workflow is, and then you try to automate as much as possible while leaving control points.
And that's the key show part, is that you want to build an automated system, but you want to leave control where the artist wants control.
So you need to kind of expose the hooks to where any point in the pipeline, they can go in and they feel like they have control.
and then go through the process yourself.
And this is especially good for tech artists because we can actually do it.
So sometimes with like tools programmers, they'll just get a list of this is all the stuff that we want and then they'll just go checklist, checklist, checklist, checklist and just give you the tool and it's like, yeah, technically it does what I want it to do but you missed half the point.
I forgot to say that yeah, there's this other pain point.
So if you actually do the process yourself, you will see that, yeah, no, you guys don't even bother doing any of this, just like completely hot wire the whole thing and go from A to B way faster.
This is, it's fun because it is the same process as a tech artist too, so a little bit, yeah.
So the other misconception is that I'm training my replacement, and this is an actual conversation that I had with someone too, where I was like, okay, talk to a designer, how do you build procedural levels, and then the guy was like, listen, man.
I went to China one time and then I had to train a replacement team to basically, I came back and then I got laid off because basically I trained my outsourcers.
So I feel like I'm having the same conversation.
And this is not just in the games industry, just like everywhere you hear a lot about automation, we had conversations last night about it.
Just know that people are going to have that kind of built-in resentment and built-in resistance sometimes and you just kind of have to know how to word it.
And the way I like to word it is.
We don't want to take your job, we want to make you more productive.
That's why we build tools.
And then it's the same way, but there's a little bit of a mind shift that needs to happen with people.
With procedural system, they don't see them necessarily as tools, they see them as the next step of tools.
So there's a little bit of that.
And then there's this thing as the goldfish paradigm, which kind of ties into that, which is you will build as much content as you have time for.
So the goldfish will grow for as much size as the fish tank is.
So the fact that now we kind of displaced the time and we made production shorter, that just means you're going to build more content.
And then sure, maybe down the line, you're going to get someone greedy that's going to see it and be like, oh, I can make a game in six months.
That means I'm going to make 10 games a year with a bunch of teams.
That's technically, yeah, that could happen, but that's not what we're aiming for.
We're just aiming for, you still have the regular game cycle, but you're building more content, better games, more fulfilling experiences, and ideally you're changing the things in the beginning, so you're like, alleviating the crunch, and you're kind of making the ideas kind of stick a little bit better.
And that's really the true goal for it, but like any kind of tool, you can take it for good or you can take it for bad.
So the first example I want to talk about is basically the simplest kind of tool that I could come up with, which is making baseboards and crowd molding.
So the usual workflow is you would go and you Google baseboards, and then you find out the profile that you want, and then you're like, okay, cool, I like those, and then I want to try to build this for my game, and then you bring it in, and then you.
bring in the image and then you go with the trace tool and you go boom, boom, boom, and you start to kind of going and then nobody got time for that.
This is just a giant waste of time.
So the first change I would do is I would look at manufacturer specs.
So like a lot of these things that we're building is out in the real world.
So you can just go directly to the manufacturer and get the exact specs that you need.
and then you would do, instead of tracing things by hand, you would build a trace node that we have, and then you just build the line, and then you sweep it, and now you have the same kind of tool that would do the same workflow.
And because it's procedurally, instead of every time you need to make a change or every time you need to make a variation, you just have a system that you don't have to go and kind of fudge the points by hand again.
You just kind of feed it more things, and then the system would just kind of go and make things, which is a better way of working, in my opinion.
So now you have this kind of.
procedural straight line.
For this stuff, we want corners, right?
So we want the kind of concave and convex versions of it so we can make a modular set out of it.
And then again, the worst case scenario is someone would just put two of them together and then vert weld them hand by hand, and then they'll kind of fudge them and then kind of get it aligned.
Again, nobody got time for that.
So the way I like to do it is actually clip it.
So it's kind of like a real operation that's like you just mitered the thing.
So you just cut it at 45 and then 45 and then you shove them both together.
Some people, even on some of the comments, is you wanna sweep it along a curve.
The problem with that is that that's not generic enough.
So you could do it with just like a, instead of sweeping it along a straight line, you sweep it across a 90 degree angle.
But then if you have any kind of minute variations or if you wanna build a general system, which I'm gonna talk a little bit further down the line.
A mitering approach is a little bit better and more kind of general purpose.
So keep that in mind, towards like if you're building something, if you can extrapolate that to the next level of how this can be useful for another thing and not just for the one problem I'm trying to solve, that's helpful.
So now I have a full set.
So now I basically have a baseboard with a concave corner and a convex corner.
And then because it's non-destructive, I can just feed any input into it and then I just get the whole set.
So this is by far like, the argument that's like, oh, it doesn't take me too long to trace a curve, right?
It's just like, a couple of hours, I'll go in, and it's like, yeah, but you could do it in seconds.
And then the idea is like, the next step is instead of feeding one input, we just feed a sheet of inputs.
And now, any tool or any asset that you need to build, you just kind of run it through the pipeline, and you just have like infinite number of assets.
Basically, but it's still art directed, it's still controlled, it still fit what you want it to look like.
But all of the kind of boring, little repetitive work is just kind of gone.
So now you have a tool and then maybe you make this tool or maybe you make something else.
And then it's like people start to notice and the way it usually works is you'll make a tool and then you just use it yourself because it's so fast that you'll be like, you're the guy and then it's like, hey, do you need a baseboard?
You just ask me the baseboards, feed me the thing, I'll just run it through my system and then I'll spit it out for you and it takes no time.
But ideally you wanna kind of diffuse that out because then you become a bottleneck yourself and you kinda wanna displace that.
You wanna make the tools easy enough for other people to use.
then you're gonna start basically building tools for other people, but the problem with building tools for other people is that you have to convince the kind of task keepers and the producers that it is worth spending the time, and now it needs to be a little bit more robust, and you have to kind of encapsulate the problem a little bit.
You can't just have like this hacky tool that you just know where all the inputs are.
You kind of have to kind of extrapolate it up a level.
Again, much like regular tool development.
The one thing that I will say is, don't argue for time, just show it.
There will always be people saying that it can't be done.
There's always, always gonna be people that's saying they can do it faster by hand.
If you believe strongly on it, just do it.
So I had a great example.
I used to work in a previous company and we just had like head topologies and we had like 200 heads that we needed to change the topology on and there was a big argument whether or not that was worth doing.
And I was like, well, if we change to another head, then we're in line with other studios and they give us better tools.
But the argument was like, well, there's gonna be like, It's like 200 heads, it's gonna take you like two man weeks to kinda go and re-topologize all of them, and it's just like, it's not worth the time.
The real problem was like a political thing, so it was kinda being disguised, so one of the guys, Johnny, who's a Houdini wizard over at EA, basically he just went and was like, I just wrote a script overnight, and I just batched all the heads, and now the problem is gone.
And it's like, the next time we went to the meeting, they were like, okay, well, this is gonna take forever, and it's like, no, it's not just done.
And then the real problem like surfaced that it's like, oh, they don't want to change it.
It wasn't because of the tool or the time, it was because of some other reason.
But kind of being able to just do it by yourself and being like just take out the whole middle layer of argument and there's no time and it's worth doing.
And a little bit of the ask for forgiveness and not permission kind of applies here.
The other thing too is that.
Build a little prototype.
A lot of these tools can be built with very simple nodes, and you can do a proof of concept and then show it.
If you can't, look at examples of people doing it.
There's a lot of people doing proceduralism now.
So there's a lot of talks from EA.
They have a great stuff on SSX, how they built the whole mountain generation system.
There's a lot of stuff of Uncharted, how they're doing procedural destruction and using Houdini for that stuff.
And then there's, yeah, just go out and then see generally what you're trying to do.
And there's a lot of resources, either on GDC, at SIGGRAPH.
or on our website.
The other way to approach pitching tools is your buying time.
And this is kind of a weird mind thing because if you say, hey, I need, whatever, $5,000 to buy this piece of software, but that's gonna save you a lot of time, people don't see that as, like on a budgeting mindset, it's like people are free because I'm already paying for people.
So I don't wanna pay this much money that will give me.
theoretically, like x more people that are just production, like man time.
It's a weird kind of like non-logical argument that you have to have.
But just try to pitch it as time.
It's like you're not buying software for then you need more people to write the software.
You're just buying the software that can just automate the whole process.
Or you're building the software, not necessarily buying, but the time that you're using to build it.
The other thing, too, is like, get the buy-ins from the team.
So the worst thing you can do is come up with a cool idea about how the terrain system should be built, and then you go and you try to shove it down the terrain team's throat.
That's never going to work.
Sometimes you can muscle through it, and sometimes you get some people that are like, oh, yeah, I can see the light.
90% of the time, you need to kind of work with them throughout the whole process and kind of get buy-in from them as you're developing the tool so then they feel vested in it.
Otherwise, they're just like, even if the tool is good, and it's better, and it's faster.
just a logical argument of like, I didn't build it, I don't know who did this, it's not good enough because I didn't come up with it.
And those are, again, in the kind of argument land, it's subtle differences, but you're gonna run into it.
And I know tech artists, me personally, very logical, very just like, hey, just clearly this is more efficient, we should just use this.
And then people are like, you get kind of more emotional arguments with it.
The other thing to say is like, to show how fast people can do it.
I've showed some tools to some clients and they're like, This just shows me that we're working way too slow.
And then just looking at some of these tools, is like see people just like drawing curves and then the whole city's applied.
And it's like, Jesus Christ, we're placing parking meters by hand.
And we've did that in games.
It's like, why?
It's like, yeah, but I need control of where the parking meters are because of the way it's framed.
It's like, no, you don't.
Just please.
Just see how fast you can do it.
And then people are going to be like, well, placing a parking meter is just really fast.
I can do it super fast.
I can just click it, and then I'll drag, I'll drag, I'll drag, I'll drag.
And it's like, yeah, but if you want change and if the street moved, now you have either floating parking meters you have to go in, and every time someone changes it, you have to go and update it.
So there's a little bit of that.
Again, like, oh, it just takes me five minutes, but it shouldn't take you any time.
Those little five minutes is what bleeds production dry.
It's not like the big tools that take months.
The big tools that take months usually are the things that kind of solve production.
The little paper cuts is what kind of destroys you.
The second example that I'll go into is this pipe tool.
And this is basically like something that you want to hand off to an artist and you want to kind of extrapolate things out a little bit and then you just, now you have a tool that you just take a curve and then you get a pipe out of it and this is kind of just a traditional problem that you have.
The thing I have is you want to break down the problem a little bit.
So you want to take the curve.
You want to understand how that workflow is and how you would come up with the solution for it.
So the way I would come up with this is you take the curve input, and then you would separate the corners from the straights.
And then you would build the straights, and then you would build the corners, and then you assemble it together, and you have a pipe.
So fairly straightforward workflow.
So let's go that step by step.
So you start with the curve as an input.
As a nice bonus, another thing that people like to do is align curves to surfaces, which is a giant waste of time.
So basically what I like to do is you take the curves and then you take the first and last points and then you project it into the surface that you're gonna do it, get the surface normals out, and then you stitch that back into the curve.
So now the kind of connections are always gonna be perfect because that's the giant most waste of time thing that I've ever seen.
But it's one of those that's like, we don't know what's, like I just came up with this and it's like, we don't know what's out there and we don't know how to fix it, so we don't know what problems we have.
Then we wanna separate the straight from the corners.
This is very straightforward.
Basically you just take.
each line segment and then you kind of like carve them a little bit so you kind of spread them out a little bit and now you have basically the two kind of problem sets isolated and then you model a pipe.
So the way I model a pipe in that example is you take a cylinder and then you sweep a circle through a line and then you put two cylinders at the end of it and then I made some little BS screws that just look like something and then you merge the long kind of.
pipe part of it with the kind of end caps with it and then you do a little bit of a beveling at the end of it. So not fancy but really really basic modeling but it kind of from a far away it kind of looks and that's the other thing too that's like If you talk to an artist, they'll be like, oh no, I will bring this into ZBrush and manually do the welding and all this other thing.
It's like, yeah, but then there's this little tiny pipe on the corner of the ceiling that no one's gonna see.
Does it need that much attention?
Sometimes, yeah, and then that's the part that you kinda have to go through, is do you build something procedurally, or then you give that freedom back to the artist and be like, okay, fine, just build the pipes, give me the pipe pieces, and then I'll manually place those.
So those are the two approaches.
So then I'll just place those, just take each of those little side light segments that I did and then I would run it through the little pipe generator too, that just kind of extrudes the main cylinder and puts the two things at the end and then does the beveling.
And then the corner is actually the same tool, because you just have something that sweeps the circle along the curve and then you put two caps at the end of it, and then you add the little screws to it.
So now you're done, and you have a tool that is kind of fairly straightforward, fairly logical, anyone should be able to go in and do it.
but now you have this kind of cool system that is like just pipes are solved.
And now for your production of the rest of the game, it's like you can be the pipe guy, or ideally you hand this off to the artist where you just be like, okay, here's your pipe tool, just draw as many curves as your heart desires, and then you just run this through this tool, and then you have all the pipes you need.
So in the last stage, which is the hard stage, is now you kind of have, maybe you did this pipe tool, and maybe like five environment artists use it, and that's all you need, you don't have that many pipes in your game.
But now you're trying to build these kind of like larger systems like a building generator or like a room generator.
How do you get into that? So the way I like to think of it is basically you have this in connected subsystems And I used to have a friend that any problem that you ask him he'd be like, you know, man The spaceship is a complex problem. There's a lot of moving parts. It's not like you you can't just it's it's it's it's complicated But kind of try to feed What that critical path is and know what?
You're starting over here, you need to get over there, build little milestones of failure points that you can abort, but then kind of know what's the minimum viable product that you need to build, like any other tool, but it applies very much so to proceduralism.
The idea here too is that if you kind of know what the whole pipeline, you can just selectively replace pieces of the pipeline with proceduralism, and then leave the kind of things that are a little bit more close to people's heart, or things that people want to do.
And then you still keep the eye on the prize.
So you might be like, yeah, I built you a pipe tool, but that pipe tool is gonna tie with the cable tool, which is gonna tie to the room tool, which is gonna tie to the city tool.
So you kind of start with little pieces, but kind of keep an eye on the prize and kind of know where you're gonna go.
The other approach for this is that there is no plan B.
And we either do it or we fail.
And that's a bold move, but it works sometimes.
So Caleb Howard from EA was like, when we did SSX, we needed to do 300 tracks.
We either did 300 tracks or we failed.
We couldn't do this by hand.
The problem was so big that if proceduralism didn't work, we would just not ship the game.
And that's the opposition.
And then that puts a little bit of, what I like to say, the panic threshold, which producers will start to, because procedural systems aren't like regular art that's just like, every week I make five widgets, and then I can see five widgets being built every week.
And then if a week, five widgets weren't built, I know that I dipped a little bit.
Proceduralism is like, okay, I don't have anything, and then I have a thousand widgets.
and then that panic kind of goes away.
But then it didn't work, and then the widgets need to change somehow, and then the panic starts to creep back up, and then finally the widgets work, and then the panic kind of goes away, and then the thing system is stable, and people kind of, but know that, and it's uncomfortable to kind of be in those meetings, because people are like, hey, what's happening with this thing?
It's like, it's coming, it's really close, and it's like, how close?
It's like, I don't know.
It's like, It's like I'll keep building it and then I'll keep hitting another wall and then I'll go through that wall and then I'll go to the next wall and at one point there's no more walls and it works but until that point happens I can't tell you and then people get really nervous and they're like well let's start with plan B and let's start getting some people actually building the widgets by hand but kind of try to stick with it and kind of try to kind of show them that it's normal to kind of panic and it's normal to kind of not trust the new system but know that other people are doing it and that it's a proven thing at this point.
It's not like this weird oddball new workflow.
The other misconception is that once it starts working, people are like, proceduralism everything.
We don't need artists.
Let's make a game with five guys and let's just like, it's like software development like anything.
So there's gonna be bugs on the design.
There's gonna be things like ambiguity that an artist said that they needed something and that they don't have it.
Or then you're gonna build this beautiful building tool and then someone gives you just bad modular sets that completely break everything.
and then it doesn't work.
So there's no such thing as an off the shelf solution yet, and that's the part that we kind of need to build as a community, and kind of start getting kind of more standards and kind of building it to where we get to the point that's like, everyone wants to build their own procedural system because there isn't the one building generator that's like, just works for everybody.
So everybody has their own thing.
It's like, oh, I want to do a Parisian building, so my buildings are completely different.
I want to do an Old West building, so it's completely different.
Until someone comes up with the PBR of buildings.
that is like, you just can't mess this up.
You just give it a curve, and then you select which style you want, and then you get better curves than anything.
And that's I think where Substance did really well, to where it's just like, you just have a library of really good materials.
Yeah, you wanna make gold, go make gold, but the gold that they gave you is pretty good.
So then people start to kinda go down that kinda pedestal of like, my gold is better than, and it's like, yeah, do you really wanna spend?
30 hours building a procedural wood, sure, go and spend and do that, but like 90% of the time you can just find something that is already done at a quality that you like and then kind of move on.
So for my final example, I have this modular set, which is, as you can see, is very similar to something that I showed earlier today.
But it's kind of like the extrapolation.
So the problem that I have in this one is I have something that is X size and I need to fit it in something that is Y size.
And then the way I usually start with it is like, okay, I'll just place it there, and then I'll place another one, and then the way we do it by hand is like, okay, I have a wall segment, I'll put wall segment, wall segment, and then I'll put some weird oddball little corner shape that didn't fit because people didn't really apply to the grid, or it didn't just kind of fell off, and now I have this one custom piece that it's like a weird corner, and ideally what I would like to do is I would like the procedural system to calculate how many things can I fit there and then distribute the weight of that scaling slightly by all the pieces.
So then you get a little bit like a 5% squish on each asset, but it's not noticeable and you don't have all these weird little custom end caps that you have to figure out how to do it.
So again, the math of this, this is the only math of the whole talk.
It's fairly straightforward.
So if you have something that is two wide and you have something that is one wide, you put, you figure out what the size needs to be so you need to multiply it by two.
So that's just like a basic kind of ratio what you have to multiply.
And then if you do it one by one, it starts to get easy, but then the real problem is when you have something that is like 367.58 divided by eight.
And it's like, okay, then I just want a system that deals with that and I don't wanna worry about that.
So if you have something that's five, you divide five by two and you kind of figure out how to do it.
And then the other problem they have to do is the number of segments.
So how many of these, because I don't want to just get one really long segment, I want to figure out how many of these segments can I fit in this wall size.
And then I want to kind of subdivide it.
So you just divide it by two and you kind of round it so you get an integer.
And then you figure out the individual size of those.
So you kind of have the individual piece.
It's going to be a scale of like a small scale of what the original one was.
So you kind of get the full, whatchamacallit, like how do you call it?
Just the whole math.
And it.
I know you guys will look over it and kind of look it over, but it's really simple math.
You have the wall piece, you figure out how many widgets you want to put in it, and then you figure out what is the delta of the full size versus the widget size that I got divided, and then that's just how much you need to scale things by.
But once you have that, now you have a system that you can do this.
And then it's just like, oh crap, that's magic.
But it's like three little equations.
It's really like now you have a tool that just places things along a wall panel and you don't have to deal with it and then things will stretch up to a threshold and then they'll kind of move to the next stretch but on the opposite way and then they'll kind of start growing and then if you put that with a real asset, you get something that looks like that and as you can see, it's like, yeah, you get a little bit of a stretching and you can see it really bad when it's moving but when you kind of freeze it, it's kind of imperceptible.
So now you have this thing that you can squish.
But I also have a way to kind of miter things, right?
So then I have ways to kind of make things squish this way, but then I can also figure out how to put corner pieces.
So what this means is that I can have a room generator.
So I can just make a thing that just takes a box as an input, and then I can make rooms with it with really basic math, and it just works.
And you can see how this starts to extrapolate.
So we started with the baseboard that everybody was like, what the hell is this baseboard for?
But now we get to the point that you could see how it extrapolated this to a building.
to where now this is the first floor, instead of kind of having things facing inside, I'll face them outside, same kind of technique, and then you just build things up, and then you do the same thing when you're building things up, to where it's like you divide things equally, and you kind of put the first floor and the last floor, and kind of squish the middle parts.
But getting to this stage to where it's like, now you have tools, and that's how people work, that's a hard kind of mind thing.
People need to drink the Kool-Aid, and they have to be like, yeah, I'm in, I get it, that's how I want to work, I don't want to place things by hand ever again.
So there's the cost involved in kind of getting to that.
There's a lot of ego of people being like, I'm really fast and unreal, and then there's a bunch of tools and I can just blue, blue, blue.
And it's like, yeah, I'm sure you could, but getting to that stage is really important.
You're gonna get pushback, and the best way is kind of like, use these talks, use other talks that people are doing with proceduralism, and kind of help drive that home, and kind of show the light a little bit, as it were.
So the other thing too is that.
I like to think about it as a vertical monopoly to where if you have one driverless car in the road, that's great because you have something that's automated and it's driving by yourself.
But the moment that you have a person driving the car, now the automated system needs to figure out how to drive around the bad driver and there's all these other kind of problems associated with it.
So the real system is like when all of the driverless, when the whole pipeline is automated, what does that open up?
So it's like when you have the whole thing that you can make a room, you can make a building, you can make a city.
you can place anything, what does that open up?
Like now you can have massive worlds, or you can have small worlds and lots of them.
So getting to that stage that like the whole pipeline is automated is kind of like the golden grail.
A few studios are getting really close to it, but you're gonna start to see that kind of paradigm shift of just like, now games are massive, and there's just a lot of content, and they're all AAA.
And then a lot of people won't know that they're being used procedurally, which is the nice part.
So it doesn't have that kind of stank on it that is like, oh, it was just fractals and random seeds.
So that's, that's, there's.
A little bit of that.
So just overall, the pros and cons of going procedural.
So it's non-destructive, so you can change your mind, because that never happens in production.
You have a whole pipeline that is as much automated as possible.
And the really nice thing is that you can have a process that is parallel.
So now you don't have this waterfall pipeline anymore.
You can have the character starting, and you can already start rigging and animating, and know that once the character's done.
the system will just pick it up and transfer weights and everything is done.
So now you don't have this like, oh, lighting gets screwed always because they're just at the end of the pipeline and then they're just going to eat the little crunch at the end of it.
It's like, no, they can start lighting in the beginning because everything is already in place.
And we're just kind of building the shelf for it.
But as things kind of res in, everything kind of comes together.
The cons for it is that there is a long arrangement.
There is an investment up front that you kind of have to go through it.
there's this perceived loss of control, which is perceived in the beginning.
And there's a lot of people that are like, yeah, I don't have the control, but then really it's like, well, did I really need the control of like manually placing the screws on the wall?
No, like if I just draw a spline on it, that's enough control for me.
And then it's new and different, and that means it's scary.
And that's something that you kind of have to be cognizant of as you're kind of pitching things through that just on that emotional level, people are like, I've been doing games for 20 years.
And that's how I've done it.
And we've always done it this way.
You're coming in and you're telling me that there's a completely different way of working.
I don't like that.
I wanna, like, there's job security in me knowing the pipeline and me knowing how it's done.
If you come in and displace that, that's scary.
So it's something that you kinda have to be aware of and just work with them.
And it's as much of an emotional coaching as it is just like a production building.
So then, as you kinda like, if you hitch that level of, okay, now we have a procedural system and we can build anything that we want, it's just iterating.
And basically, each of those modules can be better.
You can build a better poly reducer.
You can build a better quad remesher.
You can build a better transfer of weights.
You can build a better UV.
So you can kind of start driving that.
And then you can also start tying AI-driven systems to it, which I have a talk in 10 minutes over there, which is basically, now you have this black box that takes input, but now we have this other thing that can make inputs to drive this black box.
And then now you start to get a really cool, interesting approach that you have.
The artists are kind of curating the content more than manually generating them, which is a little bit different, but it's kind of democratizes it a little bit.
So it's a little bit of, if I can just draw a paper map and make a level out of it, now QA can build maps.
Like you don't need to be a master world builder and Unreal wizard to be able to make a map.
Anyone can make a map, even if it's just a white box.
And that gets us really closer to where we need to be, which is.
3D is too expensive to make right now.
There's all sorts of fields that are trying to get into 3D with photogrammetry and historical preservation and archeology and all these other things that are trying to get it, but it's just too damn expensive because it just takes too long.
So getting it to where building content is cheaper, you're not gonna be running out of jobs.
There's plenty of 3D work to go around.
It's just a matter of distributing it from being in the games industry to going out wide, which I think is the next evolution for our crew.
So that's the rest of it.
Come say hi tomorrow, we have a Houdini training day.
So I'm gonna be talking from noon to one, and it's gonna be over at the Marriott, and then we're gonna have booth talks.
I have two talks every day, and then you can just come by.
I have another talk right after this, so I don't think I can hang around too much for questions, but I will.
But then if you can't grab me, grab me over there.
And that's all I got.
And how long do I have, 10 minutes?
Oh, 20. 20?
Okay, so we have...
Okay.
Thanks.
So we have two options.
Choose your own adventure.
We can do QA and we can just chat and kind of talk over whatever questions you guys have, or I have more content that I can just ramble for another 20 minutes.
Show of hands, who wants questions?
Who has questions?
Okay.
Then I will go on to Bono's round.
And then just lightning round more shit.
Okay, Bono's round.
So these are the things that didn't make it to the talk.
And then now I just get to talk because the talk is over.
So another example that I wanted to talk about was Dirt Skirts.
This didn't really fit my perfect paradigm of you have a perfect little thing, and then you move on, and it's a sequence of examples.
But it's just another thing that people do.
We lost months of work doing this in a previous title.
And then the idea here is you have a piece of geometry that's colliding with another piece of geometry and you want to make a little trim because that line is really ugly.
So the two inputs to the system are gonna be, have a piece of terrain or a piece of flat geometry and then you're gonna have a rock that is a piece of, just another piece of geometry.
So the way we do it is we Boolean them together.
And then that basically, with the new system, you get a curve that is the Boolean, that is basically where the two things meet.
So now you have a piece of geometry that is kind of like.
unified the rock with the terrain, and then you can have a curve that is where the two of them meet.
Then you just sweep some geometry along that seam.
We convert that to a volume, so now we kind of have like a little donut that is like the kind of skirt for it.
And then we do an intersect with that union that we had originally.
So now we kind of have just the skirt part of the kind of two parts of it.
Then we offset that by the normal, and that just kind of makes it so Z-fighting doesn't hate us.
and then we add some vert alpha at the edges of it to kind of fade it a little bit.
And then we add UVs procedurally by just doing some like planar mapping because it doesn't really matter because you're gonna put some noisy texture here anyways.
And then you apply the material.
So that's kind of the secret of building dirt skirts.
And now you just have a system that it's like, oh now you just have geometry and then things and then just make dirt skirts for the whole map.
So we started to do that previously.
We didn't have this Boolean tool, so it kind of didn't work as well, but now with 16 we have a lot of new stuff that makes this super easy.
And then the other thing, which is my main talks in a lot of things, is basically this crazy stuff that I'm doing called vertex animation textures.
Who has seen any of this stuff online?
All right, sweet.
So this is in 16.
Houdini 16, and it's basically a way of getting geometry caching, and Ben is gonna talk a little bit about that too, in his talk, so I'm really happy to, kind of like, as talks are happening at GDC, you already have a DCC app that can do this stuff.
So it's a way of getting geometry caches into a game engine using textures.
So the way that works is, and we had another skip button in case we ran out of time, but there's four different ways of doing this caching, so there's the, we call soft, which is the same topology all the way through the pipeline.
So it's like cloth and soft body dynamics and that kind of stuff.
Rigid, which is moving chunks.
So basically you have rigid body destruction.
Fluids, which is like a changing topology and then sprite for camera facing cards.
So I'm gonna go a little bit into those.
So the soft, basically you can get this stuff.
So you can get cloth simulations, you can get oceans, you can get soft bodies, and you can actually get skin meshes, which is really cool.
So the Uncharted guys gave a little peek on this and they're probably gonna have another talk this week on how they did the chickens in Uncharted 4 by basically.
using this kind of technique and tying it with their particle system because in the particle system, you can just spit out static meshes, but then if you can have a shader that has animation on it, now you have static meshes with animation just running around the world and you can just spit out hundreds of these and they're fairly fast.
So what the hell is happening underneath the hood?
So the way we stored the data is we have these, the textures, which is actually a really good format because you have.
every pixel has a red, green, and blue component, which means we can put a X, Y, and Z position in it.
And then we just basically store that, and it's uncompressed.
And then we make the UVs basically be lined up horizontally on the mesh.
So you have a second UV set that just kind of like gets stripped out horizontally, and then on the texture side, you basically just put every pixel is a point.
and then every frame is a row.
So then the shader actually needs to be super simple, which is just you take that second UV set and then you just scroll down.
And then it kind of does a piano roll thing where it just kind of keeps setting the world positions and the normals every frame, which works really well.
So this is the Unreal shader, which is not super complicated.
So the kind of interesting part is in the bottom to where, and this is online, I have it on my Twitter.
But basically, the hard part is just calculating the UVs and kind of scrolling it down, but that's really it.
And then you just sample the two textures on the vertex shader, and then you just set the position and the world position offset, and then you set the normals.
And you have to do some shenanigans in Unreal in specific, because you have to pass it through the custom UV channel so it gets calculated in the vertex shader, and then you pick it up from the vertex shader and pass it to the pixel shader.
So what else can we do with this?
So we can do destruction.
And instead of storing positions and normals, we can store positions and rotation.
in your two textures.
So now you have this kind of same, they have two exactly the same simulations, just exported different ways.
So one way is using the texture animation, the other way is using joints.
So the same kind of system, the way the artists work is the same, and then they just output the data the way they need to output it.
But the cool thing is if you were gonna try to do something with like 3,000 joints, that would cripple most of your consoles.
But with this thing, we can kind of get it, and it's super fast, and it just works.
And the texture's not that huge, because you just have 3,000 by 100 texture.
And then you can kind of fudge it a little bit, so you can basically get like a 1K by 1K texture.
So for this, we basically store the position in the quaternion on the texture, and then we store the pivot of each chunk in the vertex color.
all of the chunks, verts, have the same UV.
So basically, because they have the same UVs, they sample the same position and rotation, so they kind of move as a single unit.
And then they basically have to do just the movement of the position and then the rotation.
But because you have the pivot, you know how to rotate it from there, and it just works.
And then, let's see.
So then the next one is the sexy one, which I really like, because there's really no way of doing this.
besides going into Alembic, but then Alembic has its own problems of basically recalculating the geometry of your frame.
Ben is gonna talk Friday, a better way of doing this, so I always like to say, this is the artist's solution to the problem.
Ideally, you get a proper graphics engineer that can hotwire the data into your graphics card, but in our cases, that we're just bootstrapping things together, it's like, yeah, we'll just write it to textures and read it, because it works.
And then people end up, the graphics program's like, no, textures are horrible, why are you doing that?
But it's like, hey man, it works.
And you kinda move on with it.
So then you can get things like this kind of stuff, which I really like.
You can change the topology and it just, it opens up a lot of really cool effects.
And what we're doing here is the same thing as we did before, it's where we're storing the position and the normals of every point, and you have the option of an additional color texture if you wanna get the color from the simulation.
But then you store a cloud of triangles, which is basically the maximum amount of triangles you could get in your whole sequence.
And then every frame you just set the position in the normals of the quads.
And then if there's no position in normals, they'll get collapsed down to zero.
So every frame, the mesh gets reassembled.
And because it's already there and you're not really creating geometry every frame, it's actually really fast.
And it's fairly cheap.
So like for this particle effect, I have something that is 5,000 tries and 99 frames.
So you can see, I need to have uncompressed textures because if I try to do block compression on this, just the whole data will get munched.
But we can kind of keep it uncompressed and it's still like six megs for the whole particle.
I have some stuff to basically collapse the normal into the alpha of the diffuse, or the position, so then you only need one texture at six megs and then the mesh is tiny, it's like 600K.
So compared to, if you're trying to try to do this in Alembic and have like a 50 meg cache or something more massive.
Yeah, this is fairly efficient.
I haven't run numbers on it yet because it's too kind of bleeding, too new.
I just finished getting the bugs worked out Saturday.
That's why it's not on the main talk.
And then the last one is basically sprites.
And then this is if you want to kind of get GPU particles, but you can actually sim it and get it art directed and kind of get it doing exactly what I want it to do.
And then you kind of bring it into the game and kind of have the same look.
So what we do here is similar to the other one.
to where instead of storing this triangle cloud, we just store a quad cloud, and then we basically move the positions of each of those to where they need to be, and then we just make the shader be camera-facing.
So it's very, all the techniques kind of build on top of each other.
And then, yeah, so this is the kind of whole shebang of the things, like the sprite is not on this one, but you can see how, and this is me making bad art, because I'm like a lazy artist.
I went to art school, but I became a tech artist because I'm lazy, and I don't like spending time making art.
But if you get a real proper, and you can swing by the booth, and we have better examples of Magnus doing some amazing lava, you guys might have seen online.
If you give this to a proper artist that knows what they're doing with, you're gonna get some amazing stuff.
And that's really the end of it.
All right, so now I'll take questions, and then we can go over the next thing.
Thank you again.
Second.
Questions?
Hey.
So great talk.
Just I feel much less alone right now.
OK.
This is absolutely everything, I think, since many years.
So it's really cool to see all these people listening to this.
the sometimes when you take artists in a company you feel a bit alone with all the things that nobody believes it's magic and okay it's not possible so it's very interesting and I feel something is missing a bit to this talk maybe many things because it's short but it's Most of the time we try to solve problems, we try to automate things, so there is some kind of defined problem and we try to find a solution, but also sometimes we find something new.
Yeah.
We answer a question nobody asks.
And that's very interesting too because it's not always trying to fix a productivity problem.
Sometimes it's also art.
And it's another way to do art.
It's just using anything, code, scripts, software, anything to do art.
And what do you think about this?
I think it's awesome.
I think that's where it gets into really interesting land because...
you move from TechCardist being this kind of firefighting unit to being the people making the content and being the people that, they were the only people that could pull this off.
So when I was in production, I was that, like I was the river guy and I was the kind of hard problem guy.
So, and it's still in the problem space, but like if we can get to the point that TechCard is just driving that and they'll be like, hey, there's this crazy new game that is possible only because of this new system that I came up with, that is, that's absolutely.
Like I come from a, a broken down production jaded environment.
So I'm just looking at the next problem.
But yeah, seeing it as a, there's just a wide open field and now a tech artist is kind of driving it.
And I went into another thing.
Okay, yeah, absolutely.
No, that's where I want to get to.
To where tech artists are the ones making the content and then we're the ones kind of pushing it forward.
Very, very good point.
Thanks.
Yeah.
All right, everybody.
Thank you so much.
And then come talk to me afterwards there in the booth.
And Bennett is up next.
