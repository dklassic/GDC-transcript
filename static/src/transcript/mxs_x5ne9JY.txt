testing. Right on. Cool. So yeah, welcome to my presentation. My name is Matt Dole. I'm a tech art director on Frostbite at Electronic Arts. And the presentation here is called Implementing a Scripting Solution for Your Editor. All right. So that we know what we're talking about when we talk about scripting. We're talking about these types of scripting and these customizable tools. So.
To get a feeling for the audience here, who here has not written any scripting or code whatsoever?
Show of hands, who's not written any scripting or code whatsoever?
So, that's really cool.
I've given presentations where there's a lot of artists or designers or people that are new to this, but...
being exposed to it, realize that it's not limited only to tech artists and engineers, it's something that a much broader audience can actually utilize.
So if you're familiar with Maya, obviously they've got Maya embedded language, mouse scripting, they also have Python.
We have the, I guess, previous Softimage had Python and many other scripting languages.
3D Studio Max has MaxScript, Photoshop has JavaScript.
And then when I'm talking about Unity, I'm talking about the Unity editor specifically, and being able to customize that.
So all of this should kind of start to paint a picture of where we're going with this presentation, is about the editor that you use to create content, and the scripting functionality that you can use in those editors, for both automation and customizing that.
So let's look at...
What we did with Frostbite and creating something called FBScript, obviously FB could most likely stand for Frostbite, the idea that scripting empowers game developers is something I obviously believe in, and it does this by providing a framework for customizing the existing solution to meet any needs that might emerge during production.
You don't always know what you're getting into at the start, right?
But obviously that isn't in a vacuum, it isn't in a bubble.
It has to be built on a foundation of something that exists before that.
So we're familiar with the adage that success starts with standing on the shoulders of giants, and that's no different here.
So there's a few really cool technologies that this is built on.
Avalon Edit, which I'll go into a little bit of detail on as well as Iron Python, all stacks on top of this Frostbite platform.
A key thing to point out here though.
is that this is all going down into the domain of .NET applications.
And so, I know that's a very common domain, but it is an important thing to point out that it's a lot of the details that I'll be going over do have that requirement.
And then the largest requirement, the most important thing about all of this, isn't really just about creating some script editor where you can write some lines of text and have it execute and do something.
The really key thing is how this is actually used in production.
The game teams that use this effectively, and not only using it effectively, but then sharing it across a community.
So that is also very key.
So as I go through a lot of the implementation details, it will keep a lot of this in mind.
So we'll look at not only building up a scripting editor, that scripting API, the language, all of that kind of stuff.
the technology that it interfaces, but then as well as how it actually gets used in production and how to facilitate all of that.
Cool, so for those of you that don't know what Frostbite is, it's not the easiest Google search.
Execute with caution, avoid images.
The shattered hand should give you some kind of indication of what you might be in for.
In terms of the name of our technology, this stuff originates from Sweden, which is, I know, half a year in darkness and cold, so...
Comes from an inspired place, but in terms of creating games, the vision of all of this is empowering the game creators to create the future of gaming. So that's something that we're striving towards.
Although we never feel like we're there, where we've achieved the very best technology or the very best editors, that's always what we're aiming towards.
And if you look at the game teams that are using this technology in shipping games, I believe it's being used to great success.
So if we look at how scripting has been used in all of these different editors, we've got Battlefield here, which is a first-person shooter.
We've got racing, sports, stylized games such as Garden Warfare and Dragon Age Inquisition.
And here's just a little video.
to give a flavor of that diversity.
So Frostbite was originally created for Battlefield.
And then the next game that used Frostbite outside of Battlefield, outside of Dice, was Need for Speed.
And we're seeing it also being used in sports titles now.
And this game was really fun to work on and to play, and it just kind of breaks the mold in terms of what to expect from the typical fare of Griddy and Rail.
And then we've got, at least on many charts out there, Game of the Year, not all of them, but it's still a proud accomplishment there to be in that league there.
Cool, so this is how scripting was used in these.
different games here. We've got Battlefield using it for data inspection and optimizations.
We've got Need for Speed using it for a number of things, but Out of the Gates, it was used heavily for stress testing the editor limitations, and we'll look at what that actually means in just a moment. Sports have been using it for batch asset conversion and a whole bunch of other things. On Garden Warfare, which I'll look at later in a bit more detail, it was used...
to automate the setup of thousands of different assets earlier on in production, with enough time to actually test gameplay ramifications.
And then, as well on Dragon Age, an absolutely monstrous game, the largest game I've ever seen in production, and of very high quality, too.
So, to actually dig through all of that data that gets generated by so many people actually contributing to create that, definitely we leveraged scripting to do a lot of testing and optimizations on that project.
So as I mentioned, Frostbite was originally used to create the original Battlefield franchise games and then subsequent versions of Battlefield later.
That team was DICE and DICE created Battlefield and also created these tools and technology called Frostbite.
They had a solution that worked really well for them, and if they needed to extend it or add functionality or anything, they were very well-versed in that environment.
The editor that was being used inside of Frostbyte is called Frosted.
I guess if you say it fast, it sounds frosted.
The key distinction here, though, is that...
When you have a team like this, I mean, you're gonna find scripting's gonna be useful anyways, but they didn't find as much of a need out of the gates because they're still building the technology, and every time they bumped into something that they couldn't do, they could add it.
But as soon as you start looking at having more than one game, and especially more than one type of game, it is really key to be able to have as much flexibility there as possible.
without needing to go through that whole process of not only designing, implementing, getting first functional testing, and then iterating on that really slow loop can be quite challenging, and especially worth noting.
I was one of the members on that Need for Speed, the run team, which was located in Vancouver, Canada.
And the Frostbite team is located in Stockholm, Sweden, so when their work day would end, just as they're leaving work, we're arriving to work.
And so there wasn't a lot of crossover there, and it was really tricky then to kind of wrangle that communication.
We could send an email, but then we would expect maybe a result, if we're lucky, some crossover, but mostly the next day.
And so when you have a new team that's using this kind of technology with that kind of a communication gap, there's a lot of challenges that present themselves.
Not only are the engineers on your team trying to learn the stuff so that they can later support you, but that support isn't immediately there.
So it should seem fairly apparent looking at these two screenshots, that racing games can be very different both visually, but especially in the experience compared to a first-person shooter.
So when we're setting out to actually create this game, there's a lot of unknowns.
And this all is leading in towards adding a scripting solution in an editor to accomplish a lot of this stuff.
But we'll see how we get there in just a second.
the Need for Speed the Run game. This goes back a while. We'll look at some more recent games soon here. But this was the starting point and it was a really cool and ambitious project.
The experience that we were trying to build was a race from San Francisco to New York.
And what we ended up building was 5,000 square kilometers of terrain, extracted from USGS satellite data, handcrafted with extra erosion details and all of that kind of funness.
And then thousands, hundreds of thousands of assets placed and creating this sense of speed as we raced through that world at a hundred meters a second, which is, you know, 260 miles an hour in some cars.
gives an idea of what we're trying to achieve, and then how do we apply technology towards achieving that?
Well, we had experience creating racing games, but not creating racing games on this new platform.
And so when we started to create Need for Speed the Run, we had previous games and lots of data that we could look at that we were really familiar with.
And in this case, we had over 80,000 different assets placed in the world of Need for Speed Undercover.
So the idea was that we would bring that stuff over into this Frostbite ecosystem, bring it into the editor, you know, turn slide sliders, turn knobs, get a feeling for cause and effect on a data set that we were familiar with.
But it wasn't as simple as that because the automation systems and everything for dealing and porting an old set of data wasn't readily available.
So that's something that we actually had to build up.
So what we ended up with was an experience that was much larger than any previous game that we had created.
And we had over 20 levels with each one of those containing roughly 40,000 different placements in it.
So that added up easily 10 times as many as our previous game.
How we originally got a lot of this stuff through the pipeline was creating C-sharp plugins, was extending the initial functionality of the editor, was making all of these kinds of improvements.
In order to accomplish that, it did take weeks to get that first functional look at it.
Even after we had all of that data through and we're looking at, you know, it's quite a volume of data just from the previous game.
no one person is going to look through all of those different assets and try and start tweaking and tuning it because even once we had a bunch of this stuff in an editor, there's a whole lot of stuff that became apparent.
It's like, well, how does this stuff get bundled?
How do you put it on disk?
How do you stream it off of disk?
How do we do all of these kinds of optimizations for texture compression, level of details of how this stuff will render efficiently or the most efficiently?
So all of that stuff takes tuning and a bit of experimentation and iteration.
And to iterate over that much data is just simply gonna take a lot of time if you're gonna try and achieve that by hand.
But with scripting, you can apply a rule set and then apply that across a broad set of data.
I think we get the high level concept there.
But without that scripting functionality, that wasn't readily available.
So we set out to create this.
So what is the Frostbite Editor scripting?
What is that?
So we had scripting solutions to port a lot of data over from 3D Studio Max to Maya and we could use all of these different scripting languages to do that.
We could do data conversion inside of Photoshop and we had scripting languages to do that.
We didn't currently have a scripting language inside of Frostbite, so when we implemented, this is what it all turned into.
And we'll look at actually how to implement this in just a moment.
But this was the solution that we came up with.
It was Iron Python plus a thin layer.
that thin layer, I'd describe it as a thin layer instead of an API, and an IDE. And that's what we call FBScript. Let's give this slide a second to load up here. So, you can see the video playing there. I'm just going to cue off the slide in the background there.
So it was an epic experience that we ended up crafting.
It turned out well, especially from a visual point of view.
The worlds looked amazing.
We could travel through all of this awesome terrain between San Francisco to New York, and we could have it as close to real as possible.
And in getting there, we built up a lot of scripts to help.
not only in the initial data conversion of the previous game, but as well as working across many different domains, from the worlds, the lighting, the audio, all of that kind of stuff.
And the key things there that we utilize is what you'd use scripting for anything.
Just to query the hidden information about data, it's not always exposed to you in a UI.
To automate the technical and repetitive tasks, gets things done faster and it's less error-prone.
and you can quickly create tools and extend functionality.
And there's all sorts of caveats there in terms of just how much you want to do in scripting versus something like C sharp or creating an application.
But I can get into a bit more of that later.
So let's look at implementation details.
So IronPython's first up.
This is the layer that's built on top of FrostEd.
Again, it is a .NET application.
And I should say that Originally, when I was first looking at that application, I was considering, okay, well, I need an ability to go in there and automate stuff, because that's just what I'm familiar with.
I don't know of an environment or a production that I haven't been able to do that.
I originally wanted C Sharp.
That's something that was really familiar to me.
I had experience using, just on the side, not specifically at EA, but just looking at the functionality and things like Unity 3D.
and they have really nice scripting functionality in there with C sharp, and not only on the runtime, but in the editor as well.
And so, you get a lot of stuff for that.
You get an IDE, you could be using MonoDevelop, you could be using Visual Studio.
You don't have to create a script editor.
In that environment, you can have access to all of those different assemblies that you would in your project.
So if you wanted to have, if you wanted to implement something, that framework is really apparent right away.
But there are limitations there.
And those limitations are things that I wasn't actually fully aware of at the time.
Python, especially Iron Python, was a very new technology at the time.
This goes back to maybe 2007.
No, that's too far back.
2008 or 2009, I think.
Anyways, the cool thing, Iron Python can actually do absolutely everything that C Sharp can do.
It has full access to everything in C Sharp.
and it can do more, which is, okay, cool.
What we're doing is actually starting with C Sharp and adding additional functionality.
And that additional functionality is a dynamic environment.
And this is a bit tricky to wrap a head around.
If you're an engineer and you're jumping into Visual Studio, you have an idea about the structure and the framework and an algorithm of sorts of what you're gonna be building up.
And then you'll build it, compile it, and then test a lot of assumptions.
Whereas in a dynamic environment, specifically what we'll be looking at, It's very highly iterative.
We use a terminology called REPL, or R-E-P-L, so read, eval, print loop.
And sometimes you'll execute it ad hoc.
You'll have, write a couple lines and then execute those couple lines, no compiling required, and then test your assumptions and proceed.
So this is the solution that we created.
We'll look at it in action.
But what does this actually look like to implement it?
Like is it really heavy?
Like how do you apply this to an application?
Consider you have an application that's written in .NET and you want to add this to it.
Is it going to be a big challenge?
And the answer to that is no.
That might seem like a little bit of a daunting wall of text but that's actually everything that's required to add Iron Python to an application.
And well, you might very well be able to find this kind of information online somewhere.
What we'll be doing is taking it a step further and looking at how to connect not only IronPython into a .NET application, but then connect that with an editor and with a production solution here.
But before we proceed beyond all of this, and this slide right here can get a little bit much to look at, it's a bit hand-wavy.
It's like, okay, yeah, sure, you can write some code and get a result, but let's see it in action.
So that's what you see as a screenshot.
But let's actually see this video here play out.
I think this is worth taking four minutes, although it's a bit of a fast ride here.
What we're gonna see is from the download the Iron Python DLLs to setting up a .NET application and applying Iron Python in four minutes.
You know, it's sped up a little bit in some spots just to speed up the download speed and whatnot.
But I think from a high level you'll quickly appreciate that.
In order to get something like this stood up, it doesn't cost a lot.
So there we go, we've created a new WinForms project.
I know it's a little bit old compared to WPF, but just for simplicity's sake, we can see we can block stuff in really quickly here.
So we've added a list box, a text box, a button.
We've named the button execute.
We double click on it and we get that functionality in there for...
what happens when you click that button.
And we'll add those details in a moment.
And then we'll add a new folder for references, because that Iron Python DLLs that we just downloaded need some place to put them.
So we'll go and find that zip file.
We'll grab those DLLs and drag them into that reference folder.
And there you go.
You have a place on disk where they're referenced, but now we need to plug them into that solution.
So you go to references, do a browse, browse to that spot on disk that you just saved them to, and now you have access to all those DLLs in your solution.
Cool.
Next up, we have to add a little using line there.
Just a simple one.
So you just reference in that Microsoft hosting, uh, scripting one.
We set up the script runtime and the engine.
A distinction there is the engine is the thing that evaluates the scripts and the runtime is the thing that manages memory and scope.
And this is just for an example.
So we create an example class and it does not a lot.
We have a public function in there that will simply just return a string that says, hello.
And then we initialize that example class.
We initialize the script engine.
And after you execute a script, it has to output somewhere.
You could use it somewhere else in an application, or you could output it as a text to some output window.
So in this case, we're just gonna fill up that list box with the results that are being output from the script.
And here we're initializing.
What are we doing? We're adding the example class as a global variable.
This is a big distinction here where you can have any class whatsoever, any object exposed to scripting in this manner, and that's why it's thrown in a for loop even though we're just adding one for right now.
Cool, and then we click the button, and that passes the text that we had in the text editor.
It passes that into the scripting engine.
The results are piped out back to that memory stream, and then passed into the list box so that we can see it in the UI.
So that's in really short order, setting up absolutely everything that you need.
We compile it, build, run.
We type in something really simple, like one plus one.
we've got a calculator. That's using Python to do Python scripting. You can type in any Python script there and it would execute. In this case we have access to .NET functionality as well. So there we're grabbing our example class, we're executing that method and it says hello is the result. So super simple, super high level, but I think that you can see very quickly that you have implementation details that anyone could utilize. I think it's pretty cool.
I think I probably have a secret agenda in showing that, because any application that I find myself using, I would love to find scripting available inside of it, because that gives me the hooks available to add in additional functionality in as lightweight a form as possible.
All right.
So.
I'm going into a little bit more of a production solution side from there.
We can see the groundwork.
That's all foundational stuff.
And if you have that in place, there's a few things that you can add on top of that, and there you have a production solution.
So the examples that I'm going to be showing are simplified versions, to not go into all of the cruft of whatever it is that you would create.
Would definitely look a little bit heavier than what I'm about to show.
But I'll cover just enough detail to see how everything hooks together, how it all connects.
So let's take a look. Before I look at the coding examples, let's look at it in action. So this is a video of the editor FrostEd and the scripting editor, FBScript, interfacing with each other. And here we have a bunch of things going on. We have the thin wrapper exposed as FB. We have an assembly exposed as world render.
We have a data explorer on the left hand side.
It's just a list of assets, very common in a lot of different editors.
We can select those things, and we can store whatever we have selected in a variable we specify.
And the command to do that is really simple.
So you can just say, hey, I've got this thin wrapper called FB, and FB lets me say something like, get assets from data explorer selection.
So that's straightforward.
and then we can iterate over that list of assets that we have selected and confirm our assumptions.
We can say, hey, I think I selected some stuff and I suspect it's gonna be in this list of, this variable as a list, test that assumption.
Go, yeah, it actually is.
So we go, okay, now I know that each one of these assets that is going to be available now inside of this script, I can store it iteratively inside of that loop as the outdoor light is what I wanna get access to from that asset.
And then not only can you get assets from a list of assets, you can also kind of pare down into assets.
So look at component pieces, however that happens to be set up.
I know it's all very specific to Frostbite, but I think the general principle applies.
And then you have access to the member properties and functions.
And so there I run a quick query.
So the outdoor light sun rotation for X, it happens to be at 120, executed that line, it returns the result to the output field.
But you can type in any value and execute that.
And what I'm clicking on there is just execute current line.
So it's not the entire script that gets re-evaluated, it's just that one line.
So any portion of your script, you can always just execute ad hoc that way and find out further information about that or operate on that data.
So that's the high-level idea.
I mean, it's a super simple example, but it's just enough, I think, to give us an idea of what we're going in for when I start talking about further implementation details.
All right.
So, iron python exceptions is the thing that was missing from that very first simple example.
That very first simple example allows us to do things like one plus one, and it will return a value of two.
So that's fairly intuitive and straightforward.
But if we were to type in something like A plus B, it was like, well, what the heck is that?
You haven't defined it yet, and you'd want to throw some sort of an exception.
So, to do that is actually not that difficult.
And so I'm not gonna go into the details because it's also a solved problem.
So just like.
Some of the other examples I'll be looking at later, including Avalon Edit, there are solutions that are already out there that we can utilize.
And so this is a really good resource that I can point you towards.
Devhawk.net has a lot more than just this particular example but this is where I started.
And here we can see setting up the traceback framework.
Here, the idea of the awareness that it exists is more key than exactly how to do it.
But what's going on right here is we have a hook there into that exception.
So any time there's a problem with a script that gets run, it has a mechanism to pipe that exception back and tell us, you know, what's it gonna tell us.
It's gonna say, what line number did a script fail and what was the error message?
And then we can do something meaningful with that information.
There's a bunch of other stuff going on in here, but again, not gonna linger on this particular side of things.
What I wanna do is move on and look at the script engine initialization, and in particular, the scope management.
So as long as you have exception handling set up, that's great, and you can see right here in the initialization, you've got this engine.setTrace, which is kind of kicking all of that stuff off.
We're going into reset scope.
So.
This is important because there's a bunch of stuff that's going to happen here that helps us hook into an editor.
Let's look at that.
Alright, so in scope by default, we have assemblies, Python paths, aliases, you could throw in a whole ton of stuff into here, but it can also be quite simple.
So in this case, what we want to do is just iterate over all the assemblies that are available in the application that we're having scripting in.
So that's pretty cool.
We can go everything that you would have access to if you were inside of C Sharp, you now have access to inside of scripting with that simple iteration loop.
And then we can also throw a whole bunch of other stuff at it.
We can say, here's a list of Python libraries that we can have access to.
And then we can also declare a bunch of objects.
You could have singletons or whatever the case may be, but you could build up a bunch of structures in there that you just have access now as well inside of scripting.
So that's how you pass all that stuff in.
And that was a very high-level quick overview of Iron Python implementation.
And let's look at that last bit of stuff that we just saw and how that connects with the FBScript Editor.
So inside of the FBScript Editor or inside of any kind of scripting editor solution that you would look at I highly recommend looking at Avalon Edit.
I found it really easy to use, and it solves all of those common problems that you would expect as a bar of entry for any kind of text editor, would be it LimeWire or Notepad++ or whatever the case may be.
You're gonna end up with Avalon Edit having syntax highlighting, folding, code completion, all of that funness.
So before getting into a few more code looking slides, you can see a quick video of this stuff in action.
And what we're looking at here, just illustrating the idea behind importing something that we should be familiar with, the system namespace in C sharp, in .NET in particular.
And in this case, what we're doing is, as we're typing, we're getting code completion.
So, okay, that's cool.
A couple other things that are available here, as well as asking for help on giving functions, as well as, and this is a subtle one, it's kind of something I missed too as the video is playing, but right out of the gate, when we executed that first line import system, it wasn't in scope.
After we executed it is, and so it bolds the system.
So syntax highlighting can help us with more than just keywords and all of that kind of stuff.
It can help us understand what's in scope.
So that in the component pieces again is easy access to .NET functions. Here we can see a iron python script that says hey, what's, whether a file exists or not. And then we can see the code required to expose that and make it available to the scripting. So there it is. Just adding in all of the assemblies available there.
Now what about that code completion stuff, the drop-down menus and all of that?
Where are we pulling that information from?
How does that get passed from something that's a script that executes something to an editor that as you're typing is giving you some feedback?
So that's in two places.
It's in a public execute script method.
What does that mean?
It means that...
yeah, okay, when you wanna hit that play button or execute script button or whatever it is that executes multiple lines of code or one line of code or whatever the case may be, that same functionality there that you're gonna execute a large script with, that same functionality can get called as you're typing.
So you can pass in, and this is the key point to the next one, you can pass in the previous word.
So it is helpful to have a very simple script parser that will parse your script, find what the previous word was, and then pass that into the scripting engine.
So you can do things like, well, let's take a look.
You can do things like this, where you have access to your script engine, so you can call that execute script function, and as you're typing, you can get that previous word and you can do a directory on it.
Like, if you're not familiar with Python, if you type dir, bracket, and then inside of those brackets you're gonna put in a variable.
That variable then will be, what you'll get as an output from that is you'll get a list of the member methods and properties.
So because we're calling that in code there, what we can see here is, what we can see here is that we have not only the ability to execute the script from anywhere, from any part of your C-sharp application, but we can also execute that on the fly.
So as we're typing that system.io.file, as soon as you hit that dot, that dot triggers an event, and it says, okay, cool, I'm gonna look for a list of members and attributes that belong to system.io.file, and then it gives us that list in that drop-down menu.
And that would be the same thing as if we had put that whole thing in brackets and get something as an output.
And just one more thing, sorry on that last slide there, is some of these functionalities here might not look familiar, but if you did investigate the Avalon edit there, because it has such nice interfaces there for building up code completion boxes, here you can see those in action as well.
And we're just passing in the results into that code completion.
Cool, and we can do the same thing with Python scripts.
So, it actually goes beyond that, and I'll reiterate this point later with an example in production.
But there's so much more that you can do in this space.
So it's not just about going, here's an application, I wanna bring everything that application can see, and now I wanna have that in a scripting environment.
Obviously here we're looking at an example where we can go, okay, here's a whole bunch of Python libraries, but you can dynamically add a whole bunch of Python libraries later.
through calls from your script, not only can you do that, you can also add references to XAML to help with UI, and you can add in references to DLLs to help with, well, if you wanted to create an application or a library with a whole bunch of functionality, you wanted to write that in C Sharp using Visual Studio, that's all good, you can have that DLL, as long as it's a .NET DLL, you can have that available inside of the script environment as well.
Now syntax highlighting, I'm not gonna go long on, we all get this fairly standard bar of entry into script editing, but I just want to reiterate that point that I called out earlier too there.
If you type in something into this editor, everything is just gonna be text, and especially if you know Python, it's gonna be very dynamic, so there's not gonna be really any strong typing or anything going on.
However, after you execute something, it will exist in scope, and it's that reflection of what is in memory.
that can tell us stuff back to the editor.
And so as soon as we've imported system, or as soon as we've executed anything that registers something in memory, as long as it's being executed and it's there in memory, it's gonna go bold to help us give that indication.
So that's really useful for REPL workflows.
And something else is just more of a counterpart to code completion.
So if you hit dot and you get a drop-down list.
In this case, if you use the Python command help and then throw in any object into help, you're gonna get some documentation if there's something that exists for that.
So in this case, we can get documentation both from Python commands and from...
.NET commands. And that was the FB script editor. I think there's about three slides for the FB modules. It's just a thin wrapper, so it should be fairly light. And then we'll look at production examples.
Thin wrapper should be just that, should be very thin, really light and accessible.
If you wanted to go into the guts and access absolutely everything and do everything well, you actually do have access through scripting to do that.
You can also go into C Sharp to do that.
But to make something accessible to a community of people that are gonna be building stuff and using it, documentation helps, but it is really important to make sure that it's as intuitive and easy to use as possible for new users.
So, here we're looking at a list of commands.
that should seem really simple.
Create, guess you all, you wanna create some stuff, you gotta create command.
You wanna edit some stuff, you got an edit command.
You wanna get or query some information, you've got that.
The user commands is an interesting aside, but it's a very reflective system.
So the user commands actually helps us reflect into the scripting engine itself and modify parameters about the scripting environment.
A bit crazy, but anyways, it's there.
And also just various utilities that you'd wanna expose.
So this is an example of that.
So here you import that thin wrapper called FB.
So with a thin wrapper imported, and obviously in your case, it could be called absolutely anything, I go with a two-letter designation, so it's easy to type, one-letter designation, too easy to conflict if someone else wanted to use a single variable name.
But with FB imported, with that thin wrapper imported, we can do things like...
As soon as we hit FB dot, we get that first list of what do you want to do?
Do you want to get or create or what? So I want to get some information.
So I hit get and they'll say well what do you want to get and it's like a whole list of assets of like you know do you want to get a mesh or a texture or what and you get that list and then you go well I want to get I just want to get assets from the data explorer selection.
So that gives us a quick easy flowing path to actually get the information that we want.
and here we can get a high level idea of how to build up a thin wrapper.
For me, it's really easy to say that it helps to say, you know, if the sub-modules read like English, it's easier to follow.
In this case, I don't know, some examples that I would pick out.
So you have a level, a scene, and in that scene is some layers.
So you can ask that question, you can say fb.getLayersFromScene, and then you can pass in maybe a filter to say, okay, only get me the layers with this string in it or something.
I think you get the idea there.
And we saw that video earlier of executing scripts, seeing that update not only in the properties of an object, but also update in the editor.
And in this case, it's just reiterating that point.
So here we're saying, yep, we can query assets, we can query components, we can pare down into the data and find the information that we want.
And as soon as we have access to that data, we can modify it.
So that is what we've accomplished with all of that.
And the interesting thing too, and I'll touch on it coming up here, is...
especially on the Dragon Age side of things.
It's really easy to spend a small amount of time, but still, maybe that takes a couple minutes to write.
To accomplish what?
That you could change with a slider, right?
So from a tech art perspective, it always gets a bit tricky to justify how much time to spend scripting something that you can do very readily or easily with the UI.
So the key point is always tracing it back to how you batch script that and automate it over tens or thousands of assets there.
So high level goals of implementing a thin wrapper.
Exposing commonly used commands.
You just get a strong base, a strong starting point.
Abstract queries to easily access assets.
So if that same functionality existed, but it was like nested in some, you know, some name space inside of some object inside of some other object, sub-object.
If that functionality is buried away, just to expose it at a higher level, especially if it's commonly used.
And then provide a consistent and intuitive way to get started with scripting.
Alright, production examples.
So all of that was the implementation details of how to hook up a scripting solution in an editor, specifically a .NET editor.
But what value does any of that have if we're not actually using it in production and creating something that can be appreciated?
So here we're gonna look at some production examples from Dragon Age Inquisition, Garden Warfare, and Battlefield.
Should be noted that across the community of people using Frostbite IDA There's maybe about 200 or more people using FB scripts creating them and writing them this includes tech artists designers engineers a surprisingly wide set of people and They're using it to help make you know the redundant or repetitive parts of their job. You know a bit faster and less error-prone, so Let's take a look at that So, Garden Warfare is first up.
And before I go running down that road going, hey, look at what we did on Garden Warfare.
I know, because I sit through these sessions too, in the back of my mind is going, well, how can I use that?
What does that mean to me?
And so, when I go into this detail, it's important for me to try and find a way that how does this apply to someone outside of Zomboss Academy?
EA or wherever. So let's take a look. So when I mentioned earlier that on Garden Warfare that we set up thousands of assets automatically, what does that mean? It's like, okay, well you click a button and you get a thousand assets and they're done. And it's not quite what I meant.
What I mean is that you set up the framework for those assets.
And what does a framework of an asset mean?
We thought that it was really simple, right?
Well, most of us here, I'm guessing, are savvy enough to realize that anything that you see rendered on screen isn't just one thing.
It's composed of many. And what are those things?
We start with concept art. We get it.
We have an idea, maybe as a Word document or something.
And then it gets represented as some concept.
Again, it could be text or it could be an image.
And then when we have that concept, we start creating something, something physical, but it's still not in the game.
It's just like, okay, this is our first steps towards this.
And we create models, sometimes really high-res models, and we use ZBrush or whatever the case may be to sculpt something that's way too big to actually fit in the game.
We build up textures, and the textures are way higher resolution than what we'll actually use in the game.
And we start building up this really nice-looking thing.
of diffuse and specular normals and all of that goodness.
And then we start applying it with shaders and materials and we start building up something that we're starting to say, hey, I get it, this is what we're making.
And then we start seeing something in the game eventually with, but maybe it's not moving yet, maybe it's just like, oh, this is how it renders with this engine, with these lighting conditions or whatever.
And then we, excuse me, hook up gameplay, like how does it respond to button clicks, what is the animation doing, the visual effects.
obviously all of that requires skeletons and character rigs.
And then the component parts need to get rigged and how they get swapped in and out. So yeah, we've got this guy running around and he's got a state flow and how he responds to all of that kind of stuff. And then we've got audio as well. So that stuff, even though it could be a really simple thing, can be quite complex. So...
It's also not something that you understand exactly how it all connects together at the beginning of a project.
You figure it out as you go.
You go like, does this work?
Does this connect over here?
And as you kind of build up enough assets and you start to see how it all connects together, you start identifying patterns.
And you're going, okay, I get it.
You know, this type of a thing is always gonna connect this way.
The interesting thing is after you actually start to digest that and you start to appreciate just, okay, this is what we're doing right now.
If you take a moment and pause right there, you realize that it's actually really complex because you came about it organically and you got to that point not because you're like, ah, this is the best way to design how everything should get connected together.
It's like, no, this is actually what, you know, it's a creative process.
If that diagram doesn't make your brain melt, the idea is that each one of those nodes has a lot of properties and additional values beneath it yet.
So it's less of an array of things.
It's more of a matrix that goes quite deep.
And that's just a single asset.
So you're like, wow, okay.
You know, there's a lot of button clicking going on just to connect the dots.
For an artist or a designer or someone to go, okay, I'm gonna build something.
And every time they're building something, they're going, okay, this connects to that, this connects to that, this connects to that.
That takes a lot of time.
So what we did on this project was once we had that figured out and we had a way that was consistent enough, we could script how a lot of this stuff gets connected together using placeholder assets.
So we build up a volume, say for a head prop or something like that, and that volume would say that's where that head prop, be it a hat or something, needs to exist within.
It's just parameters to say, here's your guidelines, but this is where it's gonna exist, that's how it's gonna function, but it's not the real asset yet.
And then we'd throw the concept art on it, and it would look ugly.
I mean, a concept art mapped onto some geometry.
It looks completely out of place, but you get the idea of what it's gonna turn into at a glance.
And then we do a whole bunch of other things But the end of all of that stuff is that we could use a framework of real assets So we could use real geometry real textures all of that kind of stuff. It just doesn't look The way it should yet And the things that that tells us is, you know, how much memory is it gonna consume?
How is that gonna perform in the runtime?
How are you gonna swap these things out?
How is that gonna interface with the UI?
How is that gonna work with the progression of the game as you unlock things or get weapon upgrades or whatever the case may be?
All of those questions that usually you don't get to by the time, like it usually comes after you've created all of this content, you can front load a lot of that.
That was a really cool success and a learning experience from that project.
There's a few more guys kicking around.
And that's just to highlight that it isn't always just physical geometry.
Sometimes it's particle effects or visual effects or sometimes it's audio or sometimes...
I mean, it spans across all of those domains.
So that is another thing that I did want to mention was that...
beyond actually being able to get an early look at how everything fits together, it also helps smooth over its production grease, if you will, so that a lot of these different domains can be working and they can be building stuff and they don't have to be waiting on the next person to finish whatever it is that they're doing because we have a placeholder for that.
Alright, Battlefield. So Battlefield, Daniel Rashidi at Battlefield, a very talented technical artist.
created something that was way beyond anything I had imagined FBScript would be used for, and he found a lot of new ways to utilize this technology that I hadn't seen it used before as well.
So that was including using loosely bound XAML and .NET DLLs as I'd mentioned earlier.
So not everything had to be written in scripting.
Some of this stuff, some of the components of it could be written somewhere else and then imported into this ecosystem.
The cool thing is, being inside of that ecosystem, you're now in a highly iterative environment.
So you can take some of those well-understood component pieces and then add them into this.
So let's see that in action.
An interesting thing is, we're gonna look at something that Daniel made for Battlefield.
It's called Level Scanner, and he's made a lot of different types of tools.
We're looking at that.
and it was used to great success on Battlefield for understanding their large data set.
But it was also used as well on Dragon Age, and let's take a look at that.
So here's a video.
Alright, so that's the level scanner, and it kind of picked up a little bit late there, but we'll come back to the starting thing just in a moment.
So the whole thing there is that you've got all of this information about your data.
A lot of this information is abstract.
It's not ever in one place.
It's using information from a whole bunch of different places to figure stuff out.
You can sort it based on a number of different parameters.
And in this particular case, it's found an asset that has reasonably well-implemented LODs, but it's used a lot in one given level.
That was the rock example.
And then this other example right here for the door, where it's only used once in a level, is missing the, it has an LOD, but the LOD is not optimized as much as what it could be.
So this gives you a sense of going, ah, we've got all of this data.
We're going to dedicate our time and money and efforts so that we're going to make this game run as efficiently as possible.
But we can't just start with the very first asset we see and then go from there.
We want to have a sense of where to start first.
And so all of this UI and everything else, he put into the hands of the art teams, and they could get a better sense of how to prioritize their efforts of where they wanted to spend time optimizing for runtime performance and memory and all that.
So that takes us as a bit of a segue to Dragon Age because we saw some Dragon Age assets there.
So Jeff Vannell, another really smart guy, and really practical too.
So he had to approach solving problems from many different angles.
And obviously not everyone is gonna include FBScript.
And another key thing too is that when you set out, you're not going to be creating content really using scripting or automated process.
I mean, you can.
You can use procedural techniques and everything else, but ultimately a creative process is going to be involved.
And that's going to be the starting point anyways.
So the big thing to point out here is that on Dragon Age, I mean, my mind short-circuited when I was looking at that project and looking at the data sets and trying to understand even what someone could do to try and optimize for all of the different platforms that it was released on.
And when you look at almost 20,000 different visual effects, 20,000 different assets in the visual effects folder alone, it's pretty phenomenal.
And you click on one of those things, it's like, okay, let's look at this.
Dragon VFX for when it lands hard and then you go okay open that thing up and you get like all of these other assets that it's referencing in there so you've got oh I've got this debris and dust and all of that kind of stuff and you click on one of those and you go into there and it's got like all of these things of how to actually render and animate and do all of that kind of stuff with the visual effects and then you've got all of that information for each of the different platforms that it's targeted towards.
It's a bit much, and I think what they did was a really cool thing, is they just targeted ultra quality.
They just try and build this thing up for the best possible visual results that they could, and then they would do a very smart approach, a pass on it, to try and get it to progressively be as high visual quality as possible while meeting the memory and performance restraints as you look at the lower end systems.
Another key thing, too, about this is that.
I like his quote here, is if the process is technical and repetitive, we can script it to save time and reduce user errors.
And it's that, and reduce user errors that really resonates with me too, because it's not just about, hey, we got this done faster.
You can have an army of people getting something done faster, but you also end up with a lot of errors, so it's just a nice thing that we can use scripting for.
And if I look at this next slide here too, talks to some of the BioWare's experiences with this.
And again, talking to the point, too, of how much time do you spend scripting something versus, you know, if an army of people, or if even just a few people just spent, like, really a lot of time working on something.
And there's a tricky balancing act to understand, oh, maybe I spent way too much time doing something that didn't really save a lot of time.
So, it was Dave Schaefer, who's the lead SDET at BioWare there, did a return on investment.
analysis and they measured that they saved 30 months based on just QA efforts alone through FB scripts. And not every script saved time. So, actually if I look at that last slide there again, there's a couple other things I wanted to mention too.
is they had to ask other questions.
Like, some scripts that you're running are actually doing things that are physically not possible no matter how many button clicks you throw at it.
So there are some scripts like that.
And so to try to make that distinction of could this have been done by hand?
No, this is new functionality added that we just couldn't have even tried to take on without this.
And then in addition to that, of all of the things created, if we see in the lower end spectrum, there were scripts that were arguably a waste of time.
So maybe more time was spent creating something and it wasn't used as much as it was anticipated.
And you didn't get your return on investment there.
But by far and large, you're going to find the medium.
is gonna return a significant value.
And then every once in a while you hit the jackpot where you're like, wow, that was really taking us a lot of time by hand, but we really saved a lot of time.
And so you see those edge cases there as well.
Oh, and one other thing too I wanted to point out too on this slide is the quote here by Darren Clark.
And just a key thing there is the fact that when you free up the time on your team, you can spend more time testing other areas.
So it's, if you kind of, applying your scripts to those technical things that can be automated, and that require that technical test, the things that you need creative people, and in this case QA are creative people that help us understand what the quality of a product, in this case, gameplay experiences are, we can get their time dedicated in a much more effective way in that way.
Alright, so, next steps.
I've talked about, well, let's see here, I've talked a while about stuff in the past and that stuff, I mean, it's a bit tricky.
I'm a generalist and I think of my mind like a revolving door.
So that stuff comes in and then it goes out and then I have to really try hard to go back and dig it up and understand it again.
I'm always far more excited about the next steps.
So this stuff has me really excited going forward.
It's, okay, we've done some stuff and it was valuable and it's shipped games and that's cool, but what does the future hold and what are we gonna do with that?
So Michael Sharp at Criterion has created something that we're planning to use internally.
It's called, he's named it Community Toolbox.
While this is not immediately applicable to this audience, you're not going, oh cool, I want to use Community Toolbox, it's not an application that we're trying to pitch or sell or it's going to be used outside of EA, but the idea here is behind how to connect a lot of people that are building stuff and then wanting to share it between teams, studios, domains, whatever the case may be.
And so that's what I want to look at here, is how to best facilitate that.
So I've got a video, let's take a peek.
Alright, so he set up a web portal, and that's really nice.
Everyone can access it across the company.
We can download this tool.
The installation process is fairly straightforward.
Not a lot of options or buttons or fields or things to fill up, we just download it, we launch FrostEd, it matches up the environment system there with that.
And then we've got that new tool that's available in the taskbar. So accessibility is always really key Here we're looking at a Look dev visual environment. We're just getting a feel for how certain things render behave with camera and all that kind of stuff When you normally move a camera around in frosted and most editors you're using a mouse And you're using a mouse and probably the alt key or something like that and clicking and dragging and orbiting and zooming and trucking and all that That's the normal way, but if you wanted to use a controller you could.
Now this isn't functionality that was created by the FrostEd team.
It's something that Mike hooked up with a bunch of other component pieces here to interface with an Xbox controller in the editor.
So how did he do that? Well, without closing FrostEd there, he just browsed on the website there that had this available, clicked on that DLL or that plugin.
and clicked install and then went back to Frosted and there it is available. So now it's the Xbox controller doing all sorts of additional functionality like tilt and all of that kind of stuff.
So again, less about the exact specifics of what's going on right here, and more about the idea behind, hey, when you have a framework that actually supports scripting, there's more to it than just scripting.
There are all these other kind of hooks that you can plug in various plugins into, no pun intended, and a lot of additional functionality there.
So that's cool.
It has something that's really accessible.
But this other thing right here is really key too.
And this is something that he's created called ScriptPad.
And the way this functions is inside of that same ecosystem, the idea of being able to browse the tools and things that other people are writing across multiple teams.
And then when you find something that you're interested or want to actually test out, that it's readily available there right inside of the editor.
So in this case, we've got a test camera there that we're pulling down as a test from BioWare, and we're going, okay, cool, we've got a slider here, and it's adjusting the zoom of the camera.
We can look at the edit script.
So we can peek behind the functionality of any given tool there.
And this is all inside the editor, so it's not like we need to have Visual Studio open or that we need to have any other kind of, a bunch of stuff to go and figure out how was something done.
All of that stuff is packaged up together there.
And then, because we had previously downloaded the script pad, we don't need to do that again.
So it's just illustrating that we can always grab any existing tool that's on the machine, or we can always grab an updated version of it.
And in this particular example, we're going, okay, well, it's common in a pipeline to get a GUID or some sort of reference that isn't exactly the name of an object.
So someone created a tool that would allow us to take a GUID, put that into a simple text field, hit a button, and it would find where that, the asset using that GUID is in a scene and frame it in selection.
And then we can look at the code behind that as well.
And it's a script and it references a whole bunch of stuff, but also has lots of revisions.
And this is a key thing for me going forward, is in trying to build...
To implement, to support and maintain this kind of a solution is easy enough on one team with a handful of people using it.
As you get into the hundreds of people using something, and they're across multiple versions of your editor, and to try and maintain, well, okay, they have this script, but it's for a different version of the editor.
How you maintain all of that, I'm really excited to look at solutions like this that will help manage that.
And then there's all sorts of searches and filters and advanced filters to not only find a tool of a given name, but also even go deeper than that and say, find me all the tools that use this keyword or bit of code in it. All right. Wrapping up. So, yes, indeed, on the shoulders of giants. Lots of people contributing and helping and supporting and all of that.
Not the least of which, Ludovic Chavant is the guy who introduced me to Iron Python, helped kick this thing off.
I've done a lot of the implementation since then, but big shout out to Ludo.
DevHawk, found as an invaluable resource online.
AvalonEdit, another invaluable resource.
Huge respect for, well, the initial inventor of Iron Python, Jim Huggaden, and subsequent maintainer of that, Jeff Hardy.
and a huge long list of credits and thanks and really the list does go on.
And here we are with questions, so, and a quick reminder too, evaluations.
So, there you go, a little guide.
They take three clicks.
We have a mic on? Looks like we need help with the mic here.
When you were showing the autocomplete for the Python, you said you were evaluating the Python code before that?
How are you dealing with side effects in there?
Sorry, if I understood the question, it's when I'm showing the autocomplete dialog for the Iron Python.
What was the second part of the question?
How are you dealing with the, if I have code that has side effects, that does something, but you're also evaluating it just to do the autocomplete in there.
So if I'm creating objects or something, and then you do the autocomplete on the object, If I understand the question, it's how to distinguish the difference between a property on a code completion and a method that's going to do something, and perhaps what the parameters are for that method.
Am I getting that right?
No, it's like, so if you're in the script, you're creating an object, and then later, further down in the script, you're offering all the autocomplete options on that object.
Mm-hmm.
If you have to evaluate that multiple times, aren't you creating the object multiple times?
And wouldn't you have lots of side effects from that?
Oh, I think it's just for memory and scope management.
And if you have something already in memory and you're looking at a property of that in memory and then another property of that in memory, the concern is about how that exists inside of scope and is there any knock-ons or issues with that?
Also, if I'm in the level, I'm creating whole objects, like actually placing, I don't know, trees in the level or something, wouldn't I be running that over and over again just for the autocomplete?
The interesting thing about this is that it's actually just referencing, it's just references.
So it doesn't duplicate anything in memory.
So when we're looking at an object that is there and we want to access it, we can change a value on it.
And it's changing the value, because it's referenced to the actual object, it changes the value on the object itself.
It doesn't exist more than once in memory.
Okay, so you're only always re-evaluating the current line, not the entire script?
That's correct, yes.
Okay, thanks.
Given that you originally wanted to start with C sharp, and now that Microsoft's released Project Roslyn and F sharp type providers, would you still go back to Iron Python?
That's a good question.
I would actually have to learn more about that.
I mean, if you're available afterwards, I'd love to chat.
Sure.
Cool, thanks.
Hi.
Hello.
Oh, hey.
I just had a question about, it's kind of more policy, really.
If you're opening up those tools, and the last slide you showed where you've got an online community where people can share scripts and so on.
Do you have any kind of security concerns about basically allowing anybody to write code that effectively ends up running on anybody else's machine?
Yeah, that's a really good question.
It's funny because the amount of stuff that we expose in FrostEd is actually truly terrifying to the engineers that wrote it.
And they're like, well, what if everything breaks?
Like, someone's going to use it incorrectly and stuff's just going to, you know, stop working.
The environment that we work in with Perforce is a decent safety net, so you can actually run mayhem on a complete data set, but that's your local copy and nothing gets submitted until it's validated.
But that validation step is really key.
So we did really large batch processes on tons of data on Dragon Age, for example.
But we spent a day or two with QA validating and making sure all of the runtime implicant...
try that again. The run time implications of that were all sound. So yeah, there is due diligence required to make sure what you're doing, especially in broad strokes, holds up.
Thank you.
Hi. How much work did you have to do to the code of your editor to expose all this functionality or did you get most of it for free because you were doing everything with C-sharp?
we got most of it for free because we were doing everything with C Sharp, especially in .NET.
There are tricky bits there, as if you have really risk-averse or really, I don't know, I mean, there are ways in which you could implement a .NET solution that wouldn't be as readily, excuse me, readily exposed.
But yeah, anything that's declared as a public function, if it isn't private or protected, we'll be there for you to utilize as you need.
Cool, thanks.
When you're using the scripts, are you able to undo and redo the effects that they do?
Yes and no. There are some commands that are wrapped that way inside of the Frost Editor, and we have a roadmap in play for future improvements towards that to better handle undo-redo, but for the most part, especially if we're just doing a property change or whatever.
The future is yes, but at the moment it's a bit sparse that way.
Yeah, so how you explain it is then if you would go in a for loop and go through all the objects and change like one property in all of them, so you would have to undo through each and every object then separately, like if you did something wrong.
That's possible, or yeah, to batch, call a reset value or something like that.
Yeah, okay, thank you.
While you were working on this, did you guys end up implementing debuggers or like ways to visualize like the current state of the Python environment?
Yes, it's something I did implement fairly early, although I haven't seen it in as wide use in production.
The DevHawk website has some really good examples of it there in play as well.
You absolutely can and I have it hooked up.
in a prototype fashion, where you could put in a breakpoint, hit those breakpoints, and on a breakpoint, inspect or watch all sorts of variables and modify those variables on the fly.
So all of that stuff is possible, I've seen it in practice, but getting it really slick so that it's production ready is a bit more tricky.
Cool, thank you everyone.
