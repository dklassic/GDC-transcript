Alright, I think I'm gonna get started now. Before we begin, the usual reminders, please silence your cell phones, and they're doing the pass scanning thing, oh, wow, they're doing the pass scanning thing, so between each session, make sure that you get your pass scanned so that when you do your evaluations, you get one for each of the sessions in the talk. So, alright, hi, thank you for being here, I'm David Pittman.
I'm going to be talking about procedural level generation today, and I'm just very briefly going to introduce myself. It's my first time speaking here at Level Design in a Day, and my background is a little bit different. I was not a level designer before. I used to work in big budget games, especially at 2K Marin, where I was an AI programmer on Bioshock 2, and for a time I was the lead AI programmer on what eventually became the Bureau XCOM Declassified. I kind of got burnt out on that game.
About two years ago I had the opportunity to do something new.
I co-founded Minor Key Games with my twin brother, and now I do a little bit of everything.
I do programming, design, bad art, audio, business and marketing, pretty much anything that has to happen to ship a game, I do it now.
So about two years ago, I made this game called Eldritch.
And when I was working on it, I actually had a kind of difficult time explaining to friends and family what I was making.
It wasn't like a particularly innovative game.
It was just a hybrid of genres that people didn't really visualize the way that I was thinking of it.
It was kind of hard to describe.
I tended to talk about it in terms of my influences in immersive simulations and roguelikes, but what I was really trying to say is if you take first-person combat and magic and stealth and you mix it with procedural levels and permanent player death and dress it up in Lovecraftian fiction and make it on a shoestring budget, you get something that looks like Eldritch.
So Minor Key Games is a two-person company.
It's myself and my twin brother Kyle.
We actually work on individual projects, though.
I made Aldrich completely by myself in a span of slightly less than eight months, which I don't track hours.
I think that's silly, especially for independent developers.
Back of the envelope calculation puts that around 1,500 person hours of work to make this game.
That number didn't mean a lot to me.
So I thought about what would it be for a conservative big budget game that would be maybe 100 people working for two years and not crunching.
That would be like 400,000 person hours.
So this was like a fraction of a percent of the work.
of a large game, and I'm not saying that to brag, like the game has a ton of rough edges, but it's just, I had a very fast, or a very short time span to make this game, and I had to work very fast.
And so that's going to be something that comes up throughout this talk, is trying to find the simplest thing that could possibly work, and that was actually why I chose to do procedural level generation for this game.
Despite the kind of rushed development of Eldritch, it was fairly well received.
I've cherry-picked the ratings I show here, because it's my talk and I can do that.
But, you know, 9 out of 10 people who wrote a review on Steam liked the game, so that was pretty cool.
And it made a tenfold return on investment, which was also really nice.
And it didn't do that by selling millions of units or millions of dollars.
It was not that successful, but the development was so lean that it was fairly easy to recoup the cost.
So I want to talk about specifically what I was trying to accomplish with the levels in Eldritch.
But first I want to talk about why I used procedural level design for this game and why anyone might use it.
So the first reason is probably the most familiar is if the game calls for an element of perennial discovery, the way that roguelike games do, every time you play a roguelike.
or some strategy games like Civilization, users randomize maps to great effect.
The player can't go into the game knowing what that level's going to look like.
They can learn the systems, but they can't learn the space.
And so the game design in that case actually dictates that you need a generator so that the levels are different every time.
Project constraints are another big one, and I think this is the reason that there's kind of the current in vogue, rogue-like scene amongst independent developers, myself included.
So as an individual developer, I didn't have time in eight months to make even like five to six hours of gameplay.
If I were building the maps by hand, I was trying to do everything else too.
Make enemy AIs, build the physics for the game, like I wrote my own engine for this game.
I just wouldn't have had time to do levels.
If you're familiar with the project management triangle of cost, time, and scope, where as one of these things changes, the other two have to push and pull to accommodate it.
As an individual developer, cost and time are the same thing.
Like this triangle basically flattens into a line between how much money do I have and how big is the scope of the game going to be.
I had to keep the scope of the game small because I was going to run out of money.
I couldn't have continued to do that as a full-time job.
Another reason to consider procedural level design is if it plays to your team's strengths.
My background was as a programmer.
I was able to get very fast at developing procedural levels.
I had done this sort of thing just as a hobby before.
And so when I went to make this game, it was natural for me to want to do this.
Whereas if I were trying to make levels by hand, I'm not an experienced level designer.
I would have been kind of fumbling at it.
I would have been much slower about it.
procedural levels also kind of enable content reuse in a really good way.
Everything I made for this game kind of just ended up in the mix to where if I if I built a module I made some new art like it just ended up showing up everywhere in the game you would see it regularly you would play you know the structure of a roguelike is such that you die you play a level over and over you know a variation on the same level and so you saw all the content in Eldritch a lot there wasn't the kind of in big budget games especially, there's a lot of money spent on set piece things that you might only see one time in 10 or 12 hours of play. There's multiple ways to use procedural level generation. The one that we're familiar with, the one that I use for Eldritch, is generating levels at runtime, but you could also generate levels offline and then work on them by, you know...
I can imagine this is a good way to, as an indie developer, create a game that's a bigger scope than what it looks like your team could support.
Generate a large terrain randomly and then fill in key points of interest by hand.
You could do something like that.
You don't also have to make a whole game that's based on random levels.
You could supplement a 10-hour campaign.
that's built by hand and then if the player wants to do more after that, like there's an endless amount of generated levels so they could play after that.
I actually don't know of any games that have done that, but it seems like it would be a really cool thing.
The last point I want to make is that procedural level generation is design.
I think there's a tendency to regard it as the domain of engineering, but I can imagine kind of like a hypothetical programmer who doesn't have any design sensibility.
That person couldn't write a good algorithm to generate levels because they don't know how to evaluate the output of the system.
Like you have to know what's a good level.
In a way it's almost like, you know, if you're a lead level designer, you may not be the one building levels, but you have to be able to tell the rest of your team, you know.
here's what the levels for this game are going to be like and be able to recognize if something isn't fitting what the game needs. That's kind of the same thing that working on procedural levels is, is that the uh, excuse me, fight in the cold. You need to be able to develop a set of rules that will produce good levels.
by knowing how to, by knowing what a good level is.
And that's why I think this is important to talk about at level design in a day, is because, you know, this is a room full of people who have internalized what is a good level.
You have expert knowledge, you are used to building levels.
You know, I'm kind of fumbling around in the dark, like I'm not an experienced level designer, but I hope to share, you know, what I learned along the way and show how I did, you know, take some design sensibility and shape what I made with Eldritch.
So the specific goals I had for levels in Eldritch, I was not trying to create like the sprawling, random terrain of something like Minecraft.
I wanted to do compact levels that had a clear start, a clear end, they took two to five minutes to go through.
I wanted the spaces to look, I put handcrafted on the slide, that's actually not a good word.
I wanted them to be synthetic worlds, look like they were constructed.
I wanted to have ancient sunken cities and not just like.
terrain and cave systems. I couldn't use noise, I had to do things that were hand-built, you know. I wanted the effect to be of continuous space instead of room-to-room. There's a few other contemporary first-person roguelikes on the market. They tend to be more like arena shooters. You get locked into a room, you fight monsters, the door opens, you move to the next room, and that's great.
Like, I really enjoy a lot of those games, but that wasn't what I was trying to make with Eldritch.
And the last goal that I had here was I wanted the worlds to be semi-coherent, which is a kind of strange goal.
Normally you would want worlds to be coherent, you want like a kind of internal logic and consistency.
But I was looking at Lovecraft reference, I was reading Lovecraft stories and that was sort of the inspiration for the world.
And one of these things that comes up in a lot of his writing, he describes environments in detail.
But there's a kind of sense of alien wrongness to the worlds that he describes.
This is from Call of Cthulhu.
He talked of his dreams in a strangely poetic fashion, making me see with terrible vividness the damp, cyclopean city of slimy greenstone whose geometry, he oddly said, was all wrong.
It's a recurring element in Lovecraft.
And one of the things, I mean, sometimes it takes the form of non-Euclidean geometry and actually three-dimensional space kind of being warped in a way that our minds can't comprehend.
In Eldritch, I wasn't interested in doing that sort of thing.
but I wanted the idea that the worlds are not logical, not consistent, something's wrong about them.
And that's something that I don't actually think I was very successful at, but I wanted to put it out there, I mean, that's kind of what GDC is about, talk about your mistakes as well.
I would also look to art reference, things that were specifically based on Lovecraft's writing, as well as, you know, just pieces of art that I've seen and think, you know, look, this is Giovanni Battista Paranesi's Carcieri wood etchings, it looks like a video game environment, right?
And the stuff I was getting from the art references were like, I want to have right angles, big Cyclopean masonry, really complex layouts.
Like if you look at Carceri, you see these staircases, you've got catwalks, you've got people all over the place, but the connectivity of the space isn't really clear at first glance.
That was kind of what I wanted.
I wanted a sense of verticality that's not common in first-person shooters, and that ended up kind of coming back to bite me later.
I'll talk about that.
And I mean, it's not about the structure and the layout specifically, but I wanted to use light and fog to create a sense of atmosphere that makes these relatively small levels feel bigger than they are.
And the results, in the best case, are something like this.
We've got, like if you know what you're looking for here, you can kind of see the edges.
We've got on the right side of the screen, we've got like green grass, and then there's a kind of clear divide into a module that's made out of stone.
But it's continuous space, it's not room to room.
We've got things that look familiar.
We've got ladders, we've got sconces with lights.
But it's only semi-coherent.
Like, we've got a ladder that goes up to a stone catwalk.
It's not really clear what that's for.
That was kind of the best I could do in the time that I had for that sense of alien wrongness.
I don't think it was successful.
But these are the kind of levels that we get from Eldritch.
So to give you an overview of how the levels were generated, there's kind of three steps.
We start by building three-dimensional maze, just kind of in the abstract.
And I'm visualizing here in two dimensions because that's way easier to put on a slide.
But if you imagine, you've got a box, it's sliced up along every axis evenly.
Or like if you ever had like the clear plastic maze toys that you have to get ball bearing through, you can visualize it like that.
So we build the maze and it defines the high level structure of a level but it doesn't have any geometry, it doesn't have any environment art.
Then we populate it with a modular kit of rooms.
And this is the sort of thing that you might even be doing as a level designer now if you have like, you know, modular environment art and you can snap pieces together.
It's basically exactly the same concept and then we generate entities, enemies, and items.
I just want to give credit where it's due.
Also, this is not like a particularly revolutionary idea.
I was inspired in large part by the Spelunky generator.
So, Derek Yu, who made Spelunky, has written a bit about it, but Darius Kazamy kind of separately implemented the whole game in JavaScript, I believe, and has made like an interactive version of Spelunky's generator that you can play with on the website.
It's really cool.
Like, check that out if you get a chance.
So, the first step, we have to generate this maze.
And you might wonder why we start with a maze.
Because if I'm playing a game and I say, yeah it was really cool, it had some good things, some bad things, I played this one level and it was kind of maze-like, do you think I meant that that was a good level or not?
Like, maze has connotations about, I probably meant that that was difficult to navigate, I wasn't sure where I was going, maybe I got lost, maybe it all looked the same.
Mazes to me say, I don't know where I was going and the environment was all kind of homogeneous.
So why would I start with a maze then, if there are those negative connotations?
Well, for a roguelike game, not knowing where you're going, that's actually a good thing.
That's part of the central mechanic of a roguelike, is there isn't like explicit wayfinding.
Like there's not a designer who's trying to guide the player to the exit.
Part of a roguelike is you have to find the exit.
So that part I was just okay with, and I actually wanted to have...
really twisty confusing levels because it did come back to that kind of Lovecraftian alien wrongness.
If you have like a confusing level and you get lost in it, that's actually kind of cool.
That's part of the Lovecraft experience.
But what I didn't want was the idea that the environments are all very homogeneous, like every part of a level looks like every other part.
That is not a good experience. That helps you get lost if you don't have visual landmarks and things that make each moment of a level memorable.
So I want the structure of a maze, but not the visual sameness of a maze.
So there's a lot of ways that you can generate mazes.
I think the extent of research that I did was to go to the Wikipedia page for maze generation and pick the first thing that looked like I could use it.
I ended up with something called Prim's Algorithm.
Nels liked it.
I ended up with something called Prim's Algorithm.
which the steps are described there, but we're just gonna go through it visually.
Basically, you start with the maze, and it's all closed off to begin with.
Basically, it's a bunch of rooms, they have walls between them, and we call them closed, and then we're going to pick one at random.
We're gonna start in the lower left.
We're gonna say, all right, that's the first room in our open set of the maze.
And then we just randomly expand to any neighbor of that cell, so maybe we go up from there.
Then on the next step, we're going to pick randomly from the open rooms.
and expand to any closed neighbor of that.
So we go that way, and we keep doing this and keep growing until either we've done enough passes that we're happy with the maze, or eventually we fill all the space.
So if we consider the structure of this maze, like it's a decent maze, it looks balanced like a maze should be, and as much as a maze can have balance, but there's no loops in it.
That's kind of a property of the algorithm, like because we open a path from an open node to a closed node, we can never join two open nodes together and create loops.
There's also no open space in it.
And those are things that I ended up trying to find ways to fix.
So I made a few modifications to Prim's algorithm.
There's two random factors in Prim's algorithm.
There's randomly pick a node to expand from and randomly pick the node that you're going to expand to.
So I biased which node that I'm picking to expand from based on trying to expand from the most recent visited room if I crank that knob up.
This wasn't like a constant, I do it all the time.
This was a control that I had to try to differentiate worlds.
If I turn that knob up, Basically, I get like the generator kind of just expands through the space until it terminates in the dead end or it has nowhere Left to go and so you get long twisty mazes that end up being kind of claustrophobic to explore They don't have a lot of branches in them If I turn that knob back down I get branches from anywhere in the maze and it's more open space lots of junctions less twisty claustrophobic spaces So the other random factor is which room we're expanding to, and I apply that toward expanding on the horizontal plane.
Because remember, we're doing this maze in three-dimensional space.
It doesn't look like this.
It looks like kind of you've got three levels of this stacked up.
In addition to opening paths north, south, east, or west, we can open paths up and down.
people are used to walking in the ground plane, and where, you know, even as first-person game players, we're trained to navigate in that plane, and vertical traversal ends up being really difficult.
Even in a game like Eldritch, where there were a lot of powers and abilities to try to give you vertical traversal, it just wasn't a lot of fun to do.
So I biased the maze expansion to always explore the ground plane, and only when it terminated and it couldn't go anywhere else, then I would make a path up or down and continue to explore kind of the next story of the maze.
And the last modification I made to Prim's algorithm, it's not actually even part of the algorithm per se, but after we've run all these steps and we've generated the maze, I just randomly knocked down a bunch more walls.
And what that gives us is, we look at this and we wanted to have loops in here.
I wanted to have...
some long lines of sites and open courtyards, and the maze generation by itself wasn't producing any of that.
But if I just start knocking out walls, I get this sort of thing.
And I could have done a really intelligent system here of like, you know, try to identify a long loop and find like the wall that I can knock down to make the most interesting kind of level. It turned out in a maze this small.
knocking down any random wall gets me exactly what I want and never has any bad side effects.
So it was like, again, the simplest thing that could possibly work.
And yeah, it took me like five minutes to write and it makes a huge difference.
This is actually the modification to Prims that makes the most difference in a level because if I turn this all the way up, like I get wide, wide open spaces. If I turn it down I get like claustrophobic levels and it's the difference in like it starts from the same maze algorithm but you end up you know in a picture like sorry I gotta go way back so in a picture like this it's a very open space we've got like connectivity all between here a maze by itself could never produce this right because There would be walls occluding all this.
So yeah, this ends up being the most useful factor of the three modifications I made.
Sorry.
So everything that I was talking about with the maze generation so far, I'm kind of talking about regarding all space kind of as equivalent.
But in the level in Eldritch, there's other things in the level besides just corridors and corners.
There's the entrance and exit to the level are kind of unique features.
There's shops, there's bank vaults to rob, shrines to acquire powers at.
And each of those is going to have to have environment art and a module made for it.
And that has to fit somewhere into the maze.
Shops you always enter from one side.
I would sometimes tend to put them in corners, the exit of the maze, it always had to go somewhere specific, like the entrance had to go on the top of the maze, the exit had to go on the bottom.
So I had these special rooms and they had to go certain places in the maze.
And the first way that I wanted to do this was to generate the maze and then search it for where I could put these features.
The problem is because...
like the geometry of the exit, the geometry of a shop, any of those kind of things, it had to fit somewhere specific in the maze.
And there wasn't always a guarantee from generating a random maze that I would have a place that could go.
For example, I want to put a shop into a dead end, because it has one entrance.
In this example, there's only one place that could go.
In the top right corner, that's the only dead end in the maze.
Like, if I kept cranking that open tuning knob way up...
there wouldn't be anywhere to put a shop.
And then even though I need that, like for balance and for tuning purposes, it just couldn't fit anywhere.
So what I found I could do, I don't search the maze for a fit for these rooms.
I actually seed the maze with the rooms that I need, and I prescribe, like, this room with this structure has to go here in the maze.
So it looks like this.
It starts even before we run Prim's algorithm.
We've got the maze and it's all closed off.
And we say, all right, here's gonna be a shop, here's gonna be an exit.
And we open up, not just those rooms, but also their neighbors.
And then I lock the rooms that actually have those features in them, the shop and the exit, and I say, when I'm doing the maze expansion, nothing else can ever touch those walls.
So I run the maze expansion and it goes from the neighboring rooms that I opened and we get the whole maze built out here.
And I've got that guarantee that nothing is going to knock down the walls of the shop.
Even if I crank up the open up the world tuning knob all the way and knock down all the rest of the walls, the generator is going to guarantee this shop is always going to have this structure.
So now we've got this kind of abstract maze.
filling three-dimensional space, but it doesn't have any environment art, it doesn't have any geometry yet.
I use a modular approach to this, like you may have heard, talked about last year for Skyrim.
I build small chunks of the world, and each cell in the maze is going to get filled in with one of those chunks.
Eldritch uses a voxel engine.
Each module is 12 meters by 12 meters by eight meters high, and I just build them kind of like the way you would do if you're in creative mode in Minecraft.
I have an in-game editor.
I put voxels down.
The challenge is that every module has to connect with any other module.
I don't have any guarantees about, like, which ones are going to be picked adjacent to which others.
And, with, you know, 12 meters on a face, there's kind of a lot of ways, there's a lot of space where they could join.
This was another case where I just did the simplest thing that could possibly work.
I made a safe region on the exterior face of each module, and that's what's highlighted in yellow in these images.
So any module that has, that intends to connect on that face, it has to have that space be open.
And so, like in the image on the left, this module connects in both directions.
One face is completely open, the other is walled off, except for that safe region that ensures that those two faces could join together.
It will always be traversable by the player or by enemy AIs.
I could get some kind of fun effects by playing around with opening up.
geometry on the exterior face outside of the safe region.
In this example, like this, sorry this picture is kind of hard to see, but we've got a corridor, so we're looking at the module from the outside and we've got a corridor.
that goes inside in the safe region, but we've also got kind of an opening up here in the top outside the safe region.
And what happens is that we get kind of just serendipitous effects by when this module meets up with other modules, it just kind of reinterprets what that opening looks like.
So the typical, like the most common case is that it just looks like a balcony opening up onto the adjacent module.
But sometimes there's some geometry in the adjacent module.
It looks like this is part of a feature, you know, that the two rooms shared that's kind of crumbling away.
Sometimes we get, because the voxel grid is so low resolution, they're one meter cube voxels, we just get a lot of features that serendipitously join here.
So in this, the adjacent module had like an upstairs level and it just looks like it connects to that opening.
And actually this really hides like the boundary between the two modules really well.
Like this just looks like one space.
You wouldn't look at this and assume that it was two separate modules.
And then sometimes because this opening is outside the safe space, it just ends up running into a wall.
And the player, you know, they approach this from the other side, they open the door and they're like looking at a dead end, it's just a wall there.
And I was like, well that's not good, you know, I want the levels to be semi-coherent but that just seems like a bad use of space.
And then I realized, I can just put some loot on the ground there and then it looks like a loot closet and it looks completely intentional.
So, yeah, I was just, this was the sort of thing, and I didn't do this too much in the game because it didn't tend to feel, like players started to perceive this pattern and it started to break down, but once in a while it was kind of nice to get these kind of serendipitous results.
So, in the maze there's six directions that any room can exit, north, south, east, west, up and down.
That means that there's 64 different combinations of ways that rooms can be configured.
2 to the power of 6, 64.
That means that ostensibly we would have to build a module to fit in each of the 64 configurations.
But of course, we think that wouldn't make sense.
Like a room with an exit to the north, it's the same as a room with an exit to the south, just rotated.
So the generator will do the rotation for me.
So if we have a tile, it's got exits to the north, south, and east.
The generator can rotate that about the vertical axis like we would expect and give us a module that will fit into the other rooms.
This is just what you would expect if you've worked with modules before.
It's just like laying down the tiles in the city building game.
But the other thing that we can do that you couldn't do with physical tiles is we can also mirror this.
And so when I do this, I get a north, south, and west exit, which we already had in the first row from rotation, so mirroring isn't necessary, like it doesn't fill any void in the level generator, but it does kind of reuse the modules in an interesting way because if you rotate a room, like the player doesn't perceive that.
If we took this room and rotated it 90 degrees, it just feels like the same room, we're just facing a different direction.
And when you mirror it, you do get the flipped image, and the player actually perceives that as a different kind of room.
It did have the constraints that I couldn't ever like, I couldn't try to spell something out on the voxels because then I would get the mirror image and the word would get reversed.
So by using those transforms, we get 24 configurations in the maze that we have to build modules for instead of 64.
And I can imagine if I were building like a six degrees of freedom descent style shooter, I could even reduce that set more because you could take like a room that has an exit to the north and rotate it up.
But since Eldritch has an up vector and gravity, I couldn't do that.
So 24 configurations to build modules for, that doesn't sound too bad, but we don't want the maze to be homogeneous.
We don't want, for example, every T-junction to look like every other T-junction.
So I need to build multiple modules.
for each of these 24 configurations, and that starts to sound like a bit more work.
I also don't know immediately, how many modules do I need?
I want to avoid repetition in the level, I want to have a number of modules so I can plug in to any similar configuration in the maze, but how many?
So I wrote a little tool that generates a maze 10,000 times and just dumps a spreadsheet of like, here's how many times I had a dead end room, here's how many times I had an L junction or a T junction.
and then it sorts those by their frequency.
And so that doesn't give me an absolute metric of how many modules I need to build, but it gives me a comparative metric of L junctions appear three times as often as T junctions.
I should build three times as many L junction modules so that there's a bigger set to pull from because you'll see those more often in the maze.
So, I ended up just, I mean, this scales really well.
I could build, like even today, I could go back in to Aldrich and build more modules, and it just gets thrown into the mix, and when I generate a level, sometimes you'll see those, sometimes you won't.
I just had to, you know, kind of decide arbitrarily where I was going to cut that off and how much work I was going to do.
What I did was, in the statistical report, if an L-junction shows up.
eight times in a level. I built eight variations of that module. It just seemed like a good number to do. And so between all the the modules that will go into the maze and modules that had specific features like shops and entrances and exits and shrines, I ended up with about 60 modules that I had to build for each world of the game. And in the first version of Eldritch that I shipped, I think there were about 300 modules across the course of the game.
So one of the things I wanted to do was have each world in the game represent kind of one story from Lovecraft's Ouvra.
The first world of the game was loosely based on the Shadow over Innsmouth.
And it's supposed to represent kind of a cave system and sunken ruins beneath a New England town.
And the way that I wanted to do that was to represent it like the town with red brick and steel beams, and then have a kind of cave system beneath that.
and then sunken ruins at the bottom.
And so I just started building modules that had each of those themes in them, and it ended up being very visually noisy.
It felt chaotic.
I wanted levels that were semi-coherent, but this just felt noisy.
It was beyond not making sense to just not looking good.
So the first thing I thought I could do was, well, I'll just split each of those themes out into its own modular set.
I'll have, first you'll go through the warehouse level, then you'll go through the caves level, and then you'll go through the ruins level.
The problem is that would triple the amount of modules I needed to build.
Each of those would have to be a complete set.
My solution here was, I just explicitly declared each module that I was building as part of one of those themes.
And then when I generate a level, the generator elects one of the themes from the set to be the dominant theme.
So it says, like, maybe this is going to be a warehouse level.
And it prefers to use warehouse modules when they're available.
But if, for example, I'm building...
The maze has some room in it, and I don't have a warehouse module that fits that room, it just falls back to using whatever else that can fit in there.
And so then I go from, like, the scene on the left, if I do, like, the color coding pass over it...
Like the bright green parts here are the ruins level, and then the dark blue is caves, and the red part is warehouses.
And the image on the left is what it looked like before, where it's just, you've got all these themes all in the player's view right here, and it's just kind of visually noisy.
After doing this themes pass, I ended up with levels like what you see on the right, where everything that you can see in here is from the ruins theme.
And then, you know, maybe at some part in the level, I don't have a...
ruins module that fits in there and so it falls back to using caves or warehouses and at that point it looks okay it's like sure I buy that maybe you know this the sunken ruin touches into a cave system somewhere that that looks fine but it's not so visually noisy So most of the modules I've been talking about are just things that populate anywhere in the maze, but I also needed to have the modules for future rooms, entrances and exits, shops, shrines, all these things.
This is basically the complement of the prescribed rooms in the maze, the things where the geometry had to be locked down.
In fact, in the data, it's all the same thing.
Like this is the definition for a bank vault in the first world.
The first six lines describe where in the maze it's going to go, and then at the bottom it says, these are the modules that it can use there.
And I used this for a lot of things, not just the shops and things, but also to add points of really rare visual interest, things that would be key landmarks both visually and experientially.
The image on the left here is from the second world of the game, and it's kind of hard to see probably, but it's a throne room, and it's being guarded by these two statues.
They're like weeping angels from Doctor Who, if you're familiar with that.
They come to life when you look away from them.
There's no other way to get to the throne room except to go past these guys, so it becomes a very dangerous challenge.
This is the sort of thing, it's memorable when you see this, it stands out, it's, you know, a really cool encounter that's a little different than just fighting enemies in the rest of the game.
But I didn't want to use these too much, I didn't want to have them show up all the time, so at most you get one of these per level, there's not even, you know, guaranteed to be one.
But just let me do something, you know, once in a while, just mix something fun in, just a little, you know, kind of unique, bespoke encounter that gets mixed into the level somewhere.
I also used them, feature rooms, to do things like the image on the right, it's a ziggurat at the end of the first world, and it's bigger than any feature that the maze could generate on its own, because it's actually built out of eight modules, kind of arranged into a giant cube, so you would never see a feature this large just in a typically generated level in the game.
It can only happen kind of when I build it as a bespoke thing.
So now we have, we've built the maze, we've populated it with the modules, and we need to spawn some objects into it, some enemies to fight, some loot.
You know, the goals that I had for this, first are kind of the things that you would expect, building levels by hand, you have to challenge the player with enemies and traps, you have to give them incentive to explore.
by having loot to pick up.
For a procedural game, there were additional goals.
I have to actually place these in sensible locations, or the generator has to place them in sensible locations.
And I also had to control the group population.
I didn't want to leave it up to chance how many enemies are in a level.
I wanted to be able to ramp that up over the course of the game.
So like the first world, there's a dozen enemies, and at the end, within the same space, there might be two dozen.
I needed to be able to control that.
I'd never even considered trying to write an algorithm to place entities.
Like, there's just so many rules.
Like, if I'm trying to place a light in the world, we all kind of have assumptions from being people about where a light fixture might go.
But trying to codify that into a rule set would be really, really difficult.
So I knew that I wanted to place entities by hand, but I didn't want to say, like, everywhere that this one module shows up, there's always going to be...
this kind of trap or this kind of enemy.
And I think this sort of thing is used in games with hand-built levels as well as procedural games.
What I did was to just kind of abstract the concept of putting an entity into the world one step away so that when I generate the level, there's a rule set that runs that says like, all right, here's a thing, as a designer, I put a spawner into the world and there's an opportunity for something to spawn there, but then there's a rule set that's going to run and say, do I actually want to spawn something right now?
And if so, what's it going to be?
So the most basic version of this is like a spawner that says, it always spawns and it's always this one thing.
And we use that like for the player spawner because you always need a player.
I could do spawners that had a random chance.
I did this a lot for traps.
I would just cover a module with spikes on the ground or trip wires criss-crossing it, but then it gives them a one in two or one in three chance to spawn.
So the specific arrangement of the traps in that room will be a little bit different every time it runs.
What's more interesting that I could do is to actually randomize what entity was spawned there.
This is an example of when you've broken into a bank vault.
there's a bunch of coins to gather up from behind the gates and it has a 75% chance of spawning at all and then if it does spawn, it's got a three to two chance to spawn a big pile of coins, which is actually a separate entity than just a single coin.
I used this also for enemies.
I would just place a generic enemy AI spawner and then it had a table of like, here's all the enemies that can actually be for this level and they're weighted by like, we want a whole bunch of kind of grunt enemies but we only want one really tough guy, so I could do that kind of thing.
Then I needed to control the population.
I called this resolve groups, which is a kind of bad name.
But basically, the idea was I gather up all of the spawners that are tagged a certain thing, like all the enemy AI spawners.
And then I run some rules.
I call the set of those.
And I'm able to resolve that into a subset of things I actually want to spawn.
I used that for enemy AIs, for a few really rare items like healing fountains that, they not only heal you but increase your max health.
Things I really needed to control the number of those that appear throughout, over the course of the entire game.
And this also let me run some additional rules while I was doing it, like for enemies, I want to enforce a minimum distance from the player spawn.
It was a really terrible experience early on in the game when like, you would, you know, I never put an enemy AI spawner in the same module as the player spawn, but it could end up like adjacent to something that had three enemies in it, and suddenly, you know, you've got monsters in your face and you've just entered the level.
So I just put a minimum spawn on there, so when it's resolving that big set of spawners into the small subset that it's actually going to use, it just gets rid of anything that's near the player anyway.
Spawner placement was something I didn't think a lot about until very late in development.
When I started, I was building modules and I'd put enemies in them and I'd put some traps down, I'd put some loot, I was just kind of putting a little bit of everything everywhere.
And as the game progressed and as I play tested it and felt more comfortable understanding what the game was, I realized that the placement of items was actually really key to guiding players through the level even in a randomly generated level.
Players are really good at perceiving repeated patterns in games.
It's really easy when you've played the game a few times to say, oh, I recognize that that room is a dead end.
It's not going to get me to the exit.
I should just not go that way, because I'm doing fine.
I just want to get to the end of the game right now.
Instead, what I started doing was, I didn't put loot, like, along any room that would have junctions.
I started not putting loot in there and just putting it in dead-ends.
So that when you're going through the game, you do some combat, you're running low on items, you see a dead-end, and you know that it's not the way to the exit, but you also know there's going to be loot there.
You know, that's where you can go and replenish your bullets, replenish your money.
Traps I ended up moving into hallways, and I use hallways kind of liberally here to mean any module that has two exits, whether it's literally a hallway, or an L-shaped corner, or a vertical mineshaft.
Anything where the player's experience is really just to traverse the space, there's not another choice to be made there.
That was a good place to put traps, just make that traversal a little bit more interesting.
I also put traps in dead ends, it's kind of to guard the loot, that was a really good place for them.
And then enemies, I wanted enemies to kind of congregate around junctions.
There was no really good way to ensure that, because enemies in Eldritch, they wander randomly.
It kind of didn't matter where I spawned them.
They were going to wander all over the level, wander into the traps, get themselves killed.
But the target experience I had, and it didn't quite work out, was to have enemies at junctions where the player could choose to circumvent an encounter or sneak past it and have some options, and use the fact that there's multiple ways into the space as part of that encounter.
Like I said, this is stuff that I didn't start thinking about until really late in Eldritch's development.
And it's kind of, this is what I want to leave you with, and this is the key takeaway, is this stuff made the game way, way better, and this stuff is not, like, mutually exclusive from random level generation.
the kind of rules that as level designers you've internalized, you have your expert knowledge of what makes a good level and how to build that.
If I had had that, I would have known to do this sort of stuff much earlier in the game.
I would have been thinking about these kind of things earlier instead of having to kind of stumble through it.
So that's what I want to leave you with is...
I hope that as level designers you can be super excited the way that I am about procedural level design, but bring the expert knowledge that you have that people like I don't have into it and find ways to do generated levels better than what we've seen before.
Make generated levels that are better than Eldritch because you know what makes a good level and because you've got that experience and that practice.
I think I actually...
plays through this a lot faster than I intended.
So that's my talk, thank you for coming and listening and we definitely have time for questions if you've got any.
So yeah, go ahead and use the mics if you have any questions for David, line him up.
this is going to roll right into the lunchtime portfolio review. So anybody who wants to ask questions for David, we want to prioritize those questions and then as those taper off, we're going to go into the portfolio review. For anybody who is leaving and coming back for lunch or trying to drop in early, what we're going to do is we're going to go through anybody who has portfolios that they want to get critiques on and if those don't take us all the way through to the beginning of the talk, uh, Brennan's talk at what time did we do? Sorry?
145. So the next talk begins at 145. We'll do portfolio for you until then. If we run out of portfolios we'll do an open Q&A with anyone who wants to talk to the speakers until that point.
I'm kind of in the same boat where I started out with programming knowledge and then I started going towards the design. So I understood some of your constraints. One thing that you mentioned that I haven't explored and I was curious about was you said you had problems with the verticality. Like you had some things and I was wondering if you could expand on some of the experiences you had trying to implement more verticality and what the negatives of that were.
Sure yeah the question is about verticality in the levels and if I could expand on you know some of the experiences I had with that building Eldridge.
One of the things I just kind of skipped over in the slide, let me see if I can get back there.
The...
When I was talking about like the safe regions in levels, the image on the right here is actually the safe region for vertical traversal.
It had to be wider than the one for for lateral traversal just because...
like what it takes to move vertically, you know, move up specifically, like falling is really easy in games, but to move vertically, you know, Elder Tech actually has a pretty sophisticated movement suite, like you can mantle up onto two meter high objects, you have powers that can just boost you into the air and things.
a rope gun so you can just shoot ropes into the ceiling and climb up them.
It has a lot of ways to move vertically, but I couldn't count on the player to have any of those at any given time.
So I always had, you know, when I would make a module that's supposed to connect upward, I would have to build like kind of these really ugly elaborate staircases up, and it ended up being kind of like all the worst rooms in the game are the ones where you're trying to move up because there's no space left for anything interesting to happen there once I've got it in.
If I could have done something where like I...
If I could have guaranteed that the player never had to move up and you just fell between levels, then it would actually be a lot easier to do that because, like I said, falling is really easy.
Thank you.
Thank you very much, it was really interesting.
Now, I was just curious, I see that you build a lot of tools and do a lot of tweaking, I just want to know how long did it take you from taking it to the first part until you felt that...
your tools were already generating really good levels.
Right, so the question is how long did it take, I guess between the first pass version of this and when it was, when the levels were good or when the tools were good, which are you asking?
When the levels were good, where you felt like, okay, I'm not touching it anymore, it's good.
I'm not sure I can really say.
The development of the game was so accelerated, and even up until the very end, I was still changing things.
I also built the levels chronologically, which is kind of not a best practice.
So the first world in the game was the first one that I built.
And I think you can maybe see that in the game, of the first world is a lot more experimentation.
And by the end of the game, I had figured some of that stuff out.
But the tools actually didn't change too much.
It was just, like I said on that last slide, it was figuring out what worked.
to make a good level and how to guide the player in a random space.
Thank you.
Hello, thank you very much.
I would like to hear any comments or tips for non-scripted people and the downfalls of using or scripting the procedural system rather than using a dedicated software for generating that.
Thank you.
Was that a question?
Okay, say for example Houdini, who is a dedicated software for procedural generator levels.
What are the downfalls of actually coding your procedural stuff and using a 3D package?
Right, right, right, I'm sorry I misunderstood.
What's the advantage of using an existing solution for procedural systems instead of writing my own?
So I actually haven't evaluated, like, I mean I didn't even know that sort of thing existed.
I think in the case of Eldritch...
It's kind of the same problem I have coming from AI programming of like so much of procedural level generation is kind of innate to what the game is. I don't know if there's a solution out there that would suffice for exactly what I was trying to make. And also I mean honestly this stuff like I probably spent about two weeks working on the tech and two weeks building the levels like a relatively small portion of the time I spent making this game was actually spent on this stuff. It didn't take that long to get to where I was able to start generating levels on this.
If I were trying to do procedural levels on a big budget game and there were much bigger requirements, I probably would consider using something like that.
But I don't know.
I haven't tried that.
All right.
Hello.
Thanks for giving your talk.
Sort of more of just a overall development question.
You said you built your own game engine for this game.
How difficult was that?
Do you think it was worth it?
Do you think that it gave you tools you needed that you wouldn't have had otherwise?
Or do you think you might have saved time using an existing game engine?
So the question is, was it worth building my own engine for this game?
So, I sort of misspoke.
I didn't build the engine during the eight months I was building Eldritch, like that would have been impossible.
I've just kind of been as a hobby building an engine since.
eight or nine years ago, and so it's something that at this point is pretty mature and something that I'm, like I work very efficiently in.
It's kind of like if I had my own licensed engine, like that's just how comfortable I am in it and how capable I am in it.
So I wouldn't necessarily recommend it to everyone.
For me it was kind of like, you know, I'm more efficient using my own code than I would be like if I were using something like Unity or Unreal, but I wouldn't recommend it probably to anyone else.
I don't know if you have enough experience with Unity or Unreal, but if you want to do something like this in an existing engine, would you have any recommendations?
Good question.
I think there are tools on the asset store for Unity.
I know that some people have done procedural levels, like in even going back to the original Unreal Engine, it's sort of different because it tends to make assumptions about how AI paths are built and things.
It assumes that the world is static and not pieced together at runtime.
But yeah, I'm sorry.
I can't really speak to existing solutions.
It's OK.
Thank you.
Yeah, thanks.
If you were going to make a sequel to Eldritch, how would you modify your algorithm going forward knowing what you now know having made Eldritch?
Good question. That may be something I'm actually thinking about.
So one of the things I wanted to do on Eldritch, and I kind of just got rid of it because of trying to do everything as simple as possible, but I wanted to have modules that were different sizes.
One of the key constraints here is that every module is just 12 meters by 12 meters.
That's not a lot of room to work with.
And I had planned to have support where, if I could search the maze for a fit, and I could say, well, here's a space where I could put in a whole big mine shaft, and then I could design that as a sort of unique feature.
That would be cool in that it would give me a lot more visual variety and sort of cohesion to the levels.
And if I weren't doing the Lovecraftian thing, I think that's something I would almost definitely have to do.
It was just kind of a trade-off that I had to make on this game to get it done fast.
But yeah, if I were doing that in the future, I think I would want to have the ability to make modules that were different sizes that could still join, you know, it would still be on the same grid as the maze, I think, because that's, you know, that's just a nice feature to have.
But yeah, the ability to do modules that were different sizes would be a big one.
Thanks. Thanks.
Thank you.
Thank you for the talk.
I was wondering about the overall pacing in your game.
How were you able to shape that? Did you do playtests?
Yeah, so the question is about pacing in the game and how was I able to get it to a shippable state.
I did do a lot of playtests over the course of development.
It was also a game where one of my key values was like, you know, I love immersive sims like Deus Ex, Dishonored, the sort of things I mentioned at first.
And so I wanted to have this sort of value of like play it your own way.
You can kind of build up any set of powers and weapons and always have a solution to the map.
Which meant I couldn't really control pacing at all.
I just kind of had to throw a bunch of features in and hope that the experience was good.
It ended up being kind of a system soup.
It doesn't have great pacing.
The only pacing I could do was like, you know, like I said, ramp up the number of enemies over the course of the game.
You know, in between levels I could say, and I could give like, you know, scheduled item drops and say like, in the first world of the game, you're not gonna get the most sophisticated powers.
You'll kind of, you'll get there eventually.
But yeah, like within a level, I really had no control for like, encounter pacing.
It was just kind of like, stuff's gonna happen and I hope it's cool.
Thank you.
Cool, thank you.
I think that's everything.
Alright, thank you for your time.
Woo!
Thank you.
Success.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
Thank you.
