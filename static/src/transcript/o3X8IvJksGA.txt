Hi there, I'm Shirvin. Welcome to Growing Your Code Library with each new project.
I have my Twitter handle there if you want to follow me after the talk or ask any follow-up questions, that's totally fine. A little bit about me, I make games primarily as a freelancer.
I'm also working on a game called MidAutumn right now, which I'll talk about at a later point.
So when I say I work as a freelancer, what that means is I don't work for any particular studio.
Most of the time I mostly have in my career in games, worked for a variety of studios on a contract basis.
Sometimes that's like a week, sometimes that's a month, sometimes it's six months.
And as I've...
kind of made my career in games.
I'm sure in Games Career Seminar, you're gonna see a lot of different ways that people have careers in games.
But for me, I've noticed that what's really helped me is to, in the same way that a lot of big studios have their proprietary technology that they develop over time, to do something similar as an individual is to kind of take the stuff that I worked on and use that to help me make games faster and more easily.
And that's kind of what I'm planning to talk about when I say code libraries.
So a couple caveats up at the top, pardon the pun.
You know, I'm just one person. My opinion at the end of the day might not be right for everyone.
So if you're watching this talk and what I'm saying really doesn't make sense for you, feel free to ignore that advice.
What I'm trying to offer here is tools that help me address kind of the complexity of making games.
Often, you know, remotely with just you in the room, which is.
very difficult when you don't have people to bounce ideas off of or anything like that.
So if that's something you're struggling with and you don't know how to approach that, here are some potential ways to address that.
So big sweeping statement right at the top of the talk is making games is super hard already.
We don't have to make it harder on ourselves.
I think sorry, I bumped the mic, but I remember when Pokemon Sword and Shield came out, Game Freak got a ton of flack for daring to reuse their their Pokemon models across all their games.
And I'm here to say, like, absolutely do that.
That's exactly the way we should be making games.
People know what Pikachu look like.
Like, like people know what Pikachu looks like.
You don't have to, like, make a hundred different variations of things and reinvent the wheel every single time.
You know.
If you have a chair in your game, and no one's going to notice, reuse it.
If you have a dialogue system, it's going to work the exact same way, reuse it.
And that's the main philosophical kind of underpinning that I'm trying to get across at the top of this talk is, you know, things are hard, make them easier on yourself, reuse things.
So, you know, I remember finishing my first project in games, and it was...
you know, daunting to say the least.
But at the end of the day, I think I got through it just because there was so much I didn't know.
And and I didn't really know enough to psych myself out.
Once that happens and you realize, oh, I have to make another game, if you want a career in games, you're going to be making a lot of games. So it's a lot harder the second time around, because you know exactly what goes into games, you know, it went into the first one.
And if you're stuck at this point, I'm here to say, you know, there's a flip side is now that you've made at least one game, you are more infinitely more able to prepare.
And I haven't just used this gif of Batman here to be cute.
I think this is a great analogy for for how you can approach things to make things easier on yourself. Right.
And it's clip Batman's on the ocean and a freaking shark appears out of nowhere.
And he just has shark repellent in his utility belt like that.
He's he.
had prepared from long ago. And I'm saying that we can totally be like Batman. Now imagine that a game is just, you know, some combination of sharks. These are problems you have to solve or features you have to implement or whatever. They're all sharks now.
You just have to do the exact same process, right?
You make sure that you have your BAT shark propellant prepared.
And in this case, we're going to be talking about POE templates.
They go in a place you can find them easily, right?
Then that's your utility belt.
And when that shark shows up, you just, you know, pop that out of your utility belt and you're good to go.
You know, obviously that's an oversimplification.
But...
you know, when I'm talking about a code library, what I mean is essentially a collection of helpful resources, right?
And they should be reusable. I'm probably going to be saying reusable a lot in this talk.
So I've bolded it. It should be, you know, backed up somewhere you can access.
And I'm primarily going to be talking about code templates or pre-written code.
But it really can just be things that help you out.
So if you like using a particular software and you want to be able to access that easily, if you have particular settings you like for that software, you know, then you want to write that down somewhere.
Some kind of documentation or links to articles or videos. That's all like that should all go in your code library in my opinion.
So Essentially, going back to the shark repellent metaphor, you want to make sure that everything in your code library is, again, reusable, but it should solve a specific problem.
The shark repellent is so like, because.
It only fixes sharks and it doesn't solve anything else.
It's lightweight, it doesn't need a ton of setup, you know, it's self-contained, and it can be combined with other things easily.
That's like the ideal thing to go in your code library.
So let's talk a bit about how you might maintain a code library, right?
So what definitely doesn't go in?
You know, you don't want to put in full project files or like really specific kind of fiddly systems that are designed to solve something that won't appear in other projects.
But as a, you know, as a counterpoint, you should absolutely still keep access to these things because you might realize, oh, you need this exact thing from this other project that that you wouldn't ever have guessed you need.
And in that case, don't go to your code library, go to your actual project, get that specific thing and then chuck it in your new project.
But definitely keep out things you don't own or are not licensed to use or something that you currently are licensed to use but might become a headache in the future.
Keep your code library safe.
you know, helpful, basically. Don't make it so you have to worry whether you're able to use something or stress out. Have it be things that you can just use at a moment's notice.
So the basic process, right, of making a code library is just like, it's mainly housekeeping, right? So the best time to do it is right after you finished a project and right before you're starting a project.
however, you know, long that stretch is between those two points. You're going to look for some code or some assets in an older project that you'll think you'll want to reuse. You're going to get rid of any elements that tie that to that specific project. You're going to make it really generalized so you can use it in a variety of different projects. You're going to just name it something that you can find really easily. I mention this step because I think often when we're working on a project, the code or assets or whatever really specifically named.
So you want to generalize that as well and then just store it somewhere you can easily access in somewhere you can intuitively find it.
Right? So like make sure that you have a file organization system and I'll get into that a bit later. And like the main note here is don't worry about getting it perfect. This is just like you know, a habit that is good to cultivate. You know, when you do it, you spend a few hours, spend a day on it, and it's okay if you don't generalize it that well, or if you overlook something, right? You want to think of this in terms of like a career-wide span of time. So each time you finish a project, you're going to have an opportunity to revisit that and realize, oh, okay, this actually was way too cumbersome to use, and I'm going to either get rid of it, I'm going to change it, and you're going to have plenty of opportunities to do that. So I'm going to talk about how I kind of think about identifying things to go in a code library. So here is a non-shark-based model of a game. This is kind of based on how a lot of mobile studios kind of think about games, but this is, you know, 50% I made this up for this talk.
So it goes pieces, core loop, metal loop, accompanying systems, and I'm gonna get into this.
So here is an image from Queen's Gambit to help me out.
So imagine the game of chess, and you have your chessboard and your pieces, and those are what I'm coining as game pieces.
So these are just things that kind of go into your game, things like character controllers or health systems or physics.
you know, the kind of building blocks, right, of your game.
And then you go out a bit wider and you get what is your core loop, right?
That's like the game of chess.
Those are things like your rules and your procedures.
So if you, you know, if you're familiar with game managers or resource systems or loop drops, they're the things that take your game pieces and turn them into a game.
And then you have your meta loop.
And I like to think of that as a chess tournament, right?
Chess has its own rules, but this is the meta game around chess that you're trying to also progress through. So that's things like, you know, managers for your overworld or your hub, progression systems, quests, different ways to kind of progress on a meta level. And then you have accompanying systems, which I think of as a tournament venue, right? Like, this is like, not necessarily even have to be used for chess, this building.
whatever. So these are things like your menus, you know, localizing for different languages, things to help with that button prompts, saving systems, these really could go in any game, but are pretty much, you know, needed for whatever game you're making. And when you're thinking about games this way, right?
It's really easy to swap things out, right?
You can have a completely different metal loop on top of a core loop, which means that that's how you're gonna reuse a lot of these systems when you've identified these scripts and put them into place.
So where, now that you have, right?
You've found some, you've identified some code, where are you gonna store it?
You could.
use version control, you know, there's Git, Perforce, Mercurial, and you could use cloud storage, Google Drive, so I'm going to be sharing some examples of like a code library later in this talk, and I've just put it up on Google Drive because that was easy for me.
It really is just like use what is, makes sense to you, for you, what's accessible, which is like what I'm gonna say a lot in this talk, basically, do what works for you.
So once you, yeah, once you know where to put it, you're gonna organize it, you know, you can organize it around a lot of different ways.
I primarily organize it around systems.
So like, I'll have a folder that says dialogue or a folder that says menus or save or load, and those will have, you know, a bunch of scripts that might be, you know, dependent on each other, which means I can just take all those things, drag it into my project, and hopefully they'll all work. But here's some potential other options, right? You could organize it around tasks, right? Some people like to think of things in terms of what they're doing at the moment, so you could have a bunch of scripts that are helpful for when you're prototyping, or when you're building levels, or animating, and this might have a bit more repetition of the types of things.
way to do it. You could organize it around the game structure that I mentioned earlier, right? So the game pieces, core loop, meta loop, etc. If that helps you. That definitely helps me, like, identify a lot of these things, but it's not necessarily my favorite way to organize things because it's kind of hard for me to search. And then you could organize this around type. I don't necessarily recommend this because, like, you know, it's like, oh, what is a manager, what is a controller, is kind of, can be arbitrary.
So I don't think it's a very intuitive way to do things.
But if this makes sense for you, that's a potential option.
So, time for some examples.
Okay, good, I'm doing great on time.
So, I'm here, I'm going to start talking about MidAutumn, which is a game I'm working on right now.
I'm going to use that as some specific examples of how I make use of my code library.
So, MidAutumn, it's a roguelite about blasting evil spirits, and it has a persistent narrative about Asian diaspora culture.
If you're interested in the game, you can follow me on Twitter.
We're also having a Kickstarter related to this year, and you can use that link to get to it.
MidAutumn underscore KS.
I realize it's underlined, so I guess the underscore isn't obvious.
So example number one, right?
Let's see how I used a sound effects controller, and I made it reusable between projects.
So I'm going to talk about a project that I was working on before mid-autumn called Black Current, which is just this little puzzle RPG game that I had.
and I had a sound effects controller in it that plays, you know, sound effects when I need to.
And this script is basically just a list of audio clips. It has a couple basic methods so, you know, it can play an audio clip, I can set the volume or the pitch.
It also had a couple very specific methods that's like play a random footstep or play a random blip dialogue.
or play a random attack sound.
It was also a singleton.
And I want to make a quick aside to talk about singletons.
It's basically, I can't go into it in this talk, but it's a class that you make that's globally accessible and there's only one instance of it.
And what's really great about singletons is that you can toss it into a project.
and all of your other scripts can just reference it right away.
So yeah, if you need something that's easily accessible for a lot of different scripts, it only needs to exist once. It doesn't need a lot of setup.
really, really useful. And then a warning up top, you probably don't want anything or most things in your code library to reference different scripts, singletons included, because then you can't just toss it into your project. But I definitely recommend reading up on these if you're interested in making things kind of easier for yourself. So anyway, yeah, so we have the singleton, we have the sound effects controller, so...
Let's see, what did I do here?
This is, yeah, so this is just an overview of the same scripts here.
So again, list of audio clips.
Here's some examples of how the methods might work.
So I would just write play, and I'd have the type of the sound effect, or I'd play a random footstep.
And this is what I did to generalize it, right?
So it's still very similar, you know, I still have a list of audio clips, still have that basic play method.
I added a couple things that I might want in other projects.
just based on what I thought might be useful.
So like you can change the pitch, but you can also change the pitch across semitones.
You can also, it also takes a custom audio clip.
So in the old one, you know, I had to add this.
I basically, every time I wanted to add a sound effect, I had to add to this list of audio clips.
And that.
um be kind of cumbersome if you're tossing it into a project so now I can do that or you know if I have another script that has a specific audio clip I can just like use that as a reference and play that. And then I got rid of all of these specific play random footsteps, play random dialogue blips, because I didn't know if my game was going to have footsteps or dialogue or attack. I don't know. So it's turned into this kind of more general play random method.
that just gets fed a list of audio clips.
So now if I have my character controller, it can have a list of footsteps in it and just send it to the sound effects controller with that list and play a random one.
And that's kind of the main idea here when you're generalizing these scripts, look for these methods or things that are, that have assumptions about the type of project you're making.
And...
take that out, right, if that's helpful. So let's see. Here is, you know, another example of how these methods work. So you can still do like play, you know, and say the type of sound effect that you want to play, or you can...
you know, play random, give them, right, the list of footsteps from your player class.
You can also play the player's attack sound, like, and then raise it up three semitones and do whatever you want with that if you want to have your game be more musical.
So example number two, right, is going to be extending the same dialogue system for two different genres.
So in the past example, we talked about that process of generalizing the script.
So now we're going to start from.
same generalizable script, right, and implement them into two projects with different needs.
So you're going to start with a dialogue system and I'm going to use Blackcurrant in mid-autumn as specific examples. So in Blackcurrant I just had little speech bubbles that popped up above the character's head and in mid-autumn we have dialogue boxes at the bottom of the screen, there's a character on the side of it, and their name is also presented.
So under the hood, these both use the exact same dialogue system, or rather the same starter point.
So this is the generalized script, right? It's got a dialogue line, which are your lines of dialogue.
It's technically a localized string that I use, which is set up for localization.
But let's, for ease of purposes, let's just say it's just text.
And then it has a reference to the speaker, your actor.
The actor has a name, it's got a unique ID.
I recommend having unique IDs in a lot of things, because every single time I make a game...
and then I don't put unique IDs and things, and then I start trying to save things and reload things.
I just go back and add IDs to things because I realized I needed them.
So that's super useful.
I'm calling that out.
So yeah, that's your actor.
It's basically just.
the name is the main thing with the actor and as a reference to it. And then we have what is a story beat, right? So like this is, you know, hard to name, but it's called a story beat because it's just that like kind of segment of story. And it's just a list of dialogue lines, right? So your lines are your individual things in the conversation and your story beat is just that list of it.
And it also has a unique ID because again, that's super helpful.
So for Black Current, these were the constraints, right?
The dialogue is occurring kind of parallel to gameplay at times.
So sometimes you'll be walking around and a speech bubble will appear.
All of the dialogue events are fully authored.
So that means I've gone in and I've written every single.
thing and they appear linearly in order as I expect them. The game has 3D characters, they move, they have animations, and the speech bubbles specifically appear over the character who is speaking. And I think they're also tinted based on which character is speaking. So this is what I did to those three generalized scripts to make it work for BlackKarin.
So you can see that I, if we go and compare this, this actor script is now completely gone.
And it's been replaced by a character data script, which was just a more robust thing that I already had for the characters.
The dialogue line now has a reference to the character data instead of the actor.
It also added a thing for animation or display time, right?
So now these dialogue lines can play an animation at the same time or they have a reference to it and I can control how long that line appears when that speech bubble appears And that character data was just this really robust script that you know, it moves the characters it tells the characters what they're like you know, abilities are, but it also already had references to where their, you know, character was in space, what their color was, so it just made a lot of sense to fold that in into the system.
And then the story beat class, you know, just got a couple, like, tags, essentially, like, should the speech bubble advance automatically? Should it freeze the player in place? Should it make, like, little letter boxes come in for cutscenes?
And it's, yeah, besides the big character data change, it's not too overwhelmingly different.
And so for mid-autumn, right, in comparison, the dialogue it drives gameplay progression. So what that means is things will happen based on whether or not you've heard certain dialogue.
So like you'll get different enemy spawns if you've heard a certain conversation or something like that.
kind of spawn in everything from a procedural dialogue pool.
So it's not linear. There's a random kind of chance of which conversations you're going to get.
And unlike Blackcurrant, the dialogue box is always going to be in the same position on the screen.
They're 2D characters. They don't really animate. And each character has a higher resolution portrait. So if you look at how this has changed, right, you'll see that In comparison to Blackcurrant, which had most of the changes in that after character data script to account for the three key characters, you don't need to do that for MidAutumn, but I needed to add a ton of stuff to the Story B class.
and I will go through that.
So like the dialogue line hasn't changed much.
There's like a portrait index that's there in case you want to use different character portraits.
The actors have nicknames that appear kind of underneath their their name.
They also have an associated color.
They also have a default location.
So in Black Currant, I didn't have to worry about that because all of the location and where the character is going to be was handled by the character itself. But in MidAutumn, I need to place specific characters based on...
where they're going to be for the conversation to make sense.
So needed that.
I also needed references to what the different portraits they can have.
And then, yeah, the main meat of the change is in the story beat class because of accounting for this procedural narrative elements.
So each story beat now has a reference to the actor, not the dialogue line itself because.
Sorry, the dialogue line still has a reference to the actor, but the story beat also has it because I need to know which, um...
basically every time a different character appears with dialogue, I have to go through each of the story beats that are associated with that character and then put a random one in there.
So the story beats now also need to know which character it's associated with. They have things like priority, so like higher priority story beats will appear sooner than lower priority ones.
They're associated to a location and they'll move the character to to that location if that's the story beat you've picked.
They also have these last four things, which are like beats to unlock, beats to disable, prerequisite beats, concurrent beats, because so much of the gameplay is driven by dialogue events, then you need to know like, okay, the player's heard this conversation, what other conversations are now possible?
Or what other conversations should not be possible because they contradict.
the one that you just had, you know, what conversations need to already have occurred for you to hear this one and don't like populate it if they haven't occurred yet? And also, are there any conversations that should appear at the same time.
So, like, an example of that is a character telling you, hey, you should go talk to this person, and then, you know, later on in the hub area, you'll run across that particular person and have a conversation with them.
And you want both of those to be present at the same time, even though it's random.
So that main kind of conclusion here is you can start from this like really simple generic starting point, which is purposefully right doesn't have a ton of functionality. Because I don't know what I'm going to actually want to do with each project yet. And then they can really, really change over the course of development and like you know, already the, this is like, you know, open to changing more, right?
Like, I think I've added, um, things for like, like voiceover functionalities here. So that's also going into, um, like the actor script or things like that. And, and keeping your generalized scripts really simple makes it a lot easier to do stuff like this instead of trying to cram functionality into it.
Okay, yeah, so example number three is going to be extending a generic enemy controller to add variety really fast, right? So in mid-autumn, sorry, voice, geez, in mid-autumn...
We started with this generic enemy controller.
It's full of virtual methods, right?
And the reason I'm using virtual methods here is that they're kind of not super cumbersome to use.
When I, let's say I wanted to make a child class, right?
So let's say I have the enemy controller class and I want to make something like a fast enemy, and I had a virtual method called move.
The really useful thing about virtual methods is I can change that move method to, you know, make sense for that new enemy type. But if I didn't want to touch it, it can have a default behavior that just works like all the other enemies, and I don't have to override it. So, like, the comparison there would be using something like an abstract class, which kind of has to override and make changes. So it's really useful to have a way of structuring these enemies where I can make them, it can modify them for their like unique elements and then not worry about everything else. So I'm like, okay, this enemy is going to know how to walk. I don't have to re-teach it how to walk every single time I make a new enemy. So starting with that kind of very basic generic controller, it had these kinds of methods.
an awake method that kind of just sets up initial starting data or relationships, references, a setup method that kind of gives the enemy everything it needs to do to function.
There's an on spawn method, you know, if I want to do something when it spawns for the first time, like, you know, like maybe some enemy like spawns and there's like an immediate explosion.
Then there's a number of things that have to do with how the enemy behaves.
So choose next state is like, oh, how does it, the enemy decide, am I going to chase after the player? Am I going to run away from the player? Am I going to go to a particular part of the area or something like that? Enemy behavior update is great for like, you know, things that need to be called essentially an update function.
So it's like, oh, does this enemy constantly need to be tracking the player's health for whatever reason? Maybe that goes in the behavior update or if something needs to be calculated based on the player's health or something like that, right? Has an attack function.
In mid-autumn a lot of the enemies have ranged attacks. So that's kind of like what that that default is as a take damage function and you know where it gets hit and there's recoil or has some vulnerability and there is an on die function So if I wanted like an enemy to explode when it died or if I wanted a certain dialogue event to trigger when it dies, that's what I could do use that for. And this is all just in the generic EnemyController that I had from my code library.
So the first step was to add some specific functionality based on the constraints or the design goals that MidAutumn needed.
If you are looking at this little gif here, you can see that when enemies attack, they actually have this little VFX stuff that plays right at the start of their attack.
So enemies needed to be able to play certain VFX or particles or things like that at specific points.
So I added a method that does that.
I also didn't initially have this melee attack method here in the base enemy controller, but this is the really useful thing about starting with these generalized classes is you can have this class, you can make kind of a couple subclasses, and I was able to realize like, oh.
I'm implementing this melee attack like three times.
I'm just going to move it into the base class really quickly.
And because the scripts are so lightweight to start with, that was really easy to do, especially early on.
So all the enemies are capable of melee attacking, even though half of them aren't going to ever use that.
I also added this tag system for the enemies.
So for example, in this...
clip right here you're seeing um these turtles with like the yellow kind of outline around them and so they have a shield up which means if you attack them um you're not going to damage you'll damage their shield but they're essentially invulnerable while that is up and I can know um from the player's point of view, right, that that enemy has a shield because it has a tag that says shielded. I can add that to any enemy I want. So I could do something where it's like, oh, if the player has this specific attack, maybe it has a special effect, right? If you attack a shielded enemy, maybe it makes the shield explode. So I can know that, you know, from just the enemy's properties. So that's the thing I added.
that was necessary for this game.
But again, if I was implementing for a different game, I might not need that.
So, it's important to keep it light and add them later up.
The enemies also have...
you know, little pop-ups of text that appear when they take damage, that say like five, six or whatever the amount of damage they take.
They have little health bars that update, and they also can sometimes trigger dialogue.
So if I wanted them to do anything in particular when the dialogue ended, like use a specific attack or something, I added a method for that, which kind of ties into how everything in MidAutumn is super dialogue-driven, that even the enemies have like dialogue-specific methods.
So.
The first kind of enemy I made with this, after setting all that up, was just a simple melee enemy. These are our face cuddlers. They're just these little floating heads that kind of move slowly towards you, and then when you get too close, they'll lunge at you. So I changed the attack method to essentially remembering that I have this generic melee attack function.
So when it attacks, it just uses the melee attack function instead of anything else.
It used to be more complicated than that, but I actually simplified it more.
And then once I made this enemy, I added two types of tags, right?
Melee enemies and ranged enemies, because now I can differentiate between them.
And then really quick, the second enemy I made was just a radial attack enemy controller.
In reality, I made the ranged enemy.
next probably, but this is just a thing that I did almost immediately after that, which was we had ranged enemies and I made one that could do kind of a circular attack instead of a regular ranged attack. And all I had to do was again modify that virtual attack method and now this enemy works. And both of these enemies, the melee and the ranged, are essentially the same enemy. Maybe their settings are different, maybe their health settings or their speed or things.
are different, but the actual script, besides from the attack method, are functionally identical.
Immediately after that, I was able to add shielded enemies, which I mentioned earlier.
So these, obviously, from the length of the text here, took a little bit more modifications to the original script to add shields, right? So, the setup method changes because I need to set up the shield. The update method because I need to check, oh, is the shield up or down, or what's the shield health, or is something happening based on that? And the take damage method obviously is the main one that's changed, where when you take damage, instead of just taking damage, it just checks, oh, is your shield active? And if so, you don't take damage.
added that enemy tag for shielded so that the player can check or other things like the game manager can also check for shielded enemies or things like that if I ever wanted to. And I added two new virtual methods. And I think this is where that level of variety starts to snowball, is when you start adding more virtual methods in your child class, right? So now I added a method that says take shield damage. So when your shield takes damage, this is what can happen. It might not even take damage if I don't want it to, right? And on shield death, if the player ever, you know, does enough damage to your shield and it drops, does anything specific happen, right? You could have the shield explode when it takes damage or something like that. So...
The really cool thing about this is now I have this basic shield enemy and that's how they all work, but I could easily make a harder version of a shielded enemy for later on in the game, or like a variant that kind of builds off of these and is essentially a shield enemy, but with a couple twists. Really easy to do that, I would just override the shield damage or the shield death method or something else. And once I had these first three, then I moved on to making a quick boss enemy. It was really simple to do this.
The really cool thing about this is you can make bosses really unique really quickly when you have all of these virtual methods to modify as you want.
I modified its choose next behavior method because this is a boss enemy. It has a more complicated logic behind why it does things. It has some unique attacks. It has some special logic with its take damage. For example, once it takes half of its damage, it enters a rage state or it triggers its second phase of attacks.
And then on die, I basically just triggered like a dialogue event so that, you know, there's some cool narrative stuff happens when the boss dies. And then I added an enemy tag for bosses, which is basically being used so that, oh, if you go into a room and there's a boss, an enemy with a boss tag, a special health bar is going to appear over it or something like that.
So.
real quick, right? Four different types of enemies. And then I made a second boss, because why not? This is very similar. If you look at this one, the comparison here is that I didn't need to... Actually, I probably did actually change its attack method. I probably just didn't include it. But this boss has a lot more narrative kind of motivation. So it has like some unique setup elements, again, some unique AI and why it attacks you at certain times. This boss, I think what I ended up doing was when it takes damage, it builds up like a resource.
And if it has enough of that resource, it will use its more powerful attacks.
So really quickly, it was able to just implement kind of a rubber banding mechanic, where if you're doing really well against this boss, he's doing more damaging attacks.
And if you're not, maybe he's going to avoid those.
And then again, triggering some special dialogue when this boss is defeated.
And then, yeah, here's like a completely new type of enemy, right?
After making those two bosses and three enemies, I was like, kind of thinking about what is a new kind of twist that we could do for like a second area.
And so this is an evolving enemy that starts from this tiny little mushroom guy, and they kind of hulk up into this bigger mushroom guy.
And, yes, it still, like, surprisingly didn't take a ton of work to make, right?
Like, I changed how the behavior update works because it just has a check for if the enemy is evolved or not, and it does a...
the typical behavior if it's evolved. And if it's not evolved, it's going to be kind of trying to evolve, which means it's going to go look for little resources to eat and get enough of those to evolve. And then its attack, again, is different because it just checks, you know, if it's evolved, do this better attack. If it's not evolved, do this weaker, not as good attack.
um added a new enemy tag for evolving so I can check if there's any of those and new virtual methods here for what happens when you evolve and what happens when you devolve which I haven't used yet actually in the game but it's there in case I want to have something where like oh the player does a ton of damage and the the enemy devolves um and then let's see yeah this next enemy I think this is the last enemy that I've included in this talk, it was just a toxic enemy controller.
And this enemy just kind of passively puts out kind of damaging particles if you get near them.
So just, yeah, I needed to set that up in the awake method, update that and modify its attack, added a new enemy tag.
And really quickly, this, you know, each time I worked on this, you know, it took me maybe like, an hour to make each different enemy type. And a lot of that was fiddling, being like, what do I want? So the really useful thing with all of these, using these kind of pre-written code templates, and then being able to make this is when I wanted a new enemy, it was really quick to just pop in that enemy controller script, set it up, and then just start focusing on variety and what I actually wanted the design to be.
And when you set this up in a way that helps you, it's like you just have all these levers you can kind of pull to make things work more quickly and effectively. And so I was able to focus a lot more on that. So yeah, let's just kind of to summarize everything, how did reusing all this code, taking a code template and kind of throwing it into MidAuto actually help while I was working on the prototype, for example. So.
It was really a lot faster than it would have been.
I was able to work on this on my own project, right, essentially, while still maintaining my main kind of living and games, which is working as a contract freelancer.
And when I'm working on MidAutumn, I don't make any money off that, so I still need to.
do other work. So I don't have a ton of time to work on this when I'm working on it. It's usually like a couple hours to four hours, maybe like a week. Another thing that happened is, right, I mentioned Blackcurrant, which is just another prototype I made back, you know, last year or two years ago or something.
And when it takes you less time to prototype, you don't have to sink as much investment into each project that you work on. So it was real easy for me to just be like, I'm gonna stop working on that one, I'm gonna work on this one, or I'm gonna move on to another one. I think when you take more time to prototype things or to test things out, there's a lot more opportunity for sunk cost fallacy to kind of sink in and then for you to feel like, oh, I've spent so much time on this. I've got to keep like doing something with it.
So that's like my main takeaway from this is making things easier, making it take less time to do things, makes it easier for me to throw things away, for me to follow different directions.
And Ultimately, putting the code library in made the Unity engine, which is what I was working in, more comfortable to work in.
And I think that's the main thing we should be trying to do.
Especially if you're a solo developer, you don't have a ton of support.
When you're just working in your room, you're not in a space with other people sometimes.
for me as a freelancer, I'm going to have to start a project, ramp up and finish it within a week, which is incredibly challenging sometimes.
So I spend as much time making sure that my work environment is as comfortable and supporting my kind of productivity as possible.
Yeah, just not having to think about, OK, how am I going to implement this and spending more time on, OK, this is what I want to do was super helpful.
Another way it helped was in shareability.
So I was working on the mid-autumn prototype.
I probably started it on last end of last year.
And after about a week or two, the builds were essentially self-playable, like they weren't necessarily fun or good or anything like that.
But, you know, I tossed in menus, I tossed in saving, you know, which is not usually what you have when you're making a prototype. But what that meant was that, you know, I had all that kind of core loop in and it was a much more functioning prototype than I otherwise would have been because I was reusing a lot of this code that I already had.
I had more time to work on debug features. So like if when I shared the build of the people for the first time, it had like a menu in the top right corner so you could just like skip a particular room of enemies or you could play whatever dialogue event you wanted to kind of break the game and get into a particular state.
And yeah, and you could kind of switch between the hub and the dungeon, you know, at any point.
And.
Normally, if you're working on a prototype, you don't always have time to make those debug features.
And it's really difficult to justify spending time on that.
But, you know, having that, having the menus, having saving, meant I could just send a build to someone.
So when I started, you know, collaborating with other people, or when I started emailing people about the game or things like that, I could just send a build.
I didn't need a ton of instruction.
I could pretty reasonably expect that they'd be able to play it.
So that's like super, super helpful when you're, when you, when you're, especially this past year, when you're working completely remote, when you don't have a ton of, um, any means really to sit next to someone and walk them through what you're working on, um, being able to add that extra functionality quickly, super helpful.
Um, another thing that.
code libraries have really allowed me to do when my own projects are like on contract is to target accessibility.
You know, a lot of the time.
accessibility features don't get implemented because people aren't thinking about them from the start of a project. But when you are kind of putting together a code library, you can make sure that you have at least like starting points for a lot of these features. So like controller remapping, right? That was something I worked on on a past project and when I was working on Minitom, I just tossed that in into the settings menu and, you know, it has the same bugs that it had from the previous project, perhaps, but it's there and I can continue working on it. You know, have a setup to help colorblind testing, making sure that that's working, you know, high contrast mode, and just more types of settings because You know, once I've implemented that setting once for most games, that's that's pretty much how it works.
Right. Volume isn't going to change that much across games or your resolution or things like that, unless you're making a very specific game.
And then that's.
the really helpful thing is everything that's specific, you get more time to work on and everything that's not, you can reuse the stuff that you want to use.
And the other thing that was really helpful, right?
Like is exactly that, right?
Increasing your scope as in spending more time on those unique things.
I'm sure I mentioned a bunch of times that I got to spend more time on design, art, narrative, less worrying about how I'm going to do things. I was able to experiment a lot on like high priority features. So, for example, we spent a lot of time on our combat system, how that works.
Should it be more straightforward? Should it have kind of this more unique idiosyncratic way of working? And if I wasn't...
solid about all the other stuff that had to happen, like menus and moving the character and things like that, I absolutely wouldn't have experimented on that.
I would have picked a more straightforward, easy-to-do option.
that would have been that. Also, you know, using pre-existing tools, right, like dev tools take an incredibly long time to actually be useful. And if you've made a couple in previous projects and you and you have them ready to go, they can really speed up how long you're able to implement things. In mid-autumn, we had like in the prototype.
like 200 different narrative events to really test the whether the procedural narrative is working. So which meant I had to implement 200 narrative events and thankfully I had a tool that helped import a ton of like text into the format for my dialogue system. So that really sped it up, you know, by taking something that would have taken two weeks and scrunching that down into a day or two is a huge win when you're, you know, when you have like, you know, really a month to work on a prototype sometimes, if at all. So.
The other last thing is that having things like these code libraries makes it a lot easier for you to help out with, you know, your friends or colleagues. The games industry is a very small industry and it's really, really great to be able to share things with each other if you have something that works.
you know, I put together a sample library for people to check out here as well.
You can access it at bit.ly slash gdc code library.
And yeah, like if you didn't, if I didn't have a code library set up already, then when people ask me like, hey, how did you do this?
Or how did you do this sample or this particular feature?
Could you help me out?
I would have to go look at my code and kind of make it.
like actually shareable before sending it out, but instead I can really quickly be like, here is this kind of generic version of what I started with. If you want more specifics, then we can like talk more, and that's super helpful. And also, like...
When I'm on other projects, right, when I'm doing the primary, the main part of my career, which is kind of working on contracts, I have my own kind of library of resources to work to reference when I'm working on the project. So, you know, let's say I have to build a dialogue system for a different studio and they have a number of constraints.
or they've partially implemented it, I can kind of reference my own work to be like, oh, maybe if, you know, I did it this way or modified it here, that would help with some of the issues that that particular studio or team is having. And it makes you more able to be competent, more able to be timely on the things you're working on. And yeah, it just makes you a better collaborative member of teams, I think.
So I want to say right at the end that, you know, I think as game developers, we should be avoiding like reinventing the wheel and making things from scratch as, like I said, at the top of the talk.
And instead, you know, if you want to make your game just 100% wheel like some crazy biblical angel, do that. You know, like if you can get away with that, I think that that's the way that people should be making games.
My favorite moments in games is when people are like, oh, I never realized that was the same exact thing in that previous game, but it's just been reused and recontextualized.
And I think that, you know, code libraries are the way that I get around that and do that.
So that, well, I totally forgot I made this slide, but.
As to tie everything up, imagine that a game is now some assemblage of wheels and also sharks and everything like that. And to conclude, games are super messy. They're already really hard to make. You know, do the things that help you get through the end of each workday and make yourself comfortable to work on them. I hope that this kind of concept of using code libraries and using pre-prepared stuff to apply to your future projects helps you out in terms of making your future projects seem less intimidating.
And just remember, like, that if you've made something before.
then you can totally do it again. And what's more, your past self is going to be able to help you in more ways than you can imagine. So, you know, keep hold of your work, refer back to it, and organize it in a way that helps you. All right, that is my talk. Thanks so much for listening.
Once again, I'm Shraveen. If you have any follow-up questions for me or you want to follow me on Twitter or you want to learn more about MidAutumn, please do so. My Twitter handle is right there on the slide and thank you so much.
