Good morning, everyone.
It's a real pleasure to be here.
I must say I'm totally terrified.
But I am Xavier Sadoulet, and with my colleague Laurent Cuvidoux, we flew all the way from France to talk about the AI in Dishonored 2.
But before getting started, we think a few things are in order.
First, we'd like to thank this community, be it the member of the Guild or the people presenting over the years at places like here, JCC.
What we will discuss today was inspired by what you guys shared.
So we're happy to give some back today.
Then, of course, we want to mention all the guys that worked on the AI for Designer 2 and supported us in the preparation of the talk.
Um, but lastly, a big shout-out to all the team in Lyon.
It is those guys' work we're representing today.
So they deserve proper credit.
There. We don't be being emotional, so let's get to it.
So who already played the first Tishanod?
Oh, not bad. Okay.
Who played Tishanod 2?
Oh, that's good.
During rehearsals at the studio, everybody was waiting there.
I guess we need to explain what the game is about.
Dishonored 2 is an action-adventure game played in first person.
Like all arcane games, it belongs to the immersive theme genre, among titles like System Shock, Deus Ex, or the Thief series.
In this game, you play an assassin that can use either stealth or combat approach, or both.
And he is given supernatural powers as tools to achieve his goals.
But essentially, the game is really about how the player chooses to approach each mission, each situation.
Here is a short video showing you a glimpse of what the game looks like.
Now that you saw what the game is about, let's talk about some challenges we had to tackle during the production.
The first one was scope.
Not like the sniper scope, more like game scope.
Let's say the AI had quite a few things to support.
Stealth, combat, verticality, dynamic relationships, teleporting player, teleporting NPCs.
Ambush behavior, NPCs interacting with blood flies, time travel, moving walls and floors and roof, player clone, time stop, player taking control of NPCs, fully interactable scripted scenes.
And what about fully interactable scripted scenes?
Why do players take control of a participating NPC?
So basically, we have all the problems of action adventure games and much, much more.
Thus, we had to rely very heavily on simulation.
Because in every feature review, there is always some guy in the team to ask something like this.
Xavier, what happens in that situation if I stop time while swapping position with my clone in front of a teleporting witch and then possess a blood fly that's carrying a stone mine?
Answer now.
Every time.
And the thing is that it's totally possible to do that kind of crazy stuff with our game.
So the bottom line.
is that there are some corners we simply cannot afford to cut.
There are many, many edge cases.
And we had to do things the hard way to ensure all systems work together.
And in order to implement those systems, we were starting from nothing.
Beginning in 2002, we chose to build a new engine, starting from 8.5, and reworking it to fit our kind of game.
We rewrote the AI part from scratch.
We also planned to take full advantage of the new generation hardware, this honored one being initially last-gen only.
And as the Arkham Asteens guy went to another project, which is a pretty cool game called Prey.
There was only one AI programmer remaining from this 101.
So we basically had to rebuild an AI team.
In that context, we decided to always try the simple thing first.
Avoid overcomplication at all costs.
We chose tried and true techniques.
Standard way of organizing our AI systems, non-stuff with ample literature available.
We tried to step away from unneeded new shiny things.
And very importantly, we did homework, spent time writing technical documentation, thinking on paper, writing unit tests for our systems.
Speaking about systems and standard stuff, we've got it all, sensory system, knowledge system, behavior tree, smart object, navmesh, everything.
But guess what?
Those are not within the scope of this talk.
What we are going to discuss today are three systems where we did things a little differently.
Let's see one of those.
Thank you, Xavier.
So hi, everyone.
I'm going to first present a few things about our rule system.
So why rules?
Very trivially, making a next-gen dishonor with such a large scope meant more assets to present.
And we're a very design-driven studio, so something our designers expressed early was their desire to have more control over how voice recordings and animations are used by the game.
Having to make a code change every time an asset needs to be integrated is very bad.
And as we didn't want to turn our designers into programmers either, we had to make sure we'd come up with something user-friendly.
Also, last but not least, we needed to find a solution with a performance cost that fits the hardware of the current generation of consoles.
So how do we track all the simulation states to present these assets in a varied and meaningful way?
This was an open question during pre-production.
And because we started our AI tech from scratch, we had the complete freedom to try a new technique.
This is where this GDC talk by Ilan Ruskin came to help.
He presented a rule system used notably in Left 4 Dead 1 and 2.
It inspired us and seemed like a good candidate to help us overcome the challenge I just mentioned.
So do yourself a favor and go check it someday.
Just to make things clear from the beginning, we basically stole all of his ideas.
So rules were something that met our requirements.
We went on and implemented a similar system in our new engine, the Void engine.
So yeah, that's it for rules.
Thanks for listening.
I'm just kidding.
I said a similar system, not identical.
Like every team, we have our own requirements.
So we did a few things differently.
For those that attended yesterday, you saw actually two other use cases of similar systems.
So this is a common thing.
My goal here is to give you details on our specifics.
So let's talk about this.
First, I need to go over the terminology and basic principles.
We define a rule as the combination of two collections, a list of conditions and a list of actions.
Conditions are predicates.
We combine them in what is just a glorified if and if conditional.
They pull the state of the simulation in, in other words, the current game context.
So, concretely, a condition is the comparison between a name variable and a constant value.
Here's an example.
We can have a rule matching when an NPC barks because they just busted the player.
So we are testing the bark trigger variable that tells us why we are trying to bark now.
And let's test a few more variables.
So is the current HP a bit low?
Is the world in high or very high chaos?
And let's match this five times out of six.
Note that we only have logical ends.
This removes the need to handle operator precedences.
It also makes evaluating the result trivial.
A rule matches when every condition matches.
So it just makes things simpler.
Now to actions.
They can be virtually anything.
As you saw earlier, for us mostly playing lines of speech or animations, but it could be anything else.
When there are several actions, they are picked one at a time.
Every time a rule matches, only one single action is executed when there's enough assets.
It's a great tool to provide variety in an explicit way.
Finally, if you take a bunch of these rules and stick them together, you get what we call a rule handler.
So this is just a set of rules, our editable resource.
So let's talk about editing.
One thing we made is an editor.
Ilan, if you hear me sometime, we followed your advice and listened to our designers.
The Wish was a tool integrated into our in-house editor.
And I already told you about designers, right?
They want everything.
So it had to come up with all the ND features that make such a tool usable, copy paste, undo, redo, et cetera.
So we created just that.
Let's see the rules editor in action quickly.
So this is me creating a couple of NPC bark rules.
Let's say I want to play some lines when an aristocrat notices something, for instance, a flower pot or a teapot.
So I won't give you a full tutorial here.
Don't worry if it's going too fast.
What I want to show here is the type of editor we have.
You can see that we have two rules.
here and here.
And also two sets of conditions and two sets of actions.
So a respectable editor, maybe not totally mature, but this is the actual tool we use to develop Dishonored 2.
Now, what did we create with this?
I won't detail everything, but as I said, we have, well, there are rules for NPCs and also rules for the player.
and mostly speech and animations.
So this proved to be quite a versatile system.
One interesting use case is achievements over there.
The rule system was a very good fit for things like check that X coins were looted to grant achievement Y.
And since we all love numbers, this is how many rules were created for each category.
So the grand total is about 6,000 rules, 6,000.
At runtime, rule handlers are instantiated and will be used for evaluation.
This means evaluating all rules it contains one by one in order and executing the first one that gets selected.
So very trivially, this one doesn't match, so we go to the second one that doesn't match either.
So we try yet another rule, and this time, every condition matches, so it's picked for execution.
We never needed to match more rules than only one.
So the evaluation stops here.
That's some CPU time for other stuff.
So what do I mean by execution?
Every time a rule is selected, one action is executed.
There are several ways you can handle this.
One way is to go over the actions sequentially.
So the first time a rule is selected, we pick the first action and execute it.
The second time, we execute the second action until we run out of actions.
So things have been pretty straightforward until now, but please bear with me.
This is where things start to be a little interesting.
At this point, we can either start again from the first action, or we can simply say these actions are depleted and never select this rule again.
We allow both, and we call these two options execution policies.
Sequential execution is handy, but sometimes what you really want is random variations.
Thanks.
For instance, for ambient bars, you don't want NPCs to say the same lines in the same order all the time.
This gives a robot effect pretty fast, and it's distracting for players.
The naive approach to randomizing things is to pick a random outcome every time a rule is selected.
The problem with this kind of approach is that it doesn't prevent repetitions.
So this is another annoying robot effect.
So we don't do this.
What we do instead is that we shuffle the action list during initialization and then shuffle again every time we reach the end.
Just like you would shuffle a deck of cards before playing a game of poker.
So this is called a shuffle back.
Given a list of possible options, it's the most natural way to use them all while avoiding common pitfalls.
Beware though, when shuffling, you should never put back the last action in the first spot.
Otherwise you'll get a nasty repetition, which we're trying to avoid.
So one workaround is to simply send it in any other random spot but the first one.
Okay. So, that's a total of four execution policies that we used in the final game.
Sequential or shuffled execution of actions were great to prevent repetition for one entity.
But what about several entities?
We still wanted to prevent the same bark.
or attack from being played twice in a row by different NPCs.
So we obtained this by putting recently executed actions in a global list, forbidding other NPCs to execute it until a cooldown depletes.
Actually, once we had this option to filter actions at runtime, we found other uses for it.
We also ended up implementing it for conditions.
So we didn't plan for this initially, and this evolved a bit organically.
But it's probably something interesting to explore further.
Earlier, I mentioned briefly that we instantiate our rule handlers during initialization.
We actually say that we compile them.
That's because we perform some significant data transforms at this stage, mostly for performance reasons.
But one interesting thing that we do is that we compile rule handlers.
This allows to add a custom set of rules for specific NPCs.
For instance, members of the Howlers gang have a bunch of specific attacks.
We can take these attacks and combine them with the generic attacks that every NPC has into one single rule handler instance.
Since we combine rule handlers, we need to determine how to solve the resultant set of rules.
So we call this a compilation policy.
One solution is to simply not sort and just concatenate everything.
This is actually a very sensible solution for small rule sets.
What you see in editor is what you get in game.
So clear and simple.
We use this for most rule types.
But for us, barks were the exception.
We have too many of them.
And really needed more lovers to get to the desired results.
So...
We first tried to sort rules by condition count, as Ilan Ruskin advises in his talk.
But it didn't cut it for us.
Our lead narrative designer, Sashka, often found herself adding new, empty conditions just to get to the outcome she wanted.
So we changed our approach near the end of the production.
The solution we've shipped with is that we give every bark a priority, and we use this as the first criteria for sorting, keeping the condition count only as a second criteria.
Something else we do during compilation is that we share identical action lists.
So, let me explain this with another example.
Our fighting NPCs can kick or punch under different sets of conditions.
So offline, we have two independent rules, one to trigger close combat attacks when back to the role literally, and another one for a player blocking too much.
At runtime, these two rules point to the same action list.
So a sequential execution shares the same counter.
In other words, you won't observe the same punch animation twice in a row, just because it was triggered under different conditions.
And yes, in case you wonder, that those give us a logical OR for the few cases where we actually need it.
Now, let me come back to variables for a moment and give you some more juicy details.
These variables have a unique path to keep things simple and order in the editor.
Their role is to tell us how to get to the actual data.
So let me list some data bindings we have.
A variable can give the value of a C++ class member or be computed by a method, we call these providers, or it can point directly at an NPC knowledge record or at a variable created in data by level designers.
And we also have a few more bindings.
So when do we resolve variables?
We resolve these variables on demand.
Most of the time, we only need a few variables to be actually resolved during one evaluation.
For instance, let's say that the first rule of a set matches.
We won't evaluate the remainder, so we don't have to pay the cost of resolving the variables we will never check.
Still.
Resolving a variable every time would be very damageable for performance.
We have variables that are actually method pointers and that do perform quite a bit of computations before they return a value.
So since resolving twice or more is useless in practice, we don't want to pay that cost each time a variable is tested during one evaluation.
So we cache the resolved values for the time of an evaluation.
and having this cache does save about 2 thirds of the time spent evaluating rules.
So note that these figures are for a thousand rule handlers, but we evaluate just a few of them per frame.
So our performance metrics are okay for this generation of consoles and onwards.
So time to close this chapter with what we envision for the future.
One thing that is a bit clumsy with our current system is that some variables are only available to some type of rule for no particular reason.
For instance, a variable exposed for barks can be missing for adducts.
If you are going to use rules in many different contexts, just like we do, make sure you take this into account and share your variables as much as possible.
And of course, you always need better debugging tools, and we make no exception.
Something we miss is a visualization tool for the combined and sorted rules.
Also at runtime, all we have to debug an evaluation is a good old dump.
So we'll try to improve this in the future.
Finally, we've talked about our cache system, but we know there's more we can do on the performance side.
So if we expand our usage of rules even more, we know there's room for it.
So to sum up, what makes rules so sexy?
Firstly, they are very appropriate for simple and short-term contextual decisions.
Secondly, they're a data-driven tool.
In the end, they made our designers happy, I believe, or at least, might be satisfied.
It should be obvious to everybody, if you have to make a code change for each and every new asset in a AAA game, well, you're just never going to ship it.
And finally, you saw the metrics, we now have more than enough hardware resources to afford such a system, so there's no reason not to do it.
So, your turn to rule, Xavier.
Thanks, Laurent, you ruled.
Okay, now let's pick DSM.
I do realize that I'm not making things easy on myself by starting a section of this talk with some obscure acronym.
So let's try to explain a bit.
Originally DSM meant dynamic space management.
Or maybe dynamic space mapping, but you could take any of those other meanings I came up with while writing this part of the talk.
And yes, there is a pen.
The point here is that it's not about what it means.
It's about what it does.
And DSM is our solution for spatial reasoning and influence mapping.
First, let me show you what we use spatial reasoning for in our game.
There you can see witches teleporting themselves and summoning a vine using dynamic position.
Then we have the always funny case of civilians running away in panic and choosing destination dynamically.
And lastly, we have the player losing NPC in combat and having them decide where they should go to chase him.
Missed.
So now to summarize all this, this is what spatial reasoning is about for us, scoring position in the world.
And in order to do that, you have to have a finite number of positions and then to evaluate them.
GSM helps us for both of those.
So let's start with the first part.
Let me introduce the main element of DSM, the layout.
The whole point of the layout is discretizing the geometry of the map, or more precisely, discretizing the nav mesh, which depends on the map geometry.
We do computation offline, going from each nav mesh face to a bunch of cells forming a layer of grid.
And voila.
The grid resolution is one meter by one meter by two meter.
And its origin is the maximum point of the navmesh bounding box.
There is ample literature around on how to build a grid from a navmesh.
We can recommend this talk among others.
Just I'm not going to detail those techniques.
Sorry.
The data representation of the DSM grid is a big array of cells.
We encode the array index on two bytes, which allows more than 60,000 cells in a map.
This is sufficient for us, as in average, we have 20,000 cells.
Now, let me talk real quick about the order of the cells in the array.
They are naturally grouped by navmesh faces.
This is an interesting property.
First, it enhance data locality.
Cells close in the world tend to be close in memory.
It's also interesting when the navmesh is getting cut.
We'll touch on that a little bit later.
And lastly, it's basically free, because it's just a consequence of the way we construct the layout, iterating over all navmesh spaces.
Each cell is a data struct containing the grid coordinate, x, y level.
the navmesh face ID it was created from, and the vertical offset from the center to this navmesh face.
NavMesh offset is important, because without it, we only have a bunch of flat grid layers to play with, which is not an ideal representation of the world, unless you're making a game on Apple II.
As you can see on the right, when taking NavMesh offset into account, our cells are far closer from what the world actually looks like.
And as this is all about picking location in the world, it's better if those locations make sense, right?
So using this offset, we can go from a cell to a real world location.
But what about doing it the other way around?
Let's say you have a location in the world and want to find which cells it belongs to.
Knowing the origin and the resolution of the DSM grid, we know we can translate from world coordinates to grid coordinates.
And then from those coordinates, we can construct a key.
that we then feed to a hash table we call Hatch Access Table and get the resulting cell index.
Easy.
Sometimes the access table is not fast enough when you need to access a lot of cells at once.
Thus, we also add a cell index stored in what we called Access Tree, which is in fact a KD tree.
With this, we can formulate queries like, give me the list of cells that are within a five-meter radius from this point in the world.
Pretty handy.
Okay, with those two ways of connecting cells, we're pretty much covered.
If we go back to our statement earlier, we saw that the word discretization part is supported by the layout.
Now let's talk about the evaluation part.
That is supported by what we call layers.
A layer is simply an array of value.
The array is allocated in one block and is the same size as the layout in the cell array.
Layers are the dynamic part of the DSM system.
They are equivalent to the classical influence map layers for those familiar with this concept.
Unlike the layout, layer data is allowed to change at run time.
It can store any data type, and those values are typically information on the game world, like danger rating of a cell, proximity to the player, et cetera.
Their main function is to support scoring of each cell.
The nice thing is that you can add as many layers as you need.
And each layer, sorry, okay, and each layer memory cost is mainly dependent on the type of data you choose to store in it.
Once you have one cell index, you can instantly access any piece of data about that cell in any layer, constant time.
Hence, we can combine layer values easily for our scoring need.
Let's call this vertical traversal.
But another interesting thing you can do with layers is traversing them sequentially until finding a cell that has the correct value.
Once we found one, then we have a cell index.
And thus, we can directly access the tile by that very cell, be it in the layout or in another layer.
Then we can carry on.
Let's call this horizontal traversal.
And please do note, good friends, that this technique was awarded the totally unofficial cache-friendliness seal of quality.
Traversing layers that way is really, really fast, provided you put reasonably-sized data in them, of course.
OK, now we can pick location in the game world and score them.
Great.
We're ready to take a look at a concrete example.
But before that.
we need to discuss a particular problem we had to solve.
Remember the moving floors and walls of ClockworkMotion?
We obviously had many cases of navmesh being cut dynamically.
How do we change that?
When the navmesh gets cut by any kind of object, like a door or a piece of furniture, the DSM gets notified with a list of the navmesh faces affected.
Remember how cells are grouped by face ID in the layout array?
This allows us to know which cell belongs to the list of cut navmesh faces very rapidly.
And from here, it's easy to test which cells are actually cut and disable them.
Disabling a cell is merely another information to it.
The access table and the access tree do not return disabled cells by default.
In the end, it is really up to the client code to decide if the disabled status is taken into account or not.
The disabled status itself is stored in a bit field containing as many bits as the layout has cells.
We use vertical traversal to check if a cell is enabled or not.
All right, let's talk about an actual example of DSM usage in the game, which is search destination selection.
The basic principle of search is that NPCs choose one destination, go to it, and then choose another one, rinse and repeat until the end of the time.
We use the DSM to decide which destination is selected.
We decided a potential search destination would be a nav mesh position of a DSM cell.
Thus, we just need to score each cell and which will be the best one.
Simple, right?
To drive this scoring, we use a specific data layer we call search influence layer.
Its value is used as a main factor for search destination scoring.
Cells without influence are not even considered.
We also use other factors to ponder this one, so that, for instance, NPCs are spread out enough or choose a cell that are not too close or too far from them, et cetera.
Whenever something is perceived by NPC, influence is seeded on the layer and propagated among neighboring cells in all directions.
The propagation speed is roughly the same as the player speed.
In order to support propagation, we keep connectivity information between cells in the layout.
The influence value itself is stored on 8 bits, using 7 bits for the value and 1 for propagation.
Please note that when manipulating influence, it is converted into a floating point number between 0 and 1.
It's more convenient for things like scoring.
We choose to have one search layer for everyone so that the data is actually shared.
And when the search is done, all the influence values are reset to invalid.
NPC clean influence from cell once inspected so that it becomes less desirable.
Cleanings mean setting the cell influence to zero.
However, it regenerates over time up to a very low value.
This is to avoid the search being ever finished before the end of the timer, or before finding the player, obviously.
NPCs clean influence in two ways.
In a cube of cells, we construct around the NPC location.
And within the inner field of view, we rasterize the triangle on the DSM grid.
We used the access table to retrieve the cells in each case.
And to be sure the NPC actually sees the cell, we checked there is a straight line on navmesh from NPC to the cell center.
So this is expensive.
So we made sure to multithread all this properly and used time slice as we don't need instant results in that case.
So to conclude on search, there is something I'd like to confess.
Yeah, some among you probably noticed this bug in the previous video.
The inference is not cleaned properly on this cell.
That's clearly a bug, right?
No, obviously, I'm just kidding.
In fact, we have smart objects affecting search.
We call them search bots, and each one is linked to a cell.
On those, we forbid search influence cleaning until the smart object usage actually takes place.
That way, the NPC will eventually go to the smart object and use it.
Now we are really done with the search part.
Let's talk about code hard facts.
During runtime, counting the layouts or those in layer, access table, access tree, et cetera, what would the memory cost for the whole DSM system be?
So who thinks it's less than 1 meg?
Who thinks it's more than 5 meg?
OK.
So all you guys that did not raise your hand, you win.
DSM memory consumption was profiled around 4 megabytes.
Some years ago, there was an interview from Naughty Dog Folks stating that they were allowed 3 megs on Uncharted 2 for the whole game states.
But with current-gen consoles, guess what?
4 megs is perfectly reasonable.
Before concluding, let's talk about some things you want to watch out when using DSM.
First thing, the big performance consumer for us has been cell accesses.
This means you need to watch out for the performance of your hashing function, make sure your KD3 implementation generates as few cache misses as possible, and really, really think about the proper way to collect cell for each use case, balancing between hash table and KD3 usage.
Second things, we can't stress enough that you don't want to store a four-byte float in a layer when all you really need is one byte.
I guess Dave would agree.
page three to eight in your book.
To finish on this part, let me tell you why DSM is sexy.
For us, the system has been a breakthrough as far as spatial reasoning is concerned.
It unlocks selecting position dynamically when all we had was pre-placed points before, which we had in DSNR1 from fleet destination or blood vines summoned position.
The second thing is that there are a lot of use cases for this system, far more than what we originally envisioned.
And finally, try it.
It's rather simple to implement and provided you're reasonable, it's affordable.
Now let's talk about another affordable system coordinated by Laurent.
Thank you.
Thank you, Xavier.
So now let's talk about Cruise.
It's our way of handling NPC coordination.
So where does this come from?
During pre-production, we knew that we were going to have standard tech fitting for individual NPC behavior, rules, DSM, et cetera, behavior tree, knowledge system.
But our system designers.
also had a strong desire to push the envelope and implement some ambitious group behaviors.
Designers, right?
We knew from previous experiences that this one desire was going to be hard to satisfy.
You can get some basic things working with inter-NPC communication, but it's hard to get a fully coordinated group behavior.
There's a point where you need another approach to avoid getting trapped in a monstrous plate of spaghetti code.
Even if there's already lots of literature about NPC coordination, we didn't find the perfect match for our desires, so we had to venture into uncharted territory.
But once more the light came from a GDC talk, again by Mika Vekala, so thank you Mika.
Among other things, he introduced the concept of situations, a technique used in Hitman Absolution.
So again, go check this if you have any interest in this topic.
Our AI crews are largely inspired by these ideas, so again, we feel that we did things interesting on our own, so let's get this.
So, what's a crew?
It's a group of people working together towards a common objective.
Take this crew or that crew.
And quite literally, they're in the same boat.
Clearly, they will have to coordinate if they want to go anywhere.
They have to row together.
Although they can row together, these peoples are still individuals.
Free them up, let the evening come, add some music and beverages, and soon you end up with this absolute mess.
Agents making their own decisions, sometimes interacting, sometimes not.
So in practice, what does this mean?
Let me illustrate this with two videos of what we call the regular combat situation.
Don't be afraid, that's our jargon for a bunch of guards directly fighting the player.
So here.
You can see that the NPCs are fighting, but things might seem a little disorganized.
They are struggling sometimes, bumping into each other, all trying to reach the player at the same time.
You see friendly fire going on.
So overall, it's not very pretty.
Now this time the crew is enabled.
So you might notice that the guards are keeping their distances a bit more.
The elite guard stays in the background and is actually shouting orders.
He also uses his gun a bit more effectively.
He used it once, and he's going to stay in the background and use it another time.
So things look a little more organized.
So what makes things different in the second video?
There's a combat crew working behind the scene to coordinate NPCs.
It assigns them a certain role in combat, for instance, melee fighter or ranged fighter.
For NPCs in melee, we have a bunch of slots that pull the navmesh around the player.
It's the crew's function to find a proper distribution across these slots.
The crew also controls the attack rate through shared attack cooldowns.
So we don't want the player to be completely overwhelmed, etc.
So...
Let's step back a bit.
I might be stating the obvious here, but I want to drive this home.
Two opposite paradigms exist.
Two approaches to group behavior, top-down or bottom-up.
The top-down approach is to have a central coordinating entity that takes decisions and gives directions, a ruling mastermind.
This allows for predetermined group behavior.
The bottom-up approach lets all individuals take their decisions, and the occasional interactions create an emergent group behavior.
See, the outcome is unpredictable, or non-predicted, as Roxanne put it yesterday.
So, I won't tell you that one approach is better than the other.
There are pros and cons on both sides.
So my point is, you have to find a balance between the two that fits the game you're making.
So what about us and this honor too?
In our case, we had early designs such as this one.
So this is the kind of group behavior our designers envisioned.
This one's from our combat designer, Jonathan.
Don't worry about the details.
Just know that this represents evolving situations with NPCs dynamically taking different roles depending on the environment and player actions.
My point is that it's very difficult to implement something along those lines when all you have.
is this absolute mess that is just impossible.
So we needed a top-down approach to AI.
We first tried a prototype of a situation system inspired by the Hitman talk, but things were very hard-coded and too rigid.
So since what we needed was a mastermind taking its own decisions, it became obvious that what we needed was an actual AI instead of.
Reinventing the wheel, we figured we could simply reuse our standard AI tech.
Our mastermind was going to have sensors, a knowledge blackboard, and a behavior tree.
So this is what we call a crew.
So what's the job of a crew?
It works like any AI, but its main interest is the members that compose it.
So just to give you an idea, typically we're talking about two to ten members.
When we update a crew, it first senses, which means that it starts by collecting the knowledge of each member.
It then thinks, which means updating a behavior tree that decides which role to assign to which member.
And finally, it acts.
This mostly consists in writing directions in the NPC's knowledge blackboards.
So they play their role correctly when it's their turn to update.
So that's another important point.
Individual behaviours still exist.
NPCs use the knowledge coming from the crew as any other source of knowledge, for example their own sensors.
So if you disable the crews, NPCs just act as if they were alone, but they are not completely shut down.
So this is what I meant by finding a balance.
If something good came out of the early 2000s craze of object-oriented programming, it's the single responsibility principle.
On one side of the balance, crews should be responsible for the coordination only.
As soon as the coordination logic starts to smell, as soon as the coordination logic starts to drive the NPCs directly, things start to smell.
Sorry about that.
On the other side of the balance, The individual behavior logic should always work on a single NPC.
As soon as it tries to perform coordination, it becomes a mess.
So our rule of thumb is that we try to avoid using any crew logic when a behavior involves only one and only one NPC.
Now you might wonder, how do we group NPCs together?
We use a very basic request system.
NPCs can emit a request to join a crew directly from their behavior tree.
We also have crews controlled by the level designers, so they can create crew requests from our in-house visual scripting tool.
This request is made of an objective and a target.
For instance, fight the player.
So just to show you what it looks like, this is a part of our individual combat behavior tree.
The highlighted node at the tree root is what posts a request to join a crew.
a combat crew in this case.
At any given time, we sort requests by priority and all NPCs sharing the same objective and target simply become members of the same crew.
So we allow an NPC to be part of only one crew.
This is both simple and dynamic and avoids putting too much complexity at such a very high level.
Now that we grouped NPCs together, let's see an illustration of group behavior.
This is the crew behavior tree for regular combat.
This is what drives the coordinated combat video I've shown earlier.
It's nothing fancy.
You see two branches, one for the roles assigned to NPCs currently engaging the player, and another one for NPCs currently chasing the player.
So this is just a definition of what roles are available for this part of combat.
But that's only one part of the crew combat behavior.
Here's what you get if you zoom out a bit.
The big picture.
As you can see, there's more than regular combat.
Under certain conditions, the crew behavior tree changes and roles are assigned differently.
So now, let me focus on the part labeled far target.
This is activated when one member of the crew notices that their path to the player is way longer than the actual distance.
So that means that there are some pieces of the level that need to be bypassed to reach them.
So what the crew does in this situation is that it splits the combat in two.
A few members are sent to flank the player trying to reach the melee, while the others simply stay put, taunting and using ranged attacks.
Note that we have two end conditions here, depending on what happens to the flanking NPCs.
As soon as any of them manages to reach the player, the fire target tree is cancelled, and the crew switches back to regular combat, which means that more NPCs will join the melee.
But if too much time passes, or if any one of the flankers gets killed, the crew marks the area around the target as unreachable.
So in this case, it's deemed too dangerous to try flanking the player.
So we'll just stick to ranged combat.
So let me show you these two outcomes in video.
Here we have a few guards.
I'm setting up a trap, and I try to lure them into it.
They busted me, combat starts and I get to a point a little bit out of reach so two of them are trying to flank me only one of them gets killed so the second one succeeds in reaching me and everybody comes to melee so I didn't set enough traps let me try another thing this time I'm putting two traps again trying to lure them into it and I get two guards killed so this time the remaining guards just decide it's safer to pick me from a distance that's it for combat crews but wait there's more we do use crews for more stuff Everything I've shown so far is completely systemic, level independent, it can trigger anywhere in the game.
But we also wanted to try to use screws for ambushes and to let level designers set them up.
There were a few cases in the first Dishonored where scripted ambushes were messing up with the systemic AI, so this was an attempt to fix it.
In Dishonored 2, level designers can create an ambush crew from script, start and stop it as they want.
On top of this, they manage the triggers and volumes that define the ambush area.
They also place spots that NPCs use for positioning.
Yet another case of coordinated behavior is search.
We use the crew to determine number of NPCs just searching actively.
In some cases, we even allow only one of them to search.
There are also more evolved coordinated behavior that may trigger when guards discover a dead body.
They first gather around the corpses.
One of them will shout a few orders, and they'll split up in search for the culprit.
If they fail in finding anything, they'll gather around again to debrief the situation before falling back to patrol.
So these phases are also handled by the crew behavior tree.
So before I close this, I just wanna show you two pitfalls of this system.
The first one is how to handle behavior trees interactions.
I'm talking about how to control the execution flow between the individual and the crew behavior trees.
For instance, you often wanna know if some part of an individual behavior is done executing before you switch to a new stage of group behavior.
We needed some kind of notification for that.
So we implemented a simple dictionary that is readable and writable from both sides and is stored in crew knowledge.
So this did the trick.
The second pitfall is how do you organize the updates in the game loop?
Crews depend on NPCs and NPCs depend on their crew.
So that's a bit of a chicken and egg problem.
it's important to keep a clean separation between the individual level and the collective level in the game loop.
So, our solution isn't very interesting since it's implementation dependent and changed a lot over time.
But please note that this is something that requires some thoughts to get right.
So clearly, this is just baby steps and we need to improve our implementation.
One thing is I wish we exposed more things in the crew behavior tree.
For instance, the conditions for assigning a role to a given NPC could be defined in it.
But for now, they're all written directly in C++ code.
Same for the execution of roles.
Something else we didn't implement is the gathering of crew members using some kind of psychic slash radio attraction.
Could be used notably for coordinated distraction in patrol, but this remained at the ideal level.
And last but not least, this almost goes without saying, but again, NPC coordination is something very abstract and requires good tools for debugging.
Ours were pretty rough, so that's something we'll have to improve in the future.
So here are my last words.
Crews are sexy.
We use them as a machete to clear the uncharted territory of NPC coordination.
They allow us to separate the coordination logic from the individual behavior.
Using behavior trees gives a visual representation of the flow of group behaviors, which is something very precious during development.
So, I wish we will find more use cases for this in the future.
Time to wrap up, Xavier.
Thanks, Laurent.
So here are some parting thoughts before we dissolve our crew.
Implementing this on a true AI was quite the ride.
Even while being very conservative and prudent, sometimes the good old keep it simple principle just does not cut it anymore in front of the whole of systems interacting together.
That's why we had to commit to put muscular systems behind simulation.
It is interesting to observe that the systems we did the most research on were the ones that needed fewer changes over the course of the production.
Whereas systems that grew more organically tend to be the ones that really need refactoring.
Obviously, this is not possible to write technical documents for everything.
Sometimes you just don't have enough visibility up front.
But when you get the chance, take the opportunity to stop coding and start writing.
AI is really about pushing proper content toward the player when it makes the most sense.
Given the amount of assets modern games have to manage, a data-driven way to select those moments and the content is absolutely crucial to maintain a decent iteration rate.
That's exactly what the rule system does for us.
And coordination, it's a hard topic.
Hard to design and implement, hard to debug and maintain.
So more often than not, games choose to fake it.
Since the Last 4 Dead 3 AI director, there has been a general trend of using some kind of master AI to drive something else than just individual NPC behaviors.
Our experience with Cruise convinced us that a top level AI making suggestions to individual NPCs strike the correct balance in order to achieve elaborate coordinator behaviors.
And lastly, we used what would seem an astronomic amount of memory in DSM.
Likewise, creating a domain-specific language, like the rule system, can be scary in terms of hardware and resource management.
However, costs that were prohibitive on a last generation console can now be totally reasonable.
But people habits tend to change lower than hardware, which means that if you are working on current gen, you really, really should try and have your lead allow you to use those extra resources.
Please, use those megs.
Use the CPU cycle.
Just use them so we can play cooler games with even cooler AI in it.
Thank you.
Thank you for listening.
So it is my duty to tell you that we are hiring.
Yeah, I'll just say Rob Ishtar is in the background.
Yeah, Rob is here.
He's our global hiring guy at ZeniMax.
So if you have some questions about this, just go see him after the talk.
OK.
No, I think we have three minutes for questions.
That's right.
So over there.
Good morning.
I was wondering, are the crews dynamic at all?
Do you add and remove MVCs or spread them around?
You're talking about the crews, right?
Yes.
How do we dynamically remove NPCs?
Or just are they dynamic at all?
Do NPCs kind of like join you?
They are dynamic.
They are completely dynamic.
As I said, it's the individual behavior that posts a request.
So basically, I'm currently searching.
Find me another NPC currently searching.
And if there's somebody, let's group them.
So it's completely dynamic.
They just enter and exit the crew as they need.
Awesome.
Merci.
Hi, I'm Sergei from Remedy. I have a question about the rule system.
I'm wondering, because you guys are using behavior trees and the rule system on top of that, so how do you make the rule system communicate with the behavior trees?
How do you decide which part of the behavior is going to be in the rule system, which part is going to be in the behavior tree?
Because they're interchangeable, essentially.
It's... Good question.
The rule system does not really coordinate with behavior trees.
What behavior tree does is like saying, okay, it is time to play a bark, and then that will fire an evaluation and using rules to select the bark that is played.
Likewise, the behavior tweak could say, it is time to play an attack, and then rules are evaluated, giving some context, and say, okay, this is the attack that is selected.
man 2 in audience So basically, the rule system is just for the barks, essentially.
Nothing else. You don't use it for anything else.
So I think you mentioned all the use cases, but...
I didn't get that.
You said the rule system was?
Was it like only for the barks?
Or like?
Oh, no, no.
It's for more than that.
Much more than that.
We use it for triggering animations, like attacks in combat, or idle breaks, what we call idle breaks, or idle animations.
Greetings, you can see NPCs greeting each other.
All this is triggered by rules.
OK.
Thank you.
One more question.
One more question.
On the right?
Okay, great talk by the way.
Loved it.
How did you sort your rules?
Because you showed some rules that were evaluating in order.
How did we- Dynamic or was the designers control that, the order of the rules that were evaluated?
How do we sort the rules?
Sort, order them.
Sort them.
What order did you process them in?
Yeah, well we sort them at compa- No, sorry, sort.
As in which order did you go through the rules trying to evaluate the conditions?
We just go from top to bottom.
And that's designer driven?
Yeah, as you want.
The designers write them in?
Yeah.
But what with lots of complex sort of conditions in there, wouldn't they sometimes the one that they'd written last was much more relevant?
I don't get that, excuse me.
If you've written three rules, they might all be just written sort of in isolation to say if the conditions are this, do this, if the conditions are this, do this.
But it strikes me that as the game is playing, a third option, for example, might be more relevant to that, to the NPC who's trying to act.
We're not dynamically sorting rules, if that's your question.
Yeah, it is.
So it's the conditions that should be written in a way that the context gives us the right rule at the right moment.
We're never sorting rule at runtime, just during initialization.
As I said, we have some kind of cool down system.
So we sometimes filter rules.
If they were previously selected, they won't be selected for a short amount of time, like for attacks.
We don't want the same attack to be triggered twice in a row.
