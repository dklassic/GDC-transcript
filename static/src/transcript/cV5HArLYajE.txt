Hello everyone. Everyone watching this is fired. You can't say I didn't warn you.
Turn off your phones, noisemakers, whatever. I'm going to get into a bit of a rant.
So I've met a lot of programmers in my day, some of them ostensibly professionals, and And many of them did not meet what I would consider to be the minimum bar for their job.
And that's what I'm going to be talking about today.
So let's play a little game.
I'm going to go through a bunch of things.
You count up how many you answer yes to.
And sum all those up at the end.
There's going to be 50 things.
These are not, these are just a sample of the 50 things that annoy me, not an exhaustive list of all the things that annoy me.
But we'll evaluate your score at the end.
So I'll state things in a positive way, you say yes, and then I'll talk about what happens when, why it annoys me when that goes wrong.
So let's start here.
I can articulate precisely what problem I'm trying to solve.
how often, I can't tell you how often I talk to a programmer, and they're off in the weeds somewhere.
They're trying to figure out, they're solving, ostensibly solving some problem, working on some code, moving some shit around, changing some things.
What problem are you trying to solve?
What benefit is this to anyone?
But they can't answer that basic question.
So here's a, this is the easy one.
We're starting here.
Like unless you can tell me exactly what problem you're trying to solve. You're just wasting time. It's just noise in the team.
I have actually articulated precisely what problem I'm trying to solve so Slightly different you think you know what problem you're trying to solve but you can't actually tell me you can't say it out loud You can't say it in a way that I could even potentially understand what problem you're trying to solve.
And you have to say it out loud.
I have to be able to hear it.
I have confirmed that someone else can articulate what problem I'm trying to solve.
You think you know what problem you're trying to solve, but other people probably have a really different idea of what that problem is.
So how often does it happen that I'm working with a programmer, I'm working with somebody, and they think they have a pretty good idea of the problem they were trying to solve.
They deliver it to somebody, and they're like, I didn't need this. This was not the thing that I needed.
Because they didn't confirm that somebody else understood what they were talking about.
I can articulate why my problem is important to solve.
So I spent, you know, you will see, I have seen many programmers say, OK, I can totally tell you what problem I'm trying to solve.
It's that these equal signs are not lined up correctly in this file.
OK, that's not an actually important problem to solve.
Who does that benefit?
So that's a small example, but how often do we waste a lot of time solving things that actually have no value?
So why is it important?
I can articulate how much my problem is worth solving.
So I'm working on a thing.
And how long should I spend on this thing?
As much as long as it takes.
OK, fuck off.
No problem is worth infinite time.
There is a maximum that this problem is possibly worth solving.
Is it a year?
OK, great.
Is it six months?
Is it a month?
Is it two weeks?
How much is this problem we're solving?
How much manpower and time and effort?
There is a limit.
What is it?
Put some boundary on the value of this problem.
I have a plan B in case my solution to my current problem doesn't work.
So I get to the end of the project.
We'll get to a demo.
I have to deliver something for E3 or GDC or whatever.
And it's two days before, of course.
And everything is broken.
And I have to say, OK, I have to give up and say, whatever I was currently working on wasn't going to work.
I have to get that plan B in there.
I have to figure it out.
I didn't have a plan B. So now I'm scrambling to try to figure it out and blaming everybody else, blaming project management or whoever put this on the schedule or all the things.
I'm very angry.
And I'm trying to scramble for a plan B. But the thing is, I knew that the deadline was coming.
I knew that there was potential risk here.
And yet, I didn't have a plan B in advance.
I didn't prepare for it.
That's a problem.
On top of that, I have already implemented my plan B in case my solution to my current problem doesn't work.
I know this is risky.
I know that when it comes right down to it, in those last few days, I'm going to have to do something.
Why didn't I just implement that thing in the first place?
Two things, right? One is, one it's a safety net and everybody else can be confident because if you wait until the last minute to implement your plan B, you have just added stress to everyone on the team because they don't know if your plan B is going to work.
So put the plan B in first. The second thing is, you implement your plan B up front.
you probably discover half the time that that's good enough.
Like, it does the job.
I don't actually need to go to plan A.
Or I discover something about my problem that I didn't anticipate at all, and plan A wasn't going to work.
So put your plan B in first.
I can articulate the steps required to solve my current problem.
So I get to somebody.
I'm stuck.
I don't know why I'm late.
I don't know why I'm not able to deliver this thing.
OK.
What are the steps you need to do in order to solve this problem?
I don't know.
I don't know.
How could you possibly expect to solve the problem if you don't know what it is that you're trying to do?
Of course that's why you're stuck.
Of course that's why you're spinning your wheels.
You can't actually tell me the individual steps that you need to take.
Take the time to write those things down.
I can clearly articulate unknowns and risks associated with my current problem.
uh this is why everyone throws up their hands when you give Estimates.
Well, I'm just going to multiply all your estimates by 3 or 5 or 100 or whatever, because I have no idea if your estimates have any value.
Because you grouped them all the same.
The things that are low risk, the things that are high risk, they're all equal.
This is two days, four days, whatever.
I don't know.
That's because you can't articulate actually what the risks are in your project.
What are the things you don't know about this?
What are the things that you need to study?
What are the things you need to test?
You can't articulate that.
Therefore, you cannot give a reasonable estimate.
I have not thought or said, I can just make up the time without immediately talking to somebody.
So it's Wednesday on a week.
You have something due to be delivered on a Friday.
On Wednesday, something else drops on your lap, some bug, something else, whatever.
You think, ah, I can make up the time.
So you work on that.
You get to Friday.
Of course, as always, you didn't make up the time.
And the thing is late.
At that point on that Friday, somebody comes to you and says, where's the thing?
Well, I couldn't do it because this thing dropped on my lap on Wednesday, and it got behind, and all the things.
All right, you knew that on Wednesday, right?
You knew that happened on Wednesday.
That was not a mystery.
It was not a surprise that that happened.
And in fact, you had all the information you needed to know to know that on Wednesday.
The problem is you thought you could make up the time.
On Wednesday, you should have told somebody about it.
I write a framework and have used it multiple times to actually solve a problem that it was intended to solve.
So.
I could get into a rant separately about frameworks, which are usually an excuse to kick a problem down the road to get somebody else to solve it.
But let's be generous and say you're building a utility of some kind that's actually useful.
Have you actually verified that it does the job that it was intended to do, or are you just waiting for somebody else to do that?
If you haven't actually proven it works, how is anybody else supposed to trust it?
I can articulate the test for completion of what the test of completion from what my current problem is.
How do I know when it's done?
How often do I talk to a programmer?
I don't know.
When is this going to be done?
How good is it?
Well, it needs to be faster.
How much faster is that?
10% faster?
10 milliseconds faster?
Like, how much faster is faster?
It needs to be smaller.
One byte smaller?
10 megabytes smaller?
How much is smaller?
How do you know when you've crossed the line and when enough is enough?
You don't have infinite space here.
Like, there's a limit.
What is the limit?
I can articulate the hypothesis related to my problem and how I can falsify it.
So what am I trying to prove?
I'm trying to prove that it's faster, cheaper.
I'm trying to prove that it's more usable.
I'm trying to prove that it's fun, whatever.
I have a hypothesis.
If I put this in, it's going to be more fun.
But I spend all my time looking at the positive numbers.
This is how fast it is.
This is how fun it is, whatever.
And I'm not looking for how I can prove it wrong.
And that's what we need to be looking for, right?
That's the scientific method.
You have to be looking how you can prove, how you can possibly prove this wrong.
Who could prove it wrong?
You have no way, if you haven't even thought about how it can be proved, your hypothesis can be proved wrong, you're doing it wrong.
I can articulate the various latency requirements for my current problem.
So, say, somebody's working on a system, I say, how long?
How long until somebody else needs this data?
Like I'm writing a function.
How long until somebody else needs this data?
I don't know.
Right now.
Right now is not an answer.
Fuck off.
Like that's immediate latency for all the things.
So your system is going to be just blocked on the main thread and blocking everybody else on the main thread.
That's your answer to all the things.
Immediate latency for all the things.
No.
That is absolutely not the answer, right?
You have latency requirements.
There are latency requirements.
Not everybody needs everything that you're In the next possible step.
right? What is the requirement? When do they actually need it? If you can't reason about it, you can't solve the problem. I can articulate the various throughput requirements for my current problem. How much do you need to push through the system? This is a basic question.
Is it really just one spinning cube?
Probably not.
Is it one thing?
Is it 10 things?
Is it 1,000 things?
Is it 10,000 things?
Is it a million things?
What is it?
What is the throughput that actually needs to be pushed through the system?
And what are the constraints of that?
You need to be able to articulate that.
I can articulate the most common concrete use case of the system I'm developing.
This presupposes, when I'm sitting down with a programmer, that they can articulate any use case of the system that they're developing.
But let's say they can.
What's the most common thing?
What's the most common thing that somebody is going to do with your system?
Well, the most common thing is that they're going to be processing all the players in the game.
Great.
How many is that?
I don't know.
It's somewhere between 10 and 100.
Great.
So why does this function only take one thing?
That's not your most common case.
You've just told me your most common case is n number greater than 1, and yet you've developed an API around one thing.
Why are you doing that?
I know the most common actual real-life values of the data I am transforming.
So somebody's solving a problem.
What does the data look like?
I don't know.
It looks like.
You know, it's an int.
Could be anything.
Could be anything.
Or it can't be anything.
There's some actual values that are actually coming through here.
What do they look like?
What's the most common things?
Well, I've created this system that adds all these numbers together.
Great.
But in real life, 99% of those numbers are 0.
So we're still wasting a bunch of time.
What are the actual numbers that you're actually dealing with?
I know the acceptable ranges of all the values of the data that I am transforming.
So.
Somebody says, it can get infinitely large.
You can do anything with this.
It can do anything.
OK, great, really, it can't.
You can't fit infinity into your 32-bit int.
Your file size value is 32 bits, so it's not going to get any bigger than that.
You have built-in limitations into your system.
What are they?
Articulate them in a way that other people can understand.
I can articulate what will happen when, somehow, data outside those ranges enters the system.
So it's inevitable.
It's going to happen.
You have a range of things.
You have an acceptable range of things.
Somehow, something is going to get in that's not inside that acceptable range.
I have 32-bit file size, for instance.
Somebody drops in a gigantic file that they've exported from Maya.
Great.
What happens?
Does your machine crash?
Does everything fail?
Do you get a nice error message that says this is too big?
What happens when this happens?
You should have a pretty good idea of what's going to happen.
and not just hope.
Developing based on hope that it will never happen is not good engineering practice.
I can articulate a list of input data into my system roughly sorted by likelihood.
Again, that you can articulate any input data is a start.
But that I can say, this is the most likely thing that I'm going to see.
I'm going to see a set of static.
you know, set of static things in the world.
That's the most likely thing.
The next most likely thing is I have a bunch of characters running around in terms of transforms, whatever.
I can roughly sort my data based on likelihood.
Great.
Now you solve for that.
Starting at the most common thing, solve for that.
Next most common thing, solve for that.
I know the frequency of change of the actual real life values of the data I'm transforming.
So I could recalculate this thing every frame, every frame, every frame. Great.
That only changes once a second.
That only changes once every once in a while when this other thing changes.
Why are we recalculating this every frame?
It's because you haven't reasoned about what the frequency of change actually is and the actual values that you're dealing with.
I have, at least partially, read the available documentation for the hardware platform and tools I most commonly use.
So you have somebody who's been working, say, on a platform, let's say desktop platform, x64, for the last 10 years.
Great.
Mostly hasn't changed.
It's mostly the same, roughly the same CPU family.
And yet, you've never cracked the manual.
So when things come open, you're like, I can't read that.
I don't know what that assembly instruction does.
That assembly structure hasn't changed in 20 years.
You've had plenty of time to look up what it is.
Read the manual.
I have sat and watched the actual user of my system.
So you can guess.
Sometimes you might be able to read a form somebody bitching, but unless you sit down behind someone and actually watch them use it and actually watch them complain and gripe and work around all the things that you broke, you don't actually know what's happening.
I know the slowest part of the user of my system's workflow with high confidence.
So.
So you just had a tool, and I thought, well, that tool's really slow.
So I threw away the tool, and I said, I'm creating a new system, and this system's going to be way faster.
The only problem is that it requires them to write this two-megabyte JSON file by hand.
Great.
That is now the slowest part of their workflow.
I know what information users of my system will need to make effective use of the solution.
So I've built a thing.
I've said, OK, all the artists need to do is optimize this.
Great.
They have absolutely no profiling information.
How do you expect them to optimize this?
You're not giving them the information that they need.
I can articulate the finite set of hardware I'm designing my solution for.
Is this solution supposed to work on a 6502?
Probably not.
OK.
So there is a piece of hardware that this is not going to work on.
Great.
Let's start there.
What hardware is it supposed to work on?
OK, desktop platforms within this range.
Great.
We can reason about that.
Which brings us to, I can articulate how that set of hardware specifically affects the design of my system.
So I have a set of hardware.
There are requirements in the hardware.
There are things that the hardware does.
How does that affect your system?
How has that affected your system?
If you can't tell me how it affects your system, then you are just blindly developing in an ether.
You need to tell me how the fact that this has SIMD, how the fact that this even has an FPU, how that has affected your design in some way.
You've chosen floating point because there's a floating point unit.
That is a clear, indirect, and trivial example of how hardware affects your design.
I recently profiled the performance of my system.
The bar here is recently.
The bar is not never or I have once.
Have you profiled it?
Have you looked and see what happens?
I have recently profiled memory usage on my system.
We've run out of memory.
I don't know why.
That's solvable.
Just look.
I have used multiple different profiling methods to measure performance on my system.
One thing I'd like to bitch about is FPS is not a measure of profiling.
Stop doing that bullshit.
Like, actually measure in milliseconds or any kind of real time how long something takes.
And then use different methods to do it.
As far as I know, maybe somebody here can correct me.
As far as I know, there's no perfect profiling tool.
Every different profiler, sampling profiler, other profilers are going to give you a different insight into your data.
Use more than one.
I know how to significantly improve the performance of my system without changing the input-output interface of the system.
Is your system optimizable?
Is there a way to get from here to there?
Or have you painted yourself into a goddamn corner that you're never going to get out of?
I've just allocated all the things because whatever, I'll optimize it at the end.
There's no end.
There's no place where that's ever going to happen.
You've just created this memory spaghetti of all the different things, all the different allocations.
There's no possible way we can undo that without changing all the interfaces to the system.
Or I've returned a value.
To go back to the latency point, I've had a function that immediately returns a value.
Unfixable.
Zero latency.
Everybody's going to call that function.
It needs that value right there, because you built it in so that it has zero latency requirement.
I know specifically how I can and will debug live release builds of my work when they fail.
So some presumptions in there.
They will fail.
It's a promise.
That happens.
Of course it happens.
But I know how to debug a live release build, whatever that means.
I do not need to be.
in a debug build, in a debugger, with source code.
Like, that's great when you have it.
But it's necessary to solve the problem when you don't.
I know what data I'm reading as part of my solution and where it comes from.
I have actually written that down.
I've organized it.
I can reason about where I'm getting the data from.
Because if I say, hey, how do we make your system parallel?
I have no idea, because I have no idea what data I'm reading or where it comes from.
So now it's impossible.
Now we're stuck in a place where you're just stuck in the main thread forever, because you've never reasoned about where your data is coming from.
I know how often I'm reading data that I do not need as part of my solution.
So I'm reading in some data.
I'm reading in 90% of that data is useless.
I'm not using it.
I'm reading in every piece of information that I read.
I'm throwing away the vast majority of the cache line that I'm actually reading in because I don't need that piece of information.
So I'm wasting most of the memory bandwidth of the machine I'm using.
I can't reason about it.
But unless I can actually.
Say how much I'm wasting.
And maybe that's a reason trade-off.
OK, I'm going to waste half my cash line because of reasons.
Fine, but at least you can reason about it.
Unless you can tell me how much you're wasting, we can't do anything about it.
I know what data I'm writing as part of my solution and where it is used.
Who's using this?
When is it used?
How is it used?
Again, what the latency requirements are.
Can you reason about this at all?
Or are you just writing arbitrarily anywhere in your system, and you have no organization at all?
The expectation is that you are organized.
I know how often I'm writing data that I do not need as part of my solution.
So I'm writing extra things.
I'm writing things that are always the same thing.
Again, unless I can reason about it and say, I've actually looked at the data, saved it out, looked at it, and say, hey, you know what?
I write that every single time.
It's always the same thing.
Or I have this giant system that essentially amounts to a lerp.
How would we cut away all that data that you're writing that you don't need and just do the lerp?
But I can't reason about it unless you can tell me what you're writing.
I can articulate how.
All the data I use is laid out in memory.
I don't just rely on some magical memory management to just put magical things in magical RAM.
That's not how it works.
It's this real memory that you really need to manage that you're actually responsible for as a developer.
Your players require you to have a consistent setup in your game.
It needs to be consistently working and consistently as small as possible.
That's on you, not on some magic system.
I never use the phrase platform independent when referring to my work, because there's no such thing as platform independent.
I never use the phrase future-proof when referring to my work, because there's no such thing as future-proof.
It is 100% a fool's errand.
How do you expect to solve a problem that you have no idea what that problem is?
You can't pre-solve problems that you have no information about.
I can schedule my own time well.
All right, how many?
I don't know how many programmers.
This is a mess of scheduling.
I don't know what I'm doing.
I don't know when I'm doing it.
I don't know how to organize my time.
You're an adult person.
Just use a calendar.
I am vigilant about not wasting other people's time.
So there's two sides to this.
One is, if you could have looked this up in five seconds on Google, why bother the whole team about it?
That's one side.
The other side is, if you spent two weeks futzing with this when it could have been solved by somebody in your team in five minutes, you're wasting their time, because now they're going to have to help you catch up after two weeks.
So find that sweet spot.
Maybe that's 15 minutes, maybe it's 30, whatever.
Find the sweet spot.
I actively seek constructive feedback and take it seriously.
I have a way of actually asking people for feedback.
And then I do something about it.
I am not actively avoiding any uncomfortable professional conversations.
There's something wrong with the system.
I'm not just keeping that to myself.
I'm actually going to somebody and saying, there's something wrong here.
We need to do something about it.
I'm not actively avoiding any professional conflicts.
Similar kind of thing.
There's something going wrong.
These people aren't talking.
These things aren't communicating.
I'm actually doing something about it.
I consistently interact with other professionals professionally.
Which means, like, I'm going to set the bar really, really low here.
No yelling.
No hitting.
Like, let's just set, I'm painting the bar on the floor.
I can articulate what I believe others should expect from me.
So a lot of people are waiting for other people to tell them what those expectations are.
Here's what I expect of you.
All right, how about you tell me, what should I expect from you?
Can you articulate that?
I do not require multiple reminders to respond to a request or to complete work.
Again, you are all adult people.
Waiting for somebody else to poke you is not an effective way of getting your job done.
I pursue opportunities to return value to the commons when appropriate.
You're all here because of the work that you've built upon other people.
You have taken some opportunity at some point to give value back to the community at large.
I actively work to bring value.
to the people that I work with.
You're part of a team.
There has to be a reason that you're part of a team.
You're not an individual person just doing individual things.
You are part of a team.
How are you bringing value to the rest of your team?
Where can you help them?
Where can you teach them?
Where can you learn from them?
How do you interact with that team?
I actively work to ensure underrepresented voices are heard.
So the thing that pisses me off, and lots of things piss me off here.
But one of the things that pissed me off is, of course, the old standby, it's a pipeline problem, and it's not my problem, and all the things, right?
Well, fuck that shit.
That's like, do something, anything, right?
Make sure that it, and especially if there's somebody in the room, make sure that they're heard.
Make sure that you're not talking over everybody, unless, obviously, you're standing in front of a room, and that's your job.
But make sure that people are heard.
So that's 50 things that pissed me off.
Again, a sample, not exhaustive.
So let's grade.
So if you had a score of 0 to 20, you agree, you did 0 to 20 of those things in the positive sense, fired.
All right, you have a score of 21 to 40, fired.
41 to 49, fired.
Score of 50.
This is the minimum bar.
You can argue with me whether or not this is the right minimum bar, but it is the minimum bar.
I'm not trying to set the bar that high.
These are basic expectations, really simple things that we should expect from everybody.
And I think that's what is the absolute minimum that I can expect people to do.
And I think this represents a good portion of that.
Thank you.
