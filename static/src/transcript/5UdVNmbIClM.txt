Hello, everybody.
Welcome to Game Design Case Studies.
I am Eric Zimmerman, and I'm moderating this panel.
What is game design case studies?
Game design case studies was inspired by a question about what is an advanced game design talk.
Unlike our sisters and brothers, our spiritual sisters and brothers in other design fields like architecture, graphic design, industrial design, we're a very young field.
We're still kind of figuring out what an advanced.
understanding of game design might be.
And I'm inspired for panels like this by things like Detail Magazine, architectural detail, not the men's magazine.
They have magazines that are extremely focused.
These individual magazines are about, like, timber construction and building libraries.
And inside, they basically have porn for architects, right?
Like...
detailed diagrams and layouts that just explain, hey, how does this design system work?
How is it put together beyond what you see on the surface?
And the challenge for us as game designers, especially with video games, is that we play each other's games, but we have to extrapolate how the system works.
based on how we think it's functioning under the hood.
So the idea here is to be able to lift up the hood and really see what's underneath.
The session was approved by GDC.
I did a call for papers and I got a lot of excellent...
proposals for game design case studies, and I chose these three amazing ones that you're going to see today.
So we're going to see three 15-minute presentations.
And the guidelines for what they're doing is just, each of them are going to show one game that they designed and one system in that game.
And all we want them to do is show us how it works.
Without some of the other things that sometimes take up time.
They only have fifteen minutes.
So we really want them to focus just on how it works.
And hopefully what we'll get as a result is porn for game designers.
So please join me in welcoming Tanya Short, Dan Kassar and Bennett Foddy today to give their game design case study.
We're going to start with Tanya Short.
Tanya, we are so lucky to have her design brilliance here today.
She is the captain at Kit Fox Games.
And she is going to be here talking about a game that she designed, Shattered Planet.
Take it away, Tanya.
Thanks, Eric.
Right, so I'm the captain of Kit Fox Games, and I'm going to tell you about the way that the levels in Shattered Planet are procedurally generated according to design philosophies.
So Kit Fox Games is actually made up of four people.
Another one is in the audience over there somewhere.
And the reason I bring this up is because a lot of what I'm going to be talking about today is actually systems developed by Zhang Wu, but also primarily Mike Ditchburn.
and he would rather die than be up here talking to you right now, so I'm here to tell you about the procedures that we developed together and the design philosophies that I developed with him.
So Shattered Planet came to Steam last July and it's a science fiction dungeon crawler of sorts. It could be called a roguelike by some.
And the point to take away here, by looking at the screenshot, is that it is procedurally generated tile by tile.
So all of the walkable area is generated by an algorithm.
There's no hand-built pieces there.
And it started at the beginning, we wanted to make levels that felt like someone had designed them.
So we took apart a, this is a very early mock-up of a level that we were designing, and looked at what made it feel like it was designed.
And so I'll be going through the procedure that the algorithm actually takes and why it takes those steps.
And then what content design tools and methods that we used, and then what's missing.
So the procedure.
of the procedural generation begins with the actual geometry.
So it builds a shopping list of possible rooms in the dungeon that you can walk along.
And that's, you can think of that as analogous to a level designer coming up with what the possible minimum and maximum size is that they can build a given room in.
And then it starts placing them out, deciding where doors can be placed.
It chooses one as a door.
It places another island, it connects the island.
And it makes a critical path and it makes side paths.
And it understands which is the main and which is the off.
the critical path, which will be important later.
But at this point, you have basic geometry, and it decays to look a little bit more organic, a little bit more like a shattered planet, and a little less like a dungeon that you would find under the ground with a lich in it.
And it does that by each individual cell along the edge, kind of managing itself, having cellular automata to decide, based on its neighbors, its probability of disappearing, with possible doors kept as an exception for reasons.
The next step is it paints the texture of what it should actually look like to humans.
It uses Perlin noise.
Mike squashed it until it had a good contrast at the resolution we wanted, which was 5 to 5 or 9 by 9.
And then along the seams it paints a transition texture, which on the right you'll see between 1 and 2.
They never actually touch.
There's a transition texture put in there where they would have touched.
So you get this result of the primary texture, the secondary texture, and a transition texture in between, which is pleasing.
One thing that you'll notice here, actually, is that the bridges never got quite transitioned correctly.
They still stick to only one of the primary textures.
Oh, well.
The third thing that it does is it makes it feel even more organic and even more shattered by, again, using cellular automata to have the individual spaces around a given room decide its probability of having what we call crumblies.
Each edge has that percentage chance to spawn a new crumbly, and it inherits the texture of the cell next to it.
In the case of a transition texture, it just picks one of the two textures to inherit.
We did have to move the islands a bit further away from each other to prevent the illusion that you could walk on these crumblies between islands.
That was the only real adjustment we had to make to the algorithm.
And you can see this is before we added the crumblies.
It looks very geometric, very rigid.
And then adding crumblies and also a background texture helps immensely with the feeling that you're actually in a level that someone may have designed by hand.
So next, we have to figure out where to put the obstacles.
So we wanted obstacles to make the terrain more varied, to not let you just walk everywhere you can see.
And to do that, we first used a depth-first algorithm, a depth-first maze generation.
And what you can see it's doing here is any given place that is part of the maze, connects to every other place, right? There is no place in this maze where you will get stuck.
You can always move around even though there's obstacles, and so we used a variant of this on the map using pathfinding, so the pathfinder would decide where obstacles were allowed to go.
We would not do it this way again.
I do not recommend it.
And it's because this works especially well with rectangles.
And as I described before, we don't actually use rectangles.
So for example, if you start with the door at the top white section, if you start walking on that path, it no longer connects to a lot of the other paths.
You actually will get stuck almost constantly.
using this method.
So we had to actually add and duct tape a second system which would go around and destroy obstacles that were placed in the way if the pathfinder couldn't find the rest of the maze that it had generated.
So that was fun.
So, next, I mentioned before that there's a critical path and an off-critical path.
The reason why you needed to know that was because, although there's different entities that could spawn in them, one of these was actually a particular kind of entity which would So, we could pick a bridge and turn it into an invisible bridge and put a locked door on it, and then put a key along the main path.
So, the design tools, we could specify zero to three of these locked doors, and it would segment away one of the side paths, and make sure you couldn't get stuck, and that room could only be accessed through that bridge.
And that's important to happen first because the next step was to find where there were dead ends in the level and actually loop them around again.
Because as any level designers in the room might know, you shouldn't have players backtracking constantly.
So all of the possible doors that we flagged earlier, now look around and see, are there any possible doors kind of near me?
If so, I have a 50% chance of connecting to you with an additional bridge.
So you end up with a much better flow, a much more fun experience to explore, because you're not constantly going out into the tree and then back again, and then out in the side path and back again.
So next, the algorithm looks around and says, OK, well, let's put in some enemies, some treasure, some items, some story bits.
And it has a similarly built shopping list that I've defined of possible entities.
So it puts a certain amount of risk and reward, like little breadcrumbs of treasure, and smaller enemies along the main path, and bigger enemies and bigger treasures along the side paths.
And it actually uses the obstacle list here that we generated earlier. Remember the maze everywhere where it was generating where obstacles were allowed to go? It uses that because enemies are basically obstacles. You have to be able to get through them at some point to get to the end.
So that's a reuse there of the algorithm's side system.
And finally, after the whole level is built, it's all living, there's enemies and treasure, and you're ready to start playing, it splats a big layer of darkness on top, and then the player goes around deleting it as he walks.
This simultaneously adds a bit of mystery, making it feel like maybe there's something around the corner that the designer has intended for you, but it also, as a side benefit, gives the player a sense of where they came from and where they're going, because if they haven't been there yet, then there's darkness in front.
And it kind of allows the player to have a self-directed, strategic exploration of the space.
If they're more of a careful player, they'll use the fog differently than a very bold player or a completionist player.
And it was interesting watching Fafagavore specifically to get those cues.
So the planet has created itself.
We now have an algorithm that will generate the basic islands.
So the problem at that point is, what should it actually generate and why?
And that's something the algorithm can't really help us with.
As the level designer, game designer of Kit Fox, I look at the tools, and they're just a pile of mad libs.
So I start defining the upper bounds and the lower bounds, and I start thinking of themes.
I tell it, okay, this is a cold room where there's mushrooms, and it can be about this big, and it can have these kinds of things in it.
And I hope that the algorithm gets it, and I play it a little bit.
And so this is kind of what that looks like.
This is me defining the primary, secondary, transition tiles, potential holes in the geometry, and obstacles, and things like that.
Yeah, so another consideration in picking the minimum and maximum sizes was actually to think about the theme emotionally of a given level.
So if a level is supposed to be very claustrophobic, that's more of a defensive level because you have more backing when you're fighting enemies.
You're not going to get surrounded as much.
You can see everything all at once.
smaller rooms are better, whereas we have a place called the Wasteland, which is a much bigger, open, agoraphobic, scary place, that's better suited to larger numbers and the sizes of the islands. So, at some point, we realised that although we wanted to support various player strategies, there were a few that needed special attention.
One was fire. Everybody loved setting things on fire.
and we wanted to encourage that, but part of the problem was that there wasn't enough grass everywhere, which was the flammable stuff, and so part of it was actually going through methodically and thinking about what are exactly all of the strategies that we're supporting, how exactly are...
are the different island themes supporting this.
So fire is a strategy that's supported, and the various other things.
We have to make sure that there are enemies and treasure to be found that suit the way that the player is trying to play.
And that meant tweaking exactly the content in there.
Even if the algorithm itself remained the same, a given level will generate very differently, depending on what strategy it's trying to encourage.
One special shout-out is that we had an explosion effect that everybody wanted instantly, which was making all of the tiles fall off the face of the earth.
It was exploding, shattering the planet.
It's everybody's fantasy, right?
And then the player would get stuck, and then they weren't as happy.
So we added in a little bit of a caveat there, that if you exploded part of the level that led to the exit, that...
maze algorithm I mentioned before would kick in, it would path-find between you and the ending, and it would make sure that particular path cannot get blown up, and instead it exposes this dynamically generated skeleton of the world, which most players don't even understand exactly when it's skeleton and when it's not, but it's not letting you get stranded, basically.
So, we were pretty proud of ourselves, and we were very happy that the game came out and had 400,000 downloads and whatever, but there were some problems, and it's very obvious, it became very obvious in the last few months of development.
The primary one was actually that a given room had no idea what its purpose was.
It had no idea if it was on the main path, if it was on the critical path, if it was a locked room, if it was a boss room.
There just wasn't any sense in the algorithm of what a room was at all.
It was just geometry that was connected together and painted with a texture and everything I told you about.
And that caused a problem because this is actually a screenshot I just took in the game as I was playing.
And you can see that the key in the door that was supposed to encourage, you know, exploration and risk for reward of go find the key and bring it back to the door and get a reward.
It's non-functional because the key is right next to the door.
Like, why bother?
And meanwhile, although this particular example has crystals floating over there, which is very exciting, half the time there'd be no treasure on the other side, and that's fun too, right?
Yeah.
So, if we could go back in time, we would definitely tell ourselves to build in an idea of what each room is doing.
Another thing that we wished we had done is more of a meta-level design of difficulty.
So we had a ramping difficulty kick in after a certain point, and it would make it harder and harder and harder, but it really just kind of felt like a bunch of random stuff that was sometimes harder and sometimes easier, whereas a better-designed pacing would have peaks of very difficult fights and then let you relax a little bit and then build back up and so forth.
that is not a good thing, and that does not do that. And finally, the number one thing that people complained about, they said that it was, it felt a little empty, and, to me, I interpreted that as lacking deep consequences. It lacked any rooms that were hand-built. It lacked any kind of sense that things were connected.
And I think that we as humans, and especially roguelike players, we're suckers for deep patterns.
We just love making constellations out of nothing.
And it really needed to feed that a little bit more.
And so that's what we're building into our next game, which is Moon Hunters.
We're building a lot more hand-built content and completely redoing the procedural generation.
And so now, I will take your questions.
Thank you.
If we have time for a couple quick questions for Tanya before we move on to Dan.
And while we're getting Dan's laptop set up, any questions about Tanya?
Yeah.
So you're making the shift between blue design and then moving towards the tank or what does that look like?
So the question, just to repeat it for everyone, was as you're making the move from the procedural to the designer.
The other way around.
From the feel to the mechanics of the procedural generation.
I mean, it's just part of the process for me.
I feel that that's an important part for every designer, to think about the goal, the vision, and then break that down into rules.
And the way that we did that was we actually built a hand-built tutorial level.
and gave it to people and tested it and made sure we liked it.
And then once we had something we liked, we analyzed it.
And we looked at, okay, well, what are these rules?
I was traditionally trained as a level designer, so I knew some of it.
But some of it was unique to the game that we couldn't have known before building that prototype because it was specific for that game.
So that gave us rules about like, oh, this is how big that room should be, and this is how long corridors should be, and that kind of thing.
And so that helped us build towards code.
You're welcome.
All right, thank you very much, Tanya.
All right, I'm here to introduce next Dan Kassar.
So don't tell anybody, this is a secret, but we've snuck in a tabletop game designer into this session.
So, yeah.
So Dan is here to talk about one of his card games and its drafting mechanic, but the twist is that he's also a software developer.
So he's also gonna talk a little bit about some of the digital tools that he created in order to test and balance his card game as it was being developed.
So take it away, Dan.
Thank you, Eric.
Hi, I'm Dan Kassar.
I'm a tabletop game designer, originally from New York, now based in Philadelphia.
And I'm going to be talking about how I use digital tools to help me balance the Rochester draft in Cavemen, the Quest for Fire.
Drafting is one of the most fundamental game mechanics out there.
After all, we all remember picking teams for kickball in the schoolyard.
But in the world of modern board games, when people talk about drafting, what they usually mean is a particular kind of card drafting that I call pick and pass.
The way it works is this.
Each player is given a hand of cards.
He selects one card from his hand and then passes the remainder to his left, simultaneously receiving a new hand from his neighbor on the right.
Again, players pick one of the cards for themselves and continue to pass them on.
I think it's safe to say that the prominence of this approach probably came from Magic the Gathering and its booster draft tournament format, where instead of building a deck beforehand, it makes deck construction part of the tournament itself.
Each participant is given a booster pack.
Players each open their pack, select a card, and then pass the remaining cards.
Antoine Bausa proved how successful this mechanic could be when he won the prestigious Kenne Spiel des Jahres, the German Expert Game of the Year Award, in 2011 for his game Seven Wonders, which is entirely based on the pick-and-pass draft mechanic.
But I remember some time in the early 90s, I saw a group of players at a local game store drafting Magic cards in a way that I hadn't seen before.
Instead of opening one pack per player and passing the cards, they would open a single booster, spread the cards face up on the table, and then players would take turns making their picks.
I later learned that this was called a Rochester draft, named for the city in western New York, where the format is supposed to have originated.
Widely regarded among serious magic players as the drafting format that requires the most skillful play, an open draft plays quite differently from pick and pass.
It turns cards into chess.
It challenges a player to make the best decision based on what he has already chosen and what he has seen the other players select.
Turn order becomes all important and counter drafting becomes a much greater factor.
Because there's no hidden information, you can choose to thwart an opponent by denying him a card that he needs, but only if you're willing to sacrifice one of your picks to do it.
Cavemen the Quest for Fire is a card drafting game I designed based on the Rochester draft that was published by Rio Grande Games in 2012. Players bid for turn order before drafting cards to contribute to their tableau that represents their tribe. Combining an open draft with an auction creates a game experience that can be highly competitive without the need for direct conflict. Players take the role of tribal leaders and compete for scarce resources.
such as dinosaurs to hunt, cavemen to recruit, and inventions to discover, vying to be the first to invent fire.
Gameplay is organized as follows.
Each turn, a number of cards are drawn face up into a common card pool.
Then the players use teeth, representing prestige amongst the tribes, to bid for the conch, which is the first player token.
After the bid, players pay food for the cavemen in their tribe to keep everyone alive.
Then starting with the conch holder and proceeding clockwise around the table, players take actions that allow them to draft cards from the pool, and then some of the remaining cards are discarded and the pools replenish for another round.
So the challenge was how to achieve cost and reward curves that not only kept the pace of the game moving forward, but also created opportunities for players to compete meaningfully in a game that used resource denial as its primary means of player aggression.
For example, suppose we're early on in a game with three players.
Abe has the conch at the start of the round, and if no one bids, he will go first.
He's trying a technology-focused strategy.
Since invention is the way to win the game, it's very efficient, but it can be hard to keep your tribe fed, and starvation can ruin your plans.
Brenda sits to Abe's left.
She's trying to pursue a strategy that relies on foraging.
It's a slower but safer strategy than hunting, and also gives her the freedom to go after certain inventions.
Chris is the third player.
He's pursuing a hunter-based strategy that ensures that his tribe will be well-fed.
But it might be hard for him to compete for special abilities later on in the game.
In this spread, the most interesting card is this one.
Baskets, which is an invention that grants its owner a considerable bonus to their foraging score.
Obviously, any of the players would derive a benefit from this card.
But Brenda will benefit most, since it suits her strategy best.
Abe bids first, since he starts with the conch, but he decides to pass, since he thinks that the other players will bid, and in Cavemen, you are allowed to jump back into an auction, even if you passed in an earlier round.
Brenda also passes, because she's betting Abe won't draft the card that she wants.
Chris decides he can't take a chance, and he bids two teeth to gain the conch.
He wins the auction and drafts baskets so that Brenda can't get it.
Moments like this are where the fun of the game really come from, and they require a number of conditions to be met in order for those situations to emerge.
To create that tension, players need to have both the desire and the ability to be in the bidding.
And in Cavemen, that means having sufficient total skill to make use of the card in question.
as well as enough teeth to make it worthwhile to participate in the auction.
In order to achieve this balance, I went through a huge number of evolutions of the deck before settling on the one that made it to print.
And I was only able to manage that complexity with the help of technology.
I started writing code on my Commodore 64 when I was 8 years old.
And I've been writing software professionally for the last 15 years.
So I suppose it's almost second nature that for me to record the information related to my games, be they analog or digital, in a computer readable format.
I chose to use a form of loosely structured data called XML to represent the dead.
XML, extensible markup language, was designed to be both human and machine readable and to permit evolution over time.
Data elements are represented as tags with names and values that you can expand on arbitrarily to suit your needs.
Since the data was human readable, I could work with it without any special tools, just a text editor like Windows Notepad, and it allowed me to quickly add and remove cards.
And since it was machine readable, I could use it for all sorts of automation.
from printing my prototype decks to running scripts that exercise different play scenarios.
Over time, however, editing the document by hand became a cumbersome, and importing the data into Excel, while helpful, was a tedious manual process.
So instead, I developed a piece of software that worked much like Excel, but used my XML document as its data source and would save a copy of the document every time I made a change.
This offered a number of key advantages.
For one thing, this automatic version tracking ensured that I never lost any of my ideas.
I could always go back to a previous revision.
Over the two and a half years I spent working on the game, I created more than 450 versions of the deck.
Sometimes they worked, but more often they didn't.
If I decided I didn't like the direction things were going in, I could simply go back through the history of the data and carry on from an earlier version.
Additionally, the flexibility that I had in adding and removing fields allowed me the freedom to discover over time what data was important to track and what was not.
As I conducted playtesting, I went back to my document and tried to incorporate what I learned.
Sometimes I needed to tweak a cost.
Sometimes I wanted to change the wording on a card.
But just as often, I was trying to capture data that was beyond just what appeared on the physical card.
I wanted data about how that card affected gameplay overall.
I wanted to understand how each card fit in, at which players selected them, and at what time.
Since there was no strict structure to the data, I could make up new fields as I went along, and I could remove them later without causing problems if the information didn't prove valuable.
This allowed me to incorporate playtesting metadata directly alongside my card data, so that I could then edit and analyze all of it using the same tool.
And this was how I identified the three core strategies that players generally followed.
I noted the number of cavemen that a player had and of which types at the time that an invention was taken and over time, certain patterns started to emerge.
The hunter strategy was characterized by selecting additional hunters early and gaining an advantage in food and teeth.
It's straightforward and effective, but it means that the player cannot leverage many of the higher cost inventions in the game.
The inventor strategy usually meant taking a thinker as your first recruit and then carefully managing your food supply while amassing inventions that only you could use.
It has the advantage of being efficient, but thinkers can't help you feed your tribe, so food often becomes a problem.
The elder strategy focuses on foraging as a safe food supply and can be dominant if it manages to acquire one of the few key inventions that help it gain teeth so that they can compete for fire at the end of the game.
Once I had made that discovery, I started including the strategies in my data.
When I designed a card, I would tag it with the strategy I was gearing it towards.
And then after playtesting, I would add additional information about the strategy being used by the player who drafted it.
This helped by not only making sure that the cards were doing what I designed them to do, but also helped me make sure that I could easily see how many of the cards I had intended to help each of the three major strategies.
If I added or removed cards, I could make sure that the strategies remained relatively equally supported.
I remember one time in particular where my playtesting data showed its value in an unexpected way.
I had been taking the game to designer meetups for playtesting sessions, and the game was generally well-received.
But there were a number of questions about the balance of the inventions in the game.
So, I had been steadily tweaking costs and swapping out cards, and gradually, a strange thing happened.
Players had stopped engaging in the auction.
Everyone was content to simply let the conch pass around the table and take what they could.
At first I thought this was some sort of anomaly or something particular to the way the cards had been drawn.
So I kept going the way I was going, trying to achieve a perfect balance between costs and benefits for the inventions relative to one another.
But looking back over successive versions of the data, I saw that during the process of balancing the invention costs, I had gradually increased the cost for the most useful inventions, thus putting them further out of reach for more players for more of the game.
As a result, all the tension was gone.
Somehow, more balanced costs killed contention.
That's when I realized that in order to make the game fun, I had to create sufficient opportunities for players to compete.
Leveraging the data that I had gleaned from playtesting, I identified inventions that were suited to multiple strategies.
Then, I made those inventions intentionally under-costed so that players would bid for the opportunity to draft them.
For example, the Feast Card allows a player to convert food into teeth.
This, of course, only works if you have enough food to spare, so it's not suitable for a player...
focus solely on invention, but it does work well for other players that can gain a surplus through hunting or foraging. If it appears late game, this is a card that is intended to be bid over because it's mathematically superior to all other ways of gaining teeth in the game.
Similarly, medicinal herbs greatly reduces the chances that you will incur losses when you go hunting.
This works well for both hunters and inventors because both of those strategies rely on hunting to gain food.
It's got the lowest possible cost, so anyone can take it, and it's more useful than many other cards at the two and three cost levels.
So this encourages players to compete over it.
Tabletop designers may not always think about the ways they can leverage technology to help them enrich an analog experience.
Balancing a set of cards can be a tremendously tedious task.
A single design decision can cause changes that ripple throughout the entire deck as cost curves shift and card counts are thrown out of balance.
Having software to make this more manageable encouraged me to take more chances, make bigger changes, and ultimately led to a better design.
Dan, it's a crime that you're not working in the digital game industry.
I think we have a question over here.
Sure.
So...
First of all, yeah, the tool is excellent.
I built something similar, but I was using Google Spreadsheets, which does a lot of this stuff.
But what I found was, and you can export things, export XML, you can do the revision history.
But what I found difficult was figuring out a way to actually visually display these cards.
I used HTML, but it's really hard to get that to print properly.
I'm just wondering what kind of tool you built or used for that display.
Yeah, that's a problem that I worked on.
I went through a few iterations on that.
First, I tried SVG, which turned out to be really difficult.
Don't recommend that.
So I tried using my second, more successful attempt.
I leveraged an external tool called NANDEC.
If you're a tabletop game designer, you might know this one.
It's actually.
scripting software that you write code to generate your cards. So out of my tool I would generate a script for Nandeck so I could leverage it to generate my cards and print them. So that worked a lot better. So whenever I'm building tools for a game, I'm thinking always about how I'm not spending time making my game. I was wondering if you measured the amount of time you invested in your tool because it seems like all of your work is spent on your tool. So I'm wondering if Like, with a video game usually when you work on your editor you're also like salvaging some of that technology for your game, but it seems like in this case there's absolutely no overlap.
Perfect test case for the tool has, yeah, nothing to do with the production.
Right.
And was there anything that you did to like make sure that the features you were adding were paying off on like an individual basis?
Because obviously the tool paid off, but there were a lot of like, you know, seems like luxury, quality of life stuff in your tool.
Did that work out well?
Yeah, I would say that without the benefit of the tool, I wouldn't be able to surface the same data that I was able to see with it.
It was kind of the thing that started as a hobby project, started very small.
Like I said, I was originally just tweaking the XML by hand in Notepad.
And then I was like, well, I'm a programmer.
I can do better than this.
And so I did.
And, you know, it evolved over time.
No, I never measured how much time I actually spent on it.
Like I said, it was kind of, you know, grew up with the game.
Over time, I just added more and more features.
And as I said, I spent years working on the game.
So it was...
I never really paid attention to, you know, how much time it was.
I don't... Because it was fairly generic, I didn't feel like it was wasted time because I am using it for future games as well.
Cool.
Thanks.
Thanks.
Let's take one more for Dan.
Thank you.
How much of the analytics stuff you got was out of the running your, you mentioned software to run games following certain strategies.
How much would you say came from that versus how much you got from watching and I presume recording human play sessions?
Did you record those and feed it back into analytics?
I recorded it in that I watched and then put the data back in.
And so I did do a certain amount of scripting and automation.
And what that allowed me to do, what that was generally to do was to just run algorithms to check my math.
Once I was comfortable with that, then it was pretty much all hand play testing that gave me the best results.
Thank you.
All right.
Thank you, Dan.
Thank you.
Thank you.
One of the funny things about games is that games and game designers are kind of like dogs, right?
I mean, as a species, you would never guess that, like, some strange little thing that looks like a shaved rat is also this...
the same, same species as a sort of huge, giant, hairy bear of a dog, right?
That is like ten times as large and looks like it's from a different planet.
So what's amazing about the, the, the designers that we have for you today is that they're so different.
And it's, it's my pleasure to introduce Bennett Foddy, who's going to give you a completely different kind of case study.
He's here to talk today about real-time physics in, in his game Super Pole Riders.
Bennett is a legendary indie game designer, best known for QWOP.
He's also a professor at the NYU Game Center, where I also teach.
Let's give it up for Bennett Foddy!
APPLAUSE Thanks, Eric.
So Super Pole Riders is a game of pole vaulting polo.
It's part of a compilation of four local multiplayer games called Sports Friends, which is out for PCs and PlayStations.
So the basic idea of Super Pole Riders is that players traverse an arena primarily by vaulting up on a pole vault pole, which allows them to kick a ball that's suspended on a wire towards a goal and score points, right?
So that's the basic layout of the game.
And what I'm going to talk about today is how I designed the input scheme for the pole, the pole pointing mechanics.
The game itself is a gamepad redesign of an older Flash game I made called Pole Riders.
A game that I thought had some pretty bad design flaws.
I was really unhappy with.
The original game is a browser game.
So you're using digital keys to control the pole.
And the way that works is you can only rotate the pole towards pointing up with the up key or towards pointing down with the down key.
And it moves really slowly and I think inaccurately and it feels unresponsive and very loose, which is funny but not very fun.
And I also had this really serious problem, which was that people were blocking the goal with their poles.
And, you know, this is super embarrassing to admit in front of a crowd like this, but my attempt to solve it was that I made the defending player have really weak arms if he was standing near his own goal, so he couldn't lift up his pole very well.
uh... which you can imagine not a very good solution doesn't work anyway because you can kind of like run towards the wall and get it wedged up there and then the other person can't score a goal. So I was really unhappy with that as well.
And I came to see all of those problems as stemming from a kind of a central conflict between the design goals of real-time input schemes, input schemes for real-time games, and the technical limitations when you're using a physics engine for your games.
So in real-time games, there is this thing that you want, which is a really tight correspondence between the control surface.
and the controlled object. So the classic example would be in Super Mario Brothers, your character is basically instantly in the air when you hit the jump button.
And, you know, what's more of a kind of a apropos example is really the design touchstone for my game is the arcade game 720 Degrees, the old Atari game, which has a special joystick called a spinner, which is a joystick that's constrained to the edge of a circle. So you can see you're only able to move it around the edge of the circle.
And then what it does is it makes the skateboard always point exactly where the spinner is pointing, no matter what.
So there is this one-to-one correspondence between the position of the joystick and the position of the skateboard in the digital realm.
And by contrast, games that have fully dynamic physics engines, which we're starting to see more and more of, typically use indirect controls that have a very weak correspondence between the input surface and the game.
Because At an engine level, you can't manipulate things in the same absolute direct way without risking glitches.
So, for example, this is Angry Birds.
In Angry Birds, what you do is you pull back on an invisible spring which attracts the bird towards your finger without it mattering whether or not the spring can get the bird all the way to your finger.
In fact...
If you made it so that the bird stuck absolutely to your finger's position, you'd get glitches if you put your finger over the ground, for example.
The physics engine wouldn't know what to do and you'd get flaws and glitches.
Or in Lander, you're applying this gentle thrust to a moving object with this thrust control to gradually alter its velocity.
So you can't make the position of the Lander correspond one to one to the thrust control.
You can't even make the velocity of it correspond one to one.
you're just applying a kind of weak acceleration.
And I think we still see a lot of physics-based games that are in that vein, using buttons or joysticks or triggers to control an acceleration, rather than have a kind of one-to-one correspondence.
And Pole Riders is a physics game, and it has this fully dynamic world, which means the players, the poles, and the ball are all able to push back on each other.
But it's also an action sports game, so I wanted the pole to be controlled with that one-to-one correspondence to the controls.
Which for the sequel meant using an analog stick, partly because we're also targeting consoles and PCs.
So those two things are in conflict, since in-game objects can push back on the digital pole, but they can't push back on the real thumbstick.
The pole can even get jammed against the walls or against environmental objects or players, in which case it won't do anything when you move the controller.
So it's going to completely break correspondence.
So when I went to make Super Pole Riders, I had the idea that I wanted to solve or at least reduce that conflict.
And so my approach was to start by making two grounding decisions, which I was reasonably confident were correct, and then to try and solve all of the kind of secondary problems which bubbled up out of those two decisions.
So the first grounding decision I made was the pole should always at least try to move so that it's pointing in the direction that you're pushing the analog stick, like the spinner joystick in 720 degrees.
So that...
allows you to at least have the goal of creating a strong or perfect correspondence between the game world, the pole in the game world, and then the analog stick on the game pad, because the pole is literally mimicking the motion of the thumb stick.
The second grounding decision I made was that the pole should be unrealistically heavy, much heavier than the player and the ball.
And that's for two reasons.
So the first is just a technical reason.
So the way these physics simulations work is if you've got two objects that are connected, they won't be stable unless they have similar mass, which in this case means that the mass of the very first part of the pole, the very first segment of it, has to be close to the player's mass.
So the total mass of the pole will be greater than the player.
And second, since the pole is the main element that you're controlling, that's where all of the kind of strategy and action happens.
I was thinking of the pole as being the real character, right?
It's the real avatar of the player.
So I wanted it to have physical dominion over the player's body.
So it, for that reason, needed to be far heavier than the player as well.
So I went about implementing it, and to do that, I anchored the pole to the player's body using a rotational joint.
So this is just a, you can imagine, like a little pivot joint that has a motor on it that can apply a rotational force or a torque to rotate the pole.
And the question is, how fast and how strong should the motor turn?
And so as a first step, what I did is I just gave it a proportional control, which just means that the torque of the motor.
is some arbitrary tunable constant, which I've written here as K, because I did a physics degree in college, multiplied by the difference between the joystick angle, the angle that you're pushing the joystick in, and the pole's angle in the game.
So the idea is that it's pushing hard when the pole is far away from the position that you're requesting with the joystick, and it lets up a little bit as you get closer.
So I also made it that if the person let go of the joystick altogether, the motor would just switch off.
But that leads to the problem of overshoot, right?
So the pole reaches its target quickly, but it's so heavy that the weak proportional torque, remember it's going down to a kind of force of zero at that point, can't stop this super heavy, fast moving pole when it reaches the target position.
You wind up with a wildly oscillating pole that never, never points where you want it to point.
So what I realized is that my two grounding decisions were in conflict.
So in engineering, I did some research, and in engineering, that sort of overstrute and oscillation is a problem that occurs in all kinds of systems, from the furnaces that heat up large buildings to thermostats in coffee makers and so on.
And they have a standard solution in engineering, which is to use what's called a PID controller, PID controller, which stands for Proportional Integral Derivative Control.
which takes the proportional control I described on the previous slide and it adds integral and derivative components to the proportional control.
Now, that sounds very complicated and technical, but it's not.
It just means that you're going to speed up the motor based on its angle relative to the target.
That's what we're already doing.
But you're also going to slow it down relative to its angular speed and to its average angle over time.
So you've got, instead of one constant K, you've got three constants, K1, K2, and K3.
These are just tunable constants.
And it turns out, you know, there's no magic way of tuning this system, whether it's a boiler or whether it's a video game.
The way people do it when they're fixing the furnace in your building is you just tune the numbers manually until you find the right combination of magic numbers.
I did that. Eventually I tuned these constants to the point where I had a reasonable blend of speed and stability.
So with that, with that added, it looks something like that.
And with the PID tuned, I was able to find this kind of, I think, a reasonable balance. Like, as good of a balance as you'll get with a super heavy pole.
And so I had, kind of, first pass of my direct pointing controls that I wanted with the heavy pole.
But latency is still a problem here, right?
You know, it's taking time for the pole to reach its target, which is a problem.
Because...
you know, although it takes time for the pole to rotate, your control stick can be moved around instantly.
So it was feeling sluggish.
It also breaking that one-to-one correspondence in the controls that I was going for.
And I'm spending a lot of time with the pole pointing in a direction that's different from where I'm pointing the stick.
In 720 degrees they have that same problem, but they were able to implement a fix in hardware.
This is the underside of that spinner controller.
There's a bike chain and a heavy weight hidden under the joystick.
So it just resists being moved around too fast.
So there's this hard mechanical limit on how fast you can rotate it.
which limits the rotation of the skateboard in the game.
But that's obviously not an option if you have a thumbstick on a gamepad.
It's also not an option to try to rotate the in-game pole as fast as the thumbstick because that would require near infinite forces in the physics simulation which will certainly cause bugs and glitches. So I couldn't do that.
You need controls that can respond instantly, but you can't force things in physics games to react instantly, especially if they're heavy.
So it's kind of a fundamental problem facing most physics-based games.
And I don't think it's usually solved well.
But I came up with two fixes to it.
So the first one is to add some one-to-one instant cosmetic feedback that's reacting instantly to the thumbstick, but which isn't part of the physics world.
So if you look closely here, I know it's subtle.
But the instant that I move my thumb stick, the player's elbows rotate.
So it looks like he's kind of twisting his upper arm to apply leverage to the pole.
So that kind of squares the circle, right?
We keep our slow, dynamic physics world without having glitches, but we're adding fast visual feedback elements that aren't part of the physics simulation.
So the controls now respond at least cosmetically perfectly to the joystick, at least in these kind of elbows.
And so players feel at least like the game is reacting to their input even though the pole, even if the pole is blocked, even if it can't rotate at all.
And I think that reduces the feeling of latency.
The second approach I took was to design the game so that the player is unconsciously encouraged to request positions with the thumbstick that are close to the pole's current rotation, current angle.
So it's like the player is enforcing one-to-one correspondence between the stick and the pole rather than the system.
So how do you do that?
Well, this is again back to 720 degrees.
What they do is they wipe you out if you point the stick in a direction that's perpendicular to the direction you're traveling in.
So it gives you this message you're trying to spin too far, it wipes you out.
So you usually, what you're doing when you're playing that game is you're trying to keep the joystick pointed in a direction that's close to the direction of travel, rather than making really fast corrections.
I couldn't do that in my game. I can't wipe people out because they moved the thumbstick too far.
But it did provide the inspiration for the actual fix that I came up with.
So while I was tuning the game, I realized that I could make the ball a lot lighter than the pole and the player.
And if I made the ball really light, then it would be easy to block it, either with the pole or with your body.
So then what you find when you test it is that the players want to spend more of their time in a defensive pole, either with the stick straight up or with the stick straight down, where they're trying to keep the pole still.
They're only making these kind of minor corrections, like in 720 degrees, to the angle of the pole.
So the thumbstick and the pole are usually pointing the same way.
And I don't think people really notice that they're doing it, but they're doing this job of bringing the thumbstick and the pole into one-to-one correspondence for you.
So you still have this kind of high latency and poor correspondence if you need to switch the pole's position suddenly, but you're only doing that a small proportion of the time.
So by making the ball extra light, I made the correspondence better more of the time.
Okay, but that solution leaves me with one further kind of problem, which is it brings back this problem from the original game.
So now that I can block with the pole, I can use the pole to block the goal indefinitely, since the ball can't pass through the pole.
So I really struggled with that problem.
I think it's evidenced by the fact that what I did with the Flash version, with his arms getting really weak when he was standing near his goal.
But after really kind of thinking about it for a long time, I found some solutions to this in level design.
So by adding a dip in front of the goal, so that when you're standing in it, your pole just can't reach high enough to block.
That was one solution.
Another level, I added a hole in the goal area, so you just can't stand there and defend.
And the other thing I did is I made some levels where there's this uncollidable backboard that the pole can't rest against.
Which means that if somebody comes and pushes you, the pole is just going to be pushed back past the goal and it's not able to defend anymore.
So that's how I designed the input scheme for Super Pole Riders.
It's a system that doesn't just happen at the level of interpreting the joystick movement and deciding what to do with that joint.
but also at the level of how the player and the ball objects are constructed.
How heavy they are and how the levels are designed.
And I think, in the end, that does a pretty good job of solving the fundamental conflict here.
I've got my fully dynamic physics world where everything can push back on each other.
And I've got a control system that corresponds, most of the time at least, to the thumbstick on a gamepad.
It's not as good as 720 degrees, but I think it's a lot better than the original version of the game, and it makes pretty good use of the analog sticks.
Thanks.
