1
00:00:06,208 --> 00:00:09,429
Hello and welcome to Simple and Powerful Animation Compression.

2
00:00:10,550 --> 00:00:13,411
I am Nicolas FrÃ©chette, a programming consultant.

3
00:00:13,571 --> 00:00:14,972
And the work I'll be presenting today

4
00:00:15,852 --> 00:00:18,653
was done for Eidos Montreal earlier last year.

5
00:00:18,673 --> 00:00:23,375
I am to remind you to please turn off noise-making devices.

6
00:00:24,255 --> 00:00:26,036
And at the end, if everything goes well,

7
00:00:26,076 --> 00:00:27,537
we should have time for questions.

8
00:00:27,797 --> 00:00:29,878
And I'll be waiting as well at the wrap-up room on 3022

9
00:00:30,078 --> 00:00:31,018
on this floor.

10
00:00:35,684 --> 00:00:39,425
Before we begin, I'd like to thank two other contributors

11
00:00:40,525 --> 00:00:42,086
who helped me along with the work

12
00:00:42,126 --> 00:00:43,286
I'll be presenting here today.

13
00:00:44,046 --> 00:00:48,767
First, Frederic Zimmer, with whom I bounced every idea

14
00:00:50,108 --> 00:00:51,968
here as well as many, many more

15
00:00:52,248 --> 00:00:54,209
that didn't make it into the presentation.

16
00:00:55,104 --> 00:00:58,645
And both him and Luke Mamakos contributed immensely

17
00:00:59,405 --> 00:01:01,265
with their past experiences working

18
00:01:01,285 --> 00:01:05,286
with animation compression and the results and lessons

19
00:01:05,446 --> 00:01:07,047
they learned doing so.

20
00:01:07,967 --> 00:01:09,767
And of course, none of this would have been possible

21
00:01:09,787 --> 00:01:11,047
without Eidos Montreal.

22
00:01:13,908 --> 00:01:16,349
We'll first begin with a bit of context,

23
00:01:16,649 --> 00:01:19,569
why we needed to revisit character animation

24
00:01:19,609 --> 00:01:20,469
compression in 2016.

25
00:01:23,262 --> 00:01:25,564
and what essentially prompt all of this.

26
00:01:26,405 --> 00:01:28,527
We'll then move on and take a quick look

27
00:01:28,768 --> 00:01:31,230
at the classic solutions in the industry

28
00:01:31,270 --> 00:01:32,471
to this well-known problem

29
00:01:33,312 --> 00:01:35,975
and what we looked at to inspire from.

30
00:01:35,995 --> 00:01:40,919
And of course, we'll finish with our own special blend,

31
00:01:41,600 --> 00:01:44,323
a new twist on an old technique

32
00:01:44,583 --> 00:01:46,765
and the surprising results that we got out of it.

33
00:01:49,945 --> 00:01:53,366
So last year, I was contracted by a game team

34
00:01:53,506 --> 00:01:56,768
working with a game engine from Rise of the Tomb Raider,

35
00:01:56,928 --> 00:02:00,750
which was released in 2015 on the Xbox One.

36
00:02:01,671 --> 00:02:03,471
And of course, they already had

37
00:02:03,511 --> 00:02:04,872
character animation compression,

38
00:02:05,452 --> 00:02:07,714
and in fact, they dated as far back as 1996, two decades.

39
00:02:11,243 --> 00:02:13,484
So they've been thoroughly battle-tested,

40
00:02:13,504 --> 00:02:16,465
they've been used in dozens of AAA titles,

41
00:02:17,806 --> 00:02:20,147
and the primary compression algorithm

42
00:02:20,688 --> 00:02:22,648
is based on linear key reduction.

43
00:02:23,329 --> 00:02:27,091
And they also had a fallback, less aggressive algorithm

44
00:02:27,611 --> 00:02:29,372
based on simple quantization.

45
00:02:29,852 --> 00:02:33,994
And we'll cover both of these flavors in a bit later.

46
00:02:36,010 --> 00:02:37,811
Now, the primary compression algorithm

47
00:02:38,412 --> 00:02:39,492
offered a pretty good size.

48
00:02:39,532 --> 00:02:44,115
And it hadn't been an issue so far in the past or even today.

49
00:02:44,915 --> 00:02:47,377
But as we were ramping up the number of characters

50
00:02:48,197 --> 00:02:50,098
on and off the screen that were animating,

51
00:02:51,139 --> 00:02:53,020
we started to notice that decompression

52
00:02:53,500 --> 00:02:55,581
was a little bit slower than we would have liked.

53
00:02:57,615 --> 00:03:01,137
And we were starting to get more and more issues with accuracy.

54
00:03:01,857 --> 00:03:04,298
Unfortunately, the legacy algorithm

55
00:03:04,818 --> 00:03:09,079
did not expose parameters that were very intuitive to tweak.

56
00:03:09,679 --> 00:03:13,200
And animators failing to get the accuracy that they needed

57
00:03:14,141 --> 00:03:16,782
on a clip-per-clip basis would revert

58
00:03:16,802 --> 00:03:18,682
to the less aggressive algorithm.

59
00:03:19,082 --> 00:03:23,544
And this was slowly pushing the size and the memory footprint

60
00:03:24,044 --> 00:03:25,545
higher and higher as time went on.

61
00:03:26,652 --> 00:03:30,735
And eventually, this culminated in a big problem for cinematics.

62
00:03:31,555 --> 00:03:34,857
Cinematics of course need very high accuracy.

63
00:03:35,197 --> 00:03:37,278
They're iconic moments in our game.

64
00:03:37,318 --> 00:03:42,681
There's a lot of time and energy and money that goes into making them as nice as we can

65
00:03:42,761 --> 00:03:43,742
possibly make them.

66
00:03:44,603 --> 00:03:45,943
They're also somewhat exotic.

67
00:03:46,003 --> 00:03:51,887
You can have all kinds of things and characters that get animated from animals to props to

68
00:03:51,927 --> 00:03:52,447
destruction.

69
00:03:54,037 --> 00:03:56,099
And the camera can get very close to them.

70
00:03:56,539 --> 00:03:59,501
So it's very important to get very high accuracy.

71
00:04:00,422 --> 00:04:04,224
And of course, size and the memory footprint still matter

72
00:04:04,264 --> 00:04:04,965
for cinematics.

73
00:04:05,245 --> 00:04:08,067
You walk into a room, and if you need to load from the

74
00:04:08,127 --> 00:04:11,830
disk a very large cinematic, then that takes a lot of time.

75
00:04:12,090 --> 00:04:14,432
And of course, you have to live with a runtime memory

76
00:04:14,472 --> 00:04:15,232
footprint as well.

77
00:04:16,833 --> 00:04:19,135
But the problem grew bigger than that.

78
00:04:19,615 --> 00:04:20,596
And we reached a point.

79
00:04:21,567 --> 00:04:26,529
where about 40% of our clips use the less aggressive algorithm.

80
00:04:27,390 --> 00:04:29,791
And that's a significant amount.

81
00:04:30,371 --> 00:04:33,233
And the reason we got here is because the quality is getting

82
00:04:33,453 --> 00:04:35,234
higher and higher as we collectively

83
00:04:35,294 --> 00:04:37,795
push the quality of our games higher.

84
00:04:38,255 --> 00:04:39,776
And so time is really the enemy.

85
00:04:39,816 --> 00:04:42,938
And this number will only ever go up with time.

86
00:04:43,878 --> 00:04:47,280
So it prompted us to revisit the animation compression.

87
00:04:48,729 --> 00:04:53,851
But unfortunately, the legacy code was not quite ideal to work with.

88
00:04:54,951 --> 00:05:01,273
By virtue of being very old, it aged somewhat poorly, like a lot of code tends to do.

89
00:05:02,014 --> 00:05:10,036
And sadly, the data format was not streaming-friendly, so we couldn't use it as a technique to fix

90
00:05:10,096 --> 00:05:11,417
our issues with cinematics.

91
00:05:11,537 --> 00:05:12,597
We needed a new approach.

92
00:05:14,465 --> 00:05:17,408
And, last but not least, nobody really wanted to

93
00:05:17,468 --> 00:05:19,651
get near it. The code was in a state

94
00:05:19,711 --> 00:05:23,234
where it wasn't particularly, and a number of people

95
00:05:23,454 --> 00:05:25,557
had tried in the past to improve on it

96
00:05:26,117 --> 00:05:28,199
and failed to significantly do so.

97
00:05:30,201 --> 00:05:33,785
So faced with these problems, we designed a number

98
00:05:33,825 --> 00:05:37,128
of goals to come up with a new solution.

99
00:05:38,284 --> 00:05:42,086
First and foremost, we wanted to tackle cinematics first.

100
00:05:42,587 --> 00:05:44,408
They're a more isolated problem.

101
00:05:44,548 --> 00:05:46,450
If we ever end up breaking anything,

102
00:05:46,570 --> 00:05:48,371
it only affects a small part of the game,

103
00:05:48,531 --> 00:05:50,873
and we don't grind the whole production floor to a halt.

104
00:05:51,474 --> 00:05:52,935
And it's also a little bit easier,

105
00:05:53,355 --> 00:05:55,457
because we can use streaming if we need to.

106
00:05:57,038 --> 00:05:58,880
And they're also very good candidates,

107
00:05:58,920 --> 00:06:01,201
because they have the highest accuracy requirement.

108
00:06:02,338 --> 00:06:05,059
We wanted to keep it as simple as possible.

109
00:06:05,299 --> 00:06:07,500
The time budget for this was only 20 days,

110
00:06:07,961 --> 00:06:08,821
which is very short.

111
00:06:09,441 --> 00:06:12,043
In those 20 days, I had to, of course, take a look

112
00:06:12,203 --> 00:06:14,024
at the old legacy code, figure out

113
00:06:14,064 --> 00:06:15,464
if there is anything to be done with it,

114
00:06:16,265 --> 00:06:18,986
implement whatever new solution that we can come up with.

115
00:06:19,486 --> 00:06:21,067
And of course, if we need to do streaming,

116
00:06:21,487 --> 00:06:23,768
it needs to fit in that time frame as well.

117
00:06:26,813 --> 00:06:29,133
If we're going to build this for the future,

118
00:06:29,514 --> 00:06:32,754
we want the decompression to be as fast as possible.

119
00:06:32,935 --> 00:06:35,255
We want it to scale to large numbers of bones,

120
00:06:35,835 --> 00:06:38,876
which are always increasing with cinematics.

121
00:06:40,156 --> 00:06:43,577
And the recent and not so recent hardware trends

122
00:06:44,238 --> 00:06:46,338
is for more memory and more cores,

123
00:06:46,858 --> 00:06:49,519
but each individual core is not dramatically

124
00:06:49,579 --> 00:06:51,240
becoming faster and faster.

125
00:06:52,314 --> 00:06:55,116
And essentially this means that it's becoming more

126
00:06:55,156 --> 00:06:57,897
and more common to have a slightly larger memory

127
00:06:57,917 --> 00:07:00,379
footprint if it means that we can work a

128
00:07:00,399 --> 00:07:01,079
bit faster.

129
00:07:02,440 --> 00:07:05,262
Essentially memory is becoming cheaper than cycles.

130
00:07:06,602 --> 00:07:08,784
Of course, we want very high accuracy, as I've

131
00:07:08,824 --> 00:07:09,284
mentioned.

132
00:07:09,704 --> 00:07:11,485
It's an important problem for us, and we don't

133
00:07:11,525 --> 00:07:14,107
want to go back to yesteryear where we had

134
00:07:14,247 --> 00:07:18,009
foot sliding and these sort of vibrating artifacts.

135
00:07:20,000 --> 00:07:23,701
We also had a small set of secondary goals.

136
00:07:25,181 --> 00:07:27,722
Obviously, we wanted to keep the size as small as

137
00:07:27,802 --> 00:07:30,562
possible, but it wasn't the primary issue for us.

138
00:07:31,042 --> 00:07:35,063
Primarily because we were hoping to fix that through

139
00:07:35,103 --> 00:07:36,124
streaming if we had to.

140
00:07:37,124 --> 00:07:40,085
But we don't want to leave any stones unturned, of course.

141
00:07:41,204 --> 00:07:47,152
Ideally, we want nothing or very little to tweak for our animators. I think we could

142
00:07:47,192 --> 00:07:52,759
all agree that animators' time is much better spent creating content, polishing content,

143
00:07:53,700 --> 00:07:59,467
than it is spent tweaking compression settings in the hope that the algorithm is not going

144
00:07:59,527 --> 00:08:00,468
to butcher their work.

145
00:08:02,184 --> 00:08:04,144
And last but not least, it would be really nice

146
00:08:04,204 --> 00:08:08,125
if we could supersede that decades old code

147
00:08:08,565 --> 00:08:11,766
and failing to do so, at least replace the weaker

148
00:08:12,026 --> 00:08:14,707
algorithm used by 40% of our clip.

149
00:08:18,207 --> 00:08:21,168
So armed with these goals, we took a look

150
00:08:22,248 --> 00:08:24,129
at the existing solutions in the industry

151
00:08:24,949 --> 00:08:25,949
that we could inspire from.

152
00:08:26,209 --> 00:08:29,590
And they roughly fall into four families or categories.

153
00:08:31,013 --> 00:08:34,956
signal processing, curve fitting, linear key reduction,

154
00:08:35,296 --> 00:08:37,117
and simple key quantization.

155
00:08:37,658 --> 00:08:39,079
So we'll talk a little bit about those.

156
00:08:41,301 --> 00:08:44,083
First up, we have signal processing.

157
00:08:45,043 --> 00:08:48,306
In this category, probably the most common or famous

158
00:08:48,826 --> 00:08:50,107
is based on wavelets.

159
00:08:51,108 --> 00:08:53,930
But you also have things like principal component analysis

160
00:08:54,391 --> 00:08:56,212
and various database approaches.

161
00:08:56,963 --> 00:08:59,366
Now, unfortunately, they're way too complex.

162
00:08:59,686 --> 00:09:03,149
And even a cursory overview in the presentation here today

163
00:09:03,910 --> 00:09:04,890
would be far too long.

164
00:09:06,131 --> 00:09:08,253
So I will redirect you to my blog if you're

165
00:09:08,273 --> 00:09:09,134
curious about this.

166
00:09:09,554 --> 00:09:11,656
There's a link on the last slide.

167
00:09:13,238 --> 00:09:16,340
And I go in depth as much as I could on the topic.

168
00:09:17,882 --> 00:09:21,345
We chose not to inspire from this technique, primarily

169
00:09:21,385 --> 00:09:23,987
because it was far too complex for our needs.

170
00:09:26,265 --> 00:09:28,346
Next, we looked at curve fitting.

171
00:09:29,286 --> 00:09:32,408
Curves are a very elegant solution for animation data.

172
00:09:33,428 --> 00:09:36,730
It's what is typically used in Maya, Max, and Motion Builder

173
00:09:36,790 --> 00:09:39,131
to represent animation data to animators.

174
00:09:39,852 --> 00:09:42,553
And the reason is very obvious if you look at the graph

175
00:09:42,573 --> 00:09:43,133
here on the right.

176
00:09:44,074 --> 00:09:44,754
The green curve.

177
00:09:46,426 --> 00:09:48,708
fits on about 60 keyframes or so.

178
00:09:49,229 --> 00:09:51,331
But I only need 10 control points

179
00:09:51,651 --> 00:09:53,212
to represent the whole curve.

180
00:09:53,773 --> 00:09:56,295
So it's very dense data-wise.

181
00:09:56,455 --> 00:09:57,296
It's very compact.

182
00:09:58,617 --> 00:10:02,161
And it can very accurately represent the animation data.

183
00:10:02,621 --> 00:10:04,743
So on the upside, it's a very sensible choice.

184
00:10:05,904 --> 00:10:06,565
It makes sense.

185
00:10:07,125 --> 00:10:09,487
It's common because it's apt.

186
00:10:10,248 --> 00:10:11,730
And it's also very compact.

187
00:10:13,120 --> 00:10:19,122
But the downsides are that for us, the original curves from Maya were not accessible through

188
00:10:19,282 --> 00:10:20,463
our existing pipeline.

189
00:10:20,963 --> 00:10:26,645
Essentially this would have meant that we would have had to recalculate the curves from

190
00:10:26,845 --> 00:10:28,945
our already discretized data.

191
00:10:30,906 --> 00:10:34,327
Decompression is also somewhat slow with this technique.

192
00:10:35,118 --> 00:10:40,899
primarily because you, for every track, rotation, and translation, you need to search which

193
00:10:40,959 --> 00:10:46,581
control points you need to interpolate from at a particular point in time. And you need

194
00:10:46,621 --> 00:10:50,882
to search over and over. Now, you can keep it fast by sorting your

195
00:10:50,922 --> 00:10:57,603
data and introducing a cursor, but that's somewhat medium implementation in complexity.

196
00:10:57,643 --> 00:11:00,664
You have to write a lot of code to get it right and get it competitive.

197
00:11:02,446 --> 00:11:05,807
And I wasn't sure if I had enough time in the 20 days

198
00:11:05,847 --> 00:11:06,287
that I had.

199
00:11:07,587 --> 00:11:10,528
It's also not so great for motion capture data,

200
00:11:10,688 --> 00:11:13,128
or any sort of data that is very noisy,

201
00:11:13,308 --> 00:11:16,809
such as offline simulation, destruction, clot,

202
00:11:16,869 --> 00:11:17,830
or hair simulation.

203
00:11:19,210 --> 00:11:20,870
And the reason for that is that the data,

204
00:11:20,950 --> 00:11:23,671
by nature of being very noisy, is not easily

205
00:11:23,751 --> 00:11:25,571
representable as a curve.

206
00:11:25,951 --> 00:11:29,092
And the overhead of each control point becomes too great.

207
00:11:32,433 --> 00:11:34,614
We also looked at linear key reduction.

208
00:11:35,615 --> 00:11:39,017
It's conceptually very similar to curve fitting.

209
00:11:39,437 --> 00:11:41,999
Instead of using a spline interpolation function,

210
00:11:42,079 --> 00:11:45,101
such as Hermite, we use linear interpolation.

211
00:11:47,183 --> 00:11:49,104
So we have our discretized samples,

212
00:11:50,064 --> 00:11:53,227
and we'll iterate on them and identify keys

213
00:11:53,547 --> 00:11:55,948
that can be linearly interpolated from their neighbors.

214
00:11:56,869 --> 00:11:59,351
And when we find them, we can just drop them,

215
00:11:59,751 --> 00:12:01,592
because they're trivially reconstructable.

216
00:12:03,429 --> 00:12:06,750
So the technique is reasonably simple and quick to implement.

217
00:12:07,170 --> 00:12:08,930
It's also reasonably compact.

218
00:12:09,610 --> 00:12:14,371
We make some minimal amount of effort to exploit the redundancy in the data.

219
00:12:15,911 --> 00:12:16,732
And it's very common.

220
00:12:16,772 --> 00:12:19,612
It was similar to the legacy implementation based on it.

221
00:12:20,112 --> 00:12:24,873
So it was very, already known by the animators and the other programmers working with this.

222
00:12:26,413 --> 00:12:29,434
Unfortunately, it was also similar to the existing.

223
00:12:30,783 --> 00:12:33,964
technique. As I mentioned, others had tried to improve on

224
00:12:34,024 --> 00:12:35,585
it and failed, and I wasn't sure in the

225
00:12:35,625 --> 00:12:37,425
amount of time that we had that I could

226
00:12:37,465 --> 00:12:40,046
significantly improve on it using the same technique.

227
00:12:41,646 --> 00:12:44,347
It's also like curve fitting, suffering from the same

228
00:12:44,407 --> 00:12:47,607
issues of slow decompression. And again, you can use

229
00:12:47,627 --> 00:12:50,628
the same tricks to keep it fast, which require

230
00:12:51,108 --> 00:12:52,548
some time to implement and get it right.

231
00:12:53,878 --> 00:12:57,400
And again, it's not terribly great for motion capture

232
00:12:57,520 --> 00:13:00,382
or noisy data, because again, there's not a lot

233
00:13:00,823 --> 00:13:02,304
of redundancy to exploit.

234
00:13:05,586 --> 00:13:08,928
And the last technique is the simplest one by far.

235
00:13:09,048 --> 00:13:10,630
It's just simple quantization.

236
00:13:11,150 --> 00:13:14,432
We have our discretized samples, and we make no effort

237
00:13:14,552 --> 00:13:15,513
to remove any of them.

238
00:13:15,973 --> 00:13:18,595
We retain everything and instead just focus on

239
00:13:19,436 --> 00:13:22,218
using a reduced number of bits to represent them.

240
00:13:24,449 --> 00:13:27,592
So it's really dead simple, which means that it's

241
00:13:27,632 --> 00:13:31,074
very fast to implement, very fast to decompress as

242
00:13:31,094 --> 00:13:33,616
well. There's hardly any code that goes into this.

243
00:13:34,477 --> 00:13:37,099
And it's also a solid foundation upon which to

244
00:13:37,139 --> 00:13:40,041
build on, because the other two techniques, like linear

245
00:13:40,081 --> 00:13:43,123
key reduction and curve fitting, essentially build on top

246
00:13:43,164 --> 00:13:45,145
of this. The remaining keys that you use to

247
00:13:45,205 --> 00:13:49,488
interpolate or the curve control points are generally stored

248
00:13:49,528 --> 00:13:50,990
on a reduced number of bits as well.

249
00:13:53,373 --> 00:13:57,274
So of course, the downside of the technique is that it's not very compact.

250
00:13:57,814 --> 00:14:04,277
The old legacy implementation that was causing our size to balloon up was essentially built

251
00:14:04,337 --> 00:14:06,117
around this, and it was an issue.

252
00:14:06,977 --> 00:14:12,319
But we deemed it good enough because we knew we could get it in a streaming-friendly format

253
00:14:12,379 --> 00:14:14,960
very quickly and solve our problem through that.

254
00:14:15,400 --> 00:14:18,201
So we decided to build on simple quantization.

255
00:14:19,144 --> 00:14:22,006
And then later on, if we have more time, we can build more

256
00:14:22,046 --> 00:14:23,366
complex solutions on top.

257
00:14:25,727 --> 00:14:29,949
So our solution essentially breaks down into four

258
00:14:30,109 --> 00:14:32,331
categories, or sections.

259
00:14:32,951 --> 00:14:36,513
We'll first talk about range reduction and how we use it to

260
00:14:36,553 --> 00:14:40,094
increase accuracy and be more aggressive with compression.

261
00:14:41,028 --> 00:14:45,912
we'll talk about uniform segmenting and how we use it for the same purpose as well as

262
00:14:46,053 --> 00:14:52,979
to speed up streaming. We'll talk about constant tracks or, and animated tracks and the ratios

263
00:14:53,560 --> 00:14:59,665
that, that we see in the wild. And of course we'll talk about quantization and the number

264
00:14:59,685 --> 00:15:01,547
of bits that we use per component.

265
00:15:04,335 --> 00:15:08,378
Range reduction boils down to talking about our tracks,

266
00:15:08,558 --> 00:15:11,680
or animated tracks, in terms of their range of motion.

267
00:15:12,601 --> 00:15:14,542
So for example, in a specific clip,

268
00:15:15,102 --> 00:15:19,245
I might have my elbow rotate by 120 degrees around some axis.

269
00:15:20,186 --> 00:15:23,668
Of course, the theoretical range is the full 360 degrees.

270
00:15:23,808 --> 00:15:25,569
But in this particular clip, it's only 120.

271
00:15:28,571 --> 00:15:30,693
If I want to quantize it on four bits,

272
00:15:32,291 --> 00:15:35,492
The natural thing to do is to split the full range

273
00:15:35,752 --> 00:15:36,992
onto 16 intervals.

274
00:15:37,573 --> 00:15:40,614
And that gives me a precision of 22 and 1â2 degrees.

275
00:15:41,934 --> 00:15:44,555
And it's immediately obvious what the issue here.

276
00:15:45,215 --> 00:15:48,936
I have a lot of intervals that fall far outside the actual

277
00:15:48,996 --> 00:15:50,137
effective range of my clip.

278
00:15:51,832 --> 00:15:54,634
So the smart thing to do is, of course, instead

279
00:15:55,154 --> 00:15:59,658
to partition our effective range into our 16 intervals, which

280
00:15:59,718 --> 00:16:02,379
increases our precisions by three in this example

281
00:16:02,419 --> 00:16:05,341
here, up to 7.5 degrees.

282
00:16:07,543 --> 00:16:10,245
Of course, the trade-off is that we now have some overhead.

283
00:16:10,265 --> 00:16:13,527
We need to store the range minimum value, as well as

284
00:16:13,547 --> 00:16:16,449
the range extent, in order to reconstruct our values.

285
00:16:17,870 --> 00:16:21,112
we have to normalize our values within that range as well,

286
00:16:21,533 --> 00:16:24,315
which is good for us, because it means that after this step,

287
00:16:24,755 --> 00:16:26,996
our rotation, translation, and scale data

288
00:16:27,557 --> 00:16:29,758
is now used in the same units.

289
00:16:29,818 --> 00:16:32,520
It's a scale value within the range between 0 and 1.

290
00:16:34,341 --> 00:16:36,102
And of course, reconstructing the value

291
00:16:36,182 --> 00:16:39,605
and performing range expansion is trivial.

292
00:16:39,725 --> 00:16:42,286
It's a multiply and add, which is

293
00:16:42,346 --> 00:16:44,428
very efficient with the hardware.

294
00:16:47,715 --> 00:16:52,437
We need six scalar values to represent a full track range.

295
00:16:53,497 --> 00:16:56,499
Each track type, rotation, translation, and scale, they

296
00:16:56,539 --> 00:16:57,920
all have three components.

297
00:16:58,360 --> 00:17:00,261
And we need the minimum and the extent for each.

298
00:17:01,261 --> 00:17:05,223
We store these six scalar values as full precision

299
00:17:05,283 --> 00:17:09,225
floats in our clip metadata, which boils down to 24 bytes

300
00:17:09,345 --> 00:17:10,245
per animated track.

301
00:17:12,771 --> 00:17:16,496
So with this, it means that we can increase our accuracy

302
00:17:16,796 --> 00:17:20,881
with a small overhead, which allows us to be much more

303
00:17:20,921 --> 00:17:25,127
aggressive in the compression of the actual track data.

304
00:17:25,187 --> 00:17:27,249
We can be more lossy, because the loss is not

305
00:17:27,309 --> 00:17:28,010
as visible anymore.

306
00:17:29,568 --> 00:17:31,930
Sadly, this is not great for short clips.

307
00:17:32,550 --> 00:17:36,033
If I only have two or three key frames, obviously, the

308
00:17:36,113 --> 00:17:38,975
overhead of the range information is going to offset

309
00:17:39,055 --> 00:17:41,117
a lot of the gains that I'm otherwise going to have.

310
00:17:41,757 --> 00:17:44,359
But in a general case, it's absolutely worth it.

311
00:17:44,699 --> 00:17:47,782
And range reduction is a cornerstone of our algorithm.

312
00:17:52,225 --> 00:17:57,846
Next we have uniform partitioning. We decided to split our clips into blocks of

313
00:17:57,946 --> 00:18:04,247
sixteen keyframes for three reasons. And why sixteen? Just because it seemed the

314
00:18:04,307 --> 00:18:08,828
sensible values, but in truth, we haven't had time to try anything else, and it

315
00:18:09,128 --> 00:18:15,249
worked out all right for us. So the primary reason for uniform partitioning

316
00:18:15,289 --> 00:18:19,150
is that, is that it makes seeking within the clip very fast and easy.

317
00:18:20,147 --> 00:18:22,710
for a specific point in time that I want to sample,

318
00:18:23,231 --> 00:18:26,315
I can quickly, within a simple index table,

319
00:18:26,415 --> 00:18:28,478
find which blocks I need to interpolate from.

320
00:18:29,119 --> 00:18:31,862
And this, of course, also makes it very easy

321
00:18:32,463 --> 00:18:34,526
to perform streaming ahead of time,

322
00:18:34,666 --> 00:18:36,128
finding out which blocks I need

323
00:18:36,188 --> 00:18:37,229
and bringing them into memory.

324
00:18:39,630 --> 00:18:46,555
And last but not least, it allows us to do range reduction again a second time per block.

325
00:18:47,055 --> 00:18:52,780
So we have two levels of range reduction. First at the whole clip level, and once more

326
00:18:53,520 --> 00:18:59,365
for within each block. And, again, we store the range information

327
00:18:59,385 --> 00:19:04,809
metadata within each block. Our six scalars this time are quantized onto

328
00:19:04,889 --> 00:19:07,471
eight bits, because they're essentially between zero and one.

329
00:19:08,583 --> 00:19:11,465
and that yields six bytes per animated track.

330
00:19:12,626 --> 00:19:13,987
You do have to be careful, though.

331
00:19:14,407 --> 00:19:19,831
Because we quantize the range information here, it means that the normalization step

332
00:19:20,071 --> 00:19:25,214
is now lossy, and you have to take into account that loss in order to get accurate results.

333
00:19:29,677 --> 00:19:32,059
We also have a lot of constant tracks.

334
00:19:32,654 --> 00:19:36,317
A character might have 200 bones with three tracks per bones.

335
00:19:36,417 --> 00:19:37,738
That's 600 tracks.

336
00:19:37,978 --> 00:19:40,761
But obviously, not everything is animated in every clip.

337
00:19:41,641 --> 00:19:43,162
So I wanted to know the proportions

338
00:19:43,203 --> 00:19:45,364
that we had to try and figure out

339
00:19:45,825 --> 00:19:49,648
what was the best way to take advantage of that.

340
00:19:50,388 --> 00:19:53,030
So I analyzed about 3,500 clips from various main characters.

341
00:19:57,485 --> 00:20:01,688
And I found out that bones are constant about 65% of the time.

342
00:20:02,228 --> 00:20:05,050
And the bind pose, 45% of the time.

343
00:20:05,891 --> 00:20:09,213
And that makes sense, because facial bones, IK bones, camera

344
00:20:09,233 --> 00:20:12,496
bones, they're only ever animated in the clips that

345
00:20:12,556 --> 00:20:13,457
actually need them.

346
00:20:16,339 --> 00:20:19,121
Tracks are also constant 87% of the time, and the bind

347
00:20:19,141 --> 00:20:19,881
pose 79% of the time.

348
00:20:23,658 --> 00:20:26,300
And again, this makes sense, because while rotation is very

349
00:20:26,400 --> 00:20:30,104
often animated, the translation and the scale is

350
00:20:30,164 --> 00:20:32,165
very rarely animated.

351
00:20:32,566 --> 00:20:38,731
In fact, scale in my data set was the bind pose 99.8% of the

352
00:20:38,771 --> 00:20:38,971
time.

353
00:20:40,733 --> 00:20:44,797
So to take advantage of this, we use two bitsets that we

354
00:20:44,857 --> 00:20:46,098
store in our clip metadata.

355
00:20:47,364 --> 00:20:50,146
we have one bit per track. That tells us

356
00:20:50,206 --> 00:20:51,887
whether the track is the bind pose or not.

357
00:20:52,207 --> 00:20:53,688
And if it is, then of course we can

358
00:20:53,789 --> 00:20:56,851
drop the entire track, because it's trivially reconstructible at

359
00:20:56,891 --> 00:21:01,314
run time. And our second bit set is again

360
00:21:01,454 --> 00:21:03,395
one bit per track, which tells us whether the

361
00:21:03,435 --> 00:21:06,597
track is constant or not. And if it's constant,

362
00:21:07,058 --> 00:21:08,999
then we store the one key that we need

363
00:21:09,379 --> 00:21:11,541
with full precision in our clip metadata.

364
00:21:12,967 --> 00:21:17,549
And from this follows that if a track is not the bind pose and it's not constant, then

365
00:21:17,629 --> 00:21:21,672
it's animated and variable, and it's quantized and compressed normally.

366
00:21:25,094 --> 00:21:27,055
And that takes us to the quantization step.

367
00:21:28,496 --> 00:21:33,539
And originally I did, like, almost all the implementations out in the world do, and I

368
00:21:33,599 --> 00:21:35,320
hardcoded the number of bits to 16.

369
00:21:36,902 --> 00:21:39,583
and I've seen as low as twelve in the wild.

370
00:21:40,183 --> 00:21:41,723
And that was that, and it worked, and it was

371
00:21:42,004 --> 00:21:44,925
entirely equivalent to the old legacy implementation.

372
00:21:47,346 --> 00:21:49,466
But one day, in the shower, I had a, a

373
00:21:49,766 --> 00:21:52,848
striking moment where I, I thought, well, what if

374
00:21:52,908 --> 00:21:55,128
I try to brute force search what is the

375
00:21:55,188 --> 00:21:56,549
best bitrate per clip?

376
00:21:57,655 --> 00:22:01,297
it's not that hard. So we try sixteen, fifteen, and

377
00:22:01,317 --> 00:22:03,299
then we go as low as we can up until

378
00:22:03,339 --> 00:22:06,040
we exceed some error threshold. And that worked out,

379
00:22:06,120 --> 00:22:08,522
and that gave us good gain. And then I

380
00:22:08,722 --> 00:22:12,064
started thinking, well, now that my bit rate is

381
00:22:12,345 --> 00:22:15,367
not hardcoded anymore, it's variable, how far can I

382
00:22:15,427 --> 00:22:15,847
push this?

383
00:22:17,748 --> 00:22:21,571
So a logical next step was, you know, to

384
00:22:21,820 --> 00:22:26,903
to observe that the rotation, the translation, and the scale data is, it's very different.

385
00:22:27,344 --> 00:22:33,948
The units are different. The data behaves very differently. It makes sense to, to store

386
00:22:34,449 --> 00:22:40,393
our, our bitrate, one for rotation, one for translation, and one for scale independently.

387
00:22:41,874 --> 00:22:47,418
And so that's what I did. I brute force searched three bitrates per clip for each track, track,

388
00:22:47,678 --> 00:22:48,498
track type.

389
00:22:50,237 --> 00:22:51,778
And again, that gave us very good gains.

390
00:22:51,818 --> 00:22:54,861
And if we can do it per clip, it's also very trivial

391
00:22:55,361 --> 00:22:56,562
to now do it per block.

392
00:22:57,783 --> 00:23:00,845
And this takes us to the last logical step

393
00:23:00,885 --> 00:23:02,026
that we can take this to.

394
00:23:03,287 --> 00:23:06,830
And it's, well, can I find the best individual track

395
00:23:06,890 --> 00:23:09,552
rate per track per block?

396
00:23:11,233 --> 00:23:14,956
And of course, this is really the holy grail here.

397
00:23:16,110 --> 00:23:22,815
because this new variable bitrate is absolutely ideal for animation data. It's ideal for

398
00:23:22,975 --> 00:23:28,819
our hierarchical data. Like everybody else out there, our animation data is compressed

399
00:23:28,879 --> 00:23:34,904
in local space of the parent bone. This means that every bone has a little bit

400
00:23:34,944 --> 00:23:40,568
of error due to compression, and the error accumulates down the hierarchy when we reconstruct

401
00:23:40,608 --> 00:23:42,029
it for skinning, for example.

402
00:23:43,576 --> 00:23:46,859
So of course, parent bones contribute more error

403
00:23:47,179 --> 00:23:49,061
by virtue of being higher in the hierarchy.

404
00:23:49,181 --> 00:23:51,863
So they need more bits to retain more precision.

405
00:23:53,584 --> 00:23:56,207
And conversely, children don't need as much precision

406
00:23:56,267 --> 00:23:57,788
because they don't contribute as much error

407
00:23:57,828 --> 00:23:59,890
and they only require fewer bits.

408
00:24:00,630 --> 00:24:03,333
And with a variable bitrate, we can entirely do this.

409
00:24:04,430 --> 00:24:06,832
We also have exotic tracks.

410
00:24:06,932 --> 00:24:09,533
We might have a track that's very noisy for some reason

411
00:24:09,593 --> 00:24:12,715
in the clip, or has a very wide range of values, which

412
00:24:12,775 --> 00:24:17,037
requires unusually high accuracy, or more bits.

413
00:24:17,837 --> 00:24:20,659
And with a variable bitrate, we don't need to bias the

414
00:24:20,679 --> 00:24:23,100
whole clip negatively.

415
00:24:23,860 --> 00:24:26,121
It's also great for temporal coherence.

416
00:24:26,942 --> 00:24:29,363
In cinematics, it's not unusual to have all your

417
00:24:29,403 --> 00:24:30,924
characters animated in sync.

418
00:24:31,993 --> 00:24:33,675
with clips that are all the same length.

419
00:24:34,095 --> 00:24:36,617
But if a character is off screen for a while,

420
00:24:37,057 --> 00:24:38,958
he's still animated, but he doesn't move.

421
00:24:39,418 --> 00:24:41,800
And with a variable bitrate, we can, of course,

422
00:24:42,540 --> 00:24:45,883
use fewer bits, if not zero, for the parts

423
00:24:46,043 --> 00:24:46,943
where they're not moving.

424
00:24:46,963 --> 00:24:51,426
And this, of course, adapts to all kinds of animation data,

425
00:24:51,606 --> 00:24:52,907
regardless of how it looks.

426
00:24:55,349 --> 00:24:58,451
We settled on 16 possible bitrates.

427
00:25:00,015 --> 00:25:04,418
zero, three, four, five, up to sixteen, and twenty-three.

428
00:25:05,539 --> 00:25:08,441
And the reason why we need it higher than sixteen

429
00:25:08,521 --> 00:25:12,744
is that some clips have unusually high precision requirements.

430
00:25:13,064 --> 00:25:17,087
For example, world space cinematics might have the root bone

431
00:25:17,127 --> 00:25:20,429
be very far, or a camera bone move very far,

432
00:25:21,110 --> 00:25:24,452
or maybe you're throwing a weapon very far ahead, like an arrow.

433
00:25:25,973 --> 00:25:29,295
So you need more than sixteen bones in a few rare cases.

434
00:25:31,630 --> 00:25:35,292
Unfortunately, 23 was perhaps a bad and naive choice,

435
00:25:35,492 --> 00:25:36,852
chosen a bit prematurely.

436
00:25:38,313 --> 00:25:40,534
Initially, I just selected it because it was the same

437
00:25:40,614 --> 00:25:43,416
as the float mentissa minus the sign bit.

438
00:25:43,956 --> 00:25:46,397
And that seems like a sensible choice at the time.

439
00:25:46,958 --> 00:25:49,839
But of course, as I was writing the presentation,

440
00:25:50,459 --> 00:25:52,821
I realized that the dequantization step

441
00:25:53,221 --> 00:25:56,602
requires our integer to be uniquely representable

442
00:25:57,043 --> 00:25:58,043
as a floating point number.

443
00:25:59,052 --> 00:26:02,593
and accurately representable. And of course, it turns out

444
00:26:02,653 --> 00:26:05,874
that a 32-bit float can only accurately and uniquely

445
00:26:05,954 --> 00:26:09,756
represents integers up to six significant digits.

446
00:26:10,836 --> 00:26:12,557
Essentially what this means is that there's some

447
00:26:12,637 --> 00:26:17,619
rounding happening here that we hadn't foreseen. So maybe

448
00:26:17,659 --> 00:26:22,621
something like nineteen might be enough. But really, in

449
00:26:22,661 --> 00:26:25,162
truth, we could probably really measure it. I don't

450
00:26:25,242 --> 00:26:27,943
know whether the rounding is really a big issue

451
00:26:27,963 --> 00:26:28,203
or not.

452
00:26:29,227 --> 00:26:32,830
or if 19 would be better, there's definitely room for improvement here.

453
00:26:35,152 --> 00:26:40,877
We do have one edge case, which is when a track bit rate is zero.

454
00:26:41,257 --> 00:26:44,420
It means that the track is constant within the block.

455
00:26:45,321 --> 00:26:50,205
Now, of course, if the track is constant, then we don't need range information, because

456
00:26:50,285 --> 00:26:52,286
our track extent is zero.

457
00:26:53,653 --> 00:26:56,835
And when that happens, we reuse the 48 bits

458
00:26:57,476 --> 00:26:59,017
that we had for our range information,

459
00:26:59,117 --> 00:27:02,600
and we store our constant key at that memory location

460
00:27:02,680 --> 00:27:05,662
with 16 bits per component, which is typically

461
00:27:06,123 --> 00:27:07,924
enough precision for what we need.

462
00:27:11,003 --> 00:27:15,187
So, so far on the compression side, almost everything is very, very trivial.

463
00:27:15,627 --> 00:27:21,211
We have our bit sets, we have our normalization within the range that we're calculating, it's

464
00:27:21,231 --> 00:27:22,872
a bunch of min-max, it's very trivial.

465
00:27:23,453 --> 00:27:27,455
The only really complex step is the bit rate selection.

466
00:27:29,077 --> 00:27:31,919
And to figure out how to do that, we need to talk about two things.

467
00:27:33,012 --> 00:27:38,196
First, we need a way to compare bit rates. Which bit rate is superior or inferior to

468
00:27:38,236 --> 00:27:42,860
which other bit rate? Now, it's obvious that a bit rate is better if it's slower, because

469
00:27:42,920 --> 00:27:48,185
it means a lower memory footprint. But it's only acceptable if it doesn't make us exceed

470
00:27:48,265 --> 00:27:54,010
some error threshold. So it's very important to be able to accurately and precisely measure

471
00:27:54,530 --> 00:27:58,854
the error that we introduce. And so we'll talk about our error metric function.

472
00:28:00,059 --> 00:28:04,781
And we also need a way to be smart about attacking the problem.

473
00:28:05,281 --> 00:28:10,022
Up until now, I've been brute-forcing which bitrate is the best.

474
00:28:11,523 --> 00:28:14,904
But now that I reach this point, I have 600 tracks,

475
00:28:15,504 --> 00:28:19,085
only a handful, or 50, 80 or so, that are animated,

476
00:28:19,445 --> 00:28:22,286
but I have 16 permutations to try per track.

477
00:28:22,726 --> 00:28:24,447
It's a huge search space.

478
00:28:24,847 --> 00:28:26,527
We can't afford to brute-force anymore.

479
00:28:26,587 --> 00:28:28,928
So we need a smart way to attack this.

480
00:28:34,167 --> 00:28:37,548
So measuring accuracy, it's really, really important.

481
00:28:38,309 --> 00:28:41,891
And in fact, it's an absolute cornerstone of our algorithm.

482
00:28:41,911 --> 00:28:44,432
And you'll see why later.

483
00:28:46,173 --> 00:28:49,435
It's important because our algorithm uses it to converge

484
00:28:49,915 --> 00:28:50,616
on a solution.

485
00:28:51,776 --> 00:28:54,618
And of course, we use it as well to compare our results

486
00:28:54,658 --> 00:28:57,780
with the other compression algorithms in the engine and

487
00:28:57,800 --> 00:28:58,720
other engines.

488
00:29:00,283 --> 00:29:02,864
You might be surprised to learn that it's often

489
00:29:03,024 --> 00:29:06,445
overlooked and poorly implemented, even in

490
00:29:06,565 --> 00:29:10,746
state-of-the-art game engines, such as what we had before.

491
00:29:12,186 --> 00:29:14,667
And there's no standard way to do this, either in the

492
00:29:14,707 --> 00:29:16,467
industry or academia.

493
00:29:17,568 --> 00:29:20,829
They all have their own special flavor of how to

494
00:29:20,889 --> 00:29:21,469
measure error.

495
00:29:21,549 --> 00:29:23,670
And of course, we are no different.

496
00:29:23,790 --> 00:29:26,090
And I will be presenting our own flavor here today.

497
00:29:28,042 --> 00:29:34,346
There's three criterias that an error metric really needs to meet that are critically important.

498
00:29:35,686 --> 00:29:39,729
It needs to account for the fact that our data is hierarchical in nature.

499
00:29:41,270 --> 00:29:48,173
It needs to account for the aggregate transform, the rotation, the translation, and the scale.

500
00:29:49,575 --> 00:29:51,416
And it also needs to account for the fact

501
00:29:52,057 --> 00:29:55,100
that we have a visual mesh, something that we often forget

502
00:29:55,380 --> 00:29:58,182
with animation data, because we're working with a skeleton.

503
00:30:00,885 --> 00:30:03,747
So the hierarchy is very important.

504
00:30:03,847 --> 00:30:06,589
As I mentioned, the error accumulates down the hierarchy.

505
00:30:07,290 --> 00:30:09,232
This makes it very obvious that if you

506
00:30:09,352 --> 00:30:11,414
use a local space error metric, you're

507
00:30:11,434 --> 00:30:13,555
not getting the full view of the true error

508
00:30:13,596 --> 00:30:14,436
that you're introducing.

509
00:30:15,393 --> 00:30:15,974
So that's bad.

510
00:30:16,034 --> 00:30:19,738
We really want to be using an object space arimetric because

511
00:30:19,778 --> 00:30:24,343
it allows us to see the full impact of our changes in bit

512
00:30:24,363 --> 00:30:25,024
rate selection.

513
00:30:27,307 --> 00:30:29,649
The aggregate error is also very important.

514
00:30:30,110 --> 00:30:33,313
It's very common, sadly, to measure the error with the

515
00:30:33,754 --> 00:30:35,876
bone position or the leaf bone position.

516
00:30:36,780 --> 00:30:39,842
But of course, it ignores the rotation and the scale

517
00:30:39,882 --> 00:30:41,983
contribution of that individual bone.

518
00:30:42,763 --> 00:30:45,885
And we need to take into account the full transform,

519
00:30:45,965 --> 00:30:48,346
because the error can be anywhere, not just

520
00:30:48,406 --> 00:30:49,487
on the translation.

521
00:30:54,269 --> 00:30:56,310
And last but not least, the error

522
00:30:56,390 --> 00:30:58,551
that we might measure on the skeleton is not.

523
00:30:59,447 --> 00:31:02,049
the same or equivalent as we would measure it

524
00:31:02,189 --> 00:31:04,831
on the visual mesh. The skeleton is never really

525
00:31:04,891 --> 00:31:07,954
visible, right. The visual mesh is what the users,

526
00:31:07,974 --> 00:31:10,676
what the designers, what the animators, what everybody sees.

527
00:31:12,418 --> 00:31:14,419
And the error is not the same, because with

528
00:31:14,459 --> 00:31:18,563
rotation and scale, the error actually increases the further

529
00:31:18,583 --> 00:31:21,245
away you get from the bone. And we can

530
00:31:21,305 --> 00:31:22,867
visualize it like this here.

531
00:31:23,727 --> 00:31:26,870
Suppose I have a bone with some rotational error.

532
00:31:27,932 --> 00:31:29,813
If I have a vertex that's skinned on that

533
00:31:29,873 --> 00:31:32,996
bone and it's very close to the bone, the

534
00:31:33,036 --> 00:31:37,640
linear displacement as a result, in red here, from

535
00:31:37,680 --> 00:31:39,702
that rotational error is gonna be fairly small.

536
00:31:40,583 --> 00:31:43,906
But if my vertex is much further away, for,

537
00:31:43,966 --> 00:31:46,168
with the same rotational error, all of a sudden

538
00:31:46,208 --> 00:31:50,211
my linear displacement is much larger. So, of course,

539
00:31:50,251 --> 00:31:53,074
it's a very important property, and we need to

540
00:31:53,114 --> 00:31:55,316
take it into account in our error metric function.

541
00:31:58,928 --> 00:32:01,990
And we can observe that the vertex displacement

542
00:32:02,030 --> 00:32:04,491
on the visual mesh is really the true measure

543
00:32:04,892 --> 00:32:06,893
of our accuracy. It's what everybody sees.

544
00:32:06,913 --> 00:32:09,254
It makes sense. That's what we should be measuring.

545
00:32:10,815 --> 00:32:13,417
And we end up with skinning being, essentially,

546
00:32:13,437 --> 00:32:16,659
our error metric function. And it satisfies, of course,

547
00:32:16,759 --> 00:32:19,120
all three criteria that we just talked about.

548
00:32:20,643 --> 00:32:22,705
Now unfortunately, it's way too slow.

549
00:32:23,486 --> 00:32:26,189
A character might have 200 bones, but it could

550
00:32:26,249 --> 00:32:28,991
easily have 50,000 vertices or much more.

551
00:32:30,153 --> 00:32:33,336
The mesh information might not even be available in

552
00:32:33,376 --> 00:32:36,059
your animation compression pipeline at that point in your

553
00:32:36,079 --> 00:32:36,559
pipeline.

554
00:32:37,300 --> 00:32:39,022
And you might not even know the true mesh

555
00:32:39,282 --> 00:32:41,905
if you're doing mesh sharing between the skeletons.

556
00:32:44,395 --> 00:32:46,736
And of course, some bones don't even have

557
00:32:47,356 --> 00:32:48,977
any vertices that are skinned on them.

558
00:32:49,177 --> 00:32:51,937
IK bones, camera bones, or the root bones of the characters,

559
00:32:51,997 --> 00:32:54,578
they don't have any vertices that are directly skinned on them

560
00:32:54,598 --> 00:32:55,238
that we can use.

561
00:32:56,278 --> 00:32:59,599
So instead, we use virtual vertices.

562
00:33:00,780 --> 00:33:02,880
These allow us to approximate the skinning.

563
00:33:04,020 --> 00:33:06,021
They satisfy, of course, all three criteria

564
00:33:06,081 --> 00:33:07,821
by virtue of being the same process.

565
00:33:08,793 --> 00:33:10,674
And it's also very intuitive to tweak.

566
00:33:10,734 --> 00:33:13,175
It's simply the vertex distance from the bone.

567
00:33:13,255 --> 00:33:16,816
So we approximate the skinning with a uniform shell,

568
00:33:16,956 --> 00:33:17,357
if you will.

569
00:33:18,817 --> 00:33:22,419
And the output is, of course, an object space displacement,

570
00:33:22,959 --> 00:33:23,599
like we want.

571
00:33:26,120 --> 00:33:29,401
In practice, internally, we settled on 3 centimeters

572
00:33:30,161 --> 00:33:34,183
for our normal bones, which comprise 99% of all our bones

573
00:33:34,363 --> 00:33:36,924
for main characters, props, and so on.

574
00:33:38,318 --> 00:33:42,240
And we also have one meter for high-accuracy bones.

575
00:33:42,801 --> 00:33:45,742
And which is which is, of course, animator-defined and

576
00:33:45,802 --> 00:33:50,164
data-driven, with the exception that the root bone

577
00:33:50,764 --> 00:33:54,526
is always considered to be high-accuracy, just because I

578
00:33:54,566 --> 00:33:57,287
wanted to be extra conservative with the data.

579
00:34:00,009 --> 00:34:04,251
So now that we can properly measure our error, and which

580
00:34:04,291 --> 00:34:07,052
bitrate is superior or inferior to which other

581
00:34:07,072 --> 00:34:07,352
bitrate.

582
00:34:08,589 --> 00:34:10,950
We need a smart way to trim our search space.

583
00:34:12,391 --> 00:34:14,392
So that we can compress, you know, in this entry.

584
00:34:16,474 --> 00:34:20,896
So we decided to do a two-phase approach to tackle the problem.

585
00:34:21,576 --> 00:34:24,978
We do a first pass to find an approximate solution.

586
00:34:26,382 --> 00:34:30,684
And then we do a second pass to refine it to the local minimum.

587
00:34:31,284 --> 00:34:32,885
And this is an important distinction.

588
00:34:33,505 --> 00:34:38,128
The algorithm I'll be presenting here today does not find the globally optimal solution

589
00:34:38,148 --> 00:34:41,849
of what is the best bitrate for all tracks and all blocks.

590
00:34:43,190 --> 00:34:48,913
We simply find a decent local minimum, so there's definitely some room for improvement

591
00:34:48,953 --> 00:34:50,054
here in the future, perhaps.

592
00:34:52,295 --> 00:34:54,476
And the way the algorithm works is like this.

593
00:34:55,727 --> 00:35:01,070
Initially, we'll set all our tracks to have the maximum amount of accuracy.

594
00:35:01,190 --> 00:35:03,991
The highest bitrate possible here, 23.

595
00:35:05,511 --> 00:35:07,152
And then we begin the first pass.

596
00:35:08,053 --> 00:35:13,255
And the goal of the first pass is to lower all the bitrates simultaneously in lockstep.

597
00:35:15,676 --> 00:35:19,778
As much as we can, up until we exceed an error threshold, and then we stop.

598
00:35:20,952 --> 00:35:24,273
with the exception that the root bone here on the top left

599
00:35:24,773 --> 00:35:28,114
remains locked to full precision during the first pass.

600
00:35:28,654 --> 00:35:32,135
And the reason for this is that in world space cinematics

601
00:35:32,195 --> 00:35:35,995
or any clip that requires unusually high precision

602
00:35:36,095 --> 00:35:37,836
on the part of the root bone here

603
00:35:38,436 --> 00:35:41,076
would negatively bias the first pass.

604
00:35:41,616 --> 00:35:44,857
So we leave it fixed for now.

605
00:35:46,298 --> 00:35:48,700
And so we lower our bitrate as much as we can,

606
00:35:49,020 --> 00:35:50,441
up until we can't anymore.

607
00:35:51,161 --> 00:35:52,642
And then the second pass begins.

608
00:35:52,782 --> 00:35:54,783
And the goal of the second pass is

609
00:35:54,823 --> 00:35:57,024
to iterate over each track individually

610
00:35:57,585 --> 00:35:59,526
and lower the bitrate as much as we can,

611
00:36:00,086 --> 00:36:02,608
up until we've processed all the tracks

612
00:36:02,928 --> 00:36:05,089
without exceeding our error thresholds.

613
00:36:09,299 --> 00:36:13,200
So in a sense, we minimize the bit rate very aggressively here.

614
00:36:13,880 --> 00:36:19,022
It also means that we maximize the error up to our threshold very aggressively.

615
00:36:19,902 --> 00:36:22,122
And it'll be made obvious in a future slide.

616
00:36:23,083 --> 00:36:25,883
This makes the threshold critically important.

617
00:36:26,604 --> 00:36:31,365
If it's too high, it's immediately obvious because we maximize the error up to it.

618
00:36:33,265 --> 00:36:35,686
I tried one millimeter in object space.

619
00:36:37,134 --> 00:36:43,678
and it proved far too high. For a third-person camera on a normal character, there was no

620
00:36:43,798 --> 00:36:48,380
error that was visible. No foot sliding, no vibration. But as soon as the camera came

621
00:36:48,460 --> 00:36:54,303
up close to the character, you could see the artifacts somewhat fairly obviously, which

622
00:36:54,724 --> 00:36:59,866
this essentially made it absolutely unsuitable for cinematics or whenever you're backing

623
00:36:59,986 --> 00:37:03,588
out on a wall and the camera's pushed in closer to the character.

624
00:37:06,303 --> 00:37:09,925
We settled on hard coding a tenth of a millimeter

625
00:37:10,445 --> 00:37:11,966
as our accuracy threshold.

626
00:37:12,646 --> 00:37:15,187
Now, a tenth of a millimeter, to put it into perspective,

627
00:37:15,728 --> 00:37:18,769
is about the average width of a human hair.

628
00:37:20,110 --> 00:37:21,631
So this is really awesome.

629
00:37:21,671 --> 00:37:27,774
It essentially means that our animations look pretty much

630
00:37:27,814 --> 00:37:28,635
like they do in Maya.

631
00:37:28,655 --> 00:37:31,256
There's no visual difference that you can see.

632
00:37:35,399 --> 00:37:37,803
And now we get to the results, the fun part.

633
00:37:38,324 --> 00:37:42,072
Unfortunately, the game this is going to be futurely shipped

634
00:37:42,192 --> 00:37:44,797
on has not been announced yet.

635
00:37:45,824 --> 00:37:47,626
And so I can't show any fancy videos.

636
00:37:47,686 --> 00:37:50,028
And even if I could, they would look essentially like

637
00:37:50,048 --> 00:37:50,708
they do in Maya.

638
00:37:50,788 --> 00:37:52,670
So that would not be terribly fun.

639
00:37:53,390 --> 00:37:57,314
Instead, what I did is I ran the compression on a large

640
00:37:57,834 --> 00:37:58,555
number of clips.

641
00:37:58,955 --> 00:38:00,336
I aggregated the results.

642
00:38:00,596 --> 00:38:01,937
I generated a bunch of charts.

643
00:38:02,518 --> 00:38:06,001
And I took out some concrete examples to kind of give you a

644
00:38:06,081 --> 00:38:08,983
glimpse of how it performs in the real world.

645
00:38:11,997 --> 00:38:16,942
So I aggregated about 3,900 clips for various characters,

646
00:38:17,142 --> 00:38:18,543
including the main character.

647
00:38:19,844 --> 00:38:24,068
The total compression time was 3.2 hours on a single thread,

648
00:38:24,669 --> 00:38:27,271
or 10 minutes multi-threaded on my desktop.

649
00:38:28,772 --> 00:38:33,056
The total sum of the clip length is about 5.4 hours at

650
00:38:33,597 --> 00:38:33,997
30 FPS.

651
00:38:34,077 --> 00:38:37,320
So it's definitely very significant and representative

652
00:38:37,560 --> 00:38:38,801
of our game as a whole.

653
00:38:41,458 --> 00:38:45,919
Here we have the distribution of the number of key frames

654
00:38:46,039 --> 00:38:46,480
per clip.

655
00:38:48,340 --> 00:38:50,421
And there's really only two things I want to point out

656
00:38:50,461 --> 00:38:50,641
here.

657
00:38:51,321 --> 00:38:54,823
The first is that we have about 22% of our clips that

658
00:38:54,863 --> 00:38:55,683
are very short.

659
00:38:55,783 --> 00:38:58,164
They use one block or less.

660
00:38:58,944 --> 00:39:02,425
Those obviously are not going to compress too well by virtue

661
00:39:02,465 --> 00:39:03,746
of having more overhead.

662
00:39:05,407 --> 00:39:11,029
And we have, in fact, up to 11% that use half a block or less,

663
00:39:11,209 --> 00:39:12,109
which is not great.

664
00:39:13,149 --> 00:39:17,451
Fortunately for us, we have about 49% of our clips that

665
00:39:17,551 --> 00:39:19,352
use three blocks or more, and that are going

666
00:39:19,372 --> 00:39:20,492
to compress very well.

667
00:39:24,067 --> 00:39:29,471
The total size on disk was about 168 megs for the sample set.

668
00:39:30,152 --> 00:39:33,234
And in comparison, the legacy size of the same set

669
00:39:33,774 --> 00:39:35,235
was around 300 megs.

670
00:39:35,776 --> 00:39:39,759
Now keep in mind, this was for 60% linear key reduction

671
00:39:40,799 --> 00:39:44,342
and 40% the legacy simple quantization.

672
00:39:45,683 --> 00:39:48,845
The average number of animated tracks is 56.

673
00:39:53,447 --> 00:39:58,848
Here we have the distribution of the error per clip in millimeters.

674
00:39:59,869 --> 00:40:05,550
And this slide makes it bleedingly obvious that the algorithm maximizes the error up

675
00:40:05,610 --> 00:40:06,271
to the threshold.

676
00:40:07,031 --> 00:40:12,813
As early as the 15th percentile or so, already the error is almost equal to the threshold.

677
00:40:16,034 --> 00:40:18,615
But never exceeding it, which is what we wanted.

678
00:40:21,600 --> 00:40:25,324
Here we have the distribution for our compression ratio

679
00:40:25,925 --> 00:40:26,926
in logarithmic scale.

680
00:40:27,867 --> 00:40:30,750
And we can see on the far left that there's a lot of clips

681
00:40:31,190 --> 00:40:33,493
that don't compress too well, as we suspected.

682
00:40:33,753 --> 00:40:35,134
They're probably very short.

683
00:40:36,135 --> 00:40:40,139
And even the median, 18 to 1, is not terribly great.

684
00:40:40,380 --> 00:40:42,502
But there's a lot of clips on the right that

685
00:40:42,542 --> 00:40:43,843
compress very, very well.

686
00:40:45,172 --> 00:40:48,252
And there's even quite a few exotic clips

687
00:40:48,332 --> 00:40:50,533
that compress abnormally well.

688
00:40:50,773 --> 00:40:53,554
3,000 to 1 is definitely not representative,

689
00:40:54,014 --> 00:40:57,074
but there were definitely about 10 to 20 of those.

690
00:40:57,555 --> 00:40:59,535
So I'm not quoting the average here,

691
00:40:59,615 --> 00:41:02,456
because it would obviously be very biased and meaningless.

692
00:41:04,596 --> 00:41:06,557
A quick word about the compression ratio

693
00:41:06,697 --> 00:41:09,177
is that it's absolutely meaningless

694
00:41:09,797 --> 00:41:12,298
unless you and I use the same formula

695
00:41:12,458 --> 00:41:13,758
to calculate the raw size.

696
00:41:16,028 --> 00:41:19,289
And here, my formula is the number of keyframes

697
00:41:19,630 --> 00:41:23,931
times the number of bones times 36 bytes per bone.

698
00:41:24,391 --> 00:41:26,792
And the 36 bytes comes from the fact

699
00:41:26,912 --> 00:41:29,753
that every bone key has three tracks,

700
00:41:30,553 --> 00:41:33,434
and each track is three components or three floats,

701
00:41:34,974 --> 00:41:36,475
which yields 36 bytes.

702
00:41:40,236 --> 00:41:42,536
And here, here is probably my favorite slide.

703
00:41:43,545 --> 00:41:47,708
This is the distribution of which bit rates ended up being selected.

704
00:41:47,888 --> 00:41:53,032
So horizontally, we have our bit rate buckets, 0, 3, 4, 5, up to 23.

705
00:41:54,052 --> 00:41:58,035
And vertically, we have how often it was selected by the algorithm.

706
00:42:00,457 --> 00:42:01,878
And there's two distributions here.

707
00:42:04,199 --> 00:42:06,440
is in our second phase of our algorithm.

708
00:42:06,480 --> 00:42:08,641
When we go over each track individually

709
00:42:08,741 --> 00:42:10,622
and we lower the bitrate as much as we can.

710
00:42:11,223 --> 00:42:12,763
In blue, we started at the root,

711
00:42:13,224 --> 00:42:14,684
going toward the leaf's bones,

712
00:42:15,005 --> 00:42:17,246
or parent first, children after.

713
00:42:17,946 --> 00:42:20,767
And in orange, we do the opposite.

714
00:42:20,807 --> 00:42:21,788
We start with the children,

715
00:42:22,328 --> 00:42:24,429
and we go up towards the parent and the root.

716
00:42:25,590 --> 00:42:27,311
Originally, when I wrote the algorithm,

717
00:42:28,352 --> 00:42:30,214
I started at the root going towards the leaves,

718
00:42:30,274 --> 00:42:32,257
and it seemed like a sensible choice to me.

719
00:42:32,717 --> 00:42:35,181
And then as I was generating the slide, I wondered,

720
00:42:35,641 --> 00:42:38,665
would the distribution look really different if I flipped

721
00:42:39,066 --> 00:42:40,888
the loop and went the other way around?

722
00:42:41,309 --> 00:42:42,811
And it turned out that it did.

723
00:42:44,171 --> 00:42:49,754
And we can see on the far left that, in orange, by starting with the children first, we have

724
00:42:49,954 --> 00:42:53,376
a larger incidence of lower bit rates.

725
00:42:53,516 --> 00:42:56,677
Zero, three, four, up to eight, we have much more of them.

726
00:42:57,197 --> 00:43:02,360
And this makes sense, conceptually, because we have more children than we have parents.

727
00:43:03,941 --> 00:43:09,864
But of course, by starting with the children first, it forces our parents to retain more

728
00:43:09,944 --> 00:43:12,445
precision for the same error.

729
00:43:13,563 --> 00:43:15,685
And so we also, on the right of the graph,

730
00:43:15,745 --> 00:43:19,049
we can see, starting at 13, 14, 15, 16, and 23,

731
00:43:19,609 --> 00:43:20,370
you can't see them.

732
00:43:20,470 --> 00:43:21,251
They're not zero.

733
00:43:21,291 --> 00:43:22,432
They're just very small.

734
00:43:23,153 --> 00:43:25,435
But they're all higher, starting with the children,

735
00:43:26,116 --> 00:43:27,157
going towards the parents.

736
00:43:30,587 --> 00:43:33,550
And essentially, the net result of this

737
00:43:33,570 --> 00:43:36,814
is that starting with the children first, going up,

738
00:43:37,595 --> 00:43:41,700
is 2% smaller in memory for no change in compression time,

739
00:43:41,860 --> 00:43:44,643
no change in accuracy, no change in decompression time.

740
00:43:45,584 --> 00:43:47,226
And of course, there's probably other ways,

741
00:43:47,727 --> 00:43:50,630
other orderings that you could think of to try here.

742
00:43:51,815 --> 00:43:53,716
I did try to take the best of the two,

743
00:43:54,056 --> 00:43:59,819
essentially doubling the compression time, but the result was less

744
00:43:59,999 --> 00:44:04,061
than a tenth of a percent. So definitely not worth it.

745
00:44:08,222 --> 00:44:10,523
So essentially we ended up with about ten percent

746
00:44:10,543 --> 00:44:13,825
of our tracks using three or four bits or

747
00:44:13,885 --> 00:44:19,647
less per component. Almost a quarter, twenty-two percent, using

748
00:44:19,867 --> 00:44:21,008
up to six or less.

749
00:44:22,160 --> 00:44:25,624
and almost half, 47%, using eight or less.

750
00:44:26,425 --> 00:44:30,431
And this is really what surprised me the most

751
00:44:30,751 --> 00:44:31,552
about our results.

752
00:44:32,173 --> 00:44:34,236
If a year ago you had come to me and told me

753
00:44:34,476 --> 00:44:36,879
that I could store a significant amount of rotation

754
00:44:36,899 --> 00:44:39,943
and translations on three or four bits per component,

755
00:44:41,013 --> 00:44:44,217
which is 9 or 12, a byte, a byte and a half

756
00:44:44,457 --> 00:44:46,359
for a whole rotation or a translation,

757
00:44:47,160 --> 00:44:49,382
and do so with sub-millimeter accuracy,

758
00:44:49,783 --> 00:44:51,485
I definitely never would have believed you

759
00:44:51,925 --> 00:44:53,246
without data to back it up.

760
00:44:53,787 --> 00:44:56,170
And it turned out that it was entirely possible.

761
00:45:00,513 --> 00:45:03,575
Here are some concrete examples that I pulled out

762
00:45:03,675 --> 00:45:04,215
from the set.

763
00:45:05,035 --> 00:45:07,576
These are all for our main character.

764
00:45:08,357 --> 00:45:11,718
We have a short scramble animation, which is very fast.

765
00:45:12,318 --> 00:45:15,519
We have a normal idle slow animation.

766
00:45:16,260 --> 00:45:17,920
We have a regular walk cycle.

767
00:45:19,081 --> 00:45:21,562
And of course, a very long cinematic.

768
00:45:22,882 --> 00:45:25,963
The number of animated tracks ranges from 11% to 16%, so

769
00:45:26,043 --> 00:45:26,424
fairly low.

770
00:45:31,456 --> 00:45:33,939
We have, of course, the raw size, compressed size,

771
00:45:33,999 --> 00:45:36,321
yielding us a compression ratio, which

772
00:45:36,401 --> 00:45:40,546
is very decent between 20 to 1 and 32 to 1.

773
00:45:40,746 --> 00:45:43,049
And we can see the cinematic compressing very well

774
00:45:43,169 --> 00:45:44,330
with 28 to 1.

775
00:45:47,373 --> 00:45:50,537
I also extracted the average keyframe size,

776
00:45:50,577 --> 00:45:53,160
because I thought it was very telling.

777
00:45:54,288 --> 00:45:58,811
This is the number of bytes to represent all tracks at a

778
00:45:58,852 --> 00:45:59,932
particular point in time.

779
00:45:59,992 --> 00:46:02,234
So a whole key frame across all tracks.

780
00:46:03,936 --> 00:46:06,538
And what we can see here is that essentially fits between

781
00:46:06,598 --> 00:46:08,079
three and five cache lines.

782
00:46:09,060 --> 00:46:12,402
So when we're sampling our clip, we need to interpolate

783
00:46:12,422 --> 00:46:13,563
between two key frames.

784
00:46:13,944 --> 00:46:17,146
So we need to read twice that amount of bytes, essentially,

785
00:46:17,166 --> 00:46:17,767
to interpolate.

786
00:46:18,207 --> 00:46:19,848
Of course, there's other things like the range

787
00:46:19,888 --> 00:46:21,249
information that you need to read.

788
00:46:21,885 --> 00:46:24,926
But the track data is very dense and compact.

789
00:46:25,947 --> 00:46:26,707
It's all linear.

790
00:46:27,227 --> 00:46:31,329
And it contributes directly to our decompression speed being

791
00:46:31,390 --> 00:46:32,250
very, very fast.

792
00:46:33,010 --> 00:46:36,432
These numbers are on the Xbox One in microseconds.

793
00:46:36,612 --> 00:46:38,573
And they range between 27 and 33.

794
00:46:40,254 --> 00:46:42,955
And there's a number of things that we can say about this

795
00:46:43,055 --> 00:46:43,536
number here.

796
00:46:44,536 --> 00:46:48,578
The first is it's about half or twice as fast as the old

797
00:46:48,618 --> 00:46:51,500
legacy linear key reduction algorithm.

798
00:46:52,439 --> 00:46:55,520
And it's also much more predictable and consistent.

799
00:46:55,760 --> 00:46:59,301
The old algorithm varied a lot in decompression time,

800
00:46:59,341 --> 00:47:01,502
depending on how far along in the clip we were.

801
00:47:02,242 --> 00:47:04,663
Whereas here now, it's always very predictable.

802
00:47:06,163 --> 00:47:07,964
It also probably could be a little bit lower.

803
00:47:08,964 --> 00:47:11,605
I did not get to spend as much time on it optimizing

804
00:47:11,645 --> 00:47:12,285
as I would have hoped.

805
00:47:12,305 --> 00:47:14,566
And there remains some low-hanging fruits.

806
00:47:16,860 --> 00:47:19,361
Another reason why the decompression is very fast

807
00:47:19,541 --> 00:47:23,682
is that our compression format for rotations

808
00:47:24,342 --> 00:47:28,243
is the same as at the runtime when we're blending our poses.

809
00:47:28,823 --> 00:47:31,224
And that format is the quaternion logarithm.

810
00:47:31,684 --> 00:47:34,445
It's essentially the rotation axis multiplied

811
00:47:34,885 --> 00:47:35,925
by the rotation angle.

812
00:47:35,985 --> 00:47:36,765
So three floats.

813
00:47:39,626 --> 00:47:41,887
So that means, essentially, that there's no conversion

814
00:47:42,367 --> 00:47:43,467
to or from quaternion.

815
00:47:43,807 --> 00:47:46,028
There's no square root to reconstruct anything.

816
00:47:47,087 --> 00:47:49,508
That keeps it very fast.

817
00:47:51,109 --> 00:47:53,870
These numbers are also somewhat of a worse case,

818
00:47:54,150 --> 00:47:56,412
because they're for the main character, which has more

819
00:47:56,452 --> 00:48:00,254
bones, typically ranging between 180 and 200, I

820
00:48:00,294 --> 00:48:01,334
believe, for the cinematic.

821
00:48:02,595 --> 00:48:05,877
Whereas our NPCs have, of course, far fewer bones than

822
00:48:05,917 --> 00:48:09,058
this, and will decompress even faster.

823
00:48:11,633 --> 00:48:16,478
So in conclusion, we've really hit a sweet spot with the technique.

824
00:48:16,798 --> 00:48:21,883
It's very fast to decompress, and it would be hard to make it significantly faster.

825
00:48:22,544 --> 00:48:28,249
It's also reasonably compact, so much so that we decided to use it across the board and

826
00:48:28,369 --> 00:48:30,251
supersede all the legacy stuff.

827
00:48:32,313 --> 00:48:36,957
And we did not even need to resort to streaming, because the memory footprint was good enough

828
00:48:36,997 --> 00:48:37,498
at that time.

829
00:48:39,396 --> 00:48:42,197
And it's also very high accuracy and tunable,

830
00:48:43,618 --> 00:48:45,439
which makes it future-proof.

831
00:48:45,519 --> 00:48:47,019
If the number of bones increases,

832
00:48:47,620 --> 00:48:50,161
if the data increases in complexity,

833
00:48:50,741 --> 00:48:52,502
the algorithm will adapt very well.

834
00:48:54,483 --> 00:48:56,084
It's also very versatile.

835
00:48:56,484 --> 00:48:58,765
It works out right out of the box,

836
00:48:58,945 --> 00:49:01,746
regardless of the animation, the rig,

837
00:49:02,266 --> 00:49:05,068
or however the data looks, if it's noisy or not noisy.

838
00:49:06,332 --> 00:49:07,212
It adapts very well.

839
00:49:07,772 --> 00:49:10,312
There's nothing to tweak for the animators.

840
00:49:10,592 --> 00:49:14,793
It's excessively rare for us to go and mark a bone

841
00:49:15,133 --> 00:49:16,754
as high accuracy.

842
00:49:16,794 --> 00:49:18,734
And when we do, we typically do on the rig.

843
00:49:19,454 --> 00:49:22,055
And then it just works everywhere else.

844
00:49:23,775 --> 00:49:27,135
And it's good enough that we don't need any more fallback

845
00:49:27,516 --> 00:49:31,536
compression algorithm for when it messes up, because it

846
00:49:31,616 --> 00:49:33,677
always meets our accuracy requirements.

847
00:49:35,017 --> 00:49:35,977
So one algorithm.

848
00:49:36,635 --> 00:49:43,776
for all our animations. And of course, it's bleedingly simple. It took

849
00:49:43,856 --> 00:49:49,757
twenty to twenty-five days to implement, and there's so little code and it's so easy

850
00:49:49,777 --> 00:49:54,418
to comprehend that there's been no maintenance on it. Only a single bug surfaced in the first

851
00:49:54,478 --> 00:50:00,759
month, and it's been in use for over a year now. And this makes it very easy to build

852
00:50:00,919 --> 00:50:05,600
on and improve, and I'm sure you can think of many ways that this could be improved on.

853
00:50:09,602 --> 00:50:15,249
And that's it. We reached the questions. You're free to go on my blog. I discuss all of these

854
00:50:15,509 --> 00:50:21,957
techniques. And I'll be posting the content of the presentation in deeper detail as well

855
00:50:23,138 --> 00:50:27,844
in due time. And if we exceed the time for the questions, I'll be at room 3022 at the

856
00:50:27,904 --> 00:50:28,385
end of the hall.

857
00:50:48,985 --> 00:50:49,706
Hi, great talk.

858
00:50:51,087 --> 00:50:53,248
What was the workflow for animators?

859
00:50:53,749 --> 00:50:56,330
So you'd create an animation clip, then you'd have to go

860
00:50:56,370 --> 00:50:57,091
through this algorithm.

861
00:50:57,131 --> 00:50:57,871
How did that work out?

862
00:50:58,992 --> 00:51:03,755
Right, so before, animation clips would be imported into

863
00:51:03,815 --> 00:51:06,617
some animation set for a particular character.

864
00:51:08,329 --> 00:51:11,771
And typically, it would use the default algorithm

865
00:51:11,791 --> 00:51:12,771
with the default settings.

866
00:51:12,991 --> 00:51:15,873
And then if in game they saw that the accuracy was not

867
00:51:15,933 --> 00:51:19,154
as good as they would like, they would go and change

868
00:51:19,174 --> 00:51:20,995
the compression settings as needed

869
00:51:21,055 --> 00:51:24,237
and typically fall back on the lesser compression algorithm.

870
00:51:24,617 --> 00:51:26,498
But now with the new algorithm, there's

871
00:51:26,558 --> 00:51:29,359
nothing that's exposed for the animator to tweak.

872
00:51:29,439 --> 00:51:32,220
We hardcoded the threshold to keep it simple.

873
00:51:32,741 --> 00:51:35,702
But in truth, it might be a bit overly conservative.

874
00:51:37,002 --> 00:51:38,943
So the compression was already part of their workflow?

875
00:51:39,243 --> 00:51:40,283
Yes, absolutely.

876
00:51:40,443 --> 00:51:43,244
It was always present for the last 20 years.

877
00:51:43,904 --> 00:51:46,625
It was just old.

878
00:51:47,366 --> 00:51:47,546
Thanks.

879
00:51:47,606 --> 00:51:52,207
Hi.

880
00:51:52,767 --> 00:51:54,848
You say you store the quaternion logarithms?

881
00:51:55,328 --> 00:51:55,568
Yes.

882
00:51:55,668 --> 00:51:56,789
And that avoids a square root.

883
00:51:56,909 --> 00:52:02,030
But if you need the quaternion, you'd need a cosine, right?

884
00:52:03,317 --> 00:52:03,537
Is that?

885
00:52:03,557 --> 00:52:03,757
Yes.

886
00:52:04,678 --> 00:52:06,920
Internally, when we're blending our poses,

887
00:52:07,160 --> 00:52:11,043
we use quaternions logarithms during the blending process.

888
00:52:11,083 --> 00:52:14,666
So we only ever convert to quaternions at the very end

889
00:52:14,806 --> 00:52:16,707
once we have the final blended pose.

890
00:52:17,068 --> 00:52:19,029
We convert it to quaternions and matrices,

891
00:52:19,510 --> 00:52:20,971
and then we work with that for skinning.

892
00:52:22,172 --> 00:52:24,073
OK, I was just curious about, yeah.

893
00:52:24,454 --> 00:52:26,395
So we use quaternions throughout, so I was.

894
00:52:27,356 --> 00:52:28,777
Yeah, it was a very unusual.

895
00:52:30,283 --> 00:52:34,746
choice. It was the only engine I ever saw using quaternion logarithms for blending.

896
00:52:35,346 --> 00:52:40,990
But it remains a very sensible choice for the compression format because it's three

897
00:52:41,070 --> 00:52:46,254
floats as opposed to four for quaternion. And it may not be the best representation,

898
00:52:46,454 --> 00:52:48,455
but it's definitely legit.

899
00:52:49,416 --> 00:52:56,661
Q I think you touched on this a little bit, but did you notice any artifacting with going

900
00:52:56,701 --> 00:52:57,481
between any

901
00:52:59,277 --> 00:53:03,478
any additive animations being at a different compression rate than the animation that they

902
00:53:03,498 --> 00:53:04,138
were being applied to?

903
00:53:04,158 --> 00:53:12,720
The, well, with a tenth of a millimeter, it was never very visible. The only instances

904
00:53:12,780 --> 00:53:18,861
where we saw artifacts were with very, very large props, where the vertices were much,

905
00:53:18,981 --> 00:53:24,442
much further away than our one meter threshold allowed. And in those instances,

906
00:53:26,355 --> 00:53:31,377
because the actual value of the vertex distance was not exposed, only the

907
00:53:32,177 --> 00:53:34,238
boolean for default or high precision,

908
00:53:34,898 --> 00:53:37,859
we added intermediary bones that are never animated

909
00:53:38,499 --> 00:53:41,880
just so that the final bone that we're skinned on is actually closer to our

910
00:53:41,920 --> 00:53:46,102
threshold and that was good enough for us. All these bones, by virtue of being

911
00:53:46,142 --> 00:53:47,782
never animated, they

912
00:53:48,122 --> 00:53:49,003
compress trivially.

913
00:53:49,523 --> 00:53:51,424
So you saw it in your attachments, not in your blending.

914
00:53:51,924 --> 00:53:52,064
Yeah.

915
00:53:55,030 --> 00:53:56,431
Hi, excellent talk.

916
00:53:57,191 --> 00:54:00,333
Regarding the measuring accuracy, you said you used a

917
00:54:00,373 --> 00:54:02,335
mesh vertex to join data.

918
00:54:02,355 --> 00:54:06,317
I was just wondering, would the curvature of the track

919
00:54:06,377 --> 00:54:09,559
would be a better heuristic to choose a bit rate?

920
00:54:10,900 --> 00:54:11,720
I'm sorry, can you repeat?

921
00:54:11,780 --> 00:54:13,582
What would be a better heuristic?

922
00:54:13,702 --> 00:54:17,684
The curvature of the track, because it kind of tells you

923
00:54:17,724 --> 00:54:19,285
the acceleration of the value.

924
00:54:19,983 --> 00:54:22,147
would that be a better heuristic?

925
00:54:22,729 --> 00:54:26,696
Right, so you're wondering if using basically the velocity

926
00:54:27,758 --> 00:54:29,602
would be a better measure.

927
00:54:29,642 --> 00:54:31,746
To store the precision better.

928
00:54:31,826 --> 00:54:32,007
Right.

929
00:54:33,135 --> 00:54:37,059
It's possible. You could definitely factor it in into the metric function.

930
00:54:37,320 --> 00:54:37,560
Okay.

931
00:54:38,021 --> 00:54:41,565
The metric function you can make arbitrarily complicated.

932
00:54:41,805 --> 00:54:46,791
And you could definitely use this, for example, with blend shape animated coefficients,

933
00:54:47,272 --> 00:54:50,596
but then the data is not hierarchical anymore. You would have a different error metric.

934
00:54:51,637 --> 00:54:52,558
But you didn't try that.

935
00:54:53,098 --> 00:54:55,179
No, we haven't tried that.

936
00:54:55,459 --> 00:54:59,201
I went straight to this because it was somewhat close to what

937
00:54:59,281 --> 00:55:00,761
Unreal 4 uses, for example.

938
00:55:01,182 --> 00:55:04,763
But I generalized it with virtual vertices over every bone

939
00:55:04,803 --> 00:55:06,124
and not just the extremities.

940
00:55:06,604 --> 00:55:06,784
Cool.

941
00:55:06,824 --> 00:55:07,104
Thank you.

942
00:55:07,124 --> 00:55:11,066
Hi.

943
00:55:11,926 --> 00:55:14,368
What was the worst case steps in terms

944
00:55:14,408 --> 00:55:17,289
of hierarchy of the bones of the animation that you compressed?

945
00:55:18,928 --> 00:55:19,769
That's a good question.

946
00:55:20,790 --> 00:55:23,892
I think for most characters, it doesn't really go...

947
00:55:25,213 --> 00:55:30,077
Most of our characters are humanoids, so the depth is maybe five or six.

948
00:55:31,898 --> 00:55:33,540
We did have some animals, though.

949
00:55:34,801 --> 00:55:42,827
I believe we had some sort of large predatory cat, feline, which obviously had much more

950
00:55:42,887 --> 00:55:44,007
bones for the tail.

951
00:55:45,287 --> 00:55:47,668
and the paws and the spine was also a bit longer.

952
00:55:48,168 --> 00:55:51,069
And that particular character is really what caused

953
00:55:51,089 --> 00:55:53,570
the most issues and prompted the whole discussion

954
00:55:54,130 --> 00:55:56,811
over the compression artifacts in the first place.

955
00:55:57,131 --> 00:55:58,071
Okay, great.

956
00:55:58,391 --> 00:56:00,752
Because we had a case where the character

957
00:56:00,832 --> 00:56:02,453
actually carried a chain or something then.

958
00:56:02,853 --> 00:56:03,713
That was a nightmare.

959
00:56:03,733 --> 00:56:05,194
So we had to actually flat the sinks out

960
00:56:05,534 --> 00:56:06,254
in terms of skeleton.

961
00:56:06,774 --> 00:56:10,477
Yeah. That's why an object space error metric is very important,

962
00:56:10,678 --> 00:56:14,000
because that way, regardless of how deep the chain is,

963
00:56:14,040 --> 00:56:18,324
you always have the true measure of the error that's introduced.

964
00:56:18,444 --> 00:56:23,348
But that sounds like it will start out maxed out from the beginning,

965
00:56:23,408 --> 00:56:26,611
so yeah, probably wasn't effective. Thank you.

966
00:56:26,631 --> 00:56:27,311
All right.

967
00:56:29,313 --> 00:56:32,876
So I believe that's, yeah, almost all the time we have.

968
00:56:32,896 --> 00:56:34,798
All right, thank you.

