1
00:00:05,620 --> 00:00:09,462
OK, so my name is Branislav Grudzik, and I'm a 3D team lead

2
00:00:09,462 --> 00:00:11,823
programmer from Ubisoft Toronto, and I had the pleasure

3
00:00:11,823 --> 00:00:13,744
of working with Christian on Far Cry 5.

4
00:00:13,744 --> 00:00:17,506
Hi guys, I'm Christian Kudocheres.

5
00:00:17,506 --> 00:00:19,828
I'm part of AMD's developer technology group.

6
00:00:19,828 --> 00:00:22,929
I work with developers to make sure that their games are

7
00:00:22,929 --> 00:00:24,930
running smooth on Radeon on PC.

8
00:00:28,831 --> 00:00:31,755
Awesome, so just a little agenda we'll cover today.

9
00:00:31,755 --> 00:00:33,857
We did a little introduction, but then we'll talk about

10
00:00:33,857 --> 00:00:36,801
the history of water in previous Far Cry games.

11
00:00:36,801 --> 00:00:39,424
We'll talk about Montana, as that's where Far Cry 5 is

12
00:00:39,424 --> 00:00:39,745
located.

13
00:00:39,745 --> 00:00:43,049
We'll look at the engine tools and rendering goals.

14
00:00:43,049 --> 00:00:46,093
And we'll actually look through a full render of a

15
00:00:46,093 --> 00:00:47,415
frame of water in Far Cry 5.

16
00:00:48,068 --> 00:00:51,511
And then Christian will talk about how we optimized our

17
00:00:51,511 --> 00:00:54,233
computators with half-precision math.

18
00:00:54,233 --> 00:00:57,076
And we'll close it off with the problems, how we actually

19
00:00:57,076 --> 00:00:58,777
debug these problems, and the future.

20
00:00:58,777 --> 00:01:03,521
So just to get this started, this is a screenshot of

21
00:01:03,521 --> 00:01:05,202
Archive 5.

22
00:01:05,202 --> 00:01:09,525
Rendering-wise, it was the old Blinn Specular rendering model.

23
00:01:09,525 --> 00:01:11,307
Water was the same.

24
00:01:11,307 --> 00:01:13,428
We had planar reflections.

25
00:01:14,217 --> 00:01:16,339
So we moved on to Far Cry 3.

26
00:01:16,339 --> 00:01:18,321
Far Cry 3 was the first introduction of PBR

27
00:01:18,321 --> 00:01:19,322
in the Far Cry engine.

28
00:01:19,322 --> 00:01:22,825
Although water remained relatively non-PBR,

29
00:01:22,825 --> 00:01:25,848
it still looked quite good.

30
00:01:25,848 --> 00:01:27,969
Far Cry 4, we did PBR version 2.

31
00:01:27,969 --> 00:01:31,713
Also, water's starting to look quite nice,

32
00:01:31,713 --> 00:01:33,074
although we were starting to struggle

33
00:01:33,074 --> 00:01:34,595
with waterfalls in our game,

34
00:01:34,595 --> 00:01:37,498
and the reflections in the normal map,

35
00:01:37,498 --> 00:01:39,920
it was trying to distort the image a little bit too much,

36
00:01:39,920 --> 00:01:40,841
which we didn't like.

37
00:01:42,517 --> 00:01:46,538
And then Far Cry Primal is where we actually really started

38
00:01:46,538 --> 00:01:48,939
to consider redoing the water system

39
00:01:48,939 --> 00:01:50,500
as we were trying to hit the limits

40
00:01:50,500 --> 00:01:52,541
of what we wanted it to look like.

41
00:01:52,541 --> 00:01:56,262
So this is a screenshot of Far Cry 5.

42
00:01:56,262 --> 00:01:59,023
You can tell everything has gotten an overhaul,

43
00:01:59,023 --> 00:02:01,384
including fully PBR water with flow maps,

44
00:02:01,384 --> 00:02:03,425
reflections, and refraction.

45
00:02:03,425 --> 00:02:09,068
So before we get started how we actually render this,

46
00:02:09,068 --> 00:02:11,108
our first approach is to...

47
00:02:11,758 --> 00:02:13,719
Look at some reference images of Montana,

48
00:02:13,719 --> 00:02:15,840
where Far Cry 5 is located.

49
00:02:15,840 --> 00:02:17,681
We knew that we could technically do this

50
00:02:17,681 --> 00:02:19,661
with the old water shader,

51
00:02:19,661 --> 00:02:21,282
but that's not what we wanted to do,

52
00:02:21,282 --> 00:02:22,763
as when you go to Montana,

53
00:02:22,763 --> 00:02:25,424
you'll see a lot of rivers that are really fast,

54
00:02:25,424 --> 00:02:28,466
and there's no way you can get this kind of displacement

55
00:02:28,466 --> 00:02:29,286
from just a normal map.

56
00:02:29,286 --> 00:02:32,127
Then we get to rapids.

57
00:02:32,127 --> 00:02:33,348
If we wanna do rapids,

58
00:02:33,348 --> 00:02:35,589
you're gonna struggle with flat water,

59
00:02:35,589 --> 00:02:38,550
so we really need a system that will handle slope water.

60
00:02:40,527 --> 00:02:41,648
Waterfalls.

61
00:02:41,648 --> 00:02:45,091
Surprisingly, there are a lot of waterfalls in Montana,

62
00:02:45,091 --> 00:02:47,634
probably 50 or more.

63
00:02:47,634 --> 00:02:49,095
And in the previous Far Cry games,

64
00:02:49,095 --> 00:02:50,817
we made all these manual,

65
00:02:50,817 --> 00:02:52,979
and we had to deal with the connections

66
00:02:52,979 --> 00:02:55,442
between the river, for example, and the waterfall,

67
00:02:55,442 --> 00:02:57,164
which was quite tedious.

68
00:02:57,164 --> 00:02:59,586
And if we made any single change to the terrain,

69
00:02:59,586 --> 00:03:01,989
we'd have to go edit the things we did before,

70
00:03:01,989 --> 00:03:03,050
which was unacceptable.

71
00:03:04,178 --> 00:03:08,127
Montana also has some exotic locations such as sulfur ponds.

72
00:03:08,127 --> 00:03:09,791
At this point, we already knew

73
00:03:09,791 --> 00:03:12,357
that our previous lighting model would not work,

74
00:03:12,357 --> 00:03:14,322
so we wanted to tackle this.

75
00:03:15,838 --> 00:03:17,839
So in terms of our game engine, there's

76
00:03:17,839 --> 00:03:20,520
three sides that play together to get our awesome water

77
00:03:20,520 --> 00:03:22,580
system, which is the engine side, which

78
00:03:22,580 --> 00:03:24,401
deals with the data generation and streaming

79
00:03:24,401 --> 00:03:25,761
and all the textures.

80
00:03:25,761 --> 00:03:27,882
And we have a very simple water queries API.

81
00:03:27,882 --> 00:03:31,903
We have an awesome tool, which is

82
00:03:31,903 --> 00:03:34,184
artist-driven and procedural.

83
00:03:34,184 --> 00:03:35,824
And the rendering, I'll talk about this fully.

84
00:03:36,929 --> 00:03:39,271
So from the engine side, we had many functions

85
00:03:39,271 --> 00:03:41,552
that handled the water level before.

86
00:03:41,552 --> 00:03:42,813
But once we started doing this,

87
00:03:42,813 --> 00:03:44,454
I think I had about a 93 file change list,

88
00:03:44,454 --> 00:03:46,816
which went through the entire engine

89
00:03:46,816 --> 00:03:49,657
and cleaned all of it up for it to be a single function

90
00:03:49,657 --> 00:03:53,240
that returned the water level and handled everything for you.

91
00:03:53,240 --> 00:03:57,282
This deals with water quadtree for any water that is moving

92
00:03:57,282 --> 00:03:59,584
and all the baked water height maps that are streamed in,

93
00:03:59,584 --> 00:04:01,405
such as lakes, rivers, and waterfalls.

94
00:04:02,085 --> 00:04:05,207
And one thing to note is we also support the ocean for things

95
00:04:05,207 --> 00:04:07,069
we'll see soon.

96
00:04:07,069 --> 00:04:09,450
Flow in physics, everything we do in the GPU,

97
00:04:09,450 --> 00:04:11,471
we have to replicate in the CPU because we

98
00:04:11,471 --> 00:04:14,133
can have objects that are moving around in the world

99
00:04:14,133 --> 00:04:15,134
according to the flow map.

100
00:04:15,134 --> 00:04:19,016
And last but not least, it's the baked material map.

101
00:04:19,016 --> 00:04:20,817
We need to do underwater, so we need

102
00:04:20,817 --> 00:04:25,260
to know exactly which material is where in the world.

103
00:04:25,260 --> 00:04:28,682
So just for reference, this is how this function looks like.

104
00:04:28,682 --> 00:04:30,343
There's an engine level and a render.

105
00:04:31,868 --> 00:04:33,490
a rendered thread function, which

106
00:04:33,490 --> 00:04:36,755
returns you the water level and the get water flow directions.

107
00:04:36,755 --> 00:04:39,358
And from an API perspective, our entire engine

108
00:04:39,358 --> 00:04:40,840
simply uses this and nothing more.

109
00:04:42,445 --> 00:04:44,566
Tools-wise, in the previous Far Cry games,

110
00:04:44,566 --> 00:04:47,629
the Far Cry engine is a sector-based engine,

111
00:04:47,629 --> 00:04:51,752
which means we have 64 by 64 sectors in the world.

112
00:04:51,752 --> 00:04:53,393
And if an artist wanted to place water,

113
00:04:53,393 --> 00:04:55,474
they had to turn on the water per sector.

114
00:04:55,474 --> 00:04:57,496
And if you want to get a lake,

115
00:04:57,496 --> 00:04:59,697
you have to do this probably 20, 30 times,

116
00:04:59,697 --> 00:05:01,659
changing material in each one.

117
00:05:01,659 --> 00:05:03,660
And if you want to slope water, you're kind of out of luck.

118
00:05:03,660 --> 00:05:05,361
You'd have to terraform the terrain

119
00:05:05,361 --> 00:05:07,983
around the water surface to actually get this to work.

120
00:05:07,983 --> 00:05:10,965
So, for Far Cry 5, we went more of a procedural generation route.

121
00:05:11,817 --> 00:05:15,199
and this is just a little video of how that works.

122
00:05:15,199 --> 00:05:17,340
So an artist would simply place a bunch of points

123
00:05:17,340 --> 00:05:20,862
on the terrain using our lake creation tool,

124
00:05:20,862 --> 00:05:23,724
and then we could switch to the river tool,

125
00:05:23,724 --> 00:05:25,865
which places a spline, which allows us to modify

126
00:05:25,865 --> 00:05:28,326
the width and the depth of the spline,

127
00:05:28,326 --> 00:05:29,967
and this actually modifies the terrain

128
00:05:29,967 --> 00:05:31,348
underneath it as well.

129
00:05:31,348 --> 00:05:34,009
And then the artist simply clicks one button

130
00:05:34,009 --> 00:05:37,952
and he gets fully procedural water generated.

131
00:05:39,256 --> 00:05:43,437
One thing to note in this video is we're actually doing this

132
00:05:43,437 --> 00:05:46,497
in Houdini, and this handles all the materials and textures

133
00:05:46,497 --> 00:05:47,978
underneath the water surface as well.

134
00:05:47,978 --> 00:05:50,978
So you'll see here there's rocks, moss,

135
00:05:50,978 --> 00:05:54,999
and the dirt that connects to the rest of the terrain.

136
00:05:54,999 --> 00:05:56,119
And we didn't have to do anything

137
00:05:56,119 --> 00:05:58,000
in terms of connecting the water bodies,

138
00:05:58,000 --> 00:05:59,920
which was quite painful in the previous Far Cry games.

139
00:05:59,920 --> 00:06:04,261
So this is kind of the bulk of the work we did.

140
00:06:04,863 --> 00:06:07,886
We wanted to experiment with a screen space distillation,

141
00:06:07,886 --> 00:06:12,290
which is what's gonna give us this awesome look.

142
00:06:12,290 --> 00:06:14,652
Per pixel material, we're moving towards

143
00:06:14,652 --> 00:06:18,515
with each pixel containing data from the material buffers,

144
00:06:18,515 --> 00:06:22,479
so we don't actually have to deal with

145
00:06:22,479 --> 00:06:24,661
reading things from world space.

146
00:06:24,661 --> 00:06:26,582
And this allows us to do blending,

147
00:06:26,582 --> 00:06:28,404
because now we have all the data per pixel,

148
00:06:28,404 --> 00:06:30,926
and we can know what other materials are in this pixel.

149
00:06:31,816 --> 00:06:33,817
We do everything in Compute as much as we can,

150
00:06:33,817 --> 00:06:38,699
minus the depth test and rendering the depth out.

151
00:06:38,699 --> 00:06:40,179
And we do flow maps with foam,

152
00:06:40,179 --> 00:06:41,480
as previously in the Far Cry games

153
00:06:41,480 --> 00:06:42,820
we only had a scrolling UV texture.

154
00:06:42,820 --> 00:06:47,482
So just a little bit of the things we achieved

155
00:06:47,482 --> 00:06:50,163
before we get into the actual rendering algorithm.

156
00:06:50,163 --> 00:06:52,564
This is a simple water plane that artists can just place,

157
00:06:52,564 --> 00:06:54,485
can move up and down.

158
00:06:54,485 --> 00:06:56,585
Particles also interact with it fully.

159
00:06:56,585 --> 00:06:59,346
This is a more exotic lake.

160
00:07:02,795 --> 00:07:04,695
This is a wide river.

161
00:07:04,695 --> 00:07:06,576
As you can see, there's displacement at the bottom

162
00:07:06,576 --> 00:07:08,737
and it will fade out in the distance.

163
00:07:08,737 --> 00:07:10,237
We have a nice LOD transition

164
00:07:10,237 --> 00:07:13,278
between the high tessellation and low tessellation.

165
00:07:13,278 --> 00:07:18,480
This is another example where we have a river

166
00:07:18,480 --> 00:07:22,221
that is modulated by its depth and its width,

167
00:07:22,221 --> 00:07:24,141
which drives how the foam is generated

168
00:07:24,141 --> 00:07:26,462
in this specific location.

169
00:07:26,462 --> 00:07:32,124
And foam will also follow around any rocks and the terrain.

170
00:07:33,017 --> 00:07:35,839
So out of this tool we also have procedural waterfalls.

171
00:07:35,839 --> 00:07:38,741
Artists simply place a spline, click that button,

172
00:07:38,741 --> 00:07:40,122
and let me just play it again,

173
00:07:40,122 --> 00:07:42,584
and they also get waterfalls with flow maps.

174
00:07:42,584 --> 00:07:46,588
We talked about some exotic locations,

175
00:07:46,588 --> 00:07:50,051
but this is one example of where there's a helicopter

176
00:07:50,051 --> 00:07:52,413
that's affecting the sulfur pond below it,

177
00:07:52,413 --> 00:07:53,954
and you can see the helicopter

178
00:07:53,954 --> 00:07:55,915
spawning displacement particles on top of it,

179
00:07:55,915 --> 00:07:58,017
which are disturbing the water surface and creating foam.

180
00:07:59,733 --> 00:08:02,534
So on top of having to support all of this in the Engine,

181
00:08:02,534 --> 00:08:05,095
we also have to support all these features in the World Map,

182
00:08:05,095 --> 00:08:08,157
as you will see once you play Far Cry 5.

183
00:08:08,157 --> 00:08:13,999
And this is our Far Cry Arcade in-game editor,

184
00:08:13,999 --> 00:08:15,980
where we also support ocean rendering.

185
00:08:15,980 --> 00:08:20,482
Not only do we do all these things,

186
00:08:20,482 --> 00:08:22,843
we also support a nice underwater effect.

187
00:08:24,830 --> 00:08:27,914
And I really like this slide because it really shows you

188
00:08:27,914 --> 00:08:29,777
how much water there is in our world.

189
00:08:29,777 --> 00:08:33,641
This actually brings us to one point where we not only need

190
00:08:33,641 --> 00:08:36,124
to render water close to the player, we actually need to do

191
00:08:36,124 --> 00:08:37,526
it in the distance as well.

192
00:08:37,526 --> 00:08:39,589
And this has to go really fast on the GPU.

193
00:08:41,574 --> 00:08:43,815
Okay, so we're gonna talk about how we do all of this

194
00:08:43,815 --> 00:08:45,456
in Screen Space and how we achieve

195
00:08:45,456 --> 00:08:47,457
Screen Space tessellation.

196
00:08:47,457 --> 00:08:49,317
The general idea behind this algorithm

197
00:08:49,317 --> 00:08:52,299
is that an artist gives us a very low resolution mesh

198
00:08:52,299 --> 00:08:54,700
and they also give us a material

199
00:08:54,700 --> 00:08:57,641
which will guide how we actually tessellate.

200
00:08:57,641 --> 00:09:00,283
And from this we will create a Screen Space tessellated mesh.

201
00:09:02,370 --> 00:09:04,672
So from the artist's point of view, all they give us is

202
00:09:04,672 --> 00:09:08,575
simple parameters such as amplitude, roughness, speed,

203
00:09:08,575 --> 00:09:11,538
scale, and we bake this out into a structure buffer.

204
00:09:11,538 --> 00:09:16,001
One problem with DirectX 11 is that we can't actually deal

205
00:09:16,001 --> 00:09:17,523
with textures if we're going towards a

206
00:09:17,523 --> 00:09:19,244
screen space approach.

207
00:09:19,244 --> 00:09:22,166
So instead, the artists are simply using indices into

208
00:09:22,166 --> 00:09:24,649
texture arrays for any texture they want per pixel.

209
00:09:24,649 --> 00:09:28,252
And that also gets baked out into a texture index and a

210
00:09:28,252 --> 00:09:28,892
structure buffer.

211
00:09:30,402 --> 00:09:32,904
So if you can imagine when you're running around

212
00:09:32,904 --> 00:09:33,904
in an open world game,

213
00:09:33,904 --> 00:09:35,545
there's materials constantly being loaded.

214
00:09:35,545 --> 00:09:38,967
So what we actually do is have one fairly large

215
00:09:38,967 --> 00:09:42,029
structure buffer which runs a compute shader

216
00:09:42,029 --> 00:09:44,691
and takes the data out of that material

217
00:09:44,691 --> 00:09:45,851
into a structure buffer.

218
00:09:45,851 --> 00:09:47,873
And then from this point on,

219
00:09:47,873 --> 00:09:50,474
we handle everything using just an index per pixel.

220
00:09:50,474 --> 00:09:54,317
And at this point,

221
00:09:54,317 --> 00:09:57,258
we actually link everything using per pixel.

222
00:09:58,918 --> 00:10:02,559
So this is the actual overall rendering algorithm.

223
00:10:02,559 --> 00:10:05,601
We'll go through all the stages in how we actually do this.

224
00:10:05,601 --> 00:10:08,862
So don't worry about this large graph.

225
00:10:08,862 --> 00:10:12,684
So the first stage is always visibility.

226
00:10:12,684 --> 00:10:16,125
How do you actually handle rendering water close by and

227
00:10:16,125 --> 00:10:17,666
in the distance?

228
00:10:17,666 --> 00:10:20,007
For water near the player, we actually use a conditional

229
00:10:20,007 --> 00:10:21,848
rendering approach with occlusion queries.

230
00:10:22,848 --> 00:10:26,612
and we simply store the query per mesh instance.

231
00:10:26,612 --> 00:10:29,675
In the distance, we actually do a GPU pipeline

232
00:10:29,675 --> 00:10:32,778
where we have two cases, which is flat water and a height map

233
00:10:32,778 --> 00:10:33,099
water.

234
00:10:33,099 --> 00:10:36,182
Both of this data is loaded from a quadtree on the GPU,

235
00:10:36,182 --> 00:10:38,805
and we use this to do a sector occlusion.

236
00:10:39,565 --> 00:10:41,828
and create the indirect draw arguments buffer.

237
00:10:41,828 --> 00:10:43,549
And this part's fairly simple,

238
00:10:43,549 --> 00:10:47,333
because the Compute Shader can just fetch from the height map,

239
00:10:47,333 --> 00:10:49,515
and it can know whether it's a flat piece of water

240
00:10:49,515 --> 00:10:51,397
or if it's a waterfall or a river.

241
00:10:51,397 --> 00:10:55,661
And once it does this, it will actually pass the data

242
00:10:55,661 --> 00:10:58,464
through the indirect draw arguments buffer

243
00:10:58,464 --> 00:10:59,825
and give us...

244
00:11:00,643 --> 00:11:01,684
a draw call.

245
00:11:01,684 --> 00:11:02,924
Now, this is very important.

246
00:11:02,924 --> 00:11:06,665
It's a large open world game, so in a typical scene,

247
00:11:06,665 --> 00:11:07,885
you might have 80 to 90 draw calls.

248
00:11:07,885 --> 00:11:11,466
But once you do occlusion, you might end up only doing 10.

249
00:11:11,466 --> 00:11:14,587
There are some really heavy scenes

250
00:11:14,587 --> 00:11:17,727
where you might actually end up having 600 water bodies.

251
00:11:17,727 --> 00:11:20,008
And this is why we actually had to split the water

252
00:11:20,008 --> 00:11:22,088
into near rendering and far rendering,

253
00:11:22,088 --> 00:11:24,069
where the far rendering is a single draw call,

254
00:11:24,069 --> 00:11:27,250
but the water bodies close by are actually

255
00:11:27,250 --> 00:11:28,030
multiple draw calls.

256
00:11:29,678 --> 00:11:32,220
So if we want to do everything in screen space,

257
00:11:32,220 --> 00:11:34,241
we kind of need a mini G-buffer,

258
00:11:34,241 --> 00:11:37,484
which is a little bit lower resolution and a higher FOV,

259
00:11:37,484 --> 00:11:39,646
which defines the surface shape.

260
00:11:39,646 --> 00:11:41,207
And as I mentioned before,

261
00:11:41,207 --> 00:11:43,269
artists do not give us tessellated Meshes.

262
00:11:43,269 --> 00:11:45,831
We actually do screen space tessellation.

263
00:11:45,831 --> 00:11:48,092
So in the pass we call the position pass,

264
00:11:48,092 --> 00:11:50,914
we write out three Textures, which is the data Texture,

265
00:11:50,914 --> 00:11:52,616
the Mesh Normal,

266
00:11:52,616 --> 00:11:55,618
and Depth Buffer only containing the water planes.

267
00:11:55,618 --> 00:11:57,179
Once you do this for all the water nearby

268
00:11:57,179 --> 00:11:58,681
and in the distance,

269
00:11:59,255 --> 00:12:02,636
you get textures that look like this.

270
00:12:02,636 --> 00:12:05,198
Now, what do you actually store in these textures?

271
00:12:05,198 --> 00:12:07,119
In the data texture, we store the shader ID,

272
00:12:07,119 --> 00:12:07,979
which is an 8-bit.

273
00:12:09,960 --> 00:12:16,144
texture, and that contains shader features, which could be, is it front face, does it

274
00:12:16,144 --> 00:12:20,747
support lighting or not, and is it a valid pixel or not.

275
00:12:20,747 --> 00:12:24,750
We also store the material structure buffer index, because from this point on, everything

276
00:12:24,750 --> 00:12:25,350
is done per pixel.

277
00:12:25,350 --> 00:12:31,094
And you'll notice we're also storing the MIP level of the algae and the foam, because we

278
00:12:31,094 --> 00:12:35,957
are doing things in screen space, we don't have access to DDX, DDI, so we kind of have

279
00:12:35,957 --> 00:12:37,458
to pack this out in the early stage.

280
00:12:40,362 --> 00:12:42,084
Water is a very interactive thing,

281
00:12:42,084 --> 00:12:45,427
so we implemented something called Vector Displacement Maps.

282
00:12:45,427 --> 00:12:48,950
And this is a fairly simple particle editor extension

283
00:12:48,950 --> 00:12:52,734
where we render projected box decals for each particle.

284
00:12:53,812 --> 00:12:56,074
And the way that works is when you render the box,

285
00:12:56,074 --> 00:12:59,637
we sample the depth buffer that has water in it,

286
00:12:59,637 --> 00:13:01,579
and we do position from depth to project that

287
00:13:01,579 --> 00:13:03,340
onto the water surface.

288
00:13:03,340 --> 00:13:05,102
We also have to invert to object space

289
00:13:05,102 --> 00:13:05,742
for applying the UVs,

290
00:13:05,742 --> 00:13:08,765
otherwise you will notice distortion in screen space.

291
00:13:08,765 --> 00:13:11,147
At this point, we also clip all the offscreen pixels,

292
00:13:11,147 --> 00:13:13,329
sample the displacement textures,

293
00:13:13,329 --> 00:13:14,651
and also do any sort of animation

294
00:13:14,651 --> 00:13:15,631
that the artist might want,

295
00:13:15,631 --> 00:13:16,953
because if you're doing splashes,

296
00:13:16,953 --> 00:13:18,814
it's probably multiple frames, not a single frame.

297
00:13:21,149 --> 00:13:23,611
The most important things from this slide

298
00:13:23,611 --> 00:13:25,372
is the fading of the displacement

299
00:13:25,372 --> 00:13:27,053
towards the edges of the box.

300
00:13:27,053 --> 00:13:29,835
If you're applying a projected box decal on a,

301
00:13:29,835 --> 00:13:32,557
for example, a waterfall, you will see displacement

302
00:13:32,557 --> 00:13:35,239
exploding as it gets to the edge of the box,

303
00:13:35,239 --> 00:13:36,160
which you don't want to do.

304
00:13:36,160 --> 00:13:38,561
And how do you actually blend all of these?

305
00:13:38,561 --> 00:13:39,822
We do a max alpha blend,

306
00:13:39,822 --> 00:13:43,005
where we clear the texture to a negative flow max,

307
00:13:43,005 --> 00:13:45,767
and we do alpha blend max to get all these textures.

308
00:13:45,767 --> 00:13:47,908
So, at the end, we get a texture

309
00:13:47,908 --> 00:13:50,010
that has all the displacement splashes in it.

310
00:13:52,664 --> 00:13:55,407
We actually went away from giving control to artists

311
00:13:55,407 --> 00:13:58,811
to paint normal maps, because we found that that creates

312
00:13:58,811 --> 00:13:59,351
a lot of repetitions.

313
00:13:59,351 --> 00:14:01,874
So instead of that, we create noise

314
00:14:01,874 --> 00:14:03,496
to get the general surface shape, which

315
00:14:03,496 --> 00:14:04,757
is the high frequency noise.

316
00:14:04,757 --> 00:14:08,020
And for that, we used the fractional Brownian motion

317
00:14:08,020 --> 00:14:09,562
with nine iterations per pixel.

318
00:14:10,383 --> 00:14:14,426
If you don't know how that works, basically each iteration adds more frequency as you double the UV scale.

319
00:14:14,426 --> 00:14:21,231
And this is one thing to remember, this is fairly expensive because it's 9 texture fetches per pixel.

320
00:14:21,231 --> 00:14:25,794
So we actually do an LOD approach where in the distance we do 3 fetches and close by we do 9.

321
00:14:25,794 --> 00:14:30,397
And we don't want to go to 0 because otherwise the reflections look really bad in the distance.

322
00:14:31,096 --> 00:14:33,297
And there's two errors on this diagram.

323
00:14:33,297 --> 00:14:35,858
One is that this texture is not cleared.

324
00:14:35,858 --> 00:14:38,540
Because we have many passes, and we have a valid mask on

325
00:14:38,540 --> 00:14:41,581
the screen, which tells us where there is water, there is

326
00:14:41,581 --> 00:14:42,922
no need to clear these textures.

327
00:14:42,922 --> 00:14:46,164
So in every pass, it will just simply check if there is

328
00:14:46,164 --> 00:14:46,724
water or not.

329
00:14:46,724 --> 00:14:49,145
If there is, it will sample the valid data.

330
00:14:49,145 --> 00:14:50,446
Otherwise, it does not.

331
00:14:50,446 --> 00:14:53,688
And the last thing is, the second error is we combine the

332
00:14:53,688 --> 00:14:56,689
splashes with the high frequency surface shape.

333
00:14:58,375 --> 00:15:02,417
So now that we know the surface shape and all the displacement,

334
00:15:02,417 --> 00:15:05,077
we actually need to do screen space distillation.

335
00:15:05,077 --> 00:15:06,958
But we don't want to do this for tiles that don't exist.

336
00:15:06,958 --> 00:15:10,219
We need to do some sort of occlusion paths.

337
00:15:10,219 --> 00:15:12,780
So the way this works is we divide the screen

338
00:15:12,780 --> 00:15:14,300
into 32 by 32 tiles.

339
00:15:14,300 --> 00:15:17,621
We found 32 by 32 is the best for all hardware.

340
00:15:17,621 --> 00:15:19,342
We first started with eight, went up

341
00:15:19,342 --> 00:15:21,382
until we found the one that works.

342
00:15:21,382 --> 00:15:23,483
And the way this works is we simply

343
00:15:23,483 --> 00:15:25,223
get a per tile pixel count.

344
00:15:26,104 --> 00:15:31,071
And you have two cases, like a tile might have a pixel that has water or does not have water.

345
00:15:31,071 --> 00:15:37,721
If it has water, we do an atomic add into a structure buffer, but we also use the group

346
00:15:37,721 --> 00:15:41,987
shared memory to store this before we actually write it out into the structure buffer.

347
00:15:42,732 --> 00:15:45,275
One thing to remember is if you're working on console or DX12,

348
00:15:45,275 --> 00:15:48,258
you could actually use the ballot instruction

349
00:15:48,258 --> 00:15:51,942
because we have a per pixel Boolean we can test against

350
00:15:51,942 --> 00:15:55,145
to reduce this from 64 atomics to a single atomic

351
00:15:55,145 --> 00:15:57,428
because we run this in a grid of 8x8 threads.

352
00:15:57,428 --> 00:16:01,833
Once all the threads are finished and the group thread ID is zero,

353
00:16:01,833 --> 00:16:04,916
we actually write out the total pixel count into a structure buffer.

354
00:16:05,731 --> 00:16:11,004
And then we do another pass where we simply iterate this list and get the pixel count.

355
00:16:11,004 --> 00:16:14,091
If it's greater than zero, we increase the...

356
00:16:14,340 --> 00:16:15,942
indirect draw arguments buffer by one.

357
00:16:15,942 --> 00:16:18,605
And the last line there is very important

358
00:16:18,605 --> 00:16:20,606
because we will write out the tile ID

359
00:16:20,606 --> 00:16:22,468
into a second structure buffer.

360
00:16:22,468 --> 00:16:25,031
And you can see from a render.capture,

361
00:16:25,031 --> 00:16:32,598
this specific view has 606 mesh instances on the screen

362
00:16:32,598 --> 00:16:34,981
with each one being 1536 indices,

363
00:16:34,981 --> 00:16:36,382
so it's highly test-related.

364
00:16:36,382 --> 00:16:36,622
So now we know.

365
00:16:40,013 --> 00:16:42,855
what water is visible, which tiles are visible,

366
00:16:42,855 --> 00:16:45,916
we need to actually render this mesh.

367
00:16:45,916 --> 00:16:49,477
So from the previous pass, we know exactly

368
00:16:49,477 --> 00:16:51,498
which tiles will have water or not have water,

369
00:16:51,498 --> 00:16:55,960
and we will render a mesh that's tessellated per tile

370
00:16:55,960 --> 00:16:56,640
where it is visible.

371
00:16:56,640 --> 00:17:00,662
How do you actually figure out the density?

372
00:17:00,662 --> 00:17:03,203
In this example, I'm using a 512 by 512 buffer,

373
00:17:03,203 --> 00:17:05,224
which will get upsampled to the viewport.

374
00:17:06,338 --> 00:17:10,040
And we just take the 512 divided by 32, which is our

375
00:17:10,040 --> 00:17:12,140
screen tile size, and we get 16 by 16 quads.

376
00:17:12,140 --> 00:17:16,221
And this actually gives us constant density tessellation.

377
00:17:16,221 --> 00:17:19,583
And we use drawIndexInstanceIndirect to

378
00:17:19,583 --> 00:17:21,023
actually draw each tile on the screen.

379
00:17:21,023 --> 00:17:23,164
This is why we need to know which tile will

380
00:17:23,164 --> 00:17:23,864
have water or not.

381
00:17:23,864 --> 00:17:28,665
So just to run you by how each tile is rendered.

382
00:17:30,352 --> 00:17:32,853
You'll see it renders a highly tessellated mesh.

383
00:17:32,853 --> 00:17:36,254
But how does it know where to render this mesh?

384
00:17:36,254 --> 00:17:40,776
From the previous pass, we wrote out the instance IDs,

385
00:17:40,776 --> 00:17:42,857
or the tile IDs, into a structure buffer.

386
00:17:42,857 --> 00:17:44,417
And that maps to a draw call.

387
00:17:44,417 --> 00:17:46,958
And then for each vertex, we can figure out

388
00:17:46,958 --> 00:17:48,479
which instance it belongs to.

389
00:17:48,479 --> 00:17:50,780
From each instance, we can figure out

390
00:17:50,780 --> 00:17:53,641
how to create the UVs, because our mesh is simply

391
00:17:53,641 --> 00:17:57,803
storing a 16-bit position that's compressed.

392
00:17:57,803 --> 00:17:58,923
And we can convert that into a...

393
00:18:00,052 --> 00:18:06,217
UV. Once we have the UV, we could actually sample the depth and compute the world space

394
00:18:06,217 --> 00:18:13,062
position in a larger field of view, and then sample the displacement texture which contains

395
00:18:13,062 --> 00:18:19,548
the FBM and splash. And at this point, we use NAND to clip all of our vertices because

396
00:18:19,548 --> 00:18:21,670
there's no other way to clip in a vertex shader.

397
00:18:23,018 --> 00:18:27,080
At that point, we also project into screen space

398
00:18:27,080 --> 00:18:33,642
with a regular FOV and do depth test with the screen buffer.

399
00:18:33,642 --> 00:18:33,862
Sorry.

400
00:18:33,862 --> 00:18:36,523
And what you get is this.

401
00:18:36,523 --> 00:18:40,584
So as you can tell, there's no pixels that are black,

402
00:18:40,584 --> 00:18:45,265
where there's the mesh, because it's per pixel tessellation.

403
00:18:45,265 --> 00:18:46,726
Again, with the depth buffer test.

404
00:18:47,842 --> 00:18:50,643
And again, it's screen space, so we have to write out the

405
00:18:50,643 --> 00:18:54,465
UVs to match this discrepancy between the larger field of

406
00:18:54,465 --> 00:18:56,146
view and the lower field of view.

407
00:18:56,146 --> 00:19:00,728
Why are we doing this large field of view example?

408
00:19:00,728 --> 00:19:03,929
If anybody has done any ocean rendering, you will know that

409
00:19:03,929 --> 00:19:06,410
when the camera gets close to the water, it will clip.

410
00:19:06,410 --> 00:19:08,751
And we actually want to fix this.

411
00:19:08,751 --> 00:19:12,433
So when we do this in the larger field of view and do

412
00:19:12,433 --> 00:19:13,954
the tessellation, we upsample.

413
00:19:15,095 --> 00:19:16,175
And we get this.

414
00:19:16,175 --> 00:19:19,458
There is some amount of distortion

415
00:19:19,458 --> 00:19:22,720
between the large field of view to the lower field of view,

416
00:19:22,720 --> 00:19:26,442
but it's hardly noticeable with motion.

417
00:19:26,442 --> 00:19:31,426
So that's kind of the deferred pass for a mini G-buffer.

418
00:19:31,426 --> 00:19:33,827
But as I mentioned before, we don't actually

419
00:19:33,827 --> 00:19:34,888
give the artist the normal map.

420
00:19:34,888 --> 00:19:38,090
So we need to generate a screen space normal map

421
00:19:38,090 --> 00:19:41,672
without ddx, ddy, which we use position from depth to do this.

422
00:19:42,638 --> 00:19:46,900
And one thing to notice, because we are a first-person game,

423
00:19:46,900 --> 00:19:49,461
when you get close to the water surface,

424
00:19:49,461 --> 00:19:50,961
this will actually create artifacts,

425
00:19:50,961 --> 00:19:52,702
so we increase the sampling radius

426
00:19:52,702 --> 00:19:56,404
as you get to the water surface.

427
00:19:56,404 --> 00:19:58,685
We do blend with the Mesh Normal

428
00:19:58,685 --> 00:20:00,446
to remove any of the discontinuities,

429
00:20:00,446 --> 00:20:05,588
because we do get a low-res Mesh from the artist,

430
00:20:05,588 --> 00:20:07,529
which is blended with the high-frequency

431
00:20:07,529 --> 00:20:08,269
Displacement Normal.

432
00:20:09,750 --> 00:20:11,350
So this is probably my favorite slide

433
00:20:11,350 --> 00:20:14,852
because before doing this, we actually found

434
00:20:14,852 --> 00:20:17,593
that we're getting a lot of specular aliasing

435
00:20:17,593 --> 00:20:22,595
and we actually do this for our offline textures as well.

436
00:20:22,595 --> 00:20:24,736
But because we have a reference normal

437
00:20:24,736 --> 00:20:27,897
that we're storing in screen space, we need to filter it.

438
00:20:27,897 --> 00:20:29,518
So we're doing a variance-based approach

439
00:20:29,518 --> 00:20:32,719
where we simply compute the Gaussian normal per pixel

440
00:20:32,719 --> 00:20:34,520
and we solve for smoothness

441
00:20:34,520 --> 00:20:35,760
based on the reference smoothness.

442
00:20:36,533 --> 00:20:38,554
And why is this important?

443
00:20:38,554 --> 00:20:44,216
If you don't do this, you'll notice that actually the variance increases quite a lot.

444
00:20:44,216 --> 00:20:46,217
So you will lose some of your specular.

445
00:20:46,217 --> 00:20:49,518
But lucky for us, we have a per pixel material map.

446
00:20:49,518 --> 00:20:54,440
So we could actually use that to scale it back into the range we expect water to be

447
00:20:54,440 --> 00:20:58,542
with the variance we actually need to fix the specular aliasing.

448
00:20:58,542 --> 00:21:03,063
And if you do this, you'll see your specular has come back.

449
00:21:06,861 --> 00:21:09,303
So talk a little bit about the foam.

450
00:21:09,303 --> 00:21:10,964
Foam is fairly straightforward.

451
00:21:10,964 --> 00:21:14,006
It's just a noise texture modulated by a noise texture.

452
00:21:14,006 --> 00:21:17,729
But the more complex portion of this is the flow map, which

453
00:21:17,729 --> 00:21:21,372
is sampled using two different offset phases in order to

454
00:21:21,372 --> 00:21:21,992
avoid pulsing.

455
00:21:21,992 --> 00:21:25,615
And where do we actually show this foam?

456
00:21:25,615 --> 00:21:28,517
It's driven using a sine distance field based on the

457
00:21:28,517 --> 00:21:29,638
shorelines and the rocks.

458
00:21:29,638 --> 00:21:33,061
And at this point, we also blend in the displacement

459
00:21:33,061 --> 00:21:34,902
foam with the shoreline foam.

460
00:21:36,524 --> 00:21:39,647
So we are an open world game, so we can't actually afford

461
00:21:39,647 --> 00:21:41,429
to do all this at runtime.

462
00:21:41,429 --> 00:21:46,174
So we actually bake out the entire world's flow map and

463
00:21:46,174 --> 00:21:51,178
run the generation at runtime in an offline process.

464
00:21:51,178 --> 00:21:52,320
This is how it looks.

465
00:21:52,320 --> 00:21:55,282
Some of you might think, oh, this is Fluttville, which it

466
00:21:55,282 --> 00:21:57,885
is, so we run a Fluttville algorithm.

467
00:21:59,204 --> 00:22:03,106
But flood fill is kind of tricky because some pixels will

468
00:22:03,106 --> 00:22:05,488
arrive at the destination sooner than others.

469
00:22:05,488 --> 00:22:08,430
So we actually use a signed distance field to guide the

470
00:22:08,430 --> 00:22:11,412
flood fill around corners, which also works for rocks.

471
00:22:11,412 --> 00:22:16,515
And out of this, we get a flow map texture atlas, which we

472
00:22:16,515 --> 00:22:17,395
have two variations.

473
00:22:17,395 --> 00:22:19,757
One is a high resolution texture, and one

474
00:22:19,757 --> 00:22:20,817
is a world flow map.

475
00:22:20,817 --> 00:22:24,259
The high resolution close to the player gets streamed in as

476
00:22:24,259 --> 00:22:26,040
the player is running around the world.

477
00:22:26,040 --> 00:22:28,882
And the world flow map is baked out once.

478
00:22:30,805 --> 00:22:33,245
The way the world flow map actually works is an old trick

479
00:22:33,245 --> 00:22:36,886
where we, based on a sector ID, we can figure out a UV

480
00:22:36,886 --> 00:22:40,206
remap table, which is stored in the texture itself, which

481
00:22:40,206 --> 00:22:43,587
can help us figure out which portion of the atlas to read.

482
00:22:43,587 --> 00:22:46,547
And this is a self-contained texture, so any feature that

483
00:22:46,547 --> 00:22:49,348
needs the flow map could actually read this simply

484
00:22:49,348 --> 00:22:50,468
based on the world position.

485
00:22:50,468 --> 00:22:54,969
And this is also our world height map, which we also bake.

486
00:22:54,969 --> 00:22:59,690
The low-resolution textures are eight meters per pixel.

487
00:23:01,321 --> 00:23:03,102
OK, so we generated all the things

488
00:23:03,102 --> 00:23:05,983
that we need for a water surface.

489
00:23:05,983 --> 00:23:07,544
But how do you actually light this?

490
00:23:07,544 --> 00:23:10,225
Because everything is in screen space.

491
00:23:10,225 --> 00:23:14,486
So there is one important thing that I mentioned earlier,

492
00:23:14,486 --> 00:23:16,427
is our water does write depth.

493
00:23:16,427 --> 00:23:18,448
So at this point, we need to sample the.

494
00:23:20,043 --> 00:23:22,284
the depth with and without water,

495
00:23:22,284 --> 00:23:24,405
and also all the material IDs per pixel.

496
00:23:24,405 --> 00:23:27,627
So you'll see in the screenshot on the right,

497
00:23:27,627 --> 00:23:28,587
we get the material ID,

498
00:23:28,587 --> 00:23:31,109
and we also get the blend material ID.

499
00:23:31,109 --> 00:23:34,850
This is very important because artists can place

500
00:23:34,850 --> 00:23:37,752
two rivers with having very different materials,

501
00:23:37,752 --> 00:23:39,633
and we actually need to gradually blend

502
00:23:39,633 --> 00:23:42,815
from one river to the other without any discontinuities.

503
00:23:42,815 --> 00:23:46,196
And we have a function that actually

504
00:23:46,196 --> 00:23:47,817
interpolates the material properties.

505
00:23:48,824 --> 00:23:51,365
We don't actually want to blend all the material properties,

506
00:23:51,365 --> 00:23:53,926
but only the specific ones that are required,

507
00:23:53,926 --> 00:23:56,727
because it's kind of a waste of ALUs to do the rest.

508
00:23:56,727 --> 00:24:01,749
So now that we've actually blended all of our data,

509
00:24:01,749 --> 00:24:03,910
we need to actually read all of this from the structure buffer.

510
00:24:04,862 --> 00:24:06,063
and compute the lighting.

511
00:24:06,063 --> 00:24:07,345
In the previous Far Cry games,

512
00:24:07,345 --> 00:24:10,208
water simply supported the directional light,

513
00:24:10,208 --> 00:24:13,051
but now we do full-tiled Z-bin lighting

514
00:24:13,051 --> 00:24:15,394
on our water surface, which is pretty much

515
00:24:15,394 --> 00:24:18,678
the most expensive part of the lighting pass.

516
00:24:18,678 --> 00:24:21,861
And now we support the GI reflections,

517
00:24:21,861 --> 00:24:23,824
the directional point spotlights,

518
00:24:23,824 --> 00:24:25,866
and we also support exposure lights.

519
00:24:27,815 --> 00:24:30,636
So in terms of actually lighting the water surface,

520
00:24:30,636 --> 00:24:34,077
the way we do light transport is we went away from giving

521
00:24:34,077 --> 00:24:36,437
control to artists to give a specific color.

522
00:24:36,437 --> 00:24:39,018
But instead, they actually deal with the

523
00:24:39,018 --> 00:24:39,998
scattering coefficients.

524
00:24:39,998 --> 00:24:44,199
So we have a table of water types that the artists can

525
00:24:44,199 --> 00:24:46,780
pick from, or they can create their own.

526
00:24:46,780 --> 00:24:50,161
The way that works is just got RGB scattering coefficients

527
00:24:50,161 --> 00:24:53,582
with a turbidity value at the end, which is based on the

528
00:24:53,582 --> 00:24:55,843
physical properties of the water.

529
00:24:56,283 --> 00:24:59,345
So with this, you can create oceans, rivers

530
00:24:59,345 --> 00:25:01,927
that are quite muddy or clear.

531
00:25:01,927 --> 00:25:04,848
We also sampled the foam refraction in caustics buffer

532
00:25:04,848 --> 00:25:06,529
in order to compose the final image.

533
00:25:06,529 --> 00:25:09,912
This is just gonna show you how these buffers

534
00:25:09,912 --> 00:25:11,292
might look like if you did this.

535
00:25:11,292 --> 00:25:14,334
So this was the refraction.

536
00:25:14,334 --> 00:25:15,435
This is the light transport.

537
00:25:15,435 --> 00:25:20,158
This is the screen space local reflections.

538
00:25:20,158 --> 00:25:23,300
This is a low-res environment map, 64 by 64.

539
00:25:24,525 --> 00:25:26,566
And once you combine all of these,

540
00:25:26,566 --> 00:25:28,466
you get something that looks like this,

541
00:25:28,466 --> 00:25:31,387
which handles everything physically based.

542
00:25:31,387 --> 00:25:32,547
So you'll see we have the splashes,

543
00:25:32,547 --> 00:25:34,848
we have the particles interacting with the water,

544
00:25:34,848 --> 00:25:38,408
you have refraction, there's foam,

545
00:25:38,408 --> 00:25:40,849
and it works great with the rest of the terrain.

546
00:25:40,849 --> 00:25:45,630
But I did mention that this is a very VGPR heavy pass,

547
00:25:45,630 --> 00:25:48,571
so you have to be very careful how you actually handle this.

548
00:25:48,571 --> 00:25:50,511
That's what actually Christian's gonna talk about.

549
00:25:56,362 --> 00:25:56,762
All right.

550
00:25:56,762 --> 00:25:59,844
So it looks like we're doing very good on time.

551
00:25:59,844 --> 00:26:03,387
I was planning to speak through my optimizations pretty fast,

552
00:26:03,387 --> 00:26:08,390
but thank you, Bane, for mentioning about the VGPR

553
00:26:08,390 --> 00:26:13,173
usage of this shader.

554
00:26:13,173 --> 00:26:14,914
So what I'm here to talk about is about a

555
00:26:15,657 --> 00:26:21,645
way in which you can optimize your shaders by using half precision, which is 16-bit precision,

556
00:26:21,645 --> 00:26:23,007
by saving vGPRs.

557
00:26:23,007 --> 00:26:29,757
And this relates to Ben's talk because the material blending done in the SurfaceComposite

558
00:26:29,757 --> 00:26:30,518
pass is...

559
00:26:31,502 --> 00:26:34,866
Well, it's vGPR heavy, just like you mentioned.

560
00:26:34,866 --> 00:26:37,248
You can see there are a lot of different

561
00:26:37,248 --> 00:26:39,671
attributes being sampled.

562
00:26:39,671 --> 00:26:44,476
And these are very easy to optimize just with the change

563
00:26:44,476 --> 00:26:46,158
list you see here in this slide.

564
00:26:46,158 --> 00:26:49,181
So if you look at the yellow font, that was the only change

565
00:26:49,181 --> 00:26:52,365
that was needed to be done in HLSL to actually save nine

566
00:26:52,365 --> 00:26:53,686
vGPRs off this path.

567
00:26:54,187 --> 00:26:56,407
This resulted in an increase of occupancy.

568
00:26:56,407 --> 00:26:58,487
The shader went up to three waves per CMD

569
00:26:58,487 --> 00:27:00,168
from two waves per CMD.

570
00:27:00,168 --> 00:27:02,908
So the overall result was that this pass

571
00:27:02,908 --> 00:27:05,589
was running 25% faster from this simple change.

572
00:27:05,589 --> 00:27:09,350
Now, no actual change needs to be done.

573
00:27:09,350 --> 00:27:11,190
C++ size, so this is everything

574
00:27:11,190 --> 00:27:13,050
that really needs to be done.

575
00:27:13,050 --> 00:27:16,451
And now I know you're all,

576
00:27:16,451 --> 00:27:20,752
I know exactly what you're all thinking seeing this.

577
00:27:20,752 --> 00:27:21,672
What is Min16Float, right?

578
00:27:22,181 --> 00:27:25,162
So luckily, I have a slide for that.

579
00:27:25,162 --> 00:27:27,183
It's an SRSL basic data type.

580
00:27:27,183 --> 00:27:29,905
So there are no extensions needed for this optimization.

581
00:27:29,905 --> 00:27:35,687
It just lets the compiler know that it can reduce the

582
00:27:35,687 --> 00:27:36,408
precision down to 16-bit.

583
00:27:36,408 --> 00:27:38,849
And this stands for integer as well.

584
00:27:38,849 --> 00:27:40,490
So there's a min16 int data type in there as well.

585
00:27:40,490 --> 00:27:44,031
But then it's up to the software and the hardware

586
00:27:44,031 --> 00:27:47,233
stack to decide whether it can take advantage of the lower

587
00:27:47,233 --> 00:27:49,254
precision to actually speed up the

588
00:27:49,254 --> 00:27:50,534
performance of the shader.

589
00:27:52,095 --> 00:27:57,640
So this doesn't actually force the shader to use that precision, like I just mentioned.

590
00:27:57,640 --> 00:28:03,104
And it's very important to note that this doesn't specify the resource format in memory.

591
00:28:03,104 --> 00:28:10,630
It actually just allows the GPU to use 16-bit precision when it stores the values to VGPRs

592
00:28:10,630 --> 00:28:12,171
and when it actually performs the math.

593
00:28:12,171 --> 00:28:14,853
This is why no C++ changes are necessary.

594
00:28:14,853 --> 00:28:19,277
It's just because this is internal to the GPU execution, not to the resource itself.

595
00:28:19,637 --> 00:28:22,558
And please don't confuse this with the half keyword in HLSL

596
00:28:22,558 --> 00:28:25,199
because that's like 32 bits.

597
00:28:25,199 --> 00:28:28,341
And counterparts exist for GLSL, so this is not

598
00:28:28,341 --> 00:28:30,622
an HLSL-only thing.

599
00:28:30,622 --> 00:28:35,344
You can implement this on different platforms as well.

600
00:28:35,344 --> 00:28:37,404
And precision lowering cannot be automatic.

601
00:28:37,404 --> 00:28:41,866
That's why we have the keyword in the first place.

602
00:28:41,866 --> 00:28:43,747
The software stack cannot possibly guess

603
00:28:43,747 --> 00:28:44,928
when it can lower a residue.

604
00:28:45,652 --> 00:28:48,794
precision without actually impacting quality.

605
00:28:48,794 --> 00:28:52,255
So then it's up to the developer and actually the

606
00:28:52,255 --> 00:28:55,777
quality assurance department to make sure there are no

607
00:28:55,777 --> 00:28:56,797
quality issues.

608
00:28:56,797 --> 00:29:01,799
And it's up to you to find those particular variables and

609
00:29:01,799 --> 00:29:06,081
those particular bits of math that can be safely lowered

610
00:29:06,081 --> 00:29:06,662
down to 16-bit.

611
00:29:06,662 --> 00:29:08,763
And you see here listed a few examples, typical examples,

612
00:29:08,763 --> 00:29:10,943
when this is not safe, which I will not go over.

613
00:29:10,943 --> 00:29:11,664
And.

614
00:29:12,557 --> 00:29:15,378
Not trying to bore everybody, but just trying to remind you,

615
00:29:15,378 --> 00:29:17,659
register pressure is a common bottleneck.

616
00:29:17,659 --> 00:29:21,060
And the way you optimize for it is that you're really

617
00:29:21,060 --> 00:29:22,441
trying to increase occupancy on the GPU.

618
00:29:22,441 --> 00:29:25,582
And that occupancy increases at discrete

619
00:29:25,582 --> 00:29:28,243
thresholds of vGPR usage.

620
00:29:28,243 --> 00:29:31,224
So if you narrowly miss one of these thresholds,

621
00:29:31,224 --> 00:29:31,765
it's not ideal.

622
00:29:31,765 --> 00:29:33,505
So you really want to spend that effort to get on the

623
00:29:33,505 --> 00:29:34,806
right side of the threshold.

624
00:29:35,466 --> 00:29:40,331
And obviously if you target shaders that are particularly VGPR heavy,

625
00:29:40,331 --> 00:29:44,095
you probably are targeting the right bottleneck there

626
00:29:44,095 --> 00:29:46,758
and you're likely to see higher percentual gains from that.

627
00:29:49,805 --> 00:29:53,808
And there are multiple sources of eGPR pressure.

628
00:29:53,808 --> 00:29:56,150
One is I call the main source of eGPR pressure, which is

629
00:29:56,150 --> 00:29:58,632
what everybody's thinking mostly when they talk about

630
00:29:58,632 --> 00:29:59,172
eGPR pressure.

631
00:29:59,172 --> 00:30:02,575
It's just how many maximum number of live registers you

632
00:30:02,575 --> 00:30:03,997
have at the same time.

633
00:30:03,997 --> 00:30:06,799
So basically, how many temporary values need to be

634
00:30:06,799 --> 00:30:09,381
stored cached, however you want to think of it during the

635
00:30:09,381 --> 00:30:11,343
actual execution of the shader.

636
00:30:11,343 --> 00:30:14,445
And pertaining to this material blending example, the

637
00:30:14,445 --> 00:30:18,449
reason why it's particularly eGPR heavy is because

638
00:30:19,109 --> 00:30:21,030
Every material has a lot of attributes,

639
00:30:21,030 --> 00:30:24,392
and to reduce each wave's latency,

640
00:30:24,392 --> 00:30:27,373
it's often optimal to have all the memory read

641
00:30:27,373 --> 00:30:30,015
in at the beginning of the shader execution,

642
00:30:30,015 --> 00:30:32,736
and then all those values are cached basically in VGPRs

643
00:30:32,736 --> 00:30:34,877
until they're actually used.

644
00:30:34,877 --> 00:30:38,139
And now think of having to sample multiple materials

645
00:30:38,139 --> 00:30:40,140
per pixel, like in case of Far Cry 5,

646
00:30:40,140 --> 00:30:41,860
they sample up to two materials per pixel.

647
00:30:43,261 --> 00:30:46,044
So then those attributes need to be cached twice,

648
00:30:46,044 --> 00:30:49,508
you're caching twice the number of attributes.

649
00:30:49,508 --> 00:30:51,330
And even though a certain pixel

650
00:30:51,330 --> 00:30:53,251
is not using both the materials,

651
00:30:53,251 --> 00:30:55,794
the shader still needs to allocate the full VGPR

652
00:30:55,794 --> 00:30:58,217
in case it needs to allocate twice.

653
00:30:58,217 --> 00:30:59,798
So that's a real concern there.

654
00:31:02,208 --> 00:31:06,914
Obviously, packed math helps the average VGPR occupancy case

655
00:31:06,914 --> 00:31:10,698
because with packed math, you can store two 16-bit values

656
00:31:10,698 --> 00:31:13,722
in the same space you require to store a single 32-bit value.

657
00:31:13,722 --> 00:31:16,265
But there's a different dimension to VGPR pressure,

658
00:31:16,265 --> 00:31:18,047
which is actually the focus of my talk today.

659
00:31:21,080 --> 00:31:25,663
Not a lot of people are actually familiar with the fact that there is allocation overhead

660
00:31:25,663 --> 00:31:27,004
for vGPRs.

661
00:31:27,004 --> 00:31:31,627
And you can think of this as just like waste, like vGPRs that are really used.

662
00:31:32,920 --> 00:31:34,562
wastefully and that cannot be avoided.

663
00:31:34,562 --> 00:31:35,823
And it's because of certain restrictions.

664
00:31:35,823 --> 00:31:38,506
And these restrictions are related to the way

665
00:31:38,506 --> 00:31:40,487
memory operations work.

666
00:31:40,487 --> 00:31:44,351
So if you look mid-slide, you can see in monospace font

667
00:31:44,351 --> 00:31:46,954
an actual hardware instruction that loads four components

668
00:31:46,954 --> 00:31:47,514
from a buffer.

669
00:31:47,514 --> 00:31:50,617
You can see buffer load format x, y, z, w.

670
00:31:50,617 --> 00:31:55,041
And the first parameter is the actual output.

671
00:31:55,041 --> 00:31:57,083
It reads these four components, x, y, z, and w,

672
00:31:57,083 --> 00:31:58,164
into the registers.

673
00:31:59,632 --> 00:32:01,493
one to four, V1 to four,

674
00:32:01,493 --> 00:32:03,354
and that's an actual registered range,

675
00:32:03,354 --> 00:32:04,194
and that's a key concept.

676
00:32:04,194 --> 00:32:06,535
So the actual components need to be read

677
00:32:06,535 --> 00:32:07,935
into consecutive registers.

678
00:32:07,935 --> 00:32:11,677
You cannot spread them out over arbitrary registers.

679
00:32:11,677 --> 00:32:14,658
And the order of the components in the registers

680
00:32:14,658 --> 00:32:15,998
has to be exactly that order.

681
00:32:15,998 --> 00:32:19,100
So V1 will contain X, and V4 will contain W.

682
00:32:19,100 --> 00:32:21,080
There's no way to swizzle the components

683
00:32:21,080 --> 00:32:22,581
at the instruction level.

684
00:32:23,147 --> 00:32:26,490
So these are significant constraints

685
00:32:26,490 --> 00:32:28,832
that end up causing allocation overhead

686
00:32:28,832 --> 00:32:30,294
in ways which we'll show next.

687
00:32:30,294 --> 00:32:34,197
And this also would stand for texture dimensions.

688
00:32:34,197 --> 00:32:36,600
So if you look at the ISA example here,

689
00:32:36,600 --> 00:32:38,922
you can see the texture coordinate

690
00:32:38,922 --> 00:32:40,544
is the second parameter is V0.

691
00:32:40,544 --> 00:32:42,886
This is because it's a buffer.

692
00:32:42,886 --> 00:32:44,207
But if this would be a 3D texture,

693
00:32:44,207 --> 00:32:45,388
the same sort of constraints would apply.

694
00:32:49,556 --> 00:32:52,378
So how do you know if your shader is actually suffering

695
00:32:52,378 --> 00:32:53,599
from allocation overhead?

696
00:32:53,599 --> 00:32:58,464
For that, you need to perform live register analysis.

697
00:32:58,464 --> 00:33:02,887
And on PC, we have the Radeon GPU analyzer,

698
00:33:02,887 --> 00:33:05,029
which is our open source tool that

699
00:33:05,029 --> 00:33:07,291
allows you to do just that amongst many other things.

700
00:33:07,291 --> 00:33:10,394
It basically takes an HLSL as input,

701
00:33:10,394 --> 00:33:13,897
and it will generate a bunch of helpful outputs

702
00:33:13,897 --> 00:33:15,598
amongst which the live register analysis.

703
00:33:16,827 --> 00:33:20,391
And you really need this to be able to optimize your shader,

704
00:33:20,391 --> 00:33:23,414
and especially to detect the allocation overhead.

705
00:33:23,414 --> 00:33:25,155
So I'll be showing two examples.

706
00:33:25,155 --> 00:33:28,338
I will be showing two shaders, one shader which

707
00:33:28,338 --> 00:33:30,420
features no allocation overhead, which is on this slide.

708
00:33:30,420 --> 00:33:33,864
And then the next slide will show a shader that actually

709
00:33:33,864 --> 00:33:36,867
suffers from one VGBR allocation overhead,

710
00:33:36,867 --> 00:33:38,708
and is a slight modification of this shader.

711
00:33:39,569 --> 00:33:41,270
So at the bottom right in the red box,

712
00:33:41,270 --> 00:33:44,332
you can see the HLSL listing for the shader

713
00:33:44,332 --> 00:33:46,953
with a bit of pseudocode added to make it easy to read.

714
00:33:46,953 --> 00:33:50,295
And at the top, you can see the RGA output,

715
00:33:50,295 --> 00:33:53,877
which is the actual live VGPR analysis.

716
00:33:55,117 --> 00:33:57,540
And if you look at the HLSL listing,

717
00:33:57,540 --> 00:33:59,362
you can see this is a very simple shader

718
00:33:59,362 --> 00:34:01,284
that reads from an input buffer.

719
00:34:01,284 --> 00:34:03,126
It reads four components,

720
00:34:03,126 --> 00:34:05,249
and it performs some math of the components,

721
00:34:05,249 --> 00:34:10,995
and then the result is a three-component vector of...

722
00:34:11,401 --> 00:34:13,382
the initial four components.

723
00:34:13,382 --> 00:34:15,263
So you can see in yellow font,

724
00:34:15,263 --> 00:34:19,566
you can see that that is all the math

725
00:34:19,566 --> 00:34:20,887
that is performed on the input,

726
00:34:20,887 --> 00:34:23,208
contained right there in pseudocode.

727
00:34:23,208 --> 00:34:28,252
So at the top, what is the live VGPR analysis?

728
00:34:28,252 --> 00:34:30,893
You can see the RG output to the leftmost column

729
00:34:30,893 --> 00:34:31,654
is just the line number.

730
00:34:32,254 --> 00:34:34,135
which is still useful, so I can refer to it.

731
00:34:34,135 --> 00:34:38,377
The second column is the actual number of maximum vGPRs

732
00:34:38,377 --> 00:34:41,258
used at that specific location in execution.

733
00:34:41,258 --> 00:34:44,460
So it matches the particular instruction.

734
00:34:44,460 --> 00:34:47,321
And then the third column actually contains a matrix,

735
00:34:47,321 --> 00:34:49,522
and the matrix has its...

736
00:34:50,395 --> 00:34:54,719
own lines and columns, and it encodes the live VGPR state

737
00:34:54,719 --> 00:34:58,402
of each individual VGPR at each individual location in

738
00:34:58,402 --> 00:35:00,985
the instruction timeline.

739
00:35:00,985 --> 00:35:03,727
So within this matrix, the lines correspond to the

740
00:35:03,727 --> 00:35:05,309
instructions of the columns.

741
00:35:05,309 --> 00:35:08,492
They correspond to the actual VGPRs.

742
00:35:08,492 --> 00:35:11,475
So VGPR0 would be the leftmost column, and then VGPR4 would

743
00:35:11,475 --> 00:35:12,676
be the rightmost column.

744
00:35:15,106 --> 00:35:18,088
The characters encode the state.

745
00:35:18,088 --> 00:35:19,129
So we have the carets.

746
00:35:19,129 --> 00:35:20,790
You can see four carets at the top.

747
00:35:20,790 --> 00:35:24,672
A caret means that a particular VGPR is written into

748
00:35:24,672 --> 00:35:27,073
at that location by the instruction.

749
00:35:27,073 --> 00:35:30,095
And obviously, the value will have to be stored for later.

750
00:35:30,095 --> 00:35:33,638
And then the V letter, which you can see four Vs

751
00:35:33,638 --> 00:35:37,040
at the bottom, that means that value has just

752
00:35:37,040 --> 00:35:38,461
been read by that instruction.

753
00:35:38,461 --> 00:35:40,822
And the value is no longer needed.

754
00:35:41,242 --> 00:35:43,625
And then the x character, the x letter there,

755
00:35:43,625 --> 00:35:46,107
means it's a combination of the caret and the v.

756
00:35:46,107 --> 00:35:48,349
So it means that that particular instruction

757
00:35:48,349 --> 00:35:50,371
read a value from that register,

758
00:35:50,371 --> 00:35:53,494
and it overwrote that register with a new value.

759
00:35:53,494 --> 00:35:55,757
And when you see a column character,

760
00:35:55,757 --> 00:35:57,438
that just means the register is live.

761
00:35:57,438 --> 00:35:59,540
So the particular instruction might be reading from it

762
00:35:59,540 --> 00:36:01,042
or not doing anything with that register,

763
00:36:01,042 --> 00:36:03,524
but in any case, its value is needed for a later time.

764
00:36:04,085 --> 00:36:06,465
And when you see a blank space character,

765
00:36:06,465 --> 00:36:09,646
that just means the BGPR is free for usage.

766
00:36:09,646 --> 00:36:11,727
It stores no value of consequence at that point.

767
00:36:11,727 --> 00:36:15,728
So how does the shitter get compiled

768
00:36:15,728 --> 00:36:17,028
into actual machine instructions?

769
00:36:17,028 --> 00:36:18,488
You can see the first instruction

770
00:36:18,488 --> 00:36:21,729
is reading the four components.

771
00:36:21,729 --> 00:36:23,970
It's exactly the instruction we looked at earlier.

772
00:36:23,970 --> 00:36:27,050
And then the second instruction is just

773
00:36:27,050 --> 00:36:30,571
waiting for the memory operation to finish, at which point

774
00:36:30,571 --> 00:36:32,111
we have the actual math.

775
00:36:32,532 --> 00:36:34,753
And now, if you look at the actual math

776
00:36:34,753 --> 00:36:36,615
that needs to be performed, you will see that

777
00:36:36,615 --> 00:36:38,957
if the hardware is to be efficient

778
00:36:38,957 --> 00:36:40,818
about the way in which it goes and computes

779
00:36:40,818 --> 00:36:42,880
all the three components of the result,

780
00:36:42,880 --> 00:36:45,502
is it actually can do this with only three additions

781
00:36:45,502 --> 00:36:47,564
if they are done in this order.

782
00:36:47,564 --> 00:36:49,825
If the X plus Y is added first,

783
00:36:49,825 --> 00:36:52,568
if the Z component is added afterwards,

784
00:36:52,568 --> 00:36:54,629
and then if the W component is added last

785
00:36:54,629 --> 00:36:56,511
to all these intermediate results.

786
00:36:57,391 --> 00:36:59,652
So all these intermediary results will have to be stored

787
00:36:59,652 --> 00:37:03,193
in VGPRs for both purposes of computing further math

788
00:37:03,193 --> 00:37:06,454
and also for the purpose of them actually being output.

789
00:37:06,454 --> 00:37:08,374
Now if we skip straight to line six

790
00:37:08,374 --> 00:37:11,495
where the output is actually stored, it's written out,

791
00:37:11,495 --> 00:37:13,676
we can see again when it's written out,

792
00:37:13,676 --> 00:37:14,976
it has to be written out in a range

793
00:37:14,976 --> 00:37:19,217
where again the VGPRs one to three are written out

794
00:37:19,217 --> 00:37:20,818
and they have to be consecutive

795
00:37:20,818 --> 00:37:22,238
and they have to be in that exact order.

796
00:37:22,898 --> 00:37:25,183
So this creates constraints on the math

797
00:37:25,183 --> 00:37:26,285
for the math to be efficient.

798
00:37:26,285 --> 00:37:30,573
So we see the first addition at line three,

799
00:37:30,573 --> 00:37:34,019
that it has to add the x and y components.

800
00:37:34,875 --> 00:37:41,078
Obviously it has to read v1 and v2, and you can see in yellow font, you can see that the output is v1.

801
00:37:41,078 --> 00:37:46,181
And the compiler only has a choice of v1 or v2 at that point, because it just read those values,

802
00:37:46,181 --> 00:37:49,942
so now those registers are available to store intermediate values.

803
00:37:49,942 --> 00:37:52,964
So in this case, it stores the value at v1.

804
00:37:52,964 --> 00:37:58,026
And then, it's important to note with the second addition, that now the output, in order to avoid any...

805
00:37:58,146 --> 00:38:01,707
inefficient swaps, it will actually have to allocate

806
00:38:01,707 --> 00:38:04,068
that value into v2 because remember,

807
00:38:04,068 --> 00:38:06,968
it has to be all output in consecutive registers.

808
00:38:06,968 --> 00:38:09,789
So it's actually able to compute the math

809
00:38:09,789 --> 00:38:12,030
in the proper order and to store it in v1, v2, and v3.

810
00:38:12,030 --> 00:38:15,611
So everything is good here, no allocation overhead.

811
00:38:15,611 --> 00:38:18,332
Five vGPRs are used, five vGPRs are allocated,

812
00:38:18,332 --> 00:38:21,593
everything is good, the math is done in place.

813
00:38:22,273 --> 00:38:24,194
And now we're going to slightly modify the HLSL

814
00:38:24,194 --> 00:38:26,176
for our second example.

815
00:38:26,176 --> 00:38:28,598
And as you can see, the HLSL has been modified just

816
00:38:28,598 --> 00:38:32,701
by changing the component order in which the math is done.

817
00:38:32,701 --> 00:38:36,184
So now the math is done on the W and Z components first,

818
00:38:36,184 --> 00:38:37,825
and then it has to add Y, and then it

819
00:38:37,825 --> 00:38:39,427
has to add X to be efficient.

820
00:38:39,427 --> 00:38:41,568
So it's exactly backwards.

821
00:38:41,568 --> 00:38:46,072
And this really affects the way the shader runs on the machine,

822
00:38:46,072 --> 00:38:49,034
because the first edition, now it has to read from W and Z.

823
00:38:50,475 --> 00:38:54,721
But those are stored at VGPR 3 and 4, because remember, when they come in, they have to

824
00:38:54,721 --> 00:38:56,424
come in in consecutive registers.

825
00:38:56,424 --> 00:39:01,811
So now this means that the result of this addition can only be stored

826
00:39:02,274 --> 00:39:06,895
in v3 or v4 because v1 is still busy with x and v2 is still busy with y.

827
00:39:06,895 --> 00:39:13,097
So once that's done, once the compiler actually uses v3 to store an intermediate result,

828
00:39:13,097 --> 00:39:15,997
to be able to actually now store the output in consecutive registers,

829
00:39:15,997 --> 00:39:20,858
it's forced to go on to store the next results in v4 and v5.

830
00:39:20,858 --> 00:39:24,639
And when it actually allocates v5, we can see on the third column,

831
00:39:24,639 --> 00:39:29,200
the one with the matrix that encodes the vGPR register states,

832
00:39:29,200 --> 00:39:32,121
we can see red highlights vGPR2 and vGPR5.

833
00:39:32,621 --> 00:39:34,704
And we can see VGPR5 with a caret,

834
00:39:34,704 --> 00:39:37,246
it just becomes allocated to store the intermediary value,

835
00:39:37,246 --> 00:39:39,188
and then it quickly becomes deallocated

836
00:39:39,188 --> 00:39:41,070
as it's written to output.

837
00:39:41,070 --> 00:39:43,113
But we notice that throughout its lifetime,

838
00:39:43,113 --> 00:39:45,575
we notice that VGPR2 is completely empty.

839
00:39:45,575 --> 00:39:49,319
So this is what allocation overhead is.

840
00:39:49,319 --> 00:39:51,021
It's the fact that...

841
00:39:51,955 --> 00:39:54,217
the shader compiler has to allocate an additional VGPR

842
00:39:54,217 --> 00:39:56,720
even though one would have been free

843
00:39:56,720 --> 00:39:59,382
because of additional constraints.

844
00:39:59,382 --> 00:40:02,605
And this can further degenerate in a complex shader

845
00:40:02,605 --> 00:40:04,748
to cause further allocation fragmentation

846
00:40:04,748 --> 00:40:08,231
because once the actual ordering of the VGPRs matter,

847
00:40:08,231 --> 00:40:13,236
it can all cascade from there.

848
00:40:13,236 --> 00:40:13,816
So how does...

849
00:40:14,787 --> 00:40:17,652
half precision actually help allocation overhead?

850
00:40:17,652 --> 00:40:19,535
Well, the answer is actually very simple.

851
00:40:19,535 --> 00:40:25,845
Two VGPRs, only two VGPRs are needed consecutively.

852
00:40:25,845 --> 00:40:25,925
So.

853
00:40:27,511 --> 00:40:31,232
When a memory operation is loaded,

854
00:40:31,232 --> 00:40:33,252
it only needs those two consecutive EGPRs.

855
00:40:33,252 --> 00:40:37,073
That creates a lot less opportunity for fragmentation.

856
00:40:37,073 --> 00:40:40,094
And that's the simple story of it.

857
00:40:40,094 --> 00:40:43,295
So basically, if you are able to identify the locations where

858
00:40:43,295 --> 00:40:45,415
you have significant allocation overhead,

859
00:40:45,415 --> 00:40:47,356
you will be able to very effectively counter it

860
00:40:47,356 --> 00:40:48,336
by using half precision.

861
00:40:48,336 --> 00:40:51,897
And that's it for my optimization.

862
00:40:51,897 --> 00:40:57,098
Back to Bain for further water discussions.

863
00:41:00,862 --> 00:41:05,685
Okay, so basically we spent a lot of time experimenting with this and we were shipping

864
00:41:05,685 --> 00:41:06,485
Far Cry 5 is coming out next week.

865
00:41:06,485 --> 00:41:10,908
So I thought it would be interesting to talk about a lot of the problems we had trying

866
00:41:10,908 --> 00:41:14,950
to do the screen space distillation and water writing depth.

867
00:41:14,950 --> 00:41:17,451
So yeah, first line is water writes depth.

868
00:41:17,451 --> 00:41:22,514
The moment you make this decision, you're setting yourself up for a lot of bugs.

869
00:41:22,514 --> 00:41:24,135
When I say a lot, I mean a lot.

870
00:41:26,540 --> 00:41:31,562
This is kind of a little bit of a curse because you essentially have to have two depth buffers

871
00:41:31,562 --> 00:41:35,985
in your engine at this point and everything has to decide whether it's going to sample

872
00:41:35,985 --> 00:41:41,147
the one with or without water and you really need to actually think about

873
00:41:42,183 --> 00:41:45,645
how to actually implement this because in some systems,

874
00:41:45,645 --> 00:41:47,226
you can actually copy the depth buffer

875
00:41:47,226 --> 00:41:49,468
after you have the depth buffer with no water,

876
00:41:49,468 --> 00:41:51,169
but on some of them you can't.

877
00:41:51,169 --> 00:41:52,230
And what do you do with the stencil?

878
00:41:52,230 --> 00:41:53,531
If you copy it without the stencil,

879
00:41:53,531 --> 00:41:56,573
then all the passes that require the depth with stencil,

880
00:41:56,573 --> 00:41:58,054
you can't actually do that.

881
00:41:58,054 --> 00:42:00,055
Or you might even have one pass

882
00:42:00,055 --> 00:42:03,517
that does a down-res multi-sample,

883
00:42:03,517 --> 00:42:06,399
which you could potentially fix this,

884
00:42:06,399 --> 00:42:08,981
where you write out the depth, read it back in,

885
00:42:08,981 --> 00:42:11,223
and write it out through your chain of depth buffers.

886
00:42:12,317 --> 00:42:14,800
We have a lot of small textures on console.

887
00:42:14,800 --> 00:42:17,763
This is not really an issue because we do a lot of packing

888
00:42:17,763 --> 00:42:18,544
between passes.

889
00:42:18,544 --> 00:42:21,648
So we'll know exactly the layout of our data structure.

890
00:42:21,648 --> 00:42:23,970
We can pass one texture's value from one to another.

891
00:42:23,970 --> 00:42:26,093
And we do a lot of ping pong.

892
00:42:27,319 --> 00:42:30,722
simply because this allows us to pack the textures.

893
00:42:30,722 --> 00:42:34,104
And we do a frame allocator, so we know during the frame

894
00:42:34,104 --> 00:42:35,525
when the texture's gonna be free,

895
00:42:35,525 --> 00:42:37,767
so we can release the texture and regain it

896
00:42:37,767 --> 00:42:39,348
when we actually need it,

897
00:42:39,348 --> 00:42:40,549
so we don't use up a lot of memory.

898
00:42:40,549 --> 00:42:42,930
Screen space distillation,

899
00:42:42,930 --> 00:42:45,432
there are two major issues with this.

900
00:42:45,432 --> 00:42:47,574
The vertex shader is quite slow,

901
00:42:47,574 --> 00:42:49,415
and on the current GPUs,

902
00:42:49,415 --> 00:42:52,938
if you're actually launching a lot of large vertex shaders,

903
00:42:52,938 --> 00:42:54,239
but very small pixel shaders,

904
00:42:54,239 --> 00:42:55,860
you actually end up stalling the GPU.

905
00:42:56,640 --> 00:43:02,464
So we did a lot of optimizations where the vertex buffer is actually just a 16-bit integer,

906
00:43:02,464 --> 00:43:08,507
which is encoded for UVs, but it basically has to be the lightest possible vertex shader

907
00:43:08,507 --> 00:43:09,848
you can imagine.

908
00:43:09,848 --> 00:43:15,011
But lucky for us in the future, because we are doing per-pixel to vertex tessellation,

909
00:43:15,011 --> 00:43:21,455
we could do a compute pass which does all the ALU operations beforehand, and then we

910
00:43:21,455 --> 00:43:24,817
simply do a fetch from a buffer instead of actually computing everything.

911
00:43:26,197 --> 00:43:31,300
vertex buffer. We also had a lot of edge issues. I'll show you a picture of what

912
00:43:31,300 --> 00:43:36,422
this might look like. So if you do things in screen space you could actually end

913
00:43:36,422 --> 00:43:42,404
up with two connecting water bodies which ends up stretching the mesh in the

914
00:43:42,404 --> 00:43:47,406
distance which is not really ideal but we actually did end up fixing this.

915
00:43:48,307 --> 00:43:53,590
And the way we fixed it is we simply ran a compute shader that actually tracks where

916
00:43:53,590 --> 00:43:58,032
the two water bodies connect and lowers the displacement.

917
00:43:58,032 --> 00:44:03,415
This is actually a result of the FBM displacement being in screen space.

918
00:44:03,936 --> 00:44:08,420
We do plan to actually move that into world space FBM generation

919
00:44:08,420 --> 00:44:12,984
into some sort of atlas that we can fetch and fix this issue later.

920
00:44:12,984 --> 00:44:14,845
But for now, this is what we did.

921
00:44:14,845 --> 00:44:19,109
So we figure out the edges, and then we blur using a compute shader.

922
00:44:19,109 --> 00:44:22,472
The way you actually do this is, it's very simple to do,

923
00:44:22,472 --> 00:44:26,536
just like you would downsample a cubemap.

924
00:44:28,908 --> 00:44:31,849
Okay, the other really annoying thing we had to deal with

925
00:44:31,849 --> 00:44:35,630
is in Far Cry 5, we have a fishing minigame,

926
00:44:35,630 --> 00:44:38,690
which is quite nice, but this creates a fishing rod,

927
00:44:38,690 --> 00:44:41,291
which is actually a near Z and far Z.

928
00:44:41,291 --> 00:44:43,072
So it's partially UI and partially 3D.

929
00:44:43,072 --> 00:44:46,332
And if you have screen space reflections,

930
00:44:46,332 --> 00:44:49,213
you're gonna get this nasty line

931
00:44:49,213 --> 00:44:50,414
that's created by this line.

932
00:44:50,414 --> 00:44:52,834
And this line also changes color.

933
00:44:52,834 --> 00:44:53,894
So as you're fishing,

934
00:44:53,894 --> 00:44:56,095
you'll see the water's constantly flickering.

935
00:44:57,206 --> 00:44:59,387
We did actually manage to fix that

936
00:44:59,387 --> 00:45:02,048
by running a post-processing pass

937
00:45:02,048 --> 00:45:07,270
after we do the ray tracing for the screen space reflections.

938
00:45:07,270 --> 00:45:13,353
Just some little debugging tools we use to debug this.

939
00:45:13,353 --> 00:45:14,673
When you're generating a lot of data,

940
00:45:14,673 --> 00:45:18,415
you might want to create tools that help you debug this.

941
00:45:18,415 --> 00:45:20,816
In this case, we're showing the world flow

942
00:45:20,816 --> 00:45:23,357
map in a specific location along with the water level.

943
00:45:25,533 --> 00:45:30,976
And this is how the two materials would blend in screen space.

944
00:45:30,976 --> 00:45:32,678
You'll see also on the left side there's

945
00:45:32,678 --> 00:45:37,180
a little map for artists to know which material is which.

946
00:45:37,180 --> 00:45:40,803
And the colors essentially indicate the blending range

947
00:45:40,803 --> 00:45:41,603
in screen space.

948
00:45:42,145 --> 00:45:44,948
and they have control over controlling this range.

949
00:45:44,948 --> 00:45:46,829
So an artist can say, I want these two water bodies

950
00:45:46,829 --> 00:45:50,252
to blend over three meters, six meters, 12 meters.

951
00:45:50,252 --> 00:45:51,814
We typically use six meters.

952
00:45:51,814 --> 00:45:56,277
And we also showed the assigned distance field,

953
00:45:56,277 --> 00:45:58,659
which we used to debug all the water flow problems

954
00:45:58,659 --> 00:46:01,822
around rocks and shorelines.

955
00:46:01,822 --> 00:46:03,564
So I know somebody's thinking here,

956
00:46:03,564 --> 00:46:06,766
how much does this take?

957
00:46:06,766 --> 00:46:08,848
Our budget was two milliseconds on the GPU.

958
00:46:10,546 --> 00:46:13,407
these are all the passes listed and how long they take.

959
00:46:13,407 --> 00:46:15,667
The things in green are actually running

960
00:46:15,667 --> 00:46:17,288
async compute in our game,

961
00:46:17,288 --> 00:46:19,568
but if they're actually running on the main pipe,

962
00:46:19,568 --> 00:46:22,029
this is what the performance would be like.

963
00:46:22,029 --> 00:46:23,950
And if you look at the numbers,

964
00:46:23,950 --> 00:46:27,151
the two most expensive things are the tessellation,

965
00:46:27,151 --> 00:46:28,891
which is at .2 milliseconds,

966
00:46:28,891 --> 00:46:32,392
and composite passes actually is .87,

967
00:46:32,392 --> 00:46:35,073
which is mostly done by the tile Z bin lighting.

968
00:46:36,307 --> 00:46:40,169
So once we actually run this on async compute,

969
00:46:40,169 --> 00:46:43,672
our time goes down to 1.337 milliseconds.

970
00:46:43,672 --> 00:46:47,194
However, this assumes that you actually

971
00:46:47,194 --> 00:46:49,516
have gaps in your async compute pipeline.

972
00:46:49,516 --> 00:46:52,118
In our case, we did, because we have full control over

973
00:46:52,118 --> 00:46:54,339
when our async pass is run.

974
00:46:54,339 --> 00:46:55,820
So we got that large win.

975
00:46:55,820 --> 00:46:59,943
And this is just a little video to demonstrate

976
00:46:59,943 --> 00:47:01,585
all of this in action.

977
00:48:05,182 --> 00:48:09,868
So just before, we have two more slides just before we finish.

978
00:48:09,868 --> 00:48:14,534
So there's actually a bunch of other Far Cry 5 talks happening this week.

979
00:48:14,534 --> 00:48:17,498
The first one is terrain rendering by Jeremy Moore.

980
00:48:18,037 --> 00:48:21,119
The next one is the asset build system of Far Cry 5 by Remy.

981
00:48:21,119 --> 00:48:25,242
And the last one is the procedural world generation

982
00:48:25,242 --> 00:48:25,602
of Far Cry 5.

983
00:48:25,602 --> 00:48:28,565
These talks are all really good to attend,

984
00:48:28,565 --> 00:48:31,066
because they are all kind of counterparts to our water

985
00:48:31,066 --> 00:48:35,190
system, especially the procedural world generation,

986
00:48:35,190 --> 00:48:37,771
because it feeds all the data into our system

987
00:48:37,771 --> 00:48:38,752
that we use to render.

988
00:48:38,752 --> 00:48:43,336
And last but not least, a big thank you to the Far Cry 5

989
00:48:43,336 --> 00:48:43,556
team.

