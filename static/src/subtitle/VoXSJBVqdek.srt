1
00:00:07,092 --> 00:00:07,852
Good morning, everyone.

2
00:00:08,252 --> 00:00:10,093
It's a real pleasure to be here.

3
00:00:11,013 --> 00:00:12,393
I must say I'm totally terrified.

4
00:00:12,694 --> 00:00:16,975
But I am Xavier Sadoulet, and with my colleague Laurent

5
00:00:16,995 --> 00:00:19,476
Cuvidoux, we flew all the way from France to talk about the

6
00:00:19,616 --> 00:00:20,516
AI in Dishonored 2.

7
00:00:21,817 --> 00:00:24,117
But before getting started, we think a few

8
00:00:24,197 --> 00:00:24,898
things are in order.

9
00:00:26,090 --> 00:00:28,891
First, we'd like to thank this community,

10
00:00:29,311 --> 00:00:30,852
be it the member of the Guild

11
00:00:31,332 --> 00:00:33,013
or the people presenting over the years

12
00:00:33,473 --> 00:00:34,914
at places like here, JCC.

13
00:00:35,575 --> 00:00:37,596
What we will discuss today

14
00:00:37,996 --> 00:00:40,137
was inspired by what you guys shared.

15
00:00:40,417 --> 00:00:42,438
So we're happy to give some back today.

16
00:00:43,559 --> 00:00:45,179
Then, of course, we want to mention

17
00:00:45,279 --> 00:00:47,501
all the guys that worked on the AI for Designer 2

18
00:00:48,141 --> 00:00:50,102
and supported us in the preparation of the talk.

19
00:00:51,857 --> 00:00:57,058
Um, but lastly, a big shout-out to all the team in Lyon.

20
00:00:57,378 --> 00:00:59,638
It is those guys' work we're representing today.

21
00:01:00,239 --> 00:01:01,959
So they deserve proper credit.

22
00:01:02,639 --> 00:01:05,260
There. We don't be being emotional,

23
00:01:05,320 --> 00:01:06,200
so let's get to it.

24
00:01:07,320 --> 00:01:09,981
So who already played the first Tishanod?

25
00:01:11,761 --> 00:01:13,002
Oh, not bad. Okay.

26
00:01:13,342 --> 00:01:14,302
Who played Tishanod 2?

27
00:01:14,482 --> 00:01:16,963
Oh, that's good.

28
00:01:18,583 --> 00:01:22,145
During rehearsals at the studio, everybody was waiting there.

29
00:01:24,326 --> 00:01:26,187
I guess we need to explain what the game is about.

30
00:01:26,207 --> 00:01:29,348
Dishonored 2 is an action-adventure game

31
00:01:29,748 --> 00:01:30,608
played in first person.

32
00:01:31,349 --> 00:01:33,129
Like all arcane games, it belongs

33
00:01:33,170 --> 00:01:37,211
to the immersive theme genre, among titles like System Shock,

34
00:01:37,271 --> 00:01:39,452
Deus Ex, or the Thief series.

35
00:01:40,332 --> 00:01:42,473
In this game, you play an assassin

36
00:01:43,194 --> 00:01:46,495
that can use either stealth or combat approach, or both.

37
00:01:47,775 --> 00:01:50,316
And he is given supernatural powers as tools

38
00:01:50,376 --> 00:01:51,176
to achieve his goals.

39
00:01:52,197 --> 00:01:55,598
But essentially, the game is really about how the player

40
00:01:55,658 --> 00:01:58,679
chooses to approach each mission, each situation.

41
00:02:00,499 --> 00:02:03,820
Here is a short video showing you a glimpse of what the game

42
00:02:03,840 --> 00:02:04,200
looks like.

43
00:03:06,941 --> 00:03:10,943
Now that you saw what the game is about,

44
00:03:11,463 --> 00:03:13,224
let's talk about some challenges we had

45
00:03:13,304 --> 00:03:15,144
to tackle during the production.

46
00:03:16,605 --> 00:03:18,185
The first one was scope.

47
00:03:18,686 --> 00:03:22,147
Not like the sniper scope, more like game scope.

48
00:03:22,927 --> 00:03:26,209
Let's say the AI had quite a few things to support.

49
00:03:26,229 --> 00:03:32,691
Stealth, combat, verticality, dynamic relationships,

50
00:03:33,672 --> 00:03:36,153
teleporting player, teleporting NPCs.

51
00:03:37,442 --> 00:03:41,143
Ambush behavior, NPCs interacting with blood flies,

52
00:03:42,163 --> 00:03:45,745
time travel, moving walls and floors and roof,

53
00:03:46,965 --> 00:03:51,767
player clone, time stop, player taking control of NPCs,

54
00:03:52,827 --> 00:03:54,748
fully interactable scripted scenes.

55
00:03:56,089 --> 00:03:58,650
And what about fully interactable scripted scenes?

56
00:03:59,130 --> 00:04:01,851
Why do players take control of a participating NPC?

57
00:04:04,017 --> 00:04:08,279
So basically, we have all the problems of action adventure

58
00:04:08,299 --> 00:04:10,040
games and much, much more.

59
00:04:12,041 --> 00:04:15,863
Thus, we had to rely very heavily on simulation.

60
00:04:16,283 --> 00:04:19,885
Because in every feature review, there is always some

61
00:04:19,925 --> 00:04:21,966
guy in the team to ask something like this.

62
00:04:23,375 --> 00:04:27,138
Xavier, what happens in that situation if I stop time

63
00:04:27,559 --> 00:04:30,761
while swapping position with my clone in front of a teleporting

64
00:04:30,822 --> 00:04:33,264
witch and then possess a blood fly that's

65
00:04:33,304 --> 00:04:34,404
carrying a stone mine?

66
00:04:35,485 --> 00:04:37,527
Answer now.

67
00:04:38,828 --> 00:04:39,829
Every time.

68
00:04:40,309 --> 00:04:42,131
And the thing is that it's totally

69
00:04:42,171 --> 00:04:44,673
possible to do that kind of crazy stuff with our game.

70
00:04:45,714 --> 00:04:47,315
So the bottom line.

71
00:04:48,349 --> 00:04:52,013
is that there are some corners we simply cannot afford to cut.

72
00:04:52,754 --> 00:04:54,676
There are many, many edge cases.

73
00:04:55,637 --> 00:04:57,739
And we had to do things the hard way

74
00:04:57,819 --> 00:05:00,022
to ensure all systems work together.

75
00:05:00,963 --> 00:05:03,485
And in order to implement those systems,

76
00:05:04,606 --> 00:05:06,949
we were starting from nothing.

77
00:05:09,053 --> 00:05:12,174
Beginning in 2002, we chose to build a new engine,

78
00:05:12,414 --> 00:05:17,315
starting from 8.5, and reworking it to fit our kind of game.

79
00:05:18,175 --> 00:05:20,176
We rewrote the AI part from scratch.

80
00:05:21,096 --> 00:05:22,937
We also planned to take full advantage

81
00:05:23,057 --> 00:05:26,258
of the new generation hardware, this honored one being

82
00:05:26,338 --> 00:05:27,658
initially last-gen only.

83
00:05:28,378 --> 00:05:31,479
And as the Arkham Asteens guy went to another project,

84
00:05:31,959 --> 00:05:33,880
which is a pretty cool game called Prey.

85
00:05:34,858 --> 00:05:38,119
There was only one AI programmer remaining from this 101.

86
00:05:38,259 --> 00:05:40,900
So we basically had to rebuild an AI team.

87
00:05:42,200 --> 00:05:44,701
In that context, we decided to always

88
00:05:44,761 --> 00:05:47,282
try the simple thing first.

89
00:05:47,582 --> 00:05:51,643
Avoid overcomplication at all costs.

90
00:05:52,424 --> 00:05:54,885
We chose tried and true techniques.

91
00:05:55,345 --> 00:05:57,826
Standard way of organizing our AI systems,

92
00:05:58,226 --> 00:06:00,667
non-stuff with ample literature available.

93
00:06:01,970 --> 00:06:05,332
We tried to step away from unneeded new shiny things.

94
00:06:06,153 --> 00:06:09,995
And very importantly, we did homework, spent time writing

95
00:06:10,096 --> 00:06:13,678
technical documentation, thinking on paper, writing

96
00:06:13,758 --> 00:06:15,139
unit tests for our systems.

97
00:06:15,820 --> 00:06:19,682
Speaking about systems and standard stuff, we've got it

98
00:06:19,722 --> 00:06:25,046
all, sensory system, knowledge system, behavior tree, smart

99
00:06:25,086 --> 00:06:27,228
object, navmesh, everything.

100
00:06:28,228 --> 00:06:28,669
But guess what?

101
00:06:29,886 --> 00:06:32,188
Those are not within the scope of this talk.

102
00:06:33,869 --> 00:06:35,210
What we are going to discuss today

103
00:06:35,891 --> 00:06:38,613
are three systems where we did things a little differently.

104
00:06:39,053 --> 00:06:39,874
Let's see one of those.

105
00:06:41,896 --> 00:06:42,636
Thank you, Xavier.

106
00:06:43,497 --> 00:06:44,338
So hi, everyone.

107
00:06:44,678 --> 00:06:48,581
I'm going to first present a few things about our rule system.

108
00:06:50,322 --> 00:06:51,183
So why rules?

109
00:06:52,524 --> 00:06:55,306
Very trivially, making a next-gen dishonor

110
00:06:55,326 --> 00:06:58,469
with such a large scope meant more assets to present.

111
00:06:59,537 --> 00:07:01,719
And we're a very design-driven studio,

112
00:07:01,939 --> 00:07:04,481
so something our designers expressed early

113
00:07:04,942 --> 00:07:06,683
was their desire to have more control

114
00:07:06,743 --> 00:07:09,946
over how voice recordings and animations are used by the game.

115
00:07:10,847 --> 00:07:14,070
Having to make a code change every time an asset needs

116
00:07:14,110 --> 00:07:15,972
to be integrated is very bad.

117
00:07:16,553 --> 00:07:19,515
And as we didn't want to turn our designers into programmers

118
00:07:19,656 --> 00:07:21,938
either, we had to make sure we'd come up

119
00:07:21,978 --> 00:07:23,279
with something user-friendly.

120
00:07:25,167 --> 00:07:26,747
Also, last but not least, we needed

121
00:07:26,767 --> 00:07:28,408
to find a solution with a performance

122
00:07:28,488 --> 00:07:31,349
cost that fits the hardware of the current generation

123
00:07:31,389 --> 00:07:31,969
of consoles.

124
00:07:34,950 --> 00:07:38,111
So how do we track all the simulation states

125
00:07:38,852 --> 00:07:41,112
to present these assets in a varied and meaningful way?

126
00:07:41,633 --> 00:07:43,693
This was an open question during pre-production.

127
00:07:43,713 --> 00:07:46,354
And because we started our AI tech from scratch,

128
00:07:46,795 --> 00:07:48,855
we had the complete freedom to try a new technique.

129
00:07:50,559 --> 00:07:54,481
This is where this GDC talk by Ilan Ruskin came to help.

130
00:07:55,101 --> 00:07:57,983
He presented a rule system used notably in Left 4 Dead 1 and 2.

131
00:07:58,883 --> 00:08:01,885
It inspired us and seemed like a good candidate to help us

132
00:08:01,945 --> 00:08:03,646
overcome the challenge I just mentioned.

133
00:08:04,286 --> 00:08:06,367
So do yourself a favor and go check it someday.

134
00:08:06,888 --> 00:08:09,169
Just to make things clear from the beginning, we basically

135
00:08:09,189 --> 00:08:10,770
stole all of his ideas.

136
00:08:13,669 --> 00:08:17,155
So rules were something that met our requirements.

137
00:08:17,616 --> 00:08:19,719
We went on and implemented a similar system

138
00:08:19,759 --> 00:08:21,402
in our new engine, the Void engine.

139
00:08:23,065 --> 00:08:24,708
So yeah, that's it for rules.

140
00:08:24,728 --> 00:08:25,369
Thanks for listening.

141
00:08:27,775 --> 00:08:28,595
I'm just kidding.

142
00:08:29,055 --> 00:08:32,496
I said a similar system, not identical.

143
00:08:33,077 --> 00:08:35,217
Like every team, we have our own requirements.

144
00:08:35,237 --> 00:08:37,018
So we did a few things differently.

145
00:08:37,738 --> 00:08:40,579
For those that attended yesterday, you saw actually

146
00:08:40,639 --> 00:08:43,560
two other use cases of similar systems.

147
00:08:43,660 --> 00:08:45,161
So this is a common thing.

148
00:08:46,521 --> 00:08:50,102
My goal here is to give you details on our specifics.

149
00:08:50,622 --> 00:08:51,483
So let's talk about this.

150
00:08:52,785 --> 00:08:55,607
First, I need to go over the terminology and basic principles.

151
00:08:56,047 --> 00:08:59,109
We define a rule as the combination of two collections,

152
00:08:59,889 --> 00:09:02,271
a list of conditions and a list of actions.

153
00:09:04,112 --> 00:09:05,493
Conditions are predicates.

154
00:09:05,833 --> 00:09:10,756
We combine them in what is just a glorified if and if conditional.

155
00:09:11,317 --> 00:09:13,418
They pull the state of the simulation in, in other words,

156
00:09:13,458 --> 00:09:14,559
the current game context.

157
00:09:16,700 --> 00:09:20,223
So, concretely, a condition is the comparison

158
00:09:20,263 --> 00:09:22,384
between a name variable and a constant value.

159
00:09:23,907 --> 00:09:24,687
Here's an example.

160
00:09:25,867 --> 00:09:29,869
We can have a rule matching when an NPC barks because they

161
00:09:29,909 --> 00:09:30,970
just busted the player.

162
00:09:31,690 --> 00:09:34,231
So we are testing the bark trigger variable that tells us

163
00:09:34,691 --> 00:09:36,152
why we are trying to bark now.

164
00:09:37,152 --> 00:09:38,513
And let's test a few more variables.

165
00:09:39,253 --> 00:09:41,234
So is the current HP a bit low?

166
00:09:41,854 --> 00:09:44,215
Is the world in high or very high chaos?

167
00:09:45,116 --> 00:09:47,156
And let's match this five times out of six.

168
00:09:49,482 --> 00:09:51,964
Note that we only have logical ends.

169
00:09:52,665 --> 00:09:55,267
This removes the need to handle operator precedences.

170
00:09:55,828 --> 00:09:57,790
It also makes evaluating the result trivial.

171
00:09:57,890 --> 00:10:00,372
A rule matches when every condition matches.

172
00:10:00,913 --> 00:10:02,855
So it just makes things simpler.

173
00:10:04,917 --> 00:10:05,798
Now to actions.

174
00:10:06,558 --> 00:10:07,880
They can be virtually anything.

175
00:10:08,801 --> 00:10:11,423
As you saw earlier, for us mostly playing lines of speech

176
00:10:11,523 --> 00:10:13,285
or animations, but it could be anything else.

177
00:10:14,757 --> 00:10:17,477
When there are several actions, they are picked one at a time.

178
00:10:18,017 --> 00:10:22,258
Every time a rule matches, only one single action is executed

179
00:10:22,799 --> 00:10:23,759
when there's enough assets.

180
00:10:23,899 --> 00:10:26,860
It's a great tool to provide variety in an explicit way.

181
00:10:29,300 --> 00:10:32,241
Finally, if you take a bunch of these rules

182
00:10:32,341 --> 00:10:36,122
and stick them together, you get what we call a rule handler.

183
00:10:36,262 --> 00:10:40,563
So this is just a set of rules, our editable resource.

184
00:10:43,532 --> 00:10:45,173
So let's talk about editing.

185
00:10:45,993 --> 00:10:47,273
One thing we made is an editor.

186
00:10:48,313 --> 00:10:51,674
Ilan, if you hear me sometime, we followed your advice

187
00:10:51,714 --> 00:10:52,914
and listened to our designers.

188
00:10:53,554 --> 00:10:57,075
The Wish was a tool integrated into our in-house editor.

189
00:10:58,295 --> 00:11:00,356
And I already told you about designers, right?

190
00:11:00,976 --> 00:11:01,796
They want everything.

191
00:11:02,116 --> 00:11:05,196
So it had to come up with all the ND features that

192
00:11:05,237 --> 00:11:08,437
make such a tool usable, copy paste, undo, redo, et cetera.

193
00:11:09,584 --> 00:11:10,904
So we created just that.

194
00:11:11,464 --> 00:11:13,925
Let's see the rules editor in action quickly.

195
00:11:15,845 --> 00:11:19,186
So this is me creating a couple of NPC bark rules.

196
00:11:19,606 --> 00:11:23,287
Let's say I want to play some lines when an aristocrat notices

197
00:11:23,327 --> 00:11:27,828
something, for instance, a flower pot or a teapot.

198
00:11:28,728 --> 00:11:31,168
So I won't give you a full tutorial here.

199
00:11:32,188 --> 00:11:33,789
Don't worry if it's going too fast.

200
00:11:34,029 --> 00:11:37,209
What I want to show here is the type of editor we have.

201
00:11:37,609 --> 00:11:38,970
You can see that we have two rules.

202
00:11:39,861 --> 00:11:41,441
here and here.

203
00:11:43,082 --> 00:11:47,103
And also two sets of conditions and two sets of actions.

204
00:11:48,263 --> 00:11:51,324
So a respectable editor, maybe not totally mature,

205
00:11:51,364 --> 00:11:54,525
but this is the actual tool we use to develop Dishonored 2.

206
00:11:56,946 --> 00:11:58,866
Now, what did we create with this?

207
00:11:59,886 --> 00:12:04,128
I won't detail everything, but as I said, we have, well,

208
00:12:04,808 --> 00:12:08,749
there are rules for NPCs and also rules for the player.

209
00:12:09,598 --> 00:12:12,439
and mostly speech and animations.

210
00:12:13,359 --> 00:12:15,820
So this proved to be quite a versatile system.

211
00:12:17,400 --> 00:12:20,361
One interesting use case is achievements over there.

212
00:12:21,102 --> 00:12:23,662
The rule system was a very good fit for things like

213
00:12:24,443 --> 00:12:27,924
check that X coins were looted to grant achievement Y.

214
00:12:29,184 --> 00:12:30,325
And since we all love numbers,

215
00:12:31,065 --> 00:12:33,586
this is how many rules were created for each category.

216
00:12:34,086 --> 00:12:35,566
So the grand total is about 6,000 rules, 6,000.

217
00:12:40,105 --> 00:12:43,168
At runtime, rule handlers are instantiated

218
00:12:43,328 --> 00:12:44,950
and will be used for evaluation.

219
00:12:45,270 --> 00:12:48,493
This means evaluating all rules it contains one by one

220
00:12:48,873 --> 00:12:51,756
in order and executing the first one that gets selected.

221
00:12:52,377 --> 00:12:55,159
So very trivially, this one doesn't match,

222
00:12:55,280 --> 00:12:58,243
so we go to the second one that doesn't match either.

223
00:12:59,143 --> 00:13:00,925
So we try yet another rule, and this time,

224
00:13:01,205 --> 00:13:04,348
every condition matches, so it's picked for execution.

225
00:13:05,150 --> 00:13:08,371
We never needed to match more rules than only one.

226
00:13:08,771 --> 00:13:10,372
So the evaluation stops here.

227
00:13:10,552 --> 00:13:12,973
That's some CPU time for other stuff.

228
00:13:15,473 --> 00:13:17,834
So what do I mean by execution?

229
00:13:18,914 --> 00:13:21,715
Every time a rule is selected, one action is executed.

230
00:13:22,275 --> 00:13:23,856
There are several ways you can handle this.

231
00:13:24,036 --> 00:13:26,116
One way is to go over the actions sequentially.

232
00:13:26,537 --> 00:13:28,437
So the first time a rule is selected,

233
00:13:28,957 --> 00:13:30,818
we pick the first action and execute it.

234
00:13:31,699 --> 00:13:34,420
The second time, we execute the second action

235
00:13:35,380 --> 00:13:36,640
until we run out of actions.

236
00:13:37,340 --> 00:13:40,301
So things have been pretty straightforward until now,

237
00:13:40,321 --> 00:13:41,141
but please bear with me.

238
00:13:41,641 --> 00:13:43,782
This is where things start to be a little interesting.

239
00:13:45,802 --> 00:13:47,683
At this point, we can either start again

240
00:13:47,843 --> 00:13:50,543
from the first action, or we can simply

241
00:13:50,623 --> 00:13:53,724
say these actions are depleted and never select this rule

242
00:13:53,744 --> 00:13:53,944
again.

243
00:13:54,864 --> 00:13:58,985
We allow both, and we call these two options execution policies.

244
00:14:01,162 --> 00:14:05,664
Sequential execution is handy, but sometimes what you really

245
00:14:05,704 --> 00:14:07,845
want is random variations.

246
00:14:10,746 --> 00:14:10,967
Thanks.

247
00:14:14,889 --> 00:14:18,570
For instance, for ambient bars, you don't want NPCs to

248
00:14:18,610 --> 00:14:20,792
say the same lines in the same order all the time.

249
00:14:21,232 --> 00:14:23,273
This gives a robot effect pretty fast, and it's

250
00:14:23,293 --> 00:14:24,253
distracting for players.

251
00:14:27,325 --> 00:14:32,389
The naive approach to randomizing things is to pick a random outcome every time a rule is selected.

252
00:14:32,889 --> 00:14:36,451
The problem with this kind of approach is that it doesn't prevent repetitions.

253
00:14:37,032 --> 00:14:40,434
So this is another annoying robot effect.

254
00:14:41,294 --> 00:14:43,095
So we don't do this.

255
00:14:44,796 --> 00:14:49,499
What we do instead is that we shuffle the action list during initialization

256
00:14:50,060 --> 00:14:52,721
and then shuffle again every time we reach the end.

257
00:14:54,221 --> 00:14:56,962
Just like you would shuffle a deck of cards

258
00:14:57,002 --> 00:14:58,503
before playing a game of poker.

259
00:14:58,943 --> 00:15:00,483
So this is called a shuffle back.

260
00:15:01,124 --> 00:15:02,684
Given a list of possible options,

261
00:15:03,124 --> 00:15:04,725
it's the most natural way to use them all

262
00:15:04,965 --> 00:15:06,446
while avoiding common pitfalls.

263
00:15:08,447 --> 00:15:10,327
Beware though, when shuffling,

264
00:15:10,567 --> 00:15:13,709
you should never put back the last action in the first spot.

265
00:15:14,169 --> 00:15:15,830
Otherwise you'll get a nasty repetition,

266
00:15:16,150 --> 00:15:17,610
which we're trying to avoid.

267
00:15:19,231 --> 00:15:21,152
So one workaround is to simply send it

268
00:15:21,252 --> 00:15:23,913
in any other random spot but the first one.

269
00:15:28,361 --> 00:15:35,603
Okay. So, that's a total of four execution policies that we used in the final game.

270
00:15:36,623 --> 00:15:42,545
Sequential or shuffled execution of actions were great to prevent repetition for one entity.

271
00:15:44,666 --> 00:15:46,567
But what about several entities?

272
00:15:48,107 --> 00:15:49,988
We still wanted to prevent the same bark.

273
00:15:50,940 --> 00:15:55,046
or attack from being played twice in a row by different NPCs.

274
00:15:55,667 --> 00:16:00,053
So we obtained this by putting recently executed actions in a global list,

275
00:16:00,514 --> 00:16:04,039
forbidding other NPCs to execute it until a cooldown depletes.

276
00:16:05,837 --> 00:16:09,198
Actually, once we had this option to filter actions at

277
00:16:09,298 --> 00:16:11,739
runtime, we found other uses for it.

278
00:16:12,439 --> 00:16:14,760
We also ended up implementing it for conditions.

279
00:16:15,380 --> 00:16:18,761
So we didn't plan for this initially, and this evolved a

280
00:16:18,781 --> 00:16:19,502
bit organically.

281
00:16:19,542 --> 00:16:22,823
But it's probably something interesting to explore

282
00:16:22,923 --> 00:16:23,323
further.

283
00:16:25,924 --> 00:16:28,925
Earlier, I mentioned briefly that we instantiate our rule

284
00:16:28,945 --> 00:16:30,485
handlers during initialization.

285
00:16:31,539 --> 00:16:32,980
We actually say that we compile them.

286
00:16:33,321 --> 00:16:37,324
That's because we perform some significant data transforms

287
00:16:37,384 --> 00:16:40,026
at this stage, mostly for performance reasons.

288
00:16:40,927 --> 00:16:42,628
But one interesting thing that we do

289
00:16:42,948 --> 00:16:44,530
is that we compile rule handlers.

290
00:16:44,790 --> 00:16:49,134
This allows to add a custom set of rules for specific NPCs.

291
00:16:50,595 --> 00:16:52,957
For instance, members of the Howlers gang

292
00:16:53,437 --> 00:16:55,559
have a bunch of specific attacks.

293
00:16:56,443 --> 00:16:58,644
We can take these attacks and combine them

294
00:16:58,764 --> 00:17:01,705
with the generic attacks that every NPC has

295
00:17:02,646 --> 00:17:05,107
into one single rule handler instance.

296
00:17:07,968 --> 00:17:09,248
Since we combine rule handlers,

297
00:17:09,268 --> 00:17:11,789
we need to determine how to solve the resultant set of rules.

298
00:17:11,969 --> 00:17:14,570
So we call this a compilation policy.

299
00:17:15,890 --> 00:17:18,331
One solution is to simply not sort

300
00:17:18,771 --> 00:17:20,412
and just concatenate everything.

301
00:17:21,492 --> 00:17:25,094
This is actually a very sensible solution for small rule sets.

302
00:17:25,614 --> 00:17:28,416
What you see in editor is what you get in game.

303
00:17:29,096 --> 00:17:30,237
So clear and simple.

304
00:17:30,557 --> 00:17:32,378
We use this for most rule types.

305
00:17:33,218 --> 00:17:35,880
But for us, barks were the exception.

306
00:17:36,220 --> 00:17:37,541
We have too many of them.

307
00:17:38,161 --> 00:17:41,083
And really needed more lovers to get to the desired results.

308
00:17:42,223 --> 00:17:42,343
So...

309
00:17:43,278 --> 00:17:46,260
We first tried to sort rules by condition count,

310
00:17:46,821 --> 00:17:49,163
as Ilan Ruskin advises in his talk.

311
00:17:49,784 --> 00:17:51,005
But it didn't cut it for us.

312
00:17:51,685 --> 00:17:54,368
Our lead narrative designer, Sashka,

313
00:17:54,968 --> 00:17:57,670
often found herself adding new, empty conditions

314
00:17:58,191 --> 00:18:00,313
just to get to the outcome she wanted.

315
00:18:01,454 --> 00:18:04,096
So we changed our approach near the end of the production.

316
00:18:04,861 --> 00:18:08,223
The solution we've shipped with is that we give every bark a priority,

317
00:18:08,903 --> 00:18:11,424
and we use this as the first criteria for sorting,

318
00:18:11,944 --> 00:18:15,306
keeping the condition count only as a second criteria.

319
00:18:17,907 --> 00:18:21,869
Something else we do during compilation is that we share identical action lists.

320
00:18:22,229 --> 00:18:25,251
So, let me explain this with another example.

321
00:18:25,671 --> 00:18:30,573
Our fighting NPCs can kick or punch under different sets of conditions.

322
00:18:31,398 --> 00:18:34,119
So offline, we have two independent rules,

323
00:18:34,599 --> 00:18:36,280
one to trigger close combat attacks

324
00:18:36,740 --> 00:18:38,941
when back to the role literally,

325
00:18:39,461 --> 00:18:41,642
and another one for a player blocking too much.

326
00:18:42,642 --> 00:18:46,344
At runtime, these two rules point to the same action list.

327
00:18:46,904 --> 00:18:49,845
So a sequential execution shares the same counter.

328
00:18:50,806 --> 00:18:53,047
In other words, you won't observe

329
00:18:53,307 --> 00:18:55,267
the same punch animation twice in a row,

330
00:18:55,788 --> 00:18:58,729
just because it was triggered under different conditions.

331
00:18:59,688 --> 00:19:02,669
And yes, in case you wonder, that those give us a logical

332
00:19:02,849 --> 00:19:05,871
OR for the few cases where we actually need it.

333
00:19:08,252 --> 00:19:11,633
Now, let me come back to variables for a moment

334
00:19:11,693 --> 00:19:13,074
and give you some more juicy details.

335
00:19:13,874 --> 00:19:17,096
These variables have a unique path to keep things simple

336
00:19:17,196 --> 00:19:18,356
and order in the editor.

337
00:19:19,257 --> 00:19:22,758
Their role is to tell us how to get to the actual data.

338
00:19:24,801 --> 00:19:27,102
So let me list some data bindings we have.

339
00:19:27,122 --> 00:19:31,243
A variable can give the value of a C++ class member

340
00:19:31,523 --> 00:19:34,765
or be computed by a method, we call these providers,

341
00:19:35,625 --> 00:19:38,786
or it can point directly at an NPC knowledge record

342
00:19:39,706 --> 00:19:43,108
or at a variable created in data by level designers.

343
00:19:44,168 --> 00:19:46,129
And we also have a few more bindings.

344
00:19:48,169 --> 00:19:50,290
So when do we resolve variables?

345
00:19:51,302 --> 00:19:53,304
We resolve these variables on demand.

346
00:19:53,964 --> 00:19:57,026
Most of the time, we only need a few variables

347
00:19:57,066 --> 00:19:59,228
to be actually resolved during one evaluation.

348
00:19:59,888 --> 00:20:02,750
For instance, let's say that the first rule of a set matches.

349
00:20:03,491 --> 00:20:04,772
We won't evaluate the remainder,

350
00:20:05,172 --> 00:20:07,033
so we don't have to pay the cost

351
00:20:07,233 --> 00:20:09,495
of resolving the variables we will never check.

352
00:20:11,156 --> 00:20:11,396
Still.

353
00:20:12,270 --> 00:20:16,452
Resolving a variable every time would be very damageable for performance.

354
00:20:16,492 --> 00:20:19,213
We have variables that are actually method pointers

355
00:20:19,813 --> 00:20:23,174
and that do perform quite a bit of computations before they return a value.

356
00:20:24,135 --> 00:20:26,956
So since resolving twice or more is useless in practice,

357
00:20:27,396 --> 00:20:31,737
we don't want to pay that cost each time a variable is tested during one evaluation.

358
00:20:31,757 --> 00:20:35,959
So we cache the resolved values for the time of an evaluation.

359
00:20:38,869 --> 00:20:44,032
and having this cache does save about 2 thirds of the time spent evaluating rules.

360
00:20:44,772 --> 00:20:49,655
So note that these figures are for a thousand rule handlers, but we evaluate just a few

361
00:20:49,675 --> 00:20:50,536
of them per frame.

362
00:20:50,776 --> 00:20:58,421
So our performance metrics are okay for this generation of consoles and onwards.

363
00:21:01,323 --> 00:21:05,045
So time to close this chapter with what we envision for the future.

364
00:21:06,800 --> 00:21:09,761
One thing that is a bit clumsy with our current system

365
00:21:10,381 --> 00:21:12,542
is that some variables are only available

366
00:21:12,662 --> 00:21:15,643
to some type of rule for no particular reason.

367
00:21:16,163 --> 00:21:18,084
For instance, a variable exposed for barks

368
00:21:18,304 --> 00:21:19,464
can be missing for adducts.

369
00:21:20,365 --> 00:21:23,286
If you are going to use rules in many different contexts,

370
00:21:23,526 --> 00:21:26,667
just like we do, make sure you take this into account

371
00:21:27,287 --> 00:21:29,568
and share your variables as much as possible.

372
00:21:31,269 --> 00:21:34,151
And of course, you always need better debugging tools,

373
00:21:34,411 --> 00:21:35,752
and we make no exception.

374
00:21:36,413 --> 00:21:39,316
Something we miss is a visualization tool

375
00:21:39,356 --> 00:21:41,117
for the combined and sorted rules.

376
00:21:41,818 --> 00:21:44,080
Also at runtime, all we have to debug an evaluation

377
00:21:44,160 --> 00:21:45,020
is a good old dump.

378
00:21:45,941 --> 00:21:48,003
So we'll try to improve this in the future.

379
00:21:50,645 --> 00:21:52,867
Finally, we've talked about our cache system,

380
00:21:52,907 --> 00:21:55,510
but we know there's more we can do on the performance side.

381
00:21:55,590 --> 00:21:57,812
So if we expand our usage of rules even more,

382
00:21:58,152 --> 00:21:59,133
we know there's room for it.

383
00:22:01,817 --> 00:22:04,780
So to sum up, what makes rules so sexy?

384
00:22:05,661 --> 00:22:09,084
Firstly, they are very appropriate for simple

385
00:22:09,244 --> 00:22:11,206
and short-term contextual decisions.

386
00:22:12,428 --> 00:22:15,331
Secondly, they're a data-driven tool.

387
00:22:16,051 --> 00:22:18,975
In the end, they made our designers happy,

388
00:22:19,996 --> 00:22:23,339
I believe, or at least, might be satisfied.

389
00:22:25,164 --> 00:22:26,786
It should be obvious to everybody,

390
00:22:27,026 --> 00:22:28,547
if you have to make a code change

391
00:22:28,587 --> 00:22:31,189
for each and every new asset in a AAA game,

392
00:22:31,429 --> 00:22:33,491
well, you're just never going to ship it.

393
00:22:34,272 --> 00:22:35,893
And finally, you saw the metrics,

394
00:22:36,314 --> 00:22:38,555
we now have more than enough hardware resources

395
00:22:38,595 --> 00:22:39,937
to afford such a system,

396
00:22:40,357 --> 00:22:41,798
so there's no reason not to do it.

397
00:22:42,719 --> 00:22:44,360
So, your turn to rule, Xavier.

398
00:22:46,963 --> 00:22:48,584
Thanks, Laurent, you ruled.

399
00:22:49,745 --> 00:22:51,526
Okay, now let's pick DSM.

400
00:22:54,763 --> 00:23:00,266
I do realize that I'm not making things easy on myself by starting a section of this talk

401
00:23:00,286 --> 00:23:01,907
with some obscure acronym.

402
00:23:02,688 --> 00:23:04,549
So let's try to explain a bit.

403
00:23:05,850 --> 00:23:09,312
Originally DSM meant dynamic space management.

404
00:23:10,713 --> 00:23:17,217
Or maybe dynamic space mapping, but you could take any of those other meanings I came up

405
00:23:17,297 --> 00:23:18,938
with while writing this part of the talk.

406
00:23:20,360 --> 00:23:21,400
And yes, there is a pen.

407
00:23:22,301 --> 00:23:24,882
The point here is that it's not about what it means.

408
00:23:25,263 --> 00:23:26,403
It's about what it does.

409
00:23:27,244 --> 00:23:31,486
And DSM is our solution for spatial reasoning and

410
00:23:31,646 --> 00:23:32,286
influence mapping.

411
00:23:33,767 --> 00:23:38,230
First, let me show you what we use spatial reasoning for in

412
00:23:38,350 --> 00:23:38,690
our game.

413
00:23:40,711 --> 00:23:43,573
There you can see witches teleporting themselves and

414
00:23:43,693 --> 00:23:46,114
summoning a vine using dynamic position.

415
00:23:48,369 --> 00:23:52,014
Then we have the always funny case of civilians running away

416
00:23:52,034 --> 00:23:54,477
in panic and choosing destination dynamically.

417
00:23:55,238 --> 00:23:58,342
And lastly, we have the player losing NPC in combat and

418
00:23:58,423 --> 00:24:01,487
having them decide where they should go to chase him.

419
00:24:04,671 --> 00:24:04,932
Missed.

420
00:24:06,414 --> 00:24:11,516
So now to summarize all this, this is what spatial reasoning

421
00:24:11,636 --> 00:24:14,657
is about for us, scoring position in the world.

422
00:24:14,817 --> 00:24:18,279
And in order to do that, you have to have a finite number

423
00:24:18,339 --> 00:24:21,060
of positions and then to evaluate them.

424
00:24:22,280 --> 00:24:24,361
GSM helps us for both of those.

425
00:24:24,661 --> 00:24:26,502
So let's start with the first part.

426
00:24:28,078 --> 00:24:31,301
Let me introduce the main element of DSM, the layout.

427
00:24:32,241 --> 00:24:35,424
The whole point of the layout is discretizing the geometry

428
00:24:35,444 --> 00:24:39,326
of the map, or more precisely, discretizing the nav mesh,

429
00:24:40,007 --> 00:24:41,748
which depends on the map geometry.

430
00:24:43,670 --> 00:24:46,972
We do computation offline, going from each nav mesh face

431
00:24:47,953 --> 00:24:50,655
to a bunch of cells forming a layer of grid.

432
00:24:51,895 --> 00:24:52,176
And voila.

433
00:24:53,181 --> 00:24:56,825
The grid resolution is one meter by one meter by two meter.

434
00:24:57,525 --> 00:24:59,627
And its origin is the maximum point

435
00:24:59,927 --> 00:25:01,749
of the navmesh bounding box.

436
00:25:03,611 --> 00:25:06,213
There is ample literature around on how

437
00:25:06,253 --> 00:25:07,635
to build a grid from a navmesh.

438
00:25:07,755 --> 00:25:09,817
We can recommend this talk among others.

439
00:25:10,297 --> 00:25:13,781
Just I'm not going to detail those techniques.

440
00:25:13,801 --> 00:25:13,961
Sorry.

441
00:25:15,301 --> 00:25:18,743
The data representation of the DSM grid is a big array of cells.

442
00:25:19,303 --> 00:25:21,664
We encode the array index on two bytes,

443
00:25:22,605 --> 00:25:25,066
which allows more than 60,000 cells in a map.

444
00:25:25,466 --> 00:25:27,607
This is sufficient for us, as in average,

445
00:25:28,468 --> 00:25:29,788
we have 20,000 cells.

446
00:25:31,229 --> 00:25:32,790
Now, let me talk real quick

447
00:25:33,210 --> 00:25:35,271
about the order of the cells in the array.

448
00:25:36,352 --> 00:25:39,513
They are naturally grouped by navmesh faces.

449
00:25:39,753 --> 00:25:41,074
This is an interesting property.

450
00:25:42,410 --> 00:25:44,631
First, it enhance data locality.

451
00:25:45,011 --> 00:25:48,353
Cells close in the world tend to be close in memory.

452
00:25:49,433 --> 00:25:52,275
It's also interesting when the navmesh is getting cut.

453
00:25:52,495 --> 00:25:54,616
We'll touch on that a little bit later.

454
00:25:55,556 --> 00:25:58,938
And lastly, it's basically free, because it's just a

455
00:25:58,978 --> 00:26:01,759
consequence of the way we construct the layout,

456
00:26:02,180 --> 00:26:04,401
iterating over all navmesh spaces.

457
00:26:06,021 --> 00:26:09,183
Each cell is a data struct containing the grid

458
00:26:09,203 --> 00:26:10,804
coordinate, x, y level.

459
00:26:11,782 --> 00:26:14,187
the navmesh face ID it was created from,

460
00:26:15,230 --> 00:26:17,515
and the vertical offset from the center

461
00:26:17,775 --> 00:26:18,717
to this navmesh face.

462
00:26:20,213 --> 00:26:24,095
NavMesh offset is important, because without it, we only

463
00:26:24,155 --> 00:26:27,797
have a bunch of flat grid layers to play with, which is

464
00:26:27,837 --> 00:26:30,498
not an ideal representation of the world, unless you're

465
00:26:30,518 --> 00:26:31,858
making a game on Apple II.

466
00:26:33,079 --> 00:26:35,940
As you can see on the right, when taking NavMesh offset

467
00:26:36,000 --> 00:26:39,282
into account, our cells are far closer from what the world

468
00:26:39,422 --> 00:26:40,222
actually looks like.

469
00:26:41,103 --> 00:26:44,244
And as this is all about picking location in the world,

470
00:26:44,945 --> 00:26:46,826
it's better if those locations make sense, right?

471
00:26:47,807 --> 00:26:51,207
So using this offset, we can go from a cell

472
00:26:51,567 --> 00:26:52,828
to a real world location.

473
00:26:53,488 --> 00:26:55,848
But what about doing it the other way around?

474
00:26:56,808 --> 00:26:58,409
Let's say you have a location in the world

475
00:26:58,829 --> 00:27:01,089
and want to find which cells it belongs to.

476
00:27:02,410 --> 00:27:05,570
Knowing the origin and the resolution of the DSM grid,

477
00:27:06,150 --> 00:27:08,511
we know we can translate from world coordinates

478
00:27:09,111 --> 00:27:09,991
to grid coordinates.

479
00:27:11,031 --> 00:27:14,072
And then from those coordinates, we can construct a key.

480
00:27:15,316 --> 00:27:19,378
that we then feed to a hash table we call Hatch Access Table

481
00:27:19,738 --> 00:27:21,378
and get the resulting cell index.

482
00:27:21,919 --> 00:27:22,099
Easy.

483
00:27:23,839 --> 00:27:26,400
Sometimes the access table is not fast enough

484
00:27:27,141 --> 00:27:29,261
when you need to access a lot of cells at once.

485
00:27:29,942 --> 00:27:33,103
Thus, we also add a cell index stored

486
00:27:33,223 --> 00:27:34,543
in what we called Access Tree,

487
00:27:35,164 --> 00:27:36,524
which is in fact a KD tree.

488
00:27:38,269 --> 00:27:40,611
With this, we can formulate queries like,

489
00:27:40,711 --> 00:27:43,653
give me the list of cells that are within a five-meter radius

490
00:27:43,713 --> 00:27:44,834
from this point in the world.

491
00:27:45,274 --> 00:27:45,874
Pretty handy.

492
00:27:46,775 --> 00:27:49,457
Okay, with those two ways of connecting cells,

493
00:27:49,757 --> 00:27:51,278
we're pretty much covered.

494
00:27:52,779 --> 00:27:54,621
If we go back to our statement earlier,

495
00:27:55,081 --> 00:27:57,002
we saw that the word discretization part

496
00:27:57,102 --> 00:27:58,683
is supported by the layout.

497
00:27:58,904 --> 00:28:01,806
Now let's talk about the evaluation part.

498
00:28:02,546 --> 00:28:04,788
That is supported by what we call layers.

499
00:28:06,222 --> 00:28:07,865
A layer is simply an array of value.

500
00:28:08,687 --> 00:28:10,590
The array is allocated in one block

501
00:28:10,891 --> 00:28:14,338
and is the same size as the layout in the cell array.

502
00:28:16,367 --> 00:28:18,728
Layers are the dynamic part of the DSM system.

503
00:28:19,248 --> 00:28:22,229
They are equivalent to the classical influence map layers

504
00:28:22,269 --> 00:28:24,250
for those familiar with this concept.

505
00:28:25,170 --> 00:28:27,411
Unlike the layout, layer data is allowed

506
00:28:27,491 --> 00:28:28,691
to change at run time.

507
00:28:29,392 --> 00:28:33,193
It can store any data type, and those values are typically

508
00:28:33,293 --> 00:28:36,414
information on the game world, like danger rating of a cell,

509
00:28:36,474 --> 00:28:37,915
proximity to the player, et cetera.

510
00:28:38,895 --> 00:28:42,297
Their main function is to support scoring of each cell.

511
00:28:43,867 --> 00:28:47,328
The nice thing is that you can add as many layers as you need.

512
00:28:48,068 --> 00:28:50,889
And each layer, sorry, okay,

513
00:28:51,229 --> 00:28:53,249
and each layer memory cost is mainly dependent

514
00:28:53,429 --> 00:28:56,070
on the type of data you choose to store in it.

515
00:28:57,291 --> 00:28:58,891
Once you have one cell index,

516
00:28:59,411 --> 00:29:02,852
you can instantly access any piece of data about that cell

517
00:29:03,573 --> 00:29:05,613
in any layer, constant time.

518
00:29:06,013 --> 00:29:08,274
Hence, we can combine layer values easily

519
00:29:08,514 --> 00:29:09,794
for our scoring need.

520
00:29:10,515 --> 00:29:12,435
Let's call this vertical traversal.

521
00:29:13,938 --> 00:29:16,641
But another interesting thing you can do with layers

522
00:29:16,781 --> 00:29:22,127
is traversing them sequentially until finding a cell that

523
00:29:23,188 --> 00:29:24,049
has the correct value.

524
00:29:25,070 --> 00:29:28,033
Once we found one, then we have a cell index.

525
00:29:28,113 --> 00:29:29,835
And thus, we can directly access the tile

526
00:29:29,855 --> 00:29:33,258
by that very cell, be it in the layout or in another layer.

527
00:29:34,099 --> 00:29:34,920
Then we can carry on.

528
00:29:36,044 --> 00:29:39,005
Let's call this horizontal traversal.

529
00:29:39,385 --> 00:29:41,426
And please do note, good friends,

530
00:29:41,646 --> 00:29:44,547
that this technique was awarded the totally unofficial

531
00:29:44,887 --> 00:29:46,368
cache-friendliness seal of quality.

532
00:29:47,888 --> 00:29:50,529
Traversing layers that way is really, really fast,

533
00:29:50,749 --> 00:29:54,570
provided you put reasonably-sized data in them,

534
00:29:54,931 --> 00:29:55,291
of course.

535
00:29:56,851 --> 00:30:00,873
OK, now we can pick location in the game world and score them.

536
00:30:01,073 --> 00:30:01,273
Great.

537
00:30:01,733 --> 00:30:03,894
We're ready to take a look at a concrete example.

538
00:30:04,054 --> 00:30:04,634
But before that.

539
00:30:06,098 --> 00:30:08,560
we need to discuss a particular problem we had to solve.

540
00:30:24,648 --> 00:30:27,289
Remember the moving floors and walls of ClockworkMotion?

541
00:30:27,709 --> 00:30:30,991
We obviously had many cases of navmesh being cut dynamically.

542
00:30:31,271 --> 00:30:32,611
How do we change that?

543
00:30:34,226 --> 00:30:36,507
When the navmesh gets cut by any kind of object,

544
00:30:36,547 --> 00:30:38,168
like a door or a piece of furniture,

545
00:30:38,829 --> 00:30:40,690
the DSM gets notified with a list

546
00:30:40,730 --> 00:30:42,491
of the navmesh faces affected.

547
00:30:43,272 --> 00:30:45,353
Remember how cells are grouped by face ID

548
00:30:45,493 --> 00:30:46,534
in the layout array?

549
00:30:47,454 --> 00:30:49,956
This allows us to know which cell belongs

550
00:30:50,016 --> 00:30:52,597
to the list of cut navmesh faces very rapidly.

551
00:30:53,518 --> 00:30:56,080
And from here, it's easy to test which cells

552
00:30:56,200 --> 00:30:57,921
are actually cut and disable them.

553
00:30:59,298 --> 00:31:02,760
Disabling a cell is merely another information to it.

554
00:31:03,720 --> 00:31:05,501
The access table and the access tree

555
00:31:05,621 --> 00:31:08,983
do not return disabled cells by default.

556
00:31:09,983 --> 00:31:12,505
In the end, it is really up to the client code

557
00:31:12,545 --> 00:31:16,326
to decide if the disabled status is taken into account or not.

558
00:31:17,667 --> 00:31:20,869
The disabled status itself is stored

559
00:31:20,949 --> 00:31:23,150
in a bit field containing as many bits

560
00:31:23,330 --> 00:31:24,571
as the layout has cells.

561
00:31:25,211 --> 00:31:27,132
We use vertical traversal to check

562
00:31:27,212 --> 00:31:28,793
if a cell is enabled or not.

563
00:31:30,453 --> 00:31:35,437
All right, let's talk about an actual example of DSM usage

564
00:31:35,497 --> 00:31:38,119
in the game, which is search destination selection.

565
00:31:38,940 --> 00:31:42,962
The basic principle of search is that NPCs choose one

566
00:31:43,383 --> 00:31:46,305
destination, go to it, and then choose another one, rinse

567
00:31:46,425 --> 00:31:48,446
and repeat until the end of the time.

568
00:31:49,387 --> 00:31:52,529
We use the DSM to decide which destination is selected.

569
00:31:54,310 --> 00:31:57,813
We decided a potential search destination would be a nav

570
00:31:57,853 --> 00:32:00,035
mesh position of a DSM cell.

571
00:32:02,269 --> 00:32:04,810
Thus, we just need to score each cell and which

572
00:32:04,850 --> 00:32:05,450
will be the best one.

573
00:32:05,870 --> 00:32:06,410
Simple, right?

574
00:32:06,990 --> 00:32:10,111
To drive this scoring, we use a specific data layer we call

575
00:32:10,131 --> 00:32:11,611
search influence layer.

576
00:32:12,492 --> 00:32:16,153
Its value is used as a main factor for search destination

577
00:32:16,173 --> 00:32:16,493
scoring.

578
00:32:16,913 --> 00:32:19,273
Cells without influence are not even considered.

579
00:32:20,174 --> 00:32:23,154
We also use other factors to ponder this one, so that, for

580
00:32:23,234 --> 00:32:27,175
instance, NPCs are spread out enough or choose a cell that

581
00:32:27,215 --> 00:32:29,336
are not too close or too far from them, et cetera.

582
00:32:31,294 --> 00:32:33,315
Whenever something is perceived by NPC,

583
00:32:34,015 --> 00:32:37,716
influence is seeded on the layer and propagated

584
00:32:38,396 --> 00:32:40,837
among neighboring cells in all directions.

585
00:32:41,557 --> 00:32:44,898
The propagation speed is roughly the same as the player speed.

586
00:32:45,098 --> 00:32:47,158
In order to support propagation, we

587
00:32:47,198 --> 00:32:49,759
keep connectivity information between cells in the layout.

588
00:32:51,909 --> 00:32:54,691
The influence value itself is stored on 8 bits,

589
00:32:55,031 --> 00:32:58,514
using 7 bits for the value and 1 for propagation.

590
00:32:59,234 --> 00:33:01,636
Please note that when manipulating influence,

591
00:33:02,276 --> 00:33:06,479
it is converted into a floating point number between 0 and 1.

592
00:33:07,220 --> 00:33:09,641
It's more convenient for things like scoring.

593
00:33:10,842 --> 00:33:13,324
We choose to have one search layer for everyone

594
00:33:13,965 --> 00:33:16,046
so that the data is actually shared.

595
00:33:16,827 --> 00:33:19,248
And when the search is done, all the influence values

596
00:33:19,408 --> 00:33:20,289
are reset to invalid.

597
00:33:22,935 --> 00:33:28,076
NPC clean influence from cell once inspected so that it becomes less desirable.

598
00:33:28,596 --> 00:33:31,297
Cleanings mean setting the cell influence to zero.

599
00:33:32,357 --> 00:33:36,638
However, it regenerates over time up to a very low value.

600
00:33:37,019 --> 00:33:41,140
This is to avoid the search being ever finished before the end of the timer,

601
00:33:41,460 --> 00:33:43,360
or before finding the player, obviously.

602
00:33:46,954 --> 00:33:49,959
NPCs clean influence in two ways.

603
00:33:50,580 --> 00:33:53,404
In a cube of cells, we construct around the NPC location.

604
00:33:54,225 --> 00:33:56,890
And within the inner field of view,

605
00:33:57,250 --> 00:33:59,554
we rasterize the triangle on the DSM grid.

606
00:34:00,563 --> 00:34:03,565
We used the access table to retrieve the cells in each case.

607
00:34:04,546 --> 00:34:06,647
And to be sure the NPC actually sees the cell,

608
00:34:06,807 --> 00:34:09,529
we checked there is a straight line on navmesh

609
00:34:09,549 --> 00:34:11,110
from NPC to the cell center.

610
00:34:11,551 --> 00:34:13,112
So this is expensive.

611
00:34:14,332 --> 00:34:17,054
So we made sure to multithread all this properly

612
00:34:17,375 --> 00:34:19,296
and used time slice as we don't need

613
00:34:19,396 --> 00:34:20,757
instant results in that case.

614
00:34:21,317 --> 00:34:23,119
So to conclude on search,

615
00:34:23,879 --> 00:34:25,440
there is something I'd like to confess.

616
00:34:28,414 --> 00:34:31,115
Yeah, some among you probably noticed this bug

617
00:34:31,155 --> 00:34:32,076
in the previous video.

618
00:34:32,576 --> 00:34:34,597
The inference is not cleaned properly on this cell.

619
00:34:35,097 --> 00:34:37,098
That's clearly a bug, right?

620
00:34:38,919 --> 00:34:40,059
No, obviously, I'm just kidding.

621
00:34:44,021 --> 00:34:46,082
In fact, we have smart objects affecting search.

622
00:34:46,462 --> 00:34:50,104
We call them search bots, and each one is linked to a cell.

623
00:34:51,231 --> 00:34:54,392
On those, we forbid search influence cleaning until the

624
00:34:54,952 --> 00:34:57,372
smart object usage actually takes place.

625
00:34:57,912 --> 00:35:01,113
That way, the NPC will eventually go to the smart

626
00:35:01,133 --> 00:35:01,953
object and use it.

627
00:35:02,773 --> 00:35:04,714
Now we are really done with the search part.

628
00:35:05,714 --> 00:35:07,354
Let's talk about code hard facts.

629
00:35:08,394 --> 00:35:11,395
During runtime, counting the layouts or those in layer,

630
00:35:11,535 --> 00:35:15,156
access table, access tree, et cetera, what would the memory

631
00:35:15,176 --> 00:35:16,956
cost for the whole DSM system be?

632
00:35:17,076 --> 00:35:19,936
So who thinks it's less than 1 meg?

633
00:35:24,577 --> 00:35:26,338
Who thinks it's more than 5 meg?

634
00:35:29,360 --> 00:35:29,641
OK.

635
00:35:30,181 --> 00:35:33,523
So all you guys that did not raise your hand, you win.

636
00:35:38,292 --> 00:35:41,293
DSM memory consumption was profiled around 4 megabytes.

637
00:35:41,953 --> 00:35:45,274
Some years ago, there was an interview from Naughty Dog

638
00:35:45,334 --> 00:35:49,375
Folks stating that they were allowed 3 megs on Uncharted 2

639
00:35:49,796 --> 00:35:50,956
for the whole game states.

640
00:35:51,496 --> 00:35:53,617
But with current-gen consoles, guess what?

641
00:35:54,557 --> 00:35:56,217
4 megs is perfectly reasonable.

642
00:35:57,918 --> 00:36:01,019
Before concluding, let's talk about some things you want to

643
00:36:01,039 --> 00:36:02,559
watch out when using DSM.

644
00:36:03,460 --> 00:36:05,880
First thing, the big performance consumer for us

645
00:36:05,980 --> 00:36:07,641
has been cell accesses.

646
00:36:08,732 --> 00:36:11,593
This means you need to watch out for the performance

647
00:36:11,713 --> 00:36:12,693
of your hashing function,

648
00:36:13,114 --> 00:36:14,854
make sure your KD3 implementation

649
00:36:14,974 --> 00:36:17,195
generates as few cache misses as possible,

650
00:36:17,856 --> 00:36:20,377
and really, really think about the proper way

651
00:36:20,417 --> 00:36:21,817
to collect cell for each use case,

652
00:36:21,978 --> 00:36:25,099
balancing between hash table and KD3 usage.

653
00:36:26,239 --> 00:36:30,681
Second things, we can't stress enough

654
00:36:30,942 --> 00:36:34,003
that you don't want to store a four-byte float in a layer

655
00:36:34,243 --> 00:36:36,644
when all you really need is one byte.

656
00:36:36,904 --> 00:36:37,905
I guess Dave would agree.

657
00:36:39,809 --> 00:36:41,890
page three to eight in your book.

658
00:36:45,151 --> 00:36:48,572
To finish on this part, let me tell you why DSM is sexy.

659
00:36:49,192 --> 00:36:51,633
For us, the system has been a breakthrough

660
00:36:52,033 --> 00:36:54,093
as far as spatial reasoning is concerned.

661
00:36:54,753 --> 00:36:56,754
It unlocks selecting position dynamically

662
00:36:57,134 --> 00:36:59,935
when all we had was pre-placed points before,

663
00:37:00,115 --> 00:37:03,136
which we had in DSNR1 from fleet destination

664
00:37:03,516 --> 00:37:05,057
or blood vines summoned position.

665
00:37:06,343 --> 00:37:09,505
The second thing is that there are a lot of use cases for

666
00:37:09,525 --> 00:37:13,527
this system, far more than what we originally envisioned.

667
00:37:14,407 --> 00:37:15,708
And finally, try it.

668
00:37:16,548 --> 00:37:19,370
It's rather simple to implement and provided you're

669
00:37:19,410 --> 00:37:20,811
reasonable, it's affordable.

670
00:37:21,771 --> 00:37:24,453
Now let's talk about another affordable system

671
00:37:24,773 --> 00:37:25,753
coordinated by Laurent.

672
00:37:28,175 --> 00:37:28,535
Thank you.

673
00:37:29,615 --> 00:37:31,236
Thank you, Xavier.

674
00:37:31,797 --> 00:37:34,818
So now let's talk about Cruise.

675
00:37:36,133 --> 00:37:39,414
It's our way of handling NPC coordination.

676
00:37:41,614 --> 00:37:43,875
So where does this come from?

677
00:37:44,815 --> 00:37:47,636
During pre-production, we knew that we were going

678
00:37:47,696 --> 00:37:51,917
to have standard tech fitting for individual NPC behavior,

679
00:37:52,957 --> 00:37:57,198
rules, DSM, et cetera, behavior tree, knowledge system.

680
00:37:57,898 --> 00:38:00,899
But our system designers.

681
00:38:01,919 --> 00:38:04,504
also had a strong desire to push the envelope

682
00:38:05,045 --> 00:38:07,751
and implement some ambitious group behaviors.

683
00:38:09,274 --> 00:38:11,037
Designers, right?

684
00:38:13,691 --> 00:38:19,233
We knew from previous experiences that this one desire was going to be hard to satisfy.

685
00:38:19,453 --> 00:38:24,914
You can get some basic things working with inter-NPC communication, but it's hard to

686
00:38:24,954 --> 00:38:27,375
get a fully coordinated group behavior.

687
00:38:27,835 --> 00:38:32,737
There's a point where you need another approach to avoid getting trapped in a monstrous plate

688
00:38:32,777 --> 00:38:33,617
of spaghetti code.

689
00:38:37,343 --> 00:38:41,311
Even if there's already lots of literature about NPC coordination,

690
00:38:41,852 --> 00:38:44,157
we didn't find the perfect match for our desires,

691
00:38:44,237 --> 00:38:47,203
so we had to venture into uncharted territory.

692
00:38:50,293 --> 00:38:52,774
But once more the light came from a GDC talk,

693
00:38:53,454 --> 00:38:56,416
again by Mika Vekala, so thank you Mika.

694
00:38:57,716 --> 00:39:01,558
Among other things, he introduced the concept of situations,

695
00:39:01,859 --> 00:39:03,579
a technique used in Hitman Absolution.

696
00:39:04,160 --> 00:39:06,481
So again, go check this if you have any interest

697
00:39:06,521 --> 00:39:07,001
in this topic.

698
00:39:08,682 --> 00:39:12,003
Our AI crews are largely inspired by these ideas,

699
00:39:12,204 --> 00:39:16,366
so again, we feel that we did things interesting

700
00:39:16,426 --> 00:39:18,066
on our own, so let's get this.

701
00:39:20,611 --> 00:39:22,511
So, what's a crew?

702
00:39:23,111 --> 00:39:25,012
It's a group of people working together

703
00:39:25,032 --> 00:39:27,053
towards a common objective.

704
00:39:28,073 --> 00:39:30,834
Take this crew or that crew.

705
00:39:31,514 --> 00:39:33,715
And quite literally, they're in the same boat.

706
00:39:34,895 --> 00:39:37,116
Clearly, they will have to coordinate

707
00:39:37,336 --> 00:39:38,637
if they want to go anywhere.

708
00:39:38,977 --> 00:39:40,357
They have to row together.

709
00:39:42,278 --> 00:39:44,679
Although they can row together, these peoples

710
00:39:44,859 --> 00:39:46,099
are still individuals.

711
00:39:47,338 --> 00:39:50,479
Free them up, let the evening come, add some music and beverages,

712
00:39:50,599 --> 00:39:52,839
and soon you end up with this absolute mess.

713
00:39:53,480 --> 00:39:57,841
Agents making their own decisions, sometimes interacting, sometimes not.

714
00:40:00,221 --> 00:40:02,222
So in practice, what does this mean?

715
00:40:02,782 --> 00:40:04,543
Let me illustrate this with two videos

716
00:40:04,983 --> 00:40:07,483
of what we call the regular combat situation.

717
00:40:08,024 --> 00:40:10,964
Don't be afraid, that's our jargon for a bunch of guards

718
00:40:11,044 --> 00:40:12,425
directly fighting the player.

719
00:40:15,626 --> 00:40:15,986
So here.

720
00:40:17,176 --> 00:40:19,097
You can see that the NPCs are fighting,

721
00:40:20,138 --> 00:40:23,359
but things might seem a little disorganized.

722
00:40:24,680 --> 00:40:25,921
They are struggling sometimes,

723
00:40:26,761 --> 00:40:27,982
bumping into each other,

724
00:40:28,742 --> 00:40:30,563
all trying to reach the player at the same time.

725
00:40:30,603 --> 00:40:32,464
You see friendly fire going on.

726
00:40:33,965 --> 00:40:36,927
So overall, it's not very pretty.

727
00:40:39,808 --> 00:40:41,489
Now this time the crew is enabled.

728
00:40:43,180 --> 00:40:47,243
So you might notice that the guards are keeping their distances a bit more.

729
00:40:47,963 --> 00:40:52,346
The elite guard stays in the background and is actually shouting orders.

730
00:40:53,406 --> 00:40:55,988
He also uses his gun a bit more effectively.

731
00:40:56,548 --> 00:40:57,289
He used it once,

732
00:40:58,929 --> 00:41:01,731
and he's going to stay in the background and use it another time.

733
00:41:03,032 --> 00:41:05,273
So things look a little more organized.

734
00:41:06,934 --> 00:41:09,336
So what makes things different in the second video?

735
00:41:10,254 --> 00:41:13,955
There's a combat crew working behind the scene to coordinate NPCs.

736
00:41:14,775 --> 00:41:18,836
It assigns them a certain role in combat, for instance, melee fighter or ranged fighter.

737
00:41:19,576 --> 00:41:24,077
For NPCs in melee, we have a bunch of slots that pull the navmesh around the player.

738
00:41:24,737 --> 00:41:28,718
It's the crew's function to find a proper distribution across these slots.

739
00:41:29,938 --> 00:41:33,779
The crew also controls the attack rate through shared attack cooldowns.

740
00:41:34,559 --> 00:41:37,719
So we don't want the player to be completely overwhelmed, etc.

741
00:41:37,739 --> 00:41:37,779
So...

742
00:41:41,369 --> 00:41:42,269
Let's step back a bit.

743
00:41:43,230 --> 00:41:44,852
I might be stating the obvious here,

744
00:41:45,512 --> 00:41:46,714
but I want to drive this home.

745
00:41:47,474 --> 00:41:49,196
Two opposite paradigms exist.

746
00:41:49,476 --> 00:41:51,138
Two approaches to group behavior,

747
00:41:51,638 --> 00:41:53,300
top-down or bottom-up.

748
00:41:55,322 --> 00:41:57,044
The top-down approach is to have

749
00:41:57,084 --> 00:42:00,187
a central coordinating entity that takes decisions

750
00:42:01,047 --> 00:42:03,770
and gives directions, a ruling mastermind.

751
00:42:04,411 --> 00:42:06,553
This allows for predetermined group behavior.

752
00:42:08,011 --> 00:42:10,252
The bottom-up approach lets all individuals

753
00:42:10,472 --> 00:42:13,394
take their decisions, and the occasional interactions

754
00:42:13,494 --> 00:42:15,596
create an emergent group behavior.

755
00:42:15,616 --> 00:42:17,457
See, the outcome is unpredictable,

756
00:42:18,037 --> 00:42:20,719
or non-predicted, as Roxanne put it yesterday.

757
00:42:22,880 --> 00:42:25,822
So, I won't tell you that one approach

758
00:42:25,902 --> 00:42:26,983
is better than the other.

759
00:42:28,103 --> 00:42:29,784
There are pros and cons on both sides.

760
00:42:30,285 --> 00:42:33,186
So my point is, you have to find a balance

761
00:42:33,246 --> 00:42:35,348
between the two that fits the game you're making.

762
00:42:37,238 --> 00:42:39,580
So what about us and this honor too?

763
00:42:40,181 --> 00:42:43,343
In our case, we had early designs such as this one.

764
00:42:44,344 --> 00:42:46,326
So this is the kind of group behavior

765
00:42:46,586 --> 00:42:47,747
our designers envisioned.

766
00:42:48,607 --> 00:42:50,809
This one's from our combat designer, Jonathan.

767
00:42:51,810 --> 00:42:53,371
Don't worry about the details.

768
00:42:53,471 --> 00:42:55,933
Just know that this represents evolving situations

769
00:42:56,333 --> 00:42:58,695
with NPCs dynamically taking different roles

770
00:42:58,735 --> 00:43:01,197
depending on the environment and player actions.

771
00:43:01,758 --> 00:43:03,739
My point is that it's very difficult

772
00:43:03,759 --> 00:43:05,621
to implement something along those lines

773
00:43:05,781 --> 00:43:06,601
when all you have.

774
00:43:07,805 --> 00:43:10,306
is this absolute mess that is just impossible.

775
00:43:12,327 --> 00:43:15,068
So we needed a top-down approach to AI.

776
00:43:16,129 --> 00:43:18,850
We first tried a prototype of a situation system

777
00:43:18,890 --> 00:43:20,210
inspired by the Hitman talk,

778
00:43:20,870 --> 00:43:23,051
but things were very hard-coded and too rigid.

779
00:43:24,092 --> 00:43:27,933
So since what we needed was a mastermind

780
00:43:28,413 --> 00:43:29,574
taking its own decisions,

781
00:43:30,254 --> 00:43:33,495
it became obvious that what we needed was an actual AI

782
00:43:34,376 --> 00:43:34,736
instead of.

783
00:43:35,275 --> 00:43:39,598
Reinventing the wheel, we figured we could simply reuse our standard AI tech.

784
00:43:40,779 --> 00:43:45,623
Our mastermind was going to have sensors, a knowledge blackboard, and a behavior tree.

785
00:43:46,264 --> 00:43:48,486
So this is what we call a crew.

786
00:43:51,348 --> 00:43:52,569
So what's the job of a crew?

787
00:43:53,870 --> 00:43:57,654
It works like any AI, but its main interest is the members that compose it.

788
00:43:57,754 --> 00:44:01,657
So just to give you an idea, typically we're talking about two to ten members.

789
00:44:02,755 --> 00:44:04,716
When we update a crew, it first senses,

790
00:44:04,876 --> 00:44:06,596
which means that it starts by collecting

791
00:44:06,656 --> 00:44:07,977
the knowledge of each member.

792
00:44:09,077 --> 00:44:12,479
It then thinks, which means updating a behavior tree

793
00:44:12,719 --> 00:44:15,800
that decides which role to assign to which member.

794
00:44:16,921 --> 00:44:17,941
And finally, it acts.

795
00:44:18,281 --> 00:44:20,402
This mostly consists in writing directions

796
00:44:20,782 --> 00:44:22,503
in the NPC's knowledge blackboards.

797
00:44:23,103 --> 00:44:24,524
So they play their role correctly

798
00:44:24,564 --> 00:44:25,905
when it's their turn to update.

799
00:44:28,706 --> 00:44:31,147
So that's another important point.

800
00:44:31,984 --> 00:44:34,125
Individual behaviours still exist.

801
00:44:34,666 --> 00:44:38,608
NPCs use the knowledge coming from the crew as any other source of knowledge,

802
00:44:38,988 --> 00:44:40,369
for example their own sensors.

803
00:44:41,849 --> 00:44:45,591
So if you disable the crews, NPCs just act as if they were alone,

804
00:44:45,892 --> 00:44:47,212
but they are not completely shut down.

805
00:44:48,913 --> 00:44:51,294
So this is what I meant by finding a balance.

806
00:44:52,194 --> 00:44:55,455
If something good came out of the early 2000s craze

807
00:44:55,475 --> 00:44:56,835
of object-oriented programming,

808
00:44:57,436 --> 00:45:01,757
it's the single responsibility principle.

809
00:45:03,277 --> 00:45:04,517
On one side of the balance,

810
00:45:05,018 --> 00:45:08,138
crews should be responsible for the coordination only.

811
00:45:08,979 --> 00:45:11,659
As soon as the coordination logic starts to smell,

812
00:45:12,059 --> 00:45:13,580
as soon as the coordination logic

813
00:45:13,600 --> 00:45:15,300
starts to drive the NPCs directly,

814
00:45:15,380 --> 00:45:16,321
things start to smell.

815
00:45:16,821 --> 00:45:17,541
Sorry about that.

816
00:45:18,221 --> 00:45:19,401
On the other side of the balance,

817
00:45:20,386 --> 00:45:22,808
The individual behavior logic should always work

818
00:45:22,968 --> 00:45:24,510
on a single NPC.

819
00:45:25,510 --> 00:45:27,392
As soon as it tries to perform coordination,

820
00:45:27,472 --> 00:45:28,253
it becomes a mess.

821
00:45:29,153 --> 00:45:31,636
So our rule of thumb is that we try to avoid

822
00:45:31,756 --> 00:45:34,018
using any crew logic when a behavior

823
00:45:34,098 --> 00:45:36,600
involves only one and only one NPC.

824
00:45:38,742 --> 00:45:41,624
Now you might wonder, how do we group NPCs together?

825
00:45:43,285 --> 00:45:44,867
We use a very basic request system.

826
00:45:45,722 --> 00:45:49,685
NPCs can emit a request to join a crew directly from their behavior tree.

827
00:45:50,125 --> 00:45:54,708
We also have crews controlled by the level designers, so they can create crew requests

828
00:45:54,868 --> 00:45:56,970
from our in-house visual scripting tool.

829
00:45:58,371 --> 00:46:01,073
This request is made of an objective and a target.

830
00:46:01,473 --> 00:46:03,374
For instance, fight the player.

831
00:46:05,296 --> 00:46:09,939
So just to show you what it looks like, this is a part of our individual combat behavior

832
00:46:09,979 --> 00:46:10,179
tree.

833
00:46:10,520 --> 00:46:14,703
The highlighted node at the tree root is what posts a request to join a crew.

834
00:46:16,188 --> 00:46:17,309
a combat crew in this case.

835
00:46:19,010 --> 00:46:22,091
At any given time, we sort requests by priority

836
00:46:22,772 --> 00:46:25,313
and all NPCs sharing the same objective and target

837
00:46:25,333 --> 00:46:27,354
simply become members of the same crew.

838
00:46:28,194 --> 00:46:30,995
So we allow an NPC to be part of only one crew.

839
00:46:31,896 --> 00:46:33,877
This is both simple and dynamic

840
00:46:33,937 --> 00:46:36,158
and avoids putting too much complexity

841
00:46:36,318 --> 00:46:37,718
at such a very high level.

842
00:46:39,379 --> 00:46:41,080
Now that we grouped NPCs together,

843
00:46:41,860 --> 00:46:44,301
let's see an illustration of group behavior.

844
00:46:45,888 --> 00:46:48,790
This is the crew behavior tree for regular combat.

845
00:46:49,330 --> 00:46:51,872
This is what drives the coordinated combat video

846
00:46:51,952 --> 00:46:52,712
I've shown earlier.

847
00:46:53,833 --> 00:46:54,814
It's nothing fancy.

848
00:46:55,314 --> 00:46:59,056
You see two branches, one for the roles assigned to NPCs

849
00:46:59,096 --> 00:47:01,858
currently engaging the player, and another one

850
00:47:01,918 --> 00:47:04,139
for NPCs currently chasing the player.

851
00:47:05,140 --> 00:47:07,621
So this is just a definition of what

852
00:47:07,781 --> 00:47:10,083
roles are available for this part of combat.

853
00:47:11,343 --> 00:47:14,345
But that's only one part of the crew combat behavior.

854
00:47:16,078 --> 00:47:17,840
Here's what you get if you zoom out a bit.

855
00:47:18,461 --> 00:47:19,181
The big picture.

856
00:47:20,243 --> 00:47:23,006
As you can see, there's more than regular combat.

857
00:47:23,486 --> 00:47:26,970
Under certain conditions, the crew behavior tree changes

858
00:47:27,131 --> 00:47:28,953
and roles are assigned differently.

859
00:47:30,054 --> 00:47:33,218
So now, let me focus on the part labeled far target.

860
00:47:35,535 --> 00:47:42,279
This is activated when one member of the crew notices that their path to the player is way longer than the actual distance.

861
00:47:42,900 --> 00:47:46,922
So that means that there are some pieces of the level that need to be bypassed to reach them.

862
00:47:48,623 --> 00:47:52,246
So what the crew does in this situation is that it splits the combat in two.

863
00:47:52,686 --> 00:47:57,149
A few members are sent to flank the player trying to reach the melee,

864
00:47:57,649 --> 00:48:01,512
while the others simply stay put, taunting and using ranged attacks.

865
00:48:03,868 --> 00:48:08,634
Note that we have two end conditions here, depending on what happens to the flanking NPCs.

866
00:48:09,435 --> 00:48:13,920
As soon as any of them manages to reach the player, the fire target tree is cancelled,

867
00:48:14,401 --> 00:48:19,427
and the crew switches back to regular combat, which means that more NPCs will join the melee.

868
00:48:20,088 --> 00:48:24,289
But if too much time passes, or if any one of the flankers

869
00:48:24,329 --> 00:48:27,930
gets killed, the crew marks the area around the target

870
00:48:28,491 --> 00:48:29,351
as unreachable.

871
00:48:30,051 --> 00:48:32,272
So in this case, it's deemed too dangerous

872
00:48:32,312 --> 00:48:33,692
to try flanking the player.

873
00:48:33,752 --> 00:48:35,673
So we'll just stick to ranged combat.

874
00:48:37,474 --> 00:48:40,355
So let me show you these two outcomes in video.

875
00:48:42,996 --> 00:48:44,776
Here we have a few guards.

876
00:48:45,637 --> 00:48:49,198
I'm setting up a trap, and I try to lure them into it.

877
00:48:50,723 --> 00:48:52,764
They busted me, combat starts

878
00:48:54,425 --> 00:48:56,685
and I get to a point a little bit out of reach

879
00:48:57,665 --> 00:48:59,566
so two of them are trying to flank me

880
00:49:01,427 --> 00:49:04,187
only one of them gets killed so the second one

881
00:49:04,627 --> 00:49:07,448
succeeds in reaching me and everybody comes to melee

882
00:49:09,749 --> 00:49:11,069
so I didn't set enough traps

883
00:49:11,890 --> 00:49:12,910
let me try another thing

884
00:49:15,090 --> 00:49:16,491
this time I'm putting two traps

885
00:49:19,014 --> 00:49:20,616
again trying to lure them into it

886
00:49:21,917 --> 00:49:24,220
and I get two guards killed so this time

887
00:49:26,182 --> 00:49:30,106
the remaining guards just decide it's safer to pick me from a distance

888
00:49:35,071 --> 00:49:36,493
that's it for combat crews but

889
00:49:37,614 --> 00:49:38,455
wait there's more

890
00:49:39,456 --> 00:49:40,717
we do use crews for more stuff

891
00:49:41,698 --> 00:49:46,942
Everything I've shown so far is completely systemic, level independent, it can trigger

892
00:49:47,122 --> 00:49:48,283
anywhere in the game.

893
00:49:48,523 --> 00:49:54,387
But we also wanted to try to use screws for ambushes and to let level designers set them

894
00:49:54,447 --> 00:49:54,547
up.

895
00:49:55,907 --> 00:50:00,570
There were a few cases in the first Dishonored where scripted ambushes were messing up with

896
00:50:00,590 --> 00:50:03,652
the systemic AI, so this was an attempt to fix it.

897
00:50:04,293 --> 00:50:09,956
In Dishonored 2, level designers can create an ambush crew from script, start and stop

898
00:50:09,996 --> 00:50:10,677
it as they want.

899
00:50:11,534 --> 00:50:14,636
On top of this, they manage the triggers and volumes

900
00:50:14,756 --> 00:50:16,177
that define the ambush area.

901
00:50:17,778 --> 00:50:20,421
They also place spots that NPCs use for positioning.

902
00:50:22,642 --> 00:50:25,425
Yet another case of coordinated behavior is search.

903
00:50:26,325 --> 00:50:28,847
We use the crew to determine number of NPCs

904
00:50:28,927 --> 00:50:30,088
just searching actively.

905
00:50:30,188 --> 00:50:33,211
In some cases, we even allow only one of them to search.

906
00:50:34,172 --> 00:50:36,273
There are also more evolved coordinated behavior

907
00:50:36,293 --> 00:50:38,635
that may trigger when guards discover a dead body.

908
00:50:39,455 --> 00:50:41,796
They first gather around the corpses.

909
00:50:42,056 --> 00:50:45,638
One of them will shout a few orders, and they'll split up in search for the culprit.

910
00:50:46,198 --> 00:50:50,440
If they fail in finding anything, they'll gather around again to debrief the situation

911
00:50:50,480 --> 00:50:51,720
before falling back to patrol.

912
00:50:52,460 --> 00:50:56,802
So these phases are also handled by the crew behavior tree.

913
00:50:58,963 --> 00:51:02,224
So before I close this, I just wanna show you

914
00:51:02,284 --> 00:51:03,604
two pitfalls of this system.

915
00:51:03,724 --> 00:51:07,605
The first one is how to handle behavior trees interactions.

916
00:51:08,005 --> 00:51:10,666
I'm talking about how to control the execution flow

917
00:51:10,846 --> 00:51:13,467
between the individual and the crew behavior trees.

918
00:51:14,127 --> 00:51:17,188
For instance, you often wanna know if some part

919
00:51:17,228 --> 00:51:19,528
of an individual behavior is done executing

920
00:51:19,928 --> 00:51:23,009
before you switch to a new stage of group behavior.

921
00:51:24,278 --> 00:51:26,559
We needed some kind of notification for that.

922
00:51:26,979 --> 00:51:29,760
So we implemented a simple dictionary that is readable

923
00:51:30,160 --> 00:51:31,581
and writable from both sides

924
00:51:31,741 --> 00:51:33,762
and is stored in crew knowledge.

925
00:51:34,482 --> 00:51:35,362
So this did the trick.

926
00:51:37,203 --> 00:51:39,784
The second pitfall is how do you organize

927
00:51:39,844 --> 00:51:41,144
the updates in the game loop?

928
00:51:42,465 --> 00:51:46,206
Crews depend on NPCs and NPCs depend on their crew.

929
00:51:46,586 --> 00:51:49,227
So that's a bit of a chicken and egg problem.

930
00:51:50,016 --> 00:51:52,497
it's important to keep a clean separation

931
00:51:52,998 --> 00:51:55,439
between the individual level and the collective level

932
00:51:55,719 --> 00:51:56,439
in the game loop.

933
00:51:57,200 --> 00:52:00,061
So, our solution isn't very interesting

934
00:52:00,381 --> 00:52:02,002
since it's implementation dependent

935
00:52:02,182 --> 00:52:03,803
and changed a lot over time.

936
00:52:04,203 --> 00:52:05,684
But please note that this is something

937
00:52:05,704 --> 00:52:07,725
that requires some thoughts to get right.

938
00:52:10,087 --> 00:52:12,868
So clearly, this is just baby steps

939
00:52:13,108 --> 00:52:15,309
and we need to improve our implementation.

940
00:52:16,738 --> 00:52:18,919
One thing is I wish we exposed more things

941
00:52:19,019 --> 00:52:20,280
in the crew behavior tree.

942
00:52:20,340 --> 00:52:22,781
For instance, the conditions for assigning a role

943
00:52:22,821 --> 00:52:24,581
to a given NPC could be defined in it.

944
00:52:25,282 --> 00:52:27,843
But for now, they're all written directly in C++ code.

945
00:52:28,683 --> 00:52:30,244
Same for the execution of roles.

946
00:52:31,524 --> 00:52:33,265
Something else we didn't implement

947
00:52:33,505 --> 00:52:35,185
is the gathering of crew members

948
00:52:35,245 --> 00:52:38,247
using some kind of psychic slash radio attraction.

949
00:52:39,047 --> 00:52:42,628
Could be used notably for coordinated distraction in patrol,

950
00:52:42,708 --> 00:52:44,509
but this remained at the ideal level.

951
00:52:45,532 --> 00:52:48,493
And last but not least, this almost goes without saying,

952
00:52:48,893 --> 00:52:52,254
but again, NPC coordination is something very abstract

953
00:52:52,334 --> 00:52:54,355
and requires good tools for debugging.

954
00:52:55,035 --> 00:52:57,236
Ours were pretty rough, so that's something

955
00:52:57,276 --> 00:52:58,737
we'll have to improve in the future.

956
00:53:00,897 --> 00:53:02,518
So here are my last words.

957
00:53:03,438 --> 00:53:04,179
Crews are sexy.

958
00:53:05,639 --> 00:53:08,620
We use them as a machete to clear the uncharted territory

959
00:53:08,640 --> 00:53:09,781
of NPC coordination.

960
00:53:10,605 --> 00:53:13,306
They allow us to separate the coordination logic

961
00:53:13,646 --> 00:53:15,407
from the individual behavior.

962
00:53:16,668 --> 00:53:20,350
Using behavior trees gives a visual representation

963
00:53:20,450 --> 00:53:22,351
of the flow of group behaviors,

964
00:53:22,851 --> 00:53:25,332
which is something very precious during development.

965
00:53:26,173 --> 00:53:30,635
So, I wish we will find more use cases

966
00:53:30,695 --> 00:53:31,816
for this in the future.

967
00:53:31,836 --> 00:53:33,997
Time to wrap up, Xavier.

968
00:53:36,342 --> 00:53:36,902
Thanks, Laurent.

969
00:53:37,262 --> 00:53:39,603
So here are some parting thoughts

970
00:53:39,643 --> 00:53:41,183
before we dissolve our crew.

971
00:53:43,744 --> 00:53:46,845
Implementing this on a true AI was quite the ride.

972
00:53:47,445 --> 00:53:50,146
Even while being very conservative and prudent,

973
00:53:50,266 --> 00:53:52,887
sometimes the good old keep it simple principle

974
00:53:53,287 --> 00:53:55,407
just does not cut it anymore in front

975
00:53:55,427 --> 00:53:57,608
of the whole of systems interacting together.

976
00:53:58,448 --> 00:54:01,209
That's why we had to commit to put muscular systems

977
00:54:01,489 --> 00:54:02,329
behind simulation.

978
00:54:04,256 --> 00:54:07,138
It is interesting to observe that the systems we did the

979
00:54:07,198 --> 00:54:10,980
most research on were the ones that needed fewer changes

980
00:54:11,200 --> 00:54:12,381
over the course of the production.

981
00:54:13,181 --> 00:54:16,243
Whereas systems that grew more organically tend to be the

982
00:54:16,343 --> 00:54:18,124
ones that really need refactoring.

983
00:54:19,084 --> 00:54:21,405
Obviously, this is not possible to write technical

984
00:54:21,445 --> 00:54:22,446
documents for everything.

985
00:54:22,946 --> 00:54:26,208
Sometimes you just don't have enough visibility up front.

986
00:54:26,608 --> 00:54:30,090
But when you get the chance, take the opportunity to stop

987
00:54:30,110 --> 00:54:31,411
coding and start writing.

988
00:54:33,197 --> 00:54:35,799
AI is really about pushing proper content

989
00:54:35,839 --> 00:54:38,502
toward the player when it makes the most sense.

990
00:54:39,222 --> 00:54:42,745
Given the amount of assets modern games have to manage,

991
00:54:42,765 --> 00:54:45,988
a data-driven way to select those moments and the content

992
00:54:46,188 --> 00:54:49,471
is absolutely crucial to maintain a decent iteration

993
00:54:50,132 --> 00:54:50,312
rate.

994
00:54:50,592 --> 00:54:52,874
That's exactly what the rule system does for us.

995
00:54:54,439 --> 00:54:57,442
And coordination, it's a hard topic.

996
00:54:58,102 --> 00:55:01,386
Hard to design and implement, hard to debug and maintain.

997
00:55:01,866 --> 00:55:04,869
So more often than not, games choose to fake it.

998
00:55:05,710 --> 00:55:10,535
Since the Last 4 Dead 3 AI director, there has been a

999
00:55:10,575 --> 00:55:14,459
general trend of using some kind of master AI to drive

1000
00:55:14,499 --> 00:55:17,622
something else than just individual NPC behaviors.

1001
00:55:19,087 --> 00:55:22,208
Our experience with Cruise convinced us that a top level

1002
00:55:22,528 --> 00:55:25,590
AI making suggestions to individual NPCs strike the

1003
00:55:25,630 --> 00:55:27,831
correct balance in order to achieve elaborate

1004
00:55:27,871 --> 00:55:29,272
coordinator behaviors.

1005
00:55:30,552 --> 00:55:34,394
And lastly, we used what would seem an astronomic amount of

1006
00:55:34,514 --> 00:55:35,695
memory in DSM.

1007
00:55:36,375 --> 00:55:39,397
Likewise, creating a domain-specific language, like

1008
00:55:39,437 --> 00:55:42,498
the rule system, can be scary in terms of hardware and

1009
00:55:42,538 --> 00:55:43,499
resource management.

1010
00:55:44,626 --> 00:55:52,569
However, costs that were prohibitive on a last generation console can now be totally reasonable.

1011
00:55:53,259 --> 00:55:57,382
But people habits tend to change lower than hardware,

1012
00:55:58,123 --> 00:56:01,526
which means that if you are working on current gen, you

1013
00:56:01,586 --> 00:56:04,689
really, really should try and have your lead allow you to

1014
00:56:04,869 --> 00:56:06,071
use those extra resources.

1015
00:56:06,691 --> 00:56:08,112
Please, use those megs.

1016
00:56:08,613 --> 00:56:09,934
Use the CPU cycle.

1017
00:56:10,354 --> 00:56:14,118
Just use them so we can play cooler games with even cooler

1018
00:56:14,238 --> 00:56:14,558
AI in it.

1019
00:56:15,479 --> 00:56:15,720
Thank you.

1020
00:56:23,148 --> 00:56:24,329
Thank you for listening.

1021
00:56:24,530 --> 00:56:27,732
So it is my duty to tell you that we are hiring.

1022
00:56:27,752 --> 00:56:31,516
Yeah, I'll just say Rob Ishtar is in the background.

1023
00:56:31,536 --> 00:56:32,216
Yeah, Rob is here.

1024
00:56:32,437 --> 00:56:35,819
He's our global hiring guy at ZeniMax.

1025
00:56:35,859 --> 00:56:38,342
So if you have some questions about this,

1026
00:56:38,542 --> 00:56:39,783
just go see him after the talk.

1027
00:56:39,843 --> 00:56:39,923
OK.

1028
00:56:40,283 --> 00:56:43,006
No, I think we have three minutes for questions.

1029
00:56:43,126 --> 00:56:43,506
That's right.

1030
00:56:43,926 --> 00:56:44,667
So over there.

1031
00:56:45,047 --> 00:56:45,608
Good morning.

1032
00:56:46,148 --> 00:56:48,190
I was wondering, are the crews dynamic at all?

1033
00:56:48,230 --> 00:56:51,213
Do you add and remove MVCs or spread them around?

1034
00:56:52,189 --> 00:56:53,569
You're talking about the crews, right?

1035
00:56:53,609 --> 00:56:53,869
Yes.

1036
00:56:54,829 --> 00:56:56,550
How do we dynamically remove NPCs?

1037
00:56:56,730 --> 00:56:58,390
Or just are they dynamic at all?

1038
00:56:58,470 --> 00:56:59,950
Do NPCs kind of like join you?

1039
00:56:59,970 --> 00:57:01,091
They are dynamic.

1040
00:57:01,191 --> 00:57:02,311
They are completely dynamic.

1041
00:57:02,611 --> 00:57:05,652
As I said, it's the individual behavior that posts a request.

1042
00:57:06,012 --> 00:57:07,852
So basically, I'm currently searching.

1043
00:57:08,412 --> 00:57:10,893
Find me another NPC currently searching.

1044
00:57:11,073 --> 00:57:13,174
And if there's somebody, let's group them.

1045
00:57:13,654 --> 00:57:14,674
So it's completely dynamic.

1046
00:57:14,714 --> 00:57:18,095
They just enter and exit the crew as they need.

1047
00:57:18,115 --> 00:57:18,735
Awesome.

1048
00:57:18,955 --> 00:57:19,175
Merci.

1049
00:57:20,898 --> 00:57:25,701
Hi, I'm Sergei from Remedy. I have a question about the rule system.

1050
00:57:26,122 --> 00:57:30,604
I'm wondering, because you guys are using behavior trees and the rule system on top of that,

1051
00:57:30,885 --> 00:57:33,846
so how do you make the rule system communicate with the behavior trees?

1052
00:57:33,926 --> 00:57:38,229
How do you decide which part of the behavior is going to be in the rule system,

1053
00:57:38,289 --> 00:57:39,770
which part is going to be in the behavior tree?

1054
00:57:39,850 --> 00:57:41,731
Because they're interchangeable, essentially.

1055
00:57:42,212 --> 00:57:44,473
It's... Good question.

1056
00:57:47,576 --> 00:57:51,760
The rule system does not really coordinate with behavior trees.

1057
00:57:52,581 --> 00:57:57,446
What behavior tree does is like saying, okay, it is time to play a bark, and then that will

1058
00:57:57,546 --> 00:58:02,171
fire an evaluation and using rules to select the bark that is played.

1059
00:58:03,873 --> 00:58:06,134
Likewise, the behavior tweak could say,

1060
00:58:06,214 --> 00:58:07,255
it is time to play an attack,

1061
00:58:07,595 --> 00:58:10,177
and then rules are evaluated, giving some context,

1062
00:58:10,738 --> 00:58:13,260
and say, okay, this is the attack that is selected.

1063
00:58:13,280 --> 00:58:15,101
man 2 in audience So basically, the rule system

1064
00:58:15,181 --> 00:58:16,762
is just for the barks, essentially.

1065
00:58:16,802 --> 00:58:18,724
Nothing else. You don't use it for anything else.

1066
00:58:19,364 --> 00:58:21,826
So I think you mentioned all the use cases, but...

1067
00:58:22,667 --> 00:58:23,247
I didn't get that.

1068
00:58:23,307 --> 00:58:24,328
You said the rule system was?

1069
00:58:24,688 --> 00:58:26,089
Was it like only for the barks?

1070
00:58:26,289 --> 00:58:26,630
Or like?

1071
00:58:26,670 --> 00:58:26,970
Oh, no, no.

1072
00:58:26,990 --> 00:58:28,111
It's for more than that.

1073
00:58:28,411 --> 00:58:29,051
Much more than that.

1074
00:58:29,472 --> 00:58:31,293
We use it for triggering animations,

1075
00:58:31,353 --> 00:58:34,595
like attacks in combat, or idle breaks,

1076
00:58:34,716 --> 00:58:36,577
what we call idle breaks, or idle animations.

1077
00:58:37,538 --> 00:58:39,959
Greetings, you can see NPCs greeting each other.

1078
00:58:40,500 --> 00:58:42,041
All this is triggered by rules.

1079
00:58:42,221 --> 00:58:42,742
OK.

1080
00:58:42,982 --> 00:58:43,222
Thank you.

1081
00:58:44,002 --> 00:58:44,923
One more question.

1082
00:58:44,983 --> 00:58:45,564
One more question.

1083
00:58:45,724 --> 00:58:46,024
On the right?

1084
00:58:46,744 --> 00:58:48,406
Okay, great talk by the way.

1085
00:58:48,446 --> 00:58:49,227
Loved it.

1086
00:58:49,907 --> 00:58:52,230
How did you sort your rules?

1087
00:58:52,250 --> 00:58:54,612
Because you showed some rules that were evaluating in order.

1088
00:58:55,153 --> 00:58:55,553
How did we-

1089
00:58:55,593 --> 00:58:58,176
Dynamic or was the designers control that,

1090
00:58:58,336 --> 00:59:00,137
the order of the rules that were evaluated?

1091
00:59:00,278 --> 00:59:01,539
How do we sort the rules?

1092
00:59:01,619 --> 00:59:02,740
Sort, order them.

1093
00:59:02,960 --> 00:59:03,341
Sort them.

1094
00:59:03,381 --> 00:59:05,583
What order did you process them in?

1095
00:59:06,043 --> 00:59:08,306
Yeah, well we sort them at compa-

1096
00:59:08,526 --> 00:59:09,367
No, sorry, sort.

1097
00:59:10,148 --> 00:59:14,310
As in which order did you go through the rules trying to evaluate the conditions?

1098
00:59:15,390 --> 00:59:17,451
We just go from top to bottom.

1099
00:59:17,551 --> 00:59:18,671
And that's designer driven?

1100
00:59:18,971 --> 00:59:19,751
Yeah, as you want.

1101
00:59:19,771 --> 00:59:20,692
The designers write them in?

1102
00:59:20,732 --> 00:59:20,892
Yeah.

1103
00:59:21,212 --> 00:59:25,973
But what with lots of complex sort of conditions in there, wouldn't they sometimes the one

1104
00:59:25,993 --> 00:59:28,154
that they'd written last was much more relevant?

1105
00:59:28,814 --> 00:59:29,855
I don't get that, excuse me.

1106
00:59:31,236 --> 00:59:37,080
If you've written three rules, they might all be just written sort of in isolation to

1107
00:59:37,120 --> 00:59:40,923
say if the conditions are this, do this, if the conditions are this, do this.

1108
00:59:41,763 --> 00:59:47,247
But it strikes me that as the game is playing, a third option, for example, might be more

1109
00:59:47,407 --> 00:59:50,789
relevant to that, to the NPC who's trying to act.

1110
00:59:51,250 --> 00:59:54,493
We're not dynamically sorting rules, if that's your question.

1111
00:59:54,533 --> 00:59:55,114
Yeah, it is.

1112
00:59:55,194 --> 00:59:59,278
So it's the conditions that should be written in a way

1113
00:59:59,359 --> 01:00:04,564
that the context gives us the right rule at the right moment.

1114
01:00:04,824 --> 01:00:06,887
We're never sorting rule at runtime,

1115
01:00:07,067 --> 01:00:08,608
just during initialization.

1116
01:00:10,038 --> 01:00:12,280
As I said, we have some kind of cool down system.

1117
01:00:12,320 --> 01:00:13,901
So we sometimes filter rules.

1118
01:00:14,001 --> 01:00:15,462
If they were previously selected,

1119
01:00:15,562 --> 01:00:17,884
they won't be selected for a short amount of time,

1120
01:00:17,944 --> 01:00:18,644
like for attacks.

1121
01:00:19,284 --> 01:00:21,486
We don't want the same attack to be triggered twice in a row.

