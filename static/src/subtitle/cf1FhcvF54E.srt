1
00:00:12,091 --> 00:00:17,656
This talk is Building Zeta Halo, and it's about how we scaled up our content creation

2
00:00:17,756 --> 00:00:22,341
tools, workflows, and best practices to build the largest halo ever.

3
00:00:23,261 --> 00:00:24,683
My name is Kurt Digert.

4
00:00:24,843 --> 00:00:26,404
My pronouns are he, him.

5
00:00:26,805 --> 00:00:28,786
I'm lead environment technical artist at 343.

6
00:00:30,368 --> 00:00:32,849
And my name is Mikael Nelfors, pronouns he, him,

7
00:00:33,089 --> 00:00:35,689
and I'm a technical art director at 343 Industries.

8
00:00:37,850 --> 00:00:39,530
Yeah, so first I'll walk you through

9
00:00:40,010 --> 00:00:41,250
what we're gonna talk about today.

10
00:00:41,350 --> 00:00:43,231
First, we'll go over a bit of history,

11
00:00:44,251 --> 00:00:46,831
both the cultural and technological history of 343,

12
00:00:47,432 --> 00:00:50,172
so you can see a bit about where we're coming from.

13
00:00:50,892 --> 00:00:51,732
Then I'll talk about,

14
00:00:51,752 --> 00:00:55,593
or we'll talk about what our goals were for Halo Infinite.

15
00:00:56,313 --> 00:00:57,893
Then we'll talk through a few of the things

16
00:00:58,628 --> 00:01:12,237
We built to achieve those goals. We'll talk about the mass painter system, the terrain system. We'll talk about the HLOD system. We'll talk about a few procedural content creation tools and workflows that we developed.

17
00:01:13,278 --> 00:01:19,902
And finally, we'll go through our content scalability system. So first I'll hand off to Michael to talk you through the history.

18
00:01:21,743 --> 00:01:25,144
Yeah, so as some of you guys might know,

19
00:01:25,184 --> 00:01:27,845
343 industry was started by Microsoft back in 2007

20
00:01:28,185 --> 00:01:30,206
to take over Halo production from Bungie.

21
00:01:30,946 --> 00:01:37,827
And Halo Infinite is the fourth of the studio's Halo FPS games.

22
00:01:38,448 --> 00:01:40,848
And if we look at the campaign, specifically

23
00:01:40,888 --> 00:01:42,829
about campaign in the previous Halo games,

24
00:01:42,909 --> 00:01:44,309
they've all been very linear.

25
00:01:44,989 --> 00:01:46,511
unique and handcrafted.

26
00:01:46,531 --> 00:01:48,832
They used very specialized workflows

27
00:01:48,873 --> 00:01:50,914
that were destructible and time-consuming.

28
00:01:51,395 --> 00:01:53,836
For example, there was no terrain system to speak of

29
00:01:54,017 --> 00:01:57,059
or really any procedural techniques to fill out the world.

30
00:01:57,399 --> 00:01:59,941
And they only really targeted one single platform.

31
00:02:00,482 --> 00:02:02,804
So when we started talking about Halo Infinite

32
00:02:02,844 --> 00:02:03,824
and what we needed to do,

33
00:02:03,985 --> 00:02:06,386
we quickly realized that this was not scalable.

34
00:02:08,142 --> 00:02:13,944
So some of the goals we set out for ourselves when we started planning for this was we knew we had

35
00:02:13,964 --> 00:02:19,425
to support large open playable spaces. That meant we had to improve our iteration speed and stability

36
00:02:20,266 --> 00:02:25,327
which meant that we wanted to invest in modular workflows so we could fill the world with more

37
00:02:25,367 --> 00:02:30,248
variety. Procedural workflows so we could make more content than ever before.

38
00:02:30,929 --> 00:02:36,259
and non-destructive so we could make it faster. And this time around, we were going to have to

39
00:02:36,299 --> 00:02:40,727
be multi-platform. We were no longer on a single platform. We had to support

40
00:02:41,747 --> 00:02:48,410
nine-year-old hardware with the Xbox One up until the high-end PC. You will hear us talk a little

41
00:02:48,430 --> 00:02:54,813
bit later in the talk where we refer to low spec, that is, we mean Xbox One and low-end PC, and when

42
00:02:54,833 --> 00:03:00,816
we say ultra spec, that's a high-end PC. And to give you an idea of kind of what challenge we,

43
00:03:01,216 --> 00:03:02,857
how big of a challenge we had here,

44
00:03:03,627 --> 00:03:07,648
On the left side here, you can see a top down of all our campaign levels for Halo 5.

45
00:03:08,369 --> 00:03:12,390
And on the right side, you can see the main campaign island we had.

46
00:03:13,770 --> 00:03:18,612
And if you would add these Halo 5 levels on top of the campaign island, it covers about 10%.

47
00:03:19,752 --> 00:03:24,174
So we really had to do something to be able to fill this world with enough content.

48
00:03:24,834 --> 00:03:27,655
So now I'm going to hand off to Kurt, that's going to talk about

49
00:03:27,675 --> 00:03:31,496
the first of those improvements that we spent time on.

50
00:03:34,530 --> 00:03:37,852
Yeah, so first I'll talk about the mask painter system.

51
00:03:38,713 --> 00:03:42,055
So as Michael mentioned, we invested in modular workflows

52
00:03:42,135 --> 00:03:43,336
for Halo Infinite.

53
00:03:43,816 --> 00:03:46,097
The example here is a wall that's

54
00:03:46,158 --> 00:03:48,659
built out of different configurations

55
00:03:48,759 --> 00:03:51,401
from the same set of modular pieces.

56
00:03:52,142 --> 00:03:53,863
So one of the goals of the mask paint system

57
00:03:53,903 --> 00:03:56,504
was to help us tie those together visually,

58
00:03:56,945 --> 00:03:59,086
for example, by painting a rust streak that runs

59
00:03:59,166 --> 00:04:01,007
across multiple modular pieces.

60
00:04:03,153 --> 00:04:05,614
But we also wanted the mass painter system

61
00:04:05,654 --> 00:04:09,716
to be able to create the illusion of more variety

62
00:04:10,077 --> 00:04:14,379
by being able to paint different variations

63
00:04:14,619 --> 00:04:16,620
of our non-modular pieces.

64
00:04:18,461 --> 00:04:20,202
We knew we wanted the mass painter to be,

65
00:04:20,422 --> 00:04:21,603
what you see is what you get.

66
00:04:22,983 --> 00:04:25,405
We wanted to be able to paint on the actual assets

67
00:04:25,545 --> 00:04:28,867
and the actual levels and the actual lighting situations

68
00:04:29,427 --> 00:04:31,148
and see the material update in real time.

69
00:04:32,211 --> 00:04:34,773
which was about improving our iteration time.

70
00:04:35,854 --> 00:04:37,355
We also wanted the mass paint system

71
00:04:37,435 --> 00:04:39,677
to be non-destructive and art directable,

72
00:04:41,178 --> 00:04:43,079
again, to help us to iterate quickly.

73
00:04:44,780 --> 00:04:46,722
One interesting goal of the mass paint system

74
00:04:46,902 --> 00:04:48,803
is we didn't want to introduce

75
00:04:48,883 --> 00:04:50,684
any additional popping with it.

76
00:04:51,465 --> 00:04:53,526
And finally, we needed it to be affordable,

77
00:04:53,586 --> 00:04:56,749
both in terms of memory and runtime performance.

78
00:04:59,387 --> 00:05:08,734
So the design of the mass paint system. One of the first decisions we made was to go with texture based masks, rather than vertex colors to drive the material blends.

79
00:05:09,994 --> 00:05:25,606
One of the main reasons for that was vertex color based material blending systems, you can get pops between the geolots. The shape of a rust patch, for example, can shift by a surprising amount in between geolots.

80
00:05:27,688 --> 00:05:28,628
So as soon as we

81
00:05:29,708 --> 00:05:31,429
decided to go with texture based masks,

82
00:05:31,849 --> 00:05:33,931
we knew that memory was going to be something

83
00:05:34,111 --> 00:05:36,132
we're going to have to keep an eye on.

84
00:05:36,272 --> 00:05:38,313
So we built a lot of features into the system

85
00:05:38,374 --> 00:05:39,694
to keep that under control.

86
00:05:40,815 --> 00:05:42,997
The artists specify the resolution

87
00:05:43,037 --> 00:05:44,157
of each mask they paint.

88
00:05:44,598 --> 00:05:46,099
They usually pick 64 or 128.

89
00:05:46,439 --> 00:05:51,102
We also built tools to audit that content afterwards

90
00:05:51,162 --> 00:05:53,924
to catch the few giant masks

91
00:05:54,024 --> 00:05:55,705
that inevitably slipped through the cracks.

92
00:05:57,872 --> 00:06:00,975
Also, we didn't want to mask paint unique masks

93
00:06:01,135 --> 00:06:02,936
onto every placement of every asset.

94
00:06:02,996 --> 00:06:04,978
We sort of only wanted to paint enough

95
00:06:05,118 --> 00:06:07,360
to create the illusion that everything was unique.

96
00:06:07,540 --> 00:06:09,922
So we built some tools around setting up

97
00:06:09,962 --> 00:06:13,565
what we called variants and reusing them whenever possible

98
00:06:13,966 --> 00:06:15,747
to minimize how many masks we needed.

99
00:06:17,869 --> 00:06:20,531
So in the end, it wasn't as much memory

100
00:06:20,571 --> 00:06:23,393
as we were worried to do texture-based masks.

101
00:06:24,074 --> 00:06:25,835
It was on average in campaign about,

102
00:06:26,774 --> 00:06:32,838
60 megs worth of mass textures loaded on ultra spec and about 37 megs of mass textures on low spec.

103
00:06:34,118 --> 00:06:36,860
And our napkin math was that if we'd have done it with

104
00:06:37,200 --> 00:06:41,543
vertex colors instead of with textures, it would have been about 10 megs of additional memory.

105
00:06:45,045 --> 00:06:52,749
So the mask painting system we've built, you can go to the next slide, is it's fast, it's WYSIWYG.

106
00:06:53,495 --> 00:06:56,317
we can paint across multiple meshes simultaneously.

107
00:06:56,337 --> 00:06:59,739
Here you can see an example of using it in an actual level.

108
00:07:00,499 --> 00:07:02,100
The panel on the bottom right shows

109
00:07:02,500 --> 00:07:04,961
the names of the layers that are exposed to an artist.

110
00:07:04,981 --> 00:07:08,523
So they can paint on any number of those at the same time

111
00:07:08,623 --> 00:07:10,484
or on different meshes at the same time

112
00:07:10,504 --> 00:07:13,886
and get fast workflows.

113
00:07:14,346 --> 00:07:18,228
Over here, you can see some of our variant-oriented stuff.

114
00:07:20,267 --> 00:07:22,927
we're painting on the same mask on two different doors.

115
00:07:23,928 --> 00:07:26,129
And then we set up a new variant here

116
00:07:27,149 --> 00:07:28,529
so that that door is unique.

117
00:07:30,830 --> 00:07:31,891
Can jump to the next slide.

118
00:07:33,331 --> 00:07:36,832
So part of the mask paint system is the shader interface

119
00:07:36,872 --> 00:07:38,393
that reads those masks.

120
00:07:39,513 --> 00:07:42,274
We started out with, we had layered shaders

121
00:07:42,534 --> 00:07:44,335
on previous Halo games that sort of,

122
00:07:44,575 --> 00:07:46,796
we evolved that layered shader

123
00:07:46,856 --> 00:07:48,997
along with the mask painting system.

124
00:07:50,200 --> 00:08:05,764
But where we eventually landed is we were not tied to use a specific uber shader for all of our mask painting, we could annotate any texture in any shader is mask paintable, including in our shader node graph system. So here you can see what the interface for that looks like.

125
00:08:07,104 --> 00:08:16,446
To set up a texture sampler and a shader node graph is mask paintable and the spot where you type in the names for the layers. So that unlocked some

126
00:08:17,250 --> 00:08:18,771
cool special cases for us.

127
00:08:19,331 --> 00:08:21,972
For example, here we set up the opacity texture

128
00:08:22,032 --> 00:08:23,632
on this river is mass paintable,

129
00:08:23,672 --> 00:08:27,814
which allowed us to very quickly fine tune the blend

130
00:08:27,954 --> 00:08:30,674
between that river mesh and that waterfall mesh

131
00:08:31,775 --> 00:08:33,435
in a way that wouldn't have been possible before.

132
00:08:36,076 --> 00:08:40,618
So a little bit about the implementation of the mass paint.

133
00:08:40,658 --> 00:08:41,678
It runs in the GPU.

134
00:08:41,718 --> 00:08:44,039
It pretty much has to be as fast as it needs to be.

135
00:08:45,772 --> 00:08:47,553
Paint operation is a draw.

136
00:08:47,773 --> 00:08:48,914
It draws the mesh.

137
00:08:49,514 --> 00:08:53,876
And the vertex shader uses the mass paint UVs instead

138
00:08:53,916 --> 00:08:55,637
of the positions as the positions

139
00:08:55,757 --> 00:08:58,779
to stamp the mesh down into the mass texture.

140
00:08:59,439 --> 00:09:02,761
We also need a projection from world space

141
00:09:02,941 --> 00:09:07,423
to breaststroke space, which is calculated from the camera

142
00:09:07,463 --> 00:09:08,884
transform in the mouse position.

143
00:09:10,024 --> 00:09:12,326
We support an undo-redo step as part

144
00:09:12,346 --> 00:09:14,887
of our non-destructive workflows goal.

145
00:09:16,215 --> 00:09:19,577
The way undo is implemented is we play back,

146
00:09:20,338 --> 00:09:22,779
we go back to the beginning of the paint session

147
00:09:22,980 --> 00:09:24,861
and play back every stroke in the session

148
00:09:25,101 --> 00:09:26,102
except for the last one,

149
00:09:26,962 --> 00:09:29,384
which is another reason why the actual paint operation

150
00:09:29,424 --> 00:09:30,485
needs to be so fast.

151
00:09:31,646 --> 00:09:36,029
And the undo stack itself just stores that transform

152
00:09:36,189 --> 00:09:39,351
from world space to brushstroke space

153
00:09:40,132 --> 00:09:41,132
so that we can play it back

154
00:09:41,192 --> 00:09:42,373
when the camera is somewhere else.

155
00:09:43,807 --> 00:09:47,809
So I mentioned we use the mass paint UVs instead of the position.

156
00:09:49,750 --> 00:09:56,953
Originally, we used lightmap UVs for that because it was a unique unwrap that we had to have for a different reason that was already there.

157
00:09:57,533 --> 00:10:03,796
But partway through the development of Halo Infinite, we abandoned 2D lightmaps in favor of volumetric lightmaps.

158
00:10:03,976 --> 00:10:08,298
So at the time, the only thing we needed that UV set for was mass painting.

159
00:10:09,637 --> 00:10:18,722
So we started to optimize it to do things like enlarge the shells that we intended to paint on and shrink and overlap the shells that we didn't intend to paint on.

160
00:10:20,003 --> 00:10:22,944
But that ended up being a bit of a problem for us later on when we

161
00:10:24,745 --> 00:10:31,810
ended up needing that UV set for other things. For example, the HLOG material composite that I'll talk a bit more about later.

162
00:10:34,917 --> 00:10:36,898
So that's the mass paint system.

163
00:10:37,038 --> 00:10:39,839
Now I'll hand back to Michael to talk about the terrain system.

164
00:10:41,499 --> 00:10:45,141
Yeah, so looking back at the previous Halo games, like I mentioned,

165
00:10:45,361 --> 00:10:48,822
there was no terrain system and it was very destructible.

166
00:10:48,922 --> 00:10:52,944
So if you're looking at the terrains, they were actually just unique assets,

167
00:10:53,224 --> 00:10:54,505
nothing specific about them.

168
00:10:54,545 --> 00:10:56,946
They were generated, they were made in Maya, ZBrush.

169
00:10:57,626 --> 00:11:00,728
run through world machine and then import it as a regular object.

170
00:11:01,248 --> 00:11:03,309
They had a very limited number of material layers.

171
00:11:04,070 --> 00:11:08,272
So if you wanted to have, say, one biome with a set of materials

172
00:11:08,332 --> 00:11:10,933
in one end of a map and then another in the other side,

173
00:11:11,474 --> 00:11:13,575
you would have to do a lot of extra work.

174
00:11:14,355 --> 00:11:17,117
The masks had to be painted or generated by DCCs.

175
00:11:17,317 --> 00:11:21,859
There was no way of doing it in the level and in context and see it directly.

176
00:11:22,600 --> 00:11:24,301
And they had to be optimized by hand.

177
00:11:25,348 --> 00:11:28,110
All right, that we still used it to great effect.

178
00:11:28,811 --> 00:11:31,172
Just going to show some examples back from Halo five

179
00:11:31,792 --> 00:11:35,094
of the terrains that actually was made with this, which

180
00:11:36,015 --> 00:11:38,496
for the time worked really well, but.

181
00:11:39,547 --> 00:11:41,828
If for example, on this map, Attack on Sanctum,

182
00:11:42,368 --> 00:11:44,449
this is what the actual terrain mesh looks like.

183
00:11:45,310 --> 00:11:47,611
And it was actually split up into multiple sections

184
00:11:48,151 --> 00:11:49,652
so we could LOD it properly.

185
00:11:50,012 --> 00:11:52,414
And if you look at every single hole you see there,

186
00:11:53,094 --> 00:11:55,275
all those triangles were deleted by hand

187
00:11:55,515 --> 00:11:57,436
by an artist every iteration,

188
00:11:57,556 --> 00:12:00,318
just because they were covered by rocks or other placement.

189
00:12:01,138 --> 00:12:03,620
So to get perf back, they deleted them by hand.

190
00:12:03,640 --> 00:12:06,962
And you can see how much of a time sink this was.

191
00:12:07,082 --> 00:12:08,662
So we could not continue like this.

192
00:12:09,703 --> 00:12:16,390
So some of the goals we set out for ourselves, again, we wanted to what you see is what you get to speed up our iteration speed.

193
00:12:17,011 --> 00:12:31,726
We needed to support small to large landscapes, small like something like live fire from Halo Infinite, which is a small arena map, 120 by 120 meters, to something as large as our campaign island, which is seven and a half by seven and a half kilometers.

194
00:12:32,847 --> 00:12:38,632
it needed to support multiple users working at the same time so we don't lock up files and or areas

195
00:12:39,372 --> 00:12:44,216
and that includes being able to paint down materials, get physics material with effects

196
00:12:44,316 --> 00:12:49,319
and sound, getting ground cover generation procedurally with it and it needed to be

197
00:12:49,379 --> 00:12:56,244
non-destructive and platform scalable. So where we ended up was very inspired by Far Cry and the

198
00:12:56,344 --> 00:12:59,146
talks by Horace and Sarah Dawn and

199
00:13:00,507 --> 00:13:02,870
It's the design we went with is a tile height map.

200
00:13:03,171 --> 00:13:05,234
It is quadruple based and as the player moves around,

201
00:13:05,314 --> 00:13:07,357
tiles of appropriate size and resolution

202
00:13:07,397 --> 00:13:10,081
are generated and loaded into memory in virtual textures.

203
00:13:10,622 --> 00:13:13,106
And you can see on this, hopefully it's not

204
00:13:13,146 --> 00:13:14,608
lagging as much as for me.

205
00:13:15,349 --> 00:13:18,950
You can see on the screen here, when we're moving around the squares that are flashing by,

206
00:13:19,050 --> 00:13:22,771
is when we are requesting these new tiles to get generated and we're switching to them.

207
00:13:23,552 --> 00:13:28,553
And each of those tiles contains height, physical-based shading inputs like albedo and roughness,

208
00:13:28,673 --> 00:13:30,814
and things like wetness and micro displacement.

209
00:13:31,675 --> 00:13:39,377
And to scale performance and memory, we scale the distance of when we are generating and switching these,

210
00:13:39,898 --> 00:13:43,859
as well as how many of these virtual texture tiles that we do per frame.

211
00:13:45,566 --> 00:13:51,370
And the geometry we render at runtime for the terrain is basically just a grid of birds, one per heightmap texel.

212
00:13:51,570 --> 00:13:57,854
So the terrain geometric detail further from the camera is tied directly to the amount of heightmap data that is loaded into the virtual texture.

213
00:13:59,083 --> 00:14:03,865
That was true until we wanted to add more detail into this.

214
00:14:04,365 --> 00:14:07,627
So we added a feature we call micro-displacement.

215
00:14:08,567 --> 00:14:11,769
And we take the blended heights from our material layers

216
00:14:12,109 --> 00:14:15,270
and offset the vertex positions, basically, to get more detail.

217
00:14:15,710 --> 00:14:19,512
And we are really only subdividing our grid of verts

218
00:14:19,792 --> 00:14:20,333
even further.

219
00:14:21,274 --> 00:14:22,194
to get that detail.

220
00:14:22,234 --> 00:14:24,917
And this is something we also can control per platform.

221
00:14:25,657 --> 00:14:28,299
And even though our artists refer to this as tessellation,

222
00:14:28,459 --> 00:14:30,341
it's actually not hardware tessellation.

223
00:14:30,841 --> 00:14:33,524
It turned out that it was faster for us

224
00:14:33,564 --> 00:14:35,826
to just subdivide it further and continue

225
00:14:35,886 --> 00:14:39,288
with the kind of tech that we were using already.

226
00:14:40,710 --> 00:14:45,494
And now I'm going to take a step back and kind of look at the overall of how the terrain system works.

227
00:14:46,035 --> 00:14:52,541
These are basically the high level parts of our system, and it's really divided up into two sections.

228
00:14:52,561 --> 00:14:54,984
We have an offline section and a run time section.

229
00:14:56,444 --> 00:15:01,427
And in the offline section, everything is run really by masks.

230
00:15:01,507 --> 00:15:08,392
So we have our height maps or masks or user-created masks that are then fed into two sets of graphs.

231
00:15:08,512 --> 00:15:10,753
And we're going to talk a bit more about these graphs in a bit.

232
00:15:11,253 --> 00:15:15,156
So we have something we call a sculpting graph that controls the geometry of our terrain.

233
00:15:15,476 --> 00:15:20,800
And we have something we call the surfacing graph that controls our materials and ground cover.

234
00:15:22,277 --> 00:15:26,432
This then gets optimized for runtime, so we optimize the masks and logic.

235
00:15:26,930 --> 00:15:28,530
to get it into a format that's faster.

236
00:15:29,110 --> 00:15:32,211
And then that is what we were seeing in that video earlier,

237
00:15:32,271 --> 00:15:33,851
where we were requesting the various tiles

238
00:15:33,951 --> 00:15:36,832
and that gets generated into the virtual textures,

239
00:15:37,052 --> 00:15:40,273
as well as masks that are used for our runtime ground cover.

240
00:15:41,273 --> 00:15:43,934
And the virtual texture also goes into a random material.

241
00:15:43,974 --> 00:15:46,414
So the artist has the ability to do additional things

242
00:15:46,454 --> 00:15:48,795
that are not supported in a virtual texture per se.

243
00:15:49,195 --> 00:15:52,456
Things like if they wanted, say, sand blowing across the train

244
00:15:52,636 --> 00:15:54,896
or small ripples in water puddles,

245
00:15:54,956 --> 00:15:56,497
those kinds of things they can do in there.

246
00:15:57,688 --> 00:15:57,830
And

247
00:15:59,864 --> 00:16:03,806
we, although we did actually end up with two modes of our Terrain system.

248
00:16:04,686 --> 00:16:09,008
What I just described was our runtime version, which is a compiled HLSL.

249
00:16:10,149 --> 00:16:15,872
For edit time, we run the entire thing live. It skips the optimization step and the virtual

250
00:16:15,932 --> 00:16:21,075
texture. And this was basically because we wanted what you see is what you get. So we wanted the

251
00:16:21,115 --> 00:16:28,198
fastest possible iteration time. And we, but still needing the fast runtime. The downside with this

252
00:16:29,459 --> 00:16:35,461
turned is that we ended up with slightly divergent code paths, which has caused some issues with bugs

253
00:16:35,841 --> 00:16:42,323
with inconsistencies. And we also add a cost of compiling when we commit an edit, which can be

254
00:16:42,843 --> 00:16:47,865
get a bigger for if the level is really big. And this is something that we are looking into how we

255
00:16:47,905 --> 00:16:54,187
can improve in the future and get down to just one while still retaining the fast edit and fast

256
00:16:54,427 --> 00:16:54,847
run time.

257
00:16:56,143 --> 00:16:58,043
But now we're going to talk about the graphs.

258
00:16:58,063 --> 00:17:01,584
And I'm going to first hand off to Kurt that's going to talk about our sculpting graph.

259
00:17:04,064 --> 00:17:09,726
Yeah, so as Michael mentioned, the sculpting graph is the one that controls the geometry of the terrain.

260
00:17:10,906 --> 00:17:19,648
So originally it didn't do a whole lot except take the height maps that the artist sculpted with our sculpting tools and generate a normal map from that.

261
00:17:20,963 --> 00:17:24,225
But pretty soon we started to add a visual flare

262
00:17:24,566 --> 00:17:27,427
to the terrain that we could apply in a non-destructive way

263
00:17:27,487 --> 00:17:29,369
to that height map the artist sculpt.

264
00:17:30,910 --> 00:17:32,351
So a bit about the sculpting graph.

265
00:17:32,911 --> 00:17:36,673
It runs offline in the runtime terrain case.

266
00:17:37,374 --> 00:17:39,495
The results of the sculpting graph are saved out

267
00:17:39,575 --> 00:17:43,898
as textures on disk, but we also support the ability

268
00:17:43,958 --> 00:17:45,619
to run the sculpting graph in real time

269
00:17:45,719 --> 00:17:47,180
for our WYSIWYG edit mode.

270
00:17:48,625 --> 00:17:51,606
The sculpting graph is implemented as a render graph,

271
00:17:52,087 --> 00:17:55,328
which is basically a way that we built

272
00:17:55,788 --> 00:18:00,049
to expose the ability to do node-based graphics programming

273
00:18:00,649 --> 00:18:01,530
to content teams.

274
00:18:01,670 --> 00:18:03,190
So if you jump to the next slide,

275
00:18:03,230 --> 00:18:05,791
we can look at an example sculpting graph.

276
00:18:06,151 --> 00:18:07,091
Let me see what it does here.

277
00:18:07,151 --> 00:18:10,653
So we're doing stuff like we're getting the surface

278
00:18:10,933 --> 00:18:11,693
for the height map,

279
00:18:12,293 --> 00:18:15,174
getting the bindless index for that height map.

280
00:18:16,151 --> 00:18:21,534
We're allocating a temporary buffer here and plugging in that bindless index, putting that

281
00:18:21,694 --> 00:18:26,177
into a constant buffer and feeding it to this dispatch compute shader node here.

282
00:18:27,297 --> 00:18:33,541
So as you can imagine, this exposes a ton of power to the content teams, but it's also,

283
00:18:33,761 --> 00:18:36,523
you know, it's pretty easy to do things like cause TDRs in here.

284
00:18:37,864 --> 00:18:42,286
So we definitely had to work closely with rendering as we built these guys.

285
00:18:43,474 --> 00:18:45,035
So some of the things we built with this,

286
00:18:45,796 --> 00:18:47,817
one of the first ones was our road system.

287
00:18:49,018 --> 00:18:52,080
The way this works is the artist can place

288
00:18:52,200 --> 00:18:54,422
Bezier spline control points in the world,

289
00:18:54,882 --> 00:18:58,745
which have settings on them like width and opacity and falloff.

290
00:19:00,326 --> 00:19:02,128
Those Bezier spline control points

291
00:19:02,348 --> 00:19:06,311
are verts in a draw call in the sculpting graph, which then

292
00:19:07,095 --> 00:19:10,238
has a geometry shader stage that evaluates the spline

293
00:19:10,998 --> 00:19:12,279
and breaks it up into quads.

294
00:19:12,920 --> 00:19:16,383
It also does a blur pass along the spline

295
00:19:16,583 --> 00:19:19,025
to mitigate some of the stair-stepping artifacts

296
00:19:19,085 --> 00:19:21,187
we could get in extreme cases.

297
00:19:21,888 --> 00:19:24,210
You can see this checkerboard pattern here.

298
00:19:24,790 --> 00:19:26,291
So another thing we do in our roads,

299
00:19:27,573 --> 00:19:31,216
we can output textures from the Sculpting Graph

300
00:19:31,396 --> 00:19:32,116
other than just

301
00:19:33,103 --> 00:19:37,726
height maps that can then be, we can make an arbitrary number of inputs to the surfacing

302
00:19:37,766 --> 00:19:45,571
graph later on. So we use this to do things like make a mud material show up in these

303
00:19:45,611 --> 00:19:51,095
tire tracks in a texture that's mapped along the spline and make the high points have a

304
00:19:51,115 --> 00:19:59,580
grass texture on them. The next thing we built in the sculpt and graph was the terrain volume

305
00:19:59,900 --> 00:20:02,161
system, which conceptually is like a

306
00:20:02,917 --> 00:20:05,279
layers in Photoshop for the terrain system.

307
00:20:06,560 --> 00:20:08,021
Where this came from originally was

308
00:20:08,062 --> 00:20:11,965
we had one artist responsible for sculpting the terrain

309
00:20:12,045 --> 00:20:14,227
inside of the base that you can see here.

310
00:20:14,767 --> 00:20:17,930
And different world artists were responsible for the terrain

311
00:20:18,590 --> 00:20:20,532
that the base happens to be on top of.

312
00:20:20,632 --> 00:20:22,093
And we needed a way for all those artists

313
00:20:22,113 --> 00:20:24,475
to work at the same time without fighting to check out

314
00:20:24,515 --> 00:20:25,536
the same set of files.

315
00:20:26,717 --> 00:20:29,059
So the way terrain volumes work is in the sculpt graph,

316
00:20:29,199 --> 00:20:31,661
it's a draw call that draws a quad aligned

317
00:20:31,721 --> 00:20:32,361
with the volume.

318
00:20:33,636 --> 00:20:39,381
down into the terrain's height map and other input masks like the biome mask and the road mask.

319
00:20:40,442 --> 00:20:45,546
And there's also an opacity mask on the volume that the artist can fine-tune separately.

320
00:20:48,929 --> 00:20:56,054
Another thing we do in the sculpting graph is we made ourselves a hook so that we can go off and

321
00:20:56,094 --> 00:21:00,118
do things in Houdini that are a bit more fiddly and subject to

322
00:21:01,393 --> 00:21:04,254
iteration than our native terrain features.

323
00:21:04,734 --> 00:21:08,776
So we use this as a spot to run an erosion sim in Houdini

324
00:21:10,076 --> 00:21:11,396
and bring it back into the terrain,

325
00:21:11,436 --> 00:21:13,517
as well as what we call macro textures,

326
00:21:13,577 --> 00:21:15,418
which are things like normal maps

327
00:21:15,458 --> 00:21:16,878
that have interesting bumps in them

328
00:21:17,078 --> 00:21:19,079
and interesting color shifts in the albedo

329
00:21:19,119 --> 00:21:22,280
to just provide a little bit more breakup for that.

330
00:21:24,460 --> 00:21:26,741
Finally, another thing we do in the sculpting graph

331
00:21:26,801 --> 00:21:28,221
is we have this idea of wetness.

332
00:21:28,361 --> 00:21:28,542
So...

333
00:21:29,529 --> 00:21:35,494
The wetness is kind of like another height map that describes where the water table is.

334
00:21:37,695 --> 00:21:44,080
We use this to do things like create the appearance of mud around the edges of the

335
00:21:44,120 --> 00:21:52,546
lake instead of just dirt. So in the sculpting graph, rather than carry around another 16-bit

336
00:21:52,586 --> 00:21:56,930
height map, we compress this relative to

337
00:21:57,972 --> 00:22:00,974
where the terrain heights surfaces and write it,

338
00:22:01,354 --> 00:22:03,316
we write it into the terrain's virtual textures,

339
00:22:03,416 --> 00:22:06,598
which we can then, we can sample that later on

340
00:22:07,658 --> 00:22:08,139
from anywhere.

341
00:22:08,199 --> 00:22:10,320
For example, here you can see a rock is sampling

342
00:22:10,360 --> 00:22:12,442
into the terrain's virtual textures to decide

343
00:22:12,502 --> 00:22:16,664
where to draw that wet material change along itself.

344
00:22:18,425 --> 00:22:20,307
Yeah, so that's the sculpting graph.

345
00:22:20,467 --> 00:22:22,368
Now I'll hand back to Michael to talk a bit

346
00:22:22,408 --> 00:22:23,589
about the surfacing graph.

347
00:22:24,870 --> 00:22:26,591
Yeah, so as I mentioned earlier,

348
00:22:28,016 --> 00:22:30,538
just reiterates sculpting graph, controls to geometry,

349
00:22:30,958 --> 00:22:32,880
the surfacing graph that I'm gonna talk about now

350
00:22:33,000 --> 00:22:35,121
is the materials and ground cover on the train.

351
00:22:35,722 --> 00:22:38,324
And the surfacing graph really consists

352
00:22:38,364 --> 00:22:39,465
of three different parts.

353
00:22:40,005 --> 00:22:44,168
So you have here, what's highlighted here is the inputs,

354
00:22:44,328 --> 00:22:47,491
which are masks, and they are either masks coming

355
00:22:47,531 --> 00:22:49,913
from the sculpting graph that Kurt just mentioned,

356
00:22:50,273 --> 00:22:53,735
or they are masks that are created by the artists

357
00:22:53,755 --> 00:22:55,597
that they want to do something specific with.

358
00:22:56,197 --> 00:22:58,919
So they have control to add an arbitrary number of masks.

359
00:22:59,399 --> 00:23:02,161
Then on our right side, we have outputs.

360
00:23:02,441 --> 00:23:05,163
And the outputs are either material layers,

361
00:23:05,263 --> 00:23:07,484
which are discrete single material layers

362
00:23:07,524 --> 00:23:10,666
that has like color information, normal, height,

363
00:23:11,126 --> 00:23:14,048
and physics material, or they are placements.

364
00:23:14,528 --> 00:23:17,029
And placements are either procedurally generated

365
00:23:17,150 --> 00:23:19,751
ground cover, or we have some limited support

366
00:23:19,811 --> 00:23:21,372
also for audio and effects.

367
00:23:22,938 --> 00:23:26,061
And then in the middle, we have our node-based rule system.

368
00:23:26,361 --> 00:23:28,243
This is where the artist has full control

369
00:23:28,323 --> 00:23:30,605
to do whatever they really want with the mask

370
00:23:30,645 --> 00:23:32,387
to get the result thereafter.

371
00:23:32,427 --> 00:23:35,710
So they can combine the masks, subtract them from each other,

372
00:23:36,010 --> 00:23:36,230
kind of.

373
00:23:37,281 --> 00:23:39,202
If they want, like Kurt was mentioning,

374
00:23:39,282 --> 00:23:40,583
if you have a gradient in a mask,

375
00:23:40,603 --> 00:23:43,844
you can tell it to blend in a certain material

376
00:23:43,884 --> 00:23:45,525
in the first part of that gradient.

377
00:23:46,026 --> 00:23:49,067
So we go from rough gravel to finer sand.

378
00:23:49,587 --> 00:23:52,569
All those kinds of things is in the artist's hands.

379
00:23:53,852 --> 00:23:56,134
And I just want to show a quick example of it.

380
00:23:56,154 --> 00:23:59,979
This is me in edit mode, in our edit with the wig mode,

381
00:24:00,359 --> 00:24:02,902
playing around with just with some of our ground cover.

382
00:24:02,942 --> 00:24:05,725
So we have full control over spacing, size,

383
00:24:06,146 --> 00:24:08,528
what type it is, so we can just switch it on the fly.

384
00:24:08,548 --> 00:24:11,592
And that goes for both the,

385
00:24:11,772 --> 00:24:13,954
like the ground cover as well as materials.

386
00:24:15,439 --> 00:24:18,701
So it makes it really fast for our artists to work with

387
00:24:18,801 --> 00:24:21,282
and figure out kind of what is the look that they are after.

388
00:24:21,923 --> 00:24:24,244
And this works, of course, with everything,

389
00:24:24,944 --> 00:24:26,925
all the sculpting tools and painting tools,

390
00:24:26,965 --> 00:24:28,946
just like it should do.

391
00:24:29,467 --> 00:24:31,948
And so if we're sculpting, everything follows along

392
00:24:32,048 --> 00:24:34,129
and the rules that are applied.

393
00:24:34,729 --> 00:24:36,530
And something that our artists used a lot

394
00:24:36,590 --> 00:24:39,592
was that they created what they call bio-masks,

395
00:24:39,652 --> 00:24:41,453
which drives a whole lot of things.

396
00:24:41,513 --> 00:24:43,814
So instead of painting individual masks,

397
00:24:44,535 --> 00:24:49,736
they added so they have the ability to switch out all the materials and all the ground covers

398
00:24:50,436 --> 00:24:56,678
just by painting into one type of mask instead. And all that control, also control over how the

399
00:24:56,818 --> 00:25:01,379
UI looks in terms of names of masks and grouping and all that is controlled in the surface and

400
00:25:01,399 --> 00:25:07,721
graph by the artist. So we want it to be as much as possible controllable by them so they can set

401
00:25:07,761 --> 00:25:10,302
it up in the best way possible for them to work.

402
00:25:11,463 --> 00:25:17,728
And you might have seen it in that video, it's flashed by, but this is just an example of how big something...

403
00:25:18,388 --> 00:25:22,632
It kind of grows very quickly and for the campaign island, which is our biggest level,

404
00:25:23,212 --> 00:25:30,898
that graph grew quite a lot. So we had a total of 22 input masks, 53 ground cover placements,

405
00:25:31,098 --> 00:25:35,802
and 65 different material outputs, as well as 24 audio and 19 effects placements. So...

406
00:25:37,350 --> 00:25:39,251
At the same time, give them the power,

407
00:25:39,291 --> 00:25:42,052
but also make sure to keep track of what's going on

408
00:25:42,092 --> 00:25:43,352
so they don't go overboard.

409
00:25:44,813 --> 00:25:47,254
And that kind of concludes what we want to talk about

410
00:25:47,294 --> 00:25:48,314
on the terrain side.

411
00:25:48,354 --> 00:25:50,495
I just want to end with showing some of the examples

412
00:25:51,095 --> 00:25:53,716
from what the team were doing with this tech.

413
00:25:54,797 --> 00:25:57,858
And we're, honestly, I'm just blown away

414
00:25:57,898 --> 00:26:02,099
what they were able to do because it's new to the studio,

415
00:26:02,319 --> 00:26:03,800
but it didn't stop them.

416
00:26:04,500 --> 00:26:06,801
And I'm curious to see what they do in the future with it.

417
00:26:08,868 --> 00:26:14,689
And now I'm going to hand over to Kurt that's going to talk about some of the other improvements we did and he's going to start with HLODS.

418
00:26:17,470 --> 00:26:29,893
Yes, so we did build HLODS for previous Halo games, but that was very much a manual process and we knew from day one that it was never going to scale up for Halo Infinite.

419
00:26:31,193 --> 00:26:36,794
We also knew that we tend to have high fidelity assets so

420
00:26:37,503 --> 00:26:39,165
We talked about the mask painting system.

421
00:26:39,285 --> 00:26:42,127
That generally means the pixel shaders

422
00:26:42,627 --> 00:26:45,929
for a lot of our geometry carries around four layers

423
00:26:46,009 --> 00:26:47,830
that it blends together in real time.

424
00:26:49,632 --> 00:26:52,293
We have a number of other heavy pixel shader features

425
00:26:52,413 --> 00:26:54,975
like sampling into the terrain's virtual textures

426
00:26:56,096 --> 00:26:59,979
or triplanar mapping or relaxed cone step mapping.

427
00:27:01,520 --> 00:27:04,301
We also tend to have pretty heavy geometry.

428
00:27:04,642 --> 00:27:05,502
In the top image here,

429
00:27:05,542 --> 00:27:06,183
you can see our...

430
00:27:06,962 --> 00:27:17,908
LOD0 geometry. In particular, those repeating teeth are difficult to reduce with regular LOD methods.

431
00:27:20,109 --> 00:27:26,513
So we were attracted to the SimplyGone Remesher as a way to solve both of those problems. It has

432
00:27:26,553 --> 00:27:32,857
the ability to bake geometric detail, like those teeth, to texture detail in the HLODs, which you

433
00:27:32,897 --> 00:27:34,558
can see in the example HLOD below.

434
00:27:36,072 --> 00:27:40,053
It bakes all of our shaders down into a single set of textures

435
00:27:40,353 --> 00:27:44,174
for the HLOD, which, by the way, we

436
00:27:44,194 --> 00:27:47,795
did have to fix a few bugs there that we created for ourselves

437
00:27:47,855 --> 00:27:50,035
by over-optimizing the mask paint UVs,

438
00:27:50,095 --> 00:27:52,636
because the HLOD material composite

439
00:27:52,656 --> 00:27:55,417
needs that same UV set to bake the textures down for us.

440
00:27:59,198 --> 00:28:04,139
So we knew when we started out with HLODs

441
00:28:06,022 --> 00:28:08,944
Low spec was where we would need the GPU savings the most.

442
00:28:10,385 --> 00:28:12,046
But we also knew that low spec was

443
00:28:12,086 --> 00:28:14,788
where we would have the least amount of memory to spare.

444
00:28:15,388 --> 00:28:18,370
In fact, we didn't even really know how much memory

445
00:28:18,410 --> 00:28:19,851
we could use on HLODs.

446
00:28:20,151 --> 00:28:21,452
We had an idea that we were going

447
00:28:21,472 --> 00:28:25,475
to try to fit into 100 megs of content memory for HLODs.

448
00:28:27,647 --> 00:28:32,188
But in any case, we knew that balancing all of those conflicting needs was going to be tricky.

449
00:28:32,348 --> 00:28:36,650
So the way we approached it was we built a lot of controls into the HLOD system.

450
00:28:36,730 --> 00:28:43,053
So we have controls for each HLOD around reduction and remeshing settings.

451
00:28:43,853 --> 00:28:47,294
We have controls over which meshes are included or excluded from HLODs.

452
00:28:48,715 --> 00:28:53,637
We can place HLODs manually as volumes at any level of the hierarchy.

453
00:28:54,197 --> 00:28:55,498
And we also have a system that...

454
00:28:56,749 --> 00:29:01,833
automatically subdivides the world into a grid of HLODs at any level of the hierarchy.

455
00:29:03,074 --> 00:29:07,257
And we have a lot of multipliers for things like quality and switch distance

456
00:29:07,898 --> 00:29:10,260
that we can tune on each individual HLOD.

457
00:29:12,762 --> 00:29:18,887
So once we built all those controls, we started out iterating to try and figure out where the

458
00:29:18,927 --> 00:29:24,292
best balancing point was just by trial and error. And I think we learned some interesting

459
00:29:24,352 --> 00:29:25,233
things along the way.

460
00:29:26,811 --> 00:29:39,260
Originally, we anticipated we were going to need to exercise a lot of control over exactly which meshes are allowed to go into an HLOD and which aren't to try to keep the memory cost down and the quality up.

461
00:29:40,261 --> 00:29:51,369
But what we discovered is the Simplygon remesher does such a great job of deciding for you what to include and what to leave out of the remeshed mesh it builds.

462
00:29:52,250 --> 00:29:53,210
So we were able to.

463
00:29:53,608 --> 00:29:55,709
pretty much just throw everything at Simplygon,

464
00:29:56,469 --> 00:29:59,030
give it one quality setting that we tune per HLOD,

465
00:29:59,110 --> 00:30:01,851
and let Simplygon figure out what to keep.

466
00:30:02,151 --> 00:30:06,293
With one minor caveat, that if you throw everything,

467
00:30:06,353 --> 00:30:08,534
everything at it, it tends to,

468
00:30:09,514 --> 00:30:10,795
you tend to run out of memory.

469
00:30:10,855 --> 00:30:15,257
So in a few cases, we had to split HLOD volumes up

470
00:30:15,317 --> 00:30:17,017
into two smaller HLOD volumes,

471
00:30:17,938 --> 00:30:19,578
which is a relatively straightforward fix.

472
00:30:20,763 --> 00:30:29,889
We also anticipated we would need to specify texture resolution and geometric quality, really fine tune that on a per HLOD level.

473
00:30:30,870 --> 00:30:41,437
But again, what we found was that that single Simplygon remesher quality setting did a fantastic job of Simplygon just figured out for us how much textures that needed to use for each HLOD.

474
00:30:43,338 --> 00:30:50,283
We talked a bit about modular workflows earlier. So we had a modular workflow of sorts for rocks, which is that we had

475
00:30:51,305 --> 00:30:57,431
six or seven rock meshes that we built our cliff walls and things by kit bashing together,

476
00:30:58,573 --> 00:31:03,357
which is a good workflow for the artist because it's fast. You can get a high quality result,

477
00:31:03,497 --> 00:31:07,801
but it has an unfortunate consequence that you end up with a lot of rock geometry that's

478
00:31:08,582 --> 00:31:13,087
between two rock placements or hidden under the ground that you can't see but you still have to

479
00:31:13,147 --> 00:31:13,507
pay for.

480
00:31:14,509 --> 00:31:31,404
So we had hoped to be able to use the simply gone remeasure to turn those into a single efficient shell, which it does do, but we didn't have enough memory to be able to apply that technique to all the rocks in the world.

481
00:31:32,805 --> 00:31:38,651
So where we ended up for H love setup is we tend to have one parent H lot around

482
00:31:39,329 --> 00:31:44,552
base or point of interest. You can see the parent HLOD for prison on the bottom left here.

483
00:31:45,893 --> 00:31:51,377
Underneath that parent volume in the hierarchy are a number of child HLOD volumes.

484
00:31:52,718 --> 00:31:58,582
And the main reason we do that is that it allows us to push a lot of quality into those child

485
00:31:58,622 --> 00:32:02,285
volumes, which allows us to switch to them surprisingly close to the camera

486
00:32:02,865 --> 00:32:04,726
on low spec to get GPU savings.

487
00:32:06,428 --> 00:32:08,789
But then when we're a little bit further away,

488
00:32:09,089 --> 00:32:10,850
we can switch to that parent HLOD

489
00:32:10,990 --> 00:32:13,252
and stream out the child HLODs

490
00:32:13,292 --> 00:32:16,053
so we don't have to pay for that memory all the time.

491
00:32:17,134 --> 00:32:19,515
So I mentioned we had an idea

492
00:32:19,575 --> 00:32:20,976
that we could fit all our HLODs

493
00:32:21,797 --> 00:32:23,518
into 100 megs of content memory.

494
00:32:23,558 --> 00:32:26,900
But interestingly, at the end of the trial and error process

495
00:32:26,940 --> 00:32:30,061
where we ended up was more like 300 megs

496
00:32:30,342 --> 00:32:32,083
of memory budget on HLODs.

497
00:32:33,964 --> 00:32:35,485
So that's the HLOD system.

498
00:32:37,203 --> 00:32:40,483
Next I'll talk a bit about some of our procedural content creation tools.

499
00:32:40,864 --> 00:32:46,225
I mentioned in the sculpting graph that we have hooks to do things in Houdini for the

500
00:32:46,265 --> 00:32:46,665
terrain.

501
00:32:48,125 --> 00:32:53,846
So the way we interface with Houdini is we have a Python API to read and write our game

502
00:32:53,866 --> 00:32:55,026
data files directly.

503
00:32:56,386 --> 00:33:02,808
And we can invoke that API from Houdini, which ends up looking like, it looks like just loading

504
00:33:02,848 --> 00:33:03,768
the map in Houdini.

505
00:33:04,561 --> 00:33:05,721
It knows where the terrain is.

506
00:33:05,741 --> 00:33:07,442
It knows where all the rock placements and the tree

507
00:33:07,482 --> 00:33:08,202
placements are.

508
00:33:09,362 --> 00:33:11,302
And from there, we can do a number of things,

509
00:33:11,382 --> 00:33:15,143
like run an erosion sim or generate our terrain macro

510
00:33:15,163 --> 00:33:17,583
textures for some interesting bumps and breakup.

511
00:33:18,984 --> 00:33:23,024
We use a similar setup to generate flow maps

512
00:33:23,245 --> 00:33:24,905
for our river shader.

513
00:33:25,405 --> 00:33:28,926
We load the world with the river banks and the rocks

514
00:33:29,026 --> 00:33:32,206
and the mesh that's the surface of the river into Houdini

515
00:33:32,266 --> 00:33:33,587
and then run a fluid sim.

516
00:33:34,950 --> 00:33:38,912
and bake the results of that back out to a texture that the shader uses for the river.

517
00:33:41,474 --> 00:33:47,958
We have a similar system for our hex placements. The hexes is the grid of hexagonal metal

518
00:33:48,018 --> 00:33:53,822
forerunner columns that's the substructure of the ring. So the world artists place those red boxes

519
00:33:54,142 --> 00:33:58,045
in the map and then Houdini loads the map that sees the red boxes.

520
00:33:59,058 --> 00:34:02,260
And it has a number of rules to generate those hex placements

521
00:34:02,320 --> 00:34:03,962
on the right grid with the right spacing,

522
00:34:04,042 --> 00:34:06,383
with the right randomness along their tops,

523
00:34:06,804 --> 00:34:09,286
and feeds it back into a custom rendering system

524
00:34:09,306 --> 00:34:11,407
that we have for the hexes in the engine.

525
00:34:13,749 --> 00:34:15,911
And I mentioned that we had to give up

526
00:34:16,311 --> 00:34:19,173
on our idea of HLODing all of our rocks.

527
00:34:19,733 --> 00:34:23,096
So one mitigation we had for all of that hidden geo

528
00:34:23,136 --> 00:34:24,817
that we still had to pay for was we

529
00:34:26,041 --> 00:34:28,641
we had a tool to non-destructively slice the rocks

530
00:34:28,842 --> 00:34:30,302
into pieces in Houdini.

531
00:34:32,382 --> 00:34:35,763
And the benefit of that is we're able to use our runtime

532
00:34:35,803 --> 00:34:39,424
visibility culling system, and it's

533
00:34:39,484 --> 00:34:42,784
able to hide some portion of those meshes that

534
00:34:42,804 --> 00:34:45,365
are completely hidden by the ground or other meshes.

535
00:34:45,705 --> 00:34:47,726
And it doesn't do a perfect job, but it was certainly

536
00:34:47,766 --> 00:34:52,066
better than nothing to save us some runtime performance there.

537
00:34:53,328 --> 00:34:55,690
So that's our procedural content creation tools.

538
00:34:56,530 --> 00:34:57,691
Next I'll hand back to Michael

539
00:34:57,711 --> 00:34:59,552
to talk a bit about scalability.

540
00:35:01,093 --> 00:35:03,835
Yeah, so as we mentioned in the beginning,

541
00:35:04,356 --> 00:35:06,658
the previous Halo games were only really targeting

542
00:35:06,738 --> 00:35:07,318
one platform.

543
00:35:07,878 --> 00:35:12,041
So they had some scalability built into the engine

544
00:35:12,122 --> 00:35:13,563
at that point, which is basically

545
00:35:13,583 --> 00:35:15,124
the progressive resolution system

546
00:35:15,544 --> 00:35:18,066
that scales the game resolution based on

547
00:35:18,626 --> 00:35:25,632
performance as well as a throttling system that scales back certain features like LOD distances also based on what the performance is.

548
00:35:26,152 --> 00:35:29,515
But they were very few scalable systems.

549
00:35:30,456 --> 00:35:39,563
Some parameters were exposed, some were hard-coded, but overall it was very hard to outdirect, it was very hard to have an overview of what's going on, and it was very limited.

550
00:35:40,244 --> 00:35:46,489
So we went into this knowing that we needed a very flexible system that supported multiple hardware specs.

551
00:35:46,929 --> 00:35:51,168
like I mentioned at the beginning, we have to support Xbox One, which is nine-year-old hardware by now.

552
00:35:52,143 --> 00:35:53,844
So it needs to be very extensive.

553
00:35:54,304 --> 00:35:55,465
We wanted it to be data-driven,

554
00:35:56,005 --> 00:36:00,267
and we opted for that we wanted manual tuning for this.

555
00:36:00,848 --> 00:36:02,248
And several reasons for it.

556
00:36:03,209 --> 00:36:07,130
One of them, we wanted to have content and art direction

557
00:36:07,170 --> 00:36:10,292
be able to make decisions where to sacrifice visual quality

558
00:36:10,752 --> 00:36:14,294
on specific platforms to get back CPU, GPU, or memory.

559
00:36:14,894 --> 00:36:17,195
But also because of the amount of time it takes

560
00:36:17,235 --> 00:36:18,396
for an automated system

561
00:36:19,056 --> 00:36:25,619
to get things right, how to get it the results that you're after, how it should know what to

562
00:36:25,659 --> 00:36:31,501
choose versus something else. And we were not in the, we didn't feel like we were at the place where

563
00:36:31,541 --> 00:36:32,482
we wanted to.

564
00:36:33,987 --> 00:36:35,028
do that kind of choice.

565
00:36:35,068 --> 00:36:36,589
So we opted for manual tuning.

566
00:36:37,490 --> 00:36:40,211
That's still, we knew that that will still make time,

567
00:36:40,451 --> 00:36:41,412
take a lot of time,

568
00:36:41,752 --> 00:36:44,334
but it meant that we had control over what we changed.

569
00:36:44,694 --> 00:36:46,235
And this would also be able to,

570
00:36:46,716 --> 00:36:48,437
we should be able to look at that data now

571
00:36:48,477 --> 00:36:50,178
when we have released and talk about,

572
00:36:50,438 --> 00:36:52,259
can we do this automatically in the future?

573
00:36:52,699 --> 00:36:54,340
So this kind of just helped us.

574
00:36:55,473 --> 00:36:57,235
get in the mindset of what we needed to do.

575
00:36:57,716 --> 00:37:00,940
So what we kind of ended up with is what we call scalability

576
00:37:00,980 --> 00:37:01,400
presets.

577
00:37:01,741 --> 00:37:04,744
So on the left side, you can see all the various features,

578
00:37:05,225 --> 00:37:07,167
high-level features where we have scalability

579
00:37:07,207 --> 00:37:08,549
built into our engine now.

580
00:37:09,630 --> 00:37:12,173
And there's multiple settings in these,

581
00:37:12,333 --> 00:37:14,195
and they usually had multiple.

582
00:37:14,756 --> 00:37:18,599
presets within themselves as well, usually a low, medium, high and ultra.

583
00:37:19,199 --> 00:37:23,442
And on the right side, you can see a high level version of this is how we could define

584
00:37:23,902 --> 00:37:27,725
what is the settings for each of these features that we're using for, in this case,

585
00:37:28,045 --> 00:37:32,308
Xbox Series S. So it's using, in this case, a mix of medium and high.

586
00:37:33,743 --> 00:37:38,684
And like I mentioned, there was multiple settings within each of these categories.

587
00:37:38,724 --> 00:37:42,605
So for geometry, we had, for example, we could skip LEDs per platform

588
00:37:43,045 --> 00:37:45,366
or scale our LED render distances.

589
00:37:46,206 --> 00:37:50,487
Or for something like shadows, we control the resolution of our shadow maps.

590
00:37:50,807 --> 00:37:51,988
Do we use contact shadows?

591
00:37:52,548 --> 00:37:53,288
Those kind of things.

592
00:37:53,568 --> 00:37:54,228
And it was a mix.

593
00:37:54,268 --> 00:37:56,629
Some of these settings were global for the entire game.

594
00:37:56,749 --> 00:37:59,250
And in some cases, we had it so we could do it per level.

595
00:38:00,993 --> 00:38:06,114
And how the engine used this to kind of get us to a frame rate where we needed to be was that

596
00:38:06,714 --> 00:38:11,475
we had our scalability presets so they are automatically applied on console but on PC

597
00:38:11,635 --> 00:38:17,036
you choose them. If we don't hit our frame rate then we still have a progressive resolution system

598
00:38:17,076 --> 00:38:21,697
kicking in and this will start scaling the resolution down to try to get to where the

599
00:38:21,717 --> 00:38:26,758
frame needs to be. If we still don't hit frame rate at this time on the GPU throttling kicks in.

600
00:38:27,978 --> 00:38:32,661
But the difference this time around is that throttling is actually tied to our scalability presets.

601
00:38:33,141 --> 00:38:39,945
So when we set up the geometry, the multipliers for how to scale back our geometry, we have a high and a low value.

602
00:38:40,466 --> 00:38:45,609
So the high value is what's used when the game is not trying to scale it back further,

603
00:38:46,009 --> 00:38:50,252
and the low value is how close we allow it to scale back at a maximum.

604
00:38:51,192 --> 00:38:55,295
And the idea around both the progressive resolution and the throttling system

605
00:38:55,475 --> 00:38:56,636
is that these are

606
00:38:57,637 --> 00:39:02,078
a buffer that are used when the game is throwing things that you can't really predict.

607
00:39:02,598 --> 00:39:06,059
When you don't know how many enemies are going to shoot at you at any given point.

608
00:39:06,400 --> 00:39:11,481
So this is kind of how we try to maintain Perf even though those kind of situations

609
00:39:11,501 --> 00:39:15,623
happen because usually that's when you least, you won't notice it as much.

610
00:39:16,103 --> 00:39:20,824
But overall the scaleability presets should take us to Perf on a various platform on their

611
00:39:20,924 --> 00:39:21,024
own.

612
00:39:21,885 --> 00:39:28,252
And I mentioned it takes time to get to this and there is no special sauce. Really, we were using

613
00:39:28,632 --> 00:39:33,617
regular performance reviews with our various content teams and engineers to kind of look

614
00:39:33,637 --> 00:39:38,602
through it while we were at. We did build a lot of automation and

615
00:39:39,503 --> 00:39:42,984
data gathering into our process.

616
00:39:43,545 --> 00:39:46,806
We have daily or a play test or we have

617
00:39:46,866 --> 00:39:49,667
nightly run-throughs where we get data into Power BI,

618
00:39:49,687 --> 00:39:51,308
where you can see trends.

619
00:39:51,548 --> 00:39:53,849
This is an example of a high-level report where we can see

620
00:39:54,169 --> 00:39:55,729
where we are on the GPU.

621
00:39:56,830 --> 00:40:03,014
on the various parts of the island. And this kind of helps us to identify if there are regressions

622
00:40:03,554 --> 00:40:08,897
and if we need to go and look at specific areas. So we then, and then deep diving into those and

623
00:40:08,957 --> 00:40:13,620
having a conversation about what do we do is that either optimizing content or is this

624
00:40:14,600 --> 00:40:17,802
some scalability we need to apply because this is a problem all up.

625
00:40:18,723 --> 00:40:23,626
And lastly, I just want to show some examples from Halo Infinite,

626
00:40:23,746 --> 00:40:26,668
where we kind of what the differences are between the various specs.

627
00:40:27,208 --> 00:40:32,191
These are taken on PC, so there would be a resolution difference

628
00:40:32,291 --> 00:40:34,513
if I would run on console, but otherwise it's the same.

629
00:40:35,173 --> 00:40:39,656
And you definitely can see that for running this on an Xbox One,

630
00:40:39,676 --> 00:40:43,338
we have to scale back our LED distances and our sky quality

631
00:40:43,358 --> 00:40:44,539
and those kind of things have to go.

632
00:40:44,599 --> 00:40:45,159
But overall...

633
00:40:45,583 --> 00:40:48,570
the overall look of the game is still consistent throughout.

634
00:40:49,091 --> 00:40:50,735
And on something like on an interior,

635
00:40:50,775 --> 00:40:52,880
you see much less of the geometry differences,

636
00:40:52,940 --> 00:40:55,065
but more in a volumetrics and lighting.

637
00:40:56,180 --> 00:40:59,721
And then lastly, this is of course also used on MP.

638
00:41:00,461 --> 00:41:02,642
On our MP levels, since they're smaller,

639
00:41:02,702 --> 00:41:05,603
we managed to keep a much more consistent look

640
00:41:06,123 --> 00:41:08,043
on the geometry side throughout the whole range.

641
00:41:08,163 --> 00:41:11,584
It's more noticeable, especially on a reflective map

642
00:41:11,624 --> 00:41:14,765
like this, that the reflections, the squeeze-based reflections

643
00:41:14,785 --> 00:41:18,286
was something we had to turn off to get our frame

644
00:41:18,306 --> 00:41:20,486
rate on Xbox One.

645
00:41:21,861 --> 00:41:24,843
And this kind of concludes what we wanted to talk about today.

646
00:41:24,863 --> 00:41:29,027
And we want to say thanks to everyone at 343

647
00:41:29,287 --> 00:41:31,369
and all our partners, because we wouldn't

648
00:41:31,429 --> 00:41:33,490
be able to be here and talk about this

649
00:41:33,931 --> 00:41:36,993
without all their amazing work over the years.

650
00:41:37,734 --> 00:41:43,198
And while you're at GDC, please check out the other talks

651
00:41:43,218 --> 00:41:47,322
that 343 have here, everything from career development

652
00:41:47,362 --> 00:41:48,983
to programming and design.

653
00:41:49,123 --> 00:41:49,203
And.

654
00:41:51,700 --> 00:41:53,041
Please visit our website.

655
00:41:53,901 --> 00:41:55,321
We have lots of positions opening.

656
00:41:55,361 --> 00:41:57,082
Come build the future of Halo with us.

657
00:41:58,242 --> 00:42:00,363
And with that, we'll open up for questions.

658
00:42:00,383 --> 00:42:00,423
Hi.

659
00:42:01,163 --> 00:42:04,884
Hi.

660
00:42:15,187 --> 00:42:15,227
Hi.

661
00:42:15,247 --> 00:42:15,287
Hi.

662
00:42:15,307 --> 00:42:15,347
Hi.

663
00:42:15,367 --> 00:42:15,407
Hi.

664
00:42:15,427 --> 00:42:15,467
Hi.

665
00:42:15,487 --> 00:42:15,527
Hi.

666
00:42:15,547 --> 00:42:15,587
Hi.

667
00:42:15,607 --> 00:42:15,647
Hi.

668
00:42:15,667 --> 00:42:15,887
Hi.

669
00:42:15,907 --> 00:42:15,947
Hi.

670
00:42:15,967 --> 00:42:16,007
Hi.

671
00:42:16,027 --> 00:42:16,067
Hi.

672
00:42:16,087 --> 00:42:16,127
Hi.

673
00:42:16,147 --> 00:42:16,187
Hi.

674
00:42:16,207 --> 00:42:16,247
Hi.

675
00:42:16,267 --> 00:42:16,307
Hi.

676
00:42:16,327 --> 00:42:16,367
Hi.

677
00:42:16,387 --> 00:42:16,427
Hi.

678
00:42:16,447 --> 00:42:16,487
Hi.

679
00:42:16,507 --> 00:42:16,547
Hi.

680
00:42:16,567 --> 00:42:16,607
Hi.

681
00:42:16,627 --> 00:42:16,667
Hi.

682
00:42:18,001 --> 00:42:19,381
Sure. Thanks for the talk.

683
00:42:19,621 --> 00:42:24,663
Um, so you sliced up your rocks in Houdini so that you could do like sub part

684
00:42:25,503 --> 00:42:26,183
culling on them.

685
00:42:26,843 --> 00:42:29,664
Did you end up having to pay extra draw calls for each of those parts?

686
00:42:29,704 --> 00:42:33,565
Or did you have a system that kept the different chunks of the rock as one draw

687
00:42:33,585 --> 00:42:33,825
call?

688
00:42:36,006 --> 00:42:37,506
Um, good question. Uh,

689
00:42:37,746 --> 00:42:42,848
so our engine is actually does a really amazing job of instancing and GPU

690
00:42:42,868 --> 00:42:43,428
submission. So, uh,

691
00:42:46,294 --> 00:42:53,836
It was more draw calls, but it doesn't. Well, it's not actually more draw calls. It would have been if we didn't have instancing so

692
00:42:54,616 --> 00:43:06,679
We did work closely with rendering about that plan before we put it into action and they were able to give us some sort of guidelines on how many chunks might be appropriate and we were careful to test it.

693
00:43:07,139 --> 00:43:09,880
Hope that answers your question. Yep. Thank you.

694
00:43:12,529 --> 00:43:18,570
As someone who's so heavily involved in tool development,

695
00:43:19,710 --> 00:43:22,311
were you privy to any of the decisions

696
00:43:22,391 --> 00:43:26,712
behind ultimately making this Halo an open world

697
00:43:26,752 --> 00:43:28,512
game as opposed to a more linear shooter?

698
00:43:31,753 --> 00:43:34,673
That was not really something that was on our level.

699
00:43:36,534 --> 00:43:38,574
So can't speak for that, sorry.

700
00:43:41,609 --> 00:43:46,172
Hi, I was wondering if you could talk about performance scaling that you had to deal with

701
00:43:47,633 --> 00:43:49,675
drive access and network.

702
00:43:50,876 --> 00:43:55,699
Did you have any type of scalability decisions that you made around those restrictions?

703
00:43:58,130 --> 00:44:04,158
So most of the stuff that we had to deal with was, I wasn't really involving those areas.

704
00:44:04,178 --> 00:44:09,725
So I, unfortunately I can't speak much for it. Ours were more, yeah, the content side scaling.

705
00:44:10,627 --> 00:44:13,370
So sorry, not able to answer that one.

706
00:44:16,181 --> 00:44:30,472
Hi. You mentioned briefly how you got, how you generate the cliffs on the levels by hand placing the sections of rocks and then just simplifying it and simply gone.

707
00:44:32,093 --> 00:44:38,819
Did you have a procedural process to place those cliffs on edges around the map? Or was everything handmade?

708
00:44:40,740 --> 00:44:42,581
It's mostly handmade. We have a few.

709
00:44:45,737 --> 00:44:47,498
a few things we do procedurally for that.

710
00:44:47,558 --> 00:44:49,459
But yeah, the cliffs are mostly handmade.

711
00:44:50,900 --> 00:44:52,961
Thank you.

712
00:44:53,021 --> 00:44:54,462
Thank you for coming out to talk.

713
00:44:54,582 --> 00:44:55,963
I was wondering what was probably

714
00:44:56,003 --> 00:44:59,304
the biggest challenge for making the procedural creation system?

715
00:44:59,565 --> 00:45:03,106
And if you were to re-approach that situation again,

716
00:45:03,166 --> 00:45:05,648
how would you do it a second time?

717
00:45:09,910 --> 00:45:10,130
Kurt?

718
00:45:11,151 --> 00:45:11,511
You want me to?

719
00:45:11,531 --> 00:45:12,932
You were more involved in that.

720
00:45:14,271 --> 00:45:20,397
Which, which procedural system. Are you referring to specifically, I guess, as a whole, the entire system as a whole.

721
00:45:21,778 --> 00:45:30,427
Yeah, I think, I think where I would go with that. There's a number of things you could say, but I think where I would go with is fine tuning the balance between

722
00:45:31,948 --> 00:45:36,633
The places where you need to really hand build stuff to get it to look exactly how you want versus

723
00:45:37,553 --> 00:45:43,937
the places where you want it to happen procedurally so that you can, you know, do it on a wide swath of the game and

724
00:45:46,239 --> 00:45:52,023
in preserving the ability to do both of those things where it's appropriate to do one course versus the other.

725
00:45:53,224 --> 00:45:57,107
So I think what's top of my mind about where we go next is just sort of

726
00:45:57,947 --> 00:46:02,251
revisit some of the assumptions we made about which parts of the world had to be hand-built.

727
00:46:04,372 --> 00:46:07,796
in which parts it's possible to procedurally build.

728
00:46:10,018 --> 00:46:14,083
Yeah, I would agree with that because a lot of it,

729
00:46:14,383 --> 00:46:19,249
especially for this project, this was a lot of new things for the

730
00:46:19,289 --> 00:46:20,210
teams as well.

731
00:46:22,290 --> 00:46:27,715
we like Kurt said, there was a lot of assumptions in how much hand tuning we wanted to do that.

732
00:46:27,875 --> 00:46:30,217
It kind of goes back to when we were talking about the rocks.

733
00:46:30,818 --> 00:46:35,802
That was a conscious decision that we rather hand tuning because we were after a very specific look.

734
00:46:36,242 --> 00:46:41,027
But I think now when we have a project that we can look back on, we have a lot of learnings.

735
00:46:42,017 --> 00:46:46,924
where we can revisit and see which of those things could we actually procedurally generate

736
00:46:47,144 --> 00:46:53,313
in the future. And I think we have a lot of opportunities there that we definitely should look at.

737
00:46:53,333 --> 00:46:55,836
Awesome. Thank you so much.

738
00:47:00,370 --> 00:47:01,711
Hello, great talk, thank you.

739
00:47:02,492 --> 00:47:04,733
I have a question about tools.

740
00:47:05,294 --> 00:47:06,735
You have 8 by 8 kilometers.

741
00:47:07,375 --> 00:47:09,217
So for example, for the train tool,

742
00:47:09,597 --> 00:47:12,859
do you have any issues with memory or performance

743
00:47:13,139 --> 00:47:15,021
when you have this kind of, let's say,

744
00:47:15,361 --> 00:47:17,102
unoptimized way, like edited it?

745
00:47:18,677 --> 00:47:19,477
On the edit side, you mean?

746
00:47:19,878 --> 00:47:21,278
Yeah, editor side, yeah.

747
00:47:21,398 --> 00:47:24,219
So yes, you can't, if you would try,

748
00:47:24,319 --> 00:47:26,679
you can't like load the entire terrain

749
00:47:26,719 --> 00:47:28,159
to edit it at any given point.

750
00:47:28,179 --> 00:47:31,000
So we had to restrict it in the sense

751
00:47:31,040 --> 00:47:34,641
of how big of a space you edit in our editor

752
00:47:34,761 --> 00:47:35,521
at any given time.

753
00:47:35,941 --> 00:47:39,202
So it will tell you when you try to load too much,

754
00:47:40,082 --> 00:47:41,542
too many of those terrain tiles.

755
00:47:42,583 --> 00:47:45,503
So yeah, definitely, with that size,

756
00:47:45,543 --> 00:47:47,224
you have to be able to split it up somewhere.

757
00:47:47,604 --> 00:47:48,044
I know it will.

758
00:47:48,564 --> 00:47:53,368
there's potential solutions with streaming techniques that we could look at for the future.

759
00:47:53,408 --> 00:47:58,031
But what the solution we ended up with, it kind of worked as well because most of the time we

760
00:47:58,051 --> 00:48:04,076
had multiple artists working at the same time and they could work in smaller sections. And if we

761
00:48:04,116 --> 00:48:07,879
wanted to do something really big where they had to affect the whole terrain, that was usually

762
00:48:08,299 --> 00:48:13,543
that they were generating something in a separate DCC like Houdini to get the simulation going.

763
00:48:13,923 --> 00:48:20,108
So it was less of a problem, but yeah, definitely on the bigger levels that that that happened to be a problem.

764
00:48:20,128 --> 00:48:21,689
Thank you.

765
00:48:23,931 --> 00:48:33,258
I was wondering if you could talk about any strategies you took on to limit popping or any type of loading artifacts as they're moving through the map.

766
00:48:37,942 --> 00:48:41,545
Let's see. So, so one thing we do is we have a lot of control over the

767
00:48:42,679 --> 00:48:49,782
the multipliers for the LOD transition distances for different types of things. So we try to,

768
00:48:51,022 --> 00:48:56,644
you know, we don't apply scaling settings uniformly to trees as we do to rocks as we

769
00:48:56,664 --> 00:49:01,806
do to hard surface. So one answer to that question is we expose a lot of tunability

770
00:49:01,906 --> 00:49:03,466
to exactly how we scale.

771
00:49:07,622 --> 00:49:19,867
Yeah, it's basically it's the teams themselves can define how granular they want to be able to set up the multipliers we have for the scaling on the various platforms.

772
00:49:20,367 --> 00:49:30,072
Other than that, I would say a lot of it was just iterating, a lot of iteration on trying to find something that works both perf and visually.

773
00:49:30,412 --> 00:49:34,354
And in some cases, that means going back and reauthor the LODs and seeing.

774
00:49:35,214 --> 00:49:41,999
like, what can we do to make this better? So it was both giving the flexibility on

775
00:49:42,019 --> 00:49:45,322
the technical side, but also a lot of iteration on the content side.

776
00:49:49,605 --> 00:49:50,626
If that answers your question.

777
00:50:01,397 --> 00:50:05,018
I had a quick question about the dynamic system

778
00:50:05,038 --> 00:50:08,320
that you use to create grass and change terrain and everything.

779
00:50:09,100 --> 00:50:11,121
Did it eventually, at runtime, just

780
00:50:11,161 --> 00:50:12,742
bake down into something static?

781
00:50:12,802 --> 00:50:15,243
Or were you able to use that during gameplay

782
00:50:15,263 --> 00:50:18,005
for things like destruction, or someone threw a grenade

783
00:50:18,065 --> 00:50:18,825
and killed the grass?

784
00:50:20,894 --> 00:50:23,855
We don't have a dynamic system like that currently.

785
00:50:25,296 --> 00:50:27,676
The ground cover is generated on the fly,

786
00:50:27,776 --> 00:50:31,237
but they are driven by masks that we don't change really.

787
00:50:31,357 --> 00:50:34,478
It's something that I would love to look into

788
00:50:34,518 --> 00:50:36,179
for the future, but not something we do.

789
00:50:36,439 --> 00:50:37,639
The only thing that's really affecting,

790
00:50:37,659 --> 00:50:41,520
we have a wind system and like grenades do a push

791
00:50:41,841 --> 00:50:42,961
through that to defect it,

792
00:50:43,001 --> 00:50:44,901
but we're not destroying anything, no.

793
00:50:46,928 --> 00:50:52,109
Before everyone runs out, we just wanted to say thank you very, very much for all of the

794
00:50:52,129 --> 00:50:56,471
people who stuck it out for the TechArt Summit in person, finally.

795
00:50:56,491 --> 00:51:00,532
So yeah, this has been Mary and Mary.

796
00:51:01,592 --> 00:51:04,073
So thank you, thanks to everyone for being here.

797
00:51:04,513 --> 00:51:06,454
Thank you to our CAs, our AV team.

798
00:51:06,514 --> 00:51:08,554
We really appreciate all the hard work you've put in today.

799
00:51:09,695 --> 00:51:13,556
Check out techartist.org if you are so inclined.

800
00:51:14,496 --> 00:51:15,776
And thanks for coming, everyone.

801
00:51:16,077 --> 00:51:16,197
Yeah.

