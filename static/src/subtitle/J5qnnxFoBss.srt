1
00:00:06,725 --> 00:00:11,647
This is a session is dark secrets of the RNG as you can see on the screen.

2
00:00:11,647 --> 00:00:17,010
Squirrel introduced you to some concepts with random number generation earlier.

3
00:00:17,010 --> 00:00:19,471
I'm going to expand on some of those.

4
00:00:19,471 --> 00:00:23,333
His was more theoretical and mine's going to be a little more based on application

5
00:00:23,333 --> 00:00:28,436
and focus not just on some of the non-obvious problems you'll run across

6
00:00:28,436 --> 00:00:31,958
with random number generation and game development, but with some of the

7
00:00:31,958 --> 00:00:34,779
non-obvious tools you have to solve those problems when you come across them.

8
00:00:36,796 --> 00:00:40,337
The title Dark Secrets may be a bit of a misnomer.

9
00:00:40,337 --> 00:00:45,058
I feel like Squirrel got into the dark complex math

10
00:00:45,058 --> 00:00:47,038
of it quite low level,

11
00:00:47,038 --> 00:00:49,519
but we're going to focus on how you use that math.

12
00:00:49,519 --> 00:00:52,800
So who am I and why should you listen to me?

13
00:00:52,800 --> 00:00:55,220
Here's some games I worked on.

14
00:00:55,220 --> 00:00:58,081
There's a lot of them at big studios.

15
00:00:58,081 --> 00:00:59,601
Yeah, I worked on Hearthstone on the prototype.

16
00:00:59,601 --> 00:01:01,322
That was the best known game I've worked on.

17
00:01:05,530 --> 00:01:11,114
I was only there for a year, but of course on digital CCGs, quite a bit of random number

18
00:01:11,114 --> 00:01:11,534
generation.

19
00:01:11,534 --> 00:01:13,116
I've worked on a variety of games through my career.

20
00:01:13,116 --> 00:01:17,859
Done some indie stuff, Overland in the bottom right there I'm no longer working on, but

21
00:01:17,859 --> 00:01:23,424
was a roguelike that definitely randomly generated levels as a consideration there.

22
00:01:23,424 --> 00:01:27,707
And yeah, still working on digital CCGs at Direwolf Digital in Denver, Colorado these

23
00:01:27,707 --> 00:01:27,867
days.

24
00:01:29,164 --> 00:01:32,828
Maybe you've heard of them, maybe not.

25
00:01:32,828 --> 00:01:36,673
But let's get into using RNG.

26
00:01:36,673 --> 00:01:39,095
And let's start with something pretty basic about the types

27
00:01:39,095 --> 00:01:42,299
of problems and decisions you'll be, you know,

28
00:01:42,299 --> 00:01:45,223
you typically have to solve as a gameplay programmer in this area.

29
00:01:46,262 --> 00:01:50,244
So, I made this game, Kinectro, a puzzle game.

30
00:01:50,244 --> 00:01:54,867
My wife was a big fan of it and playing the prototype of it back in 2011 when I was working

31
00:01:54,867 --> 00:01:55,567
on it.

32
00:01:55,567 --> 00:02:00,910
And she came to me with a big complaint that she had, it's kind of a Tetris style game,

33
00:02:00,910 --> 00:02:03,531
it spawns a random piece each turn, you have to place it on the board.

34
00:02:04,012 --> 00:02:05,894
And I heard her yelling one night

35
00:02:05,894 --> 00:02:08,617
she had gotten the same piece nine times in a row

36
00:02:08,617 --> 00:02:11,160
and I realized I needed to fix that bug,

37
00:02:11,160 --> 00:02:13,702
which I did the same way that Tetris fixes it,

38
00:02:13,702 --> 00:02:17,627
which is to use what's sometimes called bagging.

39
00:02:17,627 --> 00:02:21,351
So this is a pretty basic approach

40
00:02:21,351 --> 00:02:23,493
or consideration of randomness in your game.

41
00:02:23,493 --> 00:02:26,336
If you're doing a simple dice roll every turn, like I was, to decide...

42
00:02:26,736 --> 00:02:28,998
which of the six random pieces to spawn every turn,

43
00:02:28,998 --> 00:02:30,559
you're gonna get streaks.

44
00:02:30,559 --> 00:02:33,761
You're going to get a very random distribution.

45
00:02:33,761 --> 00:02:35,903
And sometimes you don't want your randomness

46
00:02:35,903 --> 00:02:36,663
to be that random.

47
00:02:36,663 --> 00:02:41,567
So a simple thing, it's kind of a design decision really,

48
00:02:41,567 --> 00:02:44,048
in a way, or a decision a board game designer would make

49
00:02:44,048 --> 00:02:46,070
is to say, well, that shouldn't be a die roll,

50
00:02:46,070 --> 00:02:48,312
that should be a deck of cards.

51
00:02:48,312 --> 00:02:50,213
Or in math, the distinction would be

52
00:02:52,436 --> 00:02:56,599
to roll a die is to sample from a random set with replacement.

53
00:02:56,599 --> 00:02:59,381
It doesn't change the set to sample one from it.

54
00:02:59,381 --> 00:03:02,082
Whereas a deck of cards, you take one out of it,

55
00:03:02,082 --> 00:03:04,904
it doesn't go back, and you're then

56
00:03:04,904 --> 00:03:07,006
guaranteeing in your distribution

57
00:03:07,006 --> 00:03:10,068
that that won't show up again as a repeat immediately,

58
00:03:10,068 --> 00:03:13,130
as a streak, or for a while.

59
00:03:13,130 --> 00:03:16,112
Most games that use bagging would say,

60
00:03:16,112 --> 00:03:18,874
have a bag of your random set.

61
00:03:20,568 --> 00:03:22,690
Think of it as a deck of cards, shuffle it.

62
00:03:22,690 --> 00:03:25,133
You could take three decks of cards.

63
00:03:25,133 --> 00:03:27,236
Actually, Vegas does this these days to break up

64
00:03:27,236 --> 00:03:29,699
people trying to cheat at blackjack and such.

65
00:03:29,699 --> 00:03:32,382
It's to take three decks of cards or more

66
00:03:32,382 --> 00:03:34,124
and shuffle them together and you can no longer,

67
00:03:34,124 --> 00:03:38,389
it changes the distribution of the randomness, right?

68
00:03:38,389 --> 00:03:40,631
Specifically, so yeah.

69
00:03:41,127 --> 00:03:48,670
You will see fewer streaks of the same thing showing up over and over, if that's an important consideration, as it was in that case for me.

70
00:03:48,670 --> 00:03:51,591
And you will even out the distribution.

71
00:03:51,591 --> 00:03:52,791
But of course there's an edge case.

72
00:03:55,002 --> 00:03:57,223
How, so if you shuffle three decks of cards together

73
00:03:57,223 --> 00:03:58,303
and reshuffle it when empty,

74
00:03:58,303 --> 00:04:01,044
off the top of your head,

75
00:04:01,044 --> 00:04:03,525
you might think that that means the maximum streak

76
00:04:03,525 --> 00:04:05,525
of the same thing you could ever get is three.

77
00:04:05,525 --> 00:04:07,926
You pull three aces of spades

78
00:04:07,926 --> 00:04:10,586
out of a deck of cards like that in a row.

79
00:04:10,586 --> 00:04:13,267
But actually, given that you then reshuffle a new deck

80
00:04:13,267 --> 00:04:16,148
and put it in there, the truth is there's an edge case,

81
00:04:16,148 --> 00:04:20,029
literal edge case at the edge of, or the end of one bag.

82
00:04:20,490 --> 00:04:23,131
you could get 3 aces of spades.

83
00:04:23,131 --> 00:04:25,952
And then at the start of the next bag, you have 3 more.

84
00:04:25,952 --> 00:04:30,354
So that edge case is worth considering,

85
00:04:30,354 --> 00:04:31,755
especially in the case of randomness.

86
00:04:31,755 --> 00:04:37,738
Because here's my first dark secret of RNG.

87
00:04:37,738 --> 00:04:40,239
Yeah, every random edge case that can happen eventually

88
00:04:40,239 --> 00:04:42,880
will happen, and to a live player in a ship game

89
00:04:42,880 --> 00:04:44,901
potentially, if you haven't planned for it

90
00:04:44,901 --> 00:04:46,702
and made it impossible.

91
00:04:48,014 --> 00:04:52,278
uh... and yeah you as a game play programmer of the last line of defense

92
00:04:52,278 --> 00:04:53,680
for uh...

93
00:04:53,680 --> 00:04:56,883
for that you have to sometimes think like a designer and think about these

94
00:04:56,883 --> 00:04:59,926
considerations that would normally

95
00:04:59,926 --> 00:05:03,490
i'm currently working with these uh... ccg designers at direwolf and they're

96
00:05:03,490 --> 00:05:07,554
extremely mathy but i've also worked with designers who uh... aren't

97
00:05:07,554 --> 00:05:08,635
terribly aware of

98
00:05:08,973 --> 00:05:10,653
the mathematical implications of this kind of thing,

99
00:05:10,653 --> 00:05:12,374
especially, and so sometimes as a programmer,

100
00:05:12,374 --> 00:05:14,354
it's your job to step up and say,

101
00:05:14,354 --> 00:05:17,875
have you considered this and this,

102
00:05:17,875 --> 00:05:21,156
even though it might normally fall to design.

103
00:05:21,156 --> 00:05:21,416
So, yeah.

104
00:05:21,416 --> 00:05:29,438
That leads us to, yeah, I'm referencing here at the top.

105
00:05:29,438 --> 00:05:33,258
There's a play called Rosencrantz and Guildenstern are Dead

106
00:05:33,258 --> 00:05:36,179
where the character flips the coin over and over and over

107
00:05:36,179 --> 00:05:38,880
and throughout the play, it always comes up heads, I believe.

108
00:05:39,482 --> 00:05:44,969
And that's extremely unlikely, but again, it will happen in a live game that you get like a hundred

109
00:05:44,969 --> 00:05:47,372
bad rolls in a row for some player.

110
00:05:47,372 --> 00:05:49,955
If it is mathematically possible, it'll happen eventually.

111
00:05:49,955 --> 00:05:52,859
Oops, you have to consider it.

112
00:05:52,859 --> 00:05:53,480
And that...

113
00:05:54,670 --> 00:05:57,432
The solution to that, this is a blue post

114
00:05:57,432 --> 00:06:01,195
from a Blizzard developer, not one I know or anything,

115
00:06:01,195 --> 00:06:02,996
but this is how they solved it on Diablo III,

116
00:06:02,996 --> 00:06:04,537
a very loot-driven game.

117
00:06:04,537 --> 00:06:06,519
In a game like that, this kind of consideration

118
00:06:06,519 --> 00:06:08,040
is a big deal.

119
00:06:08,040 --> 00:06:10,642
So they added what I call a pity timer

120
00:06:10,642 --> 00:06:11,963
that they're describing here.

121
00:06:11,963 --> 00:06:17,767
Basically, if there's a low chance of rolling random loot

122
00:06:17,767 --> 00:06:19,928
at every chance you have to get loot,

123
00:06:20,589 --> 00:06:26,571
And for some players, that just never rolls that way for them for hours at a time, right?

124
00:06:26,571 --> 00:06:33,714
So they put in a fallback, essentially, to say, you know, make sure that that does eventually drop for the player.

125
00:06:33,714 --> 00:06:43,319
Make it work the way you would expect it to work, that the player will eventually get the legendary drop, no matter how bad their luck is.

126
00:06:45,639 --> 00:06:47,120
I want to go over, yeah.

127
00:06:47,120 --> 00:06:50,382
The biggest dark secret of RNG

128
00:06:50,382 --> 00:06:53,403
that you'll kind of keep running into,

129
00:06:53,403 --> 00:06:54,864
I was gonna expand more on this,

130
00:06:54,864 --> 00:06:56,545
but kind of scale back this part of the talk,

131
00:06:56,545 --> 00:06:58,966
is just human brains aren't great

132
00:06:58,966 --> 00:07:03,649
at dealing with probability in general, in many cases.

133
00:07:03,649 --> 00:07:05,350
They misunderstand it easily,

134
00:07:05,350 --> 00:07:07,671
and some of our things, like the pity timer,

135
00:07:07,671 --> 00:07:09,372
are there to make.

136
00:07:10,317 --> 00:07:14,882
a player might know, oh, there's a 1% chance for this random thing to drop

137
00:07:14,882 --> 00:07:16,063
and still go out and kill it 200 times, and

138
00:07:16,063 --> 00:07:20,848
logically they could tell you they know it's possible for it to not drop in all those times,

139
00:07:20,848 --> 00:07:22,630
but they'll still complain very loudly about it.

140
00:07:22,630 --> 00:07:26,854
They don't expect it to work that way usually, unless they sit down and think through the math.

141
00:07:27,675 --> 00:07:34,721
And a lot of our tricks of RNG are there to emulate what the players expect and make randomness

142
00:07:34,721 --> 00:07:39,745
work in the way that, yeah, we expect, they expect it to work.

143
00:07:39,745 --> 00:07:41,487
Even though it's not mathematically true.

144
00:07:41,487 --> 00:07:45,089
So the pity timer is definitely an example of that.

145
00:07:45,089 --> 00:07:50,574
Of course, players will still always complain that the RNG is unfair and hates them and

146
00:07:50,574 --> 00:07:51,175
that they're...

147
00:07:52,015 --> 00:07:53,356
cursed in some way or something.

148
00:07:53,356 --> 00:07:56,159
Actually, I have an interesting story here

149
00:07:56,159 --> 00:08:00,382
that I ran across, which was a game called Urban Dead,

150
00:08:00,382 --> 00:08:01,303
which I used to play a lot.

151
00:08:01,303 --> 00:08:03,164
It was a web-based MMO.

152
00:08:03,164 --> 00:08:06,547
And it had random rolls when you hit the attack button.

153
00:08:06,547 --> 00:08:08,589
It rolls a dice and decides if you land the hit.

154
00:08:08,589 --> 00:08:11,932
And a player posited this theory

155
00:08:11,932 --> 00:08:16,415
that he could get into a groove if he hit the attack button.

156
00:08:16,872 --> 00:08:19,914
and hit, that if he waited eight seconds

157
00:08:19,914 --> 00:08:21,434
and hit it again at that time,

158
00:08:21,434 --> 00:08:24,716
that groove, stayed in that groove of hitting it every eight seconds,

159
00:08:24,716 --> 00:08:28,077
that he would always hit, it would always come up in his favor.

160
00:08:28,077 --> 00:08:32,019
And this is from the talk page then on the wiki of the developer saying,

161
00:08:32,019 --> 00:08:34,720
that's not possible, I'm using a random number generator.

162
00:08:34,720 --> 00:08:36,541
If you were in Squirrel's talk earlier...

163
00:08:37,490 --> 00:08:38,710
Maybe this isn't such a surprise,

164
00:08:38,710 --> 00:08:39,931
but it turned out the player was right

165
00:08:39,931 --> 00:08:42,031
that every eight seconds,

166
00:08:42,031 --> 00:08:46,053
he was simply taking the current time in seconds

167
00:08:46,053 --> 00:08:49,674
and putting that into rand, I think in PHP,

168
00:08:49,674 --> 00:08:52,935
but that probably calls C++ rand function.

169
00:08:52,935 --> 00:08:54,776
And I actually scrolled the,

170
00:08:54,776 --> 00:08:58,017
you had a note that like the lowest two bits

171
00:08:58,017 --> 00:09:00,217
of that were unreliable.

172
00:09:00,217 --> 00:09:01,538
So every eight seconds,

173
00:09:01,538 --> 00:09:03,418
maybe something odd was going on and coming up.

174
00:09:05,593 --> 00:09:11,356
I thought that was pretty hilarious, especially that the developer ended up catching it after

175
00:09:11,356 --> 00:09:12,416
first denying it.

176
00:09:12,416 --> 00:09:15,977
But yeah, you can't cede trivially.

177
00:09:15,977 --> 00:09:18,798
And there are cases where we get it wrong.

178
00:09:18,798 --> 00:09:22,720
So it's worth thinking through thoroughly so you don't have a bug like this in your

179
00:09:22,720 --> 00:09:24,281
live game.

180
00:09:24,281 --> 00:09:29,202
And players are superstitious enough, basically, without bugs like this sneaking in and the

181
00:09:29,202 --> 00:09:30,463
RNG actually being broken.

182
00:09:30,463 --> 00:09:33,364
But they'll always be convinced it is, whether or not it is.

183
00:09:34,733 --> 00:09:37,215
All right, here's a dark secret of gameplay programming.

184
00:09:37,215 --> 00:09:39,596
I'm about to tie all these concepts together.

185
00:09:39,596 --> 00:09:42,938
The designer will always change their minds

186
00:09:42,938 --> 00:09:45,260
about everything possible.

187
00:09:45,260 --> 00:09:49,543
This, yeah, is relevant because,

188
00:09:49,543 --> 00:09:52,065
specifically to loot drops.

189
00:09:55,201 --> 00:10:00,925
So my point here is that if you're designing a game where loot, for instance,

190
00:10:00,925 --> 00:10:04,527
is a major consideration, designers are going to want to tweak that,

191
00:10:04,527 --> 00:10:08,330
because that is a big difference on the player experience and on some other

192
00:10:08,330 --> 00:10:11,011
things that you may not expect that I'm about to get into.

193
00:10:12,459 --> 00:10:16,644
Yeah, the player experience of Legendaries is obviously a big deal.

194
00:10:16,644 --> 00:10:21,650
They want to be sure that Pity Timer is there and that they will eventually get their Legendary

195
00:10:21,650 --> 00:10:23,292
after they kill the boss enough times.

196
00:10:30,792 --> 00:10:34,133
A tool, I think I put this not in the order I expected,

197
00:10:34,133 --> 00:10:37,074
but the tool I'm trying to relate here

198
00:10:37,074 --> 00:10:39,935
is a tool that will let you control a loot drop,

199
00:10:39,935 --> 00:10:45,016
specifically a lookup table.

200
00:10:47,123 --> 00:10:50,646
Yes, a lookup table can describe a die roll,

201
00:10:50,646 --> 00:10:53,968
it can describe a deck of cards, or anything else.

202
00:10:53,968 --> 00:10:59,652
A weighted lookup table could be created with a weight,

203
00:10:59,652 --> 00:11:01,593
say 52 elements, each are a card,

204
00:11:01,593 --> 00:11:04,635
and each card starts with a weight of one.

205
00:11:04,635 --> 00:11:06,497
If the weights can be modified,

206
00:11:06,497 --> 00:11:08,238
that turns out to be a powerful tool,

207
00:11:08,238 --> 00:11:10,319
you could reduce the weight to zero once the card is drawn,

208
00:11:10,319 --> 00:11:11,760
and then reset them later.

209
00:11:11,760 --> 00:11:14,222
But you could represent a lot of other things too.

210
00:11:14,222 --> 00:11:15,763
Of course, here I'm representing

211
00:11:16,717 --> 00:11:19,179
dropping a loot drop for a boss.

212
00:11:19,179 --> 00:11:21,060
Common loot has a weight of one.

213
00:11:21,060 --> 00:11:24,241
Uncommon loot has a weight of 0.5.

214
00:11:24,241 --> 00:11:25,402
So half as likely to drop.

215
00:11:25,402 --> 00:11:27,543
And then here what I'm trying to do

216
00:11:27,543 --> 00:11:29,143
is implement a pity timer.

217
00:11:29,757 --> 00:11:33,318
The legendary lookup is its own,

218
00:11:33,318 --> 00:11:36,579
so first of all, this is nesting lookup tables

219
00:11:36,579 --> 00:11:38,920
in lookup tables, which is very useful

220
00:11:38,920 --> 00:11:43,162
and gives you to the point of being able to respond

221
00:11:43,162 --> 00:11:47,603
to the design asks, gives you a lot of flexibility

222
00:11:47,603 --> 00:11:52,164
to refactor or rework one element of the loot drop

223
00:11:52,164 --> 00:11:56,426
and add detail to it, as we've done with the pity timer here

224
00:11:56,426 --> 00:11:58,366
for the legendary case.

225
00:11:59,153 --> 00:12:02,340
I'll get into an even more complex case on the next slide.

226
00:12:04,245 --> 00:12:08,807
Yes, the dynamic weighting is the other powerful tool of a weighted lookup table, because in

227
00:12:08,807 --> 00:12:13,789
this case I'm changing the weight in order to implement the pity timer and make it so

228
00:12:13,789 --> 00:12:16,450
that eventually the legendary will drop.

229
00:12:16,450 --> 00:12:22,953
Here I'm passing in, you can see my cursor right, I'm passing in basically callback functions

230
00:12:22,953 --> 00:12:28,195
and this second one is saying each time the legendary is not picked, its weight actually

231
00:12:28,195 --> 00:12:29,576
increases.

232
00:12:29,576 --> 00:12:32,577
This, by the way, still kind of violates my rule that you should always...

233
00:12:34,248 --> 00:12:35,968
account for every edge case, like,

234
00:12:35,968 --> 00:12:38,909
mathematically, you couldn't be 100% sure

235
00:12:38,909 --> 00:12:41,189
that the legendary would eventually drop,

236
00:12:41,189 --> 00:12:43,930
unless you're also decreasing the weights

237
00:12:43,930 --> 00:12:45,250
for the other elements,

238
00:12:45,250 --> 00:12:47,110
which would be another way to implement this.

239
00:12:47,110 --> 00:12:48,711
But in this case, I'm just increasing the weight

240
00:12:48,711 --> 00:12:51,191
for the legendary each time it is missed,

241
00:12:51,191 --> 00:12:52,311
and then when it is finally hit,

242
00:12:52,311 --> 00:12:53,592
I reset the weight to the beginning.

243
00:12:53,592 --> 00:12:59,813
It's a simple but nice way, elegant way,

244
00:12:59,813 --> 00:13:01,413
and kind of maintainable,

245
00:13:01,413 --> 00:13:02,833
which is always a consideration with code.

246
00:13:04,200 --> 00:13:06,041
to implement something like this.

247
00:13:06,041 --> 00:13:08,683
So to continue tying this all together,

248
00:13:08,683 --> 00:13:13,006
one of the games I showed back there was, excuse me,

249
00:13:13,006 --> 00:13:15,207
an indie game I developed,

250
00:13:15,207 --> 00:13:18,469
Angry Henry and the Escape from the Helicopter Lords,

251
00:13:18,469 --> 00:13:22,191
part 17, the re-reckoning is the full title,

252
00:13:22,191 --> 00:13:23,612
which I'll try not to say again,

253
00:13:23,612 --> 00:13:25,853
I don't think we have time to say it too often.

254
00:13:25,853 --> 00:13:29,335
So in this example, I'm imagining that Walrus Copter,

255
00:13:29,335 --> 00:13:31,237
the boss from that game,

256
00:13:31,237 --> 00:13:32,517
let's, I'm making an Angry Henry.

257
00:13:33,318 --> 00:13:36,321
and the helicopter lord's MMO in this example.

258
00:13:36,321 --> 00:13:39,644
Walruscopter is my boss.

259
00:13:39,644 --> 00:13:41,666
He drops,

260
00:13:41,666 --> 00:13:43,648
sorry, he drops loot,

261
00:13:43,648 --> 00:13:45,109
either common, uncommon, or legendary.

262
00:13:45,109 --> 00:13:48,833
So this is the naive initial implementation.

263
00:13:48,833 --> 00:13:50,795
And now I've added,

264
00:13:50,795 --> 00:13:52,456
you saw the previous example of adding

265
00:13:52,456 --> 00:13:55,980
the idea of a pity timer to the legendary case

266
00:13:55,980 --> 00:13:56,500
and making it.

267
00:13:57,102 --> 00:14:02,306
Dynamic here. I'm also adding another consideration that

268
00:14:02,306 --> 00:14:05,029
I've heard of real MMOs running into

269
00:14:05,029 --> 00:14:06,050
with loot drops, which is

270
00:14:06,050 --> 00:14:11,974
Hey, that loot drop is an important input to the economy of a game

271
00:14:11,974 --> 00:14:15,317
if the distribution

272
00:14:15,317 --> 00:14:19,561
So in this example the first naive approach we basically

273
00:14:19,561 --> 00:14:26,326
run this for a while on our MMO and then design comes to us with a problem and says we have a problem because the

274
00:14:27,670 --> 00:14:30,871
the loot, legendary loot for the knight class

275
00:14:30,871 --> 00:14:32,992
is worth a lot more on the auction house

276
00:14:32,992 --> 00:14:35,552
than the legendary loot for the ninja class.

277
00:14:35,552 --> 00:14:36,953
And we need to change that.

278
00:14:36,953 --> 00:14:39,593
So suddenly, how do you respond to that ask?

279
00:14:39,593 --> 00:14:42,434
I would suggest you use the weighted lookup table

280
00:14:42,434 --> 00:14:46,135
and make a new, sorry, the nested nature of lookup tables

281
00:14:46,135 --> 00:14:49,836
and make a new sub lookup table for the legendary case

282
00:14:49,836 --> 00:14:52,917
that also says not only do we have this pity timer element,

283
00:14:52,917 --> 00:14:55,958
but we have a way to weight the

284
00:14:57,214 --> 00:15:00,876
loot for the different classes based on the player distribution, the popularity of those

285
00:15:00,876 --> 00:15:01,276
classes.

286
00:15:01,276 --> 00:15:06,579
Because of course, supply and demand, you're controlling the supply of loot to an economy

287
00:15:06,579 --> 00:15:07,780
and the demand goes up.

288
00:15:07,780 --> 00:15:15,384
That's a real case I've run into and there can be, you can respond to unexpected cases

289
00:15:15,384 --> 00:15:18,826
with cleanly and elegantly and with maintainable code.

290
00:15:19,600 --> 00:15:21,560
by using something like a weighted lookup table.

291
00:15:21,560 --> 00:15:23,320
So I recommend them as a tool.

292
00:15:23,320 --> 00:15:25,121
And here I kind of run through an example of,

293
00:15:25,121 --> 00:15:26,221
okay, we're hitting, we're hitting,

294
00:15:26,221 --> 00:15:29,602
and you're seeing the weight go up on the legendary case

295
00:15:29,602 --> 00:15:33,323
until eventually it finally hits the legendary case.

296
00:15:33,323 --> 00:15:34,643
Who knows how long it would take,

297
00:15:34,643 --> 00:15:36,003
but the chances get higher and higher

298
00:15:36,003 --> 00:15:37,783
the longer they keep missing it.

299
00:15:37,783 --> 00:15:40,764
And then it would step through to the next level of lookup

300
00:15:40,764 --> 00:15:43,205
and say, roll another random number.

301
00:15:43,205 --> 00:15:45,665
Each of these diamonds basically

302
00:15:45,665 --> 00:15:47,125
represents a random number roll.

303
00:15:50,647 --> 00:15:54,891
So finally it resolves, and once it does,

304
00:15:54,891 --> 00:15:57,794
the weighted, sorry, the weight

305
00:15:57,794 --> 00:15:58,574
of the legendary lookup resets.

306
00:15:58,574 --> 00:16:03,359
So weighted lookup tables can be a really powerful tool.

307
00:16:03,359 --> 00:16:06,081
They can really represent any other type of randomness

308
00:16:06,081 --> 00:16:09,184
you'd want to do, including the simpler cases.

309
00:16:09,184 --> 00:16:13,288
So they can be fit into this nested tree-like structure

310
00:16:13,288 --> 00:16:15,931
very cleanly, and again, in a maintainable way.

311
00:16:16,898 --> 00:16:24,660
All right, so I wanted to expand on something that Squirrel touched on, which is he was

312
00:16:24,660 --> 00:16:32,822
giving some examples of using his Squirrel noise library to do different random hashing

313
00:16:32,822 --> 00:16:37,464
and specifically had some impressive examples of randomly generating a world.

314
00:16:40,250 --> 00:16:47,034
Yeah, and I wanted to, we decided that I could get into how hashing could be a solution to

315
00:16:47,034 --> 00:16:55,640
solve a specific problem in RNG, or an RNG-related problem, which is the possibility of having

316
00:16:55,640 --> 00:16:59,343
deep echoes in that kind of world, and I should, I'll explain what that means.

317
00:17:01,206 --> 00:17:04,628
So here's another live case of something strange in a live game.

318
00:17:04,628 --> 00:17:09,751
Some players commenting on the fact that they're wandering through the different random worlds

319
00:17:09,751 --> 00:17:16,135
and they came across a city that looked familiar that they had come across in some other random

320
00:17:16,135 --> 00:17:16,495
world.

321
00:17:16,495 --> 00:17:23,779
This is possible because usually in these games you roll a seed and give that to the

322
00:17:23,779 --> 00:17:28,182
city, and the city generates its content from its random seed, puts that into a random number

323
00:17:28,182 --> 00:17:28,622
generator.

324
00:17:30,014 --> 00:17:33,836
and generates all of its content.

325
00:17:33,836 --> 00:17:36,837
In this case, we have a universe.

326
00:17:36,837 --> 00:17:37,937
So I have an example.

327
00:17:37,937 --> 00:17:42,099
I called it the zombie universe, where I said at the top level,

328
00:17:42,099 --> 00:17:45,740
we'll have a seed on the universe.

329
00:17:45,740 --> 00:17:51,783
Of course, that's just 42 as a nerdy reference.

330
00:17:51,783 --> 00:17:54,564
It uses that to generate a series of children,

331
00:17:54,564 --> 00:17:56,365
the next layer down, which are galaxies.

332
00:17:56,752 --> 00:18:02,038
which then generate solar systems, which each generate planets within the solar system,

333
00:18:02,038 --> 00:18:06,563
and then cities, and there's another layer not shown here in my example of villagers.

334
00:18:07,472 --> 00:18:14,898
So, what I'm highlighting in red here is the odd case you could run across if you're doing this.

335
00:18:14,898 --> 00:18:18,741
First of all, to make it clear, the seed on the top level, on each level,

336
00:18:18,741 --> 00:18:25,366
is used in the generation of the seeds for the members of the next level, the random galaxy.

337
00:18:25,366 --> 00:18:31,631
Each random galaxy has a seed and that comes out of the RNG of the level above it.

338
00:18:32,360 --> 00:18:37,543
So the problem that happens there is that eventually there's a chance of the random

339
00:18:37,543 --> 00:18:40,325
seed being used twice in two different cases.

340
00:18:40,325 --> 00:18:46,669
And if everything beneath it is also generated as a product of that seed, you're going to

341
00:18:46,669 --> 00:18:49,151
start to see that everything is the same.

342
00:18:49,151 --> 00:18:53,234
So in this case, everything in these two different solar systems is identical.

343
00:18:53,234 --> 00:18:56,196
On all the planets in that solar system.

344
00:18:56,607 --> 00:19:01,934
all the cities in them, all the cities have the villagers of the same name and occupation.

345
00:19:01,934 --> 00:19:05,318
However we would be randomly, whatever we would be randomly generating,

346
00:19:05,318 --> 00:19:08,501
we now have an echo in a game that's supposed to be noisy and

347
00:19:08,501 --> 00:19:09,903
random and unpredictable.

348
00:19:09,903 --> 00:19:13,487
Suddenly we have the exact opposite.

349
00:19:13,487 --> 00:19:13,608
So...

350
00:19:15,160 --> 00:19:18,522
We spent, I was working on this even last night,

351
00:19:18,522 --> 00:19:22,165
that we finally got to what I consider,

352
00:19:22,165 --> 00:19:24,247
to a solution, a resolution.

353
00:19:24,247 --> 00:19:26,088
There are still some caveats with it,

354
00:19:26,088 --> 00:19:28,390
but I wanna share some of what we discovered

355
00:19:28,390 --> 00:19:30,371
trying to dig in and solve that problem,

356
00:19:30,371 --> 00:19:32,573
specifically using random hashing as a tool,

357
00:19:32,573 --> 00:19:35,936
which did end up being the best solution for our purposes.

358
00:19:38,097 --> 00:19:41,319
So, essentially, let me show you real fast.

359
00:19:41,319 --> 00:19:47,963
I have stepped out into Unity and I have an example of project running with this problem.

360
00:19:47,963 --> 00:19:49,604
I hope everyone can see this okay.

361
00:19:52,506 --> 00:19:54,367
It takes a second to generate.

362
00:19:54,367 --> 00:19:58,111
Most of that time is going to the checks I'm doing for random echoes.

363
00:19:58,111 --> 00:20:06,678
So yeah, nested structure, solar systems contain planets, planets contain cities, cities contain

364
00:20:06,678 --> 00:20:07,179
villagers.

365
00:20:07,179 --> 00:20:12,944
It's a zombie universe, so they're all named Rargba, Agba, Abga, Urga.

366
00:20:14,005 --> 00:20:17,407
I can just keep reading these if it makes you laugh that much.

367
00:20:17,407 --> 00:20:22,189
Burr, that must be a cold, must be on the North Pole.

368
00:20:22,189 --> 00:20:25,671
So yes, we spent a lot of time trying

369
00:20:25,671 --> 00:20:27,652
to get around this problem.

370
00:20:27,652 --> 00:20:31,053
And you'll see that there are still cases of cities

371
00:20:31,053 --> 00:20:32,334
that have the same seed.

372
00:20:37,359 --> 00:20:41,643
I think cities that have the same name or seed.

373
00:20:41,643 --> 00:20:43,705
In this case, here's a check I was doing

374
00:20:43,705 --> 00:20:46,888
that they might have the same seed.

375
00:20:46,888 --> 00:20:49,911
I won't try to get it working again right now.

376
00:20:49,911 --> 00:20:52,694
The point was that we ended up

377
00:20:52,694 --> 00:20:55,236
following a different algorithm.

378
00:20:56,368 --> 00:21:04,116
to generate the layer below it, which is not based solely on the seed or any other data given to it by the layer above,

379
00:21:04,116 --> 00:21:07,920
which presents, prevents the echo from carrying down.

380
00:21:10,175 --> 00:21:12,696
So we go ahead and use, say I'm generating a planet,

381
00:21:12,696 --> 00:21:15,358
I go ahead and generate the content of that planet.

382
00:21:15,358 --> 00:21:19,941
In this example, that's just the name based on the seed.

383
00:21:19,941 --> 00:21:21,162
To generate the child elements,

384
00:21:21,162 --> 00:21:23,183
I want to use some other seed that,

385
00:21:23,183 --> 00:21:27,285
or some, a seed that is a product of something

386
00:21:27,285 --> 00:21:32,549
actually unique to that planet or other element.

387
00:21:32,549 --> 00:21:33,829
So in this example, you can also see

388
00:21:33,829 --> 00:21:35,250
there's these seed values.

389
00:21:37,303 --> 00:21:39,125
but there's also an index value.

390
00:21:39,125 --> 00:21:41,387
Very simple, I have three children,

391
00:21:41,387 --> 00:21:43,789
they have indexes of zero, one, and two,

392
00:21:43,789 --> 00:21:46,411
but then I can use that to uniquely identify,

393
00:21:46,411 --> 00:21:46,751
say, this planet.

394
00:21:46,751 --> 00:21:47,011
In fact,

395
00:21:47,011 --> 00:21:50,634
yeah, here's two planets that came out with the same name.

396
00:21:50,634 --> 00:21:51,194
Oh, but not the same seed.

397
00:22:04,235 --> 00:22:06,216
Okay, I won't worry about looking for one,

398
00:22:06,216 --> 00:22:10,418
but the point is that you can use the index of your layer

399
00:22:10,418 --> 00:22:13,580
recursively up the chain up to the top layer

400
00:22:13,580 --> 00:22:16,001
to say, well, this uniquely identifies me.

401
00:22:16,001 --> 00:22:19,283
Now, at first, my solution to this that I had 24 hours ago,

402
00:22:19,283 --> 00:22:22,765
but that we weren't quite happy with was to say,

403
00:22:22,765 --> 00:22:27,607
let's pre-generate all the seeds everywhere up front

404
00:22:27,607 --> 00:22:30,549
and guarantee uniqueness with a brute force approach.

405
00:22:30,549 --> 00:22:32,910
That wasn't something I wanted to resort to, for one thing.

406
00:22:34,309 --> 00:22:40,212
We also put a restriction on how many children each layer could have, a max index.

407
00:22:40,212 --> 00:22:45,595
And then we could unique, as long as we didn't achieve an overflow,

408
00:22:45,595 --> 00:22:51,378
we could take the unique indices and essentially add them together,

409
00:22:51,378 --> 00:22:56,321
multiplying, basically treat it as a base, instead of a base 2 number,

410
00:22:56,321 --> 00:23:02,804
a base 10 number, a base max index number, and build a unique integer.

411
00:23:03,295 --> 00:23:07,225
that represented the unique address,

412
00:23:07,225 --> 00:23:10,252
the recursive index of that element.

413
00:23:10,252 --> 00:23:12,718
And then once we had that, we could look up.

414
00:23:13,287 --> 00:23:17,069
use that as a lookup to a bunch of, again, unique random numbers.

415
00:23:17,069 --> 00:23:21,151
That was clumsy because it put some restrictions in place.

416
00:23:21,151 --> 00:23:25,293
What we found was better was to take a random hash and to go ahead and take this

417
00:23:25,293 --> 00:23:29,455
n-dimensional address, I should call it, based on

418
00:23:29,455 --> 00:23:32,277
the things index, and go ahead and put that into

419
00:23:32,277 --> 00:23:37,259
a hash function, one specifically, one of the ones that Squirrel

420
00:23:37,259 --> 00:23:38,099
showed you earlier.

421
00:23:41,737 --> 00:23:42,837
Yeah, here I'm...

422
00:23:42,837 --> 00:23:45,119
Yeah, this code may not be obvious or self-explanatory

423
00:23:45,119 --> 00:23:47,101
if you don't know, like, link in C-sharp,

424
00:23:47,101 --> 00:23:49,802
but this is taking all the layers,

425
00:23:49,802 --> 00:23:52,084
putting them together into an array,

426
00:23:52,084 --> 00:23:53,925
and passing that into a hash function

427
00:23:53,925 --> 00:23:57,708
that can take an arbitrary number of ints and a seed

428
00:23:57,708 --> 00:24:00,510
and give you an output that is...

429
00:24:01,691 --> 00:24:05,775
Similar to a big random lookup of unique numbers,

430
00:24:05,775 --> 00:24:09,639
a big unique, yeah, a big lookup of unique random numbers,

431
00:24:09,639 --> 00:24:13,162
but uniqueness is not guaranteed in this case.

432
00:24:13,162 --> 00:24:16,085
So there is still a possibility of collision.

433
00:24:16,085 --> 00:24:19,668
But by making it so that I, as a planet,

434
00:24:19,668 --> 00:24:21,029
generate my content.

435
00:24:21,550 --> 00:24:24,472
but based on the seed I was given by my parent.

436
00:24:24,472 --> 00:24:26,273
But when I generate the next layer down,

437
00:24:26,273 --> 00:24:29,516
I'm not using something that came down the chain.

438
00:24:29,516 --> 00:24:33,339
I'm using something unique to me.

439
00:24:33,339 --> 00:24:34,560
When I generate the next layer,

440
00:24:34,560 --> 00:24:36,201
that breaks the deep echoes

441
00:24:36,201 --> 00:24:38,263
from propagating down the hierarchy.

442
00:24:39,925 --> 00:24:46,249
And here's the initializeChildren method that actually goes and gets that seed.

443
00:24:46,249 --> 00:24:52,233
Actually, here I'm using the seed from the top level of the universe.

444
00:24:52,233 --> 00:24:56,495
Whenever I generate the seed for a particular thing, say a planet,

445
00:24:56,495 --> 00:24:59,697
this type could be planet or villager or whatever.

446
00:24:59,697 --> 00:25:04,120
Villager wouldn't call this function because it doesn't have any children.

447
00:25:04,120 --> 00:25:08,603
But in actuality, when I was using it, I found, well,

448
00:25:11,215 --> 00:25:15,759
I needed to change these seeds per,

449
00:25:15,759 --> 00:25:19,503
have a unique seed per layer that I did pre-generate

450
00:25:19,503 --> 00:25:20,404
for each type of thing.

451
00:25:20,404 --> 00:25:22,946
So basically my.

452
00:25:25,305 --> 00:25:29,047
planets would end up with the same name if they had the same,

453
00:25:29,047 --> 00:25:35,512
if they were the very first planet or had the zero index.

454
00:25:35,512 --> 00:25:39,774
Okay. So here's an example of, yeah,

455
00:25:39,774 --> 00:25:42,356
of what you get now, which is, Hey,

456
00:25:42,356 --> 00:25:46,459
there can be two solar systems that have the same random seed on them,

457
00:25:46,459 --> 00:25:50,221
but they don't have the same content under them.

458
00:25:50,221 --> 00:25:52,343
The echo does not persist.

459
00:25:54,204 --> 00:25:57,445
And I should explain why that's significant because now,

460
00:25:57,445 --> 00:25:59,886
of course you don't want the same thing

461
00:25:59,886 --> 00:26:01,286
appearing in different parts of your universe.

462
00:26:01,286 --> 00:26:02,607
Now you can have the same thing.

463
00:26:02,607 --> 00:26:04,087
Collisions are going to occur.

464
00:26:04,087 --> 00:26:06,348
Unless you have a perfect hashing function,

465
00:26:06,348 --> 00:26:08,608
which doesn't really exist,

466
00:26:08,608 --> 00:26:11,889
you're going to end up with the same seed existing

467
00:26:11,889 --> 00:26:13,630
on the same object somewhere in the world.

468
00:26:13,630 --> 00:26:14,870
What you want is for it to not persist,

469
00:26:14,870 --> 00:26:17,071
and especially, it's all about player perception

470
00:26:17,071 --> 00:26:17,691
in the end, right?

471
00:26:17,691 --> 00:26:19,611
If they don't perceive it as random or...

472
00:26:20,318 --> 00:26:22,120
uh... samey than it's not

473
00:26:22,120 --> 00:26:26,124
specifically so i could generate a city

474
00:26:26,124 --> 00:26:28,706
maybe has the same layout of roads but if it

475
00:26:28,706 --> 00:26:30,187
its contents are completely different

476
00:26:30,187 --> 00:26:33,751
the player might not even notice that this one superficial thing that makes

477
00:26:33,751 --> 00:26:34,711
the city unique

478
00:26:34,711 --> 00:26:38,235
is the same as this other city because everything outside of it is different on

479
00:26:38,235 --> 00:26:39,316
a higher level

480
00:26:39,316 --> 00:26:43,219
everything inside of it is different because we've now broken up the deep echo

481
00:26:43,219 --> 00:26:44,300
so uh...

482
00:26:45,361 --> 00:26:49,182
That's important and it is a problem.

483
00:26:49,182 --> 00:26:50,863
I don't think there's a...

484
00:26:50,863 --> 00:26:53,864
So I forgot to explain an important part of this example I'm showing you.

485
00:26:53,864 --> 00:26:56,965
You may have noticed all the seeds are very low.

486
00:26:56,965 --> 00:27:02,906
I'm of course trying to force this problem to happen by limiting all the seeds to be

487
00:27:02,906 --> 00:27:04,487
between 0 and 64 or 0 and 63, I should say.

488
00:27:04,487 --> 00:27:09,628
So that exacerbates the problem and really makes it clear that essentially...

489
00:27:11,355 --> 00:27:16,305
Well, first of all I should let you know the caveat of this solution of using random hashes.

490
00:27:16,305 --> 00:27:20,774
Once we moved away from a true, unique lookup table, we had a new problem.

491
00:27:23,077 --> 00:27:27,781
which is that essentially when I generate that lower layer,

492
00:27:27,781 --> 00:27:29,342
yes, I'm generating a seed from it,

493
00:27:29,342 --> 00:27:31,103
I'm getting it as a hash,

494
00:27:31,103 --> 00:27:32,905
or I'm getting it from a hash function,

495
00:27:32,905 --> 00:27:35,988
but again, there can be collisions in that hash function.

496
00:27:35,988 --> 00:27:38,790
So we now do have a possibility that two solar systems

497
00:27:38,790 --> 00:27:43,234
can contain a set of planets that are basically the same.

498
00:27:43,234 --> 00:27:45,676
They have the same name in my example,

499
00:27:45,676 --> 00:27:50,740
or they would have the same position in some other example.

500
00:27:50,740 --> 00:27:51,421
Again, hopefully,

501
00:27:53,068 --> 00:27:54,449
Yeah, this seems pretty bad.

502
00:27:54,449 --> 00:27:57,690
Like for a planet to have the same set of cities

503
00:27:57,690 --> 00:28:01,192
with the same names is pretty obviously samey to me.

504
00:28:01,192 --> 00:28:03,473
So it seems like, yeah.

505
00:28:03,473 --> 00:28:06,474
For the broad echoes problem, as I call this,

506
00:28:06,474 --> 00:28:09,735
I'm leaving the solution as an exercise for the viewer,

507
00:28:09,735 --> 00:28:11,596
which means we ran out of time.

508
00:28:11,596 --> 00:28:13,076
I literally got to this point last night

509
00:28:13,076 --> 00:28:15,277
in digging through the problem.

510
00:28:15,277 --> 00:28:17,738
I don't think, there is not a perfect solution.

511
00:28:18,764 --> 00:28:21,466
for the problem because of essentially

512
00:28:21,466 --> 00:28:23,207
the mathematical nature of if you

513
00:28:23,207 --> 00:28:27,530
have a function with a larger number of potential inputs

514
00:28:27,530 --> 00:28:29,551
than the potential outputs, you're

515
00:28:29,551 --> 00:28:31,332
always going to have the pigeonholing problem.

516
00:28:31,332 --> 00:28:31,853
If you have.

517
00:28:32,645 --> 00:28:34,286
more pigeons than you have holes,

518
00:28:34,286 --> 00:28:36,687
eventually two pigeons are gonna go in the same hole.

519
00:28:36,687 --> 00:28:39,469
So one way or another, you're going to run into this.

520
00:28:39,469 --> 00:28:42,931
Pre-generating, either at startup or at compile time,

521
00:28:42,931 --> 00:28:46,333
a list of a bunch of seeds that you can be certain

522
00:28:46,333 --> 00:28:48,995
are unique works, although again,

523
00:28:48,995 --> 00:28:51,777
if you have a need for more output numbers,

524
00:28:51,777 --> 00:28:53,738
given the limits of like a 32-bit int,

525
00:28:53,738 --> 00:28:56,120
if that's beyond your limitations,

526
00:28:56,120 --> 00:28:57,981
you're still going to run into collisions.

527
00:28:57,981 --> 00:28:59,642
But I think we've shown here.

528
00:29:01,053 --> 00:29:05,014
how you can keep a technique for using the uniqueness

529
00:29:05,014 --> 00:29:07,115
of a thing itself to keep the hierarchy

530
00:29:07,115 --> 00:29:09,155
from persisting down.

531
00:29:09,155 --> 00:29:11,356
It looks like I'm about out of time,

532
00:29:11,356 --> 00:29:14,957
but I do wanna recommend two other articles I ran across

533
00:29:14,957 --> 00:29:17,558
that were very useful in pointing out these.

534
00:29:18,529 --> 00:29:20,890
tools and recommend

535
00:29:20,890 --> 00:29:27,975
They recommend some other ways to use these Dan cook of on his lost garden blog had a really good

536
00:29:27,975 --> 00:29:34,199
Post about loot drop tables and how they can be nested and he did them more justice than I go there for more details on

537
00:29:34,199 --> 00:29:37,221
That technique there was also a great blog on

538
00:29:37,221 --> 00:29:43,084
Unity's blog about using repeatable random numbers and noise and

539
00:29:43,084 --> 00:29:46,387
Hashing which it really opened my eyes to how powerful that tool was

540
00:29:47,072 --> 00:29:51,696
And you can go there to find out more about those.

541
00:29:51,696 --> 00:29:52,737
Yeah.

542
00:29:52,737 --> 00:29:55,599
And I will put, I'll go ahead and share this example on,

543
00:29:55,599 --> 00:29:58,862
what's the name of the website?

544
00:29:58,862 --> 00:30:00,123
Math4GameProgrammers.com.

545
00:30:00,123 --> 00:30:00,323
Yeah.

546
00:30:00,323 --> 00:30:00,764
Thanks a lot.

