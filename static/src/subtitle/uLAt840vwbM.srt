1
00:00:06,042 --> 00:00:10,184
Welcome to Virtual GDC and my talk, Bringing Replays to World of Tanks Mercenaries.

2
00:00:11,705 --> 00:00:15,727
This talk will discuss what it took to get a full replay system working on World of Tanks

3
00:00:15,767 --> 00:00:22,710
Mercenaries on the consoles and how we replicate our full match on a live client.

4
00:00:23,891 --> 00:00:27,292
I'm Andrew Gover, Lead Software Engineer at Wargaming Sydney and I was part of the team

5
00:00:27,312 --> 00:00:32,995
that developed this system along with our colleagues in Wargaming Chicago, Baltimore

6
00:00:33,115 --> 00:00:34,556
who developed World of Tanks Mercenaries.

7
00:00:36,761 --> 00:00:42,003
So what we're going to go over today is a grounding of how we record, how we make sure

8
00:00:42,064 --> 00:00:43,624
our recordings are ready to play on the client.

9
00:00:44,905 --> 00:00:49,667
And then the majority of the talk will be on how all of the challenges we had in getting

10
00:00:50,528 --> 00:00:52,669
the replays to actually function on the client.

11
00:00:53,609 --> 00:00:57,391
And then we'll do a quick overview of how replays will help you in development and the

12
00:00:57,431 --> 00:01:01,593
future challenges that we decided we weren't going to do due to the complexity.

13
00:01:04,197 --> 00:01:09,559
So World of Tanks Mercenaries is a tactical arena tanks combat game on the consoles, the

14
00:01:09,639 --> 00:01:11,940
console version of World of Tanks on PC.

15
00:01:13,201 --> 00:01:17,923
And it had been live for approximately four years by the time we decided to integrate

16
00:01:17,943 --> 00:01:18,763
the replays feature.

17
00:01:19,643 --> 00:01:24,606
And this meant a build-up of a lot of assumptions and workarounds in the code that meant replays

18
00:01:24,646 --> 00:01:27,007
really challenged them and broke them.

19
00:01:28,607 --> 00:01:33,730
The integration took about three and a half years, three and a half months, sorry, for

20
00:01:33,870 --> 00:01:33,890
a...

21
00:01:35,122 --> 00:01:40,845
three-person team and it was mostly an engine we hadn't actually worked with before.

22
00:01:41,685 --> 00:01:48,349
So I hope that this talk will really help to allow you to get, do that faster and move

23
00:01:48,389 --> 00:01:48,989
forward quicker.

24
00:01:51,830 --> 00:01:52,671
So what is a replay?

25
00:01:53,231 --> 00:01:54,932
A replay is more than just a video recording.

26
00:01:55,612 --> 00:02:00,194
It's where the players can watch that sick flip from that, where they jumped off that

27
00:02:00,254 --> 00:02:03,076
cliff at any time, at any point.

28
00:02:04,407 --> 00:02:07,228
It's not just theirs, but also everyone else's.

29
00:02:07,708 --> 00:02:10,990
So any sick flips or multi-kills that happen during the game,

30
00:02:11,170 --> 00:02:14,071
they can watch anytime, anywhere, from any perspective.

31
00:02:16,072 --> 00:02:18,453
And this is really distinct from the console's

32
00:02:18,493 --> 00:02:20,074
built-in recording functionality,

33
00:02:20,634 --> 00:02:23,575
in that it allows you to view from everywhere.

34
00:02:23,595 --> 00:02:25,917
It's not just what you did previously,

35
00:02:26,237 --> 00:02:28,378
but what everyone did everywhere.

36
00:02:31,479 --> 00:02:32,460
So why do we want Replace?

37
00:02:33,915 --> 00:02:38,559
While they're great for reminiscing about the past, people love to see how they dominated

38
00:02:38,599 --> 00:02:38,919
a match.

39
00:02:40,160 --> 00:02:44,023
And it's really good for driving engagement outside of the gameplay loop, so getting videos

40
00:02:44,084 --> 00:02:45,405
up to YouTube or Twitch.

41
00:02:46,686 --> 00:02:53,111
And also eSports is another really big area where replays can really help in driving that

42
00:02:53,151 --> 00:02:53,912
player engagement.

43
00:02:54,893 --> 00:02:55,754
And if none of that is...

44
00:02:56,705 --> 00:03:02,328
of importance to you, then even just the in-house development testing that can really help from

45
00:03:02,408 --> 00:03:04,069
replays is worth it alone.

46
00:03:06,190 --> 00:03:09,772
So before we get into integrating all this cool stuff into our client, let's get a bit

47
00:03:09,792 --> 00:03:14,134
of understanding of how we record the replays and how we play them back and distribute them.

48
00:03:15,895 --> 00:03:17,516
So there are two types of recording you can do.

49
00:03:18,156 --> 00:03:19,797
There's server-side, which is what we did.

50
00:03:20,999 --> 00:03:24,700
which is where we have a single recording per match recorded on the server that has

51
00:03:25,020 --> 00:03:28,081
the entire world saved into the replay.

52
00:03:29,962 --> 00:03:33,343
This of course lacks a bit of the player context because you don't understand what exactly

53
00:03:33,423 --> 00:03:34,103
the player was doing.

54
00:03:34,504 --> 00:03:39,685
This is where client-side replays come in and they know the understanding of the full

55
00:03:39,725 --> 00:03:44,527
player context, but there's no understanding of what happens in the wider world.

56
00:03:46,027 --> 00:03:47,468
A well-designed network game.

57
00:03:48,188 --> 00:03:52,570
won't have the greater understanding of what's happening outside of what the player can actually view.

58
00:03:53,530 --> 00:03:58,252
So we went with server-side recordings and that's primarily what we'll be talking about here,

59
00:03:58,973 --> 00:04:02,955
but a lot of the things we discuss actually work with playing back on client-side replays as well.

60
00:04:05,976 --> 00:04:10,038
So when we do the recording, we have a very common capture technique

61
00:04:10,278 --> 00:04:14,020
in that we grab the properties and the events before we send them from the server to the client.

62
00:04:15,640 --> 00:04:21,183
This is opposed to capturing data as it comes into the server and using determinism to play

63
00:04:21,203 --> 00:04:24,945
it back, primarily due to the fact that World of Tanks is not deterministic.

64
00:04:26,406 --> 00:04:31,829
And it also means that we can create better debugging tools in order to read those sort

65
00:04:31,849 --> 00:04:33,850
of replays from that perspective.

66
00:04:37,003 --> 00:04:39,784
really into the how we record because it's a rather common technique.

67
00:04:40,364 --> 00:04:43,466
So if you need more information there are GDC talks

68
00:04:43,886 --> 00:04:47,547
on this already or just look up how Unreal does its

69
00:04:47,907 --> 00:04:49,648
recording because the techniques are very similar.

70
00:04:52,409 --> 00:04:55,831
For the rest of it the recording is backed up to an extra service so our

71
00:04:55,851 --> 00:05:00,433
recordings are always fairly stable and once the match is done we upload it

72
00:05:00,533 --> 00:05:03,954
to a Amazon like CDN using CPH service.

73
00:05:05,599 --> 00:05:09,582
And once that's completed, we add an entry to our catalog, so therefore it's searchable

74
00:05:10,203 --> 00:05:10,944
by all the players.

75
00:05:12,645 --> 00:05:16,549
Once the players want to have to find it, they send an ElastiSearch query through the

76
00:05:16,569 --> 00:05:18,011
server to the catalog.

77
00:05:18,911 --> 00:05:26,218
The catalog then returns the link to the location on the CDN, and the players are able to download

78
00:05:26,238 --> 00:05:27,299
that straight to their machines.

79
00:05:29,562 --> 00:05:30,663
Playback is the simple part.

80
00:05:31,621 --> 00:05:34,303
All we're doing is creating a fake server connection to the replay file.

81
00:05:35,003 --> 00:05:39,946
So the replay file just sends the messages, is read and sends the messages through to the real game.

82
00:05:40,286 --> 00:05:43,248
And the game doesn't actually really understand that a replay is playing.

83
00:05:43,988 --> 00:05:47,910
For all it's concerned, it's actually playing back live messages from a server.

84
00:05:48,851 --> 00:05:52,713
This means that we're not having to affect the client very much at all.

85
00:05:54,174 --> 00:05:57,976
And therefore we get the playback almost for free.

86
00:06:00,600 --> 00:06:02,041
But that doesn't solve all of the problems.

87
00:06:02,501 --> 00:06:06,665
This is where all of the challenges we had to overcome came in,

88
00:06:07,126 --> 00:06:11,189
and that's getting the client to work with the replays playing back

89
00:06:11,610 --> 00:06:13,691
in a whole bunch of different circumstances

90
00:06:13,792 --> 00:06:15,673
based on assumptions that no longer hold true.

91
00:06:17,435 --> 00:06:21,959
So I hope that if you have a game, then this will be a sort of cheat sheet

92
00:06:22,119 --> 00:06:23,020
that allows you to...

93
00:06:24,092 --> 00:06:27,393
know exactly what to do should you encounter a problem, and if you're just starting out

94
00:06:27,914 --> 00:06:32,396
then this is really advice on how to defensively code your systems so that you can have a much

95
00:06:32,456 --> 00:06:33,357
smoother integration.

96
00:06:35,138 --> 00:06:39,180
So the first point I'll make is our goal is to edit the client as little as possible,

97
00:06:39,620 --> 00:06:43,042
so that replays aren't a specialized thing.

98
00:06:43,883 --> 00:06:47,745
That won't always hold true as we'll find out, but in general we're trying to make it

99
00:06:47,845 --> 00:06:53,188
so that replays aren't something the client knows about, it's just something that happens.

100
00:06:55,982 --> 00:06:59,844
So what did we support? Well we supported being able to access all of the replays

101
00:07:01,044 --> 00:07:03,845
by browsing for them, such as a Netflix style system,

102
00:07:04,865 --> 00:07:08,907
speeding up and slowing down time, as well as jumping forwards and backwards through time.

103
00:07:10,728 --> 00:07:16,690
We have our free cameras as well as our cameras that attach around the player. And we also support

104
00:07:17,150 --> 00:07:21,992
being able to see through the player's vision, so we do have partial player context there on

105
00:07:22,032 --> 00:07:25,493
our server-side replays. We also have a highlight system.

106
00:07:26,262 --> 00:07:29,364
and entire feature parity across all of our supported consoles.

107
00:07:31,126 --> 00:07:32,707
So let's get some definitions down first.

108
00:07:33,487 --> 00:07:34,148
Time flow

109
00:07:34,168 --> 00:07:39,572
is the playback rate at which we're playing the replay.

110
00:07:40,732 --> 00:07:44,935
So we go from about 10% speed up to about 800% speed and that's

111
00:07:44,995 --> 00:07:49,439
important because having limits is really important. If you go too fast, as

112
00:07:49,479 --> 00:07:50,639
we found going beyond 800%

113
00:07:52,321 --> 00:07:55,463
is that stuff like your physics systems will break when you do that.

114
00:07:57,952 --> 00:08:01,574
The main thing that this requires is that your update loops have variable deltas so

115
00:08:01,594 --> 00:08:04,355
that you can change the flow of time flowing through your systems.

116
00:08:04,575 --> 00:08:09,658
Any assumptions built around a certain frame rate will not work properly once you scale

117
00:08:09,698 --> 00:08:09,938
time.

118
00:08:11,419 --> 00:08:16,521
Time jumping on the other hand is the ability to go directly from time A to time B without

119
00:08:17,282 --> 00:08:18,543
showing the intervening frames.

120
00:08:19,643 --> 00:08:20,544
So jumping forward here.

121
00:08:21,404 --> 00:08:22,785
This is where most of your problems occur.

122
00:08:23,545 --> 00:08:26,107
The flow is fine when you're...

123
00:08:27,621 --> 00:08:29,483
just got your update deltas going, but

124
00:08:30,143 --> 00:08:32,725
jumping through time is a concept that's not really

125
00:08:33,386 --> 00:08:34,707
something that's totally supported.

126
00:08:35,547 --> 00:08:38,470
If you have a join in progress mechanic, the ideas are similar

127
00:08:39,371 --> 00:08:42,773
but you will still probably mostly encounter your issues around jumping

128
00:08:42,793 --> 00:08:43,214
through time.

129
00:08:44,255 --> 00:08:44,955
So let's get into it.

130
00:08:45,996 --> 00:08:46,616
Our first problem.

131
00:08:47,517 --> 00:08:49,479
Straight off the bat, we had the replays playing back.

132
00:08:50,019 --> 00:08:53,842
We started playing one, thought it was good, we paused, we hit the menu and we

133
00:08:53,882 --> 00:08:54,423
couldn't do anything.

134
00:08:56,437 --> 00:09:00,321
This is down to the fact that the pause was affecting the entire game.

135
00:09:02,082 --> 00:09:05,405
From moving through the menu system to everything else,

136
00:09:05,705 --> 00:09:08,128
there was no concept of a split.

137
00:09:09,629 --> 00:09:10,830
So what we needed to do

138
00:09:12,351 --> 00:09:15,474
was to split up how our updates were affected.

139
00:09:15,874 --> 00:09:20,178
So anything for gameplay was modified by our playback rate delta.

140
00:09:20,298 --> 00:09:23,381
Things like animations, particles, physics.

141
00:09:24,555 --> 00:09:29,196
They all needed to be able to be slowed down, but things like our UI and any system timers

142
00:09:29,576 --> 00:09:31,836
for things like resource loading or spawning

143
00:09:33,196 --> 00:09:35,077
all wanted to flow at the original rate.

144
00:09:35,877 --> 00:09:38,657
So the idea is to split between gameplay and systems

145
00:09:39,277 --> 00:09:40,438
and this will get you around that problem.

146
00:09:43,338 --> 00:09:45,459
The next problem was entity sliding

147
00:09:46,399 --> 00:09:49,819
and this is something that happens when you really slow down

148
00:09:50,199 --> 00:09:51,500
your game to very slow speeds.

149
00:09:53,393 --> 00:09:57,157
So what's happening here is the tank is sliding straight after we come out of a jump

150
00:09:58,138 --> 00:10:04,383
because our network mitigation lag code was always forward predicting.

151
00:10:05,784 --> 00:10:08,566
So as soon as it came out of the jump there was no extra frames,

152
00:10:08,706 --> 00:10:12,129
so it was just sliding the way it was going before we started the jump.

153
00:10:13,272 --> 00:10:18,554
And at 10% speed this is especially exacerbated due to the fact we're only running a 10Hz

154
00:10:18,574 --> 00:10:23,616
server at 10% speed, which means we're only getting movement updates every second.

155
00:10:25,096 --> 00:10:26,137
So that's illustrated here.

156
00:10:27,177 --> 00:10:28,778
So the top one is how the real game works.

157
00:10:29,098 --> 00:10:34,680
In World of Tanks we have the benefit of a slow game, and that means we can sit slightly

158
00:10:34,720 --> 00:10:37,781
behind with a natural idea of built-in lag.

159
00:10:38,635 --> 00:10:44,139
So we're always 2.2 seconds behind where the server would assume it is.

160
00:10:45,040 --> 00:10:50,504
And we can move towards that, ensuring a specific flow that follows exactly the way we should.

161
00:10:51,305 --> 00:10:54,627
In a replay, we don't have those extra two frame buffer there.

162
00:10:55,528 --> 00:10:59,250
We're playing at the exact same position as we're reading the messages from.

163
00:10:59,551 --> 00:11:01,332
So it's always forward interpolating.

164
00:11:02,373 --> 00:11:06,876
And as you can see by the yellow line, it's always slightly off from where it should be.

165
00:11:07,835 --> 00:11:11,796
Now re-architecting this would have been quite a significant overhaul

166
00:11:12,836 --> 00:11:16,717
and we have our idea that we don't want to touch the client so much to support replays

167
00:11:16,837 --> 00:11:18,518
so instead we had to come up with a new solution.

168
00:11:20,038 --> 00:11:23,199
And that was to effectively mimic what the real world does.

169
00:11:24,279 --> 00:11:27,199
So when we're reading from our ticked frames from the file

170
00:11:28,700 --> 00:11:30,960
we don't just take the movement from the framework processing

171
00:11:31,120 --> 00:11:34,341
we look two frames ahead and we grab the movement from that.

172
00:11:34,839 --> 00:11:37,501
and then add that in to the movement filters.

173
00:11:38,502 --> 00:11:42,745
This allows for the interpolation to have that information to look forward and it always

174
00:11:42,805 --> 00:11:43,806
flows through correctly.

175
00:11:45,627 --> 00:11:49,210
If you have a game where you're always running at the bleeding edge of your time and you're

176
00:11:49,470 --> 00:11:54,795
relying on forward error prediction or interpolation, you can still use this technique to make sure

177
00:11:54,835 --> 00:11:59,779
it smooths out and you don't have any differences between what the server saw and what the replay

178
00:11:59,819 --> 00:12:00,620
is actually playing back.

179
00:12:05,463 --> 00:12:07,724
So our next one is a jump backwards.

180
00:12:08,444 --> 00:12:10,405
So a jump forwards is relatively simple.

181
00:12:10,505 --> 00:12:13,086
We just play the messages between time A and time B,

182
00:12:14,266 --> 00:12:15,347
and that's what we get.

183
00:12:16,027 --> 00:12:17,607
And we get up to exactly where we need to be.

184
00:12:19,008 --> 00:12:21,329
We can't really go from time B to time A,

185
00:12:21,409 --> 00:12:24,350
because we can't roll back what we've done.

186
00:12:26,150 --> 00:12:31,452
So the solution here is more to make the jump backwards just

187
00:12:31,472 --> 00:12:33,853
to jump forwards, but we do an entire world reset.

188
00:12:36,200 --> 00:12:41,284
Therefore we've shifted the issue from being able to do it to the amount of time it takes

189
00:12:41,344 --> 00:12:41,684
to do it.

190
00:12:42,085 --> 00:12:47,989
So reloading the world naively, if we just completely reload, means that we're going

191
00:12:48,009 --> 00:12:49,450
to have to pay the cost of a full reload.

192
00:12:50,231 --> 00:12:51,672
And that's something we didn't want to have to do.

193
00:12:52,012 --> 00:12:56,916
So we originally had a 30 second load and we got that down to about 4 seconds with some

194
00:12:56,936 --> 00:12:57,737
mitigation steps.

195
00:12:58,537 --> 00:13:04,642
Those being things like making sure we kept all of our assets around between a reload.

196
00:13:05,330 --> 00:13:08,771
So specializing that so any maps, textures, anything is

197
00:13:09,591 --> 00:13:12,472
kept in memory, it's not destroyed like the usual path would.

198
00:13:14,033 --> 00:13:15,814
And also we made sure that

199
00:13:16,454 --> 00:13:18,455
as our world can be destroyed

200
00:13:19,035 --> 00:13:20,095
and things can change

201
00:13:21,176 --> 00:13:22,136
and state is different

202
00:13:23,116 --> 00:13:25,677
we made sure that when we loaded the world we kept a vanilla copy

203
00:13:26,057 --> 00:13:27,538
just stored off to the side

204
00:13:28,318 --> 00:13:30,139
ready to go so that when we did a reset

205
00:13:30,519 --> 00:13:32,460
all we had to do was a simple dump of that.

206
00:13:33,304 --> 00:13:37,566
vanilla world over the top of the modified world, and we're immediately back to the starting

207
00:13:37,606 --> 00:13:38,267
state we needed.

208
00:13:39,367 --> 00:13:45,010
So this cut down our reload times to relatively very quickly.

209
00:13:46,991 --> 00:13:51,253
We just have to make sure that if you have any caching going on, such as putting decals

210
00:13:51,293 --> 00:13:56,016
in your world, or animations playing, or anything else that affects the world visually, that

211
00:13:56,036 --> 00:13:56,816
these things are cleared.

212
00:13:57,436 --> 00:14:01,238
Otherwise, you come back from your reset and your decals are still all over the ground

213
00:14:01,278 --> 00:14:01,578
of your map.

214
00:14:05,742 --> 00:14:11,185
So once we've got our reload properly optimized, we need to do the forward jump and optimize that.

215
00:14:12,105 --> 00:14:17,728
So what we can see here is, off to the left of the graph, there is a massive frame spike.

216
00:14:18,168 --> 00:14:21,509
And we see that that directly correlates to the amount of messages we're processing.

217
00:14:22,510 --> 00:14:29,113
Because during a jump forwards, we are processing all of those messages that are in between the two times.

218
00:14:29,253 --> 00:14:33,515
And if this is a jump backwards from the end of the replay, that's a lot of messages that we have to process.

219
00:14:35,622 --> 00:14:40,544
So in order to get around this, we want to limit the amount of messages we have to actually process during a jump.

220
00:14:42,765 --> 00:14:45,807
So what we did was to break up the messages into special categories.

221
00:14:46,607 --> 00:14:52,190
The first one was dropping all. So these were for messages that we didn't really need to process.

222
00:14:53,831 --> 00:15:00,094
Anything that didn't have a lasting impact on the game, such as any shot traces or flashy particles that are only there for a couple of seconds.

223
00:15:01,634 --> 00:15:04,296
Keep last is more for events that...

224
00:15:05,378 --> 00:15:06,639
have discrete property updates.

225
00:15:07,639 --> 00:15:10,320
Things like movement or health updates

226
00:15:10,540 --> 00:15:14,001
that are sent to the client as absolute numbers.

227
00:15:15,021 --> 00:15:17,662
The final one is the unfortunate category of always

228
00:15:17,742 --> 00:15:19,302
and their messages we always have to play.

229
00:15:20,322 --> 00:15:22,823
Any updates that happen via deltas

230
00:15:23,403 --> 00:15:26,744
or any events that required future events

231
00:15:26,764 --> 00:15:27,604
we'll need to reference

232
00:15:28,144 --> 00:15:29,645
are things that we'll have to always process.

233
00:15:30,725 --> 00:15:32,005
So in order to illustrate that,

234
00:15:33,759 --> 00:15:37,162
Here we have an example of a whole bunch of messages over a couple of frames.

235
00:15:39,203 --> 00:15:44,227
So we see that with this we can drop any of the shot fired messages, they're not important

236
00:15:44,267 --> 00:15:46,148
to play, so that gets rid of a few messages.

237
00:15:47,970 --> 00:15:50,832
Then we get to our key blast, which is where a lot of our benefits come from.

238
00:15:51,913 --> 00:15:57,036
And this is, we see the bottom few messages are both position updates and a set health,

239
00:15:57,236 --> 00:16:00,599
so as they're absolute we don't have to play any of the previous messages.

240
00:16:02,790 --> 00:16:04,892
And with all those gone, we get to our always.

241
00:16:05,693 --> 00:16:09,536
So anything that's adding score is a delta score time,

242
00:16:09,576 --> 00:16:10,436
so we have to play that.

243
00:16:10,797 --> 00:16:14,099
Or setting various enum-related flag state,

244
00:16:14,179 --> 00:16:14,880
we have to play that.

245
00:16:15,861 --> 00:16:18,563
But we see we've gone from about 19 to around six messages.

246
00:16:19,523 --> 00:16:23,987
So it's a significant increase in performance,

247
00:16:24,147 --> 00:16:25,888
because we don't have to process all of those messages.

248
00:16:27,954 --> 00:16:31,617
Unfortunately this is the level of optimization we had to stop for World of Tanks due to existing

249
00:16:31,677 --> 00:16:35,419
architectural decisions, but there are more you can do.

250
00:16:37,341 --> 00:16:41,123
Checkpointing is probably the best way of optimizing this.

251
00:16:41,904 --> 00:16:48,488
So that's copying your current state of the world into a certain location and being able

252
00:16:48,549 --> 00:16:50,090
to immediately dump that.

253
00:16:50,450 --> 00:16:55,994
So in between our world reset we would dump the world, we would take the world state,

254
00:16:56,694 --> 00:16:57,195
put that there.

255
00:16:57,715 --> 00:17:00,578
then we would take the checkpoint state, overlay that,

256
00:17:00,978 --> 00:17:04,100
and then just have to play the small amount of frames between where the checkpoint was

257
00:17:04,761 --> 00:17:05,822
and where we actually want to be.

258
00:17:06,462 --> 00:17:11,946
So that frame spike is more consistent because it's directly related to how big a

259
00:17:12,167 --> 00:17:13,488
gap there is between your checkpoints.

260
00:17:14,188 --> 00:17:18,011
Which means if you have excessively long hour-long replays, you're not getting

261
00:17:18,091 --> 00:17:21,134
massive spikes because your checkpoints could be approximately every minute

262
00:17:21,614 --> 00:17:22,895
and therefore it's more of a constant.

263
00:17:24,376 --> 00:17:25,997
In order to make full use of checkpoints,

264
00:17:26,960 --> 00:17:30,621
we have to make sure that our world state is set up in a certain way.

265
00:17:32,401 --> 00:17:33,941
So there are two methods of sending

266
00:17:35,322 --> 00:17:37,062
stuff from the client, server to the client.

267
00:17:37,702 --> 00:17:40,583
And it's either by replicating properties or by sending events.

268
00:17:42,444 --> 00:17:45,724
So in order to support checkpointing better, making sure that your

269
00:17:46,304 --> 00:17:47,805
state on your server is

270
00:17:48,525 --> 00:17:52,146
representative of what's on your client means you can actually save your state properly.

271
00:17:53,470 --> 00:17:58,213
So something like decals is not something that traditionally you would need to store on a server because it doesn't really need to know about it.

272
00:17:58,774 --> 00:18:08,940
But in the case of replays, it is better to have them actually just listed on the server so that we can store that out as a checkpoint at some point

273
00:18:09,821 --> 00:18:14,063
and therefore recreate the decals immediately upon just as a memory copy.

274
00:18:15,009 --> 00:18:19,572
rather than having to play back every message of an add decal every time we want to add one

275
00:18:20,112 --> 00:18:23,415
and therefore creating more messages and a larger spike when we do a jump forwards.

276
00:18:27,778 --> 00:18:32,721
So, our next problem is how we can see players jumping forward.

277
00:18:36,363 --> 00:18:37,364
As you can see in this video

278
00:18:39,725 --> 00:18:43,228
we jump forward a bunch of times, we zoom out and then all the trees collapse.

279
00:18:44,129 --> 00:18:47,750
I mean it's really cool in a samurai movie when someone seeks through everyone and then

280
00:18:47,790 --> 00:18:51,111
everyone collapses at the same time, but in a replay that's not entirely accurate.

281
00:18:52,851 --> 00:18:58,573
The problem here is that our tree system was not designed to operate midway through, and

282
00:18:58,673 --> 00:19:00,113
this is not just specific to that.

283
00:19:02,013 --> 00:19:09,715
The animations, your effects, like shot particles, anything on your HUD if you have timers that

284
00:19:09,755 --> 00:19:12,236
show reloads or cooldown effects.

285
00:19:14,072 --> 00:19:19,934
Our destruction, and even initialization such as spawning in resources, all of these can

286
00:19:20,034 --> 00:19:23,195
sometimes not be designed to be able to start midway through.

287
00:19:23,595 --> 00:19:28,077
They're either designed to start and then they take control of their own timers, or

288
00:19:28,097 --> 00:19:30,118
they're in one state or another.

289
00:19:32,559 --> 00:19:36,260
So what we did to fix this was to make sure that each of these systems understood when

290
00:19:36,300 --> 00:19:36,940
they started.

291
00:19:38,121 --> 00:19:40,501
So when the event happens, we store the time.

292
00:19:41,288 --> 00:19:45,893
that we currently started, which means we have to get the time that the replay is currently processing,

293
00:19:45,953 --> 00:19:50,437
not necessarily the wall clock, which can either be the start or the end of the jump.

294
00:19:51,398 --> 00:19:56,624
Then when we hit the end of the jump, we make sure that we fire off an event to each of these

295
00:19:57,124 --> 00:20:03,811
managers of these systems, so that we can adjust the duration of that event.

296
00:20:05,112 --> 00:20:10,077
based on the start time and therefore set the tree to where it would be as we jumped

297
00:20:10,137 --> 00:20:14,080
out. So trees can start falling over or they can start completely on the ground already.

298
00:20:16,102 --> 00:20:21,647
So this solves that problem of not being able to, of watching everything happen at once.

299
00:20:23,108 --> 00:20:27,231
Related to that is having things happen in the wrong position.

300
00:20:28,535 --> 00:20:33,478
So here we see a time jump and we see the explosion start back where the tank was, not

301
00:20:33,518 --> 00:20:35,679
where the tank actually is being destroyed.

302
00:20:37,401 --> 00:20:40,303
This is because these particles are meant to attach to the tank, but they don't know

303
00:20:40,343 --> 00:20:42,404
where the tank is during the time jump.

304
00:20:45,146 --> 00:20:48,728
So similar to how we needed to get the time the replay was currently processing, we also

305
00:20:48,808 --> 00:20:53,671
need to get the position of where the entity is as the replay is jumping through.

306
00:20:55,993 --> 00:21:00,334
So this is where we have a bit of a deviation from the rule of not modifying the client

307
00:21:00,895 --> 00:21:01,815
specific for replays.

308
00:21:03,315 --> 00:21:12,177
So what we need to do here is we need to store where the entities are just off to the side,

309
00:21:13,237 --> 00:21:16,978
not necessarily in our actual interpolation code.

310
00:21:18,318 --> 00:21:23,039
And when we want to reference or attach to something at a certain position, we pull from

311
00:21:23,079 --> 00:21:24,420
there during a jump only.

312
00:21:25,535 --> 00:21:29,497
We could process all of the move messages, but that's going to increase our spike because

313
00:21:29,537 --> 00:21:32,558
it makes the position an always message that has to always play.

314
00:21:33,899 --> 00:21:34,859
So this is a trade-off.

315
00:21:35,479 --> 00:21:39,301
We're having to modify the client, but the benefits of being able to do that and not

316
00:21:39,341 --> 00:21:43,763
having to play all of those move messages significantly improves the performance.

317
00:21:44,163 --> 00:21:48,625
And then all the particles and everything that's meant to happen at a certain point

318
00:21:49,185 --> 00:21:50,826
can actually happen at that certain point.

319
00:21:55,369 --> 00:22:01,694
So when it comes to architecture, when we're playing a real game, a client really only

320
00:22:01,754 --> 00:22:06,217
needs to know about its own player controller. It doesn't need to know about other player

321
00:22:06,257 --> 00:22:11,681
controllers. And therefore, unless you're doing a split-screen game, in which case this

322
00:22:12,081 --> 00:22:18,646
is probably not going to be a problem for you, for us we had a singleton that connected

323
00:22:18,706 --> 00:22:24,330
to the server as the authoritative controlling avatar. When we play a replay...

324
00:22:25,108 --> 00:22:31,772
That doesn't hold up anymore, as your player controller is suddenly all of the player controllers for every player in the game.

325
00:22:32,112 --> 00:22:36,574
And as a singleton, every time we tried to create a new player controller, we would override our existing one,

326
00:22:37,515 --> 00:22:42,498
and things would not work properly because it had no idea who it was meant to be in control of.

327
00:22:43,498 --> 00:22:48,221
For us, rewriting this would have been a massive architectural undertaking, so we had to find a way around it.

328
00:22:50,848 --> 00:22:54,531
So what we did was to take advantage of an existing observer mode.

329
00:22:55,032 --> 00:23:00,516
So World of Tanks has the ability to view and observe a match via an external observer

330
00:23:01,297 --> 00:23:03,459
and we leverage that functionality to do that here.

331
00:23:04,400 --> 00:23:10,645
So during the recording of the replay, right at the beginning, we insert a fake player

332
00:23:11,486 --> 00:23:13,267
and this player represents that observer.

333
00:23:13,508 --> 00:23:15,349
Even though they weren't actually playing in the match.

334
00:23:16,262 --> 00:23:18,744
As far as the replay was concerned, they were.

335
00:23:19,324 --> 00:23:21,146
So when we're playing it back on the client,

336
00:23:21,926 --> 00:23:26,090
it just creates a player without any knowledge that that player didn't actually exist in the game,

337
00:23:26,890 --> 00:23:28,672
and then follows our existing code paths

338
00:23:29,893 --> 00:23:31,914
in order to make use of this observer functionality.

339
00:23:32,154 --> 00:23:35,897
So if you have something like this in your game, you can easily get around this issue

340
00:23:37,559 --> 00:23:41,722
by inserting a fake player into the game, and therefore you don't have to touch your replay code at all.

341
00:23:44,369 --> 00:23:50,414
This also, the concept of this recording only message also helps with other issues as well.

342
00:23:51,254 --> 00:23:57,779
For instance, when we're recording our shot events, this could happen multiple times.

343
00:23:58,560 --> 00:24:02,643
So as you can see here, every time we send out a shot to one of our clients, we have

344
00:24:02,663 --> 00:24:03,784
to record it to a replay.

345
00:24:04,444 --> 00:24:08,687
So if three people see a shot, then we record that message three times into the replay.

346
00:24:11,011 --> 00:24:15,173
2, 1, or even 0, so we can get to the point where we don't actually record this into the replay.

347
00:24:15,853 --> 00:24:16,874
And this isn't great,

348
00:24:17,754 --> 00:24:20,976
because especially with a 30-player game, you're recording the same message 30 times.

349
00:24:22,357 --> 00:24:26,559
So instead, what we did is we don't actually record certain messages, such as firing shots.

350
00:24:28,320 --> 00:24:33,583
What we do is we specialize that and record that to our replay-only entity that we talked about earlier.

351
00:24:34,544 --> 00:24:35,904
This way, we're only recording it once.

352
00:24:37,997 --> 00:24:41,300
Even then, if no one actually saw it, we still end up recording it.

353
00:24:42,200 --> 00:24:47,245
So in this case, if a tree falls in the forest and nobody hears it, it does in fact actually

354
00:24:47,285 --> 00:24:47,825
make a sound.

355
00:24:51,909 --> 00:24:56,893
So this gets us to a point where we're going to need some feature requests.

356
00:24:57,153 --> 00:25:00,916
And one of those feature requests was being able to see where the player viewed from.

357
00:25:04,096 --> 00:25:08,639
So we see here that as we were in the free cam, we saw everyone, but now things are popping

358
00:25:08,719 --> 00:25:10,600
in as we view from the player's perspective.

359
00:25:11,921 --> 00:25:16,904
The problem here is the replay has no player context, it doesn't have the concept of what

360
00:25:16,944 --> 00:25:17,844
the player could see.

361
00:25:18,765 --> 00:25:23,147
So the first thing we have to do here is to actually record that information.

362
00:25:23,568 --> 00:25:29,731
So the server is sending which people the player can actually see, so we record that

363
00:25:29,811 --> 00:25:33,313
off to the side so we can play that message back as the replay comes in.

364
00:25:35,150 --> 00:25:36,991
Then we get to the client side and have to deal with that.

365
00:25:37,371 --> 00:25:38,371
And there are two methods for this.

366
00:25:40,972 --> 00:25:41,973
The first way we can do it

367
00:25:42,813 --> 00:25:43,753
aligns with our

368
00:25:44,694 --> 00:25:46,774
don't modify the client for replays paradigm

369
00:25:47,895 --> 00:25:51,656
in that at the level of processing the messages, if we are viewing from a certain

370
00:25:51,676 --> 00:25:52,176
perspective

371
00:25:52,937 --> 00:25:53,957
we don't actually

372
00:25:54,917 --> 00:25:58,219
play those messages. So if there's an entity that that player can't see, we don't play

373
00:25:58,239 --> 00:26:01,440
that message at all. We just lock it off and the client plays as normal.

374
00:26:02,845 --> 00:26:08,008
Now this works really well, but it does have some caveats in that if you want to switch

375
00:26:08,048 --> 00:26:11,410
players or you want to switch to FreeCam, you're always going to have to do a reset

376
00:26:11,450 --> 00:26:14,492
because certain messages have been played and therefore you can't guarantee the state

377
00:26:14,512 --> 00:26:16,653
of the world is actually consistent.

378
00:26:18,734 --> 00:26:23,657
It also means you can't do something such as ghosting where you show what players couldn't

379
00:26:23,717 --> 00:26:27,339
see but you actually want to show a visual representation of where that player was.

380
00:26:29,300 --> 00:26:30,621
So what we did do instead...

381
00:26:31,600 --> 00:26:33,201
was we did it a bit lower down.

382
00:26:33,961 --> 00:26:36,282
So we let the messages come through and we processed them,

383
00:26:37,423 --> 00:26:40,744
but if that other entity wasn't visible to that player,

384
00:26:41,464 --> 00:26:43,425
then we hit it.

385
00:26:44,206 --> 00:26:46,507
And it only became visible when we received the message

386
00:26:46,627 --> 00:26:48,447
telling us that the visibility was actually true.

387
00:26:49,868 --> 00:26:51,929
So in effect, we're modifying the client

388
00:26:52,489 --> 00:26:56,811
to make the replays work properly using visibility.

389
00:26:57,881 --> 00:27:05,824
But it gives us the ability to instantly switch between other players and all we're doing is toggling visibility flags or switching to full view of everything

390
00:27:06,484 --> 00:27:10,265
and all the other features that we can support based on having this information.

391
00:27:11,746 --> 00:27:17,328
So this is another example of you have to make the call on whether the trade-off is worth it

392
00:27:18,548 --> 00:27:21,309
in order to change what the client is doing for replays.

393
00:27:25,874 --> 00:27:29,977
So similar to what we did before was we wanted to see what the player could see

394
00:27:30,858 --> 00:27:34,762
then the request was we want to actually see exactly how the player saw that

395
00:27:35,662 --> 00:27:38,946
which is viewing from the camera of the player

396
00:27:40,987 --> 00:27:44,310
if you have a first-person game or something where the camera is generally locked to a bone

397
00:27:44,491 --> 00:27:45,492
this is relatively simple

398
00:27:46,673 --> 00:27:48,735
but for us we have a free moving camera

399
00:27:50,696 --> 00:27:52,238
so the only real solution

400
00:27:52,887 --> 00:27:56,590
would be to send the camera data up to the server.

401
00:27:57,071 --> 00:27:59,773
And this has no tangible benefits to the game.

402
00:28:00,734 --> 00:28:03,496
So you can go to your server engineers and

403
00:28:04,597 --> 00:28:06,099
please sir, can I have some more bandwidth?

404
00:28:07,900 --> 00:28:09,381
There's a chance you'll get a no.

405
00:28:10,963 --> 00:28:13,525
So the next option is just to fake it until you make it.

406
00:28:14,866 --> 00:28:18,930
We attached our camera to our bone at the front.

407
00:28:19,343 --> 00:28:24,467
of our turret, so we actually, we're seeing where the player was looking and when the player fires,

408
00:28:24,928 --> 00:28:29,872
we see exactly where the player fired. Of course we don't have any information about where they're

409
00:28:29,952 --> 00:28:37,338
free looking, but there's been no complaints about that not being there. Once the sniper mode went in

410
00:28:37,838 --> 00:28:45,345
that seemed to work properly, so it's not really that important if you don't have the exact player's

411
00:28:45,485 --> 00:28:47,687
experience there. If you, if that's 100%.

412
00:28:49,276 --> 00:28:52,839
important for you, then there are client-side replays that do that as well.

413
00:28:56,182 --> 00:28:59,805
So another feature is our highlight system, and this requires metadata.

414
00:29:00,205 --> 00:29:03,028
So we need to be able to store when the highlight happens.

415
00:29:05,310 --> 00:29:10,033
We had a few things that we wanted to do, and one of those was we wanted to keep everything

416
00:29:10,074 --> 00:29:11,355
in one single file.

417
00:29:11,595 --> 00:29:15,158
So we had one replay file to store to and distribute.

418
00:29:16,119 --> 00:29:16,359
So

419
00:29:17,657 --> 00:29:21,399
We didn't want to have to be able to modify the header on the fly

420
00:29:22,040 --> 00:29:24,441
and rewrite out the file while it's still being recorded.

421
00:29:24,862 --> 00:29:27,364
We didn't want any processing after the match had finished,

422
00:29:27,524 --> 00:29:29,885
which takes up time on the server before we uploaded it.

423
00:29:30,526 --> 00:29:33,708
So we needed the ability to insert that metadata into the file

424
00:29:34,449 --> 00:29:35,569
while it was still recording.

425
00:29:37,771 --> 00:29:41,233
And the way we do this is to leave the metadata in with the other tick blocks.

426
00:29:41,714 --> 00:29:43,655
So whenever we want to write out a piece of metadata,

427
00:29:44,456 --> 00:29:46,497
we have our ticks and then we'll insert the metadata.

428
00:29:47,553 --> 00:29:52,115
Then when we're playing it back, because we're reading things into memory in larger chunks,

429
00:29:53,115 --> 00:29:57,777
we're able to pre-process that metadata before it would actually hit it as it is playing

430
00:29:57,837 --> 00:30:01,739
back while faking the messages that come in from the server.

431
00:30:02,459 --> 00:30:08,362
So for us, our replays are only around 7 megabytes, so we can fit that entirely in memory, pre-process

432
00:30:08,402 --> 00:30:12,384
the whole thing, and strip out all the metadata before we start playing back through the file,

433
00:30:12,604 --> 00:30:14,725
and then just ignore the metadata when we get there.

434
00:30:15,525 --> 00:30:16,766
This also works for live streaming.

435
00:30:17,995 --> 00:30:19,516
because it's not reading from a separate file.

436
00:30:20,056 --> 00:30:22,657
As the messages are pulled into memory,

437
00:30:22,697 --> 00:30:24,138
you can still pull your metadata out

438
00:30:24,378 --> 00:30:26,598
and place your highlights on your timeline

439
00:30:27,299 --> 00:30:28,099
as that plays back.

440
00:30:31,220 --> 00:30:32,100
So feature parity.

441
00:30:32,540 --> 00:30:33,741
We had to support this bad boy.

442
00:30:36,242 --> 00:30:38,643
But something like this is important for things

443
00:30:38,723 --> 00:30:39,823
if you have a mobile game

444
00:30:40,023 --> 00:30:41,984
that runs across multiple platforms,

445
00:30:42,344 --> 00:30:44,185
or even if you're running your main game on mobile.

446
00:30:45,403 --> 00:30:50,586
Memory limitations and processing limitations mean you may have to make some trade-offs,

447
00:30:50,786 --> 00:30:56,068
but it's important to have feature parity as having everything work across all of your

448
00:30:56,689 --> 00:31:00,330
systems means that people don't have to wonder whether something is working or something

449
00:31:00,370 --> 00:31:03,312
is not, both for your players and for your testers.

450
00:31:06,853 --> 00:31:07,914
So we made some trade-offs.

451
00:31:08,354 --> 00:31:11,976
So when it comes to memory, specifically on the 360, we had none left.

452
00:31:13,062 --> 00:31:15,122
So we had to disable something like our world instancing.

453
00:31:15,282 --> 00:31:18,384
It meant longer load times, but it meant we still supported rewinds,

454
00:31:18,444 --> 00:31:20,524
which is really important for replays.

455
00:31:21,805 --> 00:31:26,087
We also had to deactivate some optimizations that would run in the game,

456
00:31:26,967 --> 00:31:29,148
as when you're playing back a replay,

457
00:31:29,208 --> 00:31:32,609
you're less concerned about maybe slight hitches in your frame rate.

458
00:31:33,149 --> 00:31:36,731
When your KB ratio isn't dependent on it, it's less of a concern.

459
00:31:38,491 --> 00:31:41,893
And we also had to put the replay file on the hard drive and stream it from there.

460
00:31:42,952 --> 00:31:48,135
As on the Xbox One and PS4 we could just store all our memory because we had the room,

461
00:31:48,915 --> 00:31:53,377
we had to put it on the hard drive for the 360 and that meant a whole bunch of extra TRC requirements we had to support.

462
00:31:55,178 --> 00:31:59,480
There was also some slight processing changes such as dealing with fog and loading,

463
00:32:00,000 --> 00:32:03,021
especially when you took a free cam and you could suddenly view the entire map.

464
00:32:03,201 --> 00:32:07,843
We had to make sure it worked in that situation, a situation that hadn't really come up before.

465
00:32:10,406 --> 00:32:14,429
So the main theme of what we've been talking about all throughout client is assumptions

466
00:32:15,470 --> 00:32:18,573
and that there are a lot of assumptions that can be violated by replays.

467
00:32:20,014 --> 00:32:22,376
So for instance in this specific video

468
00:32:23,297 --> 00:32:29,262
no one noticed during when you're playing gameplay that your tank explodes slightly before your shot can go out to it

469
00:32:29,362 --> 00:32:33,866
but in a replay at a slow playback rate it is incredibly obvious

470
00:32:35,748 --> 00:32:37,229
and that's something no one really picked up on.

471
00:32:38,570 --> 00:32:42,773
So what you have to make sure is that you check all of your assumptions.

472
00:32:42,974 --> 00:32:44,695
Here is a list of a bunch of assumptions.

473
00:32:45,415 --> 00:32:46,556
I'm not going to go through all of them.

474
00:32:48,117 --> 00:32:52,540
But just make sure that if you have an assumption, if you've said that can never happen,

475
00:32:52,841 --> 00:32:55,582
make sure in replays you test that that can never happen.

476
00:32:59,425 --> 00:33:03,408
And that brings us to the end of the game integration section.

477
00:33:04,189 --> 00:33:05,450
So we just have to make sure that...

478
00:33:06,580 --> 00:33:10,881
When you're integrating into your client, you make sure you take into account the flow of time

479
00:33:11,821 --> 00:33:14,082
and how we jump through time.

480
00:33:15,662 --> 00:33:17,683
How the network interpolation logic works

481
00:33:18,583 --> 00:33:20,083
and how your entities move around

482
00:33:20,543 --> 00:33:23,044
and to stop sliding and forward error prediction problems.

483
00:33:24,384 --> 00:33:28,185
How you represent your world and the state, so we can do things like check pointing.

484
00:33:30,246 --> 00:33:32,027
How you control your...

485
00:33:32,398 --> 00:33:36,520
Player controller controls other avatars, whether that's a singleton or whether you can actually

486
00:33:37,321 --> 00:33:39,102
do multiple controllers at once

487
00:33:41,063 --> 00:33:43,984
and also how these entities all handle time as well

488
00:33:44,484 --> 00:33:46,425
and especially your menus and external areas

489
00:33:47,726 --> 00:33:49,887
and just make sure you check all your assumptions.

490
00:33:52,068 --> 00:33:54,449
So now we have replays, replays working fine.

491
00:33:56,190 --> 00:33:59,131
They're great for players, but how can they help us in development?

492
00:34:00,235 --> 00:34:02,437
And the answer is quite a lot, actually.

493
00:34:05,720 --> 00:34:08,702
Before we can actually use these sort of replays in development,

494
00:34:08,742 --> 00:34:11,445
we have to make sure that our replays are trusted and tested.

495
00:34:12,586 --> 00:34:16,529
And they can be a difficult thing to diagnose issues like this

496
00:34:17,210 --> 00:34:20,312
because there's very time-sensitive concerns going on.

497
00:34:21,233 --> 00:34:23,595
It's very hard to debug something that is time-critical.

498
00:34:25,277 --> 00:34:27,178
So what we did do was we...

499
00:34:27,744 --> 00:34:32,809
made sure that we had the ability to output a replay file as something that's human readable

500
00:34:33,730 --> 00:34:37,693
putting all our messages in the parameters so we can read it.

501
00:34:39,135 --> 00:34:45,040
This not only allows you to spot things, such as that duplicate event processing that I talked about earlier

502
00:34:45,621 --> 00:34:49,224
but it also allows you to diff two different replays to see where something could be different

503
00:34:49,244 --> 00:34:52,867
see if messages are in and out of order, causing different problems.

504
00:34:54,742 --> 00:35:00,406
And you can also parse this sort of thing external to overhatching to play it in the game.

505
00:35:00,566 --> 00:35:02,187
Something like if you want to do machine learning.

506
00:35:03,768 --> 00:35:06,129
Or check for hotspots on maps.

507
00:35:08,471 --> 00:35:14,475
So once you're suddenly in development and you're using these, they're great for reliable reproductions.

508
00:35:14,675 --> 00:35:19,778
So your QA can do something, you don't have to replicate their ninja skills in order to replicate the problem they had.

509
00:35:19,838 --> 00:35:22,020
You just have to grab the replay file from what they did.

510
00:35:22,875 --> 00:35:25,036
and automatically your client will play it back

511
00:35:26,257 --> 00:35:27,879
without having you having to actually do it.

512
00:35:29,460 --> 00:35:32,022
And because the replays are playing back through the client as normal

513
00:35:32,702 --> 00:35:33,483
this means that

514
00:35:34,523 --> 00:35:35,224
you actually

515
00:35:36,365 --> 00:35:37,145
get that benefit.

516
00:35:38,686 --> 00:35:41,248
You can also share and access these replays from anywhere

517
00:35:42,329 --> 00:35:42,489
and

518
00:35:43,470 --> 00:35:46,012
therefore don't have to attach files around and potentially lose them.

519
00:35:46,452 --> 00:35:48,774
And you can also insert the metadata into the replays

520
00:35:49,334 --> 00:35:49,815
so that

521
00:35:51,276 --> 00:35:51,896
it's all...

522
00:35:52,774 --> 00:35:56,757
straight there. You can jump directly to where the issue occurred rather than having to deal

523
00:35:56,777 --> 00:35:59,959
with time codes and scrubbing and trying to find where the problem was.

524
00:36:03,801 --> 00:36:08,624
It's also really beneficial for performance testing and regression testing. Any form of

525
00:36:08,724 --> 00:36:13,187
automatic testing, replays go hand in hand with. So you're able to play the exact same

526
00:36:13,287 --> 00:36:16,949
thing, time and again, without running into issues.

527
00:36:19,700 --> 00:36:33,950
And as I mentioned earlier, it also represents the real game, so it's a lot better than any spin testing or just placing cameras in the world and looking at a generic thing, because you actually can see what your players are actually doing and looking at.

528
00:36:33,990 --> 00:36:39,733
So you're getting real world performance data as opposed to just generic data.

529
00:36:41,716 --> 00:36:46,517
It also means that you can take your replays used for smoke testing and use them for your

530
00:36:46,537 --> 00:36:47,317
performance testing.

531
00:36:47,977 --> 00:36:54,179
So this is a caveat in that replays, which we'll discuss soon, go out of date very quickly.

532
00:36:55,619 --> 00:37:03,621
And so scenarios need to be reproducible via either an automatic creation method or via

533
00:37:03,681 --> 00:37:08,142
manual creation in order to be able to do consistently over several days.

534
00:37:10,920 --> 00:37:16,304
They're also helpful in live. So once your game has gone live, you can use replays to help deal with players.

535
00:37:17,084 --> 00:37:27,870
So if a player finds an error in a game, in their one in a billion error, you can just grab their replay and see how that happened, rather than trying to reproduce it a million times yourself.

536
00:37:29,131 --> 00:37:38,037
It's also great for identifying if anyone's cheating, you see how they managed to get underneath a mat and get behind that zone where only they could shoot out from.

537
00:37:38,993 --> 00:37:42,594
And also if there are any complaints about balance issues you can see from a replay

538
00:37:43,814 --> 00:37:48,796
where potential map problems might be or where a tank or anything can be overpowered.

539
00:37:50,156 --> 00:37:51,857
It's also great for post-process analytics.

540
00:37:52,357 --> 00:37:54,658
So if you come up with some stat that you want to be tracking

541
00:37:55,678 --> 00:38:00,180
then you're able to just write that process a whole bunch of replays.

542
00:38:01,271 --> 00:38:05,653
and get that information immediately rather than having to wait two weeks for your players to play through it.

543
00:38:06,213 --> 00:38:07,813
This also works for something like machine learning.

544
00:38:08,374 --> 00:38:14,876
If you want to be able to have your bots learn from how other players play, you can just process your replays and it's done there.

545
00:38:17,517 --> 00:38:22,579
So, now we've discovered how they help us in development and how to get things into the client,

546
00:38:23,079 --> 00:38:27,200
we're going to briefly just go over some of the things we decided not to do

547
00:38:28,401 --> 00:38:30,181
because we considered them either to be...

548
00:38:31,437 --> 00:38:34,018
too complicated or not worth our time.

549
00:38:35,539 --> 00:38:39,100
So I'd be... feel free to try and do some one of these things.

550
00:38:39,440 --> 00:38:41,221
They're probably GDC talks on their own

551
00:38:42,721 --> 00:38:46,563
and I'd love to be in the front row to hear how you actually overcame these problems.

552
00:38:48,743 --> 00:38:50,304
So the first one is playback in reverse.

553
00:38:50,864 --> 00:38:54,546
So what you're seeing on the screen is me faking it by playing a video back in reverse.

554
00:38:55,306 --> 00:38:58,767
We don't actually support something like this because of how complicated it is.

555
00:39:00,401 --> 00:39:04,323
Events all have their start position, so when you're playing the replay start to end, you're

556
00:39:04,343 --> 00:39:05,383
hitting the correct points.

557
00:39:06,164 --> 00:39:09,965
But the server very rarely knows where an event would end, such as playing a particle

558
00:39:09,985 --> 00:39:11,726
effect, it has no idea when the event would end.

559
00:39:12,747 --> 00:39:14,908
So when we're playing back, it doesn't know when to start.

560
00:39:16,829 --> 00:39:20,490
So in order to support something like this, you would have to pre-process your replay

561
00:39:20,530 --> 00:39:24,432
before you play it in order to calculate the end times on the client.

562
00:39:25,342 --> 00:39:29,363
and store that somewhere so that when you play backwards you can actually hit that point,

563
00:39:29,423 --> 00:39:34,705
spawn the particle effect, jump it to its end point. I mean you've already set up your

564
00:39:34,725 --> 00:39:38,065
durations so you can start from any point and then play it backwards.

565
00:39:39,086 --> 00:39:41,786
But I probably haven't touched the surface of all the problems here because there will

566
00:39:41,806 --> 00:39:47,628
be other problems with your network latency interpolation movement code not being able

567
00:39:47,668 --> 00:39:52,369
to support negative times and jumping between negative and positive.

568
00:39:54,134 --> 00:39:58,176
It's something you should probably talk to your excited designer about and just temper

569
00:39:58,196 --> 00:40:00,377
them to say it's probably not worth it.

570
00:40:02,818 --> 00:40:06,619
The next big one is versioning, and this is something we talked about quite a lot right

571
00:40:06,639 --> 00:40:07,159
at the beginning.

572
00:40:08,980 --> 00:40:13,982
The main problem being that it's something that would be nice to have, but it's very

573
00:40:14,102 --> 00:40:15,063
difficult to support.

574
00:40:16,220 --> 00:40:21,904
So replays get out of date quite often because as soon as you change your map, move a rock

575
00:40:21,944 --> 00:40:26,408
somewhere or make an asset slightly wider, you're suddenly going to get clipping in your

576
00:40:26,428 --> 00:40:29,090
replays because that wasn't like that when the replay was recorded.

577
00:40:29,790 --> 00:40:37,716
Same thing for any entity properties or definitions and how they operate or even any code that

578
00:40:37,756 --> 00:40:38,796
just controls behavior.

579
00:40:39,237 --> 00:40:43,960
As these things change, the replays will not function appropriately.

580
00:40:44,980 --> 00:40:50,542
There are mitigation steps that fix this, such as for our assets, our maps, and our

581
00:40:51,343 --> 00:40:54,404
entity assets, we can download them on demand.

582
00:40:54,804 --> 00:40:58,786
So we use a hash to look up what we actually need, and then we're playing back with the

583
00:40:58,806 --> 00:40:59,627
appropriate assets.

584
00:41:01,007 --> 00:41:04,229
Of course, this is a cost factor in that you have to store the assets in an accessible

585
00:41:04,269 --> 00:41:08,731
location to be downloaded as required, and slows down how quickly you can start your

586
00:41:08,771 --> 00:41:09,011
replay.

587
00:41:11,156 --> 00:41:15,757
For properties, we can always create redirectors that redirect old properties to new properties

588
00:41:15,917 --> 00:41:18,197
or break things up into what they should be.

589
00:41:19,677 --> 00:41:27,199
But then we're paying a performance cost of not only doing that conversion, but also how

590
00:41:27,459 --> 00:41:29,099
accurate it actually is going to end up being.

591
00:41:29,959 --> 00:41:34,500
We can get around all of this and just download the entire old client and play a replay file

592
00:41:34,560 --> 00:41:34,800
on that.

593
00:41:35,060 --> 00:41:36,060
That's very heavyweight.

594
00:41:36,260 --> 00:41:38,941
You're now storing the entire versions of your game.

595
00:41:39,971 --> 00:41:44,913
somewhere that can be downloaded and it's not exactly something you can do on a console.

596
00:41:45,153 --> 00:41:46,613
You can't fire up another executable.

597
00:41:47,454 --> 00:41:51,495
So again, you can just ask yourself how necessary something like this is.

598
00:41:53,476 --> 00:41:58,598
We keep our replays around for two weeks, so once we release any patch update it invalidates

599
00:41:58,618 --> 00:42:02,579
the replays, but we've set that expectation with players that two weeks is as long as

600
00:42:02,639 --> 00:42:04,420
replays are going to hang around for.

601
00:42:05,000 --> 00:42:08,201
And they understand that when there's a title update that they will be invalidated.

602
00:42:11,328 --> 00:42:14,790
So that's replays. That's everything we did to get replays into a game.

603
00:42:17,712 --> 00:42:21,574
If you take away anything from this talk, then make sure that it's

604
00:42:22,495 --> 00:42:27,158
try keeping your replays code and your client's code so that they're the same thing.

605
00:42:27,658 --> 00:42:29,679
So you're not specializing the client just for replays.

606
00:42:30,099 --> 00:42:33,341
Unless of course, there are certain situations where the trade-off is worth it.

607
00:42:34,582 --> 00:42:36,103
Make sure you consider the flow of time.

608
00:42:36,844 --> 00:42:38,665
Time is where most of your issues will happen.

609
00:42:39,540 --> 00:42:46,966
especially time jumping, so think about how a system or a new system will handle how time

610
00:42:47,907 --> 00:42:48,407
changes.

611
00:42:50,129 --> 00:42:56,294
And make sure when you're storing data or writing systems that access data that you

612
00:42:56,334 --> 00:43:03,200
consider how the server will send to the client and what you actually need to play back should

613
00:43:03,240 --> 00:43:04,040
we be jumping through time.

614
00:43:05,797 --> 00:43:12,162
And if someone asks you why you possibly need this feature, well, even if it's not just because players are asking for it,

615
00:43:12,902 --> 00:43:22,309
it's really important for when you're in development, because it can really speed up as a valuable tool for getting reliable testing and performance analysis.

616
00:43:23,010 --> 00:43:34,558
And if anything, it makes for just bulletproof systems design that works in a whole lot more situations than what a non-replay system design would be.

617
00:43:36,496 --> 00:43:37,698
So thank you for watching.

618
00:43:39,020 --> 00:43:40,041
I hope you've learned something.

619
00:43:40,942 --> 00:43:42,505
This is the point where I normally ask for questions,

620
00:43:42,565 --> 00:43:43,426
but there's nobody here.

621
00:43:44,107 --> 00:43:46,611
So if you have any questions, just send it off to my email

622
00:43:46,711 --> 00:43:48,373
and I'll gladly be happy to respond.

623
00:43:49,154 --> 00:43:50,035
So thanks for watching

624
00:43:50,296 --> 00:43:51,618
and I hope to see you at a later point.

625
00:43:52,299 --> 00:43:52,439
Cheers.

