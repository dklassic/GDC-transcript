1
00:00:02,478 --> 00:00:03,239
Can we get the mic on?

2
00:00:03,539 --> 00:00:04,039
All right, cool.

3
00:00:05,460 --> 00:00:06,080
Good afternoon.

4
00:00:06,100 --> 00:00:06,921
How's everybody doing?

5
00:00:08,461 --> 00:00:13,864
Couple quick announcements GDC wanted me to make.

6
00:00:14,284 --> 00:00:16,185
If everybody could turn off their cell phones

7
00:00:16,745 --> 00:00:18,486
so they don't beep during the presentation

8
00:00:18,626 --> 00:00:21,148
and so there's not a symphony after the presentation

9
00:00:21,168 --> 00:00:21,608
of emails.

10
00:00:25,395 --> 00:00:28,658
evaluation forms will be emailed out after the session.

11
00:00:28,739 --> 00:00:30,040
So if you guys could all fill those out.

12
00:00:30,500 --> 00:00:32,302
GDC wants to know which sessions were good.

13
00:00:32,803 --> 00:00:36,426
I'd also like some feedback in terms of if you guys enjoyed the presentation.

14
00:00:36,446 --> 00:00:38,588
So if you guys could fill those out, that'd be awesome as well.

15
00:00:39,789 --> 00:00:40,951
So with that, let's get started.

16
00:00:41,591 --> 00:00:44,254
This is League of Legends, scaling to millions of summoners.

17
00:00:46,694 --> 00:00:47,495
Little bit about me.

18
00:00:47,555 --> 00:00:48,636
My name's Scott DeLapp.

19
00:00:48,996 --> 00:00:50,918
I'm a scalability architect at Riot.

20
00:00:51,218 --> 00:00:52,519
I've been with Riot since 2008.

21
00:00:53,060 --> 00:00:57,143
How many people played League of Legends in beta?

22
00:00:58,745 --> 00:00:59,785
We had a good mix of people.

23
00:00:59,966 --> 00:01:01,327
Looks like about 5%, 10%.

24
00:01:02,087 --> 00:01:05,971
So in League of Legends time, I was at Riot about a year

25
00:01:06,011 --> 00:01:08,613
before beta, to kind of put some things in perspective.

26
00:01:13,551 --> 00:01:18,035
You've got my Twitter handle and my email there on the slides.

27
00:01:18,075 --> 00:01:20,236
If anybody wants to catch up after the presentation,

28
00:01:20,397 --> 00:01:21,778
I'd be more than happy to talk to people.

29
00:01:21,818 --> 00:01:22,478
So just look me up.

30
00:01:22,498 --> 00:01:24,740
A little bit about Riot.

31
00:01:25,200 --> 00:01:28,143
So Riot was founded in September of 2006

32
00:01:29,123 --> 00:01:30,745
by Brandon Beck and Mark Merrill.

33
00:01:31,685 --> 00:01:33,687
Back when I joined Riot about four years ago,

34
00:01:33,727 --> 00:01:34,828
I think we had about 25 or 30 employees.

35
00:01:37,110 --> 00:01:38,631
Today we've got a little bit north of 500

36
00:01:39,611 --> 00:01:42,513
with offices, main offices in Santa Monica, California.

37
00:01:43,274 --> 00:01:45,215
We've got an engineering office in

38
00:01:45,235 --> 00:01:48,777
in St. Louis, Missouri.

39
00:01:48,797 --> 00:01:51,418
And then we've got a player support

40
00:01:51,739 --> 00:01:52,939
and community office in Dublin

41
00:01:53,059 --> 00:01:54,700
and another one in Seoul, South Korea.

42
00:01:58,282 --> 00:01:59,563
So our mission at Riot,

43
00:02:00,183 --> 00:02:01,544
every company's gotta have a mission.

44
00:02:01,604 --> 00:02:03,666
You've gotta have some sort of core theme

45
00:02:03,726 --> 00:02:04,946
that you're gonna optimize on.

46
00:02:06,444 --> 00:02:08,344
you know, if you've got five things, which one do you pick?

47
00:02:09,724 --> 00:02:10,904
Actually, I'm gonna restart this,

48
00:02:10,924 --> 00:02:12,565
because it's auto-doing timings on me,

49
00:02:14,165 --> 00:02:15,305
which could be a bad thing.

50
00:02:15,325 --> 00:02:19,826
Let's see if this will work.

51
00:02:22,747 --> 00:02:24,607
So, our mission at Riot is very simple.

52
00:02:24,667 --> 00:02:27,448
It's to be the most player-focused gaming company in the world.

53
00:02:28,208 --> 00:02:29,048
So what does that mean?

54
00:02:29,248 --> 00:02:32,389
Well, everything that we do at Riot is viewed through the lens of...

55
00:02:33,297 --> 00:02:35,959
What do we do for the players?

56
00:02:36,619 --> 00:02:38,320
So whether that's an engineering decision,

57
00:02:38,521 --> 00:02:40,462
whether that's feedback from the forums,

58
00:02:40,502 --> 00:02:41,443
taking that into account.

59
00:02:41,803 --> 00:02:42,784
Now that doesn't necessarily mean

60
00:02:42,824 --> 00:02:45,126
that every new skin idea or something like that

61
00:02:45,366 --> 00:02:48,988
is instantly released every two weeks right

62
00:02:49,028 --> 00:02:50,349
after it pops up on the forums.

63
00:02:50,410 --> 00:02:51,871
But we take all that into account.

64
00:02:51,971 --> 00:02:53,972
I mean, we really want to focus on what's

65
00:02:54,533 --> 00:02:57,015
the best player experience for everything that we do.

66
00:02:57,835 --> 00:03:00,397
So League of Legends, how many people play League of Legends?

67
00:03:02,105 --> 00:03:05,168
Most everybody on it. So I don't need to go into everything about League of Legends.

68
00:03:06,529 --> 00:03:06,609
Ah!

69
00:03:06,930 --> 00:03:08,831
This thing keeps like auto-moving.

70
00:03:09,332 --> 00:03:09,912
It's possessed.

71
00:03:11,073 --> 00:03:11,574
Two seconds.

72
00:03:11,594 --> 00:03:15,737
Let me try it another way. I'm gonna do it in rehearsal mode.

73
00:03:17,198 --> 00:03:18,660
And then that should reset the, uh...

74
00:03:21,402 --> 00:03:22,283
...slides for some reason.

75
00:03:27,657 --> 00:03:28,338
All right, sorry about that.

76
00:03:28,818 --> 00:03:31,881
So this is a scale talk.

77
00:03:31,921 --> 00:03:34,783
So it's useful in a scale talk to have some perspective

78
00:03:34,823 --> 00:03:36,224
on what we're talking about in terms of scale.

79
00:03:36,764 --> 00:03:40,367
So we released some numbers in July of last year

80
00:03:40,387 --> 00:03:43,510
and basically covered that we had 15 million registered

81
00:03:43,590 --> 00:03:47,052
users, we had about 4 million players a month,

82
00:03:47,413 --> 00:03:52,136
and a peak CCU of about 500,000 players a day when we hit peak.

83
00:03:53,057 --> 00:03:53,197
Now.

84
00:03:54,570 --> 00:03:57,893
If we compare that to November, going forward just a little

85
00:03:57,913 --> 00:04:02,799
bit, we went to 32 million registered accounts,

86
00:04:03,019 --> 00:04:05,682
4.2 million daily players, and 1.3 million

87
00:04:06,222 --> 00:04:07,083
peak concurrent users.

88
00:04:07,504 --> 00:04:08,645
So a little bit of a difference.

89
00:04:09,386 --> 00:04:11,809
Now, how many of you went to Travis George's talk

90
00:04:11,829 --> 00:04:12,609
this morning on Dominion?

91
00:04:14,172 --> 00:04:16,732
One of the phrases that Travis used was Riot scale.

92
00:04:18,393 --> 00:04:21,014
One of the things that's interesting about the things

93
00:04:21,054 --> 00:04:23,295
we do at Riot Games is those are the numbers

94
00:04:23,315 --> 00:04:25,355
that you have to hit when something goes out the door.

95
00:04:25,955 --> 00:04:27,776
And not only do you have to hit those numbers,

96
00:04:28,076 --> 00:04:29,537
but you have to plan in advance.

97
00:04:29,677 --> 00:04:32,237
Case in point, a feature that went out in July

98
00:04:32,878 --> 00:04:36,159
now needs to be able to handle a much larger amount of users

99
00:04:36,459 --> 00:04:37,499
in November, for instance.

100
00:04:37,579 --> 00:04:39,880
So for certain types of features,

101
00:04:39,900 --> 00:04:40,100
Dominion.

102
00:04:41,993 --> 00:04:43,734
I think it was about 12 months worth of development.

103
00:04:43,914 --> 00:04:47,035
So obviously, we can't go rework Dominion between July

104
00:04:47,075 --> 00:04:48,536
and November to hit scale targets.

105
00:04:49,016 --> 00:04:50,537
So we have to be cognizant of that

106
00:04:50,677 --> 00:04:53,438
as we're developing new features to have runway going forward.

107
00:04:56,633 --> 00:04:59,734
Now, you take the scale, and you take the mission

108
00:04:59,774 --> 00:05:03,235
of being the most player-focused gaming company in the world,

109
00:05:03,475 --> 00:05:05,735
and then you start to look at that in terms of challenges.

110
00:05:06,656 --> 00:05:08,376
And the big thing is there's lots of ways

111
00:05:08,416 --> 00:05:10,937
that we can solve problems, but they don't always make sense

112
00:05:10,957 --> 00:05:11,937
from a player perspective.

113
00:05:13,578 --> 00:05:16,198
So social elements, for instance,

114
00:05:16,318 --> 00:05:18,059
they have to be accessible from everybody.

115
00:05:18,079 --> 00:05:19,439
It doesn't make sense if five of you

116
00:05:19,479 --> 00:05:21,760
can chat with five more people, but you

117
00:05:21,780 --> 00:05:24,081
can't chat with everybody in PVP.net, for instance.

118
00:05:26,299 --> 00:05:28,880
There's also crafting just an enjoyable player experience.

119
00:05:29,320 --> 00:05:30,981
So one of the things we like to get right

120
00:05:31,061 --> 00:05:33,182
is when we release a feature, we like for everybody

121
00:05:33,222 --> 00:05:34,703
to be able to get their hands on it.

122
00:05:35,823 --> 00:05:38,684
How many people have ever gotten a Christmas gift,

123
00:05:38,704 --> 00:05:40,865
and you pick the box up, and it kind of feels funny,

124
00:05:41,325 --> 00:05:46,007
and you open it up, and there's some inkjet printer printed out

125
00:05:46,067 --> 00:05:47,888
thing from Amazon that says, you will

126
00:05:47,928 --> 00:05:49,089
receive this in two weeks.

127
00:05:49,189 --> 00:05:51,489
Your mom didn't order it on time or something,

128
00:05:51,550 --> 00:05:52,570
so you got this stopgap.

129
00:05:53,450 --> 00:05:54,331
How many people like that?

130
00:05:55,175 --> 00:05:55,755
It sucks.

131
00:05:56,516 --> 00:05:58,496
So it's the same thing with gaming.

132
00:05:58,516 --> 00:06:01,277
We don't want to have this feature out and like, oh,

133
00:06:01,357 --> 00:06:04,037
well, only 1,000 people can play it right now or something.

134
00:06:04,077 --> 00:06:05,038
That's not what you want to do.

135
00:06:05,518 --> 00:06:07,258
And just like the Christmas gift,

136
00:06:07,678 --> 00:06:09,659
you'd almost wish that you didn't get the Christmas gift

137
00:06:09,739 --> 00:06:11,719
because now you just got to stare at this piece of paper

138
00:06:11,739 --> 00:06:13,380
and you're like, this isn't fun.

139
00:06:13,820 --> 00:06:15,660
Well, it's the same thing when we release features.

140
00:06:15,740 --> 00:06:18,301
I mean, if everyone can't play them, it's just not fun.

141
00:06:18,521 --> 00:06:20,521
I mean, it actually does the inverse.

142
00:06:20,581 --> 00:06:22,902
It creates negative will of the player base

143
00:06:22,982 --> 00:06:24,582
and people just aren't enjoying what they're doing.

144
00:06:25,482 --> 00:06:26,803
So when something goes out the door,

145
00:06:26,843 --> 00:06:28,584
we like to make sure that everybody can get it.

146
00:06:29,444 --> 00:06:32,365
The more recent example, for instance, was ranked teams.

147
00:06:32,385 --> 00:06:35,226
And then back before that, with Dominion.

148
00:06:35,386 --> 00:06:38,168
Dominion was in private, was in limited beta

149
00:06:38,188 --> 00:06:39,928
form for a couple days.

150
00:06:40,348 --> 00:06:42,509
And then flash forward to Monday, and here's Dominion.

151
00:06:42,709 --> 00:06:43,810
And everybody can go play it.

152
00:06:45,211 --> 00:06:47,431
So how do we create a system that balances this?

153
00:06:47,551 --> 00:06:49,492
We've got scale that continues to increase.

154
00:06:49,592 --> 00:06:52,073
But yet we want to deliver the highest quality

155
00:06:52,413 --> 00:06:53,634
all at the same time to the players.

156
00:06:55,207 --> 00:06:56,669
So that's what we're going to talk about today.

157
00:06:57,851 --> 00:06:59,813
Essentially, what I've tried to do

158
00:07:00,033 --> 00:07:01,595
is, over the last four years, we've

159
00:07:01,615 --> 00:07:03,498
developed a number of core strategies

160
00:07:03,698 --> 00:07:08,584
that have kind of evolved that we use to align with player

161
00:07:08,604 --> 00:07:10,487
value and being able to run League of Legends

162
00:07:10,547 --> 00:07:11,888
as an operational service.

163
00:07:12,982 --> 00:07:16,383
And I've tried to take the core things that we do and really

164
00:07:16,443 --> 00:07:17,904
get down to the essence of them.

165
00:07:17,984 --> 00:07:19,884
So it's not just me talking about, well, yeah, we did this

166
00:07:19,925 --> 00:07:20,345
cool thing.

167
00:07:20,385 --> 00:07:22,025
We wrote these lines of code, and here we go.

168
00:07:22,466 --> 00:07:23,666
You guys can't do anything with that.

169
00:07:24,246 --> 00:07:27,428
So we're going to start with the core items, and then we're

170
00:07:27,448 --> 00:07:30,789
going to work back and add some color commentary of how

171
00:07:30,809 --> 00:07:32,009
that applies to League of Legends.

172
00:07:32,350 --> 00:07:33,870
But at the end of the day, whether you've got a big

173
00:07:33,910 --> 00:07:38,992
project or a small project, if it's mobile or if it's a PC

174
00:07:39,012 --> 00:07:40,813
game, all the things that we're talking

175
00:07:40,833 --> 00:07:41,353
about should apply.

176
00:07:42,720 --> 00:07:44,920
So the first thing that we're going to talk about

177
00:07:44,940 --> 00:07:47,821
is we're going to talk about embracing Java and NoSQL.

178
00:07:48,022 --> 00:07:49,922
Although really most of this is NoSQL,

179
00:07:49,982 --> 00:07:52,223
so if you don't use Java, it's not a big deal.

180
00:07:52,883 --> 00:07:54,824
We're going to talk about how we think

181
00:07:54,884 --> 00:07:57,485
simple is the best way to go, followed up

182
00:07:57,525 --> 00:08:01,786
by coding a dynamic system, some scaling best practices,

183
00:08:02,146 --> 00:08:03,847
and then finally monitoring everything.

184
00:08:05,247 --> 00:08:05,408
So.

185
00:08:06,503 --> 00:08:07,845
Embracing Java and NoSQL.

186
00:08:08,607 --> 00:08:10,430
So the first problem that we have

187
00:08:10,510 --> 00:08:14,757
is how do we develop a system rapidly, but at the same time,

188
00:08:14,857 --> 00:08:16,320
plan for future capacity needs?

189
00:08:16,380 --> 00:08:18,203
Just like we saw with those slides a second ago.

190
00:08:18,544 --> 00:08:19,225
July is here.

191
00:08:19,726 --> 00:08:20,387
November is here.

192
00:08:23,324 --> 00:08:26,225
A little bit of context as we're going through the session this

193
00:08:26,305 --> 00:08:29,567
afternoon. The back-end platform systems for League of Legends

194
00:08:29,747 --> 00:08:33,489
are written in a Java-based stack. So we use a lot of

195
00:08:33,509 --> 00:08:37,771
different technologies at Riot. We use Adobe Flex, we use PHP,

196
00:08:37,992 --> 00:08:41,473
we've got a lot of C++ code. But we're going to kind of focus

197
00:08:41,554 --> 00:08:44,135
on this portion of the stack today that does a lot of the

198
00:08:44,175 --> 00:08:46,856
back-end systems with matchmaking, game server

199
00:08:46,896 --> 00:08:48,137
allocation, things of that nature.

200
00:08:49,815 --> 00:08:53,219
As far as what the stack looks like in a little more detail,

201
00:08:53,879 --> 00:08:55,881
we use a kind of a mix of old and new elements.

202
00:08:55,961 --> 00:08:57,743
If you've done anything in the Java ecosystem,

203
00:08:57,803 --> 00:09:01,127
Spring and Tomcat are pretty common things in that space.

204
00:09:01,528 --> 00:09:04,190
And then we use a caching technology from Oracle

205
00:09:04,210 --> 00:09:05,152
called Oracle Coherence.

206
00:09:06,253 --> 00:09:07,574
So before I dive into NoSQL.

207
00:09:08,782 --> 00:09:10,523
When we were developing League of Legends,

208
00:09:10,583 --> 00:09:13,104
well, I couldn't tell you that we would be where we're at today

209
00:09:13,144 --> 00:09:14,464
in terms of CC or players.

210
00:09:15,045 --> 00:09:16,905
We didn't always have an eye towards the future.

211
00:09:17,225 --> 00:09:19,986
And part of building something is not just building it,

212
00:09:20,366 --> 00:09:22,327
it's being able to sustain it and grow it.

213
00:09:22,947 --> 00:09:26,129
So given that, we wanted to be able to continue

214
00:09:26,149 --> 00:09:27,769
to develop faster and faster.

215
00:09:27,829 --> 00:09:28,970
So we used a lot of open source.

216
00:09:29,330 --> 00:09:30,470
You can do that with any language,

217
00:09:30,530 --> 00:09:31,871
whether it's in Python or in Ruby.

218
00:09:33,092 --> 00:09:34,072
Big is tooling.

219
00:09:34,812 --> 00:09:37,453
Technology has almost always failed my five-minute test

220
00:09:37,493 --> 00:09:38,194
because of tooling.

221
00:09:38,614 --> 00:09:41,595
You pull something up in an IDE or some editor

222
00:09:41,635 --> 00:09:42,835
that's supposed to support a language,

223
00:09:42,855 --> 00:09:43,596
and then it doesn't work.

224
00:09:44,116 --> 00:09:46,617
Or you try to run the debugger, or you try to run a profiler.

225
00:09:47,137 --> 00:09:49,638
So there are languages that are more concise,

226
00:09:50,218 --> 00:09:54,220
but that's not the entire part of the delivery pipeline.

227
00:09:54,880 --> 00:09:56,141
You have to be able to debug things.

228
00:09:56,161 --> 00:09:57,561
You have to be able to performance tune.

229
00:09:57,581 --> 00:10:00,262
And if you don't have the right tools to be able to do that,

230
00:10:01,166 --> 00:10:02,168
then you run into problems.

231
00:10:02,750 --> 00:10:05,396
So we always try to take both tools and language into account

232
00:10:05,416 --> 00:10:07,020
when we're delivering features at Riot.

233
00:10:08,320 --> 00:10:10,622
We also looked at the fact that we had a large pool of

234
00:10:10,642 --> 00:10:11,703
developers to pull from.

235
00:10:11,883 --> 00:10:14,325
There are a lot of buzzword-centric technologies

236
00:10:14,385 --> 00:10:16,627
right now that are awesome technologies, but you can't

237
00:10:16,667 --> 00:10:18,169
hire anybody to do anything with them.

238
00:10:18,489 --> 00:10:20,591
You'll find one guy, and the other two guys got a job

239
00:10:20,631 --> 00:10:21,211
somewhere else.

240
00:10:21,992 --> 00:10:23,333
So that's also a problem.

241
00:10:23,573 --> 00:10:26,796
So one of the things we liked about Java is there's a large

242
00:10:26,836 --> 00:10:29,858
talent pool of really awesome developers that we can work

243
00:10:29,898 --> 00:10:32,380
with to continue to raise the bar of our engineering teams.

244
00:10:37,043 --> 00:10:39,023
As I mentioned earlier, we use a product from Oracle

245
00:10:39,083 --> 00:10:40,204
called Oracle Coherence.

246
00:10:40,424 --> 00:10:42,144
But I like to always explain it.

247
00:10:42,244 --> 00:10:44,525
If you took the name off of it and threw the source code up

248
00:10:44,585 --> 00:10:47,826
on GitHub, it would just be classified as a NoSQL.

249
00:10:49,626 --> 00:10:51,086
Oh, PowerPoint says no.

250
00:10:51,927 --> 00:10:52,367
That's good.

251
00:10:55,908 --> 00:10:56,708
I blame the projector.

252
00:11:16,144 --> 00:11:17,405
And let me see.

253
00:11:17,645 --> 00:11:18,865
I think I can just skip ahead.

254
00:11:18,885 --> 00:11:31,050
There we go.

255
00:11:31,811 --> 00:11:32,671
OK, try this again.

256
00:11:33,111 --> 00:11:35,792
So if you put it up on GitHub, it

257
00:11:35,812 --> 00:11:37,913
would just be classified as a NoSQL technology.

258
00:11:38,963 --> 00:11:43,424
The other thing is when we started development of League

259
00:11:43,444 --> 00:11:47,785
of Legends four years ago, the NoSQL space was different than

260
00:11:47,825 --> 00:11:48,366
it is today.

261
00:11:48,586 --> 00:11:51,546
So we do use different NoSQL technologies at Riot today.

262
00:11:51,606 --> 00:11:53,887
We use Redis for some things, MongoDB.

263
00:11:54,327 --> 00:11:56,447
But back when we were making decisions four years ago, to

264
00:11:56,747 --> 00:11:59,688
start with, this was one of the more established choices.

265
00:12:00,228 --> 00:12:02,049
Coherence is used a lot in the financial space.

266
00:12:02,089 --> 00:12:05,609
So there's a lot of large clusters that do a lot of

267
00:12:05,629 --> 00:12:06,870
high-performance computing behind it.

268
00:12:09,176 --> 00:12:11,318
So the big thing that coherence gives us,

269
00:12:11,378 --> 00:12:13,400
and you get these with a lot of NoSQL technologies,

270
00:12:13,520 --> 00:12:14,681
you get horizontal scaling.

271
00:12:15,302 --> 00:12:17,123
That's helped us simplify absorbing

272
00:12:17,223 --> 00:12:18,424
CCU growth over time.

273
00:12:18,484 --> 00:12:20,466
So you can add boxes, the data partitions.

274
00:12:21,127 --> 00:12:23,189
So that's a pretty good combination.

275
00:12:23,729 --> 00:12:25,751
The other thing that you get from a lot of NoSQL

276
00:12:25,791 --> 00:12:27,933
technologies, and we talk a little bit more about this

277
00:12:27,973 --> 00:12:30,435
later in the presentation, it's not just about the tech.

278
00:12:30,956 --> 00:12:32,978
A lot of them have patterns of the way you interact with

279
00:12:33,018 --> 00:12:33,098
them.

280
00:12:34,389 --> 00:12:36,530
And given those patterns, the real power

281
00:12:36,630 --> 00:12:39,072
is what they're enforcing with those patterns that

282
00:12:39,132 --> 00:12:41,773
then translates out in scale and other benefits later.

283
00:12:43,895 --> 00:12:46,796
And I started this with the presentation view again.

284
00:12:48,677 --> 00:12:49,098
One more time.

285
00:12:49,798 --> 00:12:50,538
Sorry about that, guys.

286
00:12:52,640 --> 00:12:53,880
It is possessed today.

287
00:13:00,304 --> 00:13:00,364
OK.

288
00:13:02,808 --> 00:13:04,890
As far as how we use coherence, one way that people

289
00:13:04,990 --> 00:13:07,051
use caching technology is how many people use memcache?

290
00:13:08,452 --> 00:13:09,893
So a lot of times with memcache, we'll

291
00:13:09,913 --> 00:13:11,335
do a cache to the side pattern, where

292
00:13:11,355 --> 00:13:12,956
you have some sort of data access tier,

293
00:13:13,236 --> 00:13:15,418
and then you load data from a database,

294
00:13:15,518 --> 00:13:19,281
and then we turn around and put the data in the cache

295
00:13:19,301 --> 00:13:20,482
to then read from memory.

296
00:13:20,902 --> 00:13:22,764
And normally, it's some sort of distributed memory.

297
00:13:23,824 --> 00:13:25,246
Because you have too much data or something,

298
00:13:25,286 --> 00:13:26,727
it's not going to fit on a local machine.

299
00:13:26,747 --> 00:13:28,708
Well, in our case, we're going to do a cache.

300
00:13:29,845 --> 00:13:32,166
we actually take the cache and pull it over here.

301
00:13:32,446 --> 00:13:35,428
And it's actually the first level that the DAO talks to.

302
00:13:35,928 --> 00:13:37,449
In a lot of cases, I tell the engineers,

303
00:13:37,489 --> 00:13:39,390
just forget that there's a database even back there.

304
00:13:40,011 --> 00:13:44,593
So the benefit of that is it's much more direct at one level.

305
00:13:44,693 --> 00:13:46,194
But then we're also taking advantage

306
00:13:46,234 --> 00:13:47,815
of all the different technologies that

307
00:13:47,855 --> 00:13:50,797
are in the NoSQL and slash caching layer itself.

308
00:13:52,070 --> 00:13:54,291
A lot of times to get real performant things,

309
00:13:54,311 --> 00:13:56,572
you're going to have to get down into the technology.

310
00:13:56,712 --> 00:13:59,094
The idea of we're going to do everything agnostic

311
00:13:59,934 --> 00:14:01,415
starts to kind of break down at some point,

312
00:14:01,455 --> 00:14:03,396
because you need something that you're just not

313
00:14:03,416 --> 00:14:04,977
going to get in an agnostic sense.

314
00:14:06,078 --> 00:14:07,579
Just like if you've written SQL and then

315
00:14:07,599 --> 00:14:10,600
you need to get down to some stored procedure technology

316
00:14:10,640 --> 00:14:13,342
in Postgres or MySQL, you can't write it in plain vanilla

317
00:14:13,362 --> 00:14:14,002
a lot of times.

318
00:14:14,923 --> 00:14:17,204
So we get a lot of power from doing that, though.

319
00:14:18,100 --> 00:14:22,504
The biggest thing is grid computing. I can write one line

320
00:14:22,544 --> 00:14:26,989
of code and run a query or run a mutation operation and it will

321
00:14:27,009 --> 00:14:30,312
turn around and use 200 cores seamlessly and come back with

322
00:14:30,352 --> 00:14:33,035
some sort of result. I don't have to worry about well will it

323
00:14:33,075 --> 00:14:36,178
not come back, what if it gets duplicate data coming back, it's

324
00:14:36,218 --> 00:14:37,419
just one line of code and that's it.

325
00:14:38,348 --> 00:14:41,210
That's a really cool thing, because now engineers at Riot,

326
00:14:41,230 --> 00:14:42,731
we don't have to focus on, well, how

327
00:14:42,751 --> 00:14:45,294
do I deal with all the plumbing of 200 cores?

328
00:14:45,674 --> 00:14:46,334
I just use them.

329
00:14:46,555 --> 00:14:48,136
So I can go back and do what I want to do,

330
00:14:48,276 --> 00:14:49,597
which is focus on player value.

331
00:14:50,558 --> 00:14:52,199
We also get things, as I mentioned earlier,

332
00:14:52,239 --> 00:14:54,001
like transparent partitioning.

333
00:14:54,381 --> 00:14:56,022
So we can add machines to the cluster,

334
00:14:56,302 --> 00:14:58,824
and our scale pretty much goes out linearly

335
00:14:59,185 --> 00:15:00,426
in a very predictable fashion.

336
00:15:03,929 --> 00:15:05,750
So moving a little bit away from the setup now.

337
00:15:06,721 --> 00:15:08,661
The next thing is simple is best.

338
00:15:08,901 --> 00:15:12,022
So how do we develop features quickly, but at the same time

339
00:15:12,402 --> 00:15:14,483
don't drown ourselves in bugs and technical debt?

340
00:15:16,423 --> 00:15:20,064
So a modern CPU will do more than 3 billion instructions.

341
00:15:20,544 --> 00:15:21,044
That's a lot.

342
00:15:21,624 --> 00:15:23,184
You can throw away and mess around

343
00:15:23,224 --> 00:15:25,325
with 2.5 billion instructions and still

344
00:15:25,345 --> 00:15:27,485
have 500 million instructions to do something with.

345
00:15:28,605 --> 00:15:31,066
Most code I've seen, 500 million instructions

346
00:15:31,106 --> 00:15:33,707
is plenty for most types of things that you're doing.

347
00:15:35,054 --> 00:15:37,656
The other thing is, technology these days is fast.

348
00:15:38,317 --> 00:15:39,918
I'm not saying you don't need to pay attention to it

349
00:15:39,998 --> 00:15:43,281
and make smart decisions, but languages are fast,

350
00:15:43,581 --> 00:15:45,282
memories fast, networks fast.

351
00:15:46,223 --> 00:15:47,824
Used to, when I was fresh out of college,

352
00:15:47,884 --> 00:15:50,066
you'd have all these debates about this language is fast,

353
00:15:50,086 --> 00:15:52,088
this language is slow, this is interpreted,

354
00:15:52,128 --> 00:15:53,168
you can never use it for that.

355
00:15:53,749 --> 00:15:55,250
I don't hear a lot of that these days.

356
00:15:55,510 --> 00:15:57,252
If you read hacker news, most of the stuff

357
00:15:57,312 --> 00:15:59,193
is not about a language being fast or slow.

358
00:15:59,928 --> 00:16:03,232
I mean, there's all kinds of things with JavaScript,

359
00:16:03,312 --> 00:16:05,375
with Node.js out there, and Python,

360
00:16:05,395 --> 00:16:06,516
and all kinds of new languages.

361
00:16:06,576 --> 00:16:10,180
So it's really not so much about raw language speed anymore.

362
00:16:11,462 --> 00:16:13,685
The other thing is, complexity at the end of the day

363
00:16:13,725 --> 00:16:14,866
is the enemy of quality.

364
00:16:15,627 --> 00:16:17,249
The more complex things are, I can give you

365
00:16:17,269 --> 00:16:19,512
a laundry list of reasons why that's a problem.

366
00:16:20,933 --> 00:16:24,315
uh, you know, long methods with lots of code in them, if you

367
00:16:24,335 --> 00:16:27,817
try to transition it to a new engineer, you know, that, that

368
00:16:27,917 --> 00:16:31,260
handoff has problems. You know, there's unforeseen edge cases,

369
00:16:31,340 --> 00:16:34,842
there's bugs that pop up, if you want to reuse code between this

370
00:16:34,902 --> 00:16:37,243
piece of a system over here and this piece of a system over

371
00:16:37,263 --> 00:16:41,606
there, it doesn't quite fit right because it's too big. So

372
00:16:41,626 --> 00:16:45,769
at the end of the day, our big thing is to not overdesign. So

373
00:16:45,829 --> 00:16:47,750
let's, let's dig into a little bit of that. So,

374
00:16:49,097 --> 00:16:50,438
One of the theories that we use is this thing

375
00:16:50,458 --> 00:16:51,479
what we call rig the game.

376
00:16:51,799 --> 00:16:54,501
So you can have some sort of operation

377
00:16:54,541 --> 00:16:56,582
that you need to do multiple things at the same time.

378
00:16:57,062 --> 00:16:58,683
And you can do a lot of coordination,

379
00:16:59,384 --> 00:17:01,866
but it's usually easier to kind of divide the inputs up

380
00:17:02,126 --> 00:17:04,967
in advance if you can kind of flip the problem inside out.

381
00:17:05,568 --> 00:17:07,289
So if we look at a visualization of that.

382
00:17:08,822 --> 00:17:11,825
You can have a bunch of threads and have work,

383
00:17:11,985 --> 00:17:13,207
and then have data that they share,

384
00:17:13,287 --> 00:17:14,448
and they can sit there and coordinate.

385
00:17:14,888 --> 00:17:16,550
But as you can see, just looking at this picture,

386
00:17:16,590 --> 00:17:17,811
the picture doesn't even look clean.

387
00:17:18,132 --> 00:17:19,033
You got all these lines.

388
00:17:19,073 --> 00:17:20,894
It kind of takes you a second to figure out what's going on.

389
00:17:22,856 --> 00:17:25,279
On the flip side, you can take the data.

390
00:17:26,588 --> 00:17:30,851
kind of nicely split it up based on pairing it up with the work.

391
00:17:31,232 --> 00:17:32,512
It's a much cleaner picture.

392
00:17:33,173 --> 00:17:35,555
The other thing is the code behind this is much simpler.

393
00:17:35,855 --> 00:17:37,196
Once the code gets a chunk of data,

394
00:17:37,256 --> 00:17:39,017
it does what it needs to do, and that's it.

395
00:17:39,057 --> 00:17:40,378
It doesn't have to worry about edge cases.

396
00:17:40,418 --> 00:17:42,960
It doesn't have to worry about dirty reads or anything else.

397
00:17:43,400 --> 00:17:44,661
It just goes about its business.

398
00:17:44,861 --> 00:17:47,603
And then that pattern will pretty much stack out.

399
00:17:48,483 --> 00:17:50,785
So a couple examples of that in League of Legends.

400
00:17:51,971 --> 00:17:54,354
Right around season one, we went through and reworked the game

401
00:17:54,374 --> 00:17:55,615
server allocation algorithm.

402
00:17:56,216 --> 00:17:57,838
I'll talk more about that later as well.

403
00:17:58,338 --> 00:17:59,740
One of the things that we did was

404
00:17:59,820 --> 00:18:02,122
we wrote it with the idea that it can partition itself.

405
00:18:03,239 --> 00:18:04,960
And for the longest time in production,

406
00:18:05,040 --> 00:18:06,661
we never turned it up more than one.

407
00:18:06,681 --> 00:18:09,703
There was just a level one running back there.

408
00:18:10,184 --> 00:18:11,645
But then when we got close to Dominion,

409
00:18:11,665 --> 00:18:13,186
if you went to Travis's presentation,

410
00:18:13,346 --> 00:18:15,368
one of the interesting characteristics of Dominion

411
00:18:15,428 --> 00:18:18,130
was the fact that games are now 20 minutes shorter

412
00:18:18,170 --> 00:18:18,610
for Dominion.

413
00:18:18,870 --> 00:18:20,171
So if the same quantity of players

414
00:18:20,191 --> 00:18:22,233
that used to play Summoner's Rift now play Dominion,

415
00:18:22,773 --> 00:18:25,175
it's twice as many people going through the turnstiles.

416
00:18:25,795 --> 00:18:29,518
So twice as many game starts, twice as many champ selects,

417
00:18:29,818 --> 00:18:31,680
twice as many statistics being processed,

418
00:18:31,880 --> 00:18:33,241
twice as many games being allocated.

419
00:18:33,841 --> 00:18:36,383
So when we were load testing for Dominion,

420
00:18:37,144 --> 00:18:39,345
we went and cranked the knob up, so to speak,

421
00:18:39,565 --> 00:18:40,626
validated the results.

422
00:18:41,770 --> 00:18:44,792
tweaked a couple little edge cases for things. You can run

423
00:18:44,812 --> 00:18:47,715
into things like starvation with this model. I mean you don't

424
00:18:47,755 --> 00:18:50,117
want to run out of game servers for instance. So we added a

425
00:18:50,137 --> 00:18:53,040
little bit of work stealing. So you didn't have one pool that

426
00:18:53,080 --> 00:18:55,362
got full and the other one didn't. But all in all it was a

427
00:18:55,402 --> 00:18:56,403
very simple migration.

428
00:19:01,399 --> 00:19:02,840
So the next thing I'm going to cover today

429
00:19:03,080 --> 00:19:05,141
is the concept of coding a dynamic system.

430
00:19:05,261 --> 00:19:06,842
And this is one of the key things

431
00:19:06,982 --> 00:19:10,945
that we've evolved to do at Riot over the last several years.

432
00:19:11,626 --> 00:19:16,189
So the big problem is how do we handle not only monthly change,

433
00:19:16,529 --> 00:19:18,370
but as you guys all know, every two weeks

434
00:19:18,831 --> 00:19:20,932
we push out a champion and use a couple skins.

435
00:19:20,972 --> 00:19:22,433
So we have biweekly change.

436
00:19:22,993 --> 00:19:25,115
And then we also have what I like to call hourly change.

437
00:19:26,113 --> 00:19:28,715
Change is not just when we decide that we're going to

438
00:19:28,755 --> 00:19:29,236
have change.

439
00:19:29,616 --> 00:19:30,637
Change just kind of happens.

440
00:19:31,478 --> 00:19:35,101
So I usually like to use the analogy, a single box or a

441
00:19:35,261 --> 00:19:37,683
developer laptop or workstation is a very

442
00:19:37,743 --> 00:19:38,584
predictable beast.

443
00:19:38,944 --> 00:19:41,967
It's got a set amount of memory, it has a set CPU on

444
00:19:42,027 --> 00:19:45,010
it, you run your code, it runs kind of in a predictable

445
00:19:45,050 --> 00:19:47,192
amount of time, and you know what you're going to get.

446
00:19:48,753 --> 00:19:50,955
A large system, however, changes while it's running.

447
00:19:52,229 --> 00:19:55,610
I usually say around the office, I mean, it's basically organic.

448
00:19:55,730 --> 00:19:58,031
There's inputs and outputs, and you see things ripple.

449
00:19:58,411 --> 00:20:00,231
But at the same time, you may not exactly know,

450
00:20:00,251 --> 00:20:01,211
well, why does that ripple?

451
00:20:01,692 --> 00:20:02,892
I see it, and I kind of know.

452
00:20:02,952 --> 00:20:04,412
But again, why is it doing that?

453
00:20:04,912 --> 00:20:06,373
There's all kinds of reasons for that.

454
00:20:06,553 --> 00:20:08,693
So a couple examples, just to give you guys a few

455
00:20:09,013 --> 00:20:10,054
that we've seen over the years.

456
00:20:10,974 --> 00:20:13,495
One thing, I think it was two summers ago,

457
00:20:14,835 --> 00:20:17,596
we had lots of player reports on the forums of issues

458
00:20:17,636 --> 00:20:18,156
in the game.

459
00:20:18,336 --> 00:20:20,156
And we kind of dug into our systems a little bit.

460
00:20:20,957 --> 00:20:25,403
and then it kind of went away. Well, late in the day we figured out, this happened to be Europe,

461
00:20:26,885 --> 00:20:32,512
there was I think a Champions League playoff going on and all the people in Europe were

462
00:20:32,572 --> 00:20:34,355
streaming the soccer matches over the internet.

463
00:20:35,109 --> 00:20:36,690
And the pipes were just a little bit full.

464
00:20:37,311 --> 00:20:39,253
So we were seeing a reflection, essentially,

465
00:20:39,273 --> 00:20:41,416
of the internet infrastructure in Europe.

466
00:20:41,816 --> 00:20:42,657
And it wasn't just us.

467
00:20:42,697 --> 00:20:44,179
All kinds of other games are seeing it, too.

468
00:20:44,639 --> 00:20:45,880
So that was something that didn't have anything

469
00:20:45,921 --> 00:20:47,642
to do with us doing a deploy, yet we

470
00:20:47,703 --> 00:20:52,007
had an operational change that we had to try to mitigate.

471
00:20:52,868 --> 00:20:56,048
A little different example that I'll tell on myself

472
00:20:56,849 --> 00:20:59,509
is back when we were in a real, real early beta.

473
00:21:00,349 --> 00:21:02,810
Of course, we were a 25, 30 person company.

474
00:21:03,590 --> 00:21:06,130
And our beta environment was sharing

475
00:21:06,170 --> 00:21:08,271
a certain amount of infrastructure and data centers

476
00:21:08,311 --> 00:21:10,291
that our load test environment was sharing.

477
00:21:10,951 --> 00:21:13,212
And I'm sitting in the office in Santa Monica.

478
00:21:13,432 --> 00:21:14,452
I've got my headphones on.

479
00:21:14,792 --> 00:21:16,732
I'm pounding the heck out of the system

480
00:21:16,772 --> 00:21:18,353
trying to raise the scale on some stuff.

481
00:21:18,933 --> 00:21:21,014
And all of a sudden everybody around me starts asking, why

482
00:21:21,034 --> 00:21:22,355
do we have lag in the system?

483
00:21:22,395 --> 00:21:23,076
What's going on here?

484
00:21:23,156 --> 00:21:24,216
And the forums go crazy.

485
00:21:24,336 --> 00:21:25,978
I'm like, it's probably me.

486
00:21:26,618 --> 00:21:29,220
So I clicked the little button, stopped the load test, and

487
00:21:29,460 --> 00:21:30,601
sure enough, everything went away.

488
00:21:30,781 --> 00:21:33,402
Well, it turns out I had saturated a couple switches

489
00:21:33,422 --> 00:21:35,444
and a few other things sitting there in the office with my

490
00:21:35,484 --> 00:21:37,985
little botnet of load test harnesses.

491
00:21:38,526 --> 00:21:41,408
So that was another example of something that just kind of

492
00:21:41,468 --> 00:21:42,328
came out of the left field.

493
00:21:43,305 --> 00:21:45,066
But there's much more practical things, too.

494
00:21:45,206 --> 00:21:47,526
I mean, you get hardware failures.

495
00:21:47,986 --> 00:21:49,527
If you do the math on large systems,

496
00:21:49,547 --> 00:21:52,727
you know, a hard drive will die about once a year on average.

497
00:21:52,767 --> 00:21:54,008
So if you have enough boxes, you're

498
00:21:54,028 --> 00:21:55,428
going to get a hard drive that dies every day.

499
00:21:56,248 --> 00:21:58,368
So the question is, when do we fix this?

500
00:21:59,809 --> 00:22:00,849
Do we do it next release?

501
00:22:01,389 --> 00:22:02,849
Do we create a downtime?

502
00:22:03,669 --> 00:22:05,650
Well, if we do it next release, what if it's a big problem?

503
00:22:06,210 --> 00:22:07,510
Again, player value.

504
00:22:08,653 --> 00:22:11,134
Another one would be, what if we do it during a downtime?

505
00:22:11,194 --> 00:22:13,116
Well, we can pick lighter downtimes,

506
00:22:13,356 --> 00:22:15,217
but that doesn't mean there's not people playing.

507
00:22:15,717 --> 00:22:17,718
For instance, we hired a new engineer the other day,

508
00:22:17,759 --> 00:22:20,060
and we were talking, and he's got a young son,

509
00:22:20,140 --> 00:22:21,521
so he gets up at five in the morning

510
00:22:22,381 --> 00:22:23,602
and would play League of Legends,

511
00:22:24,022 --> 00:22:25,163
get a couple games in in the morning.

512
00:22:25,243 --> 00:22:27,905
Well, we might be doing downtime at 5 a.m. Pacific.

513
00:22:28,065 --> 00:22:30,686
So yeah, that doesn't affect the masses,

514
00:22:30,967 --> 00:22:33,188
but he's just as valuable as they are.

515
00:22:33,348 --> 00:22:35,830
So, you know, you wanna try to not have downtime as well

516
00:22:35,870 --> 00:22:36,770
when you have to fix things.

517
00:22:38,364 --> 00:22:39,244
So that's not going to work.

518
00:22:40,185 --> 00:22:42,286
So there's a variety of ways that we come about

519
00:22:42,446 --> 00:22:44,487
making things dynamic.

520
00:22:44,867 --> 00:22:46,228
One of them is picking technologies

521
00:22:46,268 --> 00:22:47,289
with elastic properties.

522
00:22:48,429 --> 00:22:50,150
As we talked about earlier, like NoSQL.

523
00:22:50,351 --> 00:22:52,792
You get dynamic cluster recomposition

524
00:22:52,852 --> 00:22:54,073
if you need to pull nodes.

525
00:22:55,073 --> 00:22:57,215
We try to pick a lot of things with stateless growth patterns

526
00:22:57,255 --> 00:23:00,156
so we can add boxes in and put them behind the load balancer

527
00:23:00,216 --> 00:23:01,177
and add capacity.

528
00:23:02,275 --> 00:23:06,699
things of that nature. Now, not everything has to be elastic. A

529
00:23:06,759 --> 00:23:09,141
lot of times you'll get force multipliers. So like for

530
00:23:09,181 --> 00:23:12,583
instance, our caching tier, that helps a lot of things. It's

531
00:23:12,623 --> 00:23:15,185
less load on things in the front. It can kind of spread out

532
00:23:15,225 --> 00:23:18,188
across the caching tier. You also get things in different

533
00:23:18,208 --> 00:23:20,670
places in the stack, maybe sometimes behind the caching

534
00:23:20,690 --> 00:23:24,833
tier. So like in our case, we do right behind batching for

535
00:23:24,873 --> 00:23:25,353
certain things.

536
00:23:25,874 --> 00:23:29,655
So, that actually gives us, in some ways, a little more

537
00:23:29,835 --> 00:23:31,836
robustness for the database, because the database doesn't

538
00:23:31,856 --> 00:23:34,477
have to work as hard. There's not as many simultaneous open

539
00:23:34,497 --> 00:23:38,259
connections. Being able to take a larger chunk of data, the

540
00:23:38,279 --> 00:23:42,061
databases can optimize a little different. So, compared to what

541
00:23:42,101 --> 00:23:46,963
I've seen on a lot of crazy rigs and setups with 50, 100 MySQL

542
00:23:47,003 --> 00:23:50,365
instances, we don't have to run near as much per CCU as what

543
00:23:50,385 --> 00:23:52,445
I've seen for a lot of things that just go straight to a

544
00:23:52,465 --> 00:23:53,446
database, for example.

545
00:23:54,967 --> 00:23:57,788
Now, it's also not just about technology.

546
00:23:57,868 --> 00:23:59,309
It's about what you do with your code.

547
00:23:59,729 --> 00:24:01,750
Your code is probably the biggest thing

548
00:24:02,370 --> 00:24:03,231
that you're going to run into.

549
00:24:03,331 --> 00:24:04,231
It's things that you've done.

550
00:24:04,271 --> 00:24:06,332
And we've done lots of these ourselves.

551
00:24:07,193 --> 00:24:07,893
I'm not going to lie.

552
00:24:07,913 --> 00:24:10,214
When we first rolled League of Legends out, guess what we did?

553
00:24:10,234 --> 00:24:12,135
We had properties and config files.

554
00:24:12,656 --> 00:24:13,736
But that's what everybody else does.

555
00:24:13,777 --> 00:24:16,839
They've got their little XML or their JSON or their text file,

556
00:24:16,879 --> 00:24:17,560
and hey, that works.

557
00:24:18,260 --> 00:24:20,222
Works real good until the system is

558
00:24:20,582 --> 00:24:22,704
having an issue at 5 o'clock on Friday afternoon,

559
00:24:22,764 --> 00:24:25,066
and you don't want to have to reboot it to change a setting.

560
00:24:25,887 --> 00:24:28,449
So all of our settings are dynamic these days.

561
00:24:29,527 --> 00:24:32,349
And then we use coherence to basically propagate out

562
00:24:32,389 --> 00:24:32,809
the data.

563
00:24:33,090 --> 00:24:34,691
But you can use all kinds of different things.

564
00:24:35,211 --> 00:24:38,734
I think Netflix the other day did a white paper, something

565
00:24:39,255 --> 00:24:41,156
that I saw that they're using Zookeeper to push out

566
00:24:41,196 --> 00:24:42,137
configuration changes.

567
00:24:42,918 --> 00:24:45,600
Now the other thing that people get hung up on is, well, oh,

568
00:24:45,840 --> 00:24:47,121
when do I push those changes?

569
00:24:47,201 --> 00:24:48,162
How do I make this happen?

570
00:24:48,282 --> 00:24:49,964
Because I need to make sure it happens at right,

571
00:24:50,264 --> 00:24:51,105
this exact second.

572
00:24:51,585 --> 00:24:56,571
Well, with a larger running system or just any system in general, there is no exact second.

573
00:24:56,812 --> 00:24:58,514
There's people and there's still people.

574
00:24:58,794 --> 00:25:00,616
So there's just before and after.

575
00:25:01,077 --> 00:25:05,262
So it doesn't matter that you get lost in the minutia of it has to go out right here.

576
00:25:06,263 --> 00:25:08,566
It's just before and after and it needs to be a reasonable amount of time.

577
00:25:09,628 --> 00:25:13,410
The other thing is your algorithms have to be able to take advantage of this.

578
00:25:13,731 --> 00:25:17,914
You can push out a new setting, but if your system doesn't ever pay attention to it, it doesn't matter.

579
00:25:18,474 --> 00:25:22,637
So a lot of our algorithms essentially, they'll loop, or they'll come back around,

580
00:25:22,677 --> 00:25:26,760
and every so often look and see, oh, well this value went from 5 to 10, let me adjust.

581
00:25:31,140 --> 00:25:33,662
So looking at some more specific examples of this,

582
00:25:34,422 --> 00:25:35,703
all the thread pools that we've got,

583
00:25:36,003 --> 00:25:37,263
we've added wrappers to them to be

584
00:25:37,323 --> 00:25:38,524
able to config them on the fly.

585
00:25:39,404 --> 00:25:42,086
Let's just say it's not a good thing if we have a box that's

586
00:25:42,126 --> 00:25:45,748
running at 10% CPU, and we have some operational issue,

587
00:25:46,568 --> 00:25:48,849
and Mark Mill's like, well, can we fix it?

588
00:25:48,909 --> 00:25:50,810
And I'm like, well, we have lots of hardware,

589
00:25:50,850 --> 00:25:52,871
but no, I can't get any more threads out of it right now.

590
00:25:53,331 --> 00:25:54,372
I mean, that's just silly.

591
00:25:54,752 --> 00:25:57,473
So all the threads we can tweak on the fly if we need to.

592
00:25:58,622 --> 00:26:01,404
We've taken this up a couple levels in recent years as well.

593
00:26:02,005 --> 00:26:04,746
We can change roles in machines, pull them in and out.

594
00:26:05,747 --> 00:26:07,848
This helps a lot with hot fixes.

595
00:26:08,028 --> 00:26:11,971
We can do much smaller hot fixes on back end server side things

596
00:26:12,011 --> 00:26:12,231
now.

597
00:26:12,652 --> 00:26:15,153
And we can also do different things with features

598
00:26:15,834 --> 00:26:18,816
without just ruling them out as part of the Big Bang Deploy.

599
00:26:19,216 --> 00:26:21,297
So Dominion, again, was a perfect example of that.

600
00:26:21,317 --> 00:26:21,938
Dominion was out.

601
00:26:22,939 --> 00:26:26,742
we were able to do some kind of real world beta testing with it

602
00:26:26,783 --> 00:26:27,643
and then just flip it on.

603
00:26:28,084 --> 00:26:30,346
So that works out really good to be able to manage that.

604
00:26:34,109 --> 00:26:35,870
So the next thing I'm going to dive into

605
00:26:36,131 --> 00:26:38,232
is scaling best practices.

606
00:26:38,493 --> 00:26:41,435
So what happens when we follow all these rules for scaling

607
00:26:41,455 --> 00:26:42,856
that we see floating around the internet

608
00:26:43,757 --> 00:26:44,838
and we still run into issues?

609
00:26:48,261 --> 00:26:50,703
So this is my modern scaling Cliff Notes.

610
00:26:51,516 --> 00:26:53,497
as I like to call it, when we do engineering,

611
00:26:53,637 --> 00:26:55,578
onboarding at Riot.

612
00:26:55,958 --> 00:26:57,599
So we start out, and scaling is hard.

613
00:26:58,800 --> 00:27:00,541
So let's get rid of some things so it's easier.

614
00:27:02,302 --> 00:27:02,882
What do we get rid of?

615
00:27:02,902 --> 00:27:03,522
Does anybody know?

616
00:27:03,542 --> 00:27:05,944
There's all kinds of options, and then there's

617
00:27:05,964 --> 00:27:07,164
these things that you use all the time.

618
00:27:07,184 --> 00:27:08,245
You're like, I can't get rid of that.

619
00:27:09,305 --> 00:27:10,066
So then we go the other way.

620
00:27:10,166 --> 00:27:11,046
We're like, all right, I'll start

621
00:27:11,066 --> 00:27:12,067
with a blank sheet of paper.

622
00:27:12,727 --> 00:27:14,488
And we're going to just put three things on there

623
00:27:14,508 --> 00:27:15,028
and call it a day.

624
00:27:17,608 --> 00:27:20,210
And then, once we only have three things, we can optimize.

625
00:27:20,430 --> 00:27:22,912
So let's say we make a choice that the minimum user that

626
00:27:22,952 --> 00:27:25,193
plays League of Legends has to have a two megabit internet

627
00:27:25,213 --> 00:27:25,553
connection.

628
00:27:25,634 --> 00:27:28,656
Well, I don't have to optimize for a 56k modem anymore,

629
00:27:29,136 --> 00:27:29,676
as an example.

630
00:27:30,317 --> 00:27:32,859
There might be some other decisions I can make.

631
00:27:32,939 --> 00:27:35,080
Maybe my art assets can be a little bit bigger,

632
00:27:35,140 --> 00:27:36,881
because I know they can come down faster.

633
00:27:37,844 --> 00:27:40,847
So if we take that and we take that concept

634
00:27:40,887 --> 00:27:42,488
and we look at it with some different technologies,

635
00:27:42,508 --> 00:27:43,990
how many people know what MapReduce is?

636
00:27:44,390 --> 00:27:47,012
So a lot of the Hadoop stuff in the BI space these days,

637
00:27:47,553 --> 00:27:49,354
it's a concept called MapReduce under the hood.

638
00:27:50,135 --> 00:27:52,037
And really, MapReduce is saying, well, we're

639
00:27:52,057 --> 00:27:53,618
going to solve all of our problems

640
00:27:53,638 --> 00:27:55,039
with a Map step and a Reduce step.

641
00:27:55,159 --> 00:27:57,341
And then we can optimize the heck out of how that operates.

642
00:27:59,339 --> 00:28:03,080
With NoSQL. A lot of NoSQL is, I'm going to just take your joins away.

643
00:28:03,641 --> 00:28:05,601
Because the average case is awesome on your joins,

644
00:28:06,101 --> 00:28:10,183
but the un-average case that we need to join two big tables

645
00:28:10,383 --> 00:28:11,583
causes you performance problems.

646
00:28:11,863 --> 00:28:14,424
So if you don't do that most of the time, you won't have problems.

647
00:28:15,044 --> 00:28:18,825
Now, interestingly enough, most NoSQL technologies are putting joins back,

648
00:28:19,045 --> 00:28:22,667
secondary indexes, and NoSQL, and SQL now, it's kind of funny.

649
00:28:24,107 --> 00:28:26,328
Another one's CapTheorem. How many people know what CapTheorem is?

650
00:28:27,470 --> 00:28:29,613
So, CAP theorem is this theory that says you've got

651
00:28:31,414 --> 00:28:34,177
consistency, availability, and partitioning.

652
00:28:34,458 --> 00:28:35,359
And you can only pick two.

653
00:28:35,859 --> 00:28:37,781
So, if you want consistency and availability,

654
00:28:37,861 --> 00:28:39,303
it's kind of hard to partition stuff.

655
00:28:39,663 --> 00:28:40,884
Whereas, if you have availability,

656
00:28:40,904 --> 00:28:42,266
and you can seamlessly partition,

657
00:28:42,746 --> 00:28:44,828
keeping things completely consistent all the time

658
00:28:44,848 --> 00:28:45,489
will cause problems.

659
00:28:48,854 --> 00:28:50,576
So looking at this at a little more practical level,

660
00:28:50,976 --> 00:28:53,478
the common example, if you read a lot of big data stuff

661
00:28:53,558 --> 00:28:55,840
or scaling data in general, is they talk

662
00:28:55,860 --> 00:28:56,941
about keeping stuff together.

663
00:28:57,361 --> 00:28:59,823
So they usually always use this example of a blog entry.

664
00:29:00,524 --> 00:29:01,885
And the blog entry has a comment.

665
00:29:01,905 --> 00:29:03,246
You can store them in the same record.

666
00:29:04,266 --> 00:29:05,087
Then you do something.

667
00:29:05,868 --> 00:29:09,271
I write some crazy discussion on

668
00:29:10,754 --> 00:29:13,935
on the League of Legends forums with a blog, one of our blogs

669
00:29:13,975 --> 00:29:16,257
about something about this champion is the best champion

670
00:29:16,297 --> 00:29:18,238
ever. Well, everybody gets on there and says, no, you're

671
00:29:18,258 --> 00:29:22,720
crazy. So now I have 300 comments that are all stored in

672
00:29:22,760 --> 00:29:27,463
the same record. And now my code that's manipulating that has a

673
00:29:27,503 --> 00:29:30,424
different performance characteristic. But we're not

674
00:29:30,464 --> 00:29:32,605
here to talk about blog comments. So let's talk about a

675
00:29:32,646 --> 00:29:34,246
very practical example of the same thing.

676
00:29:35,243 --> 00:29:38,865
So with League of Legends, we have servers that run lots of

677
00:29:39,605 --> 00:29:40,865
League of Legends server processes.

678
00:29:42,506 --> 00:29:45,266
And we have a root object that represents the server.

679
00:29:46,467 --> 00:29:48,948
And there's a bunch of child objects that represent the

680
00:29:49,128 --> 00:29:50,668
game server processes underneath that.

681
00:29:50,828 --> 00:29:53,269
And we use that as part of our game server

682
00:29:53,289 --> 00:29:54,089
provisioning algorithm.

683
00:29:56,614 --> 00:29:59,155
So, the thing that's interesting is, over time,

684
00:29:59,195 --> 00:30:02,377
the complexity of those child objects has gotten larger.

685
00:30:02,557 --> 00:30:03,697
We have more game modes now.

686
00:30:03,737 --> 00:30:04,898
There's more champions in the game.

687
00:30:05,718 --> 00:30:08,160
And the number of games per server, we're more efficient,

688
00:30:08,460 --> 00:30:10,261
and we run larger hardware than we used to.

689
00:30:11,722 --> 00:30:13,823
So if you kind of dig down into the data model a little more,

690
00:30:14,143 --> 00:30:14,963
you've got a machine.

691
00:30:15,624 --> 00:30:17,865
It might have game instances with name and player

692
00:30:17,885 --> 00:30:18,605
in some different state.

693
00:30:19,526 --> 00:30:23,968
Well, the problem is, all that's happening at the same time.

694
00:30:25,672 --> 00:30:27,214
And these child objects start to get bigger.

695
00:30:27,934 --> 00:30:30,496
And I've got tons of instances on a server.

696
00:30:31,277 --> 00:30:34,359
So I go from pushing 20K of data around

697
00:30:34,379 --> 00:30:36,421
to maybe pushing more than a half a mega data around.

698
00:30:38,202 --> 00:30:39,784
And even though I said things are fast,

699
00:30:40,144 --> 00:30:41,445
things aren't infinitely fast.

700
00:30:42,066 --> 00:30:44,868
So I start having network transfer and object

701
00:30:44,908 --> 00:30:47,790
serialization being bounding factors to my game server

702
00:30:47,830 --> 00:30:48,571
provisioning algorithm.

703
00:30:50,176 --> 00:30:53,479
You've also got the fact that this algorithm performs exactly

704
00:30:53,539 --> 00:30:55,861
the opposite of how you would want as an engineer.

705
00:30:56,441 --> 00:30:58,623
As you get more people on the system, it goes slower.

706
00:30:59,244 --> 00:31:01,265
At a minimum, you want it to run at constant speed.

707
00:31:01,886 --> 00:31:06,009
And even better would be to find a clever way with technologies

708
00:31:06,049 --> 00:31:08,051
used like ring buffers to actually run faster

709
00:31:08,091 --> 00:31:08,972
when there's more load on it.

710
00:31:09,652 --> 00:31:10,653
But we're going the opposite.

711
00:31:11,193 --> 00:31:13,275
So essentially, we've kind of got the pipe full.

712
00:31:13,415 --> 00:31:15,037
I mean, yeah, we may not be saturating a 1 gig.

713
00:31:16,598 --> 00:31:21,258
you know, network segment, but we're still bound by moving all that data around.

714
00:31:22,472 --> 00:31:25,073
So at this point, we had to go back before season one

715
00:31:25,113 --> 00:31:27,153
and review and basically say, do we really

716
00:31:27,213 --> 00:31:28,234
have one object anymore?

717
00:31:28,414 --> 00:31:29,094
We thought we did.

718
00:31:29,474 --> 00:31:31,655
But when we really dug into it, there's actually,

719
00:31:32,375 --> 00:31:34,376
even though both objects are about a game,

720
00:31:34,416 --> 00:31:35,536
they have very different roles.

721
00:31:36,117 --> 00:31:38,437
So we had to go through and divide those objects up

722
00:31:39,178 --> 00:31:41,899
with one having the players in some different state

723
00:31:41,919 --> 00:31:44,740
that we need for pregame and another object that

724
00:31:44,780 --> 00:31:46,761
represents just the state we need for game server

725
00:31:46,821 --> 00:31:47,261
allocation.

726
00:31:48,041 --> 00:31:51,384
At that point, that object became a very consistent fixed size.

727
00:31:52,005 --> 00:31:53,806
So now the pipe is much better.

728
00:31:54,167 --> 00:31:59,511
So the game server provisioning algorithm will now run pretty much at constant speed.

729
00:32:00,332 --> 00:32:04,816
So essentially the moral of the story is all these rules, you can't just let them go to

730
00:32:04,836 --> 00:32:05,136
your head.

731
00:32:05,697 --> 00:32:07,597
You've got to wonder, well, OK, when do I

732
00:32:07,637 --> 00:32:08,598
pick a new set of rules?

733
00:32:08,738 --> 00:32:10,419
When do I slightly adjust things?

734
00:32:10,959 --> 00:32:12,900
And you have to continue to look at your system

735
00:32:12,940 --> 00:32:14,640
as it evolves to see if now you've

736
00:32:14,680 --> 00:32:18,022
moved into a different place that now you need to react to.

737
00:32:22,204 --> 00:32:24,165
So the final thing I want to drive into

738
00:32:24,705 --> 00:32:26,786
is the concept of monitoring everything.

739
00:32:28,246 --> 00:32:30,327
So how do we know when we have a problem?

740
00:32:33,485 --> 00:32:34,205
We've got pictures.

741
00:32:34,926 --> 00:32:35,807
How many people like pictures?

742
00:32:36,947 --> 00:32:37,348
Few people.

743
00:32:38,048 --> 00:32:38,329
Alright.

744
00:32:39,009 --> 00:32:41,711
How many people like logs with millions of operations a day?

745
00:32:43,152 --> 00:32:44,754
Few more people. It's about even so far.

746
00:32:45,754 --> 00:32:47,115
Well, I'm going to vote like this.

747
00:32:48,336 --> 00:32:52,159
There are logs right now that I will die before I can scan them with my eyes

748
00:32:52,319 --> 00:32:54,001
enough to find patterns in them. I've tried.

749
00:32:55,740 --> 00:32:58,683
And there's also causality. Causality in logs is hard. You

750
00:32:58,723 --> 00:33:01,145
can, you know, a lot of times limit things down by a thread.

751
00:33:01,585 --> 00:33:03,908
But when you're going across different machines, you've got

752
00:33:03,928 --> 00:33:06,911
to start having, you know, ways to coordinate, you know,

753
00:33:07,091 --> 00:33:09,974
transactions and sequences and it just kind of spirals out of

754
00:33:10,014 --> 00:33:12,857
control real quick. So like in this case, this happened to be

755
00:33:12,877 --> 00:33:13,537
a network issue.

756
00:33:14,398 --> 00:33:16,979
and we can see it ripple through that organic system I talked

757
00:33:16,999 --> 00:33:20,941
about earlier with load averages change and the matchmaking queue

758
00:33:20,961 --> 00:33:24,162
has a little hiccup and then you can see it reflect in the

759
00:33:24,182 --> 00:33:27,884
network traffic. So you go look at the graphs and essentially

760
00:33:27,904 --> 00:33:29,865
you can try to go back in time and figure out what was the

761
00:33:29,925 --> 00:33:33,086
trigger. Because you'll see the ripple in all kinds of different

762
00:33:33,106 --> 00:33:34,927
cases. Maybe it was the other thing. Maybe it was the

763
00:33:34,967 --> 00:33:35,648
matchmaking queue.

764
00:33:36,168 --> 00:33:37,811
Well, if there's an issue with the matchmaking queue,

765
00:33:37,831 --> 00:33:39,675
then people can't get in champ select as fast,

766
00:33:39,715 --> 00:33:41,559
and you'll see network ramifications that way.

767
00:33:41,900 --> 00:33:43,523
So it is kind of tricky to find the timing,

768
00:33:43,543 --> 00:33:45,086
but at least you've got something to start with.

769
00:33:47,720 --> 00:33:50,280
So we try to monitor the heck out of everything.

770
00:33:50,300 --> 00:33:53,661
And one way that we do that is we automate metrics gathering.

771
00:33:53,741 --> 00:33:57,502
So in our case with Java, we've got a AOP,

772
00:33:57,943 --> 00:34:00,103
aspect-oriented interceptor, that basically we

773
00:34:00,143 --> 00:34:02,264
log all the external calls for League of Legends

774
00:34:03,124 --> 00:34:04,985
coming into the platform systems.

775
00:34:05,305 --> 00:34:06,325
So think about that for a second.

776
00:34:06,525 --> 00:34:07,005
Lots of calls.

777
00:34:07,926 --> 00:34:09,868
Then we sample the internal calls.

778
00:34:09,928 --> 00:34:12,030
Now, really we just need a statistical sample.

779
00:34:12,110 --> 00:34:13,872
So we back this out over time.

780
00:34:13,912 --> 00:34:17,136
It used to be, I don't know, 5% and 1%.

781
00:34:17,176 --> 00:34:18,398
Now it's probably a tenth of a percent.

782
00:34:18,418 --> 00:34:21,341
Then we log all that out, and then we

783
00:34:21,421 --> 00:34:22,222
automate the reporting.

784
00:34:23,608 --> 00:34:26,589
And as the last bullet point says, people always ask me,

785
00:34:26,609 --> 00:34:27,349
well, isn't this slow?

786
00:34:28,169 --> 00:34:30,170
Well, you need to be cognizant of things.

787
00:34:30,210 --> 00:34:32,450
You don't want to get a disk I O backup or something

788
00:34:32,470 --> 00:34:32,850
like that.

789
00:34:32,870 --> 00:34:34,611
So you've got to make sure that that's OK.

790
00:34:34,771 --> 00:34:38,072
But general overhead on this CPU and disk wise is about 1%,

791
00:34:39,372 --> 00:34:42,733
versus the data that allows us to triage live systems

792
00:34:42,813 --> 00:34:45,013
and make evaluations of changing features.

793
00:34:45,373 --> 00:34:46,193
That data's invaluable.

794
00:34:47,610 --> 00:34:49,472
Now, all that data is useless if I can't

795
00:34:49,592 --> 00:34:50,453
look at it in a good way.

796
00:34:50,933 --> 00:34:53,615
So this happens to be an example of an automated report

797
00:34:53,635 --> 00:34:56,437
that we run that basically compares two snapshots in time.

798
00:34:56,817 --> 00:34:59,359
And it runs every day on all the different environments

799
00:34:59,379 --> 00:34:59,760
that we run.

800
00:35:00,901 --> 00:35:03,182
Now, I can scan those numbers that are there.

801
00:35:03,763 --> 00:35:05,584
But that's going to take me a second.

802
00:35:05,644 --> 00:35:08,346
So as you can see, we've got the color-coded red bars that

803
00:35:08,366 --> 00:35:09,347
pop out real quick.

804
00:35:09,767 --> 00:35:11,128
And I can say, well, something's changed.

805
00:35:12,009 --> 00:35:13,710
So now, what are we going to do next?

806
00:35:13,830 --> 00:35:14,931
We've got those red bars.

807
00:35:15,652 --> 00:35:16,833
How are we going to dig into that problem?

808
00:35:19,315 --> 00:35:21,096
We can go back to our logs and grep things.

809
00:35:21,116 --> 00:35:22,137
That sounds like a good idea.

810
00:35:24,818 --> 00:35:26,319
However, if you're going to bother

811
00:35:26,419 --> 00:35:29,440
to add one layer of automation, why stop there?

812
00:35:30,080 --> 00:35:33,402
So it was very obvious when we first got this report.

813
00:35:33,442 --> 00:35:36,803
The engineer that worked on it, he'd email me the sample of it.

814
00:35:36,863 --> 00:35:37,524
I'd be like, great.

815
00:35:37,744 --> 00:35:39,224
Now, what are we going to do with the red bar?

816
00:35:39,505 --> 00:35:41,445
And I'd always ask him, the next question

817
00:35:41,465 --> 00:35:42,366
was always the same one.

818
00:35:42,506 --> 00:35:43,927
So I'm like, well, let's just automate that.

819
00:35:44,507 --> 00:35:46,588
So in this case, let's say hypothetically the red bar

820
00:35:46,608 --> 00:35:47,988
was like a max value.

821
00:35:49,045 --> 00:35:52,438
So with a max value, I'm going to want to know distribution

822
00:35:52,819 --> 00:35:55,369
because a max is only telling me half the problem.

823
00:35:57,604 --> 00:35:58,884
So in this case, you can vary.

824
00:35:58,904 --> 00:36:00,785
I don't know if you guys can read that or not.

825
00:36:00,825 --> 00:36:03,586
But down at the bottom, we've got about 113 calls

826
00:36:03,606 --> 00:36:04,707
that took more than two seconds.

827
00:36:05,087 --> 00:36:07,608
That could have been slow ISP, all kinds of things.

828
00:36:08,088 --> 00:36:12,551
But on the flip side, I've got a little bit north of 542,000

829
00:36:12,751 --> 00:36:14,992
that are less than 100 milliseconds.

830
00:36:15,412 --> 00:36:17,513
So if I was to give you a percentage on this,

831
00:36:17,533 --> 00:36:20,434
99.99-something percent are all fine.

832
00:36:20,835 --> 00:36:23,476
So statistically, there's really not a problem here.

833
00:36:24,334 --> 00:36:26,295
So we need to go through and automate

834
00:36:26,535 --> 00:36:28,777
to make those decisions be able to just happen.

835
00:36:29,898 --> 00:36:31,159
Now, some other things that we've done

836
00:36:31,640 --> 00:36:33,281
is game server monitoring.

837
00:36:33,902 --> 00:36:35,543
Originally, there's things that dump out in logs

838
00:36:35,583 --> 00:36:38,185
that say how many people have been in champ select,

839
00:36:38,225 --> 00:36:39,907
and then we transition, and you sit there and wait.

840
00:36:40,708 --> 00:36:43,770
That usually is indicative of a game server having issues.

841
00:36:44,190 --> 00:36:45,852
So we'll turn around, and we've automated

842
00:36:45,892 --> 00:36:47,293
the log gathering of that, and it

843
00:36:47,313 --> 00:36:49,095
goes straight to the person that's going to react to that.

844
00:36:50,531 --> 00:36:52,972
And then over time, we've started

845
00:36:52,992 --> 00:36:55,234
to work on things like building more sophisticated rules

846
00:36:55,514 --> 00:36:57,535
that the servers will basically just take themselves offline.

847
00:36:57,955 --> 00:37:01,537
I mean, again, it's easier to err

848
00:37:01,597 --> 00:37:03,158
on the side of the player experience

849
00:37:03,518 --> 00:37:06,860
than it is to wake somebody up or have the network operations

850
00:37:06,880 --> 00:37:09,981
center take time to go respond.

851
00:37:10,021 --> 00:37:11,702
It's better to pull the thing from service

852
00:37:12,483 --> 00:37:17,045
in a peaceful transition and then react to the problem.

853
00:37:21,942 --> 00:37:26,645
So to recap, we talked a little bit about embracing

854
00:37:26,745 --> 00:37:28,567
technologies that are elastic, like NoSQL.

855
00:37:30,328 --> 00:37:32,690
We're big believers at Riot that the best thing to do

856
00:37:32,770 --> 00:37:34,071
is usually the simplest thing to do.

857
00:37:35,072 --> 00:37:36,493
The engineers that sit at the round table

858
00:37:36,513 --> 00:37:38,634
and say, oh, I need this crazy threading thing,

859
00:37:38,654 --> 00:37:42,037
and I need this big, huge grid computing setup.

860
00:37:42,057 --> 00:37:43,458
A lot of times, we don't even need that,

861
00:37:43,518 --> 00:37:44,218
even though we use it.

862
00:37:44,699 --> 00:37:48,061
We use it for some things, but we try not to pound the fit

863
00:37:48,101 --> 00:37:48,862
and put everything in it.

864
00:37:49,002 --> 00:37:49,883
We always start with simple.

865
00:37:51,671 --> 00:37:53,652
A dynamic system is going to give you a lot more

866
00:37:53,913 --> 00:37:56,654
operational flexibility than having hard-coded config files

867
00:37:56,734 --> 00:37:58,095
and things that are very rigid.

868
00:38:00,377 --> 00:38:03,379
Monitoring everything, or excuse me, scaling best practices

869
00:38:04,659 --> 00:38:07,461
are pretty much, you know, even though they're the 80-20 case,

870
00:38:07,721 --> 00:38:09,543
there are cases that they are meant to be broken.

871
00:38:10,643 --> 00:38:13,025
And then finally, you need to monitor the live system.

872
00:38:13,045 --> 00:38:15,166
Otherwise, you essentially are kind of flying blind

873
00:38:15,206 --> 00:38:17,548
in terms of what is actually happening

874
00:38:17,568 --> 00:38:18,628
and what's happening to your players.

875
00:38:19,763 --> 00:38:23,146
So with that, I'd be happy to take some questions.

876
00:38:23,907 --> 00:38:25,308
I purposely left a little bit of time

877
00:38:25,328 --> 00:38:27,090
because I assume people had a number of questions.

878
00:38:27,130 --> 00:38:28,010
Just walk up to the mics.

879
00:38:28,030 --> 00:38:29,692
If you want to talk to anybody at Riot,

880
00:38:29,712 --> 00:38:31,273
there's a few people floating around the audience.

881
00:38:31,714 --> 00:38:32,835
I'll be available afterward.

882
00:38:32,935 --> 00:38:35,918
And then we've got a booth over in the career pavilion.

883
00:38:35,938 --> 00:38:37,919
If you're interested in any of the types of things

884
00:38:37,939 --> 00:38:39,281
that we're doing, we're always looking

885
00:38:39,401 --> 00:38:41,683
for more awesome engineers to join Riot Games.

886
00:38:42,023 --> 00:38:42,864
So thank you.

887
00:38:57,233 --> 00:39:00,816
question on your server side stuff. How do you test

888
00:39:00,876 --> 00:39:04,758
everything? How do you test things like failover or if

889
00:39:05,018 --> 00:39:07,960
somebody accidentally a server, you can't just crash a data

890
00:39:07,980 --> 00:39:11,303
center and see what happens. Well, actually.

891
00:39:13,315 --> 00:39:16,017
One of the things that we do that I've heard is a little

892
00:39:16,057 --> 00:39:19,801
different than some people is we have a couple full scale

893
00:39:19,861 --> 00:39:23,744
environments that we try to test as detailed as we can.

894
00:39:24,165 --> 00:39:25,266
There are certain features.

895
00:39:25,586 --> 00:39:28,148
It takes longer to statistically model the data,

896
00:39:28,529 --> 00:39:31,231
dummy it up, and run the, I like to call it, it's like the

897
00:39:33,173 --> 00:39:34,714
high school chemistry lab experiments.

898
00:39:34,914 --> 00:39:38,498
It takes longer to do that sometimes than to actually

899
00:39:38,518 --> 00:39:39,358
write the code sometimes.

900
00:39:39,699 --> 00:39:43,400
We do a lot of that. That's not, even for us, that's not always

901
00:39:43,440 --> 00:39:47,081
practical for everything. So we try to spend a lot of time of

902
00:39:47,501 --> 00:39:52,783
what can I do to test something that will then extrapolate. So

903
00:39:52,803 --> 00:39:56,264
that's another thing that we do. As far as specifically your

904
00:39:56,304 --> 00:40:00,606
case of failure, 95% of things that I've seen that has a white

905
00:40:00,646 --> 00:40:04,467
paper or a sales guy that says it fails over, doesn't.

906
00:40:05,630 --> 00:40:07,831
I can't tell you how many times I've seen something that, oh

907
00:40:07,871 --> 00:40:10,111
yeah, it's master slave and when you pull the master it's just

908
00:40:10,151 --> 00:40:13,312
going to pop. It never works like that. I can give you two

909
00:40:13,352 --> 00:40:15,912
technologies we've got in our stack that work as advertised

910
00:40:15,952 --> 00:40:19,073
and the rest we've had to kind of work on. So, yeah, you have

911
00:40:19,113 --> 00:40:21,193
to test failover. You don't just put it in and configure it and

912
00:40:21,213 --> 00:40:24,754
go. I know some companies, I'm trying to think, I think it's

913
00:40:24,914 --> 00:40:28,515
Netflix has got a tool called Chaos Monkey that they actually

914
00:40:28,955 --> 00:40:31,215
let it run during set hours of the day and it just runs around

915
00:40:31,275 --> 00:40:31,995
and destroys stuff.

916
00:40:32,515 --> 00:40:35,018
because their theory is if you can't survive when something is

917
00:40:35,058 --> 00:40:38,361
destroyed, then you're kind of just putting your head in the

918
00:40:38,381 --> 00:40:41,324
sand. I know I joke with some of the guys at Riot, I'll say

919
00:40:41,444 --> 00:40:43,726
things have been running good and they're like shh. I'm like

920
00:40:43,786 --> 00:40:46,509
no, I want a system good enough that I can taunt it daily and

921
00:40:46,529 --> 00:40:49,272
it still won't fall over. So those are some of the things we

922
00:40:49,292 --> 00:40:51,734
do. But yeah, the big thing is to test the failover cases

923
00:40:51,754 --> 00:40:53,135
because they don't ever work out of the box.

924
00:40:55,039 --> 00:40:58,822
As far as monitoring everything, a couple of charts up there

925
00:40:58,862 --> 00:41:01,465
look like you use a tool called Cacti.

926
00:41:01,485 --> 00:41:02,005
Is that true?

927
00:41:02,025 --> 00:41:03,006
And do you also use any others?

928
00:41:03,186 --> 00:41:04,848
We've used Cacti for some things.

929
00:41:06,089 --> 00:41:08,010
We use Nagios for different alerting.

930
00:41:08,391 --> 00:41:09,852
One of the more recent things is we

931
00:41:09,912 --> 00:41:11,773
ended up writing a homegrown charting

932
00:41:11,813 --> 00:41:13,775
tool for a lot of the non.

933
00:41:14,215 --> 00:41:17,397
hardware type metrics that are actually, I call them synthetic

934
00:41:17,437 --> 00:41:20,438
metrics of our application. And essentially what we've done is

935
00:41:20,478 --> 00:41:23,659
we're big on the definition of done at Riot. And it's not just

936
00:41:23,719 --> 00:41:27,141
code. It's unit test, it's QA. One of the definitions of done

937
00:41:27,181 --> 00:41:30,222
these days at Riot is every piece of code, every feature

938
00:41:30,242 --> 00:41:30,802
that goes out.

939
00:41:31,462 --> 00:41:34,743
you have to be able to monitor it at an application level. So

940
00:41:34,803 --> 00:41:36,803
developers, you know, we've got libraries that will drop a

941
00:41:36,863 --> 00:41:39,544
couple lines of code in for their key metrics. And then

942
00:41:39,824 --> 00:41:42,024
when the features go out, we make sure to explain to, you

943
00:41:42,084 --> 00:41:45,425
know, the network operations staff and to, you know, live

944
00:41:45,465 --> 00:41:47,446
support and player support, different people that will be

945
00:41:47,466 --> 00:41:50,006
consuming that data, what does it mean? So it's not just the

946
00:41:50,046 --> 00:41:53,427
engineers. So it's part of the development cycle. You have to

947
00:41:53,467 --> 00:41:55,147
have data. Because what we kept running into was

948
00:41:56,047 --> 00:41:58,129
We'd write things and then they'd go to production and

949
00:41:58,149 --> 00:42:00,911
then we'd be like, oh, it'd be nice if we added an alert for

950
00:42:00,931 --> 00:42:02,692
that, or it'd be nice if we had data for that.

951
00:42:02,752 --> 00:42:05,934
And you were just too far behind, you were just too much

952
00:42:05,994 --> 00:42:07,635
behind the curve when you did it that way.

953
00:42:07,715 --> 00:42:10,537
So we've got some homegrown tools for some of those things.

954
00:42:10,577 --> 00:42:14,000
Now, there's a ton of things these days that you can just

955
00:42:14,020 --> 00:42:14,700
pull off the shelf.

956
00:42:14,740 --> 00:42:16,381
There's three or four different things on GitHub.

957
00:42:17,502 --> 00:42:17,762
I know.

958
00:42:19,770 --> 00:42:24,452
StumbleUpon had a time series based tool that's backed by Hadoop.

959
00:42:24,512 --> 00:42:28,995
And you can basically store like finite data, like CPUs and all kinds of different things.

960
00:42:29,015 --> 00:42:31,376
And basically you don't have to get rid of any of it.

961
00:42:31,476 --> 00:42:34,678
Which is really nice because you need to go back to an event and correlate it from two

962
00:42:34,698 --> 00:42:35,138
weeks ago.

963
00:42:35,418 --> 00:42:36,559
You don't just have the aggregate.

964
00:42:36,579 --> 00:42:39,120
You can get down to the detail level data.

965
00:42:39,140 --> 00:42:42,121
So I'd look at some of that stuff if it's something you're interested in.

966
00:42:47,552 --> 00:42:52,034
Hi, I was just kind of wondering because you did a great job of explaining scaling on technology,

967
00:42:52,054 --> 00:42:55,956
but I'm also kind of interested in how the human resources end of this works

968
00:42:55,976 --> 00:42:59,938
because if you're scaling technology, I assume you need a certain amount of human resources

969
00:42:59,978 --> 00:43:03,760
to be able to cope with, you know, building out of your systems because, I mean,

970
00:43:03,780 --> 00:43:07,522
you've already described a lot of QA and testing and programming.

971
00:43:07,562 --> 00:43:11,984
So can you describe a little bit how big is your team and what do you think you need

972
00:43:12,024 --> 00:43:15,426
to actually implement some of these techniques and maybe some other advice in that area?

973
00:43:16,184 --> 00:43:23,291
Um, as far as exact numbers these days, I'll apologize. I'm probably not the guy. But I can give you a couple ballparks.

974
00:43:24,972 --> 00:43:27,695
First of all, we got a 24 hour a day network operations staff.

975
00:43:28,396 --> 00:43:31,999
There's usually two or three guys basically on duty all the time.

976
00:43:32,100 --> 00:43:33,521
So that's just the live side of it.

977
00:43:33,841 --> 00:43:36,224
Now I think back to what you were maybe hitting on.

978
00:43:36,744 --> 00:43:38,326
One of the things that we invested in, uh...

979
00:43:39,447 --> 00:43:41,248
several years ago because we knew it was going to come to

980
00:43:41,328 --> 00:43:46,090
pass is DevOps. So we have an in-house DevOps tool that

981
00:43:46,250 --> 00:43:48,651
basically just like the definition of done is you have

982
00:43:48,671 --> 00:43:51,312
to be able to monitor things. The other definition of done is

983
00:43:51,332 --> 00:43:54,153
you have to have the recipes to be able to push the code.

984
00:43:54,694 --> 00:44:00,677
So that scales all the way up from local QA environments to larger public beta environments

985
00:44:01,077 --> 00:44:04,138
to different platforms of League of Legends all over the world.

986
00:44:04,278 --> 00:44:11,802
So that's actually kept the people side of this much more fixed than what it would have been otherwise.

987
00:44:12,943 --> 00:44:16,304
As we've grown, because we have different territories that run as different environments,

988
00:44:16,565 --> 00:44:19,106
instead of having to have a whole set of people for each one.

989
00:44:20,017 --> 00:44:22,818
The tool will do a lot of it, and we keep trying to automate

990
00:44:22,858 --> 00:44:23,878
that as much as possible.

991
00:44:23,958 --> 00:44:27,099
So really you need people more on the things with racking and

992
00:44:27,140 --> 00:44:28,620
stacking hardware and that side of it.

993
00:44:29,921 --> 00:44:32,202
But can you give me an overall staff count?

994
00:44:32,262 --> 00:44:35,543
I'll tell you what, if you want to hang around after the

995
00:44:35,583 --> 00:44:37,204
session, there's a couple people from Riot in the

996
00:44:37,224 --> 00:44:39,104
audience I'll be happy to hook you up with, and they can give

997
00:44:39,124 --> 00:44:41,866
you a more specific number on some of that.

998
00:44:42,106 --> 00:44:43,766
OK, I was just looking for ballpark.

999
00:44:43,826 --> 00:44:44,066
Thank you.

1000
00:44:47,382 --> 00:44:48,002
Hi.

1001
00:44:48,583 --> 00:44:51,325
I was wondering about your use of MapReduce.

1002
00:44:52,105 --> 00:44:53,867
Because I guess some things, for example,

1003
00:44:53,927 --> 00:44:56,949
getting one player's stats, you don't really need MapReduce.

1004
00:44:56,969 --> 00:44:58,790
I guess it's just like one get.

1005
00:44:58,890 --> 00:45:00,972
So I was wondering what kind of situations you use MapReduce.

1006
00:45:00,992 --> 00:45:03,494
A lot of the stuff we're driving on the MapReduce these days

1007
00:45:03,854 --> 00:45:06,616
are we have a big data team at Riot.

1008
00:45:07,448 --> 00:45:10,109
that is diving into a number of different things with

1009
00:45:10,909 --> 00:45:12,989
statistics and BI and things of that nature.

1010
00:45:13,049 --> 00:45:15,510
So we're diving into a lot of that stuff

1011
00:45:16,190 --> 00:45:18,311
with Hadoop and MapReduce these days.

1012
00:45:18,491 --> 00:45:20,871
Actually, it's a pretty hot thing that we're hiring for,

1013
00:45:20,891 --> 00:45:21,772
if you've got any interest in it.

1014
00:45:21,892 --> 00:45:23,892
But that's where a lot of it's coming from.

1015
00:45:24,512 --> 00:45:28,773
On the, I call it the more pure platform side of the world.

1016
00:45:29,976 --> 00:45:31,797
Um, we haven't steered to that as much.

1017
00:45:32,678 --> 00:45:33,739
I mean, three, four years ago,

1018
00:45:33,759 --> 00:45:35,460
a lot of the MapReduce stuff

1019
00:45:35,520 --> 00:45:36,981
was more batch job type things,

1020
00:45:37,021 --> 00:45:39,944
which didn't really fit with the gameplay type experience.

1021
00:45:40,424 --> 00:45:43,066
So although there's different things now with, you know,

1022
00:45:43,146 --> 00:45:44,627
that are more performant with stuff like that,

1023
00:45:44,727 --> 00:45:46,669
but back when we were looking at some of the original stuff,

1024
00:45:46,689 --> 00:45:48,430
we tried to probably keep the MapReduce

1025
00:45:48,470 --> 00:45:49,791
a little more on the analytics side

1026
00:45:49,831 --> 00:45:52,273
than the actual, you know, champions-like side of the house.

1027
00:45:52,293 --> 00:45:53,194
So... man 2 in audience, cool. Thanks.

1028
00:45:53,214 --> 00:45:53,294
Yeah.

1029
00:45:53,314 --> 00:45:57,577
man 3 in audience Can you talk about how and how often

1030
00:45:57,597 --> 00:45:58,718
you guys do your load testing?

1031
00:45:59,737 --> 00:46:02,420
Load testing is a continual thing, as I like to say.

1032
00:46:02,500 --> 00:46:04,762
But primarily, there's load testing

1033
00:46:04,802 --> 00:46:06,223
that fits in the cadence of the release

1034
00:46:06,844 --> 00:46:07,745
that goes out every two weeks.

1035
00:46:07,825 --> 00:46:08,566
So that's a must.

1036
00:46:09,467 --> 00:46:13,430
Essentially, it's similar to the tribunal for the game.

1037
00:46:13,450 --> 00:46:14,711
There's a load testing tribunal.

1038
00:46:15,212 --> 00:46:16,573
And they have to sign off on things.

1039
00:46:16,593 --> 00:46:18,815
And if they don't, then various people

1040
00:46:18,835 --> 00:46:19,316
start to kind of.

1041
00:46:19,696 --> 00:46:20,296
What's going on?

1042
00:46:20,576 --> 00:46:21,157
It has a release.

1043
00:46:21,177 --> 00:46:21,737
It's ready to go.

1044
00:46:22,197 --> 00:46:26,179
Now, that being said, we also use load testing for a number of features.

1045
00:46:26,219 --> 00:46:30,720
Because sometimes, as we like to call it, we have this concept that we call it the treadmill.

1046
00:46:30,800 --> 00:46:35,582
So when code goes in, and depending on where it gets, then you have a set amount of time

1047
00:46:35,622 --> 00:46:36,383
for it's going to go out.

1048
00:46:36,803 --> 00:46:40,184
So we'll actually branch off and do specific load tests for different things.

1049
00:46:41,105 --> 00:46:45,150
to verify different code paths and strategies

1050
00:46:45,451 --> 00:46:46,732
before the code goes into main.

1051
00:46:47,293 --> 00:46:49,676
Because sometimes, just based on the risk factors of it

1052
00:46:49,716 --> 00:46:51,458
and things like that, you have to have the data

1053
00:46:51,799 --> 00:46:52,600
before you can just say,

1054
00:46:52,700 --> 00:46:54,382
all right, this is ready to go out the door now.

1055
00:46:59,122 --> 00:47:00,143
Hey, yeah, thanks for the talk.

1056
00:47:00,163 --> 00:47:02,986
I was curious on your perspective on the value

1057
00:47:03,026 --> 00:47:05,529
of owning your own hardware and the data centers

1058
00:47:05,570 --> 00:47:06,951
and that sort of thing, especially as it relates

1059
00:47:06,991 --> 00:47:07,912
to scalability.

1060
00:47:08,133 --> 00:47:10,516
Not so much when you're like where you are now at whatever,

1061
00:47:10,876 --> 00:47:12,939
30 million monthly active or 11 million monthly actives,

1062
00:47:13,039 --> 00:47:15,261
but as you're building your enterprise early on

1063
00:47:15,321 --> 00:47:17,784
and the cost benefit is less obvious than it is now.

1064
00:47:18,497 --> 00:47:22,599
Yeah, it's a mix of cost and performance and predictability,

1065
00:47:22,639 --> 00:47:23,299
I guess I'd say.

1066
00:47:24,900 --> 00:47:27,281
I've seen lots of things that I've spent an hour digging on

1067
00:47:27,341 --> 00:47:29,322
something, and then it's like, oh, Amazon's just

1068
00:47:29,382 --> 00:47:30,123
having a bad day.

1069
00:47:31,223 --> 00:47:33,524
So it's a mix of things, especially when you're

1070
00:47:33,544 --> 00:47:34,125
starting out.

1071
00:47:34,525 --> 00:47:36,045
There's a variety of cloud providers.

1072
00:47:36,085 --> 00:47:38,527
I know I walked through the pavilion earlier, and there's

1073
00:47:38,607 --> 00:47:41,328
three or four of them over there that are good places to

1074
00:47:41,368 --> 00:47:41,908
probably start.

1075
00:47:42,669 --> 00:47:44,550
The bigger thing I'd probably look at is, you know,

1076
00:47:44,590 --> 00:47:46,771
we're out with consistent performance.

1077
00:47:46,831 --> 00:47:48,212
I mean, we've had the, uh,

1078
00:47:48,232 --> 00:47:50,133
I'm trying to think, was that last fall

1079
00:47:50,153 --> 00:47:52,695
when Amazon had, like, the big massive outage?

1080
00:47:53,275 --> 00:47:55,456
And, you know, people were running from EBS volumes,

1081
00:47:55,516 --> 00:47:57,417
you know, running for the hills, all kinds of stuff.

1082
00:47:57,878 --> 00:48:00,739
So, it adds a layer of, um...

1083
00:48:01,882 --> 00:48:04,484
disruption in just your performance too.

1084
00:48:04,804 --> 00:48:07,005
And if the system can handle that, that's great, but it's

1085
00:48:07,065 --> 00:48:10,788
not going to be quite as consistent as real hardware.

1086
00:48:10,828 --> 00:48:14,471
So it's a balance you've got to maintain on all those things.

1087
00:48:14,831 --> 00:48:16,432
Or the other thing you can do is you can have

1088
00:48:16,472 --> 00:48:17,353
hybridized approaches.

1089
00:48:17,433 --> 00:48:20,435
I've talked to a lot of different people that you use

1090
00:48:20,455 --> 00:48:22,676
a little bit of this, use that for burst capacity, and so on

1091
00:48:22,716 --> 00:48:23,157
and so forth.

1092
00:48:25,930 --> 00:48:26,570
Hey, Scott, thanks.

1093
00:48:27,951 --> 00:48:31,054
Managing all those servers for something this big,

1094
00:48:31,394 --> 00:48:32,435
it's pretty tough, I'm sure.

1095
00:48:32,455 --> 00:48:35,577
Do you guys use any configuration management,

1096
00:48:35,797 --> 00:48:36,918
like Puppet or Chef?

1097
00:48:36,998 --> 00:48:41,842
And how would you get those on the new instances

1098
00:48:41,902 --> 00:48:43,944
as they're booting up, if there's failover

1099
00:48:44,084 --> 00:48:45,025
or you need a scale?

1100
00:48:45,625 --> 00:48:48,587
And how would you promote those from dev to QA to prod

1101
00:48:48,687 --> 00:48:49,768
once they're tested?

1102
00:48:50,449 --> 00:48:50,809
Gotcha.

1103
00:48:51,130 --> 00:48:54,432
So as I mentioned a little bit earlier on the DevOps side

1104
00:48:54,472 --> 00:48:55,853
of things, we do use a lot of Chef.

1105
00:48:56,954 --> 00:49:00,337
That basically is a key part of our homegrown DevOps tool.

1106
00:49:00,737 --> 00:49:03,059
So that handles a decent amount of that.

1107
00:49:03,479 --> 00:49:06,021
As far as the hardware goes, while it is smoke tested

1108
00:49:06,062 --> 00:49:09,304
and things like that, hardware doesn't go from dev to QA.

1109
00:49:09,744 --> 00:49:10,865
The software does more so.

1110
00:49:10,905 --> 00:49:12,587
So we don't have to worry as much about that.

1111
00:49:13,527 --> 00:49:15,309
And then the big thing is just having these things being

1112
00:49:15,349 --> 00:49:18,131
elastic, because you can't put something in if the system's

1113
00:49:18,171 --> 00:49:19,092
not made to handle it.

1114
00:49:19,572 --> 00:49:20,853
So I mean that's been the big thing.

1115
00:49:20,953 --> 00:49:21,413
Or even if...

1116
00:49:22,214 --> 00:49:24,935
You essentially, you've got to be able to 100% trust it.

1117
00:49:27,216 --> 00:49:28,657
Back in, you know, years past,

1118
00:49:28,697 --> 00:49:30,378
we've had things that are supposed to fail over.

1119
00:49:30,758 --> 00:49:31,739
They work most of the time.

1120
00:49:32,399 --> 00:49:32,539
Well...

1121
00:49:33,518 --> 00:49:35,439
Or, you know, you can hot, you know, deploy things

1122
00:49:35,479 --> 00:49:36,399
and they'll work most of the time,

1123
00:49:36,419 --> 00:49:37,299
then there might be an issue.

1124
00:49:37,600 --> 00:49:38,980
What happens is you end up erring,

1125
00:49:39,220 --> 00:49:40,201
erring on the side of,

1126
00:49:40,241 --> 00:49:41,801
well, we're not going to do a hot deploy

1127
00:49:41,841 --> 00:49:42,922
because we don't know what'll happen.

1128
00:49:43,022 --> 00:49:45,263
Even if it's a 1% case, you just can't.

1129
00:49:45,703 --> 00:49:48,004
So, I mean, essentially you nullified the entire thing.

1130
00:49:48,024 --> 00:49:49,664
It's just like we have a bad, you know,

1131
00:49:50,445 --> 00:49:51,726
a player that has a network issue,

1132
00:49:51,886 --> 00:49:53,047
one player can cause an issue

1133
00:49:53,067 --> 00:49:55,148
with, you know, the entire champ select process.

1134
00:49:55,529 --> 00:49:58,190
So you've got to get those types of hot-swappable things

1135
00:49:58,351 --> 00:50:00,792
rock-solid so then you can start to use them as a foundation.

1136
00:50:00,812 --> 00:50:03,154
And if there's any doubt at all,

1137
00:50:03,214 --> 00:50:05,316
then essentially most of the time

1138
00:50:05,676 --> 00:50:07,197
you end up just not using them to be safe.

1139
00:50:07,697 --> 00:50:09,319
So...yeah.

1140
00:50:09,819 --> 00:50:12,261
man in audience 5 Hi. I'm curious if you evaluated

1141
00:50:12,381 --> 00:50:14,082
any other languages for your server back end,

1142
00:50:14,402 --> 00:50:16,484
especially C-sharp or Erlang,

1143
00:50:16,744 --> 00:50:17,705
and what your opinions on those are.

1144
00:50:19,080 --> 00:50:20,961
Yeah, I mean, we're constantly looking at things.

1145
00:50:21,001 --> 00:50:23,162
I mean, again, the industry continues to evolve.

1146
00:50:23,242 --> 00:50:26,184
So we do have some things in-house with Erlang

1147
00:50:26,984 --> 00:50:28,325
and a little bit of stuff with Scala

1148
00:50:28,345 --> 00:50:30,427
that we've been doing recently.

1149
00:50:30,467 --> 00:50:31,587
So we've got some things there.

1150
00:50:32,928 --> 00:50:34,569
At the time, at least, when we started things

1151
00:50:34,629 --> 00:50:37,291
with the platform, we wanted to kind of accelerate

1152
00:50:37,351 --> 00:50:39,992
using a mix of different open source tools and other things.

1153
00:50:40,232 --> 00:50:41,953
So that's kind of where we arrived at with Java,

1154
00:50:41,973 --> 00:50:43,895
plus some of the guys on the team

1155
00:50:43,935 --> 00:50:45,656
had experience in that to start with.

1156
00:50:46,376 --> 00:50:48,518
You know, as we build new pieces and modules and things,

1157
00:50:48,538 --> 00:50:49,699
we're always kind of on the lookout

1158
00:50:49,779 --> 00:50:51,000
for what's the best thing.

1159
00:50:52,061 --> 00:50:53,802
And, you know, there is no one way to do this.

1160
00:50:53,862 --> 00:50:56,284
I mean, like I said, these days,

1161
00:50:56,605 --> 00:50:59,607
it's not about this language being fast or something else.

1162
00:50:59,647 --> 00:51:01,108
There's different characteristics, you know,

1163
00:51:01,168 --> 00:51:03,090
with, you know, actor-based models and things like that

1164
00:51:03,150 --> 00:51:04,891
that have pros and cons to them.

1165
00:51:04,931 --> 00:51:06,773
And in some situations, you know,

1166
00:51:07,033 --> 00:51:08,434
the pros are, you know, very powerful.

1167
00:51:08,514 --> 00:51:10,997
man 2 in audience What is your personal opinion of Erlang?

1168
00:51:11,477 --> 00:51:12,458
man 1 Of? man 2 in audience Erlang.

1169
00:51:13,026 --> 00:51:15,412
Erlang, I've seen a lot of awesome stuff done in Erlang.

1170
00:51:15,452 --> 00:51:18,539
You know, it's one of the things that if I had to do over,

1171
00:51:18,579 --> 00:51:20,885
I knew a little more about it when we started, a few other things.

1172
00:51:21,726 --> 00:51:23,167
It would have been a very powerful thing.

1173
00:51:24,408 --> 00:51:25,729
I know we've got a couple engineers that

1174
00:51:25,750 --> 00:51:27,051
are diving into some of the things with it.

1175
00:51:27,191 --> 00:51:30,794
I know, I think it was Facebook, there's a PDF floating around.

1176
00:51:30,814 --> 00:51:33,116
They built their chat system on top of Erlang as an example.

1177
00:51:33,216 --> 00:51:35,938
So there's a little bit of a learning curve,

1178
00:51:35,958 --> 00:51:37,319
especially coming from some other places.

1179
00:51:37,379 --> 00:51:39,942
But the power of being able to swap things in and out,

1180
00:51:40,022 --> 00:51:42,304
and it'll do in-memory migrations on different things,

1181
00:51:42,864 --> 00:51:45,026
is really cool for these types of systems.

1182
00:51:45,246 --> 00:51:45,386
So.

1183
00:51:45,887 --> 00:51:46,027
Good.

1184
00:51:46,047 --> 00:51:46,247
Thanks.

1185
00:51:46,267 --> 00:51:48,389
Yeah.

1186
00:51:49,536 --> 00:51:51,397
So you had an active MQ on one of your slides.

1187
00:51:51,437 --> 00:51:52,618
I wonder if you could talk about messaging

1188
00:51:52,638 --> 00:51:54,860
and how that fits in with scalability and monitoring?

1189
00:51:56,261 --> 00:51:57,842
I didn't dive into it, but messaging

1190
00:51:57,862 --> 00:52:00,344
is one of those key elements that always comes up

1191
00:52:00,364 --> 00:52:03,807
when you're reading about building scalable systems.

1192
00:52:03,827 --> 00:52:05,068
You've got concepts of messaging,

1193
00:52:05,688 --> 00:52:07,450
essentially asynchronous behavior.

1194
00:52:07,470 --> 00:52:09,391
Because asynchronous behavior is also

1195
00:52:09,431 --> 00:52:10,672
going to allow your system to stretch.

1196
00:52:11,653 --> 00:52:12,934
you know, it can only stretch so far.

1197
00:52:13,474 --> 00:52:15,416
But if you've got messages going back and forth,

1198
00:52:15,536 --> 00:52:17,717
then you've got some variance on,

1199
00:52:18,338 --> 00:52:20,880
as far as, you know, how fast things have to move.

1200
00:52:20,900 --> 00:52:23,342
If they get degradated by 10%, it's okay.

1201
00:52:23,902 --> 00:52:26,104
Depending on how you have buffering and persistence set up,

1202
00:52:26,164 --> 00:52:27,705
that can do some things for failover.

1203
00:52:28,245 --> 00:52:31,027
So messaging, you know, is a key piece of the equation.

1204
00:52:31,428 --> 00:52:33,709
There's different ways to do that, you know, too.

1205
00:52:33,769 --> 00:52:35,851
I mean, some people go down to kind of a bare-bones layer

1206
00:52:35,891 --> 00:52:37,932
these days with the ZeroMQ.

1207
00:52:38,012 --> 00:52:39,493
There's the Java technologies.

1208
00:52:40,765 --> 00:52:44,248
More recently, I know, I think it's Kessel

1209
00:52:44,448 --> 00:52:47,991
that Twitter's got, and I think it's Kafka's

1210
00:52:48,011 --> 00:52:48,892
the one that LinkedIn has.

1211
00:52:48,912 --> 00:52:50,132
They have different characteristics.

1212
00:52:50,193 --> 00:52:53,195
So, yeah, that's a key part of, you know,

1213
00:52:53,235 --> 00:52:55,256
the space as well, depending on, you know, your use case.

1214
00:52:55,276 --> 00:52:57,538
Anybody else?

1215
00:52:58,279 --> 00:52:58,459
Okay.

1216
00:52:59,660 --> 00:53:00,720
Well, thank you guys for coming.

1217
00:53:01,241 --> 00:53:02,962
Again, please fill out the evaluations.

1218
00:53:02,982 --> 00:53:04,623
They're going to email out afterward,

1219
00:53:04,703 --> 00:53:06,805
and I'd be happy to hang out up here and talk for a second

1220
00:53:06,825 --> 00:53:07,646
if anybody's got any questions.

