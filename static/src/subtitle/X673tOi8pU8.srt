1
00:00:05,823 --> 00:00:06,523
I'm Robert Masella.

2
00:00:06,923 --> 00:00:08,084
I'm a software engineer from Rare.

3
00:00:10,365 --> 00:00:12,366
Because we had such bad experiences with testing

4
00:00:12,706 --> 00:00:13,667
on our previous projects,

5
00:00:14,407 --> 00:00:16,388
when we started working on our latest game, Sea of Thieves,

6
00:00:17,589 --> 00:00:19,210
instead of relying on manual testing,

7
00:00:19,330 --> 00:00:20,911
we decided to completely change our approach

8
00:00:21,571 --> 00:00:24,032
and use automated testing on every part of the code base,

9
00:00:25,193 --> 00:00:26,413
including on gameplay features,

10
00:00:26,453 --> 00:00:28,054
which are notoriously tricky to test.

11
00:00:29,115 --> 00:00:30,535
So in this talk, I'm gonna walk through

12
00:00:31,476 --> 00:00:32,176
the approach we took.

13
00:00:33,038 --> 00:00:35,740
our learnings and how we benefited from it.

14
00:00:38,021 --> 00:00:39,302
First a few quick details about me.

15
00:00:40,983 --> 00:00:43,304
I've been a gameplay engineer at Rare for about 14 years.

16
00:00:44,805 --> 00:00:48,507
For anyone who doesn't know Rare, we're a Microsoft first party studio.

17
00:00:48,708 --> 00:00:52,370
We're based in central England and we've got a very long history of game development.

18
00:00:53,991 --> 00:00:57,213
Just for context, we have about 200 people in the studio at the moment.

19
00:00:59,390 --> 00:01:02,633
So games I've worked on are Banjo-Kazooie, Nuts and Bolts,

20
00:01:03,514 --> 00:01:04,895
all three of the Kinect sports games,

21
00:01:05,476 --> 00:01:07,077
and in the last four years or so,

22
00:01:07,097 --> 00:01:08,599
I've been working on Sea of Thieves.

23
00:01:10,220 --> 00:01:13,203
So rare gameplay engineers don't tend to specialize too much.

24
00:01:14,304 --> 00:01:16,425
So on Sea of Thieves, I ended up doing a bit of everything,

25
00:01:16,846 --> 00:01:20,349
including AI, physics, character movement, animation,

26
00:01:20,549 --> 00:01:21,750
and just whatever needed doing.

27
00:01:23,387 --> 00:01:25,389
So for those who aren't aware of what Sea of Thieves is,

28
00:01:26,269 --> 00:01:29,172
it's a multiplayer, open-world pirate adventure game

29
00:01:29,773 --> 00:01:31,635
where players can join in crews

30
00:01:32,015 --> 00:01:33,797
and cooperatively sail around the world,

31
00:01:34,718 --> 00:01:36,339
follow maps to find treasure,

32
00:01:36,359 --> 00:01:39,402
steal treasure from other players, and fight skeletons.

33
00:01:40,603 --> 00:01:41,904
That's what you can do, but if you want,

34
00:01:41,965 --> 00:01:45,808
you can just play instruments and get drunk on grog.

35
00:01:45,848 --> 00:01:46,469
It's up to the players.

36
00:01:48,493 --> 00:01:50,475
So since we released the game about a year ago,

37
00:01:50,495 --> 00:01:52,876
in fact, exactly a year ago now,

38
00:01:54,157 --> 00:01:56,358
we've added multiple new updates.

39
00:01:56,678 --> 00:01:59,279
So we've added skeleton AI ships for the players to fight,

40
00:01:59,780 --> 00:02:02,181
a new set of volcanic islands to explore,

41
00:02:03,241 --> 00:02:04,942
and a Megalodon shark that can appear

42
00:02:04,982 --> 00:02:06,163
and attack the players at any time.

43
00:02:07,804 --> 00:02:09,705
So in this presentation, I'll be talking about

44
00:02:09,725 --> 00:02:12,226
why we thought automated tests

45
00:02:12,246 --> 00:02:13,507
would be a good fit for Sea of Thieves.

46
00:02:15,379 --> 00:02:18,541
how our testing framework worked and how we created tests,

47
00:02:20,562 --> 00:02:24,224
how we optimized our testing during production,

48
00:02:25,785 --> 00:02:28,127
and then finally I'll talk about the benefits we got.

49
00:02:29,848 --> 00:02:32,130
So first of all, why did we decide to use automated testing?

50
00:02:33,631 --> 00:02:35,372
Well, Sea of Thieves was gonna be a very different game

51
00:02:35,512 --> 00:02:38,234
for Rare, and some of those differences meant

52
00:02:38,274 --> 00:02:40,295
that in terms of testing, there were gonna be

53
00:02:40,335 --> 00:02:42,056
some different challenges than we'd had before.

54
00:02:43,324 --> 00:02:45,446
So the first one was that this was an open world game,

55
00:02:45,506 --> 00:02:46,387
our first open world game.

56
00:02:47,348 --> 00:02:49,811
And it was going to be very open in terms of gameplay.

57
00:02:50,051 --> 00:02:51,432
There were very few restrictions, really,

58
00:02:51,473 --> 00:02:53,395
on what the players could do and when they could do it.

59
00:02:54,516 --> 00:02:57,099
So the challenge here was all the complexity that I did.

60
00:02:57,459 --> 00:02:59,301
The way features interacted meant

61
00:02:59,321 --> 00:03:02,224
that we'd have to keep checking all those interactions, all

62
00:03:02,244 --> 00:03:04,106
those features, making sure they still worked.

63
00:03:06,406 --> 00:03:07,707
So the other issue is this was going

64
00:03:07,727 --> 00:03:09,327
to be a constantly evolving game.

65
00:03:09,387 --> 00:03:11,208
This is going to be our first game as a service

66
00:03:11,668 --> 00:03:13,489
that we're going to be constantly evolving,

67
00:03:13,889 --> 00:03:14,969
responding to player feedback.

68
00:03:16,890 --> 00:03:18,491
And the issue there is that as you're constantly

69
00:03:18,531 --> 00:03:21,292
changing the code base, you've got a lot of risk of causing

70
00:03:21,312 --> 00:03:24,213
bug regressions, breaking features

71
00:03:24,253 --> 00:03:25,453
that you'd already implemented.

72
00:03:26,994 --> 00:03:28,655
And then the third challenge was that we

73
00:03:28,675 --> 00:03:31,156
wanted to, if possible, release the game within a week

74
00:03:31,376 --> 00:03:33,256
so we could respond quickly to player feedback

75
00:03:33,417 --> 00:03:34,897
or add hop fixes, that kind of thing.

76
00:03:36,409 --> 00:03:38,411
So the issue with that was that on previous projects,

77
00:03:38,431 --> 00:03:41,094
it had taken at least two weeks to verify build.

78
00:03:41,935 --> 00:03:44,117
With the extra complexity that Sea of Thieves had,

79
00:03:44,877 --> 00:03:47,140
a week just wasn't going to be enough time

80
00:03:47,240 --> 00:03:48,841
to have confidence that the build

81
00:03:48,881 --> 00:03:49,902
we were putting out to players

82
00:03:49,922 --> 00:03:51,404
was actually not going to be full of bugs.

83
00:03:53,318 --> 00:03:56,901
So if we look at the testing process that we used previously

84
00:03:57,342 --> 00:04:01,025
on our previous games, if you look at this dev timeline

85
00:04:01,345 --> 00:04:04,028
from the point where a developer makes a local change in their

86
00:04:04,068 --> 00:04:06,890
PC to the point where players get a game update,

87
00:04:07,531 --> 00:04:09,353
our old process essentially only had one point

88
00:04:09,373 --> 00:04:10,413
where we did testing, really.

89
00:04:10,934 --> 00:04:12,656
We just got lots of manual testers.

90
00:04:13,556 --> 00:04:15,918
They got a build that was created from the build system

91
00:04:15,979 --> 00:04:18,000
every so often, and we just got them to check it.

92
00:04:19,582 --> 00:04:20,784
and hope that they found all the bugs.

93
00:04:21,304 --> 00:04:23,067
So the problem with this approach is it's quite slow

94
00:04:23,087 --> 00:04:24,869
and a fairly unreliable way

95
00:04:24,889 --> 00:04:25,990
of actually finding all our issues.

96
00:04:27,732 --> 00:04:30,476
So let's look at an example of kind of the failure

97
00:04:30,516 --> 00:04:31,297
of that kind of approach.

98
00:04:33,976 --> 00:04:44,282
Yeah, so in this bug, an engineer has made a change to the game that meant that the skeleton AI's target memory was broken so that as soon as they lost line of sight with a target, they would completely forget about them.

99
00:04:44,882 --> 00:04:54,507
Okay, I admit, this engineer was me. I put this bug in the game during the beta. So again, I thought this would be a good example to show. So who is in action on a test level?

100
00:04:59,485 --> 00:05:01,285
So the skeleton starts attacking the player,

101
00:05:01,866 --> 00:05:03,786
but when the player goes around the corner,

102
00:05:04,206 --> 00:05:07,547
he just starts wandering off, so not great.

103
00:05:08,208 --> 00:05:09,488
This is what we'd expect to see.

104
00:05:09,508 --> 00:05:18,911
So now when the player goes around the corner,

105
00:05:18,931 --> 00:05:20,972
the skeleton follows, as you'd expect.

106
00:05:22,512 --> 00:05:24,173
So let's go through kind of the process

107
00:05:24,253 --> 00:05:24,893
this bug went through.

108
00:05:25,782 --> 00:05:29,024
So first of all, the bug wasn't noticed by the developer

109
00:05:29,084 --> 00:05:30,385
as they were developing IME.

110
00:05:31,046 --> 00:05:32,386
So why did this happen?

111
00:05:32,486 --> 00:05:33,807
Did I not test the game properly?

112
00:05:33,967 --> 00:05:37,509
Well, I did try the Skeleton AI on a test level

113
00:05:37,529 --> 00:05:38,550
before I submitted my change.

114
00:05:39,030 --> 00:05:41,872
But it was on an open area where there were no obstacles,

115
00:05:41,892 --> 00:05:42,893
so you didn't see this issue.

116
00:05:43,273 --> 00:05:44,794
So again, I just submitted the change.

117
00:05:47,115 --> 00:05:51,178
Then the testers will take the latest changes and test it.

118
00:05:51,338 --> 00:05:53,179
In this case, again, because the bug was subtle enough,

119
00:05:53,219 --> 00:05:54,479
they didn't actually notice it.

120
00:05:55,500 --> 00:05:57,161
And eventually, yeah, it ends up in a game update

121
00:05:57,201 --> 00:05:58,021
and released to players.

122
00:05:58,822 --> 00:06:00,103
So if we cut to a few weeks later,

123
00:06:00,123 --> 00:06:02,324
and we see how the bug was eventually fixed.

124
00:06:02,944 --> 00:06:08,008
So at this point the community team are gathering feedback from the beta players

125
00:06:08,469 --> 00:06:13,193
and they noticed that players are starting to mention that skeletons seem a bit more dumb,

126
00:06:13,253 --> 00:06:18,697
less responsive than they used to be. So again an engineer is taken away from their normal work,

127
00:06:18,717 --> 00:06:23,361
they have to be a science bug and they have to spend time fixing it, finding the bug and then fixing it.

128
00:06:24,548 --> 00:06:26,950
Eventually there is a fix, that's put into the build,

129
00:06:27,010 --> 00:06:29,192
the test doesn't have to spend time verifying that fixed,

130
00:06:29,832 --> 00:06:31,693
then that fix goes into the players,

131
00:06:32,434 --> 00:06:33,635
but of course there's every chance

132
00:06:33,975 --> 00:06:35,816
that this bug could still reoccur

133
00:06:36,557 --> 00:06:37,758
because we've got no way to stop it.

134
00:06:39,148 --> 00:06:41,410
So rather than this kind of scattershot process

135
00:06:41,470 --> 00:06:45,112
of kind of adding a bug, finding a bug, fixing it,

136
00:06:45,892 --> 00:06:47,914
maybe what we do instead is kind of regularly

137
00:06:48,014 --> 00:06:50,095
check that scenario and just make sure

138
00:06:50,115 --> 00:06:51,055
that it's never in the build.

139
00:06:51,776 --> 00:06:54,037
So let's say we've got one of our testers,

140
00:06:54,477 --> 00:06:56,478
manual testers, to kind of check that scenario

141
00:06:57,779 --> 00:06:58,540
every day or so.

142
00:07:00,601 --> 00:07:01,721
That wouldn't take too long to do,

143
00:07:02,422 --> 00:07:03,983
but in a game like Sea of Thieves,

144
00:07:04,023 --> 00:07:04,823
you're probably gonna end up with.

145
00:07:05,223 --> 00:07:10,466
Thousands of this and it's going to be like a full-time job for someone or probably more like several people and not particularly

146
00:07:11,006 --> 00:07:15,489
You know, not particularly productive job. Really. They're just going to be doing the same mind-numbing checks all the time

147
00:07:16,689 --> 00:07:18,590
So instead of wasting a human time

148
00:07:19,290 --> 00:07:23,633
Humans time doing this we could just ask the game to do it itself right with an automated test

149
00:07:24,973 --> 00:07:26,874
Then we avoid wasting the testers time

150
00:07:27,655 --> 00:07:31,396
So the automated tests also give us a few other advantages that the humans are able to do

151
00:07:32,784 --> 00:07:38,730
So, first of all, we could run tests a lot faster with automation.

152
00:07:41,353 --> 00:07:42,634
Yeah, we could run a lot faster.

153
00:07:42,694 --> 00:07:46,918
And then, the second one is that we can be a bit more precise.

154
00:07:47,219 --> 00:07:49,461
Like, the game can test its own game state,

155
00:07:49,821 --> 00:07:54,066
which the human can only really check what's going on by eyeballing the game.

156
00:07:55,107 --> 00:07:58,129
And then the third thing that the automated test can do

157
00:07:58,169 --> 00:08:01,211
is test at a different code level, different levels

158
00:08:01,371 --> 00:08:02,032
in terms of the game.

159
00:08:02,572 --> 00:08:04,874
They can check individual code function is working correctly.

160
00:08:04,894 --> 00:08:07,816
The inputs, if there's certain inputs, certain outputs come

161
00:08:07,856 --> 00:08:10,078
out, which again, a human tester can't do.

162
00:08:10,118 --> 00:08:12,600
They can only really play the game in its complete form.

163
00:08:13,685 --> 00:08:17,326
So we shouldn't just get rid of all our manual testers straight away though.

164
00:08:17,366 --> 00:08:21,347
There's a few things that they're a bit better at than an automated test.

165
00:08:21,887 --> 00:08:28,028
So humans are going to be a lot better at noticing defects to do with the visual and audio elements of the game.

166
00:08:30,388 --> 00:08:32,429
Humans are also going to be able to use their creativity,

167
00:08:32,889 --> 00:08:36,109
do exploratory testing and find issues that we hadn't really considered yet.

168
00:08:37,349 --> 00:08:40,450
And humans are just going to be a lot better at assessing the actual game experience,

169
00:08:40,470 --> 00:08:41,530
you know, how does it feel to play.

170
00:08:42,542 --> 00:08:44,743
So until we get very advanced AIs

171
00:08:44,803 --> 00:08:48,126
that could possibly do these more human-like factors,

172
00:08:48,306 --> 00:08:51,228
we wanna have a mix of human and automated testing.

173
00:08:51,728 --> 00:08:53,489
But the advantage of having automated testing there

174
00:08:53,569 --> 00:08:54,990
is that the humans don't have to do

175
00:08:55,050 --> 00:08:56,191
so many repetitive checks.

176
00:08:56,611 --> 00:08:58,473
They can do more productive things.

177
00:09:00,594 --> 00:09:02,676
Cool, so that was why we decided automated testing

178
00:09:02,696 --> 00:09:04,137
would be a good fit.

179
00:09:04,557 --> 00:09:07,439
Now I'll talk about how our test framework worked

180
00:09:07,479 --> 00:09:08,260
and how we made tests.

181
00:09:09,609 --> 00:09:11,830
So, CFE was built on top of the Unreal Engine.

182
00:09:12,550 --> 00:09:15,912
So, we used the version that was taken a few years ago.

183
00:09:15,992 --> 00:09:17,092
So, what you see in this presentation

184
00:09:17,112 --> 00:09:18,993
might not completely match with the latest version.

185
00:09:19,093 --> 00:09:20,054
So, just bear that in mind.

186
00:09:21,314 --> 00:09:23,015
So, we implemented our test framework

187
00:09:23,035 --> 00:09:26,516
by heavily modifying the automation framework

188
00:09:26,556 --> 00:09:27,197
that was already there.

189
00:09:28,237 --> 00:09:30,878
So, when we took advantage of that,

190
00:09:30,938 --> 00:09:32,299
we could do things like in the editor,

191
00:09:32,319 --> 00:09:33,779
well, to run tests in the editor,

192
00:09:33,840 --> 00:09:35,780
all we did was go to the automation tab,

193
00:09:36,681 --> 00:09:37,961
select the test we wanted to run.

194
00:09:39,742 --> 00:09:41,022
and they would all run, and they would give you

195
00:09:41,042 --> 00:09:42,523
a kind of result, a pass or fail result.

196
00:09:44,503 --> 00:09:47,505
So we could run our tests in the editor like this,

197
00:09:47,665 --> 00:09:50,366
but we could also run them on built executables.

198
00:09:50,946 --> 00:09:52,226
And we also have the standalone tool,

199
00:09:52,406 --> 00:09:54,567
which our engineers in particular used

200
00:09:54,707 --> 00:09:56,568
to kind of verify their latest code changes

201
00:09:56,608 --> 00:10:00,009
without ever having to build the game or build the editor.

202
00:10:01,432 --> 00:10:03,675
So the simplest kind of tests we had were unit tests.

203
00:10:04,155 --> 00:10:07,438
And if you're familiar with well-known test frameworks

204
00:10:07,518 --> 00:10:09,641
like NUnit, these will look very similar.

205
00:10:10,281 --> 00:10:12,143
So it's essentially a bit of code that registers

206
00:10:12,243 --> 00:10:13,304
with the automation system

207
00:10:13,845 --> 00:10:15,346
so it can be recognized as a test.

208
00:10:16,708 --> 00:10:19,050
So unit tests generally check a specific operation

209
00:10:19,130 --> 00:10:20,391
on the smallest testable bit of code,

210
00:10:20,512 --> 00:10:23,074
which generally means testing a code function level.

211
00:10:23,964 --> 00:10:26,127
So in this example, we have a test that's checking,

212
00:10:26,167 --> 00:10:28,291
you know, a very simple math library function,

213
00:10:29,854 --> 00:10:31,657
just checking that if we've got two,

214
00:10:32,238 --> 00:10:34,201
counting and calculating the distance between the vectors

215
00:10:34,241 --> 00:10:36,726
and they're equal, then we return zero.

216
00:10:37,744 --> 00:10:41,047
So most of our tests broke down into three stages.

217
00:10:41,327 --> 00:10:42,408
So first you do the setup,

218
00:10:43,248 --> 00:10:45,810
here where we just create the vector objects.

219
00:10:46,531 --> 00:10:48,032
Then we run the actual operation

220
00:10:48,092 --> 00:10:50,994
where we run the distance function.

221
00:10:51,814 --> 00:10:52,875
And then we do the assertion

222
00:10:52,895 --> 00:10:54,857
where we check the results as expected.

223
00:10:55,717 --> 00:10:59,880
So in this case, if the test comes through and fails,

224
00:11:00,040 --> 00:11:01,702
then we will throw an error to the log.

225
00:11:02,142 --> 00:11:04,423
That will get picked up by the automation system

226
00:11:04,684 --> 00:11:05,885
and actually fail the test for us.

227
00:11:07,613 --> 00:11:09,253
So if we had unit tests that cover

228
00:11:10,094 --> 00:11:11,914
every code function in the game,

229
00:11:12,114 --> 00:11:14,055
in theory we have enough testing

230
00:11:14,075 --> 00:11:15,115
that covers all the game, right?

231
00:11:15,856 --> 00:11:18,556
But of course, sometimes the way units interact

232
00:11:18,636 --> 00:11:19,837
can themselves contain bugs.

233
00:11:22,258 --> 00:11:25,619
So it's a good idea to have integration tests on top.

234
00:11:26,019 --> 00:11:27,599
So integration tests will generally cover

235
00:11:27,639 --> 00:11:30,880
like a whole feature or action in the game.

236
00:11:31,201 --> 00:11:32,981
So they provide coverage for multiple units

237
00:11:33,041 --> 00:11:33,981
that are in that feature

238
00:11:34,042 --> 00:11:35,962
and also cover the communication between them.

239
00:11:37,768 --> 00:11:39,309
So now if a unit test fails, for example,

240
00:11:39,349 --> 00:11:41,410
we know straight away that that specific unit

241
00:11:41,450 --> 00:11:42,410
is probably gonna be the problem.

242
00:11:44,170 --> 00:11:45,671
However, if one unit test passed,

243
00:11:45,851 --> 00:11:46,911
an integration test fails,

244
00:11:47,211 --> 00:11:48,652
we know there's probably some other issue

245
00:11:48,692 --> 00:11:49,452
to do with that feature.

246
00:11:50,612 --> 00:11:51,533
Probably something to do with,

247
00:11:52,153 --> 00:11:53,813
could be the communication between units

248
00:11:54,013 --> 00:11:55,714
or maybe an asset problem, something like that.

249
00:11:56,294 --> 00:11:57,474
So an integration test failure

250
00:11:57,734 --> 00:11:58,895
is gonna take longer to investigate

251
00:11:58,935 --> 00:12:00,515
because it's covering a larger scope.

252
00:12:00,895 --> 00:12:02,696
So we generally prefer unit tests when we can.

253
00:12:03,971 --> 00:12:08,193
But they're still very useful to give us that high-level signal that something's wrong, kind of broadly with a feature.

254
00:12:09,574 --> 00:12:14,436
So to create integration tests for CFEs, we just created them as maps within the Unreal Editor.

255
00:12:14,936 --> 00:12:18,859
So each map would run a, each integration test map would run a

256
00:12:19,999 --> 00:12:23,681
fixed scenario of some kind, then report back its results as a pass or fail,

257
00:12:24,482 --> 00:12:26,423
to see whether that behavior happened as expected.

258
00:12:27,886 --> 00:12:29,948
And to do the logic of what happens in these integration

259
00:12:29,968 --> 00:12:32,010
tests, we made use of the Unreal Blueprint system.

260
00:12:32,530 --> 00:12:34,712
So if you're not aware of Blueprint, it's a node-based

261
00:12:34,892 --> 00:12:37,314
scripting system available in the Unreal Engine.

262
00:12:38,956 --> 00:12:41,378
So to follow the flow of Blueprint, you just look for

263
00:12:41,398 --> 00:12:42,959
the white line, which is the execution line.

264
00:12:43,140 --> 00:12:44,941
So in this example, we just start from the

265
00:12:44,961 --> 00:12:45,702
beginPlay event.

266
00:12:46,002 --> 00:12:48,384
We delay for two seconds, then set the actor

267
00:12:48,424 --> 00:12:49,365
rotation to all zeros.

268
00:12:50,925 --> 00:12:53,727
So, Blueprint was very good for running integration tests

269
00:12:53,988 --> 00:12:55,909
as nodes can be latent,

270
00:12:56,110 --> 00:12:57,651
which means that they'll pause execution

271
00:12:57,691 --> 00:12:59,713
until a certain condition has occurred,

272
00:12:59,733 --> 00:13:01,555
which is something you tend to do quite a lot

273
00:13:01,575 --> 00:13:02,656
in these integration tests.

274
00:13:03,697 --> 00:13:04,898
So, for example, this delay node

275
00:13:04,938 --> 00:13:07,100
is just gonna be delay execution for two seconds.

276
00:13:11,742 --> 00:13:14,964
So we could have written our integration test logic with code,

277
00:13:15,484 --> 00:13:19,186
but because of later node support and because of how easy it is to iterate on blueprint

278
00:13:19,266 --> 00:13:22,908
just inside the editor, we found it more convenient to use blueprint.

279
00:13:24,503 --> 00:13:26,925
So as an example of an integration test for Sea of Thieves,

280
00:13:27,045 --> 00:13:29,627
let's say we want to create one for one of the most basic

281
00:13:30,568 --> 00:13:32,309
actions for a pirate game like Sea of Thieves.

282
00:13:32,429 --> 00:13:35,372
It's having the player interact with and turn the wheel.

283
00:13:35,852 --> 00:13:38,074
So specifically we're going to check that when they do that,

284
00:13:38,354 --> 00:13:41,537
the actual wheel angle of the mesh turns correctly.

285
00:13:41,897 --> 00:13:43,638
So this is what it looks like in game at the moment.

286
00:13:51,061 --> 00:13:52,122
Okay, so if we wanted to go back,

287
00:13:52,162 --> 00:13:53,584
create an integration test for this,

288
00:13:53,944 --> 00:13:54,785
you know, one thing we could do,

289
00:13:54,825 --> 00:13:56,708
we could load up the full world,

290
00:13:56,728 --> 00:13:59,691
we could have a player stand on the ship and turn the wheel,

291
00:13:59,891 --> 00:14:02,614
but that's gonna be very, very slow to load.

292
00:14:02,715 --> 00:14:04,917
And also you're bringing so many other systems

293
00:14:04,937 --> 00:14:06,339
that are gonna affect your test,

294
00:14:06,359 --> 00:14:08,361
you're not really kind of looking specifically

295
00:14:08,381 --> 00:14:09,082
at the wheel anymore.

296
00:14:09,943 --> 00:14:13,644
So instead, you can have a much simpler version,

297
00:14:13,664 --> 00:14:15,905
and this is what we end up doing in this example.

298
00:14:16,325 --> 00:14:18,606
So we're gonna have a player, just standing on a platform,

299
00:14:18,706 --> 00:14:19,527
interacting with a wheel,

300
00:14:20,267 --> 00:14:21,667
and that's essentially all we need.

301
00:14:23,728 --> 00:14:25,149
So this is a blueprint for the test,

302
00:14:25,489 --> 00:14:27,910
and you can see it splits up into those three phases

303
00:14:27,990 --> 00:14:31,091
like we had before, setup, run operation, and check results.

304
00:14:31,931 --> 00:14:33,492
So I'll zoom in a bit better so you can see.

305
00:14:35,040 --> 00:14:39,182
So in the first half we start with a big in-play event, which is on the level blueprint

306
00:14:39,963 --> 00:14:44,005
We a lot of the setups already done for us essentially by adding the wheel and the player

307
00:14:44,125 --> 00:14:49,188
But we also need the player to interact with the wheel before you can actually turn it. So we do that first

308
00:14:50,149 --> 00:14:55,212
Then we do the run operation which is in this case is having the player apply a fake input

309
00:14:57,167 --> 00:14:57,767
just to turn the wheel.

310
00:14:59,068 --> 00:15:00,990
And then finally we do an assertion

311
00:15:01,050 --> 00:15:02,652
and we check that the wheel angle

312
00:15:02,812 --> 00:15:04,374
has kind of gone beyond a certain tolerance

313
00:15:04,814 --> 00:15:05,995
so we know that the wheel

314
00:15:06,035 --> 00:15:07,396
has been interacted with correctly.

315
00:15:08,337 --> 00:15:09,198
And then we finish the test.

316
00:15:10,540 --> 00:15:12,341
So this is what the test looks like in action.

317
00:15:14,043 --> 00:15:14,844
I've slowed it down a bit

318
00:15:14,884 --> 00:15:16,745
and made the angle a bit larger

319
00:15:16,806 --> 00:15:18,127
just to show visually what's happening.

320
00:15:18,327 --> 00:15:20,349
So in reality, probably running less than a second.

321
00:15:21,910 --> 00:15:23,311
And if we go back to the automation window,

322
00:15:23,351 --> 00:15:24,632
we can see that the test is passing.

323
00:15:25,073 --> 00:15:27,134
So now we have a test that's checking that whole operation,

324
00:15:27,975 --> 00:15:31,337
including all the units involved and the in-game assets.

325
00:15:31,777 --> 00:15:32,618
And if we run it regularly,

326
00:15:32,658 --> 00:15:35,279
we can see if something breaks this feature.

327
00:15:37,521 --> 00:15:39,241
So it's good practice that a test,

328
00:15:39,341 --> 00:15:40,482
particularly an integration test,

329
00:15:40,842 --> 00:15:42,722
is made to be robust to all the changes

330
00:15:42,762 --> 00:15:44,582
we could kind of expect that still conform

331
00:15:44,642 --> 00:15:47,223
to the behavioral contract that we kind of started with.

332
00:15:47,283 --> 00:15:48,963
So in this case that the player

333
00:15:49,243 --> 00:15:50,543
interacts with the wheel and turns it.

334
00:15:51,584 --> 00:15:53,244
If you end up kind of relying on something

335
00:15:53,304 --> 00:15:54,744
more specific than that, you're in danger

336
00:15:54,764 --> 00:15:56,525
of kind of relying more on the implementation

337
00:15:56,545 --> 00:15:58,225
of the feature, and you'll probably find

338
00:15:58,265 --> 00:15:59,645
that you're gonna have to be constantly

339
00:15:59,705 --> 00:16:02,386
reworking your test as you're reworking the implementation.

340
00:16:03,326 --> 00:16:06,409
So as an example of this, if we look at the test that we just made,

341
00:16:07,170 --> 00:16:11,854
this is the three broadly code steps that are happening when we run it.

342
00:16:11,954 --> 00:16:15,717
So first, we have a character input handler on the player character.

343
00:16:15,858 --> 00:16:17,419
That gets a negative input sent to it.

344
00:16:18,260 --> 00:16:20,942
That input handler then sends the input to the wheel object,

345
00:16:21,563 --> 00:16:24,045
and then the wheel applies that input to the wheel mesh.

346
00:16:24,506 --> 00:16:25,366
And then we check the results.

347
00:16:26,986 --> 00:16:28,647
But, and we're doing it all on the same frame,

348
00:16:28,687 --> 00:16:31,168
which is the danger, because if we decide

349
00:16:31,188 --> 00:16:33,369
to make a code change, which happens a lot,

350
00:16:33,389 --> 00:16:35,871
where we wanna defer something to the next frame,

351
00:16:36,231 --> 00:16:38,492
so let's say we defer the application

352
00:16:38,532 --> 00:16:41,654
of the wheel mesh angle to the next frame,

353
00:16:42,094 --> 00:16:43,695
so suddenly we're gonna be checking the results

354
00:16:43,735 --> 00:16:45,896
at a time when the wheel hasn't actually been changed yet.

355
00:16:46,336 --> 00:16:47,997
And if we check, then we find, yes,

356
00:16:48,137 --> 00:16:50,218
that the test is now failing,

357
00:16:50,878 --> 00:16:53,360
with an error saying that the angle is not correct.

358
00:16:55,268 --> 00:16:57,629
So the most straightforward way to fix a test

359
00:16:57,709 --> 00:16:59,270
is just to add a delay for one frame

360
00:16:59,310 --> 00:17:02,571
between the run operation and checking the result.

361
00:17:04,871 --> 00:17:06,612
And the test succeeds again.

362
00:17:08,273 --> 00:17:10,973
But let's say that we wanna do another code change now.

363
00:17:11,013 --> 00:17:12,934
This time we're gonna add a animation

364
00:17:13,014 --> 00:17:15,035
that happens kind of in that stage of the code

365
00:17:15,495 --> 00:17:17,676
between when the input handler sends the input to the wheel

366
00:17:17,796 --> 00:17:20,356
and between when we set it on the wheel mesh.

367
00:17:20,957 --> 00:17:22,717
And we're not sure how long that animation's gonna be.

368
00:17:24,354 --> 00:17:26,716
And it looks like, yep, the test is now failing again.

369
00:17:27,256 --> 00:17:28,878
So how would we fix it at this point?

370
00:17:29,438 --> 00:17:32,041
So one thing we could do is possibly inspect the animation

371
00:17:32,081 --> 00:17:33,202
and find out how long it is.

372
00:17:33,402 --> 00:17:35,604
But again, the problem there is we're

373
00:17:35,644 --> 00:17:37,305
kind of looking at the implementation again.

374
00:17:37,325 --> 00:17:39,868
And we're kind of, you know, if we take the animation out,

375
00:17:39,908 --> 00:17:41,009
we'll have to fix the test again.

376
00:17:41,962 --> 00:17:44,744
Maybe we could add a large delay, say 100 frames,

377
00:17:44,824 --> 00:17:47,827
because we're sure that the animation's not going to be

378
00:17:48,107 --> 00:17:48,767
any longer than that.

379
00:17:49,668 --> 00:17:53,911
And this would work, but you've added at least 100 frames

380
00:17:53,951 --> 00:17:54,791
to the test time now.

381
00:17:54,872 --> 00:17:57,433
And they maybe expect the animation to be a lot less.

382
00:17:57,694 --> 00:17:59,755
And again, if you run the test once or twice,

383
00:17:59,775 --> 00:18:00,415
that's not too bad.

384
00:18:00,456 --> 00:18:02,657
But we're going to be running this test hundreds of times

385
00:18:02,697 --> 00:18:04,098
a day, possibly, on our build system.

386
00:18:04,138 --> 00:18:05,939
So all those extra frames are going to add up.

387
00:18:07,264 --> 00:18:10,366
So instead, a better solution is just to use a polling version.

388
00:18:10,726 --> 00:18:13,388
So what we do is we just use a delayUntil node,

389
00:18:13,788 --> 00:18:15,669
and that will just, again, it's a latent node,

390
00:18:15,710 --> 00:18:18,411
and it will keep spinning, waiting for the angle

391
00:18:18,972 --> 00:18:19,492
to be correct.

392
00:18:19,692 --> 00:18:20,933
So again, it doesn't really matter

393
00:18:20,993 --> 00:18:24,015
what's happening as the player interacts with the wheel.

394
00:18:24,956 --> 00:18:27,018
It will find the right result eventually,

395
00:18:27,558 --> 00:18:31,080
which it does with the added animation in our works again.

396
00:18:32,141 --> 00:18:36,444
And if for some reason the wheel is actually broken, what we get is a timeout.

397
00:18:36,725 --> 00:18:43,009
So in this case, it will timeout after five seconds because the wheel is broken and we just never see the angle change.

398
00:18:43,970 --> 00:18:49,374
So this is a little bit wasteful, I suppose, because we're, you know, we're all wasting five seconds.

399
00:18:50,314 --> 00:18:52,495
But we don't expect this to happen very regularly

400
00:18:52,535 --> 00:18:54,915
because hopefully the feature is gonna be working

401
00:18:55,075 --> 00:18:55,836
almost all the time.

402
00:18:55,996 --> 00:18:58,676
So again, we tended to set our test timeouts

403
00:18:58,696 --> 00:19:00,937
to be quite high for that reason

404
00:19:01,657 --> 00:19:04,398
because we felt kind of safe doing that.

405
00:19:08,139 --> 00:19:09,419
So, I'll just have a bit more.

406
00:19:14,909 --> 00:19:17,432
So Sea of Thieves is a multiplayer game.

407
00:19:17,792 --> 00:19:19,974
It uses a network client server architecture.

408
00:19:20,996 --> 00:19:23,298
So we really wanted to make sure that we covered that

409
00:19:23,358 --> 00:19:25,300
aspect of the game with our integration test as well.

410
00:19:26,869 --> 00:19:31,332
So integration tests, we changed the automation framework

411
00:19:31,352 --> 00:19:33,674
that was there in Unreal to allow integration tests

412
00:19:33,694 --> 00:19:36,936
to pass execution between the server and the client

413
00:19:37,337 --> 00:19:38,578
so that we could check both sides

414
00:19:38,618 --> 00:19:40,059
of kind of a network communication.

415
00:19:41,120 --> 00:19:42,581
And we did this, this could work with kind of

416
00:19:42,601 --> 00:19:45,162
built executables of an actual client, an actual server,

417
00:19:45,243 --> 00:19:46,744
and it also works just on the editor

418
00:19:46,784 --> 00:19:49,786
with kind of virtual client and server processes.

419
00:19:51,707 --> 00:19:52,588
So this is what would happen

420
00:19:52,628 --> 00:19:54,469
in a typical networked integration test.

421
00:19:55,567 --> 00:19:58,569
So first the test begins on the server.

422
00:19:59,190 --> 00:20:01,491
So here we would do the setup and say how many clients

423
00:20:01,531 --> 00:20:03,833
we want in the test and do the initial kind of handshaking.

424
00:20:04,814 --> 00:20:07,196
And generally we'd set up some kind of behavior here

425
00:20:07,696 --> 00:20:08,276
on the server.

426
00:20:08,536 --> 00:20:10,278
And then we'd switch over to the client

427
00:20:10,858 --> 00:20:12,940
and we'd check that whatever we set up on the server

428
00:20:12,960 --> 00:20:15,101
has been communicated correctly over the network

429
00:20:15,181 --> 00:20:16,142
over to that first client.

430
00:20:17,663 --> 00:20:19,364
Then we'd go back to a server.

431
00:20:20,481 --> 00:20:22,924
And then depending on the test, you might end it here,

432
00:20:22,984 --> 00:20:25,166
but in this, let's say that we want to actually test

433
00:20:25,186 --> 00:20:27,569
that that communication or slightly different communication

434
00:20:27,629 --> 00:20:29,711
has been sent over to a second client.

435
00:20:29,731 --> 00:20:31,373
So again, the test could support that.

436
00:20:32,655 --> 00:20:33,636
So we could go back and forth,

437
00:20:33,676 --> 00:20:35,538
ping-ponging between server and clients,

438
00:20:36,119 --> 00:20:37,840
but when we're ready to end the test,

439
00:20:37,860 --> 00:20:40,503
we just go back to the server and we finish the test.

440
00:20:42,997 --> 00:20:45,037
So let's, as an example of what a multiplayer

441
00:20:45,057 --> 00:20:47,678
integration test looks like, for real,

442
00:20:48,298 --> 00:20:51,439
let's modify the test that we just did,

443
00:20:51,719 --> 00:20:53,739
based on the wheel, we're gonna look for the same thing,

444
00:20:53,839 --> 00:20:54,979
the change in the wheel angle,

445
00:20:55,640 --> 00:20:57,760
but we'll check that it's actually working

446
00:20:58,020 --> 00:21:01,201
on a different client, on the second client in the scene,

447
00:21:02,001 --> 00:21:03,862
which is this guy just standing to the side here.

448
00:21:04,562 --> 00:21:08,543
So what we expect to see in terms of the flow of code

449
00:21:08,643 --> 00:21:10,643
and network communication,

450
00:21:11,544 --> 00:21:14,007
is first the player interacts and turns the wheel,

451
00:21:14,147 --> 00:21:16,189
just like in the previous test example.

452
00:21:17,651 --> 00:21:19,533
Then when that wheel angle changes,

453
00:21:19,573 --> 00:21:21,635
that gets communicated up to a server.

454
00:21:22,857 --> 00:21:25,620
And then finally, that server will communicate it

455
00:21:25,640 --> 00:21:27,302
to the other client, the observing client.

456
00:21:29,682 --> 00:21:31,684
So this is the blueprint for this.

457
00:21:32,105 --> 00:21:33,426
I'll probably go a little bit faster

458
00:21:33,466 --> 00:21:34,367
because it's a little longer,

459
00:21:34,948 --> 00:21:36,830
but I'll point out all the interesting parts

460
00:21:36,890 --> 00:21:38,752
in terms of the network version.

461
00:21:39,873 --> 00:21:42,256
So we'll start from begin play again.

462
00:21:42,536 --> 00:21:44,478
Then we have a sync client server node,

463
00:21:44,598 --> 00:21:47,461
which starts the test with two clients.

464
00:21:49,818 --> 00:21:52,600
We'll then switch execution over to the first client.

465
00:21:52,880 --> 00:21:54,261
This is gonna be the interacting client.

466
00:21:55,742 --> 00:21:57,323
That client then interacts with the wheel

467
00:21:57,643 --> 00:22:00,105
and applies the fake input, just as we did previously.

468
00:22:01,366 --> 00:22:03,447
Then we'll switch to the observing client.

469
00:22:03,487 --> 00:22:05,748
So this node kind of does it in a shortcut way,

470
00:22:05,788 --> 00:22:07,690
but essentially we go to the server first

471
00:22:08,270 --> 00:22:09,571
and then to the second client.

472
00:22:09,651 --> 00:22:12,693
So this is client ID one, this is the observing client.

473
00:22:15,080 --> 00:22:16,702
that client will do the polling,

474
00:22:16,922 --> 00:22:19,965
just like on the previous version of the test.

475
00:22:20,586 --> 00:22:22,267
So when that client then sees

476
00:22:22,307 --> 00:22:24,349
that the wheel angle has changed past the tolerance,

477
00:22:26,431 --> 00:22:29,094
then we switch back to the server and we finish the test.

478
00:22:33,042 --> 00:22:35,783
So those were unit tests and integration tests,

479
00:22:35,844 --> 00:22:37,445
but we had a few other test types

480
00:22:37,845 --> 00:22:39,606
that I'd like to talk about briefly.

481
00:22:40,567 --> 00:22:42,288
So we also had asset audit tests.

482
00:22:42,648 --> 00:22:44,329
So these would check the setup on assets,

483
00:22:44,489 --> 00:22:45,950
make sure they're kind of compatible

484
00:22:45,990 --> 00:22:47,111
with what we expect in the game.

485
00:22:47,952 --> 00:22:50,674
So we had one of these per a lot,

486
00:22:50,934 --> 00:22:53,055
most of our asset types had some kind of asset audit test

487
00:22:53,456 --> 00:22:54,756
that it picked up on.

488
00:22:55,977 --> 00:22:57,218
We also had screenshot tests.

489
00:22:57,318 --> 00:22:59,800
So these looked in practice a lot like integration tests.

490
00:23:00,750 --> 00:23:03,353
But at the end of it, they usually took a screenshot,

491
00:23:03,633 --> 00:23:05,435
where we, and then we compare that screenshot

492
00:23:05,775 --> 00:23:08,818
with a process afterwards against the last known

493
00:23:08,858 --> 00:23:11,120
good screenshot of that test to check

494
00:23:11,280 --> 00:23:13,462
and if there were any differences that meant

495
00:23:13,502 --> 00:23:15,844
there was some kind of visual error or rendering bug.

496
00:23:17,220 --> 00:23:18,742
We also had performance tests.

497
00:23:19,062 --> 00:23:21,064
These are, again, similar to integration tests,

498
00:23:21,164 --> 00:23:22,166
but they ran a bit longer,

499
00:23:22,186 --> 00:23:23,947
and they would collect data

500
00:23:25,669 --> 00:23:28,792
based, to see if we got some trends or spikes

501
00:23:28,832 --> 00:23:31,876
in terms of frame rate, memory use,

502
00:23:32,216 --> 00:23:33,257
loading times, that kind of thing.

503
00:23:35,223 --> 00:23:36,344
Then finally we had boot flow tests.

504
00:23:36,364 --> 00:23:39,467
So these were the closest tests to kind of simulating

505
00:23:39,487 --> 00:23:41,709
what it's like to actually run the game, because they tested

506
00:23:41,729 --> 00:23:44,232
communication between the client, server,

507
00:23:44,272 --> 00:23:46,674
and all our services that are vital to running the game

508
00:23:46,714 --> 00:23:46,974
as well.

509
00:23:47,455 --> 00:23:50,298
And they would check under kind of common scenarios,

510
00:23:50,338 --> 00:23:53,000
such as a client joining a new server

511
00:23:53,160 --> 00:23:55,643
and registering all the services and that kind of thing.

512
00:23:58,280 --> 00:24:00,843
So I'm going to talk very briefly about the kind of infrastructure we had.

513
00:24:00,863 --> 00:24:04,368
It's not really the focus of this talk, but sort of it's kind of relevant.

514
00:24:05,789 --> 00:24:09,634
If you want to learn more, then my colleague Jafar did another talk in last year's GDC

515
00:24:09,674 --> 00:24:11,236
called Adopting Continuous Delivery.

516
00:24:12,237 --> 00:24:14,219
So check that out on the vault if you want to learn a bit more.

517
00:24:16,691 --> 00:24:19,373
So we run our tests as part of a build system, which

518
00:24:19,433 --> 00:24:20,934
is like a TeamCity.

519
00:24:20,954 --> 00:24:23,695
It uses the TeamCity continuous integration software.

520
00:24:24,236 --> 00:24:27,378
So TeamCity will go ahead, use our build farm of PCs,

521
00:24:27,418 --> 00:24:29,379
and then allocate them to do various jobs,

522
00:24:29,439 --> 00:24:33,261
such as building the game and running a group of tests.

523
00:24:34,730 --> 00:24:37,074
So depending on what kind of test it was,

524
00:24:37,134 --> 00:24:39,858
and how slow it was, and how important it was sometimes,

525
00:24:40,619 --> 00:24:42,863
would depend on how often we ran the test.

526
00:24:42,963 --> 00:24:45,267
But generally, on average, we ran every test

527
00:24:45,287 --> 00:24:47,109
we had about every 20 minutes or so.

528
00:24:48,936 --> 00:24:52,017
So if the build system encounters test failure,

529
00:24:52,617 --> 00:24:54,478
we would set the build to red.

530
00:24:54,898 --> 00:24:56,359
We have screens all around the studio

531
00:24:56,419 --> 00:24:58,780
which show kind of the status of the current build.

532
00:24:59,700 --> 00:25:03,181
And if that happens, we kind of have a bit of information

533
00:25:03,221 --> 00:25:04,822
about kind of what test job has failed

534
00:25:04,902 --> 00:25:07,403
and who was probably responsible as the last person

535
00:25:07,943 --> 00:25:10,564
to change something in that area.

536
00:25:10,924 --> 00:25:12,284
I've blanked out the name in this example

537
00:25:12,324 --> 00:25:13,945
because I didn't want to embarrass anyone at GDC.

538
00:25:17,515 --> 00:25:20,736
So to make sure we didn't have a broken build

539
00:25:20,796 --> 00:25:23,217
and that team members could carry on working,

540
00:25:23,857 --> 00:25:26,758
we have a kind of a three-step process

541
00:25:26,798 --> 00:25:30,139
for doing submits, submitting changes.

542
00:25:31,179 --> 00:25:33,280
So the first one was that you could only submit changes

543
00:25:33,360 --> 00:25:36,241
if the build was green, i.e. there was no test failing.

544
00:25:37,381 --> 00:25:39,242
We didn't want to allow people

545
00:25:39,302 --> 00:25:40,842
to continue submitting something

546
00:25:41,223 --> 00:25:42,423
if the build was already broken

547
00:25:42,483 --> 00:25:43,863
and maybe making the situation worse.

548
00:25:45,940 --> 00:25:50,349
So that would have made it very important if the test was failing, whoever was responsible

549
00:25:50,750 --> 00:25:54,999
needed to fix it as soon as they could because it was blocking the whole team from committing

550
00:25:55,020 --> 00:25:55,581
any more changes.

551
00:25:58,285 --> 00:26:02,248
Next, we always expect that each change has reasonable test coverage.

552
00:26:02,268 --> 00:26:07,311
So reasonable is obviously where there's some kind of a leeway and some kind of, you know, a grey area.

553
00:26:07,972 --> 00:26:12,995
If it was an artist or a designer, they generally wouldn't submit a test with their change.

554
00:26:13,936 --> 00:26:18,759
Often, when they submit that asset, it would get picked up by an asset audit and it would be checked there.

555
00:26:19,460 --> 00:26:22,341
But an engineer adding a new bit of code or a new feature,

556
00:26:22,742 --> 00:26:25,563
we would reasonably expect that they would include a test,

557
00:26:26,324 --> 00:26:29,045
a unit test, integration test with that submission.

558
00:26:30,266 --> 00:26:31,426
So at Rare, we don't really have,

559
00:26:31,667 --> 00:26:33,227
well, we don't have test engineers

560
00:26:33,388 --> 00:26:36,769
who do the test coverage for other engineers,

561
00:26:37,530 --> 00:26:38,470
the feature work they've done.

562
00:26:38,891 --> 00:26:43,393
We found it better if engineers decided themselves

563
00:26:43,433 --> 00:26:45,774
and took responsibility for the test coverage

564
00:26:45,814 --> 00:26:47,215
that would be needed for their change.

565
00:26:50,652 --> 00:26:52,933
And the third thing is that we ask people

566
00:26:52,993 --> 00:26:54,674
to run a pre-commit first.

567
00:26:55,594 --> 00:26:59,396
So, obviously, engineers or developers,

568
00:26:59,756 --> 00:27:01,157
they need to take some responsibility

569
00:27:01,177 --> 00:27:02,918
for their local, for submitting changes,

570
00:27:02,938 --> 00:27:04,679
they need to check that they're working correctly.

571
00:27:05,519 --> 00:27:08,180
We could have asked them to run automated tests locally,

572
00:27:09,201 --> 00:27:10,802
which, that would have taken a bit of time.

573
00:27:10,822 --> 00:27:13,223
Also, there's every chance they could forget,

574
00:27:13,383 --> 00:27:14,984
and every chance that they don't,

575
00:27:16,365 --> 00:27:17,886
running all the tests isn't really practical

576
00:27:17,926 --> 00:27:18,707
because there's a lot of them,

577
00:27:19,087 --> 00:27:20,468
so they would have to pick which tests

578
00:27:20,528 --> 00:27:21,489
are relevant to their change,

579
00:27:21,549 --> 00:27:23,771
which is gonna be prone to error.

580
00:27:24,271 --> 00:27:27,674
So instead, we ask an engineer to,

581
00:27:27,694 --> 00:27:28,775
or a developer, sorry,

582
00:27:29,175 --> 00:27:31,617
we ask all our developers to run a pre-commit first,

583
00:27:31,677 --> 00:27:33,379
which would mean that they send their change

584
00:27:33,479 --> 00:27:34,239
to the build system.

585
00:27:34,700 --> 00:27:36,802
That wouldn't actually submit it to the main branch,

586
00:27:36,882 --> 00:27:39,284
it would just, the build system would go ahead.

587
00:27:39,944 --> 00:27:41,506
build the game with that current change,

588
00:27:41,906 --> 00:27:44,609
and then run tests that it decides

589
00:27:44,749 --> 00:27:48,692
are related to that change, and to see if those,

590
00:27:48,773 --> 00:27:50,754
and then send the results back to that developer

591
00:27:50,774 --> 00:27:53,197
to say whether that change looks good enough to submit.

592
00:27:56,180 --> 00:27:59,102
So, here's a summary of kind of the full

593
00:27:59,122 --> 00:28:02,125
Sea of Thieves testing process that we ended up with,

594
00:28:03,066 --> 00:28:05,228
using that same dev timeline that I showed you earlier.

595
00:28:06,829 --> 00:28:08,271
So first of all, as I mentioned before,

596
00:28:08,411 --> 00:28:10,133
when the developer makes a local change,

597
00:28:11,355 --> 00:28:14,919
they run the pre-commit, which runs a set of automated,

598
00:28:15,620 --> 00:28:16,902
the related automated tests.

599
00:28:17,703 --> 00:28:20,066
So if the developer does this first,

600
00:28:20,126 --> 00:28:22,869
then they can be reasonably sure

601
00:28:23,229 --> 00:28:24,411
that when they submit their changes,

602
00:28:24,471 --> 00:28:25,793
it's not gonna affect the rest of the team.

603
00:28:27,892 --> 00:28:31,513
Second of all, after the developer submits the change,

604
00:28:31,593 --> 00:28:35,334
so the build system is constantly running all our tests,

605
00:28:35,714 --> 00:28:37,295
checking to see if there's intimate issues,

606
00:28:37,775 --> 00:28:39,195
running some more long-running tests

607
00:28:39,235 --> 00:28:40,916
to find trends, that kind of thing.

608
00:28:41,476 --> 00:28:43,276
So because we do this, we're fairly confident

609
00:28:43,597 --> 00:28:45,217
almost all the time that our build is good

610
00:28:45,977 --> 00:28:47,578
and we can kind of move on to the next stage

611
00:28:47,638 --> 00:28:50,278
and with whatever build we have at the moment.

612
00:28:51,835 --> 00:28:53,595
So at this point, once the build system

613
00:28:53,695 --> 00:28:56,196
kind of spits out a build, which we do every so often,

614
00:28:56,296 --> 00:28:59,377
probably every day, then we have the manual testers

615
00:28:59,417 --> 00:28:59,997
check the build.

616
00:29:00,017 --> 00:29:01,898
So this is obviously very similar to what we had

617
00:29:01,938 --> 00:29:04,138
in the previous process, but because we've done

618
00:29:04,158 --> 00:29:05,739
all that automated testing first,

619
00:29:06,779 --> 00:29:09,840
the manual testers are gonna always get

620
00:29:10,280 --> 00:29:12,381
a good build to test with, so they're not gonna get

621
00:29:12,421 --> 00:29:14,781
that show-stopping bug that happens all the time where...

622
00:29:15,362 --> 00:29:18,646
they get the build for the day and the build is just completely broken

623
00:29:18,726 --> 00:29:22,071
and they waste hours then having to get the next build which has got that fixed.

624
00:29:22,812 --> 00:29:25,496
That's not going to happen because we're fairly sure that all the automated tests

625
00:29:25,516 --> 00:29:26,718
would have picked up those kind of issues.

626
00:29:28,943 --> 00:29:32,907
Then finally, we don't do this all the time,

627
00:29:32,927 --> 00:29:35,350
but occasionally, especially when we've got new features

628
00:29:35,390 --> 00:29:36,712
that we want to get some input on,

629
00:29:37,152 --> 00:29:42,118
we'll send a latest update to a group of insider players

630
00:29:42,198 --> 00:29:44,460
to get kind of feedback on that change

631
00:29:44,661 --> 00:29:47,504
before we submit it to all of our player base.

632
00:29:47,984 --> 00:29:50,327
Again, similar to what a lot of studios would do.

633
00:29:50,847 --> 00:29:56,851
Again, the difference here is we don't we hopefully don't expect them to see actually many bugs because again

634
00:29:56,891 --> 00:30:01,214
we've gone through the automated testing process and we've gone through our manual testing process and

635
00:30:01,375 --> 00:30:06,138
Hopefully they can just concentrate and give us feedback on you know, the feature and the gameplay itself

636
00:30:08,329 --> 00:30:10,170
So, so far what I've shown you is what our testing

637
00:30:10,190 --> 00:30:13,092
looked like when we started full production on CFEs.

638
00:30:13,632 --> 00:30:15,914
Next I'll show you how we optimized our testing

639
00:30:15,934 --> 00:30:17,555
during development, or in other words,

640
00:30:18,235 --> 00:30:20,296
how we became more pragmatic over time

641
00:30:20,316 --> 00:30:21,357
with our automated testing.

642
00:30:22,598 --> 00:30:24,159
So, as we entered full production,

643
00:30:24,179 --> 00:30:26,360
we had our full team now creating tests,

644
00:30:26,620 --> 00:30:27,781
and we were seeing the benefits

645
00:30:27,961 --> 00:30:29,542
of the extra build quality we were getting,

646
00:30:29,562 --> 00:30:31,723
but we were also finding the test

647
00:30:31,743 --> 00:30:33,865
to be a bit of a burden in several ways.

648
00:30:35,788 --> 00:30:38,851
So first of all, we were spending a lot more time

649
00:30:38,911 --> 00:30:40,593
creating the tests than we expected.

650
00:30:40,613 --> 00:30:44,616
We knew we would be spending some,

651
00:30:44,696 --> 00:30:46,238
but it was happening, we were spending

652
00:30:46,258 --> 00:30:47,079
a lot more than we'd like.

653
00:30:49,565 --> 00:30:51,927
The second issue was that the tests were generally

654
00:30:52,027 --> 00:30:52,827
quite slow to run.

655
00:30:52,907 --> 00:30:55,049
We had quite a lot of them,

656
00:30:55,369 --> 00:30:57,931
and some of them were very slow to run.

657
00:30:58,871 --> 00:31:00,712
The aim was that the pre-commit process

658
00:31:00,752 --> 00:31:02,474
would take about an hour,

659
00:31:02,974 --> 00:31:05,235
but it was kind of creeping up to like hour and a half

660
00:31:06,036 --> 00:31:07,457
because it was taking such a long time,

661
00:31:07,497 --> 00:31:10,179
which meant that developers were put in a queue

662
00:31:10,219 --> 00:31:11,420
to do their pre-commit,

663
00:31:11,440 --> 00:31:14,542
which means that it would take half a day or two a day

664
00:31:14,622 --> 00:31:15,883
to kind of get their changes in.

665
00:31:15,983 --> 00:31:17,924
So that was really slowing down our development.

666
00:31:19,785 --> 00:31:21,106
The third issue was that our tests,

667
00:31:21,467 --> 00:31:23,789
particularly some tests, the long and complex ones,

668
00:31:23,809 --> 00:31:25,930
were quite unreliable, excuse me.

669
00:31:26,691 --> 00:31:28,633
And that meant that a lot of engineer time

670
00:31:28,673 --> 00:31:30,354
was put into kind of figuring out

671
00:31:30,394 --> 00:31:32,216
why a test would fail occasionally

672
00:31:32,276 --> 00:31:34,718
and kind of improving the tests, maintaining the tests.

673
00:31:36,552 --> 00:31:38,752
So for those three issues that I mentioned,

674
00:31:39,012 --> 00:31:42,253
the creation time, running time, unreliability,

675
00:31:42,993 --> 00:31:44,854
almost all of them were much, much worse

676
00:31:45,034 --> 00:31:46,755
for our map-based integration tests.

677
00:31:47,895 --> 00:31:49,935
So if we look at the running time, for example,

678
00:31:50,636 --> 00:31:53,236
the unit tests would run 10th of a second,

679
00:31:53,276 --> 00:31:54,877
something like that, that's a max.

680
00:31:55,517 --> 00:31:58,198
And then our integration tests would take up to 20 seconds.

681
00:31:58,858 --> 00:32:01,239
So this was because of all the assets

682
00:32:01,499 --> 00:32:03,019
these tests generally had to load.

683
00:32:04,520 --> 00:32:08,466
Initializing network connections took a long time getting, you know spinning up a new world each time

684
00:32:09,327 --> 00:32:14,695
We still wanted to use integration tests, but because they were so slow. We really needed to find a way to

685
00:32:15,216 --> 00:32:18,281
Improve them so we could or if possible use a lot less

686
00:32:20,137 --> 00:32:22,199
So why did we have so many integration tests?

687
00:32:22,940 --> 00:32:25,763
And we had them for gameplay features in particular.

688
00:32:26,543 --> 00:32:28,285
So if you imagine kind of the code,

689
00:32:28,425 --> 00:32:30,808
like our code base is a pyramid with Sea of Thieves

690
00:32:30,848 --> 00:32:33,050
city on top of the Unreal Engine,

691
00:32:33,971 --> 00:32:36,554
then unit tests kind of sit right at the bottom

692
00:32:36,874 --> 00:32:38,796
because they didn't really have dependencies

693
00:32:38,937 --> 00:32:40,638
on Unreal or Sea of Thieves.

694
00:32:41,779 --> 00:32:43,280
So they were nice and fast to run.

695
00:32:43,920 --> 00:32:46,681
Whereas integration tests, because they had dependency,

696
00:32:46,761 --> 00:32:49,221
they needed a built version of the game or the editor,

697
00:32:49,621 --> 00:32:51,922
they were dependent on everything Unreal,

698
00:32:52,002 --> 00:32:52,942
everything in Sea of Thieves.

699
00:32:54,463 --> 00:32:56,904
And we definitely found that the more dependencies

700
00:32:56,964 --> 00:32:59,524
on a test, the slower the test was to run

701
00:32:59,724 --> 00:33:01,025
and less reliable it was.

702
00:33:01,765 --> 00:33:05,446
So we really wanted to not use as many integration tests

703
00:33:05,946 --> 00:33:07,227
as we could, as possible.

704
00:33:10,729 --> 00:33:13,170
But unfortunately, for gameplay testing in particular,

705
00:33:13,790 --> 00:33:15,771
we were using a lot of integration tests.

706
00:33:15,871 --> 00:33:17,512
And the reason for this is because we

707
00:33:17,532 --> 00:33:19,493
were building our gameplay code on top of Unreal,

708
00:33:19,934 --> 00:33:21,574
which you know, so we're using classes

709
00:33:21,614 --> 00:33:24,336
such as actors and components, which are integral to Unreal.

710
00:33:25,236 --> 00:33:27,278
And we thought that if we wanted to get

711
00:33:27,318 --> 00:33:29,339
a true representation of our gameplay features,

712
00:33:29,379 --> 00:33:31,560
we really need to use them in the proper context, which

713
00:33:31,600 --> 00:33:34,141
meant in an Unreal map, which meant we had

714
00:33:34,161 --> 00:33:35,222
to use an integration test.

715
00:33:36,202 --> 00:33:37,963
But it was obviously very taxing.

716
00:33:38,003 --> 00:33:39,824
We were creating a lot of these very expensive tests.

717
00:33:41,068 --> 00:33:43,070
So when we kind of changed our assumption,

718
00:33:43,570 --> 00:33:45,912
and we thought, you know, maybe we could use,

719
00:33:46,633 --> 00:33:48,795
make our tests, gameplay tests run at a lower level,

720
00:33:48,835 --> 00:33:50,596
where we just check the logic,

721
00:33:50,776 --> 00:33:52,818
but didn't have all the dependencies, you know,

722
00:33:52,858 --> 00:33:53,879
we wondered if that would work.

723
00:33:54,740 --> 00:33:56,441
So instead we came up with a new kind of test,

724
00:33:56,621 --> 00:34:00,585
which we called actor tests, because they're so named,

725
00:34:00,605 --> 00:34:04,928
because they use the actor object in Unreal so heavily.

726
00:34:07,333 --> 00:34:11,334
So, actor tests were essentially a unit test for Unreal game code.

727
00:34:12,775 --> 00:34:18,677
They treated Unreal Engine concepts such as actors and components as kind of first class dependencies.

728
00:34:18,957 --> 00:34:24,879
So they weren't really unit tests in a strict, strictest sense because they had, you know, some extra dependencies on them,

729
00:34:24,919 --> 00:34:26,760
but engineers could kind of treat them that way.

730
00:34:28,815 --> 00:34:30,415
So as an example of an actor test,

731
00:34:31,115 --> 00:34:33,836
here's a typical game scenario we had during development.

732
00:34:35,076 --> 00:34:37,357
So in Sea of Thieves, we have a variety of different skeleton

733
00:34:37,417 --> 00:34:37,717
types.

734
00:34:38,437 --> 00:34:39,978
One of those is the shadow skeleton.

735
00:34:40,338 --> 00:34:43,439
So at nighttime, the shadow skeleton

736
00:34:43,799 --> 00:34:46,180
becomes all ghost-like, and he's virtually invulnerable.

737
00:34:48,039 --> 00:34:51,540
But when the time of day changes, then the skeleton changes its state.

738
00:34:52,340 --> 00:34:55,561
It becomes more like a normal skeleton, and it can be attacked again.

739
00:34:56,002 --> 00:35:00,303
So we want to make a test that checks that when the time of day changes,

740
00:35:00,483 --> 00:35:04,304
the shadow skeleton changes from its dark to its light state.

741
00:35:05,164 --> 00:35:06,745
So we could have done this as an integration test,

742
00:35:07,705 --> 00:35:10,566
but actually doing it as an actor test is a lot more efficient, as I'll show you.

743
00:35:12,892 --> 00:35:14,693
So this is the actor test that checks that feature.

744
00:35:15,254 --> 00:35:17,115
And as you can see, it looks a lot like a unit test.

745
00:35:17,855 --> 00:35:19,997
And behind the scenes, there's a little bit more

746
00:35:20,057 --> 00:35:22,198
kind of going on in terms of setup.

747
00:35:22,238 --> 00:35:24,019
There's a minimal world that's been created

748
00:35:24,440 --> 00:35:25,981
where the actors can live in.

749
00:35:27,181 --> 00:35:29,083
But for the engineer who kind of creates a test,

750
00:35:29,163 --> 00:35:31,284
they can kind of treat it like a unit test.

751
00:35:33,145 --> 00:35:35,687
So like all the other test examples,

752
00:35:35,747 --> 00:35:37,448
this kind of splits down into three phases.

753
00:35:37,848 --> 00:35:39,689
So I'll go through what's happening in this test.

754
00:35:40,857 --> 00:35:42,939
So first of all, in the setup phase,

755
00:35:42,979 --> 00:35:44,620
we create the shadow skeleton.

756
00:35:45,560 --> 00:35:47,241
We set its current state to dark.

757
00:35:48,342 --> 00:35:49,443
Then when we run the operation,

758
00:35:49,483 --> 00:35:52,144
we set the game world time to midday.

759
00:35:53,785 --> 00:35:55,466
And then finally, we check the results

760
00:35:55,486 --> 00:35:57,968
to check that the state of the shadow skeleton

761
00:35:58,008 --> 00:35:59,449
has changed to light as we expect.

762
00:36:00,189 --> 00:36:01,570
So note this line here,

763
00:36:02,171 --> 00:36:05,133
where we're ticking the shadow skeleton manually.

764
00:36:05,273 --> 00:36:06,093
So we have to do this

765
00:36:06,694 --> 00:36:08,935
because that's kind of where it polls the...

766
00:36:09,595 --> 00:36:13,621
the world time and checks that the, you know, whether it needs to change state or not.

767
00:36:13,961 --> 00:36:19,109
Now obviously in the real game you would never just call tick explicitly, split it explicitly

768
00:36:19,169 --> 00:36:25,317
like this. You would expect the Unreal Engine to, you know, run it in its own engine loop.

769
00:36:26,058 --> 00:36:28,079
But again, if we did it like that,

770
00:36:28,479 --> 00:36:30,540
then we'd have to use an integration test.

771
00:36:31,061 --> 00:36:34,863
So doing it like this has a disadvantage

772
00:36:34,903 --> 00:36:38,024
in that it's not using it in its true way.

773
00:36:38,044 --> 00:36:41,887
Yeah, it's outside of its normal environment.

774
00:36:42,727 --> 00:36:44,948
But the major benefit we get is this test

775
00:36:45,008 --> 00:36:47,390
runs a lot, lot quicker than the integration test.

776
00:36:48,979 --> 00:36:50,400
So now we had actor tests.

777
00:36:50,880 --> 00:36:54,443
We weren't going to completely throw away integration tests.

778
00:36:54,784 --> 00:36:56,425
They still gave us useful test coverage

779
00:36:56,465 --> 00:37:01,089
that the actor test didn't, such as checking the asset setup

780
00:37:01,229 --> 00:37:05,733
and checking the integration with the Unreal Engine.

781
00:37:06,334 --> 00:37:07,575
But we didn't want to use too many,

782
00:37:07,635 --> 00:37:08,936
because they're very expensive.

783
00:37:09,697 --> 00:37:12,799
So we tried to settle on a good kind of rule of thumb

784
00:37:12,859 --> 00:37:15,141
of when you would use a integration test

785
00:37:15,161 --> 00:37:16,402
and when you would use an actor test.

786
00:37:17,083 --> 00:37:19,605
And what we came up with was if you took a feature,

787
00:37:21,307 --> 00:37:23,489
you could then create an integration test

788
00:37:23,529 --> 00:37:25,610
for the golden path of the feature.

789
00:37:26,211 --> 00:37:29,233
So a golden path is like the successful run of the feature.

790
00:37:29,674 --> 00:37:32,156
And then we'd use actor tests for the edge cases

791
00:37:32,216 --> 00:37:33,037
or the failure cases.

792
00:37:33,697 --> 00:37:36,779
And we found this kind of gave us a good mix in terms

793
00:37:36,819 --> 00:37:39,240
of a balance of running the test, the time that

794
00:37:39,280 --> 00:37:41,380
took the test to run, and giving us

795
00:37:41,521 --> 00:37:45,062
kind of a reasonable test coverage that we could use.

796
00:37:46,242 --> 00:37:48,303
So as an example, there's a feature in the game where

797
00:37:48,363 --> 00:37:51,165
players can give items to other players.

798
00:37:52,394 --> 00:37:55,096
And if we look at where the test breakdown

799
00:37:55,176 --> 00:37:57,217
for the coverage for this feature.

800
00:37:57,698 --> 00:38:02,181
So the actor test cover times when giving the item

801
00:38:02,201 --> 00:38:03,402
wasn't successful, for example,

802
00:38:03,422 --> 00:38:05,343
because the player didn't have an item,

803
00:38:05,464 --> 00:38:08,306
or they can't give every kind of item.

804
00:38:09,106 --> 00:38:10,848
Whereas the integration test covered

805
00:38:11,088 --> 00:38:13,930
the full successful passing of an item.

806
00:38:15,294 --> 00:38:18,336
So in terms of how it breaks down numerically,

807
00:38:18,576 --> 00:38:20,917
is we found that the ratio of actor tests

808
00:38:21,037 --> 00:38:23,478
to integration tests was about 12 to one,

809
00:38:23,599 --> 00:38:26,660
which gave us kind of a coverage that we were happy with.

810
00:38:29,542 --> 00:38:32,163
So by using integration tests for only the golden path,

811
00:38:32,603 --> 00:38:34,144
we reduced their number by a large amount,

812
00:38:34,184 --> 00:38:36,305
but we still wanted to speed up the ones we had

813
00:38:36,505 --> 00:38:37,826
as much as possible.

814
00:38:40,286 --> 00:38:43,268
So one way we found to do that was to merge

815
00:38:43,468 --> 00:38:45,430
multiple related features.

816
00:38:46,151 --> 00:38:47,712
So this broke a general rule of testing

817
00:38:47,752 --> 00:38:50,214
that you should only really test one thing per test.

818
00:38:51,455 --> 00:38:53,376
But again, because of the speed that we were getting,

819
00:38:53,396 --> 00:38:54,997
again, we were happy to break this rule.

820
00:38:56,078 --> 00:38:58,980
So as an example, so the skeletons in the game

821
00:38:59,141 --> 00:39:00,582
have three different attacks.

822
00:39:01,763 --> 00:39:04,064
So we wanted to have a test that checked

823
00:39:04,124 --> 00:39:06,046
each of those worked and damaged the player correctly.

824
00:39:07,163 --> 00:39:10,244
So, we could have had a test per attack,

825
00:39:10,625 --> 00:39:12,405
and that's originally what I started with,

826
00:39:12,905 --> 00:39:17,347
but I realized it was just as easy to have one test

827
00:39:17,507 --> 00:39:19,788
that ran all the free attacks in sequence.

828
00:39:20,088 --> 00:39:23,289
And again, this meant that the initialization of the world,

829
00:39:23,729 --> 00:39:25,329
loading the skeleton and all its animations,

830
00:39:25,349 --> 00:39:26,990
that kind of thing, we only had to do that once,

831
00:39:27,090 --> 00:39:28,190
so we saved a lot of time.

832
00:39:30,782 --> 00:39:34,045
So, combining the tests only really worked

833
00:39:34,125 --> 00:39:36,507
if there were related features.

834
00:39:37,408 --> 00:39:40,591
But there was one aspect, one thing in most integration tests

835
00:39:40,611 --> 00:39:42,573
that was common, and that was the player.

836
00:39:42,713 --> 00:39:44,655
And it turned out the player was one of the most expensive

837
00:39:44,695 --> 00:39:46,196
objects when we used it.

838
00:39:47,017 --> 00:39:51,838
Again, it's quite a complicated object with a lot of animations attached to it and also

839
00:39:52,518 --> 00:39:56,339
initializing it kind of in a network scene for the network version of the integration

840
00:39:56,359 --> 00:39:57,680
test took a long time.

841
00:39:58,240 --> 00:40:02,081
So in fact, in a lot of cases, just initializing the player took longer than running the actual

842
00:40:02,121 --> 00:40:02,361
test.

843
00:40:03,321 --> 00:40:08,903
So one thing we used that was a, we took advantage of a feature in Unreal where you could world

844
00:40:08,923 --> 00:40:09,203
travel.

845
00:40:09,383 --> 00:40:13,364
So essentially you keep the same player object but move him from map to map.

846
00:40:14,492 --> 00:40:20,436
So we use this to transition the player between integration maps

847
00:40:20,737 --> 00:40:23,158
and meant that we didn't have to keep loading the player.

848
00:40:23,519 --> 00:40:27,802
So in this example, the player starts off in an integration test map

849
00:40:28,442 --> 00:40:30,664
a lot like the one we did before with the ship's wheel.

850
00:40:31,385 --> 00:40:34,687
We then unload that map but keep the player and then load him in another

851
00:40:34,968 --> 00:40:37,670
integration test map where he's interacting with the capstan.

852
00:40:38,735 --> 00:40:40,077
So again, we had to be careful here,

853
00:40:40,097 --> 00:40:42,299
and we had some bugs to do with state leaking

854
00:40:42,359 --> 00:40:44,262
from state to state, some test to test.

855
00:40:45,283 --> 00:40:47,706
But again, we were kind of happy to fix those bugs

856
00:40:47,806 --> 00:40:50,530
and sort that out because of the speed up game

857
00:40:50,570 --> 00:40:52,633
we were getting in terms of running the tests.

858
00:40:54,555 --> 00:40:56,776
The other issue we had, which I mentioned,

859
00:40:56,796 --> 00:40:57,897
were intermittent test failures,

860
00:40:57,977 --> 00:41:01,339
which are when tests succeed almost all the time,

861
00:41:01,379 --> 00:41:03,401
but very occasionally fail.

862
00:41:03,861 --> 00:41:06,383
Some level of test fakiness is kind of inevitable

863
00:41:06,403 --> 00:41:09,044
when you're running such a large amount of tests continuously.

864
00:41:09,485 --> 00:41:11,046
It seems to happen to almost everyone,

865
00:41:11,106 --> 00:41:12,987
which I'm quite amused by this quote

866
00:41:13,067 --> 00:41:14,828
on the Google testing blog.

867
00:41:15,709 --> 00:41:17,110
It happens to the best of people.

868
00:41:18,931 --> 00:41:22,574
So we looked into the reasons for our intermittent test failures, and they were kind of a mix of

869
00:41:23,515 --> 00:41:30,120
network issues, infrastructure issues, and sometimes a state that was leaking from test to test.

870
00:41:30,560 --> 00:41:35,924
So we would investigate and fix these causes, but we found that just stopping the team from

871
00:41:35,964 --> 00:41:40,808
checking in when we found one of these intermittent test failures was wasting a lot of time.

872
00:41:42,069 --> 00:41:42,670
Quite disruptive.

873
00:41:43,490 --> 00:41:45,332
So instead what happened was, when we,

874
00:41:46,193 --> 00:41:48,415
we changed the kind of the way the build system did things,

875
00:41:48,615 --> 00:41:50,156
and when it found a test failure,

876
00:41:50,656 --> 00:41:52,118
it would immediately run the test again.

877
00:41:52,458 --> 00:41:54,440
If the test failed for the second time,

878
00:41:54,480 --> 00:41:55,661
we would actually turn the build red.

879
00:41:56,341 --> 00:41:58,463
If it succeeded on that second time,

880
00:41:58,763 --> 00:42:00,164
we would just keep it green instead.

881
00:42:01,888 --> 00:42:03,949
Now, just because we did that didn't mean we completely

882
00:42:04,370 --> 00:42:06,010
ignored those intermittent test issues.

883
00:42:06,111 --> 00:42:08,612
We just wanted to concentrate our efforts a bit more.

884
00:42:09,112 --> 00:42:11,293
So what we did is we kept a record of those intermittent

885
00:42:11,313 --> 00:42:11,953
test failures.

886
00:42:11,973 --> 00:42:16,756
And every week or so, we drew up a list of the worst

887
00:42:16,936 --> 00:42:17,776
offending tests.

888
00:42:18,256 --> 00:42:20,057
And then we asked engineers to just look at those.

889
00:42:20,077 --> 00:42:25,000
Because those tests may have genuine issues with the actual

890
00:42:25,040 --> 00:42:27,341
test or the actual feature of the test, which meant that

891
00:42:28,041 --> 00:42:28,962
they're worth investigating.

892
00:42:31,620 --> 00:42:33,821
And the final thing we did to kind of improve our testing

893
00:42:34,642 --> 00:42:36,403
was to handle consistently failing tests.

894
00:42:36,743 --> 00:42:38,644
So these are tests that are generally badly written

895
00:42:39,024 --> 00:42:40,465
and just kind of just keep failing.

896
00:42:41,286 --> 00:42:43,267
So tests like this, they just can't be trusted

897
00:42:43,287 --> 00:42:44,928
because they're just off,

898
00:42:44,968 --> 00:42:47,089
they're worse often than having no test at all

899
00:42:48,050 --> 00:42:49,751
due to the time they waste on the build system

900
00:42:49,891 --> 00:42:51,632
and the false information they're giving to the team.

901
00:42:53,526 --> 00:42:56,086
So what we did is if a test was failing regularly,

902
00:42:56,507 --> 00:42:58,067
we moved it to a quarantine area,

903
00:42:58,827 --> 00:43:00,988
where we'd keep running the test,

904
00:43:01,788 --> 00:43:03,968
but we wouldn't turn the build red anymore if it failed.

905
00:43:04,908 --> 00:43:05,689
And at the same time,

906
00:43:05,729 --> 00:43:07,869
we told the engineer responsible for the test

907
00:43:07,889 --> 00:43:09,729
that your test has been moved into quarantine,

908
00:43:09,809 --> 00:43:10,870
could you please sort it out?

909
00:43:11,650 --> 00:43:13,230
And then we gave them a few weeks to do that,

910
00:43:13,310 --> 00:43:14,810
and if they didn't get around to it,

911
00:43:14,870 --> 00:43:16,811
then we just bin the test.

912
00:43:17,431 --> 00:43:18,992
So this seems a bit harsh, but again,

913
00:43:19,032 --> 00:43:21,492
we're thinking was that if an engineer can't prioritize

914
00:43:21,512 --> 00:43:22,813
the time to fix that test,

915
00:43:23,313 --> 00:43:25,854
it's probably not giving us a worthwhile test coverage

916
00:43:25,874 --> 00:43:28,974
and it can be recovered later anyway, so check it a minute.

917
00:43:30,815 --> 00:43:32,576
Okay, so for the final part of this presentation,

918
00:43:32,636 --> 00:43:34,376
I'd like to talk about the benefits we got

919
00:43:34,476 --> 00:43:36,057
from doing all this automated testing.

920
00:43:38,025 --> 00:43:39,307
So here's the breakdown of the tests

921
00:43:39,387 --> 00:43:40,868
that we currently have in our code base.

922
00:43:41,609 --> 00:43:44,831
So as you can see, 70% of our tests are actor tests.

923
00:43:44,911 --> 00:43:47,454
So it definitely felt like we were right

924
00:43:47,494 --> 00:43:49,896
when we thought that this was kind of the sweet spot

925
00:43:49,916 --> 00:43:53,979
in terms of the code level in where to run those tests

926
00:43:54,019 --> 00:43:55,741
for gameplay, because we were using so many.

927
00:43:57,091 --> 00:43:59,072
We only have 5% integration tests there.

928
00:43:59,573 --> 00:44:02,616
So again, trying not to overwhelm our build system

929
00:44:02,636 --> 00:44:03,757
with so many integration tests.

930
00:44:04,337 --> 00:44:07,020
But they did give us vital kind of high level feedback

931
00:44:07,100 --> 00:44:09,882
if something was broken in a feature in the game.

932
00:44:10,683 --> 00:44:12,224
About half of those were network tests.

933
00:44:14,286 --> 00:44:17,089
And screenshot performance and boot flow tests,

934
00:44:17,809 --> 00:44:19,931
we only have a very small number of those.

935
00:44:20,732 --> 00:44:22,173
Those were by far our slowest tests,

936
00:44:22,273 --> 00:44:23,554
so we only use them sparingly.

937
00:44:25,255 --> 00:44:28,016
So if you add all those up, we have about 23,000 tests,

938
00:44:28,096 --> 00:44:28,797
which is quite a lot.

939
00:44:29,477 --> 00:44:31,878
But I didn't add asset audits because, again,

940
00:44:32,358 --> 00:44:33,778
they're kind of not quite tests,

941
00:44:33,898 --> 00:44:35,459
but if we add those as well,

942
00:44:35,499 --> 00:44:36,659
I didn't want to skew the results too much,

943
00:44:36,699 --> 00:44:37,659
so I didn't add those in there.

944
00:44:38,620 --> 00:44:39,640
But if we add those as well,

945
00:44:40,020 --> 00:44:41,641
then we end up with over 100,000 tests,

946
00:44:41,701 --> 00:44:42,621
which is quite a lot.

947
00:44:43,962 --> 00:44:47,723
So if we hadn't made all those efficiency savings

948
00:44:47,763 --> 00:44:48,563
that I've been talking about,

949
00:44:48,583 --> 00:44:50,964
there's just no way we could have run those tests

950
00:44:50,984 --> 00:44:52,524
in a reasonable way on our build system.

951
00:44:54,975 --> 00:44:58,238
Cool, so with all that testing we had,

952
00:44:59,099 --> 00:45:00,560
we were seeing a lot of benefits

953
00:45:00,600 --> 00:45:01,921
in terms of build stability

954
00:45:02,261 --> 00:45:04,043
and that extra confidence that it gave us.

955
00:45:04,143 --> 00:45:07,926
So I'll go through what those things were.

956
00:45:09,808 --> 00:45:11,509
So the first one we had was the reduced time

957
00:45:11,549 --> 00:45:12,670
it took to verify the build.

958
00:45:13,290 --> 00:45:15,132
So on Connect Support's arrivals, as I mentioned,

959
00:45:15,152 --> 00:45:16,713
it took about two weeks to verify build

960
00:45:16,753 --> 00:45:18,655
before we sent it out as an update to players.

961
00:45:19,640 --> 00:45:23,021
Whereas on Sea of Thieves it took about a day and a half now, we were confident enough.

962
00:45:23,201 --> 00:45:27,402
So this was really powerful, it meant that we could very quickly turn around a hotfix

963
00:45:28,102 --> 00:45:31,743
if we needed to, just from the current version of the bill.

964
00:45:34,524 --> 00:45:37,684
The other benefit we got is we drastically reduced our manual testing team.

965
00:45:38,825 --> 00:45:44,266
So we went from 50 members that we had on Connect Sports Rivals at the time of release

966
00:45:44,386 --> 00:45:46,686
to 17 which at the time of Sea of Thieves.

967
00:45:48,669 --> 00:45:53,812
So what the numbers don't show is kind of the way that we could actually use the smaller number of testers we had a lot more

968
00:45:53,832 --> 00:45:58,534
Productively again because of all the repetitive checks were being done by automated testing

969
00:45:59,614 --> 00:46:04,437
the the QA team could work more closely with the rest of the development team and actually kind of

970
00:46:04,917 --> 00:46:08,178
Feedback and kind of what the player experience is like of playing the current bill

971
00:46:10,663 --> 00:46:13,546
So the third benefit we had was keeping our bug count very low.

972
00:46:13,726 --> 00:46:16,810
So on Sea of Thieves, our max bug count over production

973
00:46:17,630 --> 00:46:21,354
was about 214, whereas on Banjo-Kazooie-Nuts and Bolts,

974
00:46:22,255 --> 00:46:25,559
yeah, quite an older project, but still it's a good comparison.

975
00:46:26,660 --> 00:46:27,720
We went to about 3,000.

976
00:46:28,601 --> 00:46:31,502
And you can see from the bug trend graph

977
00:46:31,882 --> 00:46:32,743
how different they were.

978
00:46:33,163 --> 00:46:35,884
So on Sea of Thieves, because of all the automated testing

979
00:46:35,904 --> 00:46:39,526
we had, a lot of issues didn't really make it as far as bugs,

980
00:46:39,606 --> 00:46:42,948
because they were caught by automated testing earlier on

981
00:46:43,028 --> 00:46:44,088
and never made it into the build.

982
00:46:44,808 --> 00:46:47,750
We also had a process where we asked developers

983
00:46:47,850 --> 00:46:51,231
to look at fixing their bugs before they did feature work,

984
00:46:51,512 --> 00:46:53,573
just to keep the build as stable and clean as possible.

985
00:46:54,501 --> 00:46:56,022
Rails and Banjo-Kazooie-Nuts-and-Bolts.

986
00:46:56,183 --> 00:46:58,705
As you can see, we kind of let long-running issues

987
00:46:58,825 --> 00:47:01,087
in the build just build up, build up, build up until,

988
00:47:01,808 --> 00:47:03,489
oh no, it's a few months before release,

989
00:47:03,549 --> 00:47:04,690
and we had to fix all the bugs.

990
00:47:04,790 --> 00:47:07,453
So yeah, we spent a lot of time doing that.

991
00:47:08,494 --> 00:47:10,536
And that kind of brings me to my third one,

992
00:47:10,656 --> 00:47:12,598
is reducing crunch.

993
00:47:12,698 --> 00:47:14,940
So this was really important to us at Rare,

994
00:47:14,960 --> 00:47:16,381
and we hoped that automated testing

995
00:47:16,401 --> 00:47:18,643
would help us reduce crunch quite a bit.

996
00:47:19,284 --> 00:47:21,685
I don't have concrete stats for this, unfortunately.

997
00:47:21,705 --> 00:47:24,386
But anecdotally, developers at the studio

998
00:47:24,426 --> 00:47:26,287
definitely found that they work less over time.

999
00:47:26,728 --> 00:47:29,569
And I think the bug trend graphs kind of show why this is.

1000
00:47:30,010 --> 00:47:32,911
So on CFEs, because we had automated testing,

1001
00:47:32,991 --> 00:47:34,352
highlighting issues all the time,

1002
00:47:34,732 --> 00:47:37,334
there weren't those kind of unexpected moments

1003
00:47:37,454 --> 00:47:42,176
where you have issues crop up that you didn't expect

1004
00:47:42,256 --> 00:47:43,357
or have been around a long time.

1005
00:47:44,177 --> 00:47:46,639
And developers could maintain more regular working hours

1006
00:47:46,679 --> 00:47:47,119
because of that.

1007
00:47:48,090 --> 00:47:49,711
whereas on Bajo Kazoo, nuts and bolts,

1008
00:47:51,031 --> 00:47:52,793
when it got to that point, before release,

1009
00:47:52,893 --> 00:47:53,833
and we had all those bugs,

1010
00:47:54,434 --> 00:47:57,816
there was definitely a lot of crunching going on.

1011
00:47:58,536 --> 00:48:01,078
So, just to finish up, I'd like to go through

1012
00:48:01,098 --> 00:48:02,679
a few bonus lessons we learned

1013
00:48:02,779 --> 00:48:04,300
on our automated testing adventure.

1014
00:48:06,611 --> 00:48:09,012
So, first one is that team buy-in is really important.

1015
00:48:09,312 --> 00:48:12,094
So, the most common reason not to use automated testing

1016
00:48:12,374 --> 00:48:16,096
is obviously the time it takes to do the automated testing.

1017
00:48:16,136 --> 00:48:17,636
You know, there's no time to do it.

1018
00:48:17,696 --> 00:48:19,137
We've got to finish the game.

1019
00:48:20,178 --> 00:48:21,939
So, my counter argument would be to that,

1020
00:48:21,959 --> 00:48:23,579
that you might actually spend more time,

1021
00:48:23,599 --> 00:48:27,021
you might actually spend the same amount of time

1022
00:48:27,061 --> 00:48:28,782
or less time if you use automated tests

1023
00:48:28,842 --> 00:48:30,843
because the developers won't be spending

1024
00:48:30,863 --> 00:48:32,544
as much time fixing reoccurring bugs.

1025
00:48:33,564 --> 00:48:37,468
So we were lucky on the project that everyone on the team,

1026
00:48:37,508 --> 00:48:39,470
in fact, well, everyone at Rare kind of bought into

1027
00:48:39,490 --> 00:48:40,992
what we wanted to do with automated testing

1028
00:48:41,192 --> 00:48:42,673
and went along with us,

1029
00:48:43,354 --> 00:48:45,476
including producers and project managers.

1030
00:48:45,856 --> 00:48:46,777
Again, if we didn't have that,

1031
00:48:46,797 --> 00:48:48,619
if we didn't have that support from that highest level,

1032
00:48:49,540 --> 00:48:50,661
we really probably wouldn't have been able

1033
00:48:50,681 --> 00:48:51,281
to achieve what we did.

1034
00:48:54,064 --> 00:48:58,307
So the second one was that you should really allow time

1035
00:48:58,407 --> 00:48:59,768
if you're doing automated testing

1036
00:48:59,848 --> 00:49:01,729
to kind of build up that knowledge in the team.

1037
00:49:02,230 --> 00:49:04,011
Again, a lot of us were unfamiliar with testing

1038
00:49:04,051 --> 00:49:04,932
when we started this.

1039
00:49:05,392 --> 00:49:06,313
There's a lot you need to think about

1040
00:49:06,333 --> 00:49:07,594
in terms of what makes a good test

1041
00:49:08,234 --> 00:49:11,637
and what you have to do to make your code testable,

1042
00:49:12,257 --> 00:49:13,918
which is quite an important one as well

1043
00:49:13,998 --> 00:49:15,820
because it's very easy to make code,

1044
00:49:15,860 --> 00:49:18,181
which is just so difficult to test.

1045
00:49:19,138 --> 00:49:21,599
The bonus is that if you make code more testable,

1046
00:49:21,639 --> 00:49:23,900
it actually makes it cleaner and better as well.

1047
00:49:24,960 --> 00:49:27,461
And the second part of this is that you should make sure

1048
00:49:27,481 --> 00:49:30,381
that you spend time making sure your infrastructure

1049
00:49:30,621 --> 00:49:32,702
is robust and stable because you're gonna be

1050
00:49:32,722 --> 00:49:33,462
relying on it a lot.

1051
00:49:34,943 --> 00:49:37,723
So if this all seems a bit intimidating to get started,

1052
00:49:37,763 --> 00:49:40,304
then I'd suggest not doing what we did

1053
00:49:40,544 --> 00:49:43,205
and actually just starting testing on a small part

1054
00:49:43,245 --> 00:49:44,865
of your game or your project to begin with,

1055
00:49:45,665 --> 00:49:47,866
just to build it up rather than go all in.

1056
00:49:50,724 --> 00:49:54,968
The third lesson we learned was that iterative development, testing, they don't really mix.

1057
00:49:55,469 --> 00:50:00,654
So if you're still kind of working on your game and on the actual gameplay and checking

1058
00:50:00,674 --> 00:50:04,757
to find the fun, then it's probably not a good idea to do testing at the same time because

1059
00:50:04,777 --> 00:50:06,920
you'll be constantly having to rework your tests.

1060
00:50:08,250 --> 00:50:11,252
So, on Sea of Thieves, when we were working on new features,

1061
00:50:11,793 --> 00:50:13,454
we actually had a prototype branch that we used

1062
00:50:13,474 --> 00:50:16,477
that didn't need testing so that the developers could work

1063
00:50:16,837 --> 00:50:18,198
quickly and not have to worry about tests

1064
00:50:18,238 --> 00:50:19,419
when they're working on those features.

1065
00:50:20,520 --> 00:50:22,421
But even when they worked on the production branch,

1066
00:50:22,581 --> 00:50:25,484
we didn't really do the kind of the test-driven development,

1067
00:50:25,564 --> 00:50:27,465
test-first style approach because...

1068
00:50:28,946 --> 00:50:32,428
again, we would probably end up having to rework those tests a bit too often.

1069
00:50:32,508 --> 00:50:38,571
So what the process was more, was that we, an engineer or a developer, would make a change,

1070
00:50:38,691 --> 00:50:43,414
get it working locally, and then build the tests to kind of pin down what they'd done

1071
00:50:43,474 --> 00:50:44,895
to make sure it doesn't break in the future.

1072
00:50:47,224 --> 00:50:50,427
And then the final one is that pragmatism is important.

1073
00:50:51,488 --> 00:50:53,950
So we found we had to constantly, as you saw,

1074
00:50:53,970 --> 00:50:56,492
we had to constantly change how we were doing our testing

1075
00:50:56,512 --> 00:50:57,613
as things weren't working for us.

1076
00:50:57,893 --> 00:51:01,036
So we often weren't able to do the textbook way of doing

1077
00:51:01,076 --> 00:51:01,656
things because.

1078
00:51:02,517 --> 00:51:03,457
it wasn't working for us.

1079
00:51:03,517 --> 00:51:05,938
So my suggestion, my advice is just

1080
00:51:06,038 --> 00:51:08,458
don't be afraid to change what you're doing

1081
00:51:08,598 --> 00:51:10,139
and do what works for you.

1082
00:51:10,159 --> 00:51:13,640
Remember that testing has a cost.

1083
00:51:13,740 --> 00:51:16,341
So you can't possibly test absolutely everything.

1084
00:51:16,521 --> 00:51:19,581
So if something is trivial, maybe don't test it.

1085
00:51:19,661 --> 00:51:20,522
If something is very,

1086
00:51:22,762 --> 00:51:27,566
If a test you're going to be creating is going to be very complex and hard to maintain,

1087
00:51:27,626 --> 00:51:29,768
maybe don't do it.

1088
00:51:30,928 --> 00:51:36,192
And then on the flip side, if you're writing some code that looks quite like a complicated logic or something,

1089
00:51:36,212 --> 00:51:38,074
then definitely concentrate your testing there.

1090
00:51:38,874 --> 00:51:42,776
So, you know, just remember that you're not going to be able to have perfect test coverage,

1091
00:51:42,876 --> 00:51:45,698
so it's just not really worth trying to do.

1092
00:51:46,818 --> 00:51:50,360
And just to show that we don't have perfect test coverage, here's a video of one of my

1093
00:51:50,440 --> 00:51:54,062
favorite bugs, sorry, one of my favorite videos from bugs in our game.

1094
00:51:54,643 --> 00:51:56,163
I just love the expression on this guy's face.

1095
00:51:56,183 --> 00:51:56,304
Look.

1096
00:51:56,324 --> 00:51:56,424
Yeah.

1097
00:51:56,444 --> 00:51:56,524
Yeah.

1098
00:51:56,544 --> 00:51:57,884
Yeah.

1099
00:51:57,904 --> 00:51:58,004
Yeah.

1100
00:51:58,365 --> 00:51:58,445
Yeah.

1101
00:51:58,465 --> 00:51:58,565
Yeah.

1102
00:51:58,585 --> 00:51:58,805
Yeah.

1103
00:51:58,825 --> 00:51:58,905
Yeah.

1104
00:51:58,925 --> 00:52:01,386
Yeah.

1105
00:52:01,406 --> 00:52:01,606
Yeah.

1106
00:52:01,767 --> 00:52:01,867
Yeah.

1107
00:52:06,143 --> 00:52:07,684
It goes all the way over the horizon as well.

1108
00:52:08,504 --> 00:52:10,664
So what can I say, testing is a journey.

1109
00:52:10,985 --> 00:52:12,625
We're constantly improving, so yeah.

1110
00:52:13,705 --> 00:52:14,726
Cool, so that's the end of my talk.

1111
00:52:15,186 --> 00:52:18,347
What I've talked about here is a big team effort

1112
00:52:18,387 --> 00:52:19,427
from virtually everyone at Rare,

1113
00:52:19,467 --> 00:52:20,488
so I'd just like to thank everyone

1114
00:52:20,508 --> 00:52:23,228
who contributed to our test process in Sea of Thieves.

1115
00:52:24,249 --> 00:52:26,790
And Rarer Hiring, particularly for software engineers,

1116
00:52:26,890 --> 00:52:30,031
so if you're interested, check out the website link

1117
00:52:30,431 --> 00:52:32,811
on the page or just come and find me later.

1118
00:52:34,210 --> 00:52:34,731
And that's it.

1119
00:52:35,171 --> 00:52:36,012
Does anyone have any questions?

1120
00:52:47,339 --> 00:52:47,839
I have a question.

1121
00:52:47,939 --> 00:52:48,119
Thanks.

1122
00:52:48,299 --> 00:52:48,779
Great talk.

1123
00:52:48,899 --> 00:52:49,240
Thank you.

1124
00:52:49,700 --> 00:52:51,641
I have a question about the integration testing.

1125
00:52:51,661 --> 00:52:53,722
You didn't mention mocking at all.

1126
00:52:53,762 --> 00:52:56,084
Did you ever think about mocking away the server

1127
00:52:56,104 --> 00:52:57,185
if you did some client tests?

1128
00:52:57,285 --> 00:53:00,447
Or mocking some units away when you do some integration tests?

1129
00:53:00,647 --> 00:53:00,887
Yeah.

1130
00:53:02,602 --> 00:53:03,382
So we did a bit of that.

1131
00:53:03,422 --> 00:53:06,525
I guess because the actor test obviously didn't have network

1132
00:53:06,545 --> 00:53:09,228
communication, we would have done something similar.

1133
00:53:09,328 --> 00:53:09,868
Yes, we did.

1134
00:53:10,189 --> 00:53:14,853
So we often did things like we could fake replication.

1135
00:53:15,073 --> 00:53:17,235
So we had a way of doing that.

1136
00:53:17,855 --> 00:53:21,619
Replication is kind of the Unreal term for sending

1137
00:53:21,639 --> 00:53:22,119
something from.

1138
00:53:23,000 --> 00:53:23,800
server to client.

1139
00:53:23,900 --> 00:53:25,981
So yeah, we could fake that essentially to say,

1140
00:53:26,401 --> 00:53:27,562
this has been replicated now,

1141
00:53:28,042 --> 00:53:29,363
do the correct thing on the client

1142
00:53:29,403 --> 00:53:30,883
when you've picked that up, that kind of thing.

1143
00:53:31,263 --> 00:53:32,264
The integration tests again,

1144
00:53:32,304 --> 00:53:33,324
because there were so few of them,

1145
00:53:33,464 --> 00:53:33,965
they were kind of,

1146
00:53:34,865 --> 00:53:36,285
they wanted, we wanted kind of a more,

1147
00:53:36,326 --> 00:53:37,506
kind of a broader view,

1148
00:53:37,546 --> 00:53:39,287
a kind of more high level view.

1149
00:53:39,307 --> 00:53:41,027
So that's why we kind of did actual

1150
00:53:41,448 --> 00:53:43,008
network communication in those.

1151
00:53:43,929 --> 00:53:45,390
Okay, but you always kept the units,

1152
00:53:45,630 --> 00:53:47,391
like you always retested the units with the tests

1153
00:53:47,531 --> 00:53:48,532
also in the actual test, right?

1154
00:53:48,652 --> 00:53:49,933
I mean, yeah.

1155
00:53:49,993 --> 00:53:51,054
Sorry, we always checked.

1156
00:53:51,074 --> 00:53:52,474
Yeah, you always kept the units

1157
00:53:52,515 --> 00:53:53,655
when you tested the actual tests,

1158
00:53:54,096 --> 00:53:56,457
so you never like, so you retested the units as well

1159
00:53:56,557 --> 00:53:58,759
in the actual tests always, right, I guess?

1160
00:53:59,139 --> 00:54:00,720
I'm not sure what you mean, sorry.

1161
00:54:00,740 --> 00:54:03,702
So you're saying the, we checked the,

1162
00:54:03,722 --> 00:54:05,643
you mean unit tests or?

1163
00:54:05,883 --> 00:54:07,925
No, it's not such, I mean, I'm just thinking

1164
00:54:07,965 --> 00:54:10,106
if you sometimes mark away units you already tested,

1165
00:54:10,126 --> 00:54:11,527
you probably, you don't retest them and,

1166
00:54:11,887 --> 00:54:12,367
I mean, that's kind of.

1167
00:54:12,387 --> 00:54:13,388
Yes, that's a good point, yeah, yeah.

1168
00:54:13,548 --> 00:54:15,448
So I suppose you're right, there's a bit of retesting going,

1169
00:54:15,468 --> 00:54:18,309
but we, again, integration tests, I like that, right?

1170
00:54:18,349 --> 00:54:20,829
Like I showed that diagram where the integration tests

1171
00:54:20,869 --> 00:54:23,110
contain the unit tests, so in a way,

1172
00:54:23,130 --> 00:54:25,150
you are kind of repeating yourself a bit,

1173
00:54:25,210 --> 00:54:26,471
but the unit tests are very useful

1174
00:54:26,491 --> 00:54:28,771
because they give you that kind of very specific

1175
00:54:29,151 --> 00:54:31,072
point of failure that you could investigate.

1176
00:54:31,332 --> 00:54:33,332
Integration tests are quite high level

1177
00:54:33,372 --> 00:54:35,593
because they give you that kind of very broad sense

1178
00:54:35,633 --> 00:54:36,333
of something's wrong.

1179
00:54:37,053 --> 00:54:38,893
It takes a bit longer to investigate it,

1180
00:54:39,013 --> 00:54:41,394
but that's something you need to look at.

1181
00:54:42,114 --> 00:54:42,715
Okay, thanks.

1182
00:54:42,735 --> 00:54:44,976
Thank you.

1183
00:54:45,436 --> 00:54:48,318
Hi, so I was wondering for the pre-commit tests,

1184
00:54:48,718 --> 00:54:49,919
I found them very interesting,

1185
00:54:50,059 --> 00:54:52,740
but is there a way to sort of automate

1186
00:54:52,760 --> 00:54:54,621
which tests are picked up in that pre-commit?

1187
00:54:54,641 --> 00:54:56,643
So like analyzing what code was changed?

1188
00:54:56,743 --> 00:54:58,984
Yes, yeah, I left that out because I didn't have time

1189
00:54:59,064 --> 00:55:00,225
and it kind of didn't fit in, but yeah.

1190
00:55:00,645 --> 00:55:04,467
So how that works is every day when we're running the tests,

1191
00:55:05,388 --> 00:55:09,491
the tests kind of record what code they're touching

1192
00:55:09,511 --> 00:55:10,511
and what assets they're touching.

1193
00:55:11,092 --> 00:55:12,533
And we sort of build a map up of that.

1194
00:55:12,973 --> 00:55:14,094
And then when you do a pre-commit,

1195
00:55:14,134 --> 00:55:15,495
you kind of do a reverse lookup of that.

1196
00:55:15,615 --> 00:55:17,776
And then you kind of find out which tests

1197
00:55:18,397 --> 00:55:20,599
are kind of, were affected by that code change.

1198
00:55:21,139 --> 00:55:22,560
And then that builds your list of tests

1199
00:55:22,620 --> 00:55:23,861
that we think are related.

1200
00:55:24,201 --> 00:55:25,182
Again, it's not perfect,

1201
00:55:25,262 --> 00:55:26,703
but it's kind of good enough for what we needed,

1202
00:55:26,763 --> 00:55:28,284
especially for a pre-commit, because,

1203
00:55:30,546 --> 00:55:31,947
yeah, again, we wanted, that was,

1204
00:55:32,967 --> 00:55:34,808
it was very important to us to keep the pre-commit

1205
00:55:34,968 --> 00:55:36,028
as fast as possible.

1206
00:55:36,148 --> 00:55:38,349
And it's been a kind of ongoing challenge

1207
00:55:38,649 --> 00:55:40,269
as we keep adding more and more testing.

1208
00:55:40,289 --> 00:55:43,070
You know, we can only, we paralyze things

1209
00:55:43,110 --> 00:55:45,170
as much as we can, but there's kind of limits to that.

1210
00:55:45,270 --> 00:55:48,891
So, you know, that was kind of our latest way

1211
00:55:48,931 --> 00:55:52,052
of kind of making sure that we were speeding that up enough.

1212
00:55:53,352 --> 00:55:55,493
But it gave us good enough coverage

1213
00:55:55,573 --> 00:55:58,734
to be confident for a developer to submit their changes,

1214
00:55:59,334 --> 00:56:01,214
fairly sure that they're not gonna break things

1215
00:56:01,234 --> 00:56:01,815
for the rest of the team.

1216
00:56:02,497 --> 00:56:04,118
Cool, is there somewhere that I can read more

1217
00:56:04,158 --> 00:56:05,298
about automating that process?

1218
00:56:06,099 --> 00:56:08,720
I could probably put you in touch with someone

1219
00:56:08,921 --> 00:56:10,562
who can kind of tell you a bit more how that works

1220
00:56:10,602 --> 00:56:13,764
if you want, just find me on later

1221
00:56:13,884 --> 00:56:15,245
or on Twitter or something like that.

1222
00:56:15,625 --> 00:56:16,145
Awesome, thank you.

1223
00:56:16,185 --> 00:56:17,846
And then one more small question is,

1224
00:56:17,886 --> 00:56:19,447
what do you think about testing,

1225
00:56:20,148 --> 00:56:22,229
developing with testing as first class concerns?

1226
00:56:22,309 --> 00:56:24,130
So instead of sort of bolting it on at the end,

1227
00:56:24,570 --> 00:56:26,572
sort of designing your units for testability

1228
00:56:26,592 --> 00:56:28,293
so that they're more robust and well-structured.

1229
00:56:29,334 --> 00:56:34,697
Yes, I briefly mentioned that, but you mean like when you're actually building the code up?

1230
00:56:35,178 --> 00:56:36,479
Right, yeah, after prototyping, of course.

1231
00:56:36,499 --> 00:56:41,462
Yeah, so we do, again, as I mentioned, we don't really do it in a strictest test-driven way.

1232
00:56:42,002 --> 00:56:46,164
We just found that for gameplay especially, it's just a bit too fluid, and often you had to...

1233
00:56:47,105 --> 00:56:50,126
you're using the Unreal engine, which is not tested.

1234
00:56:50,366 --> 00:56:52,047
So that's kind of one of the limitations

1235
00:56:52,067 --> 00:56:54,809
with what we're doing here is that Unreal engine,

1236
00:56:54,849 --> 00:56:56,749
we're kind of assuming it all works.

1237
00:56:57,270 --> 00:56:58,570
And yeah, it does for the most part, right?

1238
00:56:58,790 --> 00:56:59,831
But it's not tested.

1239
00:56:59,911 --> 00:57:03,853
So often, and it's not in a very kind of,

1240
00:57:04,533 --> 00:57:06,094
it's not been built in a way,

1241
00:57:06,114 --> 00:57:08,155
there's a lot of dependencies between everything.

1242
00:57:08,215 --> 00:57:09,275
It's an old-ish engine, right?

1243
00:57:09,335 --> 00:57:13,337
So, I'm dissing Unreal now, so I'm getting in trouble.

1244
00:57:13,457 --> 00:57:13,938
I don't know.

1245
00:57:15,659 --> 00:57:18,682
So yeah, so often you would find that when you're building gameplay up, you might find,

1246
00:57:18,702 --> 00:57:21,204
oh actually I have to bring this dependency in and things like this.

1247
00:57:21,244 --> 00:57:24,266
So it's often good to get things working.

1248
00:57:24,487 --> 00:57:29,511
We just found, again, being pragmatic, that it's good to get things working rather than

1249
00:57:29,531 --> 00:57:32,634
kind of build up your tests and then your unit.

1250
00:57:32,914 --> 00:57:34,055
But you still kind of...

1251
00:57:35,055 --> 00:57:37,457
it was still definitely, when you had tests in mind

1252
00:57:37,477 --> 00:57:38,877
that you would need to make later,

1253
00:57:39,898 --> 00:57:41,839
it still meant that you would really have to think

1254
00:57:41,879 --> 00:57:43,639
about those dependencies because you knew that

1255
00:57:43,920 --> 00:57:45,640
the more you added, the more you'd have to mock later

1256
00:57:45,680 --> 00:57:46,261
and things like this.

1257
00:57:46,301 --> 00:57:48,081
So it's like, do you really need that dependency

1258
00:57:48,161 --> 00:57:49,162
as another way of doing it?

1259
00:57:49,662 --> 00:57:52,023
I definitely found that our code base was a lot cleaner

1260
00:57:52,543 --> 00:57:55,445
in C thieves than it had been in C previous projects

1261
00:57:55,485 --> 00:57:55,925
because of that.

1262
00:57:56,765 --> 00:57:57,386
Awesome, thank you.

1263
00:57:57,486 --> 00:57:57,746
Thank you.

1264
00:57:58,837 --> 00:57:59,858
Thanks for the talk.

1265
00:58:00,138 --> 00:58:03,160
Were you tempted to parallelize the integration tests

1266
00:58:03,180 --> 00:58:05,741
when you first realized they were taking so long to run

1267
00:58:05,781 --> 00:58:06,902
and you switched to actor tests?

1268
00:58:06,922 --> 00:58:07,442
Did you find that?

1269
00:58:07,482 --> 00:58:08,183
So do you mean like?

1270
00:58:08,803 --> 00:58:10,364
Well, you were running them all on one build agent

1271
00:58:10,424 --> 00:58:10,904
after the build.

1272
00:58:11,004 --> 00:58:13,065
Oh, yeah, we do parallelize them, actually, yeah.

1273
00:58:13,425 --> 00:58:16,328
Yeah, so as I mentioned, we do groups of tests.

1274
00:58:16,408 --> 00:58:18,129
So yeah, one thing we did was,

1275
00:58:18,750 --> 00:58:20,051
but we could only go as wide as,

1276
00:58:21,232 --> 00:58:22,993
we just have a limited number of agents.

1277
00:58:23,294 --> 00:58:25,616
We only, we have all our agents on site

1278
00:58:25,636 --> 00:58:26,476
and things like this.

1279
00:58:26,957 --> 00:58:29,279
So, and especially because we're running them on Xbox

1280
00:58:29,319 --> 00:58:31,360
as well, running on Xbox dev kits,

1281
00:58:31,400 --> 00:58:33,242
and that's a little, it's not quite as easy

1282
00:58:33,782 --> 00:58:37,365
to kind of, again, it's a bit more work to set that up,

1283
00:58:37,405 --> 00:58:39,267
and there's limits to the amount of dev kits we had

1284
00:58:39,287 --> 00:58:39,807
and things like that.

1285
00:58:41,028 --> 00:58:46,591
Yes, we were paralyzing them, but even with that, with the amount of changes and pre-commits

1286
00:58:46,631 --> 00:58:51,754
people are sending through, it is just an ongoing battle in terms of keeping that workable.

1287
00:58:54,527 --> 00:58:55,207
Hi.

1288
00:58:55,707 --> 00:58:57,968
I was curious, you had the one line

1289
00:58:58,008 --> 00:58:59,709
about getting buy-in from the rest of the team

1290
00:58:59,989 --> 00:59:02,370
and the trade-offs with a little bit of velocity

1291
00:59:02,470 --> 00:59:03,891
for sustainability and all that.

1292
00:59:04,351 --> 00:59:06,972
I was curious how you presented that argument

1293
00:59:07,072 --> 00:59:08,533
to the rest of the team leadership,

1294
00:59:08,593 --> 00:59:10,854
and if there was any particular data you pointed to.

1295
00:59:10,914 --> 00:59:14,615
I mean, that graph of nuts and bolts and their bug count.

1296
00:59:14,795 --> 00:59:18,497
Yeah, unfortunately, we didn't have that until we finished.

1297
00:59:18,537 --> 00:59:19,637
Good job, it did work out that way.

1298
00:59:23,499 --> 00:59:27,900
I guess, I think the reality of it really, again, because we knew this was the kind of game it was,

1299
00:59:28,000 --> 00:59:32,981
I think mostly we'd had such a bad experience with previous projects. I think I was told,

1300
00:59:33,101 --> 00:59:37,643
when I was researching for this presentation, I was told that we didn't do some DLC for an old

1301
00:59:37,683 --> 00:59:41,564
project because it would just been, the testing for it would have been too much work, which sounds

1302
00:59:41,604 --> 00:59:47,986
insane, but that's apparently the situation it was. So I think when the producers were looking at that

1303
00:59:48,046 --> 00:59:48,726
they were thinking, well...

1304
00:59:49,326 --> 00:59:49,887
whatever you think.

1305
00:59:49,987 --> 00:59:53,069
If this means we can actually do an update every week

1306
00:59:53,169 --> 00:59:54,390
if we need to, that kind of thing,

1307
00:59:54,450 --> 00:59:55,671
then let's give it a go.

1308
00:59:55,931 --> 00:59:59,194
And I've not really received much pushback from,

1309
00:59:59,534 --> 01:00:01,076
I've not heard any pushback in terms of,

1310
01:00:01,456 --> 01:00:03,758
from our producers that the tests are taking too long.

1311
01:00:04,699 --> 01:00:04,999
Thank you.

1312
01:00:07,261 --> 01:00:09,803
So your tests are running,

1313
01:00:10,043 --> 01:00:12,064
is the actor test running essentially without a world?

1314
01:00:13,356 --> 01:00:19,821
There is a world, but we kind of, we almost do like new object world and have our own world rather than whatever

1315
01:00:19,841 --> 01:00:24,344
If you know Unreal, then there's like, especially in the editor

1316
01:00:24,404 --> 01:00:27,206
I think there's like two or three worlds at the same time or something

1317
01:00:27,787 --> 01:00:33,692
We just essentially spin up a very minimal world and use that with the, you know, with the actors in there. And we again

1318
01:00:34,670 --> 01:00:35,792
It's one of those things that, again, we're not,

1319
01:00:36,192 --> 01:00:38,695
it feels like it's wrong to do because it's not,

1320
01:00:39,015 --> 01:00:40,377
you're not using things in the proper way,

1321
01:00:40,437 --> 01:00:43,040
but if you're just testing the logic of something,

1322
01:00:43,080 --> 01:00:44,822
then it was good enough for what we needed, so.

1323
01:00:45,543 --> 01:00:48,186
And how different is that sort of testing

1324
01:00:48,266 --> 01:00:50,488
compared to, like, how much did you need to change

1325
01:00:50,509 --> 01:00:52,090
the automation system, really,

1326
01:00:52,130 --> 01:00:53,372
for it to do what you needed to do?

1327
01:00:54,930 --> 01:00:56,250
change the automation system.

1328
01:00:56,410 --> 01:00:57,811
Again, I believe this is,

1329
01:00:58,791 --> 01:01:00,312
it wasn't that much work to do.

1330
01:01:00,352 --> 01:01:02,633
It was more a kind of a change of thinking

1331
01:01:02,653 --> 01:01:05,354
than changing much code in the framework, to be honest.

1332
01:01:05,435 --> 01:01:09,256
I think it, again, I think the engine does kind of support,

1333
01:01:09,296 --> 01:01:10,837
probably if you talk to Epic,

1334
01:01:10,857 --> 01:01:12,398
they were like, don't do that, it's weird.

1335
01:01:12,538 --> 01:01:15,979
But if you, you know, if you just do a new world,

1336
01:01:15,999 --> 01:01:18,661
ax a spawn actor on world or whatever,

1337
01:01:18,721 --> 01:01:20,681
then I think it will work.

1338
01:01:20,761 --> 01:01:21,722
So, and again.

1339
01:01:22,803 --> 01:01:25,366
There were some caveats, it meant some things didn't work.

1340
01:01:25,386 --> 01:01:29,372
Again, it wasn't perfect,

1341
01:01:29,432 --> 01:01:30,773
but it was good enough for what we needed,

1342
01:01:30,954 --> 01:01:33,237
and it was so much faster to run.

1343
01:01:33,958 --> 01:01:35,440
It's a big game, so we had a lot of tests.

1344
01:01:35,460 --> 01:01:35,680
Thanks.

1345
01:01:37,002 --> 01:01:37,262
Thank you.

1346
01:01:39,041 --> 01:01:44,207
I'm curious if you've ever used or heard of hypothesis or property-based testing,

1347
01:01:44,607 --> 01:01:47,610
and whether you considered using that, and if so, why not?

1348
01:01:47,931 --> 01:01:49,532
I... no, I don't think I have, actually.

1349
01:01:49,553 --> 01:01:52,256
Are you able to talk briefly about what that is?

1350
01:01:52,596 --> 01:01:58,302
Yeah, so basically the idea is that the test system generates inputs for you.

1351
01:01:58,963 --> 01:02:04,025
So the classic example is you have an encode and a decode code function,

1352
01:02:04,665 --> 01:02:10,527
and you just say the encode function is the inverse of the decode function and vice versa,

1353
01:02:11,668 --> 01:02:13,889
generate a lot of string inputs, where does it fail?

1354
01:02:13,909 --> 01:02:14,769
Okay.

1355
01:02:15,610 --> 01:02:19,051
And then it tries to find, like, the minimal string that makes it fail.

1356
01:02:19,885 --> 01:02:20,626
I see, I see.

1357
01:02:21,947 --> 01:02:25,471
No, I have to say, I don't think anyone mentioned trying that.

1358
01:02:26,612 --> 01:02:30,956
Yeah, it'd be interesting how that works in a game play scenario.

1359
01:02:31,717 --> 01:02:34,079
Yeah, it's definitely worth checking out then.

1360
01:02:34,620 --> 01:02:38,844
Hypothesis is a Python library that lets you get a good idea of how it works.

1361
01:02:39,084 --> 01:02:40,926
Cool. All right, I'll look into that. That sounds really cool.

1362
01:02:42,806 --> 01:02:48,709
Hello, first of all, one thing to address the previous concern about buy-in and something

1363
01:02:48,749 --> 01:02:53,592
I find very interesting and good to see from your perspective how you outlined how you've

1364
01:02:53,712 --> 01:02:55,193
avoided crunch potentially.

1365
01:02:55,233 --> 01:03:00,796
Yeah, again, not completely, I get in trouble if I say that we've completely abolished crunch.

1366
01:03:01,856 --> 01:03:02,357
But reduced.

1367
01:03:02,777 --> 01:03:04,038
A lot better, definitely.

1368
01:03:04,698 --> 01:03:08,624
But for me, it's like the reduction of crunch,

1369
01:03:09,826 --> 01:03:11,648
the more reliable production timeline

1370
01:03:12,129 --> 01:03:14,312
trumps moving fast and break shit

1371
01:03:14,592 --> 01:03:16,555
because you will accumulate technical debt

1372
01:03:16,575 --> 01:03:17,957
that you will have to fix in the end.

1373
01:03:18,317 --> 01:03:19,539
And your producers will like you

1374
01:03:19,579 --> 01:03:21,081
for having a reliable production timeline.

1375
01:03:22,583 --> 01:03:26,209
On that line, besides bug accumulation and technical adaptation accumulation,

1376
01:03:27,030 --> 01:03:30,915
the other typical issue I see for productions to fail in the end is performance.

1377
01:03:31,616 --> 01:03:34,821
And that is, you build your systems, you build systems upon systems upon systems,

1378
01:03:34,861 --> 01:03:37,285
and then content hits and shit hits the fan. Sorry.

1379
01:03:39,539 --> 01:03:44,103
Did you do anything to account for content hitting later

1380
01:03:44,303 --> 01:03:46,104
onto the systems in your performance testing?

1381
01:03:46,124 --> 01:03:47,125
Did you do anything on that?

1382
01:03:47,566 --> 01:03:50,208
So, yeah, as I mentioned, we have the performance tests

1383
01:03:50,608 --> 01:03:52,810
and those would do things like you would have

1384
01:03:52,850 --> 01:03:55,192
the whole world, a client in a world,

1385
01:03:55,212 --> 01:03:57,053
sorry, in the actual full C.

1386
01:03:59,636 --> 01:04:04,621
and we'd collect data for five minutes or something like that, travel to every island, you know, those kind of things.

1387
01:04:05,162 --> 01:04:11,288
And then we have graphs that we'll monitor, the engine team have that up on screens in theirs

1388
01:04:11,328 --> 01:04:15,353
and they can see in real time that something has happened and it's trended down

1389
01:04:15,753 --> 01:04:16,974
and then they'll often kind of...

1390
01:04:17,595 --> 01:04:21,538
jump in quickly, find what has changed that recently.

1391
01:04:22,959 --> 01:04:24,280
The more difficult ones are when you've got

1392
01:04:24,300 --> 01:04:26,202
this kind of a very slow downward trend,

1393
01:04:26,282 --> 01:04:28,463
when it's like, okay, we're just kind of adding content

1394
01:04:28,543 --> 01:04:31,225
and at that point often, someone has to be assigned

1395
01:04:31,265 --> 01:04:33,267
to some kind of optimization task to kind of,

1396
01:04:33,327 --> 01:04:35,048
yeah, just get it a bit above,

1397
01:04:35,529 --> 01:04:36,709
get us a bit above water again.

1398
01:04:36,790 --> 01:04:39,271
And again, that's just kind of the way it is

1399
01:04:39,311 --> 01:04:41,553
with a continually evolving game like this.

1400
01:04:42,708 --> 01:04:48,592
But had you any kind of like budgeting system for that to like find these slow trends and go like okay?

1401
01:04:48,932 --> 01:04:49,933
Maybe this is something that

1402
01:04:50,814 --> 01:04:54,456
It's okay because we're still within budget. Oh, you mean yes

1403
01:04:54,496 --> 01:04:59,679
So we do give you mean like we give the artist budgets in terms of polys and things like that you mean yes

1404
01:04:59,739 --> 01:05:02,661
And in terms of memory consumption yeah, yeah, we have that as well. Yeah

1405
01:05:03,002 --> 01:05:07,025
Yeah, but then again, we're always pushing it

1406
01:05:07,065 --> 01:05:08,386
as much as we can and then obviously,

1407
01:05:08,746 --> 01:05:11,488
that's a bit harder to do when we add stuff

1408
01:05:11,608 --> 01:05:13,070
in terms of gameplay and things like that

1409
01:05:13,910 --> 01:05:16,873
because, well, in terms of general performance

1410
01:05:17,373 --> 01:05:20,335
rather than just kind of performance caused

1411
01:05:20,395 --> 01:05:21,656
by the complexity of the world.

1412
01:05:21,676 --> 01:05:24,639
So that's something that's a bit more nebulous,

1413
01:05:24,679 --> 01:05:27,261
that's a bit hard to kind of give strict guidelines on.

1414
01:05:27,968 --> 01:05:30,249
And just one quick question to follow up on that.

1415
01:05:30,329 --> 01:05:31,750
Yeah, I think we're almost out of time, but.

1416
01:05:32,311 --> 01:05:34,732
Did you have anything to stabilize the performance testing?

1417
01:05:37,474 --> 01:05:38,374
Stabilize it?

1418
01:05:38,714 --> 01:05:40,395
Because performance can be quite noisy.

1419
01:05:40,816 --> 01:05:44,037
Oh, okay, I think we just ran over a long time, I believe.

1420
01:05:44,358 --> 01:05:45,298
I can probably find out for you

1421
01:05:46,199 --> 01:05:47,179
if we did anything more than that.

1422
01:05:47,439 --> 01:05:47,760
Cool, thank you.

