1
00:00:05,565 --> 00:00:06,886
OK, thank you, Squirrel.

2
00:00:08,747 --> 00:00:11,908
I feel like I'm really lucky each time I get to come to GDC.

3
00:00:12,028 --> 00:00:13,989
And I hope that what we have here, I think,

4
00:00:14,690 --> 00:00:16,330
maybe will open your eyes to some more ways

5
00:00:16,350 --> 00:00:17,831
that you can do things and give you

6
00:00:17,871 --> 00:00:20,612
some ideas about how we might be able to do

7
00:00:20,652 --> 00:00:22,513
some indexing of our spaces.

8
00:00:23,373 --> 00:00:25,735
And what I'm going to start out is just a high-level overview.

9
00:00:25,775 --> 00:00:27,795
What do I expect you to get from this talk?

10
00:00:28,216 --> 00:00:30,317
And so there's a set of assumptions here.

11
00:00:30,377 --> 00:00:32,298
And then we're going to get into the technical details.

12
00:00:33,038 --> 00:00:37,223
So, the first assumption is that there's a lot of design problems that we see in games

13
00:00:37,704 --> 00:00:41,588
that are underlying, can be modeled as combinations or permutations.

14
00:00:41,829 --> 00:00:43,010
So that's our first assumption.

15
00:00:43,851 --> 00:00:48,497
And the second assumption is that for many of these problems, being able to do some precomputation

16
00:00:49,237 --> 00:00:52,261
can really help us solve the questions that we're trying to answer.

17
00:00:52,802 --> 00:00:54,664
And if I'm doing that sort of computation,

18
00:00:54,844 --> 00:00:56,966
then what I want is a perfect hash function,

19
00:00:57,347 --> 00:00:59,429
because this will allow me to do a direct mapping

20
00:00:59,509 --> 00:01:02,112
from these permutations to an efficient use of memory,

21
00:01:02,432 --> 00:01:04,335
where I don't need to use chaining or other things

22
00:01:04,395 --> 00:01:05,115
in my hash tables.

23
00:01:05,195 --> 00:01:08,259
It's just a one-to-one mapping from my combination

24
00:01:08,319 --> 00:01:09,801
to some sort of thing in memory.

25
00:01:10,801 --> 00:01:14,964
And so, what you're going to learn in this talk is how to use or how to build perfect

26
00:01:15,004 --> 00:01:17,266
hash functions for combinations and permutations.

27
00:01:18,266 --> 00:01:20,828
And the structure of this here is we're going to look at both of these.

28
00:01:21,308 --> 00:01:22,729
We're going to look at an example problem.

29
00:01:22,749 --> 00:01:25,652
So what are some problems that we're going to look at that would fall into this mapping?

30
00:01:26,032 --> 00:01:27,673
And then I'll talk about how we count them.

31
00:01:27,913 --> 00:01:30,555
Counting is something you tend to do in your math classes growing up.

32
00:01:31,316 --> 00:01:32,578
But the things that you don't tend to do

33
00:01:32,658 --> 00:01:34,602
is how do we do this ranking and unranking that

34
00:01:34,622 --> 00:01:36,546
allow us to then build these tables and things.

35
00:01:36,966 --> 00:01:38,349
And then we'll look at an application.

36
00:01:38,409 --> 00:01:39,711
So we're going to do the structure twice,

37
00:01:39,852 --> 00:01:41,875
once for combinations and once for permutations.

38
00:01:43,216 --> 00:01:46,319
So we're going to start with combinations, and combinations, an example of a combination

39
00:01:46,339 --> 00:01:50,202
problem would be, say, I have a deck of cards, and with this deck of cards, what I need to

40
00:01:50,242 --> 00:01:53,164
do is I need to select some hand that I'm going to have here.

41
00:01:53,865 --> 00:01:57,828
And when I select this hand, my assumption is that I'm getting some group of cards, but

42
00:01:57,848 --> 00:01:59,930
I don't care about the order in which I get them.

43
00:02:00,010 --> 00:02:03,333
So combinations, we don't care about order, but I just want to know what cards did I get

44
00:02:03,373 --> 00:02:03,774
in the end.

45
00:02:04,474 --> 00:02:10,079
Okay, so that's one example. Another problem might be like I have puzzles and I want to look at puzzles that I could possibly design.

46
00:02:10,119 --> 00:02:15,083
What would be interesting? What would not be interesting? And so this is an example puzzle that would fall in this category.

47
00:02:15,123 --> 00:02:20,648
It's something that I'm working on and here what I'm going to do is I'm just going to roll these guys against each other.

48
00:02:20,668 --> 00:02:22,509
I'm trying to knock them all off the edge of the board.

49
00:02:23,417 --> 00:02:25,338
And there's lots of different puzzles you can build from this.

50
00:02:25,898 --> 00:02:27,559
And we can ask questions about this,

51
00:02:27,619 --> 00:02:29,539
and I'll talk about that at the end of this section.

52
00:02:30,439 --> 00:02:32,840
So we could say, for instance, what are solvable puzzles?

53
00:02:32,900 --> 00:02:34,421
What are puzzles with one solution?

54
00:02:34,441 --> 00:02:36,861
Are there queries on top of that?

55
00:02:36,981 --> 00:02:39,422
And knowing how to do this ranking and ranking

56
00:02:39,442 --> 00:02:41,343
of permutations and combinations are

57
00:02:41,383 --> 00:02:43,023
crucial to being able to do that efficiently.

58
00:02:44,272 --> 00:02:47,413
So another way of looking at combinations then from this example is that I'm trying

59
00:02:47,453 --> 00:02:50,374
to place pieces on the board and I have lots of ways that I can put them.

60
00:02:51,014 --> 00:02:55,176
Now notice that if every board position here actually had a card on it, you could see that

61
00:02:55,216 --> 00:02:59,357
putting four pieces on the board would be equivalent to choosing four different cards.

62
00:02:59,657 --> 00:03:02,559
So this is sort of where those are the exact same problem, but we're going to use the board

63
00:03:02,599 --> 00:03:05,340
here because it's a little bit easier to look at and reason about the board.

64
00:03:06,588 --> 00:03:08,489
So as I said, the first thing we're going to look at is counting.

65
00:03:08,529 --> 00:03:11,131
This is stuff I expect you probably have seen at some point in your life.

66
00:03:11,612 --> 00:03:15,095
But we can think about, I'm going to put this first piece down, I could put it really anywhere

67
00:03:15,155 --> 00:03:17,737
on the board, and that means there's 20 ways I can do that.

68
00:03:18,157 --> 00:03:21,740
The second piece, well, it could go anywhere except that piece that is already occupied,

69
00:03:21,880 --> 00:03:23,601
so 19 ways for that one.

70
00:03:23,621 --> 00:03:27,244
The next one, again, has 18 ways that I could put it down, and then 17.

71
00:03:28,645 --> 00:03:33,549
Now the thing about this though is that there's many orders in which I could put these pieces

72
00:03:33,609 --> 00:03:38,793
down that would result in the same ordering or same board position at the very end.

73
00:03:39,174 --> 00:03:42,156
So I have to account for the fact that I've actually over-counted the ways that I could

74
00:03:42,176 --> 00:03:42,436
do that.

75
00:03:42,476 --> 00:03:46,339
That is, the first piece could have gone into any of these four locations and I could still

76
00:03:46,539 --> 00:03:48,341
generate exactly the same board in the end.

77
00:03:48,721 --> 00:03:52,564
So we have to factor that out by dividing by four, dividing by three for the second

78
00:03:52,604 --> 00:03:56,707
piece, the third piece could have gone into two possible locations, and the last piece

79
00:03:56,727 --> 00:03:57,448
could go into one.

80
00:03:58,339 --> 00:04:01,162
And so that just gives us 20 factorial over 16 factorial,

81
00:04:01,803 --> 00:04:04,565
gives us a numerator and the denominator is 16 factorial,

82
00:04:04,585 --> 00:04:07,909
which is, of course, more commonly known as 20 choose 4.

83
00:04:08,810 --> 00:04:11,312
Okay, so that's the basic math of how we can do the counting.

84
00:04:11,913 --> 00:04:14,115
And now what we want to do is we want to talk about a ranking.

85
00:04:14,195 --> 00:04:17,118
So a ranking is more commonly known as a perfect hash function,

86
00:04:17,138 --> 00:04:18,379
but that's a mathematical term.

87
00:04:19,160 --> 00:04:21,341
And it's a function that we're going to take a combination.

88
00:04:21,361 --> 00:04:23,022
So I'm going to give you a board pattern,

89
00:04:23,082 --> 00:04:25,043
and I'm going to say, what is the integer that

90
00:04:25,643 --> 00:04:26,624
corresponds to this?

91
00:04:26,684 --> 00:04:28,605
And this will be an integer between n minus 1

92
00:04:28,745 --> 00:04:30,426
if there's n possible combinations.

93
00:04:31,407 --> 00:04:32,587
So let's look at how this works.

94
00:04:33,128 --> 00:04:34,449
If the upper left-hand corner, I'm

95
00:04:34,469 --> 00:04:35,489
going to call this location 0.

96
00:04:35,529 --> 00:04:37,450
We just have to establish how we're

97
00:04:37,470 --> 00:04:38,351
going to lay out our board.

98
00:04:38,371 --> 00:04:41,333
And the bottom right-hand corner is going to be location 19.

99
00:04:41,953 --> 00:04:44,434
So there's 20 possible locations on the board.

100
00:04:45,255 --> 00:04:49,277
And if I start by putting all my pieces in the far upper corner of the board,

101
00:04:49,338 --> 00:04:50,678
then that's going to be rank 0.

102
00:04:51,179 --> 00:04:53,000
And if I put them in the far bottom of the board,

103
00:04:53,040 --> 00:04:55,602
then that's going to be rank 20 choose 4 minus 1.

104
00:04:55,742 --> 00:04:56,802
In this case, there's 4,800 combinations.

105
00:04:59,495 --> 00:05:00,756
And now let's sort of build up on this

106
00:05:01,077 --> 00:05:02,478
to try and build an intuition of what

107
00:05:02,578 --> 00:05:04,780
happens when I'm trying to do this sort of ranking function.

108
00:05:05,280 --> 00:05:06,281
So what I'm going to do is I'm just

109
00:05:06,301 --> 00:05:08,003
going to take my last piece here and I'm

110
00:05:08,023 --> 00:05:09,704
going to shift it over by one spot.

111
00:05:10,145 --> 00:05:11,626
And what that does is it increases

112
00:05:11,686 --> 00:05:13,848
the rank of this particular board position by one.

113
00:05:13,908 --> 00:05:15,409
So we went from rank 0 to rank 1.

114
00:05:15,769 --> 00:05:17,331
I move it over again, I get rank 2.

115
00:05:17,391 --> 00:05:18,372
I move it again, I get rank 3.

116
00:05:19,372 --> 00:05:21,874
And in general here, at least for the last position,

117
00:05:22,414 --> 00:05:24,736
what I can do is I can count the number of spaces

118
00:05:24,876 --> 00:05:27,458
between the second to last piece and the last piece,

119
00:05:27,818 --> 00:05:30,760
and that will tell me the ranking of the board,

120
00:05:31,060 --> 00:05:33,822
at least when the first three pieces are in those positions.

121
00:05:34,222 --> 00:05:36,003
And so if I jump the last piece down here,

122
00:05:36,103 --> 00:05:36,664
I get ranking 16.

123
00:05:38,514 --> 00:05:42,760
Okay, now the question is, of course, how do I generalize this if I want to put the

124
00:05:42,780 --> 00:05:44,723
space at the beginning instead of at the end?

125
00:05:45,424 --> 00:05:48,629
And the way we're going to reason about this, at least here, is going to be recursively.

126
00:05:49,854 --> 00:05:53,277
I'm going to think about, you know, when I moved all these pieces over, we were just

127
00:05:53,297 --> 00:05:57,320
thinking about how many possible ranks did I skip when I moved the last piece down.

128
00:05:57,340 --> 00:06:01,284
Now I want to know how many ranks did I skip when I moved over on this first position.

129
00:06:01,304 --> 00:06:07,969
And so we're going to ask, what is the count of the number of positions that have a piece

130
00:06:08,129 --> 00:06:09,530
on the first spot in the board?

131
00:06:10,191 --> 00:06:13,734
Well, if we think about that, there's three pieces now that I'm going to place on the rest of the board.

132
00:06:14,094 --> 00:06:17,917
If I'm fixing the first position there, then really this is just a recursive sub-problem.

133
00:06:18,438 --> 00:06:21,961
And there's 19 choose-three ways of putting the other three pieces on the board.

134
00:06:23,047 --> 00:06:28,888
Okay, so coming back to this problem here, what I'm going to ask is how many possible

135
00:06:28,948 --> 00:06:32,229
boards did I skip over that had a piece in that first position?

136
00:06:32,249 --> 00:06:37,510
Well, as I said, that's 19 choose 3, 19 factorial over 16 factorial, 3 factorial, that's 969,

137
00:06:37,970 --> 00:06:41,071
and so that tells me that the rank of this position is 969.

138
00:06:42,972 --> 00:06:47,154
Now, if you're following along with me, then you should be able to guess that if I move

139
00:06:47,194 --> 00:06:50,656
this bottom piece over by one, then we're going to see the same effect.

140
00:06:50,716 --> 00:06:51,677
My rank's going to go from 969 to 970.

141
00:06:55,702 --> 00:07:00,425
Now the question is, well, what if happens if I move the pieces around and I put the spot somewhere else?

142
00:07:01,365 --> 00:07:04,567
That is, I put the gap here, and we do the same computation.

143
00:07:04,607 --> 00:07:10,211
What if I put the first piece in the second position, I put another piece in that blank position that I'm skipping over,

144
00:07:10,231 --> 00:07:13,693
and I want to know, well, how many ways could I arrange the rest of the pieces?

145
00:07:14,233 --> 00:07:18,496
Well, there's 17 remaining locations, and there's two pieces that I would have to put on the board.

146
00:07:19,176 --> 00:07:24,260
And so that tells me there's 136 ways that I've skipped of arranging pieces when I didn't

147
00:07:24,300 --> 00:07:28,284
put a piece in the second, that position that's being pointed to there by the arrow.

148
00:07:28,744 --> 00:07:35,430
And so the rank of this is 969, which is the first skipping, and 136, which is that second

149
00:07:35,470 --> 00:07:36,391
hole that I skipped there.

150
00:07:36,891 --> 00:07:37,892
And so the total rank is 1105.

151
00:07:39,753 --> 00:07:42,135
So the general procedure of saying, look, here's a board,

152
00:07:42,155 --> 00:07:45,557
and I want to know what the ranking of this particular

153
00:07:45,597 --> 00:07:46,018
board is.

154
00:07:46,598 --> 00:07:48,279
And again, I'll show you some applications

155
00:07:48,299 --> 00:07:50,161
that I can use this in a moment, is I'm simply

156
00:07:50,201 --> 00:07:52,943
going to go through and count how many locations,

157
00:07:53,003 --> 00:07:54,684
or how many combinations, did I skip

158
00:07:55,105 --> 00:07:57,026
in each of these sub-areas of the board.

159
00:07:57,486 --> 00:07:59,568
And when I count them all up, and I sum them all together,

160
00:07:59,608 --> 00:08:02,350
then that will be the ranking of this particular board.

161
00:08:03,274 --> 00:08:06,640
So I'm going to just go through this pseudocode here. I don't expect you to read it and understand it,

162
00:08:07,001 --> 00:08:09,145
but I just want to show you the structure of what's going on.

163
00:08:09,506 --> 00:08:13,614
So this is a recursive implementation of a base case. If I have no pieces, then the rank is zero.

164
00:08:15,384 --> 00:08:20,208
If there's a piece in the first possible location, then I just continue to rank the rest of the board.

165
00:08:20,668 --> 00:08:23,551
In the first possible location, I basically don't add anything to the rank.

166
00:08:24,091 --> 00:08:30,176
Otherwise, I count how many locations am I skipping by not putting a particular piece in a particular location,

167
00:08:30,637 --> 00:08:34,600
and then I recursively say, okay, now I've got a slightly smaller board, and I continue to rank that.

168
00:08:36,678 --> 00:08:39,781
Notice that this runs in linear time because I have to go through the entire board.

169
00:08:39,821 --> 00:08:41,042
It's linear in the board space.

170
00:08:41,683 --> 00:08:45,005
If we do some special caching about the combinations here,

171
00:08:45,025 --> 00:08:46,627
we can run linear in the number of pieces,

172
00:08:47,327 --> 00:08:48,989
and that's not too hard to do.

173
00:08:49,029 --> 00:08:50,610
We just have to do some caching in our code.

174
00:08:51,691 --> 00:08:54,333
And this code will... I'll give you a URL for all this code a little bit later.

175
00:08:55,460 --> 00:09:00,366
Unranking is the reverse process to this, that is, I want to give you an integer and

176
00:09:00,386 --> 00:09:02,668
I want to get back from it the board position.

177
00:09:03,249 --> 00:09:07,073
So the way this works is we're going to reason about what we've been doing here.

178
00:09:07,133 --> 00:09:11,318
So here I have my first board position, we know this is rank 0, and we know my second

179
00:09:11,338 --> 00:09:12,679
board position right here is rank 969.

180
00:09:14,681 --> 00:09:21,002
So given that I gave you a number that's say 803 and I want to say unrank this 803 and tell me what it is,

181
00:09:21,543 --> 00:09:25,523
well I know that if it was in the first position, the rank would be somewhere between 0

182
00:09:26,544 --> 00:09:29,944
and then the second position, with the first piece being in the second position, would be

183
00:09:30,225 --> 00:09:35,486
somewhere higher than 969. And so since my value that I'm going to unrank here is 803,

184
00:09:35,866 --> 00:09:40,907
it's between 0 and 969, which means the first piece must have gone in the first position

185
00:09:41,267 --> 00:09:44,088
and then I'm going to recursively worry about where I'm going to put the rest of the pieces.

186
00:09:44,888 --> 00:09:51,995
So we'll put our first piece in here, and we're going to continue with a rank of 803, and we're going to actually do the same computation

187
00:09:52,596 --> 00:09:53,557
again recursively here.

188
00:09:53,637 --> 00:10:00,484
So now, because there's fewer pieces to place, if I put the next piece in the second position, it would start with rank

189
00:10:00,904 --> 00:10:03,847
153, but I'm looking for rank 803, which is much larger.

190
00:10:04,528 --> 00:10:07,991
So I know that the first piece doesn't go in this first position with the left arrow there.

191
00:10:08,894 --> 00:10:12,035
So what I'm going to do is I'm going to subtract 153 from my rank.

192
00:10:12,716 --> 00:10:16,857
I'm going to get a rank of 650, and then I'm going to continue the process at the next step.

193
00:10:17,438 --> 00:10:22,080
So I get here, the rank is, and I ask, now is my rank of 650, is it between 0 and 136?

194
00:10:23,000 --> 00:10:26,622
The answer is no, so I subtract 136, and I move down the board.

195
00:10:26,942 --> 00:10:31,724
I continue to subtract, subtract, and move down the board every time I'm doing this,

196
00:10:32,164 --> 00:10:36,126
until, here, I do my subtraction and I move down, and now I find that my rank is 54.

197
00:10:37,367 --> 00:10:40,113
The ranks for the next position start at 55,

198
00:10:40,474 --> 00:10:42,498
and so my next board, my next piece on the board

199
00:10:42,559 --> 00:10:43,360
is gonna go right here.

200
00:10:45,559 --> 00:10:51,481
And now again, I continue down the board now. There's very few pieces left to place. So these ranks are fairly small again

201
00:10:51,501 --> 00:10:58,483
I do the same process over and over again until I get farther and farther down the board every time I'm decreasing this rank and

202
00:10:58,543 --> 00:10:59,704
Eventually I get down here

203
00:10:59,724 --> 00:11:04,625
I have a rank of zero the ranks are gonna start at one on the right hand side and in fact actually have two pieces

204
00:11:04,665 --> 00:11:06,726
Left to place there's only two pieces left on the board

205
00:11:07,146 --> 00:11:10,327
So I put those last two pieces in and I finished the end ranking

206
00:11:12,226 --> 00:11:13,927
So the code again here is recursive.

207
00:11:14,667 --> 00:11:18,949
My base case is if my count goes down to zero, I'm done doing the unranking.

208
00:11:18,969 --> 00:11:20,649
That is, I'm putting it inside the piece array.

209
00:11:21,250 --> 00:11:24,891
I'm going to count how many pieces I would skip if I skip the next location.

210
00:11:24,911 --> 00:11:29,673
And then I say, look, if my rank is higher than this range, zero to skipped,

211
00:11:29,773 --> 00:11:31,394
then I'm going to just keep going.

212
00:11:31,594 --> 00:11:34,095
Otherwise, I'm going to place a piece on the board,

213
00:11:34,495 --> 00:11:36,456
and then I'll recursively unrank the rest of the board.

214
00:11:37,617 --> 00:11:40,921
Okay, so the question is, for a board like this,

215
00:11:41,281 --> 00:11:42,382
what does it allow me to do

216
00:11:42,462 --> 00:11:43,984
in terms of design decisions here,

217
00:11:44,024 --> 00:11:45,987
and how did I actually come up with this level?

218
00:11:46,327 --> 00:11:47,949
And it's actually one of a very few set

219
00:11:47,989 --> 00:11:49,891
of very interesting levels that happen

220
00:11:50,071 --> 00:11:52,254
when I define this set of mechanics for this level.

221
00:11:53,192 --> 00:11:55,873
And here what we're going to do is an idea called retrograde analysis.

222
00:11:56,573 --> 00:12:01,354
What we're going to do is we're going to work backwards from all levels that we know are

223
00:12:01,414 --> 00:12:05,956
solvable or not solvable, and we're going to work up until we get more and more complicated

224
00:12:05,996 --> 00:12:11,217
levels to use the solved levels as sort of guides to the solution to the higher levels

225
00:12:11,317 --> 00:12:11,377
up.

226
00:12:12,233 --> 00:12:15,755
So in particular here what we do is we're going to go through all possible states

227
00:12:16,455 --> 00:12:19,937
and what we're going to say is, look, you give me a state number, give me the board

228
00:12:19,957 --> 00:12:21,117
that's associated with it.

229
00:12:21,578 --> 00:12:25,900
And here we're going to decide just what are the levels in my world that are solvable.

230
00:12:26,660 --> 00:12:28,721
So I get my board out of this particular ranking.

231
00:12:29,699 --> 00:12:35,483
As I said, in practice this isn't a very compact hash table, it's just an array sitting in memory.

232
00:12:35,503 --> 00:12:39,625
And then for that particular board, I'm going to look at every single possible move,

233
00:12:40,086 --> 00:12:45,269
and after I apply the move, I'm then going to get a new board state, like I took some action on that board,

234
00:12:45,289 --> 00:12:48,931
I have a new board state, and so now I'm going to get the ranking,

235
00:12:48,971 --> 00:12:51,333
which is going to go look up somewhere in memory, and it's going to say,

236
00:12:51,353 --> 00:12:53,654
is this board state, is it solvable or not?

237
00:12:54,535 --> 00:12:59,399
And if that board state is solvable, then I know that is the next state I got to by taking an action,

238
00:12:59,919 --> 00:13:03,982
then I know before I take the action that if I take that action, I'll actually be able to solve that board.

239
00:13:04,880 --> 00:13:08,101
And so if I'm looking for all the positions that could be solved by taking, you know,

240
00:13:08,121 --> 00:13:10,762
that there is at least one action that leads me to a solution,

241
00:13:11,422 --> 00:13:16,183
then this procedure here is going to then store, as I keep reading it,

242
00:13:16,263 --> 00:13:19,224
I have to run it over and over again until basically the result's subtle,

243
00:13:20,204 --> 00:13:22,305
it's going to give me all solvable positions.

244
00:13:22,725 --> 00:13:26,506
And these are going to be positions that there is at least one action that causes them to be solved.

245
00:13:27,435 --> 00:13:31,097
But I might want to ask much more interesting questions about how things work here.

246
00:13:31,577 --> 00:13:36,620
For instance, I might want to say, well, what are the set of boards for which all moves lead to a solvable position?

247
00:13:36,640 --> 00:13:38,822
And you might say, well, why is that interesting?

248
00:13:38,862 --> 00:13:41,563
Well, if you're trying to train people to play your game,

249
00:13:42,464 --> 00:13:45,746
if you give them levels that they can't actually make any wrong decisions in,

250
00:13:46,306 --> 00:13:48,829
then they're learning about the mechanics of how your game work

251
00:13:49,210 --> 00:13:52,293
without actually ever being penalized for making incorrect decisions.

252
00:13:52,393 --> 00:13:53,755
So I give this to people and they think,

253
00:13:53,815 --> 00:13:55,417
wow, I'm just playing this game so well,

254
00:13:55,877 --> 00:13:58,080
actually I've just given you levels that you can't not solve

255
00:13:58,220 --> 00:14:01,163
as long as you take legal actions, and all legal actions lead to a solution.

256
00:14:01,904 --> 00:14:02,746
So how do we do that?

257
00:14:02,786 --> 00:14:04,989
We assume that this board is going to be solvable,

258
00:14:05,169 --> 00:14:06,992
and then we go through all moves as before.

259
00:14:07,393 --> 00:14:10,017
And if we find that any move doesn't lead to a solution,

260
00:14:10,037 --> 00:14:12,541
then we say, ah, this isn't one of the states that I want

261
00:14:12,561 --> 00:14:13,502
that's fully solvable.

262
00:14:14,143 --> 00:14:16,326
And so I say, this isn't solvable at all.

263
00:14:17,223 --> 00:14:19,664
So this is a way that you can take design problems like this

264
00:14:20,064 --> 00:14:22,005
and you can start to classify what's going on.

265
00:14:22,025 --> 00:14:23,925
And you could make a slightly different version that said,

266
00:14:24,166 --> 00:14:27,567
what has two solutions, or two unique solutions,

267
00:14:27,607 --> 00:14:28,507
or different things like this.

268
00:14:28,547 --> 00:14:30,968
Or maybe I want one solution all the way down,

269
00:14:30,988 --> 00:14:33,268
but at the very beginning of the board there's two solutions.

270
00:14:33,668 --> 00:14:36,549
So you could specify anything like that as a design question

271
00:14:37,089 --> 00:14:38,710
and we could build a retrograde analysis

272
00:14:38,770 --> 00:14:41,691
to figure out what puzzles met those conditions.

273
00:14:42,705 --> 00:14:46,631
Now, there's also a lot of problems that are related to this that have to do with what's

274
00:14:46,671 --> 00:14:47,612
called multisets.

275
00:14:48,073 --> 00:14:50,657
And multisets are combinations where you allow duplicates.

276
00:14:51,278 --> 00:14:54,963
I don't have any time today to talk about how to handle multisets, but I wanted to show

277
00:14:55,003 --> 00:14:58,028
an example of this and why you might be interested in using these.

278
00:14:59,046 --> 00:15:01,349
So let's say that you're building an AI for a card game.

279
00:15:01,889 --> 00:15:05,513
So I'm going to be dealt some cards, but my cards may be like I've got lots of mana cards,

280
00:15:05,553 --> 00:15:07,475
and so I might get multiple manas in my hand.

281
00:15:07,896 --> 00:15:12,161
And I've got to think about how am I going to, like what is any particular hand going to be?

282
00:15:12,541 --> 00:15:14,243
And my AI has to make a decision.

283
00:15:14,283 --> 00:15:17,046
It says like, you know, should I make this move or make this move?

284
00:15:17,427 --> 00:15:19,969
And what is my resulting hand going to look like afterwards?

285
00:15:20,450 --> 00:15:24,732
So something you might want to do is instead of trying to do extensive online analysis

286
00:15:24,812 --> 00:15:29,353
in an offline phase, you analyze all possible five-card hands, you say how good or how bad

287
00:15:29,373 --> 00:15:33,815
they are, and then when you get at runtime, instead of having to try and do that analysis

288
00:15:33,855 --> 00:15:40,158
on the fly, I just go look this up at a table, I compute the ranking of all the possible

289
00:15:40,918 --> 00:15:43,980
hands that I could get to, and then I look them up and I get the answer there.

290
00:15:44,400 --> 00:15:46,020
This could build a much stronger AI

291
00:15:46,360 --> 00:15:49,382
that was actually much less expensive at runtime

292
00:15:49,422 --> 00:15:50,362
to do the computation.

293
00:15:51,122 --> 00:15:52,323
So if you're interested in multisets,

294
00:15:52,543 --> 00:15:53,903
they can be built on top of everything

295
00:15:53,923 --> 00:15:54,904
we've been doing so far.

296
00:15:55,604 --> 00:15:57,505
I encourage you can look up some more data about that.

297
00:15:59,282 --> 00:16:01,584
The next thing then, so that's combinations.

298
00:16:02,004 --> 00:16:03,765
The next thing we're gonna look at, permutations.

299
00:16:03,805 --> 00:16:05,427
And permutations are like combinations,

300
00:16:05,467 --> 00:16:06,288
except they're ordered.

301
00:16:06,868 --> 00:16:08,770
So we're gonna go back to our deck example here.

302
00:16:08,810 --> 00:16:09,931
I've got a deck of cards.

303
00:16:10,311 --> 00:16:11,892
But what I wanna talk about is all the ways

304
00:16:11,912 --> 00:16:13,514
that we can mix these cards around.

305
00:16:13,874 --> 00:16:15,815
That is, these are all the ways that I could shuffle this.

306
00:16:16,296 --> 00:16:18,137
And we mentioned shuffling algorithms this morning.

307
00:16:18,177 --> 00:16:19,499
Those are exactly permutations,

308
00:16:19,539 --> 00:16:22,101
and we'll see how this connection is made here

309
00:16:22,161 --> 00:16:22,781
a little bit later.

310
00:16:23,688 --> 00:16:25,849
So from here we might talk about like dealing cards out.

311
00:16:26,270 --> 00:16:29,192
There's some notable examples where people writing poker programs

312
00:16:29,972 --> 00:16:32,894
have used broken methods for, you know, shuffling cards

313
00:16:33,194 --> 00:16:35,636
and people have been able to take advantage of that to make a lot of money.

314
00:16:36,116 --> 00:16:38,698
So we want to avoid that sort of thing by making sure we're using

315
00:16:39,258 --> 00:16:40,599
very sound techniques,

316
00:16:40,940 --> 00:16:43,982
like we're really careful about how we do our permutations

317
00:16:44,362 --> 00:16:45,543
to make sure that we are

318
00:16:46,323 --> 00:16:48,124
that we're truly getting a random permutation.

319
00:16:49,034 --> 00:16:53,617
Now, there's games actually, so this is a game, Cogs, that came out in 2009.

320
00:16:54,157 --> 00:16:59,340
This game ends up that it's basically a reworking of a classic sliding tile puzzle where you're

321
00:16:59,360 --> 00:17:01,802
trying to slide the tiles and get them into the right locations.

322
00:17:02,482 --> 00:17:06,825
And it ends up in these sort of games you can actually use permutations, again I'll

323
00:17:06,865 --> 00:17:11,468
mention this at the end once we've gone through the details, we can use them to help us build

324
00:17:11,508 --> 00:17:12,328
solvers for these.

325
00:17:12,849 --> 00:17:16,331
And so for instance if you look at Jesse Schell's book on game design, what he says is that

326
00:17:17,550 --> 00:17:18,951
When you're building puzzles, it's

327
00:17:18,971 --> 00:17:21,314
very useful if you can help the player out, maybe even

328
00:17:21,354 --> 00:17:22,315
give them the solution.

329
00:17:22,796 --> 00:17:24,758
And so if you can build a solver into your game

330
00:17:24,798 --> 00:17:26,299
that anywhere the user gets stuck,

331
00:17:26,319 --> 00:17:28,121
you can help them along in the solution,

332
00:17:28,141 --> 00:17:30,764
then that's very, very useful and powerful to do.

333
00:17:31,185 --> 00:17:32,566
And in order to do that efficiently,

334
00:17:32,626 --> 00:17:34,228
you're going to want to know some of the math

335
00:17:34,248 --> 00:17:34,889
that we're doing here.

336
00:17:34,909 --> 00:17:36,851
So we're going to go through all the math,

337
00:17:36,891 --> 00:17:38,112
and I'll come back and talk about how

338
00:17:38,132 --> 00:17:38,993
we do that in practice.

339
00:17:39,834 --> 00:17:42,398
So again, we're going to start out, how do I count permutations?

340
00:17:42,558 --> 00:17:44,862
And I'm just going to use permutation of four items here.

341
00:17:44,902 --> 00:17:45,783
So I have 0, 1, 2, 3.

342
00:17:46,464 --> 00:17:48,667
And we're going to say, what are all the orders that we can put this in?

343
00:17:48,727 --> 00:17:50,190
Or what is the count of them?

344
00:17:50,210 --> 00:17:52,253
If we think about it, there's four numbers here.

345
00:17:52,293 --> 00:17:54,977
I could put any of the four of them in the first location here.

346
00:17:57,022 --> 00:18:00,323
Then when I put the first one in, there's three remaining to go in the next location,

347
00:18:00,583 --> 00:18:06,425
and then two remaining, and finally one remaining, and so this is factorial here, so just a straight

348
00:18:06,445 --> 00:18:07,065
factorial.

349
00:18:07,965 --> 00:18:12,486
And so you can see with permutations, there's many more ways that we can arrange them than

350
00:18:12,506 --> 00:18:18,968
a relatively equal size of combinations, and that's because we, if I think about the same

351
00:18:19,008 --> 00:18:22,789
set of numbers, it's because we care about the order, where in combinations we don't.

352
00:18:23,049 --> 00:18:24,909
So here we're going to take the factorial to count them.

353
00:18:26,133 --> 00:18:28,396
Now, if we want to understand ranking and unranking,

354
00:18:28,436 --> 00:18:31,240
there's something we have to understand, which is called mixed radix numbers.

355
00:18:31,300 --> 00:18:34,384
It really helps us to understand and get an intuition for what's going on.

356
00:18:34,905 --> 00:18:38,250
Now, probably most of you here haven't heard of mixed radix numbers,

357
00:18:38,630 --> 00:18:41,013
but it ends up that all of you do it every day, all the time,

358
00:18:41,154 --> 00:18:42,195
when you look at your watch.

359
00:18:42,875 --> 00:18:45,416
your count of the time is actually a mixed radix number.

360
00:18:45,436 --> 00:18:46,836
And the idea is we just have numbers

361
00:18:46,876 --> 00:18:49,037
that are in different bases that we combine together.

362
00:18:49,537 --> 00:18:51,778
So time, if I say it's 7.12 in the morning,

363
00:18:52,098 --> 00:18:54,378
that's seven base 24 and 12 base 60.

364
00:18:54,518 --> 00:18:59,100
Or if we think about currency, if I have $15.39,

365
00:18:59,140 --> 00:19:01,100
that's 15 really in an infinite base

366
00:19:01,140 --> 00:19:03,581
because ideally I could have an infinite amount of money.

367
00:19:04,361 --> 00:19:05,341
Of course, not in practice.

368
00:19:05,401 --> 00:19:07,322
But, and then I have 39 cents,

369
00:19:07,382 --> 00:19:09,102
and that 39 cents is never gonna be more,

370
00:19:09,202 --> 00:19:10,342
I'm never gonna have 100 cents.

371
00:19:10,362 --> 00:19:10,942
So that's really 39 base 100.

372
00:19:12,523 --> 00:19:16,066
So we're familiar with that and that's what's going to be sort of a key for

373
00:19:16,627 --> 00:19:17,928
part of this conversion process.

374
00:19:18,548 --> 00:19:24,153
So the first thing I'm going to talk about is how we do the conversion for mixed radix to mixed radix and then we'll actually

375
00:19:24,173 --> 00:19:27,516
look at the ranking and unranking and these do this as part of the process.

376
00:19:28,396 --> 00:19:30,538
Okay, so the first thing we're going to look at here is

377
00:19:31,299 --> 00:19:35,643
what I want to do is separate out the left hand side or the right hand side with the numbers

378
00:19:36,443 --> 00:19:38,205
and the left hand side here and

379
00:19:40,532 --> 00:19:42,072
What I'm going to do is basically say, look,

380
00:19:42,092 --> 00:19:43,872
I want this 0 to be base 4.

381
00:19:44,672 --> 00:19:46,713
But I want everything else on the right-hand side

382
00:19:46,773 --> 00:19:47,913
to be a lower base.

383
00:19:47,933 --> 00:19:49,153
So I'm going to start out by taking the 0

384
00:19:49,553 --> 00:19:50,454
and making it base 4.

385
00:19:50,894 --> 00:19:53,114
Everything on the right, I'm going to convert it to base 3.

386
00:19:53,634 --> 00:19:55,575
But I want this to be a permutation in base 3.

387
00:19:55,875 --> 00:19:58,495
And right now, it's not, because in base 3, I only have 0, 1,

388
00:19:58,695 --> 00:19:59,075
and 2.

389
00:19:59,596 --> 00:20:00,896
So I'm going to actually subtract 1

390
00:20:01,516 --> 00:20:04,276
from all of these numbers so that it is then a permutation.

391
00:20:05,850 --> 00:20:10,397
Notice here that actually my original numbers were 0, 1, 2, 3, which is sort of the most basic

392
00:20:10,697 --> 00:20:12,019
permutation that you can have.

393
00:20:12,540 --> 00:20:16,346
And so if you're working in lexicographical ordering, which is this natural alphabet ordering,

394
00:20:16,646 --> 00:20:21,793
then that's actually the zero permutation, and you'll see this as we finish going through here.

395
00:20:22,620 --> 00:20:24,721
Okay, so now I'm going to just take my next number here.

396
00:20:24,781 --> 00:20:28,543
I have 0 in base 3, and I want to take that and leave it in base 3,

397
00:20:28,583 --> 00:20:30,604
and I want to make the 1 and 2 be in base 2.

398
00:20:31,224 --> 00:20:34,066
Again, I need this to be a permutation, so I need 0 and 1 here,

399
00:20:34,086 --> 00:20:35,987
so I'm going to subtract 1 from each of those,

400
00:20:36,367 --> 00:20:38,948
so then I have a permutation of the elements 0 to 1.

401
00:20:38,988 --> 00:20:42,430
And then the last one just becomes 0.

402
00:20:42,470 --> 00:20:44,511
Your last digit's base 1, so that's all with 0.

403
00:20:44,611 --> 00:20:47,232
I also, in the last session, we were talking about mod by 1.

404
00:20:48,113 --> 00:20:49,153
We want to do that here too.

405
00:20:50,337 --> 00:20:53,038
So this is what we're doing when converting to mixed radix.

406
00:20:53,078 --> 00:20:55,659
And let's look at how we do this overall in the ranking process.

407
00:20:56,099 --> 00:20:58,340
So I have this permutation 2, 1, 3, 4.

408
00:20:58,660 --> 00:21:01,141
And I want to map it to a numerical value.

409
00:21:01,541 --> 00:21:02,741
I'm going to take 2 on the left.

410
00:21:02,801 --> 00:21:03,702
And I'm going to do that first.

411
00:21:03,762 --> 00:21:06,203
And we know, I mean, this is very similar to binary,

412
00:21:06,423 --> 00:21:08,003
where we would take 2 to some power.

413
00:21:08,443 --> 00:21:10,444
But now on the right, we don't have powers of 2.

414
00:21:10,724 --> 00:21:11,845
We actually have factorials.

415
00:21:12,385 --> 00:21:12,885
So I'm going to take 2.

416
00:21:13,485 --> 00:21:15,546
And then there's 3 factorial values to the right.

417
00:21:15,586 --> 00:21:17,146
So I get 2 times 3 factorial.

418
00:21:17,887 --> 00:21:19,888
And then I need to convert the values to the right,

419
00:21:20,268 --> 00:21:23,390
do the conversion in this mixed radix format.

420
00:21:24,751 --> 00:21:26,492
Then I'm gonna continue this, so I have one,

421
00:21:26,613 --> 00:21:28,414
and then there's two factorial combinations

422
00:21:28,474 --> 00:21:30,175
of values that I can have to the right of there.

423
00:21:30,615 --> 00:21:33,477
So one times two factorial, and then again,

424
00:21:33,577 --> 00:21:36,719
conversion to the proper mixed radix here.

425
00:21:37,300 --> 00:21:39,101
And finally, one times one factorial,

426
00:21:39,181 --> 00:21:40,642
and at the end I always have zero.

427
00:21:41,792 --> 00:21:46,000
So once, if I know how to do this conversion, or if I just have it in mixed radix, it's really easy.

428
00:21:46,080 --> 00:21:49,506
Instead of multiplying by powers of two, which is what we do in base two,

429
00:21:49,807 --> 00:21:52,792
we're multiplying by factorials, because our bases are going 4, 3, 2, 1 here.

430
00:21:54,485 --> 00:21:56,067
The pseudocode is relatively easy.

431
00:21:57,008 --> 00:21:58,309
I start out with a hash value of 0.

432
00:21:59,169 --> 00:22:01,111
I take my first piece, and I multiply it

433
00:22:01,151 --> 00:22:03,273
by the factorial of the number of entries that are left.

434
00:22:04,154 --> 00:22:06,676
And then I have to do this conversion, this mixed radix

435
00:22:06,716 --> 00:22:07,216
conversion.

436
00:22:07,597 --> 00:22:09,138
And the problem here is that this loop

437
00:22:09,318 --> 00:22:11,540
makes this entire process run in n squared time.

438
00:22:12,100 --> 00:22:13,602
And so we're going to continue looking at,

439
00:22:13,642 --> 00:22:15,643
because that gives us an intuition for what's going on.

440
00:22:16,024 --> 00:22:17,785
But then I'll show you a really cool algorithm,

441
00:22:17,805 --> 00:22:18,566
or at least I'm going to show you

442
00:22:18,646 --> 00:22:20,367
half of a really cool algorithm that

443
00:22:20,407 --> 00:22:22,890
allows us to do this in linear time with some trade-offs.

444
00:22:23,902 --> 00:22:25,182
OK, so if we want to go backwards,

445
00:22:25,522 --> 00:22:26,863
we just reverse this process.

446
00:22:27,343 --> 00:22:28,984
OK, so how am I going to reverse it?

447
00:22:29,064 --> 00:22:30,685
I take 15, 15's my rank.

448
00:22:30,705 --> 00:22:32,166
I'm going to look at the first digit here.

449
00:22:32,866 --> 00:22:36,367
And I'm going to mod it by 1 to get the first digit here.

450
00:22:36,387 --> 00:22:37,968
Well, the first digit is always 0.

451
00:22:38,729 --> 00:22:39,869
And then I'm going to divide it by 1

452
00:22:40,229 --> 00:22:42,270
to get the next rank that I'm going to work off of.

453
00:22:42,410 --> 00:22:42,730
So that's 15.

454
00:22:44,165 --> 00:22:48,569
Again, now this is base 2, so I'm going to mod by 2 to get the next digit here.

455
00:22:48,629 --> 00:22:49,050
That gives me 1.

456
00:22:49,230 --> 00:22:52,493
And then I'm going to divide by 2 to get the next rank, which is 7.

457
00:22:53,013 --> 00:22:55,615
But notice here I'm in a mixed radix format.

458
00:22:55,655 --> 00:22:59,299
I don't want my result to be in a mixed radix format because this is not generally what

459
00:22:59,319 --> 00:22:59,759
we want.

460
00:22:59,779 --> 00:23:04,123
So now I need to go here and make sure that this is a valid permutation, which it is,

461
00:23:04,183 --> 00:23:05,964
so I just leave that as it is.

462
00:23:06,045 --> 00:23:06,785
So I get 1, 0 there.

463
00:23:08,084 --> 00:23:12,186
Now I'm going to take 7, I'm going to mod by 3 to figure out the next digit, that's going to be 1.

464
00:23:12,366 --> 00:23:16,048
And I'm going to divide by 3 to get the next rank, which is 2.

465
00:23:17,089 --> 00:23:22,852
And now I need to put this again into a, I want this to be in a fixed base, so I want it base 3 all the way across.

466
00:23:23,172 --> 00:23:26,734
And so this 1 here is going to have to be increased to actually be 2.

467
00:23:28,395 --> 00:23:31,237
And I do this one more time, actually now I just have a rank of 2 here,

468
00:23:31,577 --> 00:23:36,980
and I take this digit that's there already, I increase it by 1, and now I'm back to my original permutation.

469
00:23:37,963 --> 00:23:41,369
Okay, so the code looks almost identical to what I did in ranking,

470
00:23:42,010 --> 00:23:46,318
but here I'm going to say piece x is going to be basically my hash mod the number of entries,

471
00:23:46,398 --> 00:23:48,322
I take my hash divided by the number of entries,

472
00:23:48,722 --> 00:23:50,846
and then I do this conversion for a mixed radix.

473
00:23:52,202 --> 00:23:53,824
OK, so as I said, this is n squared.

474
00:23:53,844 --> 00:23:55,526
What could we do to do a better job of this?

475
00:23:55,586 --> 00:23:58,949
Well, we all hopefully know this algorithm

476
00:23:58,969 --> 00:24:00,190
for how do I randomize a deck.

477
00:24:00,751 --> 00:24:02,292
I choose a random card, and I'm going

478
00:24:02,312 --> 00:24:03,393
to put it at the end of the deck.

479
00:24:03,794 --> 00:24:05,015
I'll choose another random card.

480
00:24:05,035 --> 00:24:06,156
I'll put it at the next space.

481
00:24:06,216 --> 00:24:07,677
And I choose, again, my last card

482
00:24:07,717 --> 00:24:08,818
is going to go in the last space.

483
00:24:09,539 --> 00:24:11,840
So, Merbill and Ruski, they came up with this algorithm

484
00:24:12,380 --> 00:24:15,101
where they basically said, look, I'm going to use my ranking

485
00:24:15,701 --> 00:24:18,041
as my so-called random number generator.

486
00:24:18,622 --> 00:24:21,022
And as long as my ranking goes on the right range of values,

487
00:24:21,442 --> 00:24:22,623
then I'll be perfectly fine there.

488
00:24:23,043 --> 00:24:24,623
So my rank here is going to be 4,

489
00:24:25,704 --> 00:24:28,764
and what I'm going to do is I'm going to choose a card to put at the end.

490
00:24:28,804 --> 00:24:30,285
There's three cards to choose from.

491
00:24:30,305 --> 00:24:32,746
So I'm going to mod it by 3, and that's going to tell me,

492
00:24:32,786 --> 00:24:34,626
take card number 1 and put it at the end,

493
00:24:35,066 --> 00:24:36,246
and then move the next card over.

494
00:24:37,633 --> 00:24:40,238
OK, then I'm going to say divide by 3 to get 1.

495
00:24:40,439 --> 00:24:42,122
And that's going to tell me my next rank.

496
00:24:42,723 --> 00:24:45,148
So I'm going to mod this by 2 to give me

497
00:24:45,168 --> 00:24:47,293
the next my next so-called random number.

498
00:24:48,587 --> 00:24:51,409
that's going to put the next card in and then of course the next the last card

499
00:24:51,429 --> 00:24:55,572
goes in the last position. So this algorithm basically takes this

500
00:24:56,073 --> 00:25:00,216
shuffling algorithm that computes a correct shuffling but instead of just

501
00:25:00,256 --> 00:25:03,058
choosing a random number or doing this with random numbers we can actually take

502
00:25:03,098 --> 00:25:06,961
a rank and we can do it. Now the reverse process is more complicated you need to

503
00:25:07,001 --> 00:25:10,884
know something about dual representations of permutations and I

504
00:25:10,924 --> 00:25:14,147
don't have time in this lecture to go over it but there's some I have a link

505
00:25:14,187 --> 00:25:16,108
to the paper which I'll give to you shortly.

506
00:25:17,004 --> 00:25:19,125
And there's code as well that I can give you.

507
00:25:19,985 --> 00:25:21,525
But the actual code for this is really simple.

508
00:25:21,565 --> 00:25:24,106
I just swap a particular piece with a piece on the end,

509
00:25:24,146 --> 00:25:25,887
and then I divide the rank by i.

510
00:25:27,347 --> 00:25:30,428
So this is useful, again, going back to this COGS game

511
00:25:30,508 --> 00:25:32,429
or many of the other puzzles we might be working on.

512
00:25:32,469 --> 00:25:33,629
I'm just going to use the sliding tile

513
00:25:33,669 --> 00:25:34,589
puzzle as an example.

514
00:25:35,109 --> 00:25:36,510
What we would do for something like this

515
00:25:36,590 --> 00:25:39,551
is if we want to solve it, we need a heuristic that guides

516
00:25:39,631 --> 00:25:40,771
us towards the solution.

517
00:25:40,791 --> 00:25:42,691
And so what we're going to do is we're

518
00:25:42,711 --> 00:25:45,032
going to basically ignore most of the pieces on the board.

519
00:25:45,472 --> 00:25:47,234
Because there's far too many combinations.

520
00:25:47,634 --> 00:25:50,717
There's like 10 trillion ways that you can arrange a 15 puzzle like this.

521
00:25:51,217 --> 00:25:56,001
But I can choose a small subset of this that I can actually solve this subset very quickly.

522
00:25:56,021 --> 00:26:00,445
I can do it offline and it doesn't take very much space or even do it on an online step.

523
00:26:00,785 --> 00:26:06,590
And it's faster to do this solving all together than it is to try and solve your original problem.

524
00:26:06,610 --> 00:26:08,392
So what I do is I solve this sub-problem.

525
00:26:09,132 --> 00:26:10,693
And once I've solved this sub-problem,

526
00:26:10,713 --> 00:26:13,295
I basically, I completely solve all ways

527
00:26:13,335 --> 00:26:15,116
that I could arrange this subset of tiles.

528
00:26:15,776 --> 00:26:17,257
And then when I come into the full problem

529
00:26:17,277 --> 00:26:19,299
and I'm trying to solve it, at every location

530
00:26:19,339 --> 00:26:21,140
I look up that subset of tiles and I

531
00:26:21,200 --> 00:26:24,041
know their distance from that particular board configuration

532
00:26:24,081 --> 00:26:24,602
to the goal.

533
00:26:25,062 --> 00:26:27,083
And so that gives me a really, really good estimate

534
00:26:27,223 --> 00:26:29,845
of what is actually the optimal path going to be to the goal.

535
00:26:30,506 --> 00:26:34,130
There's a huge literature on how to do this efficiently, so I'm really just going to point

536
00:26:34,150 --> 00:26:34,730
to this here.

537
00:26:35,011 --> 00:26:37,674
I'd be glad to talk to people, in fact, about all of this stuff.

538
00:26:37,714 --> 00:26:41,758
I'd be glad to talk to people about it later, because there's just tons more I couldn't

539
00:26:41,778 --> 00:26:42,519
put in the talk here.

540
00:26:45,960 --> 00:26:51,563
Software that I've shown in the talk here is on this website, and I haven't put all the software.

541
00:26:51,603 --> 00:26:54,605
I've implemented all these things five different times in five different frameworks,

542
00:26:55,125 --> 00:26:59,948
and what I'm doing is I'm in the process of extracting it all out and giving it in very clean formats and

543
00:27:00,008 --> 00:27:03,350
efficient formats to you. So some of the software is up here already.

544
00:27:03,750 --> 00:27:05,732
I will be adding more software in the coming days.

545
00:27:06,372 --> 00:27:11,355
And this is to do permutations, k-permutations, lexicographical orderings, this merveled rescue.

546
00:27:11,655 --> 00:27:13,636
There's a number of other algorithms that will all be here.

547
00:27:13,997 --> 00:27:16,718
both for combinations, permutations, rankings, unrankings,

548
00:27:17,119 --> 00:27:20,181
and you're free to use this however you want, wherever you want,

549
00:27:20,261 --> 00:27:25,884
so no license at all, or the most unrestricted license possible on using this code.

550
00:27:25,924 --> 00:27:30,427
Basically, I want you to be able to use it and to be able to find power in using this

551
00:27:30,447 --> 00:27:33,169
to solve the problems that you have in your design spaces.

552
00:27:33,943 --> 00:27:37,204
The last thing I would just recommend, there's this good book by David Mazur.

553
00:27:37,304 --> 00:27:39,145
As I was trying to look in this space, there's just...

554
00:27:39,666 --> 00:27:41,947
the depth of the work that could be done here is incredible,

555
00:27:42,067 --> 00:27:45,288
and the amount that I know of that is a relatively small fraction.

556
00:27:46,008 --> 00:27:48,590
But this is what I've used and found really useful for my work,

557
00:27:48,990 --> 00:27:53,612
and so if you're wanting to go even farther in depth, I would recommend this book.

558
00:27:53,712 --> 00:27:57,054
And then again, this is the URL where I'll be continuing to place my software.

559
00:27:57,414 --> 00:27:57,714
Thank you.

560
00:28:07,839 --> 00:28:09,155
And I think we have time for one or two.

