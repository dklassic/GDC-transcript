1
00:00:04,113 --> 00:00:09,514
Welcome to Beyond Emitters Shader and Surface Driven GPU Particle Effects

2
00:00:09,514 --> 00:00:15,176
Techniques. This is a talk about particle effects. This talk is not just aimed at

3
00:00:15,176 --> 00:00:21,497
graphics programmers but also technical artists and VFX artists. It's very much a

4
00:00:21,497 --> 00:00:26,358
hybrid talk. So a quick intro about myself. I've been working in the game

5
00:00:26,358 --> 00:00:27,799
industry since 1994.

6
00:00:29,717 --> 00:00:34,260
Mainly as a optimization and rendering programmer for a lot of triple-A games,

7
00:00:34,260 --> 00:00:39,262
with some technical artist work on several of them.

8
00:00:39,262 --> 00:00:43,525
These days I do many roles because I'm independent,

9
00:00:43,525 --> 00:00:48,287
and I focus a lot more now on art, VFX.

10
00:00:48,992 --> 00:00:52,634
even animation and rigging, because for me,

11
00:00:52,634 --> 00:00:55,275
I feel like there's some kind of special stuff

12
00:00:55,275 --> 00:00:58,116
that sort of lies between disciplines.

13
00:00:58,116 --> 00:01:01,057
And so I really like doing a little bit

14
00:01:01,057 --> 00:01:02,237
of everything these days.

15
00:01:08,314 --> 00:01:11,395
So the agenda for this talk is, first of all,

16
00:01:11,395 --> 00:01:14,095
I'm gonna just go over quickly what the target platform

17
00:01:14,095 --> 00:01:16,416
and the design goals were.

18
00:01:16,416 --> 00:01:21,557
Basically what motivated me to focus just on particle

19
00:01:21,557 --> 00:01:24,418
related emission and effects.

20
00:01:24,418 --> 00:01:27,459
And I'll talk about some inspiration,

21
00:01:27,459 --> 00:01:30,419
and also some experimentations that I initially started with

22
00:01:30,419 --> 00:01:34,540
that worked out pretty well, but they have limitations.

23
00:01:35,728 --> 00:01:39,109
And then I'll eventually get to my sort of,

24
00:01:39,109 --> 00:01:41,330
what I call my favorite technique,

25
00:01:41,330 --> 00:01:42,630
that I feel is very robust

26
00:01:42,630 --> 00:01:44,291
and creates some pretty cool stuff.

27
00:01:44,291 --> 00:01:45,891
If you follow me on Twitter,

28
00:01:45,891 --> 00:01:47,571
you may have seen some of that.

29
00:01:47,571 --> 00:01:49,972
I'll also touch a bit on workflow and optimization,

30
00:01:49,972 --> 00:01:52,232
and at the end there'll be a question and answer.

31
00:01:52,232 --> 00:01:54,173
So the development platform in Target,

32
00:01:54,173 --> 00:01:55,953
this was decided by me a few years ago.

33
00:02:04,950 --> 00:02:06,550
DirectX 11, Shader Model 5,

34
00:02:06,550 --> 00:02:10,531
and it works with forward and deferred rendering.

35
00:02:10,531 --> 00:02:12,311
I've been using Unity for several years now,

36
00:02:12,311 --> 00:02:16,892
and so I started with way back, like Unity 4,

37
00:02:16,892 --> 00:02:20,333
and pretty much up to the current version right now.

38
00:02:20,333 --> 00:02:23,814
So a lot of this material I'm covering

39
00:02:23,814 --> 00:02:29,175
requires you to have some amount of access

40
00:02:29,175 --> 00:02:33,296
or connection to compute instance.

41
00:02:33,800 --> 00:02:37,002
and procedural drawing methods to draw a lot of this stuff

42
00:02:37,002 --> 00:02:38,963
efficiently.

43
00:02:38,963 --> 00:02:42,946
But it's adaptable to any engine and a lot of platforms.

44
00:02:42,946 --> 00:02:43,727
So design goals.

45
00:02:43,727 --> 00:02:50,611
There's many commonly supported particle emission primitives

46
00:02:50,611 --> 00:02:52,793
and many engines already.

47
00:02:52,793 --> 00:02:58,037
Points, lines, spheres, cones, and so on and so forth.

48
00:02:58,037 --> 00:03:00,578
And even meshes these days, skin meshes.

49
00:03:00,985 --> 00:03:03,407
But my frustration with particle emission from meshes

50
00:03:03,407 --> 00:03:08,291
that it's still in many engines limited to just vertices,

51
00:03:08,291 --> 00:03:11,434
edges, and random points just on top of triangles.

52
00:03:11,434 --> 00:03:16,358
So we don't really get much sort of interesting, finer

53
00:03:16,358 --> 00:03:18,940
sort of coloring or extra control.

54
00:03:18,940 --> 00:03:21,562
And if you want particles to just emit

55
00:03:21,562 --> 00:03:24,084
from, say, part of a mesh, you usually

56
00:03:24,084 --> 00:03:27,166
have to sort of chip that off into its own sub-object.

57
00:03:27,166 --> 00:03:29,709
And it's not sort of the greatest workflow,

58
00:03:29,709 --> 00:03:30,349
in my opinion.

59
00:03:35,030 --> 00:03:37,652
So a lot of my own shader work and personal style

60
00:03:37,652 --> 00:03:40,635
involves mixing animated and procedural effects.

61
00:03:40,635 --> 00:03:43,038
Things are intended to be more surreal

62
00:03:43,038 --> 00:03:45,500
or abstract looking instead of looking realistic,

63
00:03:45,500 --> 00:03:47,663
but all of this stuff I'm covering today

64
00:03:47,663 --> 00:03:49,464
could work for realistic as well.

65
00:03:50,946 --> 00:03:53,469
But personally, I really wanted these dynamic and usually

66
00:03:53,469 --> 00:03:55,571
animating shaders, because I like things moving around,

67
00:03:55,571 --> 00:03:58,754
to give birth to particles in interesting ways.

68
00:03:58,754 --> 00:04:01,217
So even if they were simply mapped on a wall

69
00:04:01,217 --> 00:04:03,419
or a simple mesh, I wanted particles

70
00:04:03,419 --> 00:04:06,082
to sort of come off of those surfaces that

71
00:04:06,082 --> 00:04:08,845
made it actually look like it was fragments of that surface

72
00:04:08,845 --> 00:04:10,107
chipping away and dissolving.

73
00:04:14,077 --> 00:04:18,040
So, to elaborate further, my ambitious goal

74
00:04:18,040 --> 00:04:19,941
is to have particles emit from literally everything

75
00:04:19,941 --> 00:04:20,541
in the world.

76
00:04:20,541 --> 00:04:22,602
That was kind of one of the core pillars

77
00:04:22,602 --> 00:04:24,624
I was working towards for my own game.

78
00:04:24,624 --> 00:04:29,186
So, for the last couple years, I've chased this goal

79
00:04:29,186 --> 00:04:33,069
to make environments, characters,

80
00:04:33,069 --> 00:04:34,430
pretty much anything you can think of

81
00:04:34,430 --> 00:04:36,611
or render on the screen emit particles.

82
00:04:36,611 --> 00:04:37,452
So how do we do that?

83
00:04:39,110 --> 00:04:41,672
I also wanted much finer detail in that expression.

84
00:04:41,672 --> 00:04:45,814
Specifically, I wanted particles to come off of objects,

85
00:04:45,814 --> 00:04:48,756
inherit the surface properties of those objects

86
00:04:48,756 --> 00:04:49,916
that spawn them.

87
00:04:49,916 --> 00:04:51,597
I wanted to paint and meshes and work

88
00:04:51,597 --> 00:04:53,698
in a very visual way and workflow.

89
00:04:53,698 --> 00:04:55,459
Make things very artist-friendly,

90
00:04:55,459 --> 00:04:58,761
instead of lots of numbers and sliders and a property panel.

91
00:04:58,761 --> 00:04:58,801
So.

92
00:05:04,497 --> 00:05:09,040
In our industry, there's a general avoidance to discuss failure or even talk about the

93
00:05:09,040 --> 00:05:17,206
small steps that we take as we move towards our super big huge dream goals. Not everything is an

94
00:05:17,206 --> 00:05:23,450
explosive breakthrough. We usually present a lot of material. At talks and conferences,

95
00:05:23,450 --> 00:05:27,794
sort of like, hey, this is all done, this works, like, go and use it, it's awesome. But I

96
00:05:27,794 --> 00:05:33,598
think there's a lot of material that sort of, you know, works 90% of the time or it's

97
00:05:34,302 --> 00:05:36,223
If you're aware of the special cases,

98
00:05:36,223 --> 00:05:38,944
this stuff is actually very valuable to other developers.

99
00:05:38,944 --> 00:05:42,766
I really wish we would sort of share more of that stuff.

100
00:05:42,766 --> 00:05:45,267
So in this presentation, I'm gonna cover

101
00:05:45,267 --> 00:05:48,429
some of those things that are,

102
00:05:48,429 --> 00:05:52,631
don't really work for my game, but depending on your game

103
00:05:52,631 --> 00:05:55,532
and your camera view and performance

104
00:05:55,532 --> 00:05:56,352
and other things like that,

105
00:05:56,352 --> 00:06:01,735
you may find some inspiration or ideas to chase yourself.

106
00:06:05,902 --> 00:06:10,784
So looking back, I would say this is the original seed

107
00:06:10,784 --> 00:06:13,565
of the idea of wanting to spawn particles from everything.

108
00:06:13,565 --> 00:06:16,006
This is a really old demo from Unity

109
00:06:16,006 --> 00:06:19,088
when they started supporting DirectX 11.

110
00:06:19,088 --> 00:06:22,970
But it basically just renders an image

111
00:06:22,970 --> 00:06:27,272
and looks at the bright parts and draws little sprite flares.

112
00:06:27,272 --> 00:06:29,513
And I thought, well, that'd be cool

113
00:06:29,513 --> 00:06:30,873
if it spawned particles instead.

114
00:06:30,873 --> 00:06:33,555
And they sort of flew off instead of it just being like.

115
00:06:34,066 --> 00:06:36,608
draw stars on the shiny parts of objects.

116
00:06:36,608 --> 00:06:38,369
So a number of view-dependent experiments

117
00:06:38,369 --> 00:06:41,370
I'll cover now.

118
00:06:41,370 --> 00:06:45,653
So these experiments only work

119
00:06:45,653 --> 00:06:47,714
within the view of the camera.

120
00:06:47,714 --> 00:06:51,236
But they create some interesting effects

121
00:06:51,236 --> 00:06:53,538
that may be of use for certain games

122
00:06:53,538 --> 00:06:55,799
or have specific use cases that work

123
00:06:55,799 --> 00:06:56,680
within those constraints.

124
00:07:01,327 --> 00:07:04,128
So the first one I made after looking at the original sample

125
00:07:04,128 --> 00:07:08,869
that was the seed of the idea was the particle collector.

126
00:07:08,869 --> 00:07:12,191
It was to just take your Z-prepass

127
00:07:12,191 --> 00:07:14,172
and render the mesh interception objects

128
00:07:14,172 --> 00:07:17,293
against that depth and just mark them into a render target.

129
00:07:17,293 --> 00:07:19,954
And I like this because there's actually

130
00:07:19,954 --> 00:07:22,475
sort of an upper bound on how many particles

131
00:07:22,475 --> 00:07:23,755
you can potentially emit.

132
00:07:23,755 --> 00:07:28,097
Because for any given XY coordinate,

133
00:07:28,097 --> 00:07:28,897
you're a render target.

134
00:07:29,359 --> 00:07:31,180
you're only emitting one place there.

135
00:07:31,180 --> 00:07:37,023
So if you had, say, a wall and a bunch of decals

136
00:07:37,023 --> 00:07:41,465
or something covering it, you're not

137
00:07:41,465 --> 00:07:43,346
going to just draw tons and tons of them.

138
00:07:43,346 --> 00:07:48,749
So to discuss more in this one, so there's basically

139
00:07:48,749 --> 00:07:50,530
a full screen pass at the end.

140
00:07:50,530 --> 00:07:55,553
And we just look at the parts that we marked of interest

141
00:07:55,553 --> 00:07:58,935
and write out in the fragment shader at this.

142
00:07:59,288 --> 00:08:02,493
at this point to in a PEM buffer those particle positions

143
00:08:02,493 --> 00:08:05,457
because we reconstruct the world space position

144
00:08:05,457 --> 00:08:08,362
from the copy of the depth and the marked pixels

145
00:08:08,362 --> 00:08:09,103
in the render target.

146
00:08:09,103 --> 00:08:13,770
And then this feeds into the particle,

147
00:08:13,770 --> 00:08:15,472
our GPU particle engine.

148
00:08:19,814 --> 00:08:23,737
So here's a demo of one of my first experiments.

149
00:08:23,737 --> 00:08:27,040
So this is a depth intersection.

150
00:08:27,040 --> 00:08:30,282
There's the top left, the debug view of the render target.

151
00:08:30,282 --> 00:08:32,764
So where the intersection of those mesh objects

152
00:08:32,764 --> 00:08:37,067
and the depth happens, I just had to spawn particles there.

153
00:08:37,067 --> 00:08:39,249
So this is pretty fun.

154
00:08:39,249 --> 00:08:41,991
And I had tons and tons of ideas with this.

155
00:08:41,991 --> 00:08:45,514
You can have a water plane intersect geometry

156
00:08:45,514 --> 00:08:46,915
or all kinds of things.

157
00:08:48,263 --> 00:08:51,906
And I played around with this quite a lot and had a lot of fun.

158
00:08:51,906 --> 00:08:55,629
But this creates some pretty interesting effects,

159
00:08:55,629 --> 00:08:57,571
but we're dealing with a view-dependent approach here.

160
00:08:57,571 --> 00:09:00,893
So as faces become thin and edge-on to the view,

161
00:09:00,893 --> 00:09:03,375
we have fewer and fewer samples.

162
00:09:03,375 --> 00:09:06,678
And eventually, it becomes fully edge-on or back-facing.

163
00:09:06,678 --> 00:09:07,258
We get nothing.

164
00:09:09,123 --> 00:09:11,165
So, here in the highlighted red areas,

165
00:09:11,165 --> 00:09:15,129
there's a difference in actual volume of the particles.

166
00:09:15,129 --> 00:09:17,091
So, we have some problems with things sort of

167
00:09:17,091 --> 00:09:19,894
flattening out or entirely disappearing.

168
00:09:19,894 --> 00:09:24,879
So, one way to think of this is that

169
00:09:24,879 --> 00:09:27,542
every single pixel is a particle emitter.

170
00:09:28,290 --> 00:09:30,310
It doesn't have to emit just one,

171
00:09:30,310 --> 00:09:31,750
it could emit as many as we want.

172
00:09:31,750 --> 00:09:35,731
It's just we have to write that in the fragment shader.

173
00:09:35,731 --> 00:09:39,432
So less visible pixels equals less spawned particles.

174
00:09:39,432 --> 00:09:42,293
So with the limited depth information

175
00:09:42,293 --> 00:09:45,734
for the surfaces perpendicular to the camera view,

176
00:09:45,734 --> 00:09:48,574
it's causing the effect to break down.

177
00:09:48,574 --> 00:09:53,035
So large gaps appear if we swing the camera around

178
00:09:53,035 --> 00:09:54,896
to the side in a scene view or something

179
00:09:54,896 --> 00:09:56,736
detached from the normal rendered view.

180
00:09:57,818 --> 00:10:02,160
So on the left, we see these sort of scraped out

181
00:10:02,160 --> 00:10:02,780
or sort of gaps.

182
00:10:02,780 --> 00:10:06,901
Kind of reminds me of shadow mapping acne or something

183
00:10:06,901 --> 00:10:10,243
because we're out of samples here.

184
00:10:10,243 --> 00:10:13,764
So we don't have much to work with, so how do we fix this?

185
00:10:13,764 --> 00:10:19,346
So I'm quite a fan of workarounds or

186
00:10:20,974 --> 00:10:27,881
gentle hacks. So we can patch this with some extra things such as extra particle emission

187
00:10:27,881 --> 00:10:33,146
actually if it starts to go edge on. And then also add some world space jitter on top of

188
00:10:33,146 --> 00:10:38,252
the samples that we actually have that are valid. So this is kind of a way to sort of

189
00:10:38,252 --> 00:10:38,532
fill in the gaps.

190
00:10:41,015 --> 00:10:43,196
And the way we can detect this is obviously

191
00:10:43,196 --> 00:10:48,439
for a given sample, we know what the surface normal

192
00:10:48,439 --> 00:10:50,981
is relative to the eye view direction.

193
00:10:50,981 --> 00:10:54,003
Now if we're doing faster or burst particle effects

194
00:10:54,003 --> 00:10:56,164
or layering this with other effects

195
00:10:56,164 --> 00:10:57,565
that aren't view dependent,

196
00:10:57,565 --> 00:11:00,767
a lot of these shortcomings we can kind of ignore.

197
00:11:00,767 --> 00:11:03,669
It's just then, like this is just a little extra

198
00:11:03,669 --> 00:11:04,610
VFX frosting on the cake.

199
00:11:10,310 --> 00:11:13,251
So although the single collector path can create

200
00:11:13,251 --> 00:11:15,152
some small particles based on depth intersection

201
00:11:15,152 --> 00:11:17,053
between a mesh and scene depth,

202
00:11:17,053 --> 00:11:19,674
we're explicitly marking pixels with shaders.

203
00:11:19,674 --> 00:11:21,895
I still needed GPU particle emission from mesh data

204
00:11:21,895 --> 00:11:22,796
that wouldn't require a Z-prepass,

205
00:11:22,796 --> 00:11:23,596
and I didn't want to require

206
00:11:23,596 --> 00:11:24,777
some strict draw ordering rules.

207
00:11:24,777 --> 00:11:25,537
So on the left image here,

208
00:11:25,537 --> 00:11:27,518
there's several mesh objects rendered into the scene.

209
00:11:36,365 --> 00:11:39,567
Each object has extra code in its fragment shader program

210
00:11:39,567 --> 00:11:43,350
to write out particle emission positions in world space

211
00:11:43,350 --> 00:11:47,093
into the append buffer that feeds the GPU particle system.

212
00:11:47,093 --> 00:11:49,795
The image on the right side is an editor view,

213
00:11:49,795 --> 00:11:53,498
again, of the same scene where I've swung the camera around

214
00:11:53,498 --> 00:11:55,340
to see what's going on on the faces we can't see.

215
00:11:55,340 --> 00:12:00,704
So we have, in this case, back face and edge on

216
00:12:00,704 --> 00:12:02,846
still not emitting, which is problematic.

217
00:12:03,888 --> 00:12:08,812
Now we can do some tricks here with turning off backface calling and manually

218
00:12:08,812 --> 00:12:13,135
discarding in the fragment shader those backfaces and get at least front and

219
00:12:13,135 --> 00:12:17,379
backface admission. But we're not handling the case of things being edge on still.

220
00:12:17,379 --> 00:12:21,222
And although I was really happy with this effect, I was really frustrated because it

221
00:12:21,222 --> 00:12:25,426
wasn't quite robust enough for my needs. So I wasn't quite done exploring this

222
00:12:33,131 --> 00:12:36,353
view-dependent stuff in spite of its limitations.

223
00:12:36,353 --> 00:12:38,835
And so my next experiment was to combine

224
00:12:38,835 --> 00:12:41,236
screen space deferred decals with a fragment shader

225
00:12:41,236 --> 00:12:42,937
driving particle emission.

226
00:12:42,937 --> 00:12:45,539
So here in the video I have a blue decal star

227
00:12:45,539 --> 00:12:47,960
like just mapped on the ground with a split across it

228
00:12:47,960 --> 00:12:49,942
where it obviously should not emit

229
00:12:49,942 --> 00:12:52,603
because it's not intersecting the deferred decal.

230
00:12:52,603 --> 00:12:55,085
So where the positions of the star are visible

231
00:12:55,085 --> 00:12:57,166
are also positions that are valid

232
00:12:57,166 --> 00:12:58,507
for spawning those particles.

233
00:13:00,089 --> 00:13:02,911
This effect, I like it a lot because it's, again,

234
00:13:02,911 --> 00:13:07,315
something you could layer with specific hits,

235
00:13:07,315 --> 00:13:11,038
like bullet hits, ricochets, sort of anything

236
00:13:11,038 --> 00:13:12,840
you can think of.

237
00:13:12,840 --> 00:13:16,863
Now again, with this particular implementation,

238
00:13:16,863 --> 00:13:18,925
I made two variations.

239
00:13:18,925 --> 00:13:23,368
One, basically wrote everything into a single target

240
00:13:23,368 --> 00:13:25,290
so I wouldn't get double emission in case

241
00:13:25,290 --> 00:13:26,871
the decals overlapped.

242
00:13:26,871 --> 00:13:27,232
And then.

243
00:13:27,578 --> 00:13:29,720
another one where I just continually wrote out to the append buffer as I drew each decal,

244
00:13:29,720 --> 00:13:30,440
which would allow overlapping.

245
00:13:30,440 --> 00:13:32,561
So to summarize some important points about these techniques so far, at this point I had

246
00:13:32,561 --> 00:13:34,222
particles can emit from anything I draw into the screen, as long as it's in the render

247
00:13:34,222 --> 00:13:34,642
target, which is great.

248
00:13:34,642 --> 00:13:35,263
The pro and the con of this is that

249
00:13:57,852 --> 00:14:01,856
The density is dependent on pixel screen coverage.

250
00:14:01,856 --> 00:14:06,720
So we're using the existing meshes to drive all this.

251
00:14:06,720 --> 00:14:09,883
So as we draw an object to normally see it in our game

252
00:14:09,883 --> 00:14:12,506
view, we can attach this extra work

253
00:14:12,506 --> 00:14:14,848
in the fragment shader of writing

254
00:14:14,848 --> 00:14:17,610
into an append buffer structure to spawn particles

255
00:14:17,610 --> 00:14:20,253
so we don't have to have a separate draw.

256
00:14:22,757 --> 00:14:26,839
We can draw the back faces and do some tricks

257
00:14:26,839 --> 00:14:30,561
to make the back faces emit.

258
00:14:30,561 --> 00:14:35,003
And we still have the problems with partial and off-screen

259
00:14:35,003 --> 00:14:39,625
meshes not quite behaving as they should if we ever rotate

260
00:14:39,625 --> 00:14:41,126
or move the camera around.

261
00:14:41,126 --> 00:14:45,528
So this has some very limited uses, unfortunately.

262
00:14:45,528 --> 00:14:48,029
But depending on the context of your game,

263
00:14:48,029 --> 00:14:51,651
the type of your game, how you use your camera in your game.

264
00:14:52,253 --> 00:14:55,835
these could be of use to you.

265
00:14:55,835 --> 00:14:56,215
So to continue on,

266
00:14:56,215 --> 00:15:04,801
to elaborate more with the fragment shader stuff,

267
00:15:04,801 --> 00:15:10,844
writing to the pen buffer, we can do like dissolves

268
00:15:10,844 --> 00:15:14,307
and material specific stuff already that.

269
00:15:14,828 --> 00:15:18,632
transfers those material attributes to those shaders.

270
00:15:18,632 --> 00:15:22,215
So if we shade a blue triangle or a blue pattern

271
00:15:22,215 --> 00:15:25,318
or whatever, those particles that come from that

272
00:15:25,318 --> 00:15:26,419
can get those colors.

273
00:15:26,419 --> 00:15:30,943
It really depends on what you put into your pen buffer

274
00:15:30,943 --> 00:15:35,507
structure when you are going to pass that data to the GPU.

275
00:15:35,507 --> 00:15:36,848
Normally, at the bare minimum, you

276
00:15:36,848 --> 00:15:38,990
want world position and color.

277
00:15:38,990 --> 00:15:40,692
But you can add as many parameters

278
00:15:40,692 --> 00:15:41,813
as you would like to that.

279
00:15:51,315 --> 00:15:55,058
So, there's a lot of possibilities here for visual effects

280
00:15:55,058 --> 00:15:57,900
if the limitations of the technique are acceptable

281
00:15:57,900 --> 00:15:59,602
and can be worked around depending on the game

282
00:15:59,602 --> 00:16:00,883
and how it uses its camera.

283
00:16:00,883 --> 00:16:03,965
In the interest of pushing this technique even further

284
00:16:03,965 --> 00:16:05,246
and working around its limitations,

285
00:16:05,246 --> 00:16:08,489
there's some more ideas to consider,

286
00:16:08,489 --> 00:16:11,191
such as adjusting the camera FOV,

287
00:16:11,191 --> 00:16:13,552
using an explicit separate render pass,

288
00:16:13,552 --> 00:16:17,215
using a higher resolution render target if you do so

289
00:16:17,215 --> 00:16:20,498
to get even better coverage and sampling.

290
00:16:21,914 --> 00:16:26,936
If you did VR or something and you just allowed rotational pivoting, you could render into

291
00:16:26,936 --> 00:16:31,377
a cube map and handle those cases fairly easily.

292
00:16:31,377 --> 00:16:37,680
If it's in a separate pass, we can add some kind of temporal jittering to that camera

293
00:16:37,680 --> 00:16:44,163
to improve and catch samples in case you have very thin geometry that you want to have emitting

294
00:16:44,163 --> 00:16:44,643
stuff.

295
00:16:44,643 --> 00:16:50,865
And then finally, we can get fancy and look at our camera and see where it's going and

296
00:16:51,414 --> 00:16:55,198
somewhat fix the edge on problem by looking ahead.

297
00:16:55,198 --> 00:16:57,480
So if you're heading towards to look around the corner,

298
00:16:57,480 --> 00:17:01,405
your extra pass will have the camera already ahead

299
00:17:01,405 --> 00:17:02,606
and looking there.

300
00:17:02,606 --> 00:17:06,611
So you can get some particles spawned ahead of time

301
00:17:06,611 --> 00:17:10,575
before you see the effect break down a little bit.

302
00:17:14,499 --> 00:17:17,661
So in this section, I will cover object space particle

303
00:17:17,661 --> 00:17:18,301
emission.

304
00:17:18,301 --> 00:17:20,083
This is a more general purpose approach,

305
00:17:20,083 --> 00:17:22,304
and it's much better suited for all game types.

306
00:17:22,304 --> 00:17:25,206
Although I really like the view-dependent stuff

307
00:17:25,206 --> 00:17:28,729
for particle emission, building an entire game

308
00:17:28,729 --> 00:17:31,111
around the concept of everything that can make particles

309
00:17:31,111 --> 00:17:35,754
necessitates an object space approach that's

310
00:17:35,754 --> 00:17:38,997
robust enough to handle a third or first person game,

311
00:17:38,997 --> 00:17:42,099
moving around and then looking everywhere and moving quickly.

312
00:17:47,449 --> 00:17:49,711
So, after a lot of experiments,

313
00:17:49,711 --> 00:17:53,815
this is sort of what I came to to solve my problem.

314
00:17:53,815 --> 00:17:56,657
And so I call it Unfolded Mesh Shader Particle Emission.

315
00:17:56,657 --> 00:18:00,000
And a very extreme simplification of that is

316
00:18:00,000 --> 00:18:04,464
I basically unfold every single triangle off of the mesh,

317
00:18:04,464 --> 00:18:07,687
and then I shade it with a GPU to see what it looks like,

318
00:18:07,687 --> 00:18:11,710
and then I drive the particle emission from that.

319
00:18:11,710 --> 00:18:13,772
And this uses the GPU rasterizer.

320
00:18:15,732 --> 00:18:19,356
But there's a lot of important details to this technique,

321
00:18:19,356 --> 00:18:21,439
and doing it right, and getting it to run fast.

322
00:18:21,439 --> 00:18:24,803
So this is where I start my deep dive and get really

323
00:18:24,803 --> 00:18:28,988
technical regarding the algorithm, and also the flow of

324
00:18:28,988 --> 00:18:32,433
the data as it passes through the GPU pipeline.

325
00:18:38,823 --> 00:18:41,625
So a couple important points to just reinforce

326
00:18:41,625 --> 00:18:42,946
before I do that.

327
00:18:42,946 --> 00:18:44,588
This is view independent.

328
00:18:44,588 --> 00:18:48,611
It supports variable topology, sampling density,

329
00:18:48,611 --> 00:18:50,653
shader effects for every single triangle,

330
00:18:50,653 --> 00:18:53,475
every single draw call, every single instance.

331
00:18:53,475 --> 00:18:57,358
I assume no input topology and,

332
00:18:57,358 --> 00:18:59,920
I assume that the input topology

333
00:18:59,920 --> 00:19:01,902
and the shading is fully dynamic

334
00:19:01,902 --> 00:19:04,484
because I don't want to bake anything.

335
00:19:04,484 --> 00:19:06,125
I want everything to be dynamic.

336
00:19:06,970 --> 00:19:09,372
It's non-negotiable for me.

337
00:19:09,372 --> 00:19:17,057
So there's no caching or pre-computation, no baking.

338
00:19:17,057 --> 00:19:17,898
I hate it.

339
00:19:17,898 --> 00:19:18,618
I don't want that.

340
00:19:18,618 --> 00:19:27,924
So we need a few essential ingredients to get this working.

341
00:19:27,924 --> 00:19:31,967
So we need a render target for rasterization.

342
00:19:31,967 --> 00:19:35,049
The one that we have bound normally to render the game

343
00:19:35,049 --> 00:19:36,190
will suffice.

344
00:19:37,141 --> 00:19:40,122
We need an append buffer that's going to store

345
00:19:40,122 --> 00:19:44,405
the particle data when we decide we need to spawn particles

346
00:19:44,405 --> 00:19:47,026
on these triangle surfaces somewhere.

347
00:19:47,026 --> 00:19:50,828
And then all the bindings and uniforms and constant buffers

348
00:19:50,828 --> 00:19:54,370
and so on and so forth for drawing the mesh normally.

349
00:19:54,370 --> 00:19:56,571
We can just use that information.

350
00:19:56,571 --> 00:20:01,674
We actually want that because we want visual parity with

351
00:20:02,386 --> 00:20:04,808
what we render on the screen, what we show the player

352
00:20:04,808 --> 00:20:08,491
versus what we calculate when we want to emit particles.

353
00:20:08,491 --> 00:20:11,494
So, with that in mind, there's three important

354
00:20:11,494 --> 00:20:16,298
minimal sort of components to get this technique to work.

355
00:20:16,298 --> 00:20:19,261
So we need a vertex shader, a geometry shader,

356
00:20:19,261 --> 00:20:21,803
and a fragment, also known as pixel shader.

357
00:20:24,812 --> 00:20:28,598
So unfolding the mesh, the first stop is the vertex shader.

358
00:20:28,598 --> 00:20:32,045
So we need to compute the world space position

359
00:20:32,045 --> 00:20:34,409
of these vertices and we need to store them

360
00:20:34,409 --> 00:20:36,533
to the output structure that is going to flow.

361
00:20:37,458 --> 00:20:40,579
through the geometry shader and down to the fragment shader.

362
00:20:40,579 --> 00:20:44,060
This is important to do this to basically solve

363
00:20:44,060 --> 00:20:45,780
for the world space position of the geometry

364
00:20:45,780 --> 00:20:50,601
because this becomes our sort of baseline scale

365
00:20:50,601 --> 00:20:55,803
for once we need to determine what the sampling density

366
00:20:55,803 --> 00:20:58,823
is for determining particle emission.

367
00:20:58,823 --> 00:21:02,364
So we want a unified sort of scale to be in place for that.

368
00:21:03,641 --> 00:21:08,244
So, and then the SP position data obviously is going to be,

369
00:21:08,244 --> 00:21:13,088
those are the points we're going to manipulate

370
00:21:13,088 --> 00:21:19,112
to make sure that the GPU shades the topology correctly

371
00:21:19,112 --> 00:21:23,656
so we can do the particle emission determination correctly

372
00:21:23,656 --> 00:21:25,877
in the fragment shader when we get to that part.

373
00:21:29,088 --> 00:21:30,829
So an important problem to be solved is that

374
00:21:30,829 --> 00:21:33,330
if the bare minimum implementation of particle emission

375
00:21:33,330 --> 00:21:37,332
from a mesh is just three vertex positions,

376
00:21:37,332 --> 00:21:43,994
in case you want to dynamically triplanar texture an object

377
00:21:43,994 --> 00:21:45,515
or for some other reason.

378
00:21:45,808 --> 00:21:49,670
how do we determine the sampling chart and density for those triangles? How do we do it

379
00:21:49,670 --> 00:21:55,152
on a GPU? How do we make it fast? This is a complex problem space. There's a lot of

380
00:21:55,152 --> 00:22:01,214
research done. I originally thought I would need to create a unique parameterization. That

381
00:22:01,214 --> 00:22:08,977
got really scary. And so, yeah, thankfully I don't need to do any of that. So that was not

382
00:22:08,977 --> 00:22:11,918
the path I wanted to go down anyway. It seemed way more complex.

383
00:22:13,777 --> 00:22:15,337
So I needed something that would be fast,

384
00:22:15,337 --> 00:22:17,958
that would still give me the sampling density I needed

385
00:22:17,958 --> 00:22:20,018
for the triangles in object space,

386
00:22:20,018 --> 00:22:21,338
based on their world space size,

387
00:22:21,338 --> 00:22:23,319
after the visual effects and skinning

388
00:22:23,319 --> 00:22:24,539
modified the vertex positions.

389
00:22:24,539 --> 00:22:26,880
So if you had any squash and stretch,

390
00:22:26,880 --> 00:22:30,081
or grass, wind wave, wiggle, shaders,

391
00:22:30,081 --> 00:22:33,462
or anything happening, I wanted to account for that also.

392
00:22:36,700 --> 00:22:38,762
So it then dawned on me that I could completely

393
00:22:38,762 --> 00:22:40,704
avoid a majority of the problems with traditional UV

394
00:22:40,704 --> 00:22:43,226
atlas and sample generation and complex

395
00:22:43,226 --> 00:22:44,467
charting for my use case.

396
00:22:44,467 --> 00:22:47,730
All we need to do is just solve this problem for each

397
00:22:47,730 --> 00:22:48,791
triangle in isolation.

398
00:22:48,791 --> 00:22:51,873
We don't need to care about whatever is going on with its

399
00:22:51,873 --> 00:22:52,714
neighbors.

400
00:22:52,714 --> 00:22:54,976
We don't need to worry about stretching or distortion.

401
00:22:54,976 --> 00:22:59,119
We're not trying to sort of peel an orange here and then

402
00:22:59,119 --> 00:23:02,502
nicely chart it without squishing

403
00:23:02,502 --> 00:23:03,283
triangles or anything.

404
00:23:05,715 --> 00:23:09,957
So to properly unfold and generate a sampling grid,

405
00:23:09,957 --> 00:23:11,698
I decided to use the geometry shader.

406
00:23:11,698 --> 00:23:16,141
These things, some people find this objectionable,

407
00:23:16,141 --> 00:23:17,202
but it's actually really fast.

408
00:23:18,739 --> 00:23:22,522
So it's important to reiterate that I didn't want to rely

409
00:23:22,522 --> 00:23:24,143
on any pre-computed data whatsoever.

410
00:23:24,143 --> 00:23:27,866
It would have been easy to sort of pre-compute

411
00:23:27,866 --> 00:23:30,728
a unique parameterization of UV data,

412
00:23:30,728 --> 00:23:34,250
pre-compute some kind of sampling density ahead of time,

413
00:23:34,250 --> 00:23:36,092
but again, I wanted everything dynamic.

414
00:23:36,092 --> 00:23:37,273
I didn't want to rely on extra data.

415
00:23:37,273 --> 00:23:39,334
So to solve this problem one triangle at a time,

416
00:23:46,296 --> 00:23:48,617
For each triangle, I auto UV map it, basically,

417
00:23:48,617 --> 00:23:51,039
just flattening it based on its world space size

418
00:23:51,039 --> 00:23:53,681
into the currently bound render target device space.

419
00:23:53,681 --> 00:23:56,642
To make sure each triangle lies completely

420
00:23:56,642 --> 00:24:00,865
within the rasterizable space of the bound render target,

421
00:24:00,865 --> 00:24:07,429
so we don't clip it with a guard band or any kind of clipping,

422
00:24:07,429 --> 00:24:10,191
we need to apply an offset translation to it

423
00:24:10,191 --> 00:24:14,033
to make sure the GPU sees the whole thing.

424
00:24:14,988 --> 00:24:16,949
The easiest way to do this is I just calculated

425
00:24:16,949 --> 00:24:18,610
the centroid of each triangle and figured out

426
00:24:18,610 --> 00:24:21,092
the offset relative to the center of the render target

427
00:24:21,092 --> 00:24:23,594
and just slid it to the center.

428
00:24:23,594 --> 00:24:26,536
So when I do this, I get every single triangle in the mesh

429
00:24:26,536 --> 00:24:30,339
sort of thrown into the center in a little crazy little star,

430
00:24:30,339 --> 00:24:30,939
starburst kind of shape.

431
00:24:30,939 --> 00:24:34,241
So after calculating the unfolded triangle and charting it

432
00:24:34,241 --> 00:24:36,463
so it's centered into this render target,

433
00:24:36,463 --> 00:24:39,505
we can output this triangle to visually debug

434
00:24:39,505 --> 00:24:42,707
its correctness and make sure we accounted for.

435
00:24:43,853 --> 00:24:47,674
Some things that we may overlook, such as render target aspect ratio.

436
00:24:47,674 --> 00:24:50,936
And other things such as face winding order and so on.

437
00:24:50,936 --> 00:24:57,158
But face winding is usually correct as it comes in, so you don't need to worry about

438
00:24:57,158 --> 00:24:57,278
that.

439
00:24:57,278 --> 00:25:02,921
But again, it's super easy to visually debug this by just getting this part working and

440
00:25:02,921 --> 00:25:06,782
seeing the triangles in the render target somewhere.

441
00:25:06,782 --> 00:25:09,943
As long as they're within the rectangle somewhere, you're fine.

442
00:25:11,731 --> 00:25:14,833
It's also important in my implementation at least

443
00:25:14,833 --> 00:25:17,374
to set the depth of the primitive to the near clip plane

444
00:25:17,374 --> 00:25:19,215
in case we have a depth render target active

445
00:25:19,215 --> 00:25:23,497
or some kind of high Z or something going on with the GPU

446
00:25:23,497 --> 00:25:26,899
that could potentially basically snipe those triangles

447
00:25:26,899 --> 00:25:29,740
from ever going down to the fragment shader stage

448
00:25:29,740 --> 00:25:31,161
where we are trying to actually call

449
00:25:31,161 --> 00:25:34,343
and write into an append buffer and spawn these particles.

450
00:25:34,343 --> 00:25:35,904
So it's okay if these triangles overlap,

451
00:25:42,556 --> 00:25:44,536
unlike normal UV mapping.

452
00:25:44,536 --> 00:25:47,877
So why that works, I'll get into it later.

453
00:25:47,877 --> 00:25:49,778
So now that we have these unfolded triangles

454
00:25:49,778 --> 00:25:54,279
in the valid render target area where the GPU sees them,

455
00:25:54,279 --> 00:25:57,559
they'll cause the fragment shader to run,

456
00:25:57,559 --> 00:25:59,960
but we need to talk about the sampling density.

457
00:25:59,960 --> 00:26:03,260
Depending on the textures and the shader effect applied

458
00:26:03,260 --> 00:26:07,041
made by the artist, we may want an extremely high

459
00:26:07,041 --> 00:26:08,142
or very low density.

460
00:26:09,227 --> 00:26:13,148
So it really depends on what your textures look like

461
00:26:13,148 --> 00:26:16,309
or what the effect is and whether you want to emit

462
00:26:16,309 --> 00:26:18,549
a lot of particles or small amounts.

463
00:26:18,549 --> 00:26:23,390
So that's one thing to consider at this point.

464
00:26:23,390 --> 00:26:26,851
So for every pixel, the triangle covers the pixel center,

465
00:26:26,851 --> 00:26:30,292
satisfying the rasterization rules of the GPU,

466
00:26:30,292 --> 00:26:32,052
saying, hey, we need to shade this pixel.

467
00:26:33,503 --> 00:26:36,546
Fragment shader executes, the GPU will shade that portion

468
00:26:36,546 --> 00:26:38,448
of the triangle in a similar manner to how it draws

469
00:26:38,448 --> 00:26:40,209
the model normally for the game.

470
00:26:40,209 --> 00:26:45,755
So at this point, we get exactly the same shading

471
00:26:45,755 --> 00:26:48,437
that we would normally get on an object

472
00:26:48,437 --> 00:26:49,759
when we draw it in the game.

473
00:26:49,759 --> 00:26:52,822
So these shading results are then combined

474
00:26:52,822 --> 00:26:54,804
with additional shader code to determine

475
00:26:54,804 --> 00:26:57,866
if that position should emit a particle or not.

476
00:27:00,882 --> 00:27:04,483
Now, to improve the coverage of the sampling,

477
00:27:04,483 --> 00:27:11,565
especially in cases where you want to use a small triangle

478
00:27:11,565 --> 00:27:13,425
for performance reasons or...

479
00:27:13,425 --> 00:27:16,867
So, for each frame and each triangle,

480
00:27:16,867 --> 00:27:18,527
I add a random subpixel offset

481
00:27:18,527 --> 00:27:20,768
to all the vertices of that triangle.

482
00:27:20,768 --> 00:27:22,008
So we're starting to jitter,

483
00:27:22,008 --> 00:27:23,328
and that moves the grid around

484
00:27:23,328 --> 00:27:25,129
and moves the samples we get.

485
00:27:26,502 --> 00:27:29,305
The random jittering is important for improving

486
00:27:29,305 --> 00:27:32,968
the sampling, especially for static objects,

487
00:27:32,968 --> 00:27:36,111
such as world, your world, or level geometry.

488
00:27:36,111 --> 00:27:40,735
The reason being is when we take those

489
00:27:40,735 --> 00:27:44,538
static objects and we chart them into this space,

490
00:27:44,538 --> 00:27:47,040
they'll always end up in the exact same space,

491
00:27:47,040 --> 00:27:49,482
and then you get the same sampling points,

492
00:27:49,482 --> 00:27:52,325
which is what you don't want, and if your triangles

493
00:27:52,325 --> 00:27:54,067
are small, this is even more obvious.

494
00:27:56,387 --> 00:27:58,487
So adding the jitter, constantly jittering

495
00:27:58,487 --> 00:28:01,668
every single triangle, every single frame,

496
00:28:01,668 --> 00:28:04,829
fixes that problem and lets you use a smaller triangle.

497
00:28:04,829 --> 00:28:09,270
So in addition to adding the random subpixel offset

498
00:28:09,270 --> 00:28:12,010
to the triangle vertices, we can also effectively

499
00:28:12,010 --> 00:28:14,171
rotate the grid that we're sampling from

500
00:28:14,171 --> 00:28:15,851
by just rotating the triangle.

501
00:28:15,851 --> 00:28:20,832
This jittering is done for every triangle,

502
00:28:20,832 --> 00:28:22,733
again, 60 to 120 times a second

503
00:28:22,733 --> 00:28:25,153
to ensure varied sampling from different locations.

504
00:28:26,206 --> 00:28:29,988
that are also valid within the bounds of that triangle.

505
00:28:29,988 --> 00:28:34,389
So now that we have this, another step we can add

506
00:28:34,389 --> 00:28:37,091
is that we can adjust the size of this triangle area

507
00:28:37,091 --> 00:28:38,951
by uniformly scaling it.

508
00:28:38,951 --> 00:28:42,253
So this increases or decreases the scaling footprint.

509
00:28:42,253 --> 00:28:46,394
This is something you could also tune for VFX reasons.

510
00:28:46,394 --> 00:28:48,775
In the case of very few particles needing

511
00:28:48,775 --> 00:28:50,896
to be omit from every frame, you can actually

512
00:28:50,896 --> 00:28:52,997
make these triangles very small.

513
00:28:53,593 --> 00:28:57,855
So a lot of the stuff I do, they're like eight by eight

514
00:28:57,855 --> 00:28:58,776
pixels or even smaller.

515
00:28:58,776 --> 00:29:02,098
For cases when you require a burst emission

516
00:29:02,098 --> 00:29:05,680
of a ton of particles, extremely high number,

517
00:29:05,680 --> 00:29:08,382
or you need fine detailed sampling,

518
00:29:08,382 --> 00:29:11,224
then you would scale the triangles up.

519
00:29:11,224 --> 00:29:12,364
So if you wrote your name on a wall

520
00:29:12,364 --> 00:29:15,086
and you wanted a burst of several thousand particles

521
00:29:15,086 --> 00:29:16,827
to come out perfectly shaped as your name,

522
00:29:16,827 --> 00:29:18,928
then you would want these triangles to be larger

523
00:29:18,928 --> 00:29:20,129
because then you would get more samples

524
00:29:20,129 --> 00:29:22,410
and you would get more accuracy where you need it.

525
00:29:26,142 --> 00:29:28,924
So, with our triangle jittered scaled,

526
00:29:28,924 --> 00:29:32,148
we can proceed to the final fragment shading stage

527
00:29:32,148 --> 00:29:32,528
of the triangles.

528
00:29:32,528 --> 00:29:38,034
So the shader code in general will look exactly like

529
00:29:38,034 --> 00:29:40,737
the shader that you use to draw your object,

530
00:29:40,737 --> 00:29:43,880
but you're gonna add just a few extra things into it.

531
00:29:43,880 --> 00:29:46,723
Specifically determining

532
00:29:48,798 --> 00:29:51,200
how many samples or if that sample,

533
00:29:51,200 --> 00:29:56,262
based on a random dice roll or some artist tuning value,

534
00:29:56,262 --> 00:29:58,384
whether it should emit or not.

535
00:29:58,384 --> 00:30:03,066
Now the interpolant values pass through the vertex shader

536
00:30:03,066 --> 00:30:06,108
and the geometry shader, down into the fragment shader,

537
00:30:06,108 --> 00:30:08,849
simplify the amount of calculations needed per pixel sample

538
00:30:08,849 --> 00:30:10,310
for driving the particle emission.

539
00:30:11,262 --> 00:30:15,043
We passed the world space position data along

540
00:30:15,043 --> 00:30:18,384
with each vertex, so we basically get that for free

541
00:30:18,384 --> 00:30:24,225
in terms of determining where should the particle

542
00:30:24,225 --> 00:30:24,705
actually be spawning.

543
00:30:24,705 --> 00:30:25,865
So in this video here, I have an animated horse

544
00:30:25,865 --> 00:30:29,506
with a texture that spawns,

545
00:30:29,506 --> 00:30:34,967
textured with spawning particles that inherit

546
00:30:34,967 --> 00:30:37,288
the color of the polygon surface underneath.

547
00:30:38,792 --> 00:30:44,156
So after the shading stage is finished, this is pushing that

548
00:30:44,156 --> 00:30:46,639
data into the append buffer.

549
00:30:46,639 --> 00:30:49,181
And then it can be copied with, say, a compute shader.

550
00:30:49,181 --> 00:30:54,045
Copy from the append buffer into the more managed GPU

551
00:30:54,045 --> 00:30:59,169
particle system buffers that you may have, or it needs to

552
00:30:59,169 --> 00:31:01,231
be sorted and whatnot.

553
00:31:01,231 --> 00:31:03,753
And then you would draw it with draw indirect or draw

554
00:31:03,753 --> 00:31:05,075
procedural type methods.

555
00:31:09,700 --> 00:31:12,121
So now that I have particles emitting from triangles

556
00:31:12,121 --> 00:31:15,062
with pretty much any fragment shader imaginable,

557
00:31:15,062 --> 00:31:17,203
there were still a number of important things

558
00:31:17,203 --> 00:31:19,023
to think about solving.

559
00:31:19,023 --> 00:31:22,084
One of these is handling very fast moving topology

560
00:31:22,084 --> 00:31:24,525
over a single time step,

561
00:31:24,525 --> 00:31:26,346
referred to in some particle systems

562
00:31:26,346 --> 00:31:27,546
as distance-based emission.

563
00:31:27,546 --> 00:31:30,287
So if you have a rocket or something flying really fast,

564
00:31:30,287 --> 00:31:32,628
you need to make sure you get all your smoke puffs

565
00:31:32,628 --> 00:31:34,748
sort of connected and covering that

566
00:31:34,748 --> 00:31:35,949
to make it look correct.

567
00:31:35,949 --> 00:31:36,869
So when we have...

568
00:31:39,542 --> 00:31:42,724
we need to solve for that, we need to fill in those gaps.

569
00:31:42,724 --> 00:31:43,705
So how do we do that?

570
00:31:43,705 --> 00:31:48,168
So it's similar to an animator needing to do breakdowns

571
00:31:48,168 --> 00:31:51,630
or tweens, so I just used the geometry shader

572
00:31:51,630 --> 00:31:53,011
to sort of do that.

573
00:31:53,011 --> 00:31:57,374
So this is a preferable approach, in my opinion,

574
00:31:57,374 --> 00:32:00,737
than pushing all the work down into the fragment shader.

575
00:32:00,737 --> 00:32:04,199
I basically create the sort of in-betweens

576
00:32:04,199 --> 00:32:05,660
and the geometry shader stage.

577
00:32:06,555 --> 00:32:09,937
In the case of the triangles being skinned,

578
00:32:09,937 --> 00:32:12,739
squashed, stretched, the surface area of these triangles

579
00:32:12,739 --> 00:32:14,079
is highly variable.

580
00:32:14,079 --> 00:32:18,202
You usually want also some kind of velocity data

581
00:32:18,202 --> 00:32:22,184
in your vertex structure to know where the triangle

582
00:32:22,184 --> 00:32:24,025
has sort of been and where it's going,

583
00:32:24,025 --> 00:32:26,586
and that can be helpful in terms of helping you

584
00:32:26,586 --> 00:32:30,528
calculate what the accurately tweened topology

585
00:32:30,528 --> 00:32:33,950
should be in between those two sort of extremes

586
00:32:33,950 --> 00:32:35,531
of like your current frame and your next.

587
00:32:39,614 --> 00:32:43,577
So the nice thing about this is that the code

588
00:32:43,577 --> 00:32:47,561
in the geometry shader stage that is calculating

589
00:32:47,561 --> 00:32:52,105
the sampling density, we can reuse that for these tweens.

590
00:32:52,105 --> 00:32:55,628
So each in between triangle that we add

591
00:32:55,628 --> 00:32:57,870
to sort of fill in these gaps,

592
00:32:57,870 --> 00:33:00,152
we'll also get the correct sampling

593
00:33:00,152 --> 00:33:01,313
based on its surface area.

594
00:33:03,749 --> 00:33:05,289
In addition to the vertex positions

595
00:33:05,289 --> 00:33:08,090
and the triangle area varying for these tweens,

596
00:33:08,090 --> 00:33:09,790
all of the shader parameters and uniforms

597
00:33:09,790 --> 00:33:11,310
can also be varying as well.

598
00:33:11,310 --> 00:33:14,491
So we need to also adjust those appropriate calculations

599
00:33:14,491 --> 00:33:16,451
that determine those things,

600
00:33:16,451 --> 00:33:19,112
especially things like time, delta time,

601
00:33:19,112 --> 00:33:22,072
your UVs could be scrolling and so on.

602
00:33:22,072 --> 00:33:27,353
So this authoring your shader effects

603
00:33:27,353 --> 00:33:30,094
might be a tiny little bit extra complicated

604
00:33:30,094 --> 00:33:31,654
to account for this.

605
00:33:34,788 --> 00:33:37,109
So, while this technique works really well,

606
00:33:37,109 --> 00:33:38,170
there's a limitation to it.

607
00:33:38,170 --> 00:33:40,311
Geometry shaders actually have limits.

608
00:33:40,311 --> 00:33:44,713
The more complex your vertex shader structure is,

609
00:33:44,713 --> 00:33:45,933
or vertex structure is,

610
00:33:45,933 --> 00:33:48,254
the fewer tweened triangles you can have

611
00:33:48,254 --> 00:33:53,557
because if you have normals, binormals, tangents,

612
00:33:53,557 --> 00:33:54,337
and so on and so forth.

613
00:33:55,179 --> 00:33:57,261
your max vertex count is basically dropping

614
00:33:57,261 --> 00:34:01,183
because your structure is getting more complex

615
00:34:01,183 --> 00:34:04,865
and requires more storage.

616
00:34:04,865 --> 00:34:09,448
So it's necessary to adjust your sort of maximum

617
00:34:09,448 --> 00:34:10,449
in-betweens that you support to account for this.

618
00:34:10,449 --> 00:34:11,369
So when I've been talking about this,

619
00:34:11,369 --> 00:34:12,330
this has mainly been in the context

620
00:34:12,330 --> 00:34:18,554
of solving this problem in isolation,

621
00:34:18,554 --> 00:34:22,657
but what we can do is we can actually do this work.

622
00:34:23,223 --> 00:34:28,048
in addition to just normally drawing the object

623
00:34:28,048 --> 00:34:32,172
by interleaving the work of those two shaders together.

624
00:34:32,172 --> 00:34:36,176
So as I draw my objects, I also use the geometry shader

625
00:34:36,176 --> 00:34:37,537
to push out those triangles.

626
00:34:38,232 --> 00:34:40,453
In order to get this to work, your fragment shader

627
00:34:40,453 --> 00:34:43,974
doesn't know whether it's drawing

628
00:34:43,974 --> 00:34:47,715
pixels that are intended to be for the normal game view,

629
00:34:47,715 --> 00:34:50,296
or whether they're for shading and figuring out

630
00:34:50,296 --> 00:34:51,957
whether we emit particles or not.

631
00:34:51,957 --> 00:34:53,097
So how do we figure this out?

632
00:34:53,217 --> 00:34:59,026
The easiest way to do this is to just add an interpolant that basically flags all three

633
00:34:59,026 --> 00:35:03,933
vertices and then you can look at that in a fragment shader and say, oh, okay, I'm emitting

634
00:35:03,933 --> 00:35:09,601
particles from this fragment I'm supposed to shade right now versus just drawing it

635
00:35:09,601 --> 00:35:09,981
normally.

636
00:35:18,532 --> 00:35:22,133
So, some more thoughts on refining the emission.

637
00:35:22,133 --> 00:35:24,674
And to reiterate is that not all your samples

638
00:35:24,674 --> 00:35:28,275
are going to emit, even if you run at a really high

639
00:35:28,275 --> 00:35:32,916
frame rate and you shrink the triangles down,

640
00:35:32,916 --> 00:35:38,198
you're going to call discard on a lot of those fragments.

641
00:35:38,198 --> 00:35:42,700
And adding the jitter is helping you get your

642
00:35:42,700 --> 00:35:44,841
improved coverage while not needing to make

643
00:35:44,841 --> 00:35:47,762
these triangles extraordinarily large.

644
00:35:49,629 --> 00:35:53,950
If you can sort of see the visual grid of this,

645
00:35:53,950 --> 00:35:55,851
if you're emitting a lot of them,

646
00:35:55,851 --> 00:35:59,053
I personally just add the smallest amount

647
00:35:59,053 --> 00:36:02,314
of world space jitter on the surface of the triangle

648
00:36:02,314 --> 00:36:03,735
to sort of visually break the grid.

649
00:36:03,735 --> 00:36:06,556
It's very easy.

650
00:36:06,556 --> 00:36:11,898
And then, again, if you're just trickling out particles

651
00:36:11,898 --> 00:36:14,239
from something, the triangles can be very small

652
00:36:14,239 --> 00:36:16,860
and making them bigger actually won't improve anything.

653
00:36:19,987 --> 00:36:22,888
So to recap the feature set, we finally

654
00:36:22,888 --> 00:36:25,528
had something that allowed textured and animated

655
00:36:25,528 --> 00:36:26,508
fragment shaders.

656
00:36:26,508 --> 00:36:27,729
It was view independent.

657
00:36:27,729 --> 00:36:29,949
I had conditional writes to an event buffer

658
00:36:29,949 --> 00:36:32,510
so I could decide which samples did and did not

659
00:36:32,510 --> 00:36:35,750
need to write bound particles.

660
00:36:35,750 --> 00:36:38,811
I had jittered sampling, so I wasn't

661
00:36:38,811 --> 00:36:41,771
tied to the resolution of the textures

662
00:36:41,771 --> 00:36:43,692
or any kind of pre-computed baking

663
00:36:43,692 --> 00:36:45,432
to make any of this happen.

664
00:36:45,432 --> 00:36:49,693
And we can work on pretty much any mesh topology imaginable.

665
00:36:54,139 --> 00:36:59,060
So for surface material transfer to your spawn particles,

666
00:36:59,060 --> 00:37:00,301
it's pretty straightforward.

667
00:37:00,301 --> 00:37:01,621
Because in the case of a deferred render

668
00:37:01,621 --> 00:37:04,902
and say using mesh particles, the output of the append buffer

669
00:37:04,902 --> 00:37:07,522
structure would just need to contain

670
00:37:07,522 --> 00:37:10,023
the necessary parameters that you would normally

671
00:37:10,023 --> 00:37:14,684
be writing out to the gbuffer, such as albedo, emission,

672
00:37:14,684 --> 00:37:17,065
and other things of that nature.

673
00:37:17,065 --> 00:37:20,445
In the case of forward rendered objects emitting particles,

674
00:37:20,445 --> 00:37:22,866
you might want to do a little bit more work.

675
00:37:23,204 --> 00:37:30,955
Or maybe you want to bake stuff and just have then the particle emission code pass some

676
00:37:30,955 --> 00:37:31,536
of that through.

677
00:37:31,536 --> 00:37:33,699
Again, there's no hard rules here.

678
00:37:33,699 --> 00:37:35,221
It's just whatever works for you.

679
00:37:38,905 --> 00:37:41,967
So one important thing for refining this

680
00:37:41,967 --> 00:37:44,249
is you need to be, or you probably

681
00:37:44,249 --> 00:37:47,891
want to be selective about where these particles are coming from

682
00:37:47,891 --> 00:37:49,012
and where they don't.

683
00:37:49,012 --> 00:37:52,394
So a few engines out there mostly

684
00:37:52,394 --> 00:37:55,477
only support particle emission on a per object or sub-mesh

685
00:37:55,477 --> 00:37:56,837
level.

686
00:37:56,837 --> 00:37:59,639
So when we have the ability to paint stuff and run

687
00:37:59,639 --> 00:38:01,280
the fragment shader and determine

688
00:38:01,280 --> 00:38:06,544
where this is going to happen, I use a texture painting workflow

689
00:38:06,544 --> 00:38:08,405
for pretty much all of this stuff.

690
00:38:09,553 --> 00:38:11,995
So in this example, areas that should not be emitting

691
00:38:11,995 --> 00:38:14,656
particles, I just made them painted black.

692
00:38:14,656 --> 00:38:17,577
And the painted texture, I then save as an uncompressed texture

693
00:38:17,577 --> 00:38:18,017
asset.

694
00:38:18,017 --> 00:38:21,118
So it's just another texture that I add to my shader

695
00:38:21,118 --> 00:38:23,179
and then fetch and sort of look at.

696
00:38:23,179 --> 00:38:26,941
So in the fragment shader program,

697
00:38:26,941 --> 00:38:30,102
there's just one line that says, hey, is this pixel black?

698
00:38:30,102 --> 00:38:31,723
If it is black, then hey, we're not

699
00:38:31,723 --> 00:38:33,584
going to run the particle emission code.

700
00:38:33,584 --> 00:38:39,046
It's very easy to drive this stuff based on your textures.

701
00:38:41,596 --> 00:38:44,718
Mesh here, of course, has a unique UV set applied to it

702
00:38:44,718 --> 00:38:48,379
that's independent of the particle emission density.

703
00:38:48,379 --> 00:38:49,980
So I'm not relying on that whatsoever,

704
00:38:49,980 --> 00:38:50,901
just to reiterate that.

705
00:38:50,901 --> 00:38:52,001
So here's another video of me painting on a mesh

706
00:38:52,001 --> 00:38:54,863
to dissolve away specific areas.

707
00:38:54,863 --> 00:39:01,086
This has a lot of use for visual destruction effects

708
00:39:01,086 --> 00:39:03,467
where you want to emit or not emit particles.

709
00:39:04,316 --> 00:39:09,939
Now, since we're emitting this topology in object space,

710
00:39:09,939 --> 00:39:12,661
we're not tied to the resolution of the source texture

711
00:39:12,661 --> 00:39:14,121
asset mapped on this geometry.

712
00:39:14,121 --> 00:39:16,883
So the texture for this is like 256 or something.

713
00:39:16,883 --> 00:39:19,364
This is rendered at a much higher resolution.

714
00:39:19,364 --> 00:39:23,987
We can combine masking, dissolving, mixed resolutions,

715
00:39:23,987 --> 00:39:28,149
sign distance fields, or any sort of smoothing stuff

716
00:39:28,149 --> 00:39:30,470
and get accurate emission, because remember,

717
00:39:30,470 --> 00:39:32,692
we're jittering the triangles, moving them around.

718
00:39:33,140 --> 00:39:35,782
and getting the sampling at a higher density

719
00:39:35,782 --> 00:39:39,445
that's above whatever the texturing is.

720
00:39:39,445 --> 00:39:42,327
So now that I have the ability to control

721
00:39:42,327 --> 00:39:46,770
where the particles emit at a much finer detail level,

722
00:39:46,770 --> 00:39:48,532
the next desirable parameter to control

723
00:39:48,532 --> 00:39:50,433
is the particle flow direction

724
00:39:50,433 --> 00:39:52,355
as it leaves the surface of a particular point.

725
00:39:52,355 --> 00:39:55,497
There's a lot of pre-existing material here,

726
00:39:55,497 --> 00:39:57,278
flow maps and so on and so forth,

727
00:39:57,278 --> 00:40:00,021
and it basically just works out of the box

728
00:40:00,021 --> 00:40:02,563
if you just implement it.

729
00:40:03,460 --> 00:40:06,060
When I author this data, I don't use normalized flow.

730
00:40:06,060 --> 00:40:09,401
I just started painting and just mapping this stuff

731
00:40:09,401 --> 00:40:11,122
to basically red and blue channels.

732
00:40:11,122 --> 00:40:12,983
And I got interesting stuff.

733
00:40:12,983 --> 00:40:14,243
So there's no rules here.

734
00:40:14,243 --> 00:40:15,543
I mean, just experiment.

735
00:40:15,543 --> 00:40:17,524
All the texture data that you have in the shader already

736
00:40:17,524 --> 00:40:20,125
could create interesting effects with this.

737
00:40:20,125 --> 00:40:23,146
So you don't need to run off and create

738
00:40:23,146 --> 00:40:26,287
a bunch of extra textures to make some of this stuff happen.

739
00:40:30,102 --> 00:40:32,504
So some important things to keep in mind.

740
00:40:32,504 --> 00:40:35,146
Non-destructive workflow, of course, is really good.

741
00:40:35,146 --> 00:40:37,648
I like to also use Photoshop and adjustment layers.

742
00:40:37,648 --> 00:40:41,931
Use a little bit of Quixel and some other stuff too.

743
00:40:41,931 --> 00:40:45,974
Sometimes Illustrator for paths and gradients for dissolves

744
00:40:45,974 --> 00:40:46,735
and whatnot.

745
00:40:46,735 --> 00:40:52,039
Also, I add some tuning values and also a curve modifier

746
00:40:52,039 --> 00:40:56,563
in my actual shader so I can get a little more out

747
00:40:56,563 --> 00:40:58,484
of those assets as well.

748
00:41:01,678 --> 00:41:04,600
So to stretch the topology limit even further

749
00:41:04,600 --> 00:41:08,702
and just really drive home what this allows us to do

750
00:41:08,702 --> 00:41:11,483
with this approach, is that we can stack

751
00:41:11,483 --> 00:41:13,244
and combine multiple effects here

752
00:41:13,244 --> 00:41:15,025
in our vertex and geometry shader stages

753
00:41:15,025 --> 00:41:18,106
to modify the input topology.

754
00:41:18,106 --> 00:41:20,448
And it doesn't really increase the performance cost

755
00:41:20,448 --> 00:41:22,228
of the later fragment shading stage.

756
00:41:23,320 --> 00:41:25,381
The reason for that is the surface area

757
00:41:25,381 --> 00:41:27,602
would not probably be varying that much,

758
00:41:27,602 --> 00:41:30,203
so the triangles, when you unfold and chart them,

759
00:41:30,203 --> 00:41:33,484
don't change in size significantly.

760
00:41:33,484 --> 00:41:36,066
Now, for certain geometry amplification

761
00:41:36,066 --> 00:41:39,267
and procedural stuff, such as tessellation

762
00:41:39,267 --> 00:41:42,929
or anything that's going to make the surface area

763
00:41:42,929 --> 00:41:44,109
of those triangles get bigger,

764
00:41:44,109 --> 00:41:47,211
then you're obviously gonna start to pay more cost

765
00:41:47,211 --> 00:41:50,192
in the geometry shader and fragment shader stages.

766
00:41:55,780 --> 00:41:57,020
So one more thing.

767
00:41:57,020 --> 00:42:01,163
So this video here, this is like a 60,000 objects thing.

768
00:42:01,163 --> 00:42:02,343
I just sort of blew up.

769
00:42:02,343 --> 00:42:04,925
This is actually all on the GPU.

770
00:42:04,925 --> 00:42:08,046
It's done in the geometry shader.

771
00:42:08,046 --> 00:42:10,408
So I just fractured each triangle, turned each triangle

772
00:42:10,408 --> 00:42:15,430
into a tetrahedra, and then sort of spun it with a sort of

773
00:42:15,430 --> 00:42:16,131
stateless animation.

774
00:42:16,992 --> 00:42:19,273
and just randomly tumbled them and then fed them

775
00:42:19,273 --> 00:42:20,795
to the particle emission stuff.

776
00:42:20,795 --> 00:42:22,996
So this is like having 60,000 particle emitters

777
00:42:22,996 --> 00:42:25,398
of things blowing up and it's all one draw call.

778
00:42:25,398 --> 00:42:27,780
So I was pretty happy with this.

779
00:42:27,780 --> 00:42:29,221
So tessellation and other approaches

780
00:42:29,221 --> 00:42:34,565
that can increase the number of triangles

781
00:42:34,565 --> 00:42:37,908
can also be used with this emission technique.

782
00:42:37,908 --> 00:42:40,470
So again, we need to remember though

783
00:42:40,470 --> 00:42:42,371
that the more triangles we make

784
00:42:42,371 --> 00:42:44,212
or the more surface area we increase,

785
00:42:44,212 --> 00:42:46,174
then we increase the cost of doing this work.

786
00:42:48,198 --> 00:42:50,180
Depending on your use cases,

787
00:42:50,180 --> 00:42:52,383
you may want to adjust your tessellation factor

788
00:42:52,383 --> 00:42:54,466
in your particle emission geometry

789
00:42:54,466 --> 00:42:55,688
separate from what you render

790
00:42:55,688 --> 00:42:58,712
and show to the player in the normal rendering view.

791
00:43:04,140 --> 00:43:07,242
So one extremely common question I got

792
00:43:07,242 --> 00:43:09,824
when I showed this to some colleagues

793
00:43:09,824 --> 00:43:14,567
was what happens with extremely thin geometry, like grass?

794
00:43:14,567 --> 00:43:16,429
And this is something I thought about

795
00:43:16,429 --> 00:43:18,450
when I also did this implementation

796
00:43:18,450 --> 00:43:20,811
because I wanted to make grass burn

797
00:43:20,811 --> 00:43:22,873
and have particles come off every grass blade

798
00:43:22,873 --> 00:43:23,573
and stuff like that.

799
00:43:24,074 --> 00:43:29,041
And the thing is, is you can just dilate the triangle

800
00:43:29,041 --> 00:43:31,164
after you unfold it into the space

801
00:43:31,164 --> 00:43:33,327
where the GPU's gonna shade it,

802
00:43:33,327 --> 00:43:36,292
basically using like a conservative rasterization approach.

803
00:43:38,123 --> 00:43:43,308
and we're jittering so we're going to hit those triangles and we're going to be able to emit

804
00:43:43,308 --> 00:43:49,614
from them. Another thing to keep in mind when you do this is you don't do this by default

805
00:43:49,614 --> 00:43:53,197
because there's a lot of visual effects you may have where you intentionally crush

806
00:43:53,197 --> 00:43:59,263
triangles to be zero area because you have them either some kind of destruction or ‑‑

807
00:43:59,774 --> 00:44:02,056
you know, limbs or whatever sort of collapsing

808
00:44:02,056 --> 00:44:04,838
and you don't want particles to come off of those things.

809
00:44:04,838 --> 00:44:06,239
So you would test it with an epsilon

810
00:44:06,239 --> 00:44:09,342
to make sure that those particles happen.

811
00:44:09,342 --> 00:44:12,924
And the cool thing about doing this is that

812
00:44:12,924 --> 00:44:16,047
if you destroy or just hide things

813
00:44:16,047 --> 00:44:17,788
by shrinking them down,

814
00:44:17,788 --> 00:44:19,830
you don't have to worry about them emitting particles.

815
00:44:19,830 --> 00:44:21,291
So you sort of get that for free.

816
00:44:24,921 --> 00:44:27,863
So, talk a little bit about level of detail.

817
00:44:27,863 --> 00:44:32,446
A lot of this is kind of obvious,

818
00:44:32,446 --> 00:44:36,528
but one way to do it is based on distance,

819
00:44:36,528 --> 00:44:38,790
whether something's in and out of the frustum,

820
00:44:38,790 --> 00:44:42,112
you decide, hey, we're gonna emit 50% less particles,

821
00:44:42,112 --> 00:44:44,954
whether something's in or out of the frustum,

822
00:44:44,954 --> 00:44:47,295
where you decide to...

823
00:44:47,810 --> 00:44:50,251
do that sort of calling or determination

824
00:44:50,251 --> 00:44:52,312
would be in the vertex shader or the geometry shader,

825
00:44:52,312 --> 00:44:54,092
or maybe you have a compute shader

826
00:44:54,092 --> 00:44:56,333
that runs even further in advance

827
00:44:56,333 --> 00:44:59,275
and writes out to a specific stream of data

828
00:44:59,275 --> 00:45:03,156
and sort of helps inform whether you should be

829
00:45:03,156 --> 00:45:05,217
emitting from certain pieces of geometry or not.

830
00:45:05,217 --> 00:45:05,818
So I personally write,

831
00:45:15,951 --> 00:45:17,132
a lot of my shaders by hand,

832
00:45:17,132 --> 00:45:20,455
but graph and node-based workflows are everywhere.

833
00:45:20,455 --> 00:45:23,378
I mean, tens of thousands, maybe hundreds of thousands

834
00:45:23,378 --> 00:45:25,139
of people are used to this workflow.

835
00:45:25,139 --> 00:45:25,820
It's really easy.

836
00:45:25,820 --> 00:45:27,702
You pick it up, and you just start connecting things,

837
00:45:27,702 --> 00:45:30,945
and you see results.

838
00:45:30,945 --> 00:45:32,346
So,

839
00:45:32,346 --> 00:45:36,590
I've thought a lot about what do we do with this technique?

840
00:45:36,590 --> 00:45:39,072
How do we put it in the hands of more people?

841
00:45:40,093 --> 00:45:44,438
Because many of the existing tools for shader graph-based

842
00:45:44,438 --> 00:45:47,862
workflows were only letting you play with the vertex shader

843
00:45:47,862 --> 00:45:49,124
and the fragment shader.

844
00:45:49,124 --> 00:45:52,368
So what does that interface look like when we say, hey,

845
00:45:52,368 --> 00:45:54,610
you run a fragment shader, but then you

846
00:45:54,610 --> 00:45:55,592
can emit particles from it?

847
00:45:57,230 --> 00:46:00,673
So these are important questions for not just myself,

848
00:46:00,673 --> 00:46:03,936
but everybody that wants to do this stuff, to think about

849
00:46:03,936 --> 00:46:05,897
and eventually answer so we can leverage the immense

850
00:46:05,897 --> 00:46:08,660
amount of shaders and visual effects that a lot of us have

851
00:46:08,660 --> 00:46:11,802
already made without any tedious hand-porting to make

852
00:46:11,802 --> 00:46:12,883
this stuff happen.

853
00:46:12,883 --> 00:46:14,384
I have a lot of ideas on how to continue to refine this

854
00:46:14,384 --> 00:46:14,805
and optimize it.

855
00:46:26,620 --> 00:46:30,902
But I'm kind of really just having fun

856
00:46:30,902 --> 00:46:36,024
Porting a lot of shaders and figuring stuff out more but again graph-based work workflow

857
00:46:36,024 --> 00:46:39,945
You know if we add something

858
00:46:39,945 --> 00:46:44,347
You know do we just make it one particle one sample does it does it become?

859
00:46:45,226 --> 00:46:49,450
One sample can spawn up to N particles.

860
00:46:49,450 --> 00:46:55,375
And I think we need to collectively consider

861
00:46:55,375 --> 00:46:58,758
what kind of interface do we add to compute

862
00:46:58,758 --> 00:47:01,140
or open up the geometry shader stage

863
00:47:01,140 --> 00:47:03,983
and other things to existing tools.

864
00:47:07,191 --> 00:47:09,171
So my final thoughts, although I'm quite in love

865
00:47:09,171 --> 00:47:11,532
with the techniques presented today for emitting particles,

866
00:47:11,532 --> 00:47:13,212
and I'm really excited to share them with you,

867
00:47:13,212 --> 00:47:16,773
and I hope you find some inspiration from them.

868
00:47:16,773 --> 00:47:20,034
These don't replace all the use cases.

869
00:47:20,034 --> 00:47:24,335
You know, a lot of the just very simple point line

870
00:47:24,335 --> 00:47:26,995
sphere emitters and stuff are still great tools.

871
00:47:26,995 --> 00:47:28,056
You know, so this is just another,

872
00:47:28,056 --> 00:47:31,756
the stuff I've covered today is just more tools

873
00:47:31,756 --> 00:47:32,497
in your toolbox.

874
00:47:36,287 --> 00:47:48,694
So I'd like to thank the following people who reviewed this material and encouraged me to chase it.

875
00:47:48,694 --> 00:47:51,395
So that's it, and thank you for your time.

