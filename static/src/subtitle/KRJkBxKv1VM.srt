1
00:00:05,662 --> 00:00:06,742
So my name is Dan Somali.

2
00:00:06,742 --> 00:00:08,063
I'm a tools programmer at Guerrilla Games.

3
00:00:08,063 --> 00:00:11,284
And together with my colleague, Sander van der Steen,

4
00:00:11,284 --> 00:00:13,505
I'm going to talk about how we rebuilt our tools

5
00:00:13,505 --> 00:00:15,466
pipeline during the development of Horizon Zero Dawn.

6
00:00:15,466 --> 00:00:19,548
So for those of you who might be unfamiliar with the game,

7
00:00:19,548 --> 00:00:20,948
let's take a quick look at a trailer.

8
00:00:48,601 --> 00:00:51,403
All right, so now everybody knows exactly what the game is about.

9
00:00:51,403 --> 00:00:52,424
Let's continue.

10
00:00:52,424 --> 00:00:56,948
So prior to creating Horizon, we worked on Killzone,

11
00:00:56,948 --> 00:00:58,669
which is a series of first-person shooters.

12
00:00:58,669 --> 00:01:02,472
And when we were going to make the jump from building shooters

13
00:01:02,472 --> 00:01:04,434
to creating the vast open world of Horizon,

14
00:01:04,434 --> 00:01:06,496
it was going to be a big challenge for all disciplines

15
00:01:06,496 --> 00:01:08,938
within our company, and the tools team was no exception.

16
00:01:08,938 --> 00:01:11,380
So we'll cover a few different areas of interest,

17
00:01:11,380 --> 00:01:12,961
but I guess the main takeaways of this talk

18
00:01:12,961 --> 00:01:14,462
are that you'll get...

19
00:01:14,925 --> 00:01:18,427
bit of insight into why we decided to rebuild our tools

20
00:01:18,427 --> 00:01:20,809
and learn a little bit about how we approached this

21
00:01:20,809 --> 00:01:23,631
while we were already in production.

22
00:01:23,631 --> 00:01:25,773
And we'll show a few ways in which we think that it paid off.

23
00:01:25,773 --> 00:01:28,414
So if you're somebody who is responsible

24
00:01:28,414 --> 00:01:29,775
for maintaining a legacy toolset,

25
00:01:29,775 --> 00:01:31,477
or you're just somebody who uses one on a daily basis,

26
00:01:31,477 --> 00:01:33,418
this will hopefully inspire you

27
00:01:33,418 --> 00:01:34,419
to do something about that situation.

28
00:01:34,419 --> 00:01:37,801
So yeah, to begin with, I'll talk a little bit about the tools

29
00:01:37,801 --> 00:01:39,843
that we use on Killzone Shadowfall,

30
00:01:39,843 --> 00:01:42,945
followed by a bit of background on the process

31
00:01:42,945 --> 00:01:44,366
of actually rebuilding our toolchain.

32
00:01:44,984 --> 00:01:47,807
And then we'll go into some detail about our level editor,

33
00:01:47,807 --> 00:01:51,149
our 3D editor, and how actual data editing works.

34
00:01:51,149 --> 00:01:52,891
And if there's time, I'll cover a few other tools

35
00:01:52,891 --> 00:01:56,193
that we have and finally share a couple of learnings

36
00:01:56,193 --> 00:01:59,176
from our project and a bit about our future plans.

37
00:01:59,176 --> 00:02:02,038
So at the start of Horizon,

38
00:02:02,038 --> 00:02:04,640
we had a pretty fragmented tool set.

39
00:02:04,640 --> 00:02:06,501
It was built upon a mixture

40
00:02:06,501 --> 00:02:09,003
of different languages and frameworks.

41
00:02:09,003 --> 00:02:11,365
We had very long iteration times.

42
00:02:11,365 --> 00:02:12,947
I mean, in a really bad case, it could be like,

43
00:02:13,996 --> 00:02:15,357
between a designer making a change

44
00:02:15,357 --> 00:02:16,758
and actually being able to see it in-game

45
00:02:16,758 --> 00:02:17,839
was like 20 or 30 minutes.

46
00:02:17,839 --> 00:02:20,821
And to be frank, we had a lot of pretty unhappy users.

47
00:02:20,821 --> 00:02:22,582
I mean, at this time, Unity and Unreal

48
00:02:22,582 --> 00:02:25,404
were becoming much more popular and visible.

49
00:02:25,404 --> 00:02:29,366
So we had some pretty strong dissatisfaction with our users

50
00:02:29,366 --> 00:02:32,028
when they were comparing their workflows and features

51
00:02:32,028 --> 00:02:35,591
in Guerrilla Tools and comparing it to Unreal and Unity.

52
00:02:35,591 --> 00:02:40,034
So just a quick technical detail.

53
00:02:42,102 --> 00:02:44,603
At Gorilla we use an intermediate storage format which is called Cortext

54
00:02:44,603 --> 00:02:46,604
and we use that for all of our game data.

55
00:02:46,604 --> 00:02:49,265
Almost everything except for textures and audio.

56
00:02:49,265 --> 00:02:51,767
And before the data is loaded in the game, we transform it

57
00:02:51,767 --> 00:02:55,168
through a... into an optimized binary representation

58
00:02:55,168 --> 00:02:56,589
through a process that we call conversion.

59
00:02:56,589 --> 00:03:01,891
So the primary editor that we had for Cortext was the Cortext editor.

60
00:03:01,891 --> 00:03:03,892
Here's an image of the thing in all of its glory.

61
00:03:03,892 --> 00:03:04,992
It's pretty old school.

62
00:03:04,992 --> 00:03:09,354
Cortext editor displays the contents of a Cortext file as a 2D graph.

63
00:03:09,354 --> 00:03:09,394
So...

64
00:03:10,291 --> 00:03:13,614
just within follow resources with the file represented as notes on the on the

65
00:03:13,614 --> 00:03:17,056
cameras and references between those objects are represented as wires.

66
00:03:17,056 --> 00:03:22,421
So uses to create and figure a lot of our game data but in terms of actual

67
00:03:22,421 --> 00:03:25,203
data editing it's pretty low level it's it's basically one step removed from

68
00:03:25,203 --> 00:03:29,106
just editing your cortex files directly in a text editor which incidentally is

69
00:03:29,106 --> 00:03:32,349
how a lot of the configuration for earlier kills and game was actually done.

70
00:03:33,528 --> 00:03:35,128
So much of the user's energy was spent on the busy work

71
00:03:35,128 --> 00:03:36,289
of kind of creating and understanding

72
00:03:36,289 --> 00:03:37,769
these complicated resource structures

73
00:03:37,769 --> 00:03:39,410
instead of just being free to focus

74
00:03:39,410 --> 00:03:41,231
on the actual creative process.

75
00:03:41,231 --> 00:03:42,811
This tool was written in C Sharp and WinForms

76
00:03:42,811 --> 00:03:45,312
and a Sony framework called ATF,

77
00:03:45,312 --> 00:03:46,173
which was recently open sourced.

78
00:03:46,173 --> 00:03:48,814
And additionally, the code base for this tool

79
00:03:48,814 --> 00:03:50,254
was fantastically complicated.

80
00:03:50,254 --> 00:03:53,516
There was, it required really a lot of effort

81
00:03:53,516 --> 00:03:56,157
to make even trivial changes in this tool.

82
00:03:56,157 --> 00:03:58,217
So there was only a handful of programmers in the company

83
00:03:58,217 --> 00:03:59,438
who could actually even work on it,

84
00:03:59,438 --> 00:04:00,438
and there was basically nobody

85
00:04:00,438 --> 00:04:01,098
who enjoyed working on it at all.

86
00:04:02,823 --> 00:04:04,324
And the next major piece of a pipeline was Maya,

87
00:04:04,324 --> 00:04:06,305
specifically our in-house Maya plugin.

88
00:04:06,305 --> 00:04:10,327
So the plugin allows us to edit our game environments

89
00:04:10,327 --> 00:04:12,428
inside of Maya and then export them into core text.

90
00:04:12,428 --> 00:04:15,570
And the plugin uses Decima's renderer in the viewport,

91
00:04:15,570 --> 00:04:16,690
so you get an accurate representation

92
00:04:16,690 --> 00:04:19,071
of how your assets are going to look in the game.

93
00:04:19,071 --> 00:04:20,672
However, it doesn't run the entire game loop,

94
00:04:20,672 --> 00:04:22,673
so and also it leaves a lot of the game systems

95
00:04:22,673 --> 00:04:25,135
in an uninitialized state, which means that you miss

96
00:04:25,135 --> 00:04:27,316
a lot of the things that actually bring life to the game world.

97
00:04:28,008 --> 00:04:29,268
This was built in C++ and Python

98
00:04:29,268 --> 00:04:31,949
and also uses the Maya API very heavily.

99
00:04:31,949 --> 00:04:33,809
And much like the Cortex editor,

100
00:04:33,809 --> 00:04:35,190
there was only a handful of people

101
00:04:35,190 --> 00:04:36,890
who actually were able to work on it

102
00:04:36,890 --> 00:04:38,150
and also willing to work on it.

103
00:04:38,150 --> 00:04:41,891
So the last piece was a state machine editor called SMED.

104
00:04:41,891 --> 00:04:44,452
And SMED is a tool that generates Lua script,

105
00:04:44,452 --> 00:04:45,472
which is then executed in game.

106
00:04:45,472 --> 00:04:46,932
And this was used by designers

107
00:04:46,932 --> 00:04:49,413
for much of the level scripting logic within Killzone.

108
00:04:51,830 --> 00:04:55,354
So SMED began life as a prototype actually. It was created by a technical designer

109
00:04:55,354 --> 00:04:59,238
to see if it would be possible to produce a visual script editor for our game.

110
00:04:59,238 --> 00:05:03,763
The deal was that if the prototype worked out and was proven to be okay,

111
00:05:03,763 --> 00:05:06,625
then the tools team would take ownership of this thing and make it into a real tool and then...

112
00:05:08,062 --> 00:05:08,802
Yeah, we would go forward.

113
00:05:08,802 --> 00:05:10,505
But even though the prototype was successful,

114
00:05:10,505 --> 00:05:13,188
that transfer of ownership thing never really happened.

115
00:05:13,188 --> 00:05:15,291
And so at some point, this tool gained critical mass

116
00:05:15,291 --> 00:05:17,534
and the technical designer that made the original prototype

117
00:05:17,534 --> 00:05:18,795
was now responsible for maintaining

118
00:05:18,795 --> 00:05:20,417
an important part of the tool chain.

119
00:05:20,417 --> 00:05:21,819
And this tool was written in Python.

120
00:05:23,495 --> 00:05:25,855
So with the set up a designer who's aiming to accomplish a

121
00:05:25,855 --> 00:05:28,496
simple task is is forced to navigate between the sort of

122
00:05:28,496 --> 00:05:31,677
like Bermuda Triangle of lost productivity which involves

123
00:05:31,677 --> 00:05:34,078
like flipping between these 3 different applications manually

124
00:05:34,078 --> 00:05:36,519
copying string identifiers file names and values between them

125
00:05:36,519 --> 00:05:39,799
and the tools also didn't talk to each other so it meant

126
00:05:39,799 --> 00:05:42,420
that mistakes are only indicated way after the fact and usually

127
00:05:42,420 --> 00:05:44,701
by some kind of impenetrable error message when you try to

128
00:05:44,701 --> 00:05:46,902
look at the game just not not ideal.

129
00:05:49,321 --> 00:05:52,070
There were also many other tools and utilities that were part of the daily guerrilla workflow,

130
00:05:52,070 --> 00:05:53,635
but there isn't really time to go into them here.

131
00:05:55,658 --> 00:05:59,021
So one kind of tangential thing is that during shadow fall

132
00:05:59,021 --> 00:06:02,383
possibly out of just sheer frustration with the way that the tools pipeline was set up,

133
00:06:02,383 --> 00:06:04,124
the debug UI was created.

134
00:06:04,124 --> 00:06:07,286
And debug UI was an in-game user interface framework.

135
00:06:07,286 --> 00:06:09,387
It's a pretty feature-rich framework,

136
00:06:09,387 --> 00:06:11,288
but most importantly for what I'm talking about right now,

137
00:06:11,288 --> 00:06:13,690
it was something that programmers found very easy to use.

138
00:06:13,690 --> 00:06:16,631
And because of that, we ended up with a large number of very useful in-game tools.

139
00:06:16,631 --> 00:06:20,854
So I'm going to show one of those quickly, just so you can get an idea of what I'm talking about.

140
00:06:21,655 --> 00:06:24,257
So this is our in-game GPU profiler

141
00:06:24,257 --> 00:06:26,219
and you can see it displaying timing values

142
00:06:26,219 --> 00:06:27,660
for various draw calls during a frame

143
00:06:27,660 --> 00:06:30,062
and it allows you to jump to different points in the frame

144
00:06:30,062 --> 00:06:33,985
to examine the render targets or the back buffer.

145
00:06:33,985 --> 00:06:36,887
You can also see the inputs for the different samplers and so on.

146
00:06:36,887 --> 00:06:42,471
And it has an X-ray view which you can move over the scene

147
00:06:42,471 --> 00:06:44,833
and get an idea of which intermediate buffers

148
00:06:44,833 --> 00:06:46,834
are contributing to the final frame

149
00:06:46,834 --> 00:06:50,297
and what they actually look like.

150
00:06:50,297 --> 00:06:50,377
Yeah.

151
00:06:52,848 --> 00:06:55,330
So that was a little bit about the tools and some of the technology,

152
00:06:55,330 --> 00:06:57,211
but what about the game itself.

153
00:06:57,211 --> 00:06:59,192
So when starting out, we knew that Horizon was going to be very,

154
00:06:59,192 --> 00:07:00,634
very different to Killzone.

155
00:07:00,634 --> 00:07:02,455
We hadn't made an RPG before.

156
00:07:02,455 --> 00:07:04,056
We hadn't made an open-world game before.

157
00:07:04,056 --> 00:07:07,198
And aside from that, this game was going to include new types of content

158
00:07:07,198 --> 00:07:08,699
which we just hadn't built before,

159
00:07:08,699 --> 00:07:10,561
like quests and interactive conversations.

160
00:07:10,561 --> 00:07:13,983
And additionally, the tools team at Guerrilla is relatively small.

161
00:07:13,983 --> 00:07:17,706
So depending on how you count it, we had like four or six

162
00:07:17,706 --> 00:07:21,148
full-time tools programmers for a team size of about 220 people.

163
00:07:21,845 --> 00:07:23,847
So we had to be really efficient about how we used our time

164
00:07:23,847 --> 00:07:24,548
and our resources.

165
00:07:24,548 --> 00:07:27,590
All things considered, it was pretty clear

166
00:07:27,590 --> 00:07:29,852
that our extant tools pipeline would not easily

167
00:07:29,852 --> 00:07:31,353
scale to meet the demands of Horizon,

168
00:07:31,353 --> 00:07:32,694
so we decided to start again.

169
00:07:32,694 --> 00:07:35,476
So at this point, we were ready to define some initial goals

170
00:07:35,476 --> 00:07:36,417
for the new toolchain.

171
00:07:36,417 --> 00:07:40,140
And we decided to start by building a tools framework,

172
00:07:40,140 --> 00:07:42,482
which was going to act as the basis of all

173
00:07:42,482 --> 00:07:44,363
of our future tools development.

174
00:07:44,363 --> 00:07:46,325
And this was intended mainly to mitigate the

175
00:07:47,772 --> 00:07:49,413
arbitrary linguistic and technological differences

176
00:07:49,413 --> 00:07:51,595
between the tools and just enforce some consistency

177
00:07:51,595 --> 00:07:53,517
between all of them.

178
00:07:53,517 --> 00:07:55,578
Decima, which I'll cover a little bit later on,

179
00:07:55,578 --> 00:07:58,101
is our in-house engine, and we wanted to leverage

180
00:07:58,101 --> 00:08:00,182
as much of it as possible while building the new tools.

181
00:08:00,182 --> 00:08:02,845
And lastly, the debug UI had shown us that

182
00:08:02,845 --> 00:08:04,626
if it's easy to do so, then programmers will happily

183
00:08:04,626 --> 00:08:06,628
make tools for their game systems.

184
00:08:06,628 --> 00:08:07,729
So by using the engine libraries

185
00:08:07,729 --> 00:08:09,431
and keeping the others code simple,

186
00:08:09,431 --> 00:08:11,392
we would increase the chances of getting buy-in

187
00:08:11,392 --> 00:08:12,613
from other teams and, most importantly,

188
00:08:12,613 --> 00:08:14,775
help from other teams.

189
00:08:14,775 --> 00:08:14,915
And, yeah.

190
00:08:16,737 --> 00:08:19,618
So just because for an editing environment.

191
00:08:19,618 --> 00:08:21,879
We want to make sure that we build tools that would fit our

192
00:08:21,879 --> 00:08:24,801
content creators needs so that and we decided to build like

193
00:08:24,801 --> 00:08:27,463
specific editors for each discipline and we call these

194
00:08:27,463 --> 00:08:30,404
editing context and we built from usable components that we

195
00:08:30,404 --> 00:08:32,986
could then create new ones for other teams as they needed them

196
00:08:32,986 --> 00:08:35,747
and so these editing

197
00:08:35,747 --> 00:08:38,469
context would sit inside of it a single application where the

198
00:08:38,469 --> 00:08:40,630
content creator would be able to do all the work and this would

199
00:08:40,630 --> 00:08:42,771
become the integrated game development environment which we

200
00:08:42,771 --> 00:08:43,712
now call the decimator.

201
00:08:49,201 --> 00:08:52,302
So before continuing, I want to provide a little bit of background on Decima itself.

202
00:08:52,302 --> 00:08:54,263
Decima is, as I said, our in-house game engine,

203
00:08:54,263 --> 00:08:57,224
and most recently it was used for Killzone Shadowfall,

204
00:08:57,224 --> 00:08:59,465
RIGS, Mechanized Combat League, Horizon Zero Dawn,

205
00:08:59,465 --> 00:09:01,947
and is being used for the upcoming Kojima productions

206
00:09:01,947 --> 00:09:03,747
titled Death Stranding.

207
00:09:03,747 --> 00:09:05,468
And like most engines, it's separated into layers.

208
00:09:05,468 --> 00:09:08,870
So at the base, we have platform-independent game systems

209
00:09:08,870 --> 00:09:12,851
just above the OS, and this insulates the layers above from the operating system,

210
00:09:12,851 --> 00:09:14,992
which makes it just easier to port between different platforms.

211
00:09:14,992 --> 00:09:17,914
It's also important to note that our engine has always had a full PC build

212
00:09:17,914 --> 00:09:19,054
for development purposes.

213
00:09:20,241 --> 00:09:21,842
Next is core.

214
00:09:21,842 --> 00:09:23,323
This adds rendering and mesh primitives,

215
00:09:23,323 --> 00:09:24,243
lights, particles, and so on.

216
00:09:24,243 --> 00:09:26,305
And then game code on top of that,

217
00:09:26,305 --> 00:09:27,765
which adds more specific game features

218
00:09:27,765 --> 00:09:29,786
such as entities and crowds and cinematics.

219
00:09:29,786 --> 00:09:32,168
So we wanted to put the tools framework on top of that stack

220
00:09:32,168 --> 00:09:34,449
so that we would have access to everything below.

221
00:09:34,449 --> 00:09:35,330
Decima is a very mature code base,

222
00:09:35,330 --> 00:09:36,410
and it contained many libraries

223
00:09:36,410 --> 00:09:39,132
that would be useful for tools development.

224
00:09:39,132 --> 00:09:40,713
So here you can see the kind of things

225
00:09:40,713 --> 00:09:42,874
that we were interested in taking advantage of.

226
00:09:42,874 --> 00:09:44,795
One of the most important features

227
00:09:44,795 --> 00:09:47,196
was the engine's super optimized RTTI system,

228
00:09:47,196 --> 00:09:48,737
or runtime type introspection system.

229
00:09:49,250 --> 00:09:51,150
which is exactly what we need to be able to manipulate data

230
00:09:51,150 --> 00:09:53,230
in an Editor. So aside from getting a lot of well-written

231
00:09:53,230 --> 00:09:55,171
code for free, using the Decima Engine libraries

232
00:09:55,171 --> 00:09:57,771
would also mean that the Editor's code would present

233
00:09:57,771 --> 00:10:00,432
a lower barrier to entry for the other programmers in the company

234
00:10:00,432 --> 00:10:02,132
when compared to the Cortex Editor and SMED

235
00:10:02,132 --> 00:10:03,352
and the Maya plugin.

236
00:10:03,352 --> 00:10:05,873
So to fast forward a little bit, here's the Decima Editor

237
00:10:05,873 --> 00:10:06,933
as it exists today.

238
00:10:06,933 --> 00:10:10,594
And this is our level Editor context,

239
00:10:10,594 --> 00:10:12,654
which is a 3D viewport onto the game

240
00:10:12,654 --> 00:10:14,154
and an Asset Browser at the bottom,

241
00:10:14,154 --> 00:10:15,435
a hierarchical outliner on the left,

242
00:10:15,435 --> 00:10:17,015
and an Attributed Editor on the right.

243
00:10:17,015 --> 00:10:18,515
Pretty standard stuff that you would expect to see.

244
00:10:19,186 --> 00:10:21,309
This is a shot of our visual script editor,

245
00:10:21,309 --> 00:10:24,172
which is used for almost all of our in-game designer-driven logic.

246
00:10:24,172 --> 00:10:25,794
It has a 2D diagram renderer,

247
00:10:25,794 --> 00:10:27,236
which displays the logic graph of the script.

248
00:10:27,236 --> 00:10:30,199
On the right, you can see it uses the same attribute editor

249
00:10:30,199 --> 00:10:30,840
as the previous slide.

250
00:10:32,270 --> 00:10:34,511
And finally, here's a shot of our conversation editor

251
00:10:34,511 --> 00:10:35,571
or dialogue editor.

252
00:10:35,571 --> 00:10:38,952
So it uses the same diagram render as the last view,

253
00:10:38,952 --> 00:10:42,272
but to show the logic graph of the conversation.

254
00:10:42,272 --> 00:10:44,193
And this time, there's two new components.

255
00:10:44,193 --> 00:10:46,113
So on the bottom left, there is a timeline

256
00:10:46,113 --> 00:10:49,434
for positioning stuff inside of a sequencer

257
00:10:49,434 --> 00:10:50,994
and a screenplay editor for writers

258
00:10:50,994 --> 00:10:52,414
who work on the in-game dialogue,

259
00:10:52,414 --> 00:10:53,135
which is on the bottom right.

260
00:10:53,135 --> 00:10:53,235
So we...

261
00:10:57,526 --> 00:10:58,627
We'd established some initial goals,

262
00:10:58,627 --> 00:11:00,488
and we actually needed to start moving at this point.

263
00:11:00,488 --> 00:11:02,350
But the thing is, Killzone was already finished,

264
00:11:02,350 --> 00:11:05,272
and aside from a few people who were remaining on the project

265
00:11:05,272 --> 00:11:06,613
to support multiplayer and DLC,

266
00:11:06,613 --> 00:11:07,934
everybody was moving onto Horizon.

267
00:11:07,934 --> 00:11:09,695
So production was already starting.

268
00:11:09,695 --> 00:11:12,237
And despite the fact there was many issues

269
00:11:12,237 --> 00:11:13,838
with the Killzone toolchain, it did work.

270
00:11:13,838 --> 00:11:14,879
You could make a game with it,

271
00:11:14,879 --> 00:11:17,581
and the content creators were familiar with those tools,

272
00:11:17,581 --> 00:11:19,463
so they didn't necessarily even want anything to change,

273
00:11:19,463 --> 00:11:21,224
which seems illogical, but that's just how it was.

274
00:11:22,311 --> 00:11:26,413
And we also had no way to gauge how successful we'd be in this endeavor.

275
00:11:26,413 --> 00:11:28,674
So we were going to have to start really small, minimize risks.

276
00:11:28,674 --> 00:11:30,675
We couldn't disrupt the production of the game,

277
00:11:30,675 --> 00:11:33,617
and therefore we would need to continue supporting the old tools

278
00:11:33,617 --> 00:11:35,418
while we did this drive for new stuff.

279
00:11:37,655 --> 00:11:39,536
So with that in mind, we decided to focus on a single team,

280
00:11:39,536 --> 00:11:41,137
which was our audio team.

281
00:11:41,137 --> 00:11:43,439
And it represents a pretty small group of users.

282
00:11:43,439 --> 00:11:44,920
At this time, it was around four people,

283
00:11:44,920 --> 00:11:46,781
and they have a very specific set of needs

284
00:11:46,781 --> 00:11:47,922
for their workflow.

285
00:11:47,922 --> 00:11:49,403
So by essentially porting this workflow

286
00:11:49,403 --> 00:11:50,583
from the core text editor

287
00:11:50,583 --> 00:11:51,924
into the fledgling Decima editor,

288
00:11:51,924 --> 00:11:54,426
we would have an isolated test case

289
00:11:54,426 --> 00:11:56,607
for the viability of the framework as a whole.

290
00:11:56,607 --> 00:12:00,210
So our audio team works primarily with NodeGraphs,

291
00:12:00,210 --> 00:12:03,892
and NodeGraph is a high-performance visual scripting

292
00:12:03,892 --> 00:12:05,593
language that we developed in-house.

293
00:12:06,233 --> 00:12:08,314
And this is a technology that we,

294
00:12:08,314 --> 00:12:10,035
it generates C++ by the way,

295
00:12:10,035 --> 00:12:11,275
which runs natively on the target.

296
00:12:11,275 --> 00:12:14,516
And this was something we used very heavily in Shadowfall,

297
00:12:14,516 --> 00:12:16,836
and it was being proposed as a replacement for SMED and Lua.

298
00:12:16,836 --> 00:12:18,257
So this meant that if we were successful

299
00:12:18,257 --> 00:12:20,117
in porting this audio team's workflow,

300
00:12:20,117 --> 00:12:21,418
then later it would have benefits

301
00:12:21,418 --> 00:12:23,318
for other teams in production.

302
00:12:23,318 --> 00:12:26,819
If you're interested in learning more about this technology,

303
00:12:26,819 --> 00:12:28,260
there's actually a talk from GDC 2014

304
00:12:28,260 --> 00:12:30,200
by Andreas Varga and Anton Waltek,

305
00:12:30,200 --> 00:12:31,481
and they go into some detail

306
00:12:31,481 --> 00:12:32,601
about how our audio system works.

307
00:12:35,073 --> 00:12:36,293
So as a reminder, this is the thing

308
00:12:36,293 --> 00:12:38,014
that we were trying to replace.

309
00:12:38,014 --> 00:12:40,116
And this is our first prototype,

310
00:12:40,116 --> 00:12:41,556
which we built in C++ and Qt.

311
00:12:41,556 --> 00:12:43,597
It used Qt's QPainter class for the diagram,

312
00:12:43,597 --> 00:12:46,579
displayed the nodes in a similar visual style

313
00:12:46,579 --> 00:12:48,000
to the old editor.

314
00:12:48,000 --> 00:12:50,001
At this point, it wasn't very usable.

315
00:12:50,001 --> 00:12:51,522
It was basically just like a read-only display

316
00:12:51,522 --> 00:12:52,742
for node graphs that already existed.

317
00:12:54,918 --> 00:12:57,340
We also had some performance issues with Qt,

318
00:12:57,340 --> 00:12:59,501
so we decided that now we had access to Decima's renderer,

319
00:12:59,501 --> 00:13:03,204
we could just rewrite the diagram rendering using that.

320
00:13:03,204 --> 00:13:05,606
So that allowed us to write the diagram renderer

321
00:13:05,606 --> 00:13:06,987
as a single, it draws a single quad

322
00:13:06,987 --> 00:13:08,167
and then it has some pixel shader magic

323
00:13:08,167 --> 00:13:09,128
to draw the entire thing.

324
00:13:09,128 --> 00:13:10,229
It was super fast.

325
00:13:10,229 --> 00:13:11,810
It can handle huge amounts of data.

326
00:13:11,810 --> 00:13:12,771
Wasn't very useful though,

327
00:13:12,771 --> 00:13:14,492
because you still couldn't edit or save or anything,

328
00:13:14,492 --> 00:13:15,953
but it looked pretty good.

329
00:13:17,905 --> 00:13:20,847
And this is what we have today, kind of skipping forward a few steps.

330
00:13:20,847 --> 00:13:23,589
So once we added an attribute editor and a way to browse for files

331
00:13:23,589 --> 00:13:24,730
and save them and edit them and so on,

332
00:13:24,730 --> 00:13:28,132
we managed to convince one or two members of the audio team to just try it out.

333
00:13:28,132 --> 00:13:31,134
And this was a really, really painful process, actually.

334
00:13:31,134 --> 00:13:35,357
It required many iterations, and every time they came up against something

335
00:13:35,357 --> 00:13:36,658
that wasn't possible in the new editor,

336
00:13:36,658 --> 00:13:39,040
they would just immediately go back to using the old tools.

337
00:13:39,040 --> 00:13:40,701
But we focused a lot of our energy on implementing features

338
00:13:40,701 --> 00:13:43,643
that they were missing and eventually achieve feature parity

339
00:13:43,643 --> 00:13:45,364
with the old editor, and these guys started working

340
00:13:45,364 --> 00:13:46,405
in the Decima editor every day.

341
00:13:48,854 --> 00:13:51,436
So it was our initial test case and it worked pretty well.

342
00:13:51,436 --> 00:13:53,138
We reached feature parity with the old editor

343
00:13:53,138 --> 00:13:54,980
much more quickly than we anticipated.

344
00:13:54,980 --> 00:13:56,841
And because we shed this like onerous complexity

345
00:13:56,841 --> 00:13:58,323
of the old editor, it meant that we could implement

346
00:13:58,323 --> 00:14:00,545
new features very easily.

347
00:14:00,545 --> 00:14:02,187
And most importantly, programmers from other teams

348
00:14:02,187 --> 00:14:03,568
were comfortable enough with the code

349
00:14:03,568 --> 00:14:05,370
that they were able to contribute

350
00:14:05,370 --> 00:14:06,251
some pretty awesome features.

351
00:14:06,251 --> 00:14:07,892
But I'll come back to that later.

352
00:14:07,892 --> 00:14:09,514
For now, I'll hand over to Sandra.

353
00:14:14,821 --> 00:14:17,243
OK, thank you, Dan.

354
00:14:17,243 --> 00:14:20,985
So the Node Graph editor gave the tools team the necessary

355
00:14:20,985 --> 00:14:23,607
confidence to pick up the next larger project.

356
00:14:23,607 --> 00:14:26,169
And that would be creating a level editor, or 3D editor, as

357
00:14:26,169 --> 00:14:26,469
we call it.

358
00:14:26,469 --> 00:14:30,132
So in the next section, I'll explain some of the early

359
00:14:30,132 --> 00:14:31,753
design decisions that led to this new editor.

360
00:14:31,753 --> 00:14:35,595
So why create a 3D editor at this stage, you might wonder.

361
00:14:35,595 --> 00:14:38,437
As Dan mentioned, we were already in production, and so

362
00:14:38,437 --> 00:14:39,758
this is fairly ambitious.

363
00:14:39,758 --> 00:14:42,440
Why did we not just simply invest more

364
00:14:42,440 --> 00:14:43,321
into our Maya plugin?

365
00:14:44,088 --> 00:14:48,631
So first of all, the first reason

366
00:14:48,631 --> 00:14:51,673
was that Horizon Zero Dawn needed a lot of Quest content,

367
00:14:51,673 --> 00:14:55,035
which is a somewhat new content type coming from the Killzone

368
00:14:55,035 --> 00:14:55,615
series.

369
00:14:55,615 --> 00:14:59,338
So the game design workflow that we had in place in Maya

370
00:14:59,338 --> 00:15:02,019
was really the worst part of our Maya plug-in

371
00:15:02,019 --> 00:15:03,760
in terms of usability.

372
00:15:03,760 --> 00:15:08,423
Maya is simply not designed to do any level editing.

373
00:15:08,423 --> 00:15:10,024
So secondly.

374
00:15:11,247 --> 00:15:15,108
the 3D editor, a 3D editor like Unreal Unity

375
00:15:15,108 --> 00:15:18,109
would eventually benefit other workflows as well.

376
00:15:18,109 --> 00:15:21,390
It is a formidable task, and if we hadn't started it back then,

377
00:15:21,390 --> 00:15:23,230
it would have never been able to finish it in time

378
00:15:23,230 --> 00:15:24,270
for Horizon in the first place.

379
00:15:24,270 --> 00:15:28,332
And finally, the game design team

380
00:15:28,332 --> 00:15:30,092
offered a very achievable starting point

381
00:15:30,092 --> 00:15:31,373
for us to work on a 3D editor.

382
00:15:31,373 --> 00:15:34,894
If we could facilitate only object placement in the game,

383
00:15:34,894 --> 00:15:37,494
we would already provide a huge workflow improvement

384
00:15:37,494 --> 00:15:38,435
for the game design team.

385
00:15:40,660 --> 00:15:42,762
So now that we've established why we wanted this 3D editor,

386
00:15:42,762 --> 00:15:45,984
let's have a look at how we can actually achieve this.

387
00:15:45,984 --> 00:15:47,486
Looking at what we have available,

388
00:15:47,486 --> 00:15:49,487
a tools framework in its infancy,

389
00:15:49,487 --> 00:15:52,290
and a game executable, we are immediately

390
00:15:52,290 --> 00:15:54,732
presented with the first choice.

391
00:15:54,732 --> 00:15:58,936
Do we integrate the desired game subsystems into our editor,

392
00:15:58,936 --> 00:16:00,197
as illustrated on the left?

393
00:16:00,197 --> 00:16:03,399
Or do we actually merge the full game

394
00:16:03,399 --> 00:16:05,541
into our editor environment?

395
00:16:05,541 --> 00:16:08,484
So let's zoom into using only game subsystems.

396
00:16:09,189 --> 00:16:12,030
So this is the advantage of being able to tailor make your

397
00:16:12,030 --> 00:16:14,752
game loop based specifically on your editor needs.

398
00:16:14,752 --> 00:16:17,193
This leads to a very controllable viewport,

399
00:16:17,193 --> 00:16:18,533
skipping unwanted game subsystems.

400
00:16:18,533 --> 00:16:22,015
However, doing this will introduce a second code path

401
00:16:22,015 --> 00:16:25,096
where these systems will be used, leading to code

402
00:16:25,096 --> 00:16:27,798
complexity and potentially disparity between what you'll

403
00:16:27,798 --> 00:16:31,039
see in your editor versus what you see in the final game.

404
00:16:31,039 --> 00:16:32,700
Because more code is required, it will also

405
00:16:32,700 --> 00:16:33,740
take longer to develop.

406
00:16:34,951 --> 00:16:37,212
So the alternative then is integrating the full game in

407
00:16:37,212 --> 00:16:37,653
the editor.

408
00:16:37,653 --> 00:16:40,935
Game systems would truly function as they would in

409
00:16:40,935 --> 00:16:43,056
game, and as an added bonus, we can use the earlier

410
00:16:43,056 --> 00:16:45,878
discussed debug UI for free to give us a head start.

411
00:16:45,878 --> 00:16:49,820
We would also be able to play in the editor just like we

412
00:16:49,820 --> 00:16:52,022
would be able to do in game.

413
00:16:52,022 --> 00:16:54,563
As a disadvantage, though, it does introduce more overhead,

414
00:16:54,563 --> 00:16:57,385
as a lot of game subsystems are usually not required for

415
00:16:57,385 --> 00:16:58,626
certain editing operations.

416
00:16:59,182 --> 00:17:00,984
An example of this would be a weather system.

417
00:17:00,984 --> 00:17:03,926
It's typically not very useful for the game

418
00:17:03,926 --> 00:17:05,387
to be raining when you're actually

419
00:17:05,387 --> 00:17:06,268
just placing an object.

420
00:17:06,268 --> 00:17:09,350
It's both a hindrance for performance and usability.

421
00:17:09,350 --> 00:17:12,252
So given the time considerations that we had at

422
00:17:12,252 --> 00:17:16,376
hand, remember that we were already in production, we

423
00:17:16,376 --> 00:17:20,919
really felt that integrating the full game would be our

424
00:17:20,919 --> 00:17:21,420
best option.

425
00:17:23,074 --> 00:17:25,476
So now that we want the full game running in the editor,

426
00:17:25,476 --> 00:17:27,337
how do we actually achieve that?

427
00:17:27,337 --> 00:17:29,099
We're faced with another decision.

428
00:17:29,099 --> 00:17:31,921
Do we run the game in the same process as the editor,

429
00:17:31,921 --> 00:17:35,284
or as we depict on the left here?

430
00:17:35,284 --> 00:17:37,766
Or do we attach the editor to the game executable

431
00:17:37,766 --> 00:17:39,887
and use an out-of-process solution?

432
00:17:39,887 --> 00:17:42,889
Again, we examined our options.

433
00:17:42,889 --> 00:17:45,451
An in-process game is faster to set up and easier to debug

434
00:17:45,451 --> 00:17:48,754
because all data changes are direct and synchronous.

435
00:17:49,795 --> 00:17:52,016
A crash in the game is problematic, though,

436
00:17:52,016 --> 00:17:55,258
as it will inevitably take down the editor, which

437
00:17:55,258 --> 00:17:57,599
will cause loss of work and loss of frustration.

438
00:17:57,599 --> 00:18:00,421
It also makes it easy to modify in-game data directly,

439
00:18:00,421 --> 00:18:02,782
as you can access game objects via pointers.

440
00:18:02,782 --> 00:18:04,263
Over time, you could end up with a situation

441
00:18:04,263 --> 00:18:07,445
where many different systems in the editor

442
00:18:07,445 --> 00:18:10,567
would access different systems in the game.

443
00:18:11,001 --> 00:18:13,821
We felt that this would lead to an unmanageable situation,

444
00:18:13,821 --> 00:18:16,622
but enforcing this separation, we

445
00:18:16,622 --> 00:18:20,463
figured that would be hard, because due to time constraints,

446
00:18:20,463 --> 00:18:25,804
it's ever so tempting to just directly access a game system.

447
00:18:25,804 --> 00:18:28,004
An out-of-process solution, on the other hand,

448
00:18:28,004 --> 00:18:30,285
offers more stability, primarily because you

449
00:18:30,285 --> 00:18:33,685
would be able to recover from a crashing game.

450
00:18:33,685 --> 00:18:36,126
Because the game is a separate process,

451
00:18:36,126 --> 00:18:37,766
coders are forced to work in a cleaner way.

452
00:18:38,918 --> 00:18:42,741
as the editor cannot directly modify game objects via pointers.

453
00:18:42,741 --> 00:18:46,885
Finally, UI updates are not tied to the frame updates in the game and so your UI will be

454
00:18:46,885 --> 00:18:49,508
more responsive, even though the game might not be.

455
00:18:49,508 --> 00:18:53,451
So the downside of this is that you have to write a communication layer, resulting in

456
00:18:53,451 --> 00:18:55,013
a longer initial development time.

457
00:18:55,013 --> 00:19:01,278
This communication layer would also be asynchronous, which make it quite tricky for debugging.

458
00:19:03,147 --> 00:19:05,630
So similar to the decision on integrating the full game, we

459
00:19:05,630 --> 00:19:08,352
went for an in-process solution because of the time

460
00:19:08,352 --> 00:19:09,814
constraints and pressure from production.

461
00:19:09,814 --> 00:19:12,876
We did decide that an out-of-process solution should

462
00:19:12,876 --> 00:19:15,719
always remain an option later on, and so wanted to ensure

463
00:19:15,719 --> 00:19:16,800
code separation.

464
00:19:16,800 --> 00:19:19,903
To enforce this code separation, we developed the

465
00:19:19,903 --> 00:19:23,206
3D editor as if the game was running in a separate process.

466
00:19:23,206 --> 00:19:25,188
No data was to be shared between the

467
00:19:25,188 --> 00:19:26,149
editor and the game.

468
00:19:27,700 --> 00:19:31,902
Because of this separation that we quite strictly enforced,

469
00:19:31,902 --> 00:19:35,264
I'll continue to use the word process to describe,

470
00:19:35,264 --> 00:19:38,405
like editor process, meaning code executing in the editor,

471
00:19:38,405 --> 00:19:44,928
and game process for code executed in the game.

472
00:19:44,928 --> 00:19:45,208
Anyway.

473
00:19:45,732 --> 00:19:49,275
Luckily for us, making these early quick gains

474
00:19:49,275 --> 00:19:49,995
paid off quite well.

475
00:19:49,995 --> 00:19:53,858
So I have a video I'm about to show you here from roughly a

476
00:19:53,858 --> 00:19:55,980
year after starting in 3D Editor.

477
00:19:55,980 --> 00:20:00,523
And it demonstrates how a game designer uses the ability to

478
00:20:00,523 --> 00:20:03,725
play in the editor for his workflow.

479
00:20:03,725 --> 00:20:08,809
So to start off, the designer explores some section of the

480
00:20:08,809 --> 00:20:12,852
world in play mode, decides this is a nice spot for an

481
00:20:12,852 --> 00:20:14,873
encounter, and so goes into edit mode.

482
00:20:15,582 --> 00:20:18,023
Now there are some trees in the middle here.

483
00:20:18,023 --> 00:20:21,104
So what we're going to do is we're going to paint them out

484
00:20:21,104 --> 00:20:22,044
to clear the area a bit.

485
00:20:22,044 --> 00:20:26,005
And we also want to paint some more trees in the surroundings.

486
00:20:26,005 --> 00:20:27,426
So we're just going to do that.

487
00:20:27,426 --> 00:20:30,847
And then in the center of the screen

488
00:20:30,847 --> 00:20:32,587
where you want to place this encounter,

489
00:20:32,587 --> 00:20:34,768
you want to flatten the terrain out a bit.

490
00:20:34,768 --> 00:20:37,108
So we use some terrain sculpting magic for that.

491
00:20:42,612 --> 00:20:45,493
And so this looks like now we can actually place our encounter.

492
00:20:45,493 --> 00:20:49,794
So we use the content hierarchy on the left to create an encounter, give it a name,

493
00:20:49,794 --> 00:20:56,516
create it in the middle, use the asset browser also on the left to create some robots.

494
00:20:56,516 --> 00:21:01,458
So now we have two robots and we want to add a rock in the middle,

495
00:21:01,458 --> 00:21:03,378
provide some player cover perhaps.

496
00:21:03,378 --> 00:21:06,279
I'm not a game designer, so I wouldn't really know.

497
00:21:06,279 --> 00:21:11,001
But yeah, so we just use the tools to drag drop the rock in, place it.

498
00:21:11,856 --> 00:21:13,337
Save it, going to try it out.

499
00:21:13,337 --> 00:21:16,458
So now we're immediately back into edit mode.

500
00:21:16,458 --> 00:21:19,440
And yeah, Aloy can shoot some robots and see if this

501
00:21:19,440 --> 00:21:20,240
actually works out well.

502
00:21:20,240 --> 00:21:20,580
Pretty sweet.

503
00:21:20,580 --> 00:21:25,563
So with our high-level design now discussed, let's look into

504
00:21:25,563 --> 00:21:29,265
some subsystems that we required for this 3D editor to

505
00:21:29,265 --> 00:21:29,965
actually work.

506
00:21:29,965 --> 00:21:32,826
So in this section, we'll also see how we deal with the

507
00:21:32,826 --> 00:21:35,648
separation between editor code and game code.

508
00:21:37,523 --> 00:21:39,925
So a problem that you encounter quite early on when

509
00:21:39,925 --> 00:21:43,187
then diving into this solution is that the data that is in

510
00:21:43,187 --> 00:21:45,149
the game is not necessarily the same as the

511
00:21:45,149 --> 00:21:46,310
data that is on disk.

512
00:21:46,310 --> 00:21:49,052
This is caused by the process called conversion that Dan

513
00:21:49,052 --> 00:21:49,713
explained earlier.

514
00:21:49,713 --> 00:21:53,876
Examples of what can happen in conversion are shader

515
00:21:53,876 --> 00:21:56,859
compilation, and mesh optimization, et cetera.

516
00:21:56,859 --> 00:22:01,262
So having this optimized game data is a fairly common

517
00:22:01,262 --> 00:22:04,004
situation in games, but it provides a problem for editing

518
00:22:04,004 --> 00:22:05,145
as information is lost.

519
00:22:06,065 --> 00:22:09,386
Saving out cortex based objects that are read by the editor is

520
00:22:09,386 --> 00:22:13,228
not always possible once you're in the binary game data.

521
00:22:13,228 --> 00:22:17,190
So luckily, we already stated that we did not want the

522
00:22:17,190 --> 00:22:21,052
editor to operate directly on the data in the game.

523
00:22:21,052 --> 00:22:24,073
As a result, the editor works on the cortex counterpart, if

524
00:22:24,073 --> 00:22:27,235
you will, from the loaded binary data in the game.

525
00:22:27,235 --> 00:22:30,216
Each process, therefore, has its own copy of the data, and

526
00:22:30,216 --> 00:22:32,217
it cannot access the copy of the other process.

527
00:22:34,462 --> 00:22:38,647
So data in the editor is not identical nor shared between

528
00:22:38,647 --> 00:22:39,788
editor and game.

529
00:22:39,788 --> 00:22:42,691
A central concept in dealing with this problem is something

530
00:22:42,691 --> 00:22:44,113
that we call the editor node.

531
00:22:44,113 --> 00:22:48,238
So editor nodes provide all editing functionality for an

532
00:22:48,238 --> 00:22:50,000
object in the game.

533
00:22:50,000 --> 00:22:54,765
An editor node knows about a game object, but this is a

534
00:22:54,765 --> 00:22:55,706
one-directional relationship.

535
00:22:56,548 --> 00:22:59,650
So this is a convenient way of keeping the game code clean.

536
00:22:59,650 --> 00:23:02,250
The editor node lives in a separate project and code file

537
00:23:02,250 --> 00:23:05,612
from the game, and so the game code stays very clean.

538
00:23:05,612 --> 00:23:08,352
There's no hash ifdef editor in our code base.

539
00:23:08,352 --> 00:23:13,054
Second problem caused by the game operating on the

540
00:23:13,054 --> 00:23:14,615
converted data is hierarchy.

541
00:23:14,615 --> 00:23:17,896
For performance reasons, the game has little hierarchy of

542
00:23:17,896 --> 00:23:20,877
objects left remaining, resulting in a long, flat list

543
00:23:20,877 --> 00:23:22,257
of objects that are all in world space.

544
00:23:23,300 --> 00:23:26,681
This is very fast and efficient for rendering in the game,

545
00:23:26,681 --> 00:23:29,022
but not very good for editing, as often we

546
00:23:29,022 --> 00:23:30,703
want to edit in local space.

547
00:23:30,703 --> 00:23:33,344
So in order to restore some hierarchy of objects

548
00:23:33,344 --> 00:23:36,485
for editing in game, we built a hierarchical tree structure

549
00:23:36,485 --> 00:23:38,126
of these editor nodes.

550
00:23:38,126 --> 00:23:41,828
So this is done once the game is loaded

551
00:23:41,828 --> 00:23:43,328
and the user enters the edit mode.

552
00:23:43,328 --> 00:23:45,969
The tree is constructed top down,

553
00:23:45,969 --> 00:23:48,490
starting at the content root, and reflects the content that

554
00:23:48,490 --> 00:23:49,531
is currently loaded in the game.

555
00:23:51,271 --> 00:23:53,793
So having a single editor node tree, as shown on the image

556
00:23:53,793 --> 00:23:57,296
here, would violate our earlier stated goal that the editor

557
00:23:57,296 --> 00:23:59,518
cannot directly modify game data.

558
00:23:59,518 --> 00:24:04,062
The tree structure is built up in game, and so it should only

559
00:24:04,062 --> 00:24:06,824
be used by the code living in the game.

560
00:24:06,824 --> 00:24:10,447
So in order to facilitate editing hierarchical data, we

561
00:24:10,447 --> 00:24:12,369
actually have two editor node trees.

562
00:24:12,369 --> 00:24:17,313
So this allows both the editor and the game to reason about

563
00:24:17,313 --> 00:24:19,615
content hierarchy and do world or local space

564
00:24:19,615 --> 00:24:20,435
conversions, et cetera.

565
00:24:21,379 --> 00:24:23,580
So these two trees are structurally identical,

566
00:24:23,580 --> 00:24:25,801
but reference different data.

567
00:24:25,801 --> 00:24:29,142
Changes made in the editor are mapped onto the node tree

568
00:24:29,142 --> 00:24:32,003
and communicated to the game.

569
00:24:32,003 --> 00:24:34,044
So what we actually communicate in our editor

570
00:24:34,044 --> 00:24:35,364
is the next part of this presentation,

571
00:24:35,364 --> 00:24:37,045
and for which I'll hand over back to Dan.

572
00:24:37,045 --> 00:24:38,265
All right, so making changes to objects.

573
00:24:47,118 --> 00:24:48,318
When defining goals or requirements,

574
00:24:48,318 --> 00:24:49,799
it's sometimes important to list things

575
00:24:49,799 --> 00:24:50,879
that you know you don't want.

576
00:24:50,879 --> 00:24:53,000
And in our case, after working with the Quotext editor

577
00:24:53,000 --> 00:24:56,021
and to a lesser extent the other legacy tools,

578
00:24:56,021 --> 00:24:58,222
we had a pretty good idea of what we didn't want.

579
00:24:58,222 --> 00:25:00,322
So we didn't want to have any kind of proxy representations

580
00:25:00,322 --> 00:25:02,823
for game objects or string-based accessors

581
00:25:02,823 --> 00:25:05,504
or editor-specific boilerplate in the code

582
00:25:05,504 --> 00:25:07,465
or any kind of code generation steps in the build pipeline

583
00:25:07,465 --> 00:25:08,545
that would make the editor work.

584
00:25:08,545 --> 00:25:09,445
And that helped us to define some goals

585
00:25:09,445 --> 00:25:14,167
when it came to how we wanted to actually write the editor code.

586
00:25:14,167 --> 00:25:14,207
So...

587
00:25:15,130 --> 00:25:16,791
In the editor code, we wanted to just work directly

588
00:25:16,791 --> 00:25:19,152
with the concrete objects that the C++ classes

589
00:25:19,152 --> 00:25:20,493
and structs that were defined in the engine.

590
00:25:20,493 --> 00:25:23,535
And data modification by the code should just be performed

591
00:25:23,535 --> 00:25:26,376
with direct member access or via accessor functions.

592
00:25:26,376 --> 00:25:29,878
And mostly as a corollary of these two goals,

593
00:25:29,878 --> 00:25:32,079
we should be able to reuse any kind of existing

594
00:25:32,079 --> 00:25:34,341
data transformation utilities that already existed

595
00:25:34,341 --> 00:25:36,542
within the engine code and within our conversion pipeline.

596
00:25:36,542 --> 00:25:39,123
So doing these things would mean that our game

597
00:25:39,123 --> 00:25:43,025
and engine programmers would also understand the editor code

598
00:25:43,025 --> 00:25:44,166
and would find it easy to work with.

599
00:25:46,088 --> 00:25:51,072
So being able to make changes is good, but what is best in life?

600
00:25:51,072 --> 00:25:55,075
In any kind of data editing environment, it's critical to be able to undo changes that have been made,

601
00:25:55,075 --> 00:25:57,896
and this allows users to experiment, to recover from their mistakes,

602
00:25:57,896 --> 00:25:59,838
and generally feel like they're in control over what's actually going on.

603
00:25:59,838 --> 00:26:04,841
So, looking at this slide, like the first goal seems almost redundant to state,

604
00:26:04,841 --> 00:26:06,022
but it is actually important.

605
00:26:06,022 --> 00:26:10,685
The code for the undo system had to be as simple and reliable as possible,

606
00:26:10,685 --> 00:26:12,706
and in the interest of accomplishing these goals,

607
00:26:12,706 --> 00:26:14,788
we decided to avoid the kind of common...

608
00:26:15,644 --> 00:26:17,686
uh, command pattern which involves a virtual do and undo function.

609
00:26:17,686 --> 00:26:20,568
Um, because, well, there's two reasons for this.

610
00:26:20,568 --> 00:26:24,431
Like, the first is we didn't think the undo system or anything related to it should need to change

611
00:26:24,431 --> 00:26:25,913
in order to support new editor features.

612
00:26:25,913 --> 00:26:29,476
And we wanted to remove the

613
00:26:29,476 --> 00:26:31,638
possibility of having asymmetric data transformations.

614
00:26:31,638 --> 00:26:35,922
That is to say, an undo implementation that isn't the exact inverse of its do implementation.

615
00:26:37,929 --> 00:26:40,332
So given that we're approaching this whole thing from a completely clean slate,

616
00:26:40,332 --> 00:26:42,476
we may as well consider a totally ideal scenario.

617
00:26:42,476 --> 00:26:46,963
And in our case, that would be a system that just sees all the changes that are being made in the editor,

618
00:26:46,963 --> 00:26:48,645
knows how to undo those changes automatically.

619
00:26:49,089 --> 00:26:50,450
So we investigated this a little bit,

620
00:26:50,450 --> 00:26:53,271
but quickly found that such a system involved way too much overhead.

621
00:26:53,271 --> 00:26:54,992
And it was also pretty difficult to delineate

622
00:26:54,992 --> 00:26:57,073
when complicated changes were starting and ending.

623
00:26:57,073 --> 00:27:00,135
So the compromise that we settled for is that before modifying data,

624
00:27:00,135 --> 00:27:02,476
a programmer will provide some hints to the undo system

625
00:27:02,476 --> 00:27:03,997
about which objects are going to be modified,

626
00:27:03,997 --> 00:27:06,238
and then perform some modifications,

627
00:27:06,238 --> 00:27:08,119
and later indicate when those modifications are complete.

628
00:27:10,876 --> 00:27:12,437
So it's actually described changes in the editor.

629
00:27:12,437 --> 00:27:15,358
We use a transaction system, and the transactions

630
00:27:15,358 --> 00:27:16,759
consist of commands.

631
00:27:16,759 --> 00:27:18,800
And you can see a pretty simplistic example

632
00:27:18,800 --> 00:27:19,461
of such a thing here.

633
00:27:19,461 --> 00:27:23,242
But each command describes a simple individual change,

634
00:27:23,242 --> 00:27:25,324
such as the addition or removal of an object

635
00:27:25,324 --> 00:27:27,124
or an individual change to an attribute value.

636
00:27:27,124 --> 00:27:29,506
And these changes are annotated with RTTI

637
00:27:29,506 --> 00:27:30,966
so that we have enough information

638
00:27:30,966 --> 00:27:33,067
to actually use these transactions to transform

639
00:27:33,067 --> 00:27:33,568
the editor data.

640
00:27:35,742 --> 00:27:38,504
And the transaction system also has a subscriber mechanism,

641
00:27:38,504 --> 00:27:41,386
which allows you to receive notifications for all data

642
00:27:41,386 --> 00:27:43,347
changes that are happening in the editor.

643
00:27:43,347 --> 00:27:47,791
And this system is mostly used to update the user interface

644
00:27:47,791 --> 00:27:49,912
inside of the tool, have the visual representation

645
00:27:49,912 --> 00:27:51,593
of the data remain in sync with the backing data.

646
00:27:51,593 --> 00:27:55,136
So when a transaction is created or applied against the data,

647
00:27:56,991 --> 00:27:59,332
It is sent around to all the registered listeners in the editor.

648
00:27:59,332 --> 00:28:00,772
So in this case, that would be the individual components

649
00:28:00,772 --> 00:28:02,092
that have subscribed for notifications.

650
00:28:02,092 --> 00:28:05,433
And each listener is free to respond to the data change however it likes.

651
00:28:05,433 --> 00:28:08,194
But typically, a controller will inspect the transaction

652
00:28:08,194 --> 00:28:10,454
to see if any of the data which is being changed

653
00:28:10,454 --> 00:28:11,935
is represented in the view,

654
00:28:11,935 --> 00:28:14,115
and then it will just update its visual representation.

655
00:28:14,115 --> 00:28:17,936
For our views, we follow the Model-View-Controller pattern quite strictly,

656
00:28:17,936 --> 00:28:21,197
which has a few advantages in such a system.

657
00:28:21,197 --> 00:28:24,257
Mostly, code separation in that our components

658
00:28:24,257 --> 00:28:25,678
don't need to know about each other or even...

659
00:28:26,307 --> 00:28:27,227
communicate with each other.

660
00:28:27,227 --> 00:28:29,028
They're only interested in representing data,

661
00:28:29,028 --> 00:28:32,189
modifying data, and responding to modifications in data.

662
00:28:32,189 --> 00:28:34,849
It also means that the components support changes

663
00:28:34,849 --> 00:28:37,670
from anywhere, so they can be representing a change

664
00:28:37,670 --> 00:28:39,890
that's made by themselves or by other components,

665
00:28:39,890 --> 00:28:41,611
or even framework-level operations

666
00:28:41,611 --> 00:28:43,011
such as reloading of files and what have you.

667
00:28:43,011 --> 00:28:46,032
And it also means that because of this,

668
00:28:46,032 --> 00:28:47,232
there's no notion of directionality

669
00:28:47,232 --> 00:28:50,293
in any of the editor code, so views aren't concerned

670
00:28:50,293 --> 00:28:52,433
if this operation is a do or an undo or a redo.

671
00:28:52,433 --> 00:28:53,733
They just respond to the data changes.

672
00:28:56,287 --> 00:28:57,547
So one of the things we tried in the early days

673
00:28:57,547 --> 00:28:59,248
when we were playing around with the system

674
00:28:59,248 --> 00:29:01,168
is to actually build these transactions by hand

675
00:29:01,168 --> 00:29:03,129
and then apply them against the data

676
00:29:03,129 --> 00:29:04,069
in order to effect the change.

677
00:29:04,069 --> 00:29:08,031
And this is possible, but it actually proved very quickly

678
00:29:08,031 --> 00:29:09,511
to be way too cumbersome to be viable

679
00:29:09,511 --> 00:29:11,992
and it didn't fit with our ease of use goals

680
00:29:11,992 --> 00:29:12,572
in coding terms.

681
00:29:12,572 --> 00:29:14,833
So instead, we built a utility class

682
00:29:14,833 --> 00:29:15,893
which would just analyze changes

683
00:29:15,893 --> 00:29:17,234
after they'd already happened

684
00:29:17,234 --> 00:29:18,854
and generate a transaction that described

685
00:29:18,854 --> 00:29:20,335
all the changes that it had observed.

686
00:29:22,581 --> 00:29:28,866
So, before making a change, the programmer will use this diffutil to take a snapshot of the object state.

687
00:29:28,866 --> 00:29:32,129
And a snapshot is just a shallow, attribute-wise copy of the original object.

688
00:29:32,129 --> 00:29:35,652
And after that, the code is free to make any kind of modification to that object.

689
00:29:35,652 --> 00:29:39,815
And once those changes are complete, the programmer will tell the diffutil that he or she is finished with the changes,

690
00:29:39,815 --> 00:29:43,838
and the diffutil will compare the original snapshot against the current state.

691
00:29:43,838 --> 00:29:44,699
And...

692
00:29:45,063 --> 00:29:46,923
This works by using our RTTI system,

693
00:29:46,923 --> 00:29:48,764
so it reads the attribute values,

694
00:29:48,764 --> 00:29:50,904
and therefore we only see changes

695
00:29:50,904 --> 00:29:53,524
on data that is actually exposed to the RTTI system.

696
00:29:53,524 --> 00:29:54,885
So it's more fine-grained

697
00:29:54,885 --> 00:29:56,565
than just doing direct memory comparisons.

698
00:29:56,565 --> 00:29:57,705
Yeah, so how does this actually look in code?

699
00:29:57,705 --> 00:30:02,106
As you can see here, we have a super handy function

700
00:30:02,106 --> 00:30:05,507
that's gonna give us a pointer to a spotlight

701
00:30:05,507 --> 00:30:07,247
that we intend to modify.

702
00:30:07,247 --> 00:30:09,227
So we call that function,

703
00:30:09,227 --> 00:30:11,928
and then we create a diffutil on the stack,

704
00:30:11,928 --> 00:30:13,048
and we use it to take a snapshot

705
00:30:13,048 --> 00:30:14,288
of the spotlight's current state.

706
00:30:14,914 --> 00:30:16,755
So then we just perform some kind of modification.

707
00:30:16,755 --> 00:30:19,376
In this case, we use an accessor function

708
00:30:19,376 --> 00:30:20,697
to set the cone angle to 30 degrees.

709
00:30:20,697 --> 00:30:22,859
And then afterwards, we tell the diffutil that we're done

710
00:30:22,859 --> 00:30:24,220
by calling commitChanges.

711
00:30:24,220 --> 00:30:26,321
And we also supply a human-readable description

712
00:30:26,321 --> 00:30:28,102
of what we just did, which can be shown to the user

713
00:30:28,102 --> 00:30:30,944
in the user interface, for example.

714
00:30:30,944 --> 00:30:33,165
And then the diffutil will compare the snapshot

715
00:30:33,165 --> 00:30:34,847
against the current state, and it will produce a transaction

716
00:30:34,847 --> 00:30:35,747
that describes that change.

717
00:30:35,747 --> 00:30:37,808
And that's the only interaction that a programmer

718
00:30:37,808 --> 00:30:39,690
who's writing editor code actually has to do with the undo...

719
00:30:39,690 --> 00:30:41,571
has to perform to work with the undo system.

720
00:30:43,754 --> 00:30:46,937
So once we have a system that describes changes in this super granular fashion,

721
00:30:46,937 --> 00:30:49,879
it means that writing code to undo those changes is actually trivial.

722
00:30:49,879 --> 00:30:53,302
So to revert a change, we take our original transaction

723
00:30:53,302 --> 00:30:56,265
and we reverse the order of the commands

724
00:30:56,265 --> 00:30:59,647
and then we replace each command with its inverse.

725
00:30:59,647 --> 00:31:02,650
So, for example, an add object command becomes a remove object command,

726
00:31:02,650 --> 00:31:05,232
a set value command will use the old value instead of the new value,

727
00:31:05,232 --> 00:31:07,794
and once we have this transaction, we just apply it against the data

728
00:31:07,794 --> 00:31:09,656
and the data is now back in its original state.

729
00:31:09,656 --> 00:31:10,357
Easy.

730
00:31:12,933 --> 00:31:15,534
So in the same way as before, when we have an undo transaction,

731
00:31:15,534 --> 00:31:18,496
we just send a notification about that transaction

732
00:31:18,496 --> 00:31:19,996
to all the subscribed listeners,

733
00:31:19,996 --> 00:31:22,437
and the whole system just works without any kind of code changes.

734
00:31:22,437 --> 00:31:24,538
So what went well with the system?

735
00:31:24,538 --> 00:31:28,240
Well, it was very, very reliable,

736
00:31:28,240 --> 00:31:29,240
and it's a transparent system,

737
00:31:29,240 --> 00:31:31,061
at least to the programmers who are using it,

738
00:31:31,061 --> 00:31:35,683
and it can represent any kind of complicated changes.

739
00:31:35,683 --> 00:31:39,085
Because our in-editor views are only ever responding to transactions,

740
00:31:39,085 --> 00:31:40,745
there is no distinction between do and undo

741
00:31:40,745 --> 00:31:42,186
in any of our editor view code.

742
00:31:43,019 --> 00:31:47,184
And I guess what's most telling about this code is the fact that it hasn't really changed all that much in the last couple of years.

743
00:31:47,184 --> 00:31:50,329
I mean, we wrote it. Of course, there were some things that we didn't figure out in the beginning,

744
00:31:50,329 --> 00:31:51,831
so we had to tweak it a little bit.

745
00:31:51,831 --> 00:31:55,896
But at some point, it worked, and it just has continued working for, like, two and a half years or three years or something.

746
00:31:55,896 --> 00:32:00,382
That said, there are a couple of things that are not super great.

747
00:32:00,382 --> 00:32:00,442
So...

748
00:32:01,447 --> 00:32:05,388
The system relies very heavily on having transactions which describe all data changes that are occurring.

749
00:32:05,388 --> 00:32:09,689
However, as a programmer, it's pretty easy to forget to surround your changes in a diffutil

750
00:32:09,689 --> 00:32:12,009
before you actually start directly modifying the object.

751
00:32:12,009 --> 00:32:16,090
And this can lead to some very subtle irregularities in the timeline of the history stack.

752
00:32:16,090 --> 00:32:20,051
We perform some validation on transactions and debug bills to try and check the changes

753
00:32:20,051 --> 00:32:22,752
and make sure that everything makes sense, but of course we can't catch everything.

754
00:32:23,521 --> 00:32:26,802
And lastly the system doesn't support any file system changes

755
00:32:26,802 --> 00:32:29,704
which means that if a user moves files around using our refactoring tools

756
00:32:29,704 --> 00:32:32,045
the system doesn't support undoing those changes.

757
00:32:32,045 --> 00:32:35,767
But this is something that we're actually looking into fixing right now

758
00:32:35,767 --> 00:32:37,748
and we'll try and get it working for our next title.

759
00:32:37,748 --> 00:32:40,389
But actually now I'm going to hand back to Sander

760
00:32:40,389 --> 00:32:42,410
who will describe how this works with the 3D editor.

761
00:32:48,850 --> 00:32:52,152
So let's map this on to everything I explained about

762
00:32:52,152 --> 00:32:53,533
the 3D editor before.

763
00:32:53,533 --> 00:32:56,214
So when we make a data change in the editor, it results in

764
00:32:56,214 --> 00:32:57,775
the transaction being broadcast.

765
00:32:57,775 --> 00:33:01,396
So the editor node tree living in the editor listens for

766
00:33:01,396 --> 00:33:03,337
these changes and picks up this change.

767
00:33:03,337 --> 00:33:06,419
It determines which node in the tree is affected by the

768
00:33:06,419 --> 00:33:09,280
change and sends this information to the game along

769
00:33:09,280 --> 00:33:10,561
with the data change itself.

770
00:33:10,561 --> 00:33:14,062
So the corresponding editor node in the game then receives

771
00:33:14,062 --> 00:33:16,884
the change and modifies the game object, and thereby

772
00:33:16,884 --> 00:33:17,824
completing the edit.

773
00:33:19,557 --> 00:33:22,019
So with the information I've given before about having 2

774
00:33:22,019 --> 00:33:24,401
editor node trees in our process and the data

775
00:33:24,401 --> 00:33:27,543
differences between the editor and the game, the previous

776
00:33:27,543 --> 00:33:29,705
diagram is obviously a bit of a simplification.

777
00:33:29,705 --> 00:33:32,447
For starters, data in the editor is in local space, and

778
00:33:32,447 --> 00:33:34,509
objects in the game are in world space.

779
00:33:34,509 --> 00:33:37,291
Let's have a look at how the node trees allow us to deal

780
00:33:37,291 --> 00:33:39,112
with these changes.

781
00:33:39,112 --> 00:33:42,275
So let's say we modified the local space of the spotlight

782
00:33:42,275 --> 00:33:44,196
object, my spotlight, in this little hierarchy you see here.

783
00:33:45,481 --> 00:33:48,284
The spotlight has a parent object, myPrefab, which for

784
00:33:48,284 --> 00:33:51,346
this example will be the root of the tree.

785
00:33:51,346 --> 00:33:54,750
Each node in the tree can act as an adapter for transactions

786
00:33:54,750 --> 00:33:56,311
flowing through it.

787
00:33:56,311 --> 00:33:58,933
To facilitate this, all transactions are applied at

788
00:33:58,933 --> 00:33:59,694
the root of the tree.

789
00:33:59,694 --> 00:34:03,297
In this case, when the local space changes passes through

790
00:34:03,297 --> 00:34:05,820
the prefab, it appends its own local matrix to the transaction.

791
00:34:05,820 --> 00:34:09,383
So the transaction then being passed to the next object,

792
00:34:09,383 --> 00:34:11,085
which is the final object in the spotlight.

793
00:34:12,757 --> 00:34:14,257
It can do its modification.

794
00:34:14,257 --> 00:34:17,298
And because the data has flown through its parent, the

795
00:34:17,298 --> 00:34:19,158
data transaction will now be in real space.

796
00:34:19,158 --> 00:34:22,919
So because these steps are recursive, we return back to

797
00:34:22,919 --> 00:34:25,600
the prefab after successful application of the change in

798
00:34:25,600 --> 00:34:26,900
the spotlight.

799
00:34:26,900 --> 00:34:29,441
Should an ancestor node need to respond to changes of its

800
00:34:29,441 --> 00:34:32,361
children, this is the place where you could do it.

801
00:34:32,361 --> 00:34:34,822
More advanced objects might trigger updates to vegetation

802
00:34:34,822 --> 00:34:37,663
placement or terrain, as we'll see in the following video.

803
00:34:39,072 --> 00:34:43,234
So in this video that I borrowed from my colleague,

804
00:34:43,234 --> 00:34:45,396
we're actually moving a road node.

805
00:34:45,396 --> 00:34:48,037
And road nodes are part of the content hierarchy.

806
00:34:48,037 --> 00:34:51,279
And its parent node is a road system.

807
00:34:51,279 --> 00:34:53,641
And that actually knows how to modify the terrain.

808
00:34:53,641 --> 00:34:56,563
So moving these roads, as you see, actually updates the

809
00:34:56,563 --> 00:34:59,364
vegetation and the terrain systems in the game.

810
00:34:59,364 --> 00:35:03,727
This is a good example of how the EditorNodeTree actually

811
00:35:03,727 --> 00:35:04,508
facilitates this.

812
00:35:06,300 --> 00:35:08,561
So to the observer viewer, there is a piece of

813
00:35:08,561 --> 00:35:09,522
information missing here.

814
00:35:09,522 --> 00:35:13,464
Tools like the ones we've just shown actually draw a gizmo in

815
00:35:13,464 --> 00:35:17,345
the game and allow the user to interactively operate on it.

816
00:35:17,345 --> 00:35:20,407
Plenty of tools work this way, such as, for example, moving,

817
00:35:20,407 --> 00:35:21,827
but also painting, et cetera.

818
00:35:21,827 --> 00:35:24,929
So how did we implement this in the framework?

819
00:35:24,929 --> 00:35:28,110
Because we already know how to describe a data change using

820
00:35:28,110 --> 00:35:31,591
transactions and a diffutil, in an Eve implementation, we

821
00:35:31,591 --> 00:35:34,753
would simply reverse the order of the transaction and support

822
00:35:34,753 --> 00:35:36,053
the following data flow as well.

823
00:35:36,675 --> 00:35:40,518
So reading the diagram from right to left, the tool sends

824
00:35:40,518 --> 00:35:43,659
a transaction to the node tree in the game, which then

825
00:35:43,659 --> 00:35:46,421
transmits its change back to the editor, where we do the

826
00:35:46,421 --> 00:35:50,123
same modification on the cortex data that we have just

827
00:35:50,123 --> 00:35:52,064
done in game.

828
00:35:52,064 --> 00:35:54,666
So we did not do this, because this is problematic for

829
00:35:54,666 --> 00:35:56,647
various reasons.

830
00:35:56,647 --> 00:35:59,949
First of all, it becomes unclear which process has

831
00:35:59,949 --> 00:36:01,090
authority over the data.

832
00:36:02,464 --> 00:36:05,165
Secondly, because of data loss in conversion, it might be

833
00:36:05,165 --> 00:36:07,566
impossible to have this code path in the first place.

834
00:36:07,566 --> 00:36:12,068
And thirdly, and lastly, you would need some system to

835
00:36:12,068 --> 00:36:14,830
prevent a transaction being generated in the editor to

836
00:36:14,830 --> 00:36:16,851
flow back to the game again and then create a cycle.

837
00:36:16,851 --> 00:36:21,933
So because of these problems, we implemented tool support or

838
00:36:21,933 --> 00:36:23,374
gizmo support somewhat differently.

839
00:36:23,374 --> 00:36:26,676
The key here is that the tools do not actually modify the

840
00:36:26,676 --> 00:36:26,896
data.

841
00:36:27,972 --> 00:36:30,474
They simply broadcast an intention to the editor,

842
00:36:30,474 --> 00:36:32,476
telling the editor what they'd like to change.

843
00:36:32,476 --> 00:36:35,178
It's up to the editor to actually make the data

844
00:36:35,178 --> 00:36:36,479
modification itself.

845
00:36:36,479 --> 00:36:40,442
This data modification is then processed in exactly the same

846
00:36:40,442 --> 00:36:43,003
way as any other transaction.

847
00:36:43,003 --> 00:36:45,385
And that way, the editor keeps authority over

848
00:36:45,385 --> 00:36:46,446
the data at all times.

849
00:36:46,446 --> 00:36:50,069
So it also automatically works with undo, as the input for

850
00:36:50,069 --> 00:36:54,372
the editor data modification on the left is then the undo

851
00:36:54,372 --> 00:36:55,593
system instead of the tool.

852
00:36:56,152 --> 00:36:58,974
It is still the editor node in the game that modifies the

853
00:36:58,974 --> 00:37:02,376
game object as a result of a transaction in the editor.

854
00:37:02,376 --> 00:37:06,879
The game itself has no notion of the undo system at all.

855
00:37:06,879 --> 00:37:09,301
So there's one part in updating a running game that

856
00:37:09,301 --> 00:37:10,121
we have not looked at at all.

857
00:37:10,121 --> 00:37:13,844
And that is structural changes to the node tree itself,

858
00:37:13,844 --> 00:37:15,105
adding and removing objects.

859
00:37:15,105 --> 00:37:19,028
So this is done by a separate system that we call GameSync.

860
00:37:20,335 --> 00:37:23,596
So GameSync is a continuation of a system that we had in place

861
00:37:23,596 --> 00:37:25,457
before we started working on the 3D editor

862
00:37:25,457 --> 00:37:28,397
and was written for hot-loading particles into a running game.

863
00:37:28,397 --> 00:37:30,558
The system has been heavily expanded

864
00:37:30,558 --> 00:37:32,278
during the development of Horizon,

865
00:37:32,278 --> 00:37:35,039
and it works by tracking all changes in the editor,

866
00:37:35,039 --> 00:37:37,520
creating a patch file, and then inserting that into the game.

867
00:37:37,520 --> 00:37:40,461
Since we like working with spotlights,

868
00:37:40,461 --> 00:37:43,201
let's copy the spotlight in this hierarchy

869
00:37:43,201 --> 00:37:44,442
and see how GameSync works.

870
00:37:46,293 --> 00:37:48,636
So first, the incoming change is analyzed.

871
00:37:48,636 --> 00:37:52,120
The analysis phase determines which objects are modified and

872
00:37:52,120 --> 00:37:54,543
what other dependencies are required for successful

873
00:37:54,543 --> 00:37:55,884
application of the patch.

874
00:37:55,884 --> 00:37:58,767
So these dependencies are extra objects that are

875
00:37:58,767 --> 00:38:01,831
required for the conversion process or extra objects that

876
00:38:01,831 --> 00:38:04,013
might be required for the targeted game subsystem.

877
00:38:05,322 --> 00:38:08,625
The analysis phase writes out a single cortex file containing

878
00:38:08,625 --> 00:38:10,247
all required objects.

879
00:38:10,247 --> 00:38:13,309
So in this example, it contains the prefab as it will

880
00:38:13,309 --> 00:38:15,471
contain a reference to this new spotlight.

881
00:38:15,471 --> 00:38:17,473
And obviously, the file will contain

882
00:38:17,473 --> 00:38:18,354
a new spotlight itself.

883
00:38:18,354 --> 00:38:22,017
So this cortex file is then converted into a binary file

884
00:38:22,017 --> 00:38:24,239
and saved to disk, ready to be loaded and

885
00:38:24,239 --> 00:38:25,440
inserted into the game.

886
00:38:25,440 --> 00:38:29,403
The game is then paused at a sync point, meaning no

887
00:38:29,403 --> 00:38:32,786
streaming is happening and all threads are

888
00:38:32,786 --> 00:38:33,767
paused effectively.

889
00:38:35,656 --> 00:38:39,079
So applying the patch means copying the objects in the

890
00:38:39,079 --> 00:38:41,981
patch file to the affected game systems.

891
00:38:41,981 --> 00:38:45,103
The target objects in the game are overwritten, meaning that

892
00:38:45,103 --> 00:38:46,985
any cached pointers in the game actually

893
00:38:46,985 --> 00:38:49,707
will remain valid.

894
00:38:49,707 --> 00:38:53,470
Finally, after applying the patch, the game and all of its

895
00:38:53,470 --> 00:38:54,351
subsystems are resumed.

896
00:38:54,351 --> 00:38:59,715
Recapping on how GameSync worked, from a tools team we

897
00:38:59,715 --> 00:39:01,736
have mixed feelings.

898
00:39:02,696 --> 00:39:04,337
On the one hand, we have a solution

899
00:39:04,337 --> 00:39:06,178
that accepts all changes throughout the editor,

900
00:39:06,178 --> 00:39:08,600
and even changes on disk can be tracked

901
00:39:08,600 --> 00:39:09,700
by monitoring the file system.

902
00:39:09,700 --> 00:39:11,601
It can also sync patch files to a dev kit,

903
00:39:11,601 --> 00:39:15,104
allowing a user to see edits on the target

904
00:39:15,104 --> 00:39:16,624
without having to restart the game.

905
00:39:16,624 --> 00:39:19,786
On the other hand, getting GameSync fully reliable

906
00:39:19,786 --> 00:39:22,088
proved impossible throughout the project.

907
00:39:22,926 --> 00:39:25,508
Because game systems predate game sync,

908
00:39:25,508 --> 00:39:30,352
game sync tried to respect these systems as much as possible

909
00:39:30,352 --> 00:39:32,514
and thereby avoiding work for other code teams.

910
00:39:32,514 --> 00:39:36,457
This led to special case code creeping into these systems

911
00:39:36,457 --> 00:39:38,159
and very complex analysis code.

912
00:39:38,159 --> 00:39:42,602
These complexities further then complicated

913
00:39:42,602 --> 00:39:44,484
or generated performance problems

914
00:39:44,484 --> 00:39:47,046
where worst case applying a relatively simple change

915
00:39:47,046 --> 00:39:49,548
could take as much as five to 10 seconds,

916
00:39:49,548 --> 00:39:50,869
breaking a user's workflow.

917
00:39:52,893 --> 00:39:55,574
All of these complexities also led to inconsistencies

918
00:39:55,574 --> 00:39:56,554
in the results as well.

919
00:39:56,554 --> 00:40:01,016
Game sync could crash or produce incorrect results,

920
00:40:01,016 --> 00:40:05,078
such as objects being not placed incorrectly placed

921
00:40:05,078 --> 00:40:06,218
in the world.

922
00:40:06,218 --> 00:40:09,619
And this then led to a very low level of confidence

923
00:40:09,619 --> 00:40:11,420
from the users, making it high on our wish list

924
00:40:11,420 --> 00:40:13,101
to rewrite for a next project.

925
00:40:13,101 --> 00:40:13,881
But let's not end here.

926
00:40:13,881 --> 00:40:16,142
For the final part of this presentation,

927
00:40:16,142 --> 00:40:18,103
I would like to give the word back to Dan

928
00:40:18,103 --> 00:40:20,984
so he can give an overview of other tools

929
00:40:20,984 --> 00:40:21,784
that we have developed.

930
00:40:33,618 --> 00:40:33,979
Those out.

931
00:40:33,979 --> 00:40:37,981
Okay as I mentioned earlier we managed to get some help from

932
00:40:37,981 --> 00:40:40,182
another team while working working on the note graph editor

933
00:40:40,182 --> 00:40:43,885
and the most significant contribution came in the form

934
00:40:43,885 --> 00:40:46,266
of a fully featured debugger which was able to show debug

935
00:40:46,266 --> 00:40:49,928
information in real time from active instances of a graph

936
00:40:49,928 --> 00:40:51,849
which was running within the editor or just within a

937
00:40:51,849 --> 00:40:53,930
connected instance of the game running on target.

938
00:40:53,930 --> 00:40:57,593
And so the debugger had all the kind of usual features you'd

939
00:40:57,593 --> 00:41:00,534
expect to see such as variable inspection execution

940
00:41:00,534 --> 00:41:02,115
visualization and.

941
00:41:02,844 --> 00:41:04,766
It was also gathering this information over time,

942
00:41:04,766 --> 00:41:09,732
so this meant that the editor could then facilitate historical debugging

943
00:41:09,732 --> 00:41:13,577
and it would highlight previous executions on a timeline

944
00:41:13,577 --> 00:41:15,019
where the execution flow had changed.

945
00:41:15,019 --> 00:41:17,722
So it meant that it was very easy for users to kind of scrub back in time

946
00:41:17,722 --> 00:41:20,285
and figure out when some particular condition was met

947
00:41:20,285 --> 00:41:21,326
or some condition had changed.

948
00:41:22,432 --> 00:41:24,334
So this debug functionality turned out to be super useful

949
00:41:24,334 --> 00:41:25,756
during the development of Horizon Zero Dawn,

950
00:41:25,756 --> 00:41:28,680
and it spawned some similar debuggers for other systems,

951
00:41:28,680 --> 00:41:31,444
and all of those debuggers and visualizations

952
00:41:31,444 --> 00:41:32,946
were made with very minimal involvement

953
00:41:32,946 --> 00:41:35,269
from the tools team, which for us was a pretty good indicator

954
00:41:35,269 --> 00:41:38,092
that we were successful in making the tools framework

955
00:41:38,092 --> 00:41:39,594
something that could be used by the rest

956
00:41:39,594 --> 00:41:40,776
of the programmers in the company.

957
00:41:42,723 --> 00:41:45,506
So here's a video of the note graph debugger I was talking about.

958
00:41:45,506 --> 00:41:48,989
You can see how the graph is currently executing.

959
00:41:48,989 --> 00:41:53,173
This is actually the graph sound for the main character's breathing.

960
00:41:53,173 --> 00:41:56,897
You can hover over inputs on the graph and see what is actually going on, how the value

961
00:41:56,897 --> 00:41:57,798
is changing over time.

962
00:41:58,358 --> 00:42:00,598
and you can see the execution path being visualized,

963
00:42:00,598 --> 00:42:03,799
but you can also pause the execution of the graph in game,

964
00:42:03,799 --> 00:42:06,620
and then start to look at previous executions,

965
00:42:06,620 --> 00:42:07,680
and you can see how long they were taking

966
00:42:07,680 --> 00:42:08,580
in microseconds and so on,

967
00:42:08,580 --> 00:42:11,161
and you can actually then step through those executions

968
00:42:11,161 --> 00:42:12,521
and see when the control flow changed

969
00:42:12,521 --> 00:42:13,602
and flip back and forth and see how the values

970
00:42:13,602 --> 00:42:14,922
are actually working in this graph.

971
00:42:14,922 --> 00:42:16,002
Something else that was completely new for Horizon

972
00:42:16,002 --> 00:42:16,642
was interactive conversations,

973
00:42:16,642 --> 00:42:16,762
and

974
00:42:23,985 --> 00:42:27,969
With this feature, we were not beholden to any kind of existing workflow.

975
00:42:27,969 --> 00:42:31,593
So it meant that we were free to just build a new editing context from scratch

976
00:42:31,593 --> 00:42:35,736
to meet the specialized needs of the teams that were going to be using this tool.

977
00:42:35,736 --> 00:42:39,480
So that would be the writers and the quest designers and cinematic artists

978
00:42:39,480 --> 00:42:41,762
who would actually make the conversations within Horizon.

979
00:42:43,877 --> 00:42:45,337
So here's an overview of the editor itself.

980
00:42:45,337 --> 00:42:46,997
It's kind of hard to read, to be honest,

981
00:42:46,997 --> 00:42:48,918
but we have a graph that just controls

982
00:42:48,918 --> 00:42:50,218
the flow of the conversation.

983
00:42:50,218 --> 00:42:52,179
So the main character is speaking to somebody

984
00:42:52,179 --> 00:42:53,979
and they are presented with dialogue choices

985
00:42:53,979 --> 00:42:55,820
and the graph can also check for conditions

986
00:42:55,820 --> 00:42:58,740
like have you accomplished a particular quest objective

987
00:42:58,740 --> 00:42:58,920
and so on.

988
00:42:58,920 --> 00:43:01,401
Let's take a quick look at a conversation in Horizon.

989
00:43:01,401 --> 00:43:02,241
You gave them the best work you'd ever do.

990
00:43:02,241 --> 00:43:02,621
And look at it now.

991
00:43:11,654 --> 00:43:15,096
They defaced it because they hated what it stood for.

992
00:43:15,096 --> 00:43:20,539
They defaced a thing slaves like him lived and died for.

993
00:43:20,539 --> 00:43:23,321
Slaves they've already forgotten.

994
00:43:23,321 --> 00:43:25,502
Short-sighted bastards, the lot.

995
00:43:25,502 --> 00:43:31,585
If they thought their son set off this bridge, they'd jump after it.

996
00:43:31,585 --> 00:43:34,007
Ah...

997
00:43:34,007 --> 00:43:36,188
I thank you for honoring my wish.

998
00:43:36,188 --> 00:43:38,169
I hope you can find peace.

999
00:43:40,173 --> 00:43:43,155
Okay, so that was actually from quite a while ago in production.

1000
00:43:43,155 --> 00:43:47,980
But what's interesting about this conversation is that it's completely auto-generated.

1001
00:43:47,980 --> 00:43:54,045
So, I mean aside from the audio, all of the animations and camera cuts and gesture beats

1002
00:43:54,045 --> 00:43:57,809
and so on were selected by a data-driven rule-based system.

1003
00:43:57,809 --> 00:43:58,529
And the...

1004
00:44:00,010 --> 00:44:03,051
Auto generation system will also generate a robo voice

1005
00:44:03,051 --> 00:44:04,611
and facial animations where required.

1006
00:44:04,611 --> 00:44:07,292
So basically it means that a designer

1007
00:44:07,292 --> 00:44:08,912
could just produce game ready content by typing

1008
00:44:08,912 --> 00:44:10,493
in a few sentences for a conversation

1009
00:44:10,493 --> 00:44:12,653
and then immediately see it in the game

1010
00:44:12,653 --> 00:44:15,074
or even just game sync it into an active instance of the game

1011
00:44:15,074 --> 00:44:17,014
and get quick feedback on how their actual flow

1012
00:44:17,014 --> 00:44:18,755
of the conversation is actually going to be.

1013
00:44:18,755 --> 00:44:21,755
The system was pretty heavily inspired by the work of CD

1014
00:44:21,755 --> 00:44:24,516
Project Red and BioWare who've both delivered talks

1015
00:44:24,516 --> 00:44:26,717
in the last several years about how their conversation systems

1016
00:44:26,717 --> 00:44:26,897
work.

1017
00:44:27,389 --> 00:44:28,529
If you have any interest in the subject,

1018
00:44:28,529 --> 00:44:30,910
I highly recommend you check out the talk from last year's GDC,

1019
00:44:30,910 --> 00:44:33,351
which is shown here about the Witcher 3's dialogue systems.

1020
00:44:33,351 --> 00:44:37,413
But this is something that we were only able to do

1021
00:44:37,413 --> 00:44:40,174
because we'd built this new framework

1022
00:44:40,174 --> 00:44:41,614
that meant it was easy for us to experiment

1023
00:44:41,614 --> 00:44:42,295
and just try out new ideas.

1024
00:44:42,295 --> 00:44:46,116
So something else is the profiler framework.

1025
00:44:46,116 --> 00:44:47,537
So at the beginning of the talk,

1026
00:44:47,537 --> 00:44:49,117
I showed a video of our GPU profiler,

1027
00:44:49,117 --> 00:44:52,579
and this is a video of our global profiler,

1028
00:44:52,579 --> 00:44:55,660
which is for profiling on larger segments of time,

1029
00:44:55,660 --> 00:44:56,900
more along the lines of milliseconds.

1030
00:44:57,507 --> 00:45:00,328
But we had this profile framework already running in-game

1031
00:45:00,328 --> 00:45:03,750
and we were able to expose it to the editors

1032
00:45:03,750 --> 00:45:07,851
that we were able to start getting profile data back from any tools basically.

1033
00:45:07,851 --> 00:45:10,253
So we can see like how much time is being spent in certain areas,

1034
00:45:10,253 --> 00:45:13,774
we can drill in really quite to quite small time scales

1035
00:45:13,774 --> 00:45:18,697
and get an overview on what's actually being done in the editor or the game.

1036
00:45:20,723 --> 00:45:24,606
So we expose this profiler framework to the editor

1037
00:45:24,606 --> 00:45:27,668
and this allowed us to build a front end for the profiler,

1038
00:45:27,668 --> 00:45:30,429
which can show profile data in real time from any tool.

1039
00:45:30,429 --> 00:45:31,950
And this of course includes the game,

1040
00:45:31,950 --> 00:45:33,851
but it also applies to the executables

1041
00:45:33,851 --> 00:45:35,372
that we use to run our conversion process

1042
00:45:35,372 --> 00:45:37,533
and any of our kind of demons that are running

1043
00:45:37,533 --> 00:45:39,875
to facilitate our other tools, framework stuff.

1044
00:45:39,875 --> 00:45:43,597
And it's interesting to note that the editor

1045
00:45:43,597 --> 00:45:44,958
also runs the profiler framework,

1046
00:45:44,958 --> 00:45:46,138
which means that it can profile itself.

1047
00:45:46,819 --> 00:45:51,002
in real time which is super handy for being able to investigate performance

1048
00:45:51,002 --> 00:45:55,126
issues quickly or just figure out why the editors running slowly on like one

1049
00:45:55,126 --> 00:45:55,546
guys machine.

1050
00:45:55,546 --> 00:46:00,151
Something else we worked on you is a world map and one of things about

1051
00:46:00,151 --> 00:46:03,734
working on an open world game is it can be pretty hard to get an overview over

1052
00:46:03,734 --> 00:46:07,077
where things are happening so to that and we started working on a 2 dimensional

1053
00:46:07,077 --> 00:46:09,579
map representation of our game data.

1054
00:46:10,520 --> 00:46:13,822
displaying game data on the world map it's used in game is a pretty logical progression

1055
00:46:13,822 --> 00:46:18,563
and thanks to a plugable overlay system. It's possible to create visualizations for whatever we want basically so

1056
00:46:18,563 --> 00:46:25,146
right now we use it for showing stuff like the locations of quests or the location of Jira bugs

1057
00:46:25,146 --> 00:46:29,047
and it's pretty handy to get a quick quick eye on what's actually happening in the game.

1058
00:46:29,047 --> 00:46:32,128
But unfortunately it came on pretty online very late in the project

1059
00:46:32,128 --> 00:46:36,670
and it wasn't really widely used but it's something we'll probably continue to work on pretty heavily for the next project.

1060
00:46:38,592 --> 00:46:40,093
There's a quick video of that.

1061
00:46:40,093 --> 00:46:42,375
This is just a view that shows some world encounters.

1062
00:46:42,375 --> 00:46:44,076
So you're able to kind of filter and see

1063
00:46:44,076 --> 00:46:46,498
where you might run into particular types of robots

1064
00:46:46,498 --> 00:46:49,320
within the world.

1065
00:46:49,320 --> 00:46:50,742
And again, there's filtering, so you

1066
00:46:50,742 --> 00:46:53,063
can get a quick overview of what you actually want to see.

1067
00:46:53,063 --> 00:46:55,565
There's another overlay that we have

1068
00:46:55,565 --> 00:46:59,248
which shows our performance stats for each tile, which

1069
00:46:59,248 --> 00:47:00,949
is gathered on a daily basis.

1070
00:47:00,949 --> 00:47:02,431
And this shows whether our tiles are in memory

1071
00:47:02,431 --> 00:47:05,313
and within CPU budgets and GPU budgets and so on.

1072
00:47:06,128 --> 00:47:09,269
It shows tiles that are in budget as green and tiles that are out of budget as red.

1073
00:47:09,269 --> 00:47:11,811
And unfortunately, this screenshot is from very late in production,

1074
00:47:11,811 --> 00:47:16,833
I think right before Gold Master, so everything is green because we were in budget.

1075
00:47:16,833 --> 00:47:22,556
But we can drill into that tile and then get an overview on the different parts of performance stats

1076
00:47:22,556 --> 00:47:25,437
that have been happening over time, over very long periods of time,

1077
00:47:25,437 --> 00:47:28,519
because we gather these stats always.

1078
00:47:28,519 --> 00:47:31,660
So the last thing that actually came up was...

1079
00:47:33,283 --> 00:47:37,928
Now that all of our tools are written in C++, it meant that a few of the programs at Guerrilla

1080
00:47:37,928 --> 00:47:42,073
had the idea of creating a C API for the tools framework, so we could use this to expose

1081
00:47:42,073 --> 00:47:44,716
certain areas of the tools framework's functionality to other languages.

1082
00:47:44,716 --> 00:47:51,523
And so, with that in mind, we exposed stuff like file loading and saving and object manipulations,

1083
00:47:51,523 --> 00:47:53,606
and then we wrote a wrapper in Python.

1084
00:47:54,489 --> 00:47:58,814
for the decimal API which allows tech artists and designers and anybody who

1085
00:47:58,814 --> 00:48:02,918
knows most Python basically to create scripts that will like create game

1086
00:48:02,918 --> 00:48:06,601
content or modify existing game content and they use these the same tools

1087
00:48:06,601 --> 00:48:09,905
framework functionality that we actually used to build the editor.

1088
00:48:09,905 --> 00:48:12,847
So revisiting the C++ code example from earlier we can look at the same code

1089
00:48:12,847 --> 00:48:13,608
which is written in Python.

1090
00:48:14,184 --> 00:48:16,304
And yeah, we retrieve the spotlight to edit.

1091
00:48:16,304 --> 00:48:19,326
And in Python, we create a transaction

1092
00:48:19,326 --> 00:48:21,006
so that we can actually start modifying data.

1093
00:48:21,006 --> 00:48:22,367
And then we just use some accessors

1094
00:48:22,367 --> 00:48:24,128
to modify the cone angle once again.

1095
00:48:24,128 --> 00:48:25,828
And then we just commit the transaction.

1096
00:48:25,828 --> 00:48:29,010
And this is how somebody would do the same things

1097
00:48:29,010 --> 00:48:30,370
that we do in the editor with Python.

1098
00:48:30,370 --> 00:48:33,472
There's also a lot of other really cool stuff

1099
00:48:33,472 --> 00:48:36,533
that I would like to show today, but there just isn't enough time.

1100
00:48:38,087 --> 00:48:40,509
So I'll move on to conclusions.

1101
00:48:40,509 --> 00:48:41,950
So now that the game is finished,

1102
00:48:41,950 --> 00:48:43,491
we have some time to kind of tick stock.

1103
00:48:43,491 --> 00:48:45,493
And we realized that we were much more successful

1104
00:48:45,493 --> 00:48:46,794
in this whole endeavor than we anticipated,

1105
00:48:46,794 --> 00:48:49,036
but there's still a lot of work left to do.

1106
00:48:49,036 --> 00:48:50,397
We'd like to bring more of our team's workflows

1107
00:48:50,397 --> 00:48:51,237
into the new editor.

1108
00:48:51,237 --> 00:48:53,439
A lot of our environment, our set dressing

1109
00:48:53,439 --> 00:48:54,820
is still being done in Maya.

1110
00:48:54,820 --> 00:48:56,822
Some of our VFX work involving particles

1111
00:48:56,822 --> 00:49:00,865
is still performed in a standalone particle editor tool.

1112
00:49:00,865 --> 00:49:01,866
And so...

1113
00:49:03,052 --> 00:49:08,556
We'll start building you at a contest for these different workflows and continue to move

1114
00:49:08,556 --> 00:49:10,678
everybody in the company into our editor.

1115
00:49:10,678 --> 00:49:14,161
And it's under mentioned we'd like to rewrite the game sync system.

1116
00:49:14,161 --> 00:49:20,306
So it's a source of a lot of mind boggling debugging problems throughout the project

1117
00:49:20,306 --> 00:49:20,367
and.

1118
00:49:21,185 --> 00:49:25,008
we want to 3 is out of process that we can stabilize the editor because even

1119
00:49:25,008 --> 00:49:28,971
though we we had a really quick start with the 3 editor and a lot of progress

1120
00:49:28,971 --> 00:49:32,253
it meant that when we came towards the end of the game and and the project

1121
00:49:32,253 --> 00:49:34,795
story in the game was being optimized very heavily that had a really big

1122
00:49:34,795 --> 00:49:39,158
impact on the stability of the editor. So we'd like to separate this process so

1123
00:49:39,158 --> 00:49:42,741
that we don't lose start this use his work from crashes in the in the game.

1124
00:49:43,754 --> 00:49:47,295
And although we made a lot of progress on this project for the tools user

1125
00:49:47,295 --> 00:49:50,916
and space building was done in like let's say an organic fashion which means

1126
00:49:50,916 --> 00:49:54,718
that a lot of tools and concepts of the editor as user interface are kind of

1127
00:49:54,718 --> 00:49:57,979
confusing or irritating and users find it pretty hard to discover new features

1128
00:49:57,979 --> 00:50:00,900
and so we want to work on the stuff quite a lot in the future.

1129
00:50:00,900 --> 00:50:05,381
Let's say thanks to everyone at the gorilla who helped out with the stuff

1130
00:50:05,381 --> 00:50:08,582
and some special thanks to the people whose work you've you've seen here

1131
00:50:08,582 --> 00:50:09,442
today.

1132
00:50:09,442 --> 00:50:10,203
And.

1133
00:50:11,453 --> 00:50:16,336
Also, we are we're hiring so if you're interested in working with

1134
00:50:16,336 --> 00:50:19,658
What is frankly just a bunch of really awesome people with a lot of talent?

1135
00:50:19,658 --> 00:50:24,041
Then please click that link and send us your resume and we'll take a look

1136
00:50:24,041 --> 00:50:26,142
But yeah, that's it. So does anybody have any questions?

1137
00:50:52,152 --> 00:50:52,872
Thank you.

1138
00:51:06,095 --> 00:51:09,638
So after seeing some video content,

1139
00:51:09,638 --> 00:51:12,160
like just mass market content,

1140
00:51:12,160 --> 00:51:14,701
on how they were changing the workflow

1141
00:51:14,701 --> 00:51:17,503
of Decima Engine in previous titles

1142
00:51:17,503 --> 00:51:19,405
to fit the new Death Stranding title,

1143
00:51:19,405 --> 00:51:21,666
I was wondering, is there anything in particular

1144
00:51:21,666 --> 00:51:23,668
that you learned from that experience

1145
00:51:23,668 --> 00:51:26,650
or that was integrated as a result of that experience

1146
00:51:26,650 --> 00:51:29,912
with the Kojima Productions team once they came on?

1147
00:51:29,912 --> 00:51:32,174
Yeah, I mean, those guys were working for many years

1148
00:51:32,174 --> 00:51:34,896
on their engine, and Fox Engine had a lot of

1149
00:51:36,091 --> 00:51:36,812
cool capabilities.

1150
00:51:36,812 --> 00:51:39,193
So we learned a lot of technical stuff from those guys,

1151
00:51:39,193 --> 00:51:40,695
but in terms of workflow changes,

1152
00:51:40,695 --> 00:51:43,977
they're much more focused on cinematics than we were.

1153
00:51:43,977 --> 00:51:45,659
So our cinematics pipeline was something

1154
00:51:45,659 --> 00:51:47,220
that we analyzed quite heavily to understand

1155
00:51:47,220 --> 00:51:49,162
how we could improve it to fit their workflows

1156
00:51:49,162 --> 00:51:53,505
where they wanted to have very long sequences

1157
00:51:53,505 --> 00:51:54,766
of a lot of complicated interaction

1158
00:51:54,766 --> 00:51:55,547
between many characters.

1159
00:51:55,547 --> 00:51:57,969
So that was a pretty big part of it.

1160
00:51:57,969 --> 00:51:59,130
But yeah, that's about it.

1161
00:51:59,130 --> 00:51:59,730
So a couple of questions.

1162
00:51:59,730 --> 00:52:00,070
One would be.

1163
00:52:06,389 --> 00:52:09,192
How did you get buy-in from production and management,

1164
00:52:09,192 --> 00:52:10,493
or were there any problems with it?

1165
00:52:10,493 --> 00:52:15,478
And also, in the early days when you were working on stuff

1166
00:52:15,478 --> 00:52:16,939
that wasn't yet usable,

1167
00:52:16,939 --> 00:52:19,041
were you having to support two systems

1168
00:52:19,041 --> 00:52:20,482
for people editing the game?

1169
00:52:20,482 --> 00:52:20,562
Yes.

1170
00:52:20,562 --> 00:52:26,028
So, the question is, like, how do we get buy-in

1171
00:52:26,028 --> 00:52:28,690
from other teams, and how do we actually, like,

1172
00:52:28,690 --> 00:52:31,172
approach the process of dealing with two separate parts

1173
00:52:31,172 --> 00:52:31,513
of editing?

1174
00:52:32,136 --> 00:52:34,938
So getting buy-in from management wasn't that difficult

1175
00:52:34,938 --> 00:52:36,499
because we had the backing of our technical director

1176
00:52:36,499 --> 00:52:39,221
to just push forward with this that we thought,

1177
00:52:39,221 --> 00:52:41,463
in a way that we thought made sense.

1178
00:52:41,463 --> 00:52:43,585
Getting buy-in from our users was much harder

1179
00:52:43,585 --> 00:52:47,608
because the tools were really kind of crappy

1180
00:52:47,608 --> 00:52:48,428
for like a very long time.

1181
00:52:48,428 --> 00:52:50,890
And that meant that nobody wanted to use them.

1182
00:52:50,890 --> 00:52:52,651
So we had to invest a lot of energy

1183
00:52:52,651 --> 00:52:54,913
in just making sure that we met all the demands

1184
00:52:54,913 --> 00:52:57,555
of like reaching feature parity for that stuff.

1185
00:52:57,555 --> 00:52:59,256
In terms of editing,

1186
00:52:59,256 --> 00:53:00,577
having two different systems of editing,

1187
00:53:00,577 --> 00:53:01,878
that was kind of a pretty.

1188
00:53:02,520 --> 00:53:06,382
tricky tricky thing is very hard to summarize shortly because

1189
00:53:06,382 --> 00:53:10,524
there's like many different angles that was always different systems and we have in the game and

1190
00:53:10,524 --> 00:53:14,366
moving on to new data formats in the new editor would make anything

1191
00:53:14,366 --> 00:53:18,488
much easier. But I can give you some specific examples in more detail

1192
00:53:18,488 --> 00:53:21,370
but it's it's very very hard thing to to summarize.

1193
00:53:22,815 --> 00:53:26,035
mainly like all the old tools pretty much had a feature stop

1194
00:53:26,035 --> 00:53:27,796
once this got rolling.

1195
00:53:27,796 --> 00:53:29,216
So we did support them.

1196
00:53:29,216 --> 00:53:32,157
I mean, as Dan ended his presentation,

1197
00:53:32,157 --> 00:53:36,758
not all teams have moved over to the new editor.

1198
00:53:36,758 --> 00:53:39,999
But yeah, the new features for the old tools

1199
00:53:39,999 --> 00:53:43,039
is zero or very little since we've started this.

1200
00:53:43,039 --> 00:53:43,139
Hey.

1201
00:53:43,139 --> 00:53:43,800
Thanks for the talk.

1202
00:53:50,999 --> 00:53:57,720
do you have any um like uh data messaging uh steps like you know like a pipeline step or

1203
00:53:57,720 --> 00:54:02,741
something like that and how does that work with the like you know the diff patch file that you

1204
00:54:02,741 --> 00:54:10,123
do or is that actually what you mean in the uh the game sync stuff where it's actually done on

1205
00:54:10,123 --> 00:54:16,904
the game side where you know the the the the editor data has to be kind of messaged like you

1206
00:54:16,904 --> 00:54:18,545
know strings need to be hashed and.

1207
00:54:19,444 --> 00:54:22,327
all the things need to be generated for the run time to work.

1208
00:54:22,327 --> 00:54:26,730
Okay, so you're talking specifically about how the

1209
00:54:26,730 --> 00:54:28,372
editor data is actually transferred into the game

1210
00:54:28,372 --> 00:54:29,793
and how that transformation process works?

1211
00:54:29,793 --> 00:54:30,313
Yes.

1212
00:54:30,313 --> 00:54:30,493
Yeah.

1213
00:54:30,493 --> 00:54:31,174
Okay.

1214
00:54:31,174 --> 00:54:33,996
So we have a conversion pipeline that is basically just

1215
00:54:33,996 --> 00:54:37,879
lazily converting the graph of content

1216
00:54:37,879 --> 00:54:39,000
that is going to be loaded into the game.

1217
00:54:39,000 --> 00:54:42,063
And that conversion process can involve basically anything.

1218
00:54:42,063 --> 00:54:44,665
I mean, in the simplest form, it's just that we take

1219
00:54:44,665 --> 00:54:44,985
some

1220
00:54:46,238 --> 00:54:50,888
pre-converted data and write it to a binary stream in accordance with the RTTI schema.

1221
00:54:51,871 --> 00:54:57,234
But in complicated cases, it can be things like where we do a lot of baking operations and then write out

1222
00:54:57,234 --> 00:55:00,616
Stream in a certain way or whatever, but this is something which

1223
00:55:00,616 --> 00:55:07,680
Game systems and game objects are free to implement. However, they want so there's a lot of different things happening there basically, but so that

1224
00:55:07,680 --> 00:55:13,163
Runs in the game process, right? It technically does but not not inside the game instance

1225
00:55:13,163 --> 00:55:14,464
So we use the same executable

1226
00:55:14,464 --> 00:55:19,926
But it's it's a different instance like we rename the executable file and then we run the conversion process so that will basically just eat

1227
00:55:20,047 --> 00:55:22,289
up the core text files and spit out core binary files.

1228
00:55:22,289 --> 00:55:23,831
And those core binary files are then

1229
00:55:23,831 --> 00:55:25,213
actually loaded by the game.

1230
00:55:25,213 --> 00:55:26,915
So this is essentially an offline process,

1231
00:55:26,915 --> 00:55:28,217
but it's done on demand.

1232
00:55:28,217 --> 00:55:30,680
So as you're working in the editor or whatever,

1233
00:55:30,680 --> 00:55:31,842
and you load up the game, the game

1234
00:55:31,842 --> 00:55:34,165
will make a request to a convert worker for this operation.

1235
00:55:34,165 --> 00:55:35,907
It will convert the data, and then that

1236
00:55:35,907 --> 00:55:37,309
will get loaded into the game.

1237
00:55:37,309 --> 00:55:37,469
Cool.

1238
00:55:37,469 --> 00:55:37,730
Thanks.

1239
00:55:40,617 --> 00:55:46,823
I had a question about a little less technical, I guess, logistics of making this happen.

1240
00:55:46,823 --> 00:55:50,606
And so you guys started out with one prototype.

1241
00:55:50,606 --> 00:55:54,189
Was that pushed from like engineers to higher levels?

1242
00:55:54,189 --> 00:56:00,495
Like did you pitch it or was it like an order from up there somewhere?

1243
00:56:00,495 --> 00:56:03,858
Like how did you guys go about that?

1244
00:56:03,858 --> 00:56:06,780
We don't really have like a sort of...

1245
00:56:08,359 --> 00:56:10,300
strong hierarchy or something and the real so it was nobody

1246
00:56:10,300 --> 00:56:12,602
saying like hey you need to make this or something it was more

1247
00:56:12,602 --> 00:56:15,764
like as a tool seen we discussed it quite quite extensively

1248
00:56:15,764 --> 00:56:17,706
and we look to the options we're faced with and it was kind of

1249
00:56:17,706 --> 00:56:20,448
like the new game was so big and complicated that

1250
00:56:20,448 --> 00:56:22,389
while it would be technically possible to make it with all

1251
00:56:22,389 --> 00:56:25,231
tools it would just require so much effort that we decided

1252
00:56:25,231 --> 00:56:27,333
we should at least explore making a new editor and trying

1253
00:56:27,333 --> 00:56:30,115
that out so that was something that we just sort of did and

1254
00:56:30,115 --> 00:56:33,178
it was something we a conclusion that we reached as consensus

1255
00:56:33,178 --> 00:56:34,138
as a team basically.

1256
00:56:43,399 --> 00:56:51,507
I had a quick question about the basic stuff like the menus and the docking panels and the trees. They were all rewritten using this

1257
00:56:51,507 --> 00:56:58,153
That's the framework that that was started. There was nothing reused from OS code or you know I'm trying to say

1258
00:56:58,153 --> 00:57:01,817
Well for all of the kind of like lower level stuff like

1259
00:57:01,817 --> 00:57:05,320
File handles and what have you that was already present inside of the decimal engine

1260
00:57:05,802 --> 00:57:08,082
For the user interface, we have sort of two different parts.

1261
00:57:08,082 --> 00:57:11,123
We have our own custom control framework,

1262
00:57:11,123 --> 00:57:14,264
we call it, which is just simple things like buttons or any kind

1263
00:57:14,264 --> 00:57:15,744
of two-dimensional rendering.

1264
00:57:15,744 --> 00:57:18,565
And then for the most of the bread and butter controls

1265
00:57:18,565 --> 00:57:20,825
of the user interface, such as buttons and menus and whatever,

1266
00:57:20,825 --> 00:57:23,766
we use a framework called Qt, or Q-T,

1267
00:57:23,766 --> 00:57:25,206
depending on how you want to pronounce it.

1268
00:57:25,206 --> 00:57:25,886
But yeah, that's it.

1269
00:57:25,886 --> 00:57:26,286
All right.

1270
00:57:26,286 --> 00:57:26,446
OK.

1271
00:57:35,363 --> 00:57:36,724
One more.

1272
00:57:36,724 --> 00:57:37,304
Quick question.

1273
00:57:37,304 --> 00:57:39,706
So at what point of the process did you

1274
00:57:39,706 --> 00:57:41,427
decide to create the Decima API?

1275
00:57:41,427 --> 00:57:42,768
And how much of an undertaking was

1276
00:57:42,768 --> 00:57:44,849
it to create the Python wrappers for your tech artists?

1277
00:57:44,849 --> 00:57:47,371
That was something that happened very recently, actually.

1278
00:57:48,677 --> 00:57:50,139
I don't recall the exact date, but I

1279
00:57:50,139 --> 00:57:53,142
think it was within the last two or three months or something.

1280
00:57:53,142 --> 00:57:55,064
And in terms of getting it online,

1281
00:57:55,064 --> 00:57:56,646
it was a very easy thing to make, in a way.

1282
00:57:56,646 --> 00:58:00,810
It took much more time to really drill down and understand

1283
00:58:00,810 --> 00:58:02,552
exactly what this thing was going to do

1284
00:58:02,552 --> 00:58:05,676
and how each API call was going to look and whatever.

1285
00:58:05,676 --> 00:58:07,177
And then one guy just sat and wrote it,

1286
00:58:07,177 --> 00:58:09,480
and it took him, I think, a couple of weeks

1287
00:58:09,480 --> 00:58:09,980
to make the thing.

1288
00:58:09,980 --> 00:58:10,321
Cool.

1289
00:58:10,321 --> 00:58:10,461
Thanks.

1290
00:58:17,369 --> 00:58:19,093
All right, well, I think there's no more questions, so.

1291
00:58:19,093 --> 00:58:19,654
Thank you.

1292
00:58:19,654 --> 00:58:20,316
Thank you very much.

