1
00:00:07,946 --> 00:00:08,166
All right.

2
00:00:08,166 --> 00:00:10,969
A bit of housekeeping beforehand.

3
00:00:10,969 --> 00:00:15,532
Any mobile phones turn to silent, et cetera.

4
00:00:15,532 --> 00:00:20,336
And I think after this, everyone gets

5
00:00:20,336 --> 00:00:22,478
an email with some feedback.

6
00:00:22,478 --> 00:00:23,899
That'd be great if you fill it in,

7
00:00:23,899 --> 00:00:27,422
even if it's a complete disaster, which hopefully it

8
00:00:27,422 --> 00:00:27,643
won't be.

9
00:00:29,375 --> 00:00:33,956
So I'm Mike Malinowski and I'm a senior technical artist at Creative Assembly.

10
00:00:33,956 --> 00:00:41,698
I've been in the industry for about 11 years doing a mixture of rigging, tools and pipeline development.

11
00:00:41,698 --> 00:00:49,380
Previous companies have been Animal Logic, Creative Assembly at the minute, Guerrilla Games and Lionhead Studios.

12
00:00:51,031 --> 00:00:55,414
So at Creative Assembly, we can have anywhere between

13
00:00:55,414 --> 00:00:58,496
two and six projects all running in parallel

14
00:00:58,496 --> 00:00:59,837
at the same time.

15
00:00:59,837 --> 00:01:02,899
So finding the right time to pause and refactor

16
00:01:02,899 --> 00:01:06,701
or experiment with new ideas can be really challenging

17
00:01:06,701 --> 00:01:09,503
without causing potential knock-on effects

18
00:01:09,503 --> 00:01:10,884
to any of those projects,

19
00:01:10,884 --> 00:01:15,087
especially when many of those projects all share

20
00:01:15,087 --> 00:01:17,949
large chunks of a common tech art and tool code base.

21
00:01:19,060 --> 00:01:21,142
So ultimately, the takeaway of this talk

22
00:01:21,142 --> 00:01:24,724
is how we actively change the way we write our tools

23
00:01:24,724 --> 00:01:27,165
to create a environment and a pipeline

24
00:01:27,165 --> 00:01:29,627
that allows us to be a bit more forward-facing

25
00:01:29,627 --> 00:01:30,627
and to take more risks.

26
00:01:30,627 --> 00:01:35,410
The majority of the examples that I'll put forward

27
00:01:35,410 --> 00:01:37,671
use Maya and Python, but the concepts

28
00:01:37,671 --> 00:01:39,873
are certainly not limited to either of those.

29
00:01:42,078 --> 00:01:44,479
So every solution is ultimately born of a problem,

30
00:01:44,479 --> 00:01:49,563
and anyone that's wrote any tools or even just scripts

31
00:01:49,563 --> 00:01:51,484
might familiarize yourself with this scenario

32
00:01:51,484 --> 00:01:54,026
where if we've been given a tool brief

33
00:01:54,026 --> 00:01:56,327
or we've just got an idea for a script

34
00:01:56,327 --> 00:01:57,328
that might help someone.

35
00:01:58,292 --> 00:02:00,994
We sit down and we start coding.

36
00:02:00,994 --> 00:02:04,958
And if we're writing something for someone else,

37
00:02:04,958 --> 00:02:07,320
we get a good idea of what it is they're after,

38
00:02:07,320 --> 00:02:10,003
and we start putting pen to paper, right?

39
00:02:10,003 --> 00:02:11,965
And we start writing some code.

40
00:02:11,965 --> 00:02:12,886
And at that point in time,

41
00:02:12,886 --> 00:02:15,028
we're probably the only ones using it

42
00:02:15,028 --> 00:02:15,929
as we're developing it.

43
00:02:15,929 --> 00:02:18,911
So our code is pretty clean, it's pretty tight,

44
00:02:18,911 --> 00:02:21,234
and it's relatively neat, hopefully.

45
00:02:21,892 --> 00:02:24,613
And we give our tools out to a couple of users,

46
00:02:24,613 --> 00:02:26,814
we get some beta testing going on,

47
00:02:26,814 --> 00:02:28,955
and inevitably they want changes

48
00:02:28,955 --> 00:02:31,856
because we've maybe misinterpreted something

49
00:02:31,856 --> 00:02:33,016
or what they thought they want

50
00:02:33,016 --> 00:02:34,277
isn't what they actually want.

51
00:02:34,277 --> 00:02:36,758
And so we go back into our code

52
00:02:36,758 --> 00:02:40,759
and we start altering that based on that feedback.

53
00:02:40,759 --> 00:02:43,160
And the remit of the tool doesn't really change,

54
00:02:43,160 --> 00:02:46,362
but we start to jiggle our code around underneath

55
00:02:46,362 --> 00:02:48,162
and time is not always on our side, right?

56
00:02:48,162 --> 00:02:51,203
So the code becomes a little bit more unclean.

57
00:02:52,828 --> 00:02:54,351
We release it out to the team, and we

58
00:02:54,351 --> 00:02:57,235
start to get more and more users using our tools.

59
00:02:57,235 --> 00:03:02,263
And as more users use it, and as our projects continue to grow.

60
00:03:03,300 --> 00:03:05,121
So does the requirements of the tool.

61
00:03:05,121 --> 00:03:07,923
People ask for extra pieces of functionality,

62
00:03:07,923 --> 00:03:10,845
and we start bolting on more and more code

63
00:03:10,845 --> 00:03:12,606
as the projects grow.

64
00:03:12,606 --> 00:03:15,367
And if we're really lucky, or unlucky,

65
00:03:15,367 --> 00:03:17,588
then multiple projects pick up our tool.

66
00:03:17,588 --> 00:03:19,990
And everyone, whilst they work in very similar ways,

67
00:03:19,990 --> 00:03:22,391
they all have slightly different requirements,

68
00:03:22,391 --> 00:03:24,312
or additional feature requests,

69
00:03:24,312 --> 00:03:26,253
and so we bolt on more and more features,

70
00:03:26,253 --> 00:03:30,136
or maybe we expose different pieces of our libraries

71
00:03:30,136 --> 00:03:32,697
to other tools in a project-specific pipeline.

72
00:03:33,990 --> 00:03:36,673
And what this tends to lead to is this scenario

73
00:03:36,673 --> 00:03:38,995
whereby you have this monolithic, horrible piece of code

74
00:03:38,995 --> 00:03:42,800
that no one really knows which bits are used

75
00:03:42,800 --> 00:03:45,483
by which project, if any at all.

76
00:03:45,483 --> 00:03:47,265
And it ultimately leads to a point

77
00:03:47,265 --> 00:03:49,247
where no one wants to touch it

78
00:03:49,247 --> 00:03:51,810
because no one really knows what the side effects will be

79
00:03:51,810 --> 00:03:54,052
of making any changes to those bits of code.

80
00:03:55,458 --> 00:03:59,881
So when we get to that point where we can breathe and we can look forward and we have

81
00:03:59,881 --> 00:04:05,566
a pause in production where we could potentially experiment with some new ideas, we don't.

82
00:04:05,566 --> 00:04:09,148
We look back and we say there's no way I'm going through another production cycle with

83
00:04:09,148 --> 00:04:11,530
that tool there because it's just a nightmare.

84
00:04:12,562 --> 00:04:14,443
and the cost of refactoring it is so high

85
00:04:14,443 --> 00:04:17,885
that we end up just chucking it in the bin, right?

86
00:04:17,885 --> 00:04:18,965
We start again.

87
00:04:18,965 --> 00:04:21,567
We take everything we've learned from that whole process,

88
00:04:21,567 --> 00:04:24,288
but ultimately we start the process over

89
00:04:24,288 --> 00:04:26,970
and we clean slate.

90
00:04:26,970 --> 00:04:28,891
And that I see a lot, right?

91
00:04:28,891 --> 00:04:29,411
It's depressing.

92
00:04:29,411 --> 00:04:32,072
I see a lot in my own tools and I look at it

93
00:04:32,072 --> 00:04:34,674
and I die inside when I see it.

94
00:04:34,674 --> 00:04:36,235
But I think there's a better way.

95
00:04:37,561 --> 00:04:41,042
A good example of this scenario are exporters.

96
00:04:41,042 --> 00:04:43,362
So let's have a quick look at how this happens

97
00:04:43,362 --> 00:04:45,223
in a more realistic scenario.

98
00:04:45,223 --> 00:04:48,324
So here's some hypothetical export code, right?

99
00:04:48,324 --> 00:04:50,924
And imagine that we're right at the early beginnings

100
00:04:50,924 --> 00:04:52,845
of a project, and all we actually need to do

101
00:04:52,845 --> 00:04:55,765
is export some meshes and export some joints.

102
00:04:55,765 --> 00:04:58,086
So we've got a bit of code at the top

103
00:04:58,086 --> 00:05:00,487
that's literally looking for all the meshes in the scene.

104
00:05:00,487 --> 00:05:02,647
And maybe we're looking for...

105
00:05:02,987 --> 00:05:05,669
a specific attribute, and if it has this attribute,

106
00:05:05,669 --> 00:05:08,451
then we'll ask some process to export it out for us.

107
00:05:08,451 --> 00:05:10,713
And then we're doing pretty much the same thing

108
00:05:10,713 --> 00:05:12,494
at the bottom, but this time we're looking for joints,

109
00:05:12,494 --> 00:05:14,896
because all we need is meshes and skeletal data.

110
00:05:16,505 --> 00:05:18,226
But maybe our project's going reasonably well

111
00:05:18,226 --> 00:05:20,727
and we decide to implement cloth simulation.

112
00:05:20,727 --> 00:05:22,367
Maybe we're using something like Apex

113
00:05:22,367 --> 00:05:25,148
where we need to mark up and paint data

114
00:05:25,148 --> 00:05:27,289
on this geometry within Max or Maya.

115
00:05:27,289 --> 00:05:30,850
So we have to export that data out as well.

116
00:05:30,850 --> 00:05:34,271
And it kind of makes sense to put your cloth export logic

117
00:05:34,271 --> 00:05:35,992
in with your geometry export logic

118
00:05:35,992 --> 00:05:38,313
because you're always gonna export your cloth

119
00:05:38,313 --> 00:05:40,414
when you export your geometry.

120
00:05:40,414 --> 00:05:41,734
So in that goes.

121
00:05:42,651 --> 00:05:44,633
And then maybe we attend something like GDC,

122
00:05:44,633 --> 00:05:47,815
and we get really excited by the next best

123
00:05:47,815 --> 00:05:51,198
runtime rigging technology, and we come back

124
00:05:51,198 --> 00:05:53,460
and we update our exporter because we want

125
00:05:53,460 --> 00:05:54,961
to have a play with that.

126
00:05:54,961 --> 00:05:57,303
And maybe our runtime rigging information

127
00:05:57,303 --> 00:06:01,286
needs to look at geometry and skeletal information.

128
00:06:01,286 --> 00:06:04,569
So each little insertion here isn't particularly complex.

129
00:06:04,569 --> 00:06:07,471
Each line, like it's a couple of lines each.

130
00:06:08,085 --> 00:06:12,707
It's not heavy code, but it's interspersed across the whole of the exporter.

131
00:06:12,707 --> 00:06:18,170
And then perhaps in a couple of months' time, as we mature in our project and we realize

132
00:06:18,170 --> 00:06:24,093
this particular implementation isn't what we want, if someone else has gone in and added

133
00:06:24,093 --> 00:06:29,516
support for things like blend shapes, for LODs or ragdolls, trying to cherry-pick these

134
00:06:29,516 --> 00:06:32,298
pieces back out can be really challenging.

135
00:06:33,535 --> 00:06:35,397
And that ultimately leads to a scenario where you end up

136
00:06:35,397 --> 00:06:38,419
with an exporter full of legacy code where no one really

137
00:06:38,419 --> 00:06:41,362
knows which bits are used and which bits are not used.

138
00:06:41,362 --> 00:06:42,963
And no one wants to touch it.

139
00:06:42,963 --> 00:06:45,145
And every project, we write a whole new exporter

140
00:06:45,145 --> 00:06:46,286
over and over again.

141
00:06:46,286 --> 00:06:52,411
And it's this problem that we put forward a solution to.

142
00:06:52,411 --> 00:06:56,334
And for us, that solution is the implementation of a pretty

143
00:06:56,334 --> 00:06:58,656
well-established design pattern.

144
00:06:58,656 --> 00:07:01,318
And a design pattern can be thought of simply as an

145
00:07:01,318 --> 00:07:03,080
approach or a concept to code that

146
00:07:03,503 --> 00:07:06,006
can be used in many different situations.

147
00:07:06,006 --> 00:07:07,448
And there's a great website here

148
00:07:07,448 --> 00:07:08,829
which is worth having a look at.

149
00:07:08,829 --> 00:07:12,353
This has a whole myriad of different design patterns

150
00:07:12,353 --> 00:07:14,736
and it details them out and it has examples

151
00:07:14,736 --> 00:07:16,258
in Python and C Sharp and C++,

152
00:07:16,258 --> 00:07:18,400
so it's a really good resource.

153
00:07:18,400 --> 00:07:22,184
But ultimately for us, we're gonna look

154
00:07:22,184 --> 00:07:25,028
at a design pattern called the factory plugin pattern.

155
00:07:26,223 --> 00:07:29,344
But before we deep dive into what that pattern is,

156
00:07:29,344 --> 00:07:32,385
it's worth taking a moment and reflecting on the fact

157
00:07:32,385 --> 00:07:35,965
that as a discipline, tools and tech art

158
00:07:35,965 --> 00:07:38,766
stem from many different backgrounds, right?

159
00:07:38,766 --> 00:07:41,926
We have engineers who have a passion for things

160
00:07:41,926 --> 00:07:45,047
that are visual, and we have artists and animators

161
00:07:45,047 --> 00:07:47,187
who love automation, and we have tech art

162
00:07:47,187 --> 00:07:49,788
and tech animation that sits somewhere in the middle.

163
00:07:49,788 --> 00:07:52,748
And so we all come from very different backgrounds

164
00:07:52,748 --> 00:07:53,948
with very different knowledge.

165
00:07:55,275 --> 00:07:57,857
So before we look at how we implemented this pattern

166
00:07:57,857 --> 00:07:59,098
and what it actually gave us

167
00:07:59,098 --> 00:08:01,761
and some examples of where we use it,

168
00:08:01,761 --> 00:08:02,962
I think it's worth taking a moment

169
00:08:02,962 --> 00:08:05,564
and collectively getting a good understanding

170
00:08:05,564 --> 00:08:06,866
of what the pattern is.

171
00:08:06,866 --> 00:08:10,589
So the pattern itself is made up of three parts.

172
00:08:10,589 --> 00:08:13,532
You have something called a factory,

173
00:08:13,532 --> 00:08:15,274
something called an abstract,

174
00:08:15,274 --> 00:08:16,815
and something called plugins.

175
00:08:17,999 --> 00:08:20,881
Now, arguably, the most crucial part of all of these

176
00:08:20,881 --> 00:08:23,662
is the abstract, because that tends to define

177
00:08:23,662 --> 00:08:26,023
what it is we're trying to achieve.

178
00:08:26,023 --> 00:08:28,384
So that's where we'll start here.

179
00:08:28,384 --> 00:08:31,846
And an abstract is pretty much just a class, right?

180
00:08:31,846 --> 00:08:34,027
And when we tend to use classes,

181
00:08:34,027 --> 00:08:36,108
we do so so that we can write some functionality,

182
00:08:36,108 --> 00:08:39,810
and then maybe we subclass off that base class,

183
00:08:39,810 --> 00:08:41,891
and we add some more specific functionality,

184
00:08:41,891 --> 00:08:44,313
and we keep going on like that.

185
00:08:45,944 --> 00:08:49,706
An abstract isn't that dissimilar from the base class,

186
00:08:49,706 --> 00:08:51,587
assuming that the base class is the gray icon here.

187
00:08:51,587 --> 00:08:56,729
But an abstract has to follow three really strict rules.

188
00:08:56,729 --> 00:09:00,851
So we can never instance an abstract class directly.

189
00:09:00,851 --> 00:09:02,712
We can only ever inherit from one.

190
00:09:02,712 --> 00:09:06,574
And an abstract is kind of a skeleton

191
00:09:06,574 --> 00:09:07,935
of methods and arguments.

192
00:09:07,935 --> 00:09:10,656
It never contains any actual functionality within it.

193
00:09:11,720 --> 00:09:14,042
And when we subclass an abstract,

194
00:09:14,042 --> 00:09:16,904
we absolutely have to reimplement any abstract methods.

195
00:09:16,904 --> 00:09:21,888
And that gives us classes that look a lot like this,

196
00:09:21,888 --> 00:09:23,750
where they're structurally identical.

197
00:09:24,659 --> 00:09:27,341
And Python gives us a really nice module.

198
00:09:27,341 --> 00:09:28,622
That's the best thing about Python, right?

199
00:09:28,622 --> 00:09:31,265
There's always something already done for you.

200
00:09:31,265 --> 00:09:32,546
But there's a module called ABC,

201
00:09:32,546 --> 00:09:35,589
and that simply allows you to decorate your classes,

202
00:09:35,589 --> 00:09:37,190
decorate your methods,

203
00:09:37,190 --> 00:09:39,612
and it will enforce this whole paradigm.

204
00:09:39,612 --> 00:09:42,215
It won't allow you to break any of those rules.

205
00:09:42,215 --> 00:09:44,557
So it's a nice way of, if you go down this route,

206
00:09:44,557 --> 00:09:46,138
of enforcing that it's followed.

207
00:09:48,193 --> 00:09:51,015
But the fundamental part of this is ultimately

208
00:09:51,015 --> 00:09:54,158
we can start to interact with all of these classes

209
00:09:54,158 --> 00:09:55,880
in exactly the same way.

210
00:09:55,880 --> 00:09:58,843
And that brings us to the second part of the pattern,

211
00:09:58,843 --> 00:09:59,964
which is the plugins.

212
00:09:59,964 --> 00:10:02,826
And they are the green icons on this slide.

213
00:10:02,826 --> 00:10:05,228
We don't necessarily have to care or know

214
00:10:05,228 --> 00:10:07,971
what each plugin is doing under the hood

215
00:10:07,971 --> 00:10:10,013
because we know exactly how to call them

216
00:10:10,013 --> 00:10:13,436
and what we can expect from their returns.

217
00:10:15,165 --> 00:10:17,987
So that's our abstracts and our plugins.

218
00:10:17,987 --> 00:10:20,009
So the third part of the pattern is the factory.

219
00:10:20,009 --> 00:10:21,730
Now the responsibility of the factory

220
00:10:21,730 --> 00:10:25,213
is ultimately to find plugins.

221
00:10:25,213 --> 00:10:30,137
And this can be as simple as doing a walk

222
00:10:30,137 --> 00:10:32,278
over directories and Python files

223
00:10:32,278 --> 00:10:36,141
and inspecting them for implementations of our abstract.

224
00:10:36,141 --> 00:10:38,843
And the second part of that responsibility

225
00:10:38,843 --> 00:10:42,426
is to give us some way of accessing the plugins

226
00:10:42,426 --> 00:10:43,987
that they've found.

227
00:10:45,666 --> 00:10:48,707
The idea here is ultimately that the finding of plugins

228
00:10:48,707 --> 00:10:50,568
is completely dynamic.

229
00:10:50,568 --> 00:10:53,050
So we don't have to hard code import statements

230
00:10:53,050 --> 00:10:56,631
to every piece of functionality a tool might need to utilize.

231
00:10:56,631 --> 00:10:58,492
To put that into practice, we can

232
00:10:58,492 --> 00:11:00,733
start to have a piece of code that looks a bit like this,

233
00:11:00,733 --> 00:11:04,115
where given a factory, we can just ask for all the plugins

234
00:11:04,115 --> 00:11:07,516
that it has, and we can cycle over each plugin.

235
00:11:07,516 --> 00:11:09,978
We don't necessarily need to know what that plugin's doing,

236
00:11:09,978 --> 00:11:11,318
but we know how to call it.

237
00:11:11,318 --> 00:11:12,839
We know how to interact with it.

238
00:11:14,508 --> 00:11:16,550
It also means that we can scale very easily.

239
00:11:16,550 --> 00:11:18,631
To add some new functionality,

240
00:11:18,631 --> 00:11:20,953
we just drop a plugin into a location

241
00:11:20,953 --> 00:11:22,674
where our factory is searching.

242
00:11:22,674 --> 00:11:25,816
Now don't worry if that sounds a little bit fuzzy

243
00:11:25,816 --> 00:11:28,117
and conceptual because we're gonna have a look again

244
00:11:28,117 --> 00:11:32,420
at the exporter, but this time we're gonna re-implement it

245
00:11:32,420 --> 00:11:35,682
using this pattern, and then we'll see side by side

246
00:11:35,682 --> 00:11:37,703
what it actually looks like and what it gives us.

247
00:11:37,703 --> 00:11:40,245
So I said that the abstract pretty much defines

248
00:11:40,245 --> 00:11:41,746
what it is we're trying to achieve,

249
00:11:41,746 --> 00:11:43,167
so that's what we'll start with.

250
00:11:44,495 --> 00:11:47,297
So we have two methods in our abstract.

251
00:11:47,297 --> 00:11:49,539
We have a method called the viable method

252
00:11:49,539 --> 00:11:51,761
and we've got a method we've called an export method.

253
00:11:51,761 --> 00:11:54,763
So our export is pretty simple and straightforward.

254
00:11:54,763 --> 00:11:57,925
The idea behind the viable method is simply

255
00:11:57,925 --> 00:12:01,388
for this plugin to decide itself whether there's anything

256
00:12:01,388 --> 00:12:05,391
within the scene or the context that it can export.

257
00:12:05,391 --> 00:12:07,132
So if this was a cloth plugin,

258
00:12:07,132 --> 00:12:09,353
it might look to see whether there's any cloth.

259
00:12:10,101 --> 00:12:12,022
And the idea here is it's a fail-fast method,

260
00:12:12,022 --> 00:12:15,505
so it should get out as quickly as possible.

261
00:12:15,505 --> 00:12:18,648
The export method is then the method

262
00:12:18,648 --> 00:12:20,409
that's actually going to do the data wrangling,

263
00:12:20,409 --> 00:12:22,531
all the hard work.

264
00:12:22,531 --> 00:12:23,872
So that's our abstract.

265
00:12:23,872 --> 00:12:25,453
That's all an abstract is.

266
00:12:25,453 --> 00:12:27,815
It's kind of a completely empty structure.

267
00:12:29,217 --> 00:12:30,898
Next, we need a factory.

268
00:12:30,898 --> 00:12:32,699
Now, a factory is really, really generic, right?

269
00:12:32,699 --> 00:12:36,140
It's just a mechanism of searching for things,

270
00:12:36,140 --> 00:12:39,302
and it can literally be a class

271
00:12:39,302 --> 00:12:40,902
that cycles over directories,

272
00:12:40,902 --> 00:12:42,303
and any plugins that it finds,

273
00:12:42,303 --> 00:12:45,424
it holds a reference to and gives us access to them.

274
00:12:45,424 --> 00:12:48,405
And they're so generic that we wrote a little module

275
00:12:48,405 --> 00:12:51,687
we call plugged, and we now use that everywhere.

276
00:12:51,687 --> 00:12:54,668
And we just ask for a new factory.

277
00:12:55,548 --> 00:12:56,989
and we have to give it three things.

278
00:12:56,989 --> 00:12:58,650
So we have to give it the abstract

279
00:12:58,650 --> 00:13:00,531
so that it knows what to look for

280
00:13:00,531 --> 00:13:02,813
when it's searching for plugins.

281
00:13:02,813 --> 00:13:04,994
We also have to give it an identifying property

282
00:13:04,994 --> 00:13:07,835
so that it can differentiate between different plugins

283
00:13:07,835 --> 00:13:08,896
that it has a reference to.

284
00:13:08,896 --> 00:13:12,098
And then we just need to give it the locations

285
00:13:12,098 --> 00:13:14,439
where it should search for plugins.

286
00:13:14,439 --> 00:13:18,581
So that's our factory, and we have our abstract,

287
00:13:18,581 --> 00:13:20,182
so now we just need our plugins.

288
00:13:22,123 --> 00:13:24,084
So this is what a plugin could look like.

289
00:13:24,084 --> 00:13:27,265
And you'll probably notice that it's pretty much

290
00:13:27,265 --> 00:13:29,786
a copy-paste of our first exporter,

291
00:13:29,786 --> 00:13:31,487
at least the geometry part.

292
00:13:31,487 --> 00:13:34,127
The only difference is we've jiggled it around

293
00:13:34,127 --> 00:13:35,628
inside these two methods.

294
00:13:35,628 --> 00:13:38,929
And because we're doing some of the same things

295
00:13:38,929 --> 00:13:40,049
within both of those methods,

296
00:13:40,049 --> 00:13:42,010
we've just added a private method as well.

297
00:13:42,010 --> 00:13:45,531
But ultimately there's no magic, that's the key.

298
00:13:45,531 --> 00:13:46,992
We're doing the same stuff,

299
00:13:46,992 --> 00:13:49,573
we're just encapsulating the geometry

300
00:13:49,573 --> 00:13:51,733
so that it doesn't affect anything else.

301
00:13:53,144 --> 00:13:56,327
And we do the same thing for the skeletal plugin.

302
00:13:56,327 --> 00:13:57,908
The code is almost identical

303
00:13:57,908 --> 00:14:00,190
because it was identical in the last exporter.

304
00:14:00,190 --> 00:14:02,011
But we've got now two plugins.

305
00:14:02,011 --> 00:14:06,475
And they're never gonna cross-contaminate each other.

306
00:14:06,475 --> 00:14:08,437
So we can start to make drastic changes

307
00:14:08,437 --> 00:14:09,838
to how we export geometry,

308
00:14:09,838 --> 00:14:11,919
and we're never gonna affect

309
00:14:11,919 --> 00:14:14,121
how we're exporting skeletal information.

310
00:14:14,121 --> 00:14:16,403
We can never break our skeletal exporter

311
00:14:16,403 --> 00:14:19,926
even if we completely screw up our geometry exporter.

312
00:14:21,146 --> 00:14:22,447
In practice, that gives us something

313
00:14:22,447 --> 00:14:23,448
that looks like this, right?

314
00:14:23,448 --> 00:14:26,531
So we're in Maya, we have a mesh and we have a skeleton,

315
00:14:26,531 --> 00:14:30,515
and we can see that we've got some exportable attributes

316
00:14:30,515 --> 00:14:33,578
on there so that we know what should get picked up.

317
00:14:33,578 --> 00:14:36,841
And in our script editor, we import our factory.

318
00:14:36,841 --> 00:14:38,103
We're not importing plugins,

319
00:14:38,103 --> 00:14:39,584
we're not importing anything specific.

320
00:14:39,584 --> 00:14:42,066
We simply import our export factory.

321
00:14:42,927 --> 00:14:45,209
We then cycle over our factory,

322
00:14:45,209 --> 00:14:47,090
and for each plugin in that factory,

323
00:14:47,090 --> 00:14:49,491
we ask the plugin itself whether it's viable,

324
00:14:49,491 --> 00:14:52,513
whether there's anything in here it can export.

325
00:14:52,513 --> 00:14:56,276
And if there is, we ask it to do the export for us.

326
00:14:56,276 --> 00:14:57,937
Now, in this particular example in the output

327
00:14:57,937 --> 00:15:00,078
that's now disappeared,

328
00:15:00,078 --> 00:15:02,059
but there was an output for a cloth plugin,

329
00:15:02,059 --> 00:15:03,961
but there's no cloth in that scene.

330
00:15:03,961 --> 00:15:06,142
So that returned false on its viability,

331
00:15:06,142 --> 00:15:07,643
and we never even attempt to export the cloth.

332
00:15:07,643 --> 00:15:08,744
Now, there's a trade-off.

333
00:15:11,892 --> 00:15:14,534
and that's one of performance.

334
00:15:14,534 --> 00:15:18,597
If, for instance, we have 10, 15 different data types,

335
00:15:18,597 --> 00:15:21,459
it's entirely possible that we're doing the same

336
00:15:21,459 --> 00:15:24,020
or similar validation in each plugin,

337
00:15:24,020 --> 00:15:26,842
so time will keep increasing.

338
00:15:26,842 --> 00:15:28,904
But the gain of paying that cost

339
00:15:28,904 --> 00:15:31,245
is that we can start to really experiment

340
00:15:31,245 --> 00:15:34,187
with different export types without ever incurring

341
00:15:35,558 --> 00:15:38,640
the possibility of having to refactor code.

342
00:15:38,640 --> 00:15:42,002
We can extend and contract our exporter

343
00:15:42,002 --> 00:15:44,824
without causing lots of knock-on effects elsewhere.

344
00:15:44,824 --> 00:15:47,986
And that's simply because the factory

345
00:15:47,986 --> 00:15:50,287
is kind of blind to what's going on around it.

346
00:15:50,287 --> 00:15:53,529
It's simply pulling out plugins from directories.

347
00:15:53,529 --> 00:15:55,390
So to add the blend shape support,

348
00:15:55,390 --> 00:15:56,791
or to add the LOD support,

349
00:15:56,791 --> 00:15:59,432
we just drop a new Python file into a directory

350
00:15:59,432 --> 00:16:02,314
that understands how to export that information,

351
00:16:02,314 --> 00:16:03,735
and our exporter will pick it up.

352
00:16:13,759 --> 00:16:19,763
And we can harness Python's implementation of keyword arguments to great effect with this,

353
00:16:19,763 --> 00:16:22,685
to be able to be really specific at export time,

354
00:16:22,685 --> 00:16:25,247
whilst retaining a very generic export framework.

355
00:16:26,050 --> 00:16:28,752
So for those of you that might not be familiar with

356
00:16:28,752 --> 00:16:32,154
Python's keyword arguments, it's ultimately a mechanism

357
00:16:32,154 --> 00:16:35,675
that allows you to call a function with any amount

358
00:16:35,675 --> 00:16:38,077
of arguments or named arguments,

359
00:16:38,077 --> 00:16:40,038
without ever declaring them up front.

360
00:16:40,038 --> 00:16:42,799
So in this example, we're calling a function

361
00:16:42,799 --> 00:16:46,721
called export scene, and we're calling it with

362
00:16:46,721 --> 00:16:48,402
an argument of bones per vertex.

363
00:16:49,680 --> 00:16:52,122
But our export scene doesn't have an argument

364
00:16:52,122 --> 00:16:52,982
of bones per vertex.

365
00:16:52,982 --> 00:16:56,005
So that goes into the kwags argument for us,

366
00:16:56,005 --> 00:16:58,847
and that becomes a dictionary of key value pairs

367
00:16:58,847 --> 00:17:00,068
that we can utilize.

368
00:17:00,068 --> 00:17:04,271
This means the export scene method never really has to care

369
00:17:04,271 --> 00:17:06,353
what arguments are being passed to it.

370
00:17:06,353 --> 00:17:08,695
It can just blindly pass those arguments down

371
00:17:08,695 --> 00:17:12,258
to the viability and the export method of each plugin.

372
00:17:13,690 --> 00:17:16,231
Those plugins can then choose what they look at

373
00:17:16,231 --> 00:17:18,112
within those arguments.

374
00:17:18,112 --> 00:17:20,113
So our geometry plugin's probably not gonna look

375
00:17:20,113 --> 00:17:23,135
for a bones per vertex attribute, so it'll just ignore it.

376
00:17:23,135 --> 00:17:24,676
But our skeletal plugin might.

377
00:17:24,676 --> 00:17:28,658
So here it's looking for a bones per vertex attribute.

378
00:17:28,658 --> 00:17:30,700
If it finds it, then it'll use it.

379
00:17:30,700 --> 00:17:32,481
Otherwise, it'll default to four.

380
00:17:32,481 --> 00:17:34,302
And through this mechanism,

381
00:17:34,302 --> 00:17:37,424
we can get very specific export results

382
00:17:37,424 --> 00:17:39,105
without ever having to update

383
00:17:39,105 --> 00:17:41,286
the central core part of our exporter.

384
00:17:42,957 --> 00:17:46,559
So when we compare these two implementations of exporters,

385
00:17:46,559 --> 00:17:49,021
it's a bit like comparing these two images,

386
00:17:49,021 --> 00:17:53,883
where we could choose to have one big monolithic exporter

387
00:17:53,883 --> 00:17:56,385
with complex and ever-growing logic,

388
00:17:56,385 --> 00:17:58,726
which becomes hard to follow and manage.

389
00:17:58,726 --> 00:18:03,289
Or we can encapsulate each export data type

390
00:18:03,289 --> 00:18:06,410
and kind of have a one-dimensional flow of logic

391
00:18:06,410 --> 00:18:08,872
which is understandable, that allows us to contract and grow.

392
00:18:10,953 --> 00:18:13,236
And this ultimately promotes experimentation.

393
00:18:13,236 --> 00:18:17,000
As soon as you lower the risk factor,

394
00:18:17,000 --> 00:18:21,185
then people are a little bit more happy to dive in

395
00:18:21,185 --> 00:18:24,489
and try new things because the cost of doing it wrong

396
00:18:24,489 --> 00:18:27,573
is the cost of just removing a file out of a directory.

397
00:18:27,573 --> 00:18:29,035
It's not a big, massive refactor.

398
00:18:31,396 --> 00:18:35,262
What's interesting for us, when we started to understand what this pattern was,

399
00:18:35,262 --> 00:18:40,851
we realized we were kind of already using it in some informal ways.

400
00:18:42,422 --> 00:18:44,142
and we had a lot of code replication.

401
00:18:44,142 --> 00:18:48,104
So we have a node-based execution graph,

402
00:18:48,104 --> 00:18:50,865
we had an animation asset manager on Halo Wars 2,

403
00:18:50,865 --> 00:18:53,467
and a nice rich set of batching tools.

404
00:18:53,467 --> 00:18:58,129
And all of them used this pattern informally

405
00:18:58,129 --> 00:19:00,430
in a very ad hoc way to abstract some form

406
00:19:00,430 --> 00:19:02,290
of what they were doing,

407
00:19:02,290 --> 00:19:04,531
but each one had its own implementation.

408
00:19:05,715 --> 00:19:07,736
And once we realized that, that's when we sat

409
00:19:07,736 --> 00:19:10,477
and we wrote that module that was called Plugged.

410
00:19:10,477 --> 00:19:12,597
And as soon as we had a module,

411
00:19:12,597 --> 00:19:14,358
which was a generic factory class,

412
00:19:14,358 --> 00:19:17,119
the barrier of entry to using this pattern

413
00:19:17,119 --> 00:19:18,779
decreased dramatically.

414
00:19:18,779 --> 00:19:22,880
And it started to ripple across a lot of our tools.

415
00:19:22,880 --> 00:19:24,041
So we'll start to look at what tools

416
00:19:24,041 --> 00:19:27,602
that we've used them in and how we use them.

417
00:19:29,857 --> 00:19:34,181
So at CA we have a pretty rich feature rigging framework

418
00:19:34,181 --> 00:19:39,045
that's been used on a lot of projects for a lot of years

419
00:19:39,045 --> 00:19:40,987
and it's incredibly flexible

420
00:19:40,987 --> 00:19:43,108
and it allows for a massive amount of reuse

421
00:19:43,108 --> 00:19:47,312
and our riggers can churn out rigs really very quickly

422
00:19:47,312 --> 00:19:49,294
and they're incredibly reliable.

423
00:19:49,294 --> 00:19:53,257
So this is exemplified by this work here by David Vince.

424
00:20:13,553 --> 00:20:15,118
Thanks for watching!

425
00:21:31,515 --> 00:21:33,296
I love that work, he's an awesome animator.

426
00:21:34,338 --> 00:21:35,678
But it's frustratingly good.

427
00:21:35,678 --> 00:21:39,520
And I say frustratingly good because when the results

428
00:21:39,520 --> 00:21:43,221
are like that, it's really hard to justify change

429
00:21:43,221 --> 00:21:44,181
in a rigging framework.

430
00:21:44,181 --> 00:21:48,663
But ultimately, the rigging tool set that we were using

431
00:21:48,663 --> 00:21:52,804
had become quite unwieldy over time.

432
00:21:52,804 --> 00:21:55,485
So it took the approach of being

433
00:21:55,485 --> 00:21:57,586
very highly parameterized components.

434
00:21:57,586 --> 00:22:01,908
So we'd have a component, say an IK module and an FK module.

435
00:22:02,838 --> 00:22:07,500
and these would build based upon attributes on joint chains.

436
00:22:07,500 --> 00:22:10,880
So to give an idea of what a single IK module

437
00:22:10,880 --> 00:22:14,221
might be able to do, it would support these kinds of features.

438
00:22:14,221 --> 00:22:18,022
So it could be standard IK, it could be spline IK,

439
00:22:18,022 --> 00:22:23,163
and it could be any combination of these, so they're not exclusive.

440
00:22:23,163 --> 00:22:28,365
And when the order of operations is quite important in rigging,

441
00:22:28,365 --> 00:22:31,245
when it came to wanting to implement soft IK,

442
00:22:32,590 --> 00:22:34,331
what should have been a very simple

443
00:22:34,331 --> 00:22:36,211
and straightforward implementation

444
00:22:36,211 --> 00:22:38,752
actually became really high risk.

445
00:22:38,752 --> 00:22:41,353
Not because the implementation of SoftIK itself

446
00:22:41,353 --> 00:22:44,294
is challenging, but it's really hard to know

447
00:22:44,294 --> 00:22:47,474
whether you're gonna cause any possible knock-on effects

448
00:22:47,474 --> 00:22:49,455
to any other pieces of functionality.

449
00:22:49,455 --> 00:22:51,736
And when you've got six projects

450
00:22:51,736 --> 00:22:54,896
all using the exact same rigging framework,

451
00:22:55,337 --> 00:22:57,477
You can't afford to refactor the whole thing

452
00:22:57,477 --> 00:22:59,998
because you may have rigs that have been in production

453
00:22:59,998 --> 00:23:02,139
for three years or four years,

454
00:23:02,139 --> 00:23:03,960
and they have to be able to build

455
00:23:03,960 --> 00:23:06,140
to exactly the same description

456
00:23:06,140 --> 00:23:08,541
as when they were built their first time.

457
00:23:08,541 --> 00:23:10,762
And this ultimately led to a scenario

458
00:23:10,762 --> 00:23:15,084
where our riggers didn't really want to push,

459
00:23:15,084 --> 00:23:16,784
not because they didn't have the motivation,

460
00:23:16,784 --> 00:23:18,205
but they were scared of the risk.

461
00:23:20,022 --> 00:23:23,846
And it was around this time when we had a good grasp of our,

462
00:23:23,846 --> 00:23:26,849
of the design pattern,

463
00:23:26,849 --> 00:23:30,392
and we were starting to look at some of the talks

464
00:23:30,392 --> 00:23:33,796
by Richard Lyko at GDC 2014 about rigging on demand,

465
00:23:33,796 --> 00:23:36,078
and he's doing an awesome talk tomorrow on that,

466
00:23:36,078 --> 00:23:37,640
so I recommend that as well.

467
00:23:38,340 --> 00:23:40,281
And we had a tech animator called,

468
00:23:40,281 --> 00:23:41,482
we have a tech animator called Joe,

469
00:23:41,482 --> 00:23:44,623
who just put forward the idea, he's like,

470
00:23:44,623 --> 00:23:47,184
I just wanna build something, they're just joints, right?

471
00:23:47,184 --> 00:23:49,445
I just wanna build on top of maybe our controls

472
00:23:49,445 --> 00:23:51,426
or our objects, it shouldn't be this hard.

473
00:23:51,426 --> 00:23:55,767
And so that's kind of what we ended up doing.

474
00:23:55,767 --> 00:23:58,989
We're very invested in a reference rigging pipeline.

475
00:24:00,502 --> 00:24:03,423
it's just impossible to make an overnight switch

476
00:24:03,423 --> 00:24:06,804
to building rigs on demand and have them all local

477
00:24:06,804 --> 00:24:09,446
in our scenes when we've already got all of this pipeline

478
00:24:09,446 --> 00:24:12,967
in place and they're being used across multiple projects.

479
00:24:12,967 --> 00:24:15,028
So we took a middle ground and we figured,

480
00:24:15,028 --> 00:24:18,249
well, our referenced rigs are pretty stable.

481
00:24:18,249 --> 00:24:20,830
They've been used for a long time,

482
00:24:20,830 --> 00:24:22,551
but we want to make them better.

483
00:24:22,551 --> 00:24:25,092
We want to add on top of them.

484
00:24:25,092 --> 00:24:26,593
So we decided to go down the approach

485
00:24:26,593 --> 00:24:28,514
of having bolt-on components that would

486
00:24:29,226 --> 00:24:31,887
interact or sit on top of our reference rigs

487
00:24:31,887 --> 00:24:33,147
and change their behavior.

488
00:24:33,147 --> 00:24:35,267
And that looks a bit like this.

489
00:24:35,267 --> 00:24:37,528
So here we've got a rig in the scene

490
00:24:37,528 --> 00:24:40,689
and we're launching our tool that we call Reaction.

491
00:24:40,689 --> 00:24:43,970
And the animator sees a list of components

492
00:24:43,970 --> 00:24:45,350
that they can utilize.

493
00:24:45,350 --> 00:24:47,370
They can click through those components

494
00:24:47,370 --> 00:24:49,011
and they get exposed to some options

495
00:24:49,011 --> 00:24:52,592
that allow them to tailor how that component might be built.

496
00:24:52,592 --> 00:24:54,832
And we're gonna focus on a component

497
00:24:54,832 --> 00:24:57,093
called the tail simulation component.

498
00:24:57,947 --> 00:25:01,290
And the idea here is simply that the component

499
00:25:01,290 --> 00:25:03,551
builds a kind of a hybrid rig

500
00:25:03,551 --> 00:25:05,333
that sits on top of our reference rig.

501
00:25:05,333 --> 00:25:07,314
It inherits the motion of the reference rig,

502
00:25:07,314 --> 00:25:08,315
but then drives it.

503
00:25:08,315 --> 00:25:11,457
This allows the animator to keep interacting

504
00:25:11,457 --> 00:25:14,079
with the tail in a normal way, a stable way.

505
00:25:14,079 --> 00:25:16,921
But ultimately when they hit play,

506
00:25:16,921 --> 00:25:18,002
the simulation kicks in,

507
00:25:18,002 --> 00:25:19,843
and the simulation is always striving

508
00:25:19,843 --> 00:25:23,026
to achieve the poses defined by the animator.

509
00:25:24,573 --> 00:25:26,693
But a component is more than just a rig.

510
00:25:26,693 --> 00:25:28,774
It's kind of a package for the animator

511
00:25:28,774 --> 00:25:29,734
to work in a specific way.

512
00:25:29,734 --> 00:25:33,635
So it also includes tools that are specific

513
00:25:33,635 --> 00:25:35,136
to that component.

514
00:25:35,136 --> 00:25:37,016
So here we've got a really simple tool,

515
00:25:37,016 --> 00:25:39,237
a tool that just allows the animator

516
00:25:39,237 --> 00:25:41,737
to add or remove collision objects.

517
00:25:41,737 --> 00:25:44,358
So they can do that through the Maya menus,

518
00:25:44,358 --> 00:25:47,339
but it means that they don't have to jump through

519
00:25:47,339 --> 00:25:50,359
five or six nested menus across a whole bunch

520
00:25:50,359 --> 00:25:53,580
of dynamics things that they don't go through very often.

521
00:25:55,012 --> 00:25:57,113
But they can also be a little bit more complex.

522
00:25:57,113 --> 00:26:00,553
So here we've got a tool where at any point in time,

523
00:26:00,553 --> 00:26:02,854
they can choose to make a visual bookmark

524
00:26:02,854 --> 00:26:04,514
of their simulation.

525
00:26:04,514 --> 00:26:06,335
They can go back and start tuning

526
00:26:06,335 --> 00:26:08,775
their simulation attributes.

527
00:26:08,775 --> 00:26:10,976
And at any time, they can then compare the results

528
00:26:10,976 --> 00:26:15,276
of their current changes against one of their snapshots.

529
00:26:15,276 --> 00:26:17,077
And if they don't like those changes,

530
00:26:17,077 --> 00:26:19,237
they can simply restore those settings back

531
00:26:19,237 --> 00:26:21,578
and go again from where they left off.

532
00:26:22,976 --> 00:26:26,097
And then at any point, they can simply choose to remove

533
00:26:26,097 --> 00:26:27,857
and bake down the component.

534
00:26:27,857 --> 00:26:30,417
That then bakes it down onto an additive animation layer,

535
00:26:30,417 --> 00:26:33,338
allowing them to blend the results in and out,

536
00:26:33,338 --> 00:26:36,339
even after the component is gone.

537
00:26:36,339 --> 00:26:38,259
Now, the specifics of those small tools

538
00:26:38,259 --> 00:26:40,799
aren't the focus of the talk,

539
00:26:40,799 --> 00:26:43,240
but it's important to recognize

540
00:26:43,240 --> 00:26:45,480
that a component isn't just the rig, right?

541
00:26:45,480 --> 00:26:48,541
It's the whole package, so the animator can work

542
00:26:48,541 --> 00:26:50,461
in a specific way for the task

543
00:26:50,461 --> 00:26:51,982
that they are trying to achieve.

544
00:26:54,064 --> 00:26:56,225
And this whole thing uses the design pattern.

545
00:26:56,225 --> 00:26:59,067
So the abstract looks a bit like this,

546
00:26:59,067 --> 00:27:02,189
where we have an apply method, we have a remove method,

547
00:27:02,189 --> 00:27:04,530
both of which pretty much do what you'd expect.

548
00:27:04,530 --> 00:27:07,591
And then we have a build UI and a runtime UI.

549
00:27:07,591 --> 00:27:10,133
So we can interact with this tool

550
00:27:10,133 --> 00:27:11,273
either through code directly

551
00:27:11,273 --> 00:27:13,375
or we can go through the interface.

552
00:27:14,088 --> 00:27:16,469
But we don't want our tool itself

553
00:27:16,469 --> 00:27:18,130
to have any direct understanding

554
00:27:18,130 --> 00:27:19,671
of any particular component.

555
00:27:19,671 --> 00:27:23,772
So when an animator selects a component from the list,

556
00:27:23,772 --> 00:27:26,834
we simply instance a plugin,

557
00:27:26,834 --> 00:27:29,575
and we ask the plugin for its build UI or its runtime UI.

558
00:27:29,575 --> 00:27:33,396
And the tool then embeds that blindly

559
00:27:33,396 --> 00:27:34,917
into the window itself.

560
00:27:35,847 --> 00:27:39,009
and we harness the keyword arguments that we saw earlier.

561
00:27:39,009 --> 00:27:42,831
So we expect or we ask that any QWidget that's given to us

562
00:27:42,831 --> 00:27:46,794
can serialize its state down to a dictionary.

563
00:27:46,794 --> 00:27:50,296
We can then pass that into the build method,

564
00:27:50,296 --> 00:27:52,478
or sorry, the apply method of the plugin,

565
00:27:52,478 --> 00:27:54,639
and suddenly we can build these components

566
00:27:54,639 --> 00:27:56,601
either through the UI or through code

567
00:27:56,601 --> 00:27:57,581
in exactly the same way.

568
00:27:59,469 --> 00:28:03,855
And as I mentioned before, this component is a way of working,

569
00:28:03,855 --> 00:28:05,718
so it's not just the rig.

570
00:28:05,718 --> 00:28:07,781
It's also a suite of tools to help the animator.

571
00:28:09,094 --> 00:28:12,896
And this moves us from trying to write the simulation tool

572
00:28:12,896 --> 00:28:15,618
that can work on every rig in every possible context

573
00:28:15,618 --> 00:28:19,941
with a million options that an animator might rarely use,

574
00:28:19,941 --> 00:28:21,361
and instead start focusing.

575
00:28:21,361 --> 00:28:24,243
If we're building a tail simulation component,

576
00:28:24,243 --> 00:28:26,705
we're pretty sure that the animator's

577
00:28:26,705 --> 00:28:28,446
trying to animate a tail.

578
00:28:28,446 --> 00:28:29,807
If they're trying to animate a chain,

579
00:28:29,807 --> 00:28:32,208
then maybe it's better that we have a chain component.

580
00:28:33,389 --> 00:28:36,072
And this means that our dev times for making tools

581
00:28:36,072 --> 00:28:40,177
starts to reduce because we can make so many more assumptions.

582
00:28:40,177 --> 00:28:42,980
But equally for the animator, their workflow

583
00:28:42,980 --> 00:28:45,003
improves as well because they're only

584
00:28:45,003 --> 00:28:47,706
seeing options that are specific to what it

585
00:28:47,706 --> 00:28:48,727
is they're trying to achieve.

586
00:28:50,127 --> 00:28:52,848
And the mechanism behind this is just the same as a build UI.

587
00:28:52,848 --> 00:28:59,752
We simply ask the plugin for the component for its runtime UI,

588
00:28:59,752 --> 00:29:04,574
and we blindly chuck that QWidget into the QWindow.

589
00:29:04,574 --> 00:29:07,055
So we don't ever have to hard code anything

590
00:29:07,055 --> 00:29:08,396
into the tool itself.

591
00:29:08,396 --> 00:29:09,096
But it comes with a flaw.

592
00:29:09,096 --> 00:29:13,238
There's a huge hole in this whole thing.

593
00:29:13,238 --> 00:29:18,000
An animator could choose to apply the tail simulation

594
00:29:18,000 --> 00:29:19,081
rig in this scene.

595
00:29:20,711 --> 00:29:22,033
and they can work and they can animate

596
00:29:22,033 --> 00:29:24,016
and they can use the tools and they'll be happy,

597
00:29:24,016 --> 00:29:25,959
hopefully, if we've done our job right,

598
00:29:25,959 --> 00:29:26,840
which isn't always.

599
00:29:27,815 --> 00:29:31,377
And then maybe one of our TAs comes to GDC or a conference

600
00:29:31,377 --> 00:29:34,238
and they find a new way of doing tail simulation,

601
00:29:34,238 --> 00:29:36,438
a way that's just far more efficient.

602
00:29:36,438 --> 00:29:40,180
They come back excited and they update that component.

603
00:29:40,180 --> 00:29:43,221
They change the code and the rigging code

604
00:29:43,221 --> 00:29:45,321
and they update the tools so that the tools work

605
00:29:45,321 --> 00:29:47,082
with that new component.

606
00:29:47,082 --> 00:29:48,282
And the animators start using that

607
00:29:48,282 --> 00:29:49,263
and they're really happy

608
00:29:49,263 --> 00:29:51,263
because the frame rates are going through the roof.

609
00:29:52,117 --> 00:29:54,337
and then an animator opens up their old scene.

610
00:29:54,337 --> 00:29:58,159
And the rig still works because the rig's local to the scene,

611
00:29:58,159 --> 00:30:00,280
so everything's all good there.

612
00:30:00,280 --> 00:30:04,421
But as soon as they try to use the tools, they break,

613
00:30:04,421 --> 00:30:06,302
because the tools have now been refactored

614
00:30:06,302 --> 00:30:09,223
to use the new version of the rig.

615
00:30:09,926 --> 00:30:12,749
And this leads to a scenario where either our tools

616
00:30:12,749 --> 00:30:16,494
have to start working in a way where they're coded

617
00:30:16,494 --> 00:30:19,978
with backwards compatibility for all possible variations

618
00:30:19,978 --> 00:30:22,461
of the rig, or we have to start batching over

619
00:30:22,461 --> 00:30:25,484
all of our scenes constantly, keeping all the versions

620
00:30:25,484 --> 00:30:28,307
of our rigs up to the latest version.

621
00:30:29,355 --> 00:30:32,037
Ultimately, both of these mean that we actually gain

622
00:30:32,037 --> 00:30:35,660
absolutely nothing from this design pattern.

623
00:30:35,660 --> 00:30:39,322
But the solution turned out to be pretty simple.

624
00:30:39,322 --> 00:30:43,265
All we needed to do was add a version number

625
00:30:43,265 --> 00:30:44,746
to each component.

626
00:30:44,746 --> 00:30:47,127
And by doing this, we could have multiple

627
00:30:47,127 --> 00:30:51,230
tail simulation component plugins,

628
00:30:51,230 --> 00:30:53,792
and they can be differentiated only by a version number.

629
00:30:54,746 --> 00:30:56,687
This means that when an animator would choose

630
00:30:56,687 --> 00:30:58,568
to apply the component to their rig,

631
00:30:58,568 --> 00:31:02,151
we simply scrape the factory and take the highest version

632
00:31:02,151 --> 00:31:04,752
of this particular component.

633
00:31:04,752 --> 00:31:06,634
But when we open a scene,

634
00:31:06,634 --> 00:31:09,075
we look at the version of that component in the scene

635
00:31:09,075 --> 00:31:13,098
and we instance the plugin specific to that version.

636
00:31:13,098 --> 00:31:15,419
What this means is we pay a cost of code replication.

637
00:31:15,419 --> 00:31:19,462
We could have 10 versions of the tail simulation component

638
00:31:19,462 --> 00:31:21,923
and each one may only really change a little bit.

639
00:31:23,113 --> 00:31:25,714
But what it gives us is we're not constrained

640
00:31:25,714 --> 00:31:29,055
by the choices we made yesterday or last week.

641
00:31:29,055 --> 00:31:32,696
When we come with a new idea for tail simulation,

642
00:31:32,696 --> 00:31:36,237
we're writing our tools specific to that rig.

643
00:31:36,237 --> 00:31:37,718
We don't have to make our tools work

644
00:31:37,718 --> 00:31:40,739
with the way the last version worked.

645
00:31:40,739 --> 00:31:44,200
We can start to experiment in a very free way

646
00:31:44,200 --> 00:31:45,760
and know that we're not gonna break

647
00:31:45,760 --> 00:31:47,401
the rig that was built three years ago.

648
00:31:51,145 --> 00:31:53,286
And that brings us back to this slide,

649
00:31:53,286 --> 00:31:56,908
where we can strive to make our tools work

650
00:31:56,908 --> 00:31:58,949
with all the different versions of our rig

651
00:31:58,949 --> 00:32:00,610
that might be in production.

652
00:32:00,610 --> 00:32:03,672
And our tools become increasingly monolithic,

653
00:32:03,672 --> 00:32:06,853
the complexity grows, and eventually at some point

654
00:32:06,853 --> 00:32:09,755
the whole lot goes in the bin and we start again.

655
00:32:09,755 --> 00:32:12,116
Instead, we encapsulate it.

656
00:32:12,327 --> 00:32:16,187
We break it down, we accept the cost of code replication,

657
00:32:16,187 --> 00:32:18,688
but ultimately when it comes to wanting to implement

658
00:32:18,688 --> 00:32:20,628
the new version of a component,

659
00:32:20,628 --> 00:32:24,549
our mindset is purely on that implementation.

660
00:32:24,549 --> 00:32:27,029
It's not on the refactoring or the risk

661
00:32:27,029 --> 00:32:28,870
or the concerns around it.

662
00:32:28,870 --> 00:32:32,751
When it comes to asking for time to implement something,

663
00:32:32,751 --> 00:32:35,411
we don't have to take a really fuzzy guess

664
00:32:35,411 --> 00:32:37,912
at what the tech debt will be if we screw up.

665
00:32:39,095 --> 00:32:40,155
And that does happen, right?

666
00:32:40,155 --> 00:32:42,875
We all take risks, we all strive to push forwards,

667
00:32:42,875 --> 00:32:45,636
and that inevitably means that we get things wrong.

668
00:32:45,636 --> 00:32:47,636
And ultimately, the animator gets

669
00:32:47,636 --> 00:32:51,877
a far more focused workflow than just a generic rig

670
00:32:51,877 --> 00:32:54,638
that's trying to do everything for everyone

671
00:32:54,638 --> 00:32:55,518
in all circumstances.

672
00:32:55,518 --> 00:32:58,119
And this was incredibly freeing for us,

673
00:32:58,119 --> 00:33:03,340
but that freedom started to demonstrate

674
00:33:03,340 --> 00:33:06,220
restrictiveness elsewhere in our pipeline.

675
00:33:07,002 --> 00:33:08,823
specifically around metadata.

676
00:33:08,823 --> 00:33:13,066
So metadata is the glue between our rigs and our tools,

677
00:33:13,066 --> 00:33:18,270
and David Hunt did an awesome talk way back in 2009.

678
00:33:18,270 --> 00:33:21,833
But to briefly recap, metadata is a mechanism

679
00:33:21,833 --> 00:33:24,095
that means we, or our tools,

680
00:33:24,095 --> 00:33:25,896
don't have to read naming conventions,

681
00:33:25,896 --> 00:33:27,897
or they don't have to read hierarchy structures

682
00:33:27,897 --> 00:33:29,198
within our rig.

683
00:33:29,198 --> 00:33:32,621
Instead, perhaps we use network nodes and message attributes

684
00:33:32,621 --> 00:33:33,942
or string attribute data.

685
00:33:35,551 --> 00:33:38,052
But it comes with a bit of a flaw.

686
00:33:38,052 --> 00:33:42,553
Ultimately, our metadata lives inside our rigs.

687
00:33:42,553 --> 00:33:45,754
And our tools traverse this metadata.

688
00:33:45,754 --> 00:33:47,295
Whether they do that directly

689
00:33:47,295 --> 00:33:48,975
or whether they do that through a module,

690
00:33:48,975 --> 00:33:52,016
they're ultimately directly dependent

691
00:33:52,016 --> 00:33:54,197
on that particular metadata structure.

692
00:33:56,554 --> 00:33:59,598
This means that it's really hard to experiment

693
00:33:59,598 --> 00:34:03,403
or try new things in terms of metadata mechanisms.

694
00:34:03,403 --> 00:34:06,587
Or if we want to use rigs outside of our studio,

695
00:34:06,587 --> 00:34:09,491
but with our tools, it can be incredibly challenging,

696
00:34:09,491 --> 00:34:11,634
especially if those rigs come pre-bound

697
00:34:11,634 --> 00:34:14,137
with their own metadata structure attached to them.

698
00:34:14,980 --> 00:34:18,062
And in a studio where we have six projects all running

699
00:34:18,062 --> 00:34:20,904
and we have multiple tech art teams going

700
00:34:20,904 --> 00:34:24,707
and working on those, we inevitably get divergence.

701
00:34:24,707 --> 00:34:27,288
Everyone wants to push boundaries.

702
00:34:27,288 --> 00:34:30,431
And so we have two metadata systems at CA

703
00:34:30,431 --> 00:34:34,933
that are currently in play within one or two productions.

704
00:34:34,933 --> 00:34:39,857
We've got one around messaging attributes and network nodes,

705
00:34:39,857 --> 00:34:42,078
and we've got one using string markup data.

706
00:34:43,243 --> 00:34:45,846
So having the ability to interact with

707
00:34:45,846 --> 00:34:49,471
either of these mechanisms would be hugely beneficial.

708
00:34:49,471 --> 00:34:51,894
And when it's visualized in this way,

709
00:34:51,894 --> 00:34:55,058
it starts to feel like a good fit for the design pattern.

710
00:34:55,058 --> 00:34:58,883
So using that factory plug-in approach,

711
00:34:58,883 --> 00:34:59,924
that's what we did.

712
00:35:00,590 --> 00:35:04,253
Now, defining an abstract for a metadata system

713
00:35:04,253 --> 00:35:06,855
is a lot trickier than trying to define an abstract

714
00:35:06,855 --> 00:35:08,757
for a rigging tool or an exporter.

715
00:35:08,757 --> 00:35:11,699
But the principle is the same.

716
00:35:11,699 --> 00:35:15,802
Our abstract essentially becomes an API for rigs.

717
00:35:15,802 --> 00:35:18,444
And ultimately, the plugin is then responsible

718
00:35:18,444 --> 00:35:22,387
for mapping that particular metadata system to this API.

719
00:35:24,476 --> 00:35:27,077
For us at CA, the key needs of metadata

720
00:35:27,077 --> 00:35:29,859
is pretty much about being able to do big searches

721
00:35:29,859 --> 00:35:31,620
and relationship searches.

722
00:35:31,620 --> 00:35:34,341
So I wanna know all the controls in a rig,

723
00:35:34,341 --> 00:35:36,422
or I wanna know all the deformers,

724
00:35:36,422 --> 00:35:37,563
or something more specific,

725
00:35:37,563 --> 00:35:40,845
like I want the left IK hand control,

726
00:35:40,845 --> 00:35:42,606
as well as relationship information.

727
00:35:42,606 --> 00:35:45,787
So if I've got a left control, I want the opposing object,

728
00:35:45,787 --> 00:35:49,309
or what am I being affected by, or what am I affecting?

729
00:35:50,254 --> 00:35:53,156
So our abstract for our rigs looks like this.

730
00:35:53,156 --> 00:35:56,298
We have functions that are related to tagging

731
00:35:56,298 --> 00:35:57,879
and to querying.

732
00:35:57,879 --> 00:36:02,182
And we have functions that give us relationship information.

733
00:36:02,182 --> 00:36:05,765
And ultimately, we leave it to the plugin implementations

734
00:36:05,765 --> 00:36:08,447
to map the specifics of their metadata system to this API.

735
00:36:08,447 --> 00:36:10,569
We then add one more function.

736
00:36:13,880 --> 00:36:17,745
We add the viable function, because we don't want our tools

737
00:36:17,745 --> 00:36:20,009
to know what rig it's got to interact with.

738
00:36:21,635 --> 00:36:26,098
And the idea behind a viable function is very similar to what we've seen before.

739
00:36:26,098 --> 00:36:33,904
So we take in an object and then we ask that plugin whether that plugin can represent that

740
00:36:33,904 --> 00:36:34,625
object.

741
00:36:34,625 --> 00:36:41,651
So if we're dealing with a network node metadata system, maybe we'll look at the top root node

742
00:36:41,651 --> 00:36:44,973
and we'll quickly check whether there's a meta node attached to it.

743
00:36:45,374 --> 00:36:47,995
or we'll look for a string markup data.

744
00:36:47,995 --> 00:36:50,757
And the first plugin that returns true on its viability test

745
00:36:50,757 --> 00:36:53,978
is instanced and returned.

746
00:36:53,978 --> 00:36:55,439
So when we take that concept

747
00:36:55,439 --> 00:36:58,621
and we wrap it in a tiny little function that we call grab,

748
00:36:58,621 --> 00:37:01,843
we can start to get a rig API from a tool

749
00:37:01,843 --> 00:37:04,865
without really knowing or caring

750
00:37:04,865 --> 00:37:06,766
which particular metadata system

751
00:37:06,766 --> 00:37:07,886
we're actually interacting with.

752
00:37:08,807 --> 00:37:11,809
So here we're just going through every plugin in our factory

753
00:37:11,809 --> 00:37:15,813
and we're asking that plugin whether it can represent

754
00:37:15,813 --> 00:37:17,334
this rig node.

755
00:37:17,334 --> 00:37:19,476
If it can, it's instance and it's returned to us.

756
00:37:19,476 --> 00:37:22,739
And that gives us something that looks like this.

757
00:37:23,974 --> 00:37:25,055
So here we've got three rigs.

758
00:37:25,055 --> 00:37:27,176
We've got a CA production rig,

759
00:37:27,176 --> 00:37:29,577
and we've got two rigs that we took from high-end 3D.

760
00:37:29,577 --> 00:37:31,919
And all of them are vastly different, right?

761
00:37:31,919 --> 00:37:33,700
They have different naming conventions,

762
00:37:33,700 --> 00:37:36,682
different structures, different metadata.

763
00:37:36,682 --> 00:37:40,584
And we implemented a plugin to represent each rig type.

764
00:37:40,584 --> 00:37:43,265
This means that we don't really have to care

765
00:37:43,265 --> 00:37:45,086
about which rig we're interacting with.

766
00:37:45,086 --> 00:37:48,168
So we call our grab method with whatever's selected.

767
00:37:48,760 --> 00:37:51,662
We then wrap that into a select command,

768
00:37:51,662 --> 00:37:54,724
and we ask it for all the controls in the rig.

769
00:37:54,724 --> 00:37:57,266
And immediately we get a select all control script

770
00:37:57,266 --> 00:37:58,907
that's rig agnostic.

771
00:37:58,907 --> 00:38:00,888
We can use that same bit of code,

772
00:38:00,888 --> 00:38:02,949
regardless of the rig that we're operating on.

773
00:38:02,949 --> 00:38:06,231
And we can take it a little bit further.

774
00:38:06,231 --> 00:38:09,913
So we can look at all the objects that we've got selected,

775
00:38:09,913 --> 00:38:12,595
and for each one, we can ask the rig API

776
00:38:12,595 --> 00:38:13,636
for its opposing object.

777
00:38:15,119 --> 00:38:18,161
We then wrap that in a select call,

778
00:38:18,161 --> 00:38:20,222
and we get a select opposite script

779
00:38:20,222 --> 00:38:23,384
that's working on all three rigs independently.

780
00:38:23,384 --> 00:38:25,726
Then the crucial part here is in the scripts

781
00:38:25,726 --> 00:38:29,348
where we're writing, we're never making any kind

782
00:38:29,348 --> 00:38:31,389
of assumption as to the rig we're working on.

783
00:38:31,389 --> 00:38:35,492
We let the framework or the system work that out for us,

784
00:38:35,492 --> 00:38:38,313
and ultimately the system is letting each plug-in

785
00:38:38,313 --> 00:38:39,254
make that decision.

786
00:38:41,013 --> 00:38:43,835
And we can bring that back to the context of an exporter.

787
00:38:43,835 --> 00:38:48,337
So we have a very generic exporter that's plugin-based.

788
00:38:48,337 --> 00:38:50,539
And then we have a rig API where we can say,

789
00:38:50,539 --> 00:38:52,160
hey, give me all the deformers,

790
00:38:52,160 --> 00:38:53,000
and I'll pass that to the exporter.

791
00:38:53,000 --> 00:38:54,221
And suddenly we can start to export data

792
00:38:54,221 --> 00:38:55,282
from rigs that we don't control.

793
00:38:55,282 --> 00:38:56,543
That allows us to chuck in rigs into our pipeline

794
00:38:56,543 --> 00:38:57,643
from lots of different places,

795
00:38:57,643 --> 00:38:58,924
or experiment with lots of different things.

796
00:39:11,350 --> 00:39:14,352
But it's really worth pointing out that writing a plugin

797
00:39:14,352 --> 00:39:17,214
for a metadata system isn't particularly trivial.

798
00:39:17,214 --> 00:39:19,756
Depending on what that metadata system looks like

799
00:39:19,756 --> 00:39:23,178
and how it works, it can be really involved.

800
00:39:23,178 --> 00:39:25,860
But ultimately, the cost of implementing a plugin

801
00:39:25,860 --> 00:39:29,482
around a metadata system is significantly less

802
00:39:29,482 --> 00:39:31,904
than trying to get all your tools to work

803
00:39:31,904 --> 00:39:33,565
with all the different metadata systems

804
00:39:33,565 --> 00:39:35,387
that you might have in play.

805
00:39:35,387 --> 00:39:38,789
And there's an interesting side benefit to all of this.

806
00:39:39,815 --> 00:39:43,657
The abstracts and the factories are super generic,

807
00:39:43,657 --> 00:39:46,939
so they never really contain any code specific to Max

808
00:39:46,939 --> 00:39:49,321
or code specific to Maya or MotionBuilder.

809
00:39:49,321 --> 00:39:52,082
So to take this whole system

810
00:39:52,082 --> 00:39:53,984
and push it into a different application

811
00:39:53,984 --> 00:39:57,006
is really just the cost of implementing a new plugin.

812
00:39:57,006 --> 00:39:59,047
So that's what we did.

813
00:39:59,047 --> 00:39:59,887
So we took our

814
00:40:00,999 --> 00:40:03,280
our framework and we started using it in Maya

815
00:40:03,280 --> 00:40:05,640
and we've got a script here where we're just dumping out

816
00:40:05,640 --> 00:40:08,001
a bunch of information through the rig API.

817
00:40:08,001 --> 00:40:09,401
So we're asking for sockets,

818
00:40:09,401 --> 00:40:12,542
we're asking I think for meshes or some deformers,

819
00:40:12,542 --> 00:40:16,303
and then we're sending this scene over to MotionBuilder.

820
00:40:16,303 --> 00:40:19,524
And in MotionBuilder, we've got exactly the same code.

821
00:40:19,524 --> 00:40:21,845
So we're importing our rig API,

822
00:40:21,845 --> 00:40:23,345
we're grabbing those objects.

823
00:40:24,294 --> 00:40:27,256
And ultimately, we get exactly the same output.

824
00:40:27,256 --> 00:40:29,738
So we're then jumping between two different applications,

825
00:40:29,738 --> 00:40:31,200
but we're interacting with our rigs

826
00:40:31,200 --> 00:40:33,361
in exactly the same way.

827
00:40:33,361 --> 00:40:36,344
And the only cost of this is the implementation

828
00:40:36,344 --> 00:40:39,526
of a plugin that's specific to that application.

829
00:40:39,526 --> 00:40:42,829
This means we can start to build things

830
00:40:42,829 --> 00:40:46,332
in different applications and not have to worry

831
00:40:46,332 --> 00:40:48,653
about how we're gonna find our objects.

832
00:40:50,096 --> 00:40:53,582
Which brings us again here, where through representing

833
00:40:53,582 --> 00:40:56,066
our metadata systems through plugins,

834
00:40:56,066 --> 00:40:58,329
we're adding flexibility into our pipeline.

835
00:40:58,329 --> 00:41:01,174
Everything becomes a bit more forward facing.

836
00:41:01,174 --> 00:41:04,659
We're not tied into a specific metadata system.

837
00:41:05,380 --> 00:41:09,302
We could choose to make our tools work with the two metadata systems that we have in play,

838
00:41:09,302 --> 00:41:15,646
and that would work for today, but it wouldn't necessarily work for tomorrow when someone

839
00:41:15,646 --> 00:41:19,248
else comes up with a better way of dealing with metadata systems.

840
00:41:19,248 --> 00:41:26,592
And ultimately, our tools don't become the bottleneck for us experimenting.

841
00:41:26,592 --> 00:41:34,436
What becomes interesting is suddenly our metadata system and our rigging tool and our exporter

842
00:41:35,264 --> 00:41:37,065
all look the same.

843
00:41:37,065 --> 00:41:39,126
Their code structure looks the same.

844
00:41:39,126 --> 00:41:42,867
And so when we go in to do code reviews,

845
00:41:42,867 --> 00:41:47,069
the overhead of doing a review is really low.

846
00:41:47,069 --> 00:41:48,910
We're not trying to get our heads around

847
00:41:48,910 --> 00:41:51,971
how this person has implemented this system

848
00:41:51,971 --> 00:41:54,212
because the system's kind of the same.

849
00:41:54,212 --> 00:41:56,133
We're immediately looking at the detail

850
00:41:56,133 --> 00:41:57,314
and the implementation.

851
00:41:57,314 --> 00:42:01,295
The focus is fundamentally always on the functionality

852
00:42:01,295 --> 00:42:02,876
and not the framework itself.

853
00:42:05,061 --> 00:42:08,422
So we've seen animation and rigging examples,

854
00:42:08,422 --> 00:42:12,183
but the whole concept is a lot more flexible than that.

855
00:42:12,183 --> 00:42:16,965
So I mentioned before that we used this kind of informally

856
00:42:16,965 --> 00:42:19,186
in our animation asset manager on Halo Wars 2.

857
00:42:19,186 --> 00:42:22,547
So that took the concepts of an asset

858
00:42:22,547 --> 00:42:26,308
and it abstracted it away from the asset system itself.

859
00:42:26,308 --> 00:42:30,830
So that had functions like get me the dependencies,

860
00:42:30,830 --> 00:42:33,231
get me metadata, get me icons, et cetera.

861
00:42:34,775 --> 00:42:38,097
And ultimately, the framework would search through

862
00:42:38,097 --> 00:42:39,918
files and folders for files,

863
00:42:39,918 --> 00:42:43,100
sorry, search through folders for files,

864
00:42:43,100 --> 00:42:46,523
and it would pass those file paths into each plugin,

865
00:42:46,523 --> 00:42:48,544
and the first plugin that would say,

866
00:42:48,544 --> 00:42:51,086
hey, you know what, I know how to represent this asset,

867
00:42:51,086 --> 00:42:54,588
that would be instanced, and the framework,

868
00:42:54,588 --> 00:42:57,410
the asset system itself, would start calling

869
00:42:57,410 --> 00:43:01,713
the methods of that plugin to populate a database.

870
00:43:02,832 --> 00:43:06,715
This meant that we could have Maya scenes

871
00:43:06,715 --> 00:43:09,638
or Max scenes or textures,

872
00:43:09,638 --> 00:43:11,500
and the plugins would know how to read the metadata

873
00:43:11,500 --> 00:43:12,741
relating to each one,

874
00:43:12,741 --> 00:43:15,024
and our asset system wouldn't ever have to care.

875
00:43:15,024 --> 00:43:18,147
That gives us something like this.

876
00:43:18,147 --> 00:43:22,031
So we can dynamically infer the asset type filter,

877
00:43:22,031 --> 00:43:24,973
because we can just ask the factory

878
00:43:24,973 --> 00:43:26,295
for what plugins there are.

879
00:43:27,348 --> 00:43:30,471
We then query our database and we get a list of the assets

880
00:43:30,471 --> 00:43:33,093
that are in there, and we can start to interact

881
00:43:33,093 --> 00:43:34,675
with those assets.

882
00:43:34,675 --> 00:43:36,737
But when we're right-clicking one of these,

883
00:43:36,737 --> 00:43:41,101
the asset system doesn't know what actions are available.

884
00:43:41,101 --> 00:43:44,143
We simply do another validity check.

885
00:43:45,004 --> 00:43:48,829
And we ask that plugin for its action list.

886
00:43:48,829 --> 00:43:52,214
And we generate a context menu based on that.

887
00:43:52,214 --> 00:43:54,878
So if you right-click a rig, then you

888
00:43:54,878 --> 00:43:57,621
might get options like reference it or edit it.

889
00:43:57,621 --> 00:43:59,384
But if you right-click a texture,

890
00:43:59,384 --> 00:44:00,405
you might just get apply.

891
00:44:03,092 --> 00:44:07,093
But the system itself still had hard-coded code

892
00:44:07,093 --> 00:44:09,194
based on how to find an asset.

893
00:44:09,194 --> 00:44:10,634
Ultimately, on Halo Wars 2,

894
00:44:10,634 --> 00:44:13,275
all of our assets were on our local hard drive.

895
00:44:13,275 --> 00:44:16,775
So it was hard-coded to search for Maya files

896
00:44:16,775 --> 00:44:19,556
or Max files in specific locations.

897
00:44:19,556 --> 00:44:21,757
And whilst that wasn't bad

898
00:44:21,757 --> 00:44:25,457
because that adhered to the restrictions of the project,

899
00:44:25,457 --> 00:44:26,898
it limited the scope of the tool.

900
00:44:26,898 --> 00:44:29,838
And we wanted to break away from that limitation.

901
00:44:31,387 --> 00:44:32,748
So we added a second factory.

902
00:44:32,748 --> 00:44:36,349
This time the responsibility of that factory

903
00:44:36,349 --> 00:44:39,390
was to hold plugins relating to search mechanisms.

904
00:44:39,390 --> 00:44:44,032
So we then added a plugin for local folder searches

905
00:44:44,032 --> 00:44:47,374
and we moved the code that was in the asset system itself

906
00:44:47,374 --> 00:44:48,054
into that plugin.

907
00:44:48,054 --> 00:44:51,255
This meant the whole thing worked in exactly the same way,

908
00:44:51,255 --> 00:44:53,236
the result was identical,

909
00:44:53,236 --> 00:44:55,677
but our asset system was a lot lighter.

910
00:44:55,677 --> 00:44:58,478
And this opened up some interesting doors

911
00:44:58,478 --> 00:44:59,638
for experimentation.

912
00:45:01,537 --> 00:45:03,498
So for the sake of proving that flexibility

913
00:45:03,498 --> 00:45:06,621
and having a soft spot for dinosaurs,

914
00:45:06,621 --> 00:45:08,963
we implemented a second plugin.

915
00:45:08,963 --> 00:45:14,148
This time, the plugin would only return its viability test

916
00:45:14,148 --> 00:45:16,971
if the path it was given was a URL

917
00:45:16,971 --> 00:45:20,114
to a website called paleobio.org,

918
00:45:20,114 --> 00:45:23,096
which is all about taxonomy information on dinosaurs.

919
00:45:24,358 --> 00:45:26,838
And ultimately, we're no longer scraping files on a disk,

920
00:45:26,838 --> 00:45:29,239
but we're calling a remote server

921
00:45:29,239 --> 00:45:31,259
and we're asking for information,

922
00:45:31,259 --> 00:45:34,219
and we implement a second asset plugin,

923
00:45:34,219 --> 00:45:36,740
which then will only return its viability

924
00:45:36,740 --> 00:45:39,580
if it gets JSON data from this REST API.

925
00:45:39,580 --> 00:45:43,981
Now we're not making a game about dinosaur taxonomy,

926
00:45:43,981 --> 00:45:46,162
so this was a complete waste of time,

927
00:45:46,162 --> 00:45:47,802
but it proved the system.

928
00:45:47,802 --> 00:45:50,082
And it meant that we could jump

929
00:45:50,082 --> 00:45:53,423
between two vastly different data types very, very quickly.

930
00:45:54,592 --> 00:45:57,916
So here we're browsing Warhammer 2 assets,

931
00:45:57,916 --> 00:46:00,940
and these were scraped from the local hard drive

932
00:46:00,940 --> 00:46:04,284
and pulled in, and the way we interact with those

933
00:46:04,284 --> 00:46:06,507
is to open or reference.

934
00:46:06,507 --> 00:46:08,749
But we can jump over to our options tab,

935
00:46:08,749 --> 00:46:10,812
and we can see that the file path,

936
00:46:10,812 --> 00:46:14,056
or the search routes for those, were a local hard disk.

937
00:46:15,108 --> 00:46:17,391
But if we switch over to our Paleo project,

938
00:46:17,391 --> 00:46:18,932
you'll see that the search route changes.

939
00:46:18,932 --> 00:46:23,216
So the search route is now a Paleo Bio REST API.

940
00:46:23,216 --> 00:46:26,900
So it's now actively searching the online resource

941
00:46:26,900 --> 00:46:28,501
and populating the database

942
00:46:28,501 --> 00:46:30,944
based on the taxonomy information.

943
00:46:30,944 --> 00:46:34,127
And the way we interact with those assets,

944
00:46:34,127 --> 00:46:36,789
because assets are just pieces of information,

945
00:46:36,789 --> 00:46:37,870
is drastically different.

946
00:46:38,611 --> 00:46:40,652
we get an open a Google Images search

947
00:46:40,652 --> 00:46:42,493
or open a taxonomy information.

948
00:46:42,493 --> 00:46:45,354
The key with this is you never tell a producer

949
00:46:45,354 --> 00:46:48,036
what you're doing because they'll never let you do

950
00:46:48,036 --> 00:46:49,316
and play with this stuff.

951
00:46:49,316 --> 00:46:50,017
But it was good.

952
00:46:50,017 --> 00:46:54,119
But the key is it ultimately proved that it works.

953
00:46:54,119 --> 00:46:57,180
And it doesn't take a great leap of imagination

954
00:46:57,180 --> 00:46:59,421
to see that the next use of this tool

955
00:46:59,421 --> 00:47:02,123
is probably for an animation motion library.

956
00:47:02,699 --> 00:47:04,861
where maybe we're looking at motion information

957
00:47:04,861 --> 00:47:07,583
that's on a network drive, that's on Perforce,

958
00:47:07,583 --> 00:47:11,266
that's on an FTP, and perhaps we're dealing with FBX files

959
00:47:11,266 --> 00:47:15,449
and BVH files, Atom files, as well as our internal formats.

960
00:47:15,449 --> 00:47:17,871
And ultimately, for the animator or for the user,

961
00:47:17,871 --> 00:47:19,612
they don't have to care.

962
00:47:19,612 --> 00:47:23,395
They can simply search for animations within this framework,

963
00:47:23,395 --> 00:47:26,858
they can right-click an animation and apply it,

964
00:47:26,858 --> 00:47:29,600
and it's up to us in a plugin to decide what happens

965
00:47:29,600 --> 00:47:30,981
when we choose to apply.

966
00:47:31,381 --> 00:47:33,203
that kind of file format.

967
00:47:33,203 --> 00:47:36,786
Which brings us here again to this familiar slide

968
00:47:36,786 --> 00:47:39,988
where when we implement an asset system,

969
00:47:39,988 --> 00:47:41,770
it's all too easy to think,

970
00:47:41,770 --> 00:47:46,093
well, our assets are Maya files and our assets are TGAs,

971
00:47:46,093 --> 00:47:49,196
so we'll just hard code that into our asset system.

972
00:47:49,196 --> 00:47:51,758
And that's what we've done so many times

973
00:47:51,758 --> 00:47:55,000
and we end up constantly having to refactor

974
00:47:55,000 --> 00:47:57,082
or rewrite for every single project.

975
00:47:58,437 --> 00:48:04,162
Instead, we push that into small little encapsulated blobs of plugins,

976
00:48:04,162 --> 00:48:07,544
and we let the plugins decide when they should be used.

977
00:48:07,544 --> 00:48:13,569
This ultimately means that we get massive amounts of reuse from our tools.

978
00:48:13,569 --> 00:48:16,431
They become a lot more flexible in what they can be used for.

979
00:48:17,155 --> 00:48:22,057
Our coding standards tend to improve because there's a lot of familiarity,

980
00:48:22,057 --> 00:48:25,038
I can never say that word,

981
00:48:25,038 --> 00:48:26,638
between all of our tools, right?

982
00:48:26,638 --> 00:48:29,460
When a TA comes on board,

983
00:48:29,460 --> 00:48:33,561
we only have to teach them or show them how one of our tools works

984
00:48:33,561 --> 00:48:36,202
and they pretty much know how all of our other tools work

985
00:48:36,202 --> 00:48:37,683
because there's so much consistency.

986
00:48:39,542 --> 00:48:42,184
Our TAs are far more collaborative now.

987
00:48:42,184 --> 00:48:44,907
I mean, they're a pretty social group anyway,

988
00:48:44,907 --> 00:48:47,990
but as soon as they can jump onto someone else's tool

989
00:48:47,990 --> 00:48:50,553
or library and not have to go through the pain

990
00:48:50,553 --> 00:48:52,655
of understanding how the system works,

991
00:48:52,655 --> 00:48:55,037
everything's a bit more fluid and dynamic.

992
00:48:55,037 --> 00:48:58,080
But ultimately, it means we can grow

993
00:48:58,080 --> 00:48:59,262
in a much more stable way.

994
00:49:01,209 --> 00:49:02,450
And this has been really good for us,

995
00:49:02,450 --> 00:49:03,650
it's been really effective,

996
00:49:03,650 --> 00:49:07,212
and it's now interspersed across a lot of our tools

997
00:49:07,212 --> 00:49:10,834
that cover Maya, Max, MotionBuilder, and Standalone.

998
00:49:10,834 --> 00:49:14,095
So it's been really, really powerful.

999
00:49:14,095 --> 00:49:18,217
It won't necessarily minimize the amount of code you write.

1000
00:49:18,217 --> 00:49:19,758
If anything, in certain situations,

1001
00:49:19,758 --> 00:49:21,239
as we saw with the rigging tool,

1002
00:49:21,239 --> 00:49:23,060
it actually means you write more code.

1003
00:49:23,060 --> 00:49:26,581
But it means you're being a lot more focused

1004
00:49:26,581 --> 00:49:29,563
and you're paying a lot less refactoring costs.

1005
00:49:30,159 --> 00:49:33,562
It also won't solve your project-specific problems,

1006
00:49:33,562 --> 00:49:35,203
but it does allow you to scale

1007
00:49:35,203 --> 00:49:37,385
without an ever-increasing amount of complexity.

1008
00:49:37,385 --> 00:49:41,629
It allows you to experiment and take risks

1009
00:49:41,629 --> 00:49:44,451
without incurring technical debt

1010
00:49:44,451 --> 00:49:45,652
that's an unknown quantity.

1011
00:49:47,322 --> 00:49:50,184
For us specifically, we gained the ability

1012
00:49:50,184 --> 00:49:53,687
to keep growing our tools without being restricted.

1013
00:49:53,687 --> 00:49:57,410
And as I mentioned, our TAs work far more collaboratively

1014
00:49:57,410 --> 00:50:00,593
because the overhead of diving onto someone else's tool

1015
00:50:00,593 --> 00:50:01,894
is significantly lower.

1016
00:50:03,163 --> 00:50:06,605
Generally, our dev and testing times start to diminish

1017
00:50:06,605 --> 00:50:09,407
because as soon as you know how the system works

1018
00:50:09,407 --> 00:50:12,428
and you've got a pattern of files and structure,

1019
00:50:12,428 --> 00:50:14,669
you dive straight into the functionality

1020
00:50:14,669 --> 00:50:17,310
and you're not whiteboarding architectural decisions

1021
00:50:17,310 --> 00:50:18,991
every other day.

1022
00:50:18,991 --> 00:50:21,332
But more important than all of that,

1023
00:50:21,332 --> 00:50:24,334
it means that you can experiment with ideas

1024
00:50:24,334 --> 00:50:26,675
when you don't know whether they're gonna pan out.

1025
00:50:26,675 --> 00:50:27,415
And when you're.

1026
00:50:28,172 --> 00:50:32,554
visiting GDC or other things like that, you know, you get inspired and you take risks

1027
00:50:32,554 --> 00:50:37,356
and you go back and you want to try things out, but not everything pans out the way you

1028
00:50:37,356 --> 00:50:40,297
want. So that's a really nice benefit.

1029
00:50:41,433 --> 00:50:43,374
But ultimately, tools and tech art

1030
00:50:43,374 --> 00:50:45,376
are not a self-serving group.

1031
00:50:45,376 --> 00:50:48,659
Our goal is to empower content creators.

1032
00:50:48,659 --> 00:50:53,422
But the two things shouldn't be thought of as being exclusive.

1033
00:50:53,422 --> 00:50:57,205
Because the freer we are to experiment and take risks,

1034
00:50:57,205 --> 00:51:00,948
the better the results are that our content creators get.

1035
00:51:00,948 --> 00:51:03,951
And it's worth pointing out that all of this

1036
00:51:03,951 --> 00:51:06,252
is the work of our entire tech art team.

1037
00:51:06,252 --> 00:51:07,113
Thank you.

1038
00:51:19,460 --> 00:51:23,086
And if anyone has any questions, feel free.

1039
00:51:23,086 --> 00:51:23,827
Hey, Christoph from Remedy.

1040
00:51:23,827 --> 00:51:24,548
Cool stuff.

1041
00:51:24,548 --> 00:51:31,379
We have kind of similar things happening at our company.

1042
00:51:32,623 --> 00:51:34,946
I do have one question.

1043
00:51:34,946 --> 00:51:37,910
You mentioned that you have to write a lot of boilerplate code,

1044
00:51:37,910 --> 00:51:42,856
which I assume you do, to support an IK plugin for MotionBuilder, Maya, Max, whatever.

1045
00:51:42,856 --> 00:51:47,802
Can you actually always guarantee that the IK will always behave the same,

1046
00:51:47,802 --> 00:51:50,946
or is that something you're willing to live without?

1047
00:51:51,599 --> 00:51:54,700
So the rigging code itself, we haven't ported over

1048
00:51:54,700 --> 00:51:56,580
to any other application than Maya.

1049
00:51:56,580 --> 00:52:01,762
So the rigging tool at the moment is specific to Maya.

1050
00:52:01,762 --> 00:52:01,982
Right.

1051
00:52:01,982 --> 00:52:04,282
So it's only metadata that you've ported.

1052
00:52:04,282 --> 00:52:07,403
Yeah, the only one that we've really pushed out

1053
00:52:07,403 --> 00:52:09,183
is the rigging API.

1054
00:52:09,183 --> 00:52:13,044
But yeah, that would be interesting to know.

1055
00:52:13,044 --> 00:52:16,305
We're trying to solve the same issue.

1056
00:52:16,305 --> 00:52:16,665
Thanks.

1057
00:52:16,665 --> 00:52:16,825
Cool.

1058
00:52:20,986 --> 00:52:21,498
Thank you.

