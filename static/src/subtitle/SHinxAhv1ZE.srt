1
00:00:05,360 --> 00:00:07,242
So, understanding constraints.

2
00:00:09,545 --> 00:00:12,388
So, I started my talk last year with a story about Legos,

3
00:00:12,848 --> 00:00:14,030
and people seemed to like that,

4
00:00:14,130 --> 00:00:16,172
so I'm going to start this year with another story.

5
00:00:17,393 --> 00:00:19,516
So, a long time ago, when I was a teenager,

6
00:00:20,056 --> 00:00:21,358
I fell in love with skateboarding.

7
00:00:22,399 --> 00:00:25,062
And I loved it so much that I built a skateboard ramp

8
00:00:25,683 --> 00:00:26,704
in the backyard of my home.

9
00:00:27,253 --> 00:00:29,535
in Ohio, and it looked a lot like this ramp.

10
00:00:30,175 --> 00:00:31,516
And this is called a halfpipe.

11
00:00:32,097 --> 00:00:33,918
So there's a flat bottom

12
00:00:34,418 --> 00:00:35,940
joined by two quarter circles.

13
00:00:39,723 --> 00:00:41,904
So back then, I used to get this magazine,

14
00:00:42,345 --> 00:00:44,306
a skateboarding magazine called Thrasher.

15
00:00:45,207 --> 00:00:46,268
And in that magazine,

16
00:00:47,168 --> 00:00:48,049
there was an article

17
00:00:49,030 --> 00:00:49,870
that said that

18
00:00:50,511 --> 00:00:52,152
you could build a skateboard ramp

19
00:00:52,192 --> 00:00:54,494
with a different shape than the regular halfpipe.

20
00:00:55,452 --> 00:00:57,914
that uses this cycloid shape,

21
00:00:58,714 --> 00:00:59,855
and that would be faster.

22
00:01:00,656 --> 00:01:03,178
And that's kind of like the optimal shape

23
00:01:03,218 --> 00:01:04,138
for a skateboard ramp.

24
00:01:05,419 --> 00:01:09,122
So a cycloid is defined this way.

25
00:01:09,222 --> 00:01:11,203
So if you have a rolling circle

26
00:01:11,423 --> 00:01:14,445
and you trace out a point on that circle as it rolls,

27
00:01:15,226 --> 00:01:17,788
that curve that it traces out, that's a cycloid.

28
00:01:19,249 --> 00:01:23,072
So back then I had no idea how this could be possible.

29
00:01:23,452 --> 00:01:25,654
How do they know that it's this cycloid shape?

30
00:01:26,254 --> 00:01:27,675
I didn't understand the mathematics.

31
00:01:31,498 --> 00:01:33,199
Later on when I was in grad school,

32
00:01:33,219 --> 00:01:35,461
I was studying an advanced topic called

33
00:01:35,501 --> 00:01:36,942
the calculus of variations.

34
00:01:38,643 --> 00:01:40,965
And in my book I found this problem

35
00:01:41,005 --> 00:01:42,906
called the brachistochrone problem.

36
00:01:43,606 --> 00:01:44,227
Try saying that.

37
00:01:46,489 --> 00:01:48,830
Anyhow, so in this problem.

38
00:01:54,434 --> 00:01:57,976
They described an optimization problem.

39
00:01:58,016 --> 00:02:01,777
So normally when you think of what the fastest way to get

40
00:02:01,817 --> 00:02:04,858
from point A to point B, you would say a straight line.

41
00:02:06,259 --> 00:02:09,720
But if you're going from some point A to some lower point B,

42
00:02:10,280 --> 00:02:14,482
just under the influence of gravity, then a straight line

43
00:02:14,542 --> 00:02:15,763
is not the fastest path.

44
00:02:16,063 --> 00:02:17,884
Actually, you need the path to dip down.

45
00:02:19,144 --> 00:02:19,224
And

46
00:02:20,009 --> 00:02:23,351
With the calculus of variations, you can actually derive that

47
00:02:23,371 --> 00:02:27,454
the cycloid is the fastest curve for a skateboard ramp.

48
00:02:28,996 --> 00:02:30,257
So, I thought this was amazing.

49
00:02:30,437 --> 00:02:35,321
You know, I finally understood what I'd read about so many years earlier in Thrasher Magazine.

50
00:02:36,542 --> 00:02:40,205
And, so, at this point I realized, you know,

51
00:02:40,745 --> 00:02:42,707
that mathematics can actually be very useful.

52
00:02:42,727 --> 00:02:47,891
But I also realized that just understanding the mathematics was kind of its own reward.

53
00:02:48,852 --> 00:02:50,673
And I feel that way about game physics.

54
00:02:51,553 --> 00:02:55,614
Understanding constraints is very useful for what we do,

55
00:02:56,314 --> 00:02:58,615
but it's also kind of satisfying when you understand

56
00:02:58,895 --> 00:03:00,576
these things in greater detail.

57
00:03:04,977 --> 00:03:06,497
All right, so let's get started.

58
00:03:07,318 --> 00:03:09,979
So as a physics programmer, it is our job

59
00:03:10,819 --> 00:03:11,879
to understand constraints.

60
00:03:13,380 --> 00:03:16,060
Constraints are as fundamental to game physics

61
00:03:16,080 --> 00:03:17,881
as shaders are to graphics programming.

62
00:03:18,862 --> 00:03:21,264
So with shaders, you can use standard recipes

63
00:03:21,324 --> 00:03:25,947
for lighting, shadows, or you can make up your own shaders

64
00:03:25,987 --> 00:03:27,007
and create something unique.

65
00:03:28,148 --> 00:03:29,749
Just like shaders with constraints,

66
00:03:29,789 --> 00:03:33,432
you can use standard constraints like Revolute, Prismatic,

67
00:03:34,632 --> 00:03:36,333
and you can implement those.

68
00:03:37,114 --> 00:03:39,476
Or you can kind of come up with your own constraints

69
00:03:39,536 --> 00:03:40,616
and create something unique.

70
00:03:41,357 --> 00:03:44,579
So constraints are an area where a physics programmer

71
00:03:45,079 --> 00:03:46,900
can show their knowledge and their creativity.

72
00:03:50,733 --> 00:03:54,935
So we can model and program our constraints to a high degree of accuracy.

73
00:03:55,935 --> 00:04:01,017
They can be accurate enough to simulate a robot or a satellite.

74
00:04:02,098 --> 00:04:07,620
But the problem in games is that if we want to solve these constraints precisely,

75
00:04:08,401 --> 00:04:12,142
we need cubic time and we need quadratic memory.

76
00:04:14,712 --> 00:04:16,393
But for games, we can't do that.

77
00:04:16,493 --> 00:04:18,373
It's too much time, too much memory.

78
00:04:18,673 --> 00:04:22,774
So we make do with linear time and linear space solvers.

79
00:04:24,374 --> 00:04:30,016
So we're always wrestling with this low-accuracy solver.

80
00:04:30,436 --> 00:04:33,376
So the better that we understand these solvers, I

81
00:04:33,396 --> 00:04:36,257
think the better chance you'll have of creating robust game

82
00:04:36,277 --> 00:04:36,917
simulations.

83
00:04:41,618 --> 00:04:41,718
So.

84
00:04:42,940 --> 00:04:45,041
Understanding constraints can be very useful.

85
00:04:46,362 --> 00:04:49,063
You know, if you just start with constraints

86
00:04:49,543 --> 00:04:51,304
and you use the standard techniques,

87
00:04:51,884 --> 00:04:54,866
you can create constraints to do ragdolls and destruction.

88
00:04:56,027 --> 00:04:58,228
But if you understand constraints more deeply,

89
00:04:58,308 --> 00:05:01,750
you can do things like motorized ragdolls or soft constraints.

90
00:05:03,611 --> 00:05:04,891
And you can go even further.

91
00:05:04,971 --> 00:05:07,113
You can develop things like block solvers,

92
00:05:07,453 --> 00:05:09,554
position solvers, and character solvers.

93
00:05:10,294 --> 00:05:12,335
And I'm going to be talking about some of these things today.

94
00:05:16,252 --> 00:05:20,435
All right, so I've been talking about constraints at the GDC since 2005.

95
00:05:21,896 --> 00:05:26,399
You can find a lot of this reference material on my website, box2d.org.

96
00:05:28,020 --> 00:05:30,261
Nevertheless, I'm going to go through a bit of review here.

97
00:05:31,882 --> 00:05:35,685
So, in my opinion, everything starts with the position constraint.

98
00:05:36,465 --> 00:05:40,228
So imagine this skateboarder never leaves the ramp.

99
00:05:40,288 --> 00:05:43,150
It's just moving back and forth on this half pipe.

100
00:05:44,390 --> 00:05:44,510
So.

101
00:05:45,422 --> 00:05:48,483
The skateboard is constrained to that surface,

102
00:05:48,663 --> 00:05:50,883
but can move freely on that surface.

103
00:05:51,484 --> 00:05:53,084
So this is a position constraint.

104
00:05:55,185 --> 00:05:57,666
So let's look at how we would actually express

105
00:05:57,826 --> 00:05:59,947
the position constraint for that ramp.

106
00:06:01,027 --> 00:06:03,028
Well, for simplicity, we're just going to treat

107
00:06:03,068 --> 00:06:04,528
the skateboard as a particle.

108
00:06:07,289 --> 00:06:11,571
And the position constraint that we need to develop is a...

109
00:06:11,951 --> 00:06:12,551
It's a scalar...

110
00:06:13,522 --> 00:06:16,843
function of the position of that particle, P.

111
00:06:18,803 --> 00:06:20,964
And that constraint function, C, it

112
00:06:21,004 --> 00:06:23,625
must be equal to 0 when the constraint is satisfied.

113
00:06:23,805 --> 00:06:25,145
Otherwise, it must be non-zero.

114
00:06:26,406 --> 00:06:28,206
So the bottom of the ramp is flat.

115
00:06:29,026 --> 00:06:31,967
So I've just defined C to be the sine distance

116
00:06:32,227 --> 00:06:34,368
of that particle from that plane.

117
00:06:35,128 --> 00:06:37,069
So if the particle is above the plane.

118
00:06:37,587 --> 00:06:39,569
then C is positive.

119
00:06:39,669 --> 00:06:41,191
If the particle's below the plane,

120
00:06:41,631 --> 00:06:42,612
then C is negative.

121
00:06:43,353 --> 00:06:45,274
So that has the properties that we want.

122
00:06:50,179 --> 00:06:51,820
I need a different position constraint

123
00:06:51,861 --> 00:06:53,262
for the circular part of the ramp.

124
00:06:53,882 --> 00:06:54,123
So,

125
00:06:55,764 --> 00:06:56,425
in this case,

126
00:06:57,486 --> 00:06:59,427
the particle is restricted to be on

127
00:06:59,868 --> 00:07:01,670
a circle centered at P0,

128
00:07:02,330 --> 00:07:03,751
and the circle has radius R.

129
00:07:04,700 --> 00:07:09,764
So here, C is just the distance of the particle

130
00:07:09,824 --> 00:07:12,165
from the center of the circle minus the radius.

131
00:07:13,266 --> 00:07:16,148
And that has that same property, that if you're on one side,

132
00:07:16,208 --> 00:07:17,309
it's negative.

133
00:07:17,329 --> 00:07:18,910
If you're on the other side, it's positive.

134
00:07:19,250 --> 00:07:22,132
And if you're right on the circle, then it's zero.

135
00:07:22,712 --> 00:07:26,514
So actually, you can think of this constraint function, C,

136
00:07:27,715 --> 00:07:29,516
as defining an implicit surface.

137
00:07:29,697 --> 00:07:33,419
So in this case, C implicitly defines the circle.

138
00:07:37,668 --> 00:07:41,349
Alright, so now let's look at a constraint that's very ubiquitous in game physics.

139
00:07:41,949 --> 00:07:43,210
It's the contact constraint.

140
00:07:44,390 --> 00:07:47,631
So, I have a box B on this fixed plane A.

141
00:07:48,472 --> 00:07:55,854
And I'm going to set up the contact constraint for the lower left corner of the box.

142
00:07:55,874 --> 00:07:57,575
So I'm just going to do one contact point.

143
00:07:58,155 --> 00:08:00,756
In reality, you might have multiple contact points.

144
00:08:02,737 --> 00:08:05,037
Yeah, you'd have another contact point in this case for sure.

145
00:08:08,359 --> 00:08:12,000
The contact constraint says that the contact points on the touching bodies

146
00:08:12,720 --> 00:08:16,080
don't move relative to each other along the contact normal.

147
00:08:18,301 --> 00:08:21,761
So for right now, I'm just going to treat this as a bilateral constraint.

148
00:08:21,821 --> 00:08:24,522
In other words, I'm not going to let the box leave the surface.

149
00:08:24,602 --> 00:08:28,223
Later on, I will talk about how to handle inequality constraints.

150
00:08:31,643 --> 00:08:35,584
So we have the position constraint for that contact.

151
00:08:37,797 --> 00:08:38,637
And I should note that...

152
00:08:39,518 --> 00:08:42,400
So in the picture there, I have P as one point.

153
00:08:42,980 --> 00:08:46,643
Now I have a point on the box,

154
00:08:46,743 --> 00:08:48,724
and I have a point on the plane,

155
00:08:48,764 --> 00:08:49,765
and those are overlapping,

156
00:08:49,805 --> 00:08:52,007
so that's why you don't see P-A and P-B,

157
00:08:52,027 --> 00:08:54,308
because they're both the same point in this picture.

158
00:08:56,310 --> 00:08:58,631
So to get the velocity constraint,

159
00:09:00,073 --> 00:09:01,794
I need to take the time derivative

160
00:09:02,094 --> 00:09:03,555
of the position constraint.

161
00:09:03,735 --> 00:09:05,516
And we're going to need that velocity constraint

162
00:09:05,536 --> 00:09:07,138
for the solver, so that's why I'm doing this.

163
00:09:08,161 --> 00:09:09,802
So, to do...

164
00:09:11,263 --> 00:09:12,743
to get the velocity constraint,

165
00:09:12,783 --> 00:09:14,224
yeah, I just do the time derivative.

166
00:09:14,484 --> 00:09:15,745
And there's dot notation.

167
00:09:15,785 --> 00:09:18,386
That means differentiation with respect to time.

168
00:09:19,007 --> 00:09:21,828
So that dot above C means dC dt.

169
00:09:22,809 --> 00:09:24,289
And to compute the derivative,

170
00:09:24,329 --> 00:09:26,691
I have to use the chain rule of differentiation.

171
00:09:26,751 --> 00:09:27,911
So I get two terms there.

172
00:09:32,073 --> 00:09:34,475
All right, so I can make some simplifications now.

173
00:09:35,495 --> 00:09:35,635
So...

174
00:09:37,635 --> 00:09:41,819
First of all, the ground is fixed, so P.A is zero.

175
00:09:41,859 --> 00:09:44,401
So the velocity of the contact point on the ground,

176
00:09:44,441 --> 00:09:45,842
it's not moving.

177
00:09:48,684 --> 00:09:49,805
So that works in this case.

178
00:09:50,106 --> 00:09:53,508
And also, in general, I can get rid of that second term

179
00:09:53,568 --> 00:09:58,332
completely because, by definition, when I'm evaluating

180
00:09:58,392 --> 00:10:01,915
the velocity constraint, P.A and P.B are overlapped.

181
00:10:04,355 --> 00:10:05,675
That term just drops out.

182
00:10:06,095 --> 00:10:08,736
So then I'm left with something a bit simpler on the bottom.

183
00:10:12,276 --> 00:10:16,537
All right, so the solver is going to need to deal with velocity

184
00:10:17,418 --> 00:10:20,038
at the center of mass, not velocity at the contact point.

185
00:10:20,518 --> 00:10:23,779
So I need to use this standard formula that relates

186
00:10:24,379 --> 00:10:28,320
velocity on a point on the rigid body to the velocity of the center of mass

187
00:10:29,700 --> 00:10:29,940
plus...

188
00:10:30,980 --> 00:10:35,264
A term involving the angular velocity and this radius vector r.

189
00:10:39,487 --> 00:10:45,832
So, I can express p.b that way and then substitute that into the velocity constraint.

190
00:10:52,998 --> 00:10:54,980
Alright, so I have the velocity constraint now.

191
00:10:57,457 --> 00:11:02,361
Our solver is also going to need to know about how the impulses are set up,

192
00:11:02,401 --> 00:11:04,783
because the solver is going to work with impulses.

193
00:11:06,765 --> 00:11:12,349
So, the idea is to apply impulses to steer the velocity of the box

194
00:11:12,609 --> 00:11:14,891
so that the velocity constraint is satisfied.

195
00:11:17,513 --> 00:11:23,057
Well, for the contact constraint, I have to apply an impulse at the contact point

196
00:11:23,718 --> 00:11:25,279
along the direction of the normal.

197
00:11:27,705 --> 00:11:34,347
Now when I do this, at the center of mass, there's going to be a linear impulse.

198
00:11:34,968 --> 00:11:40,350
And there's also going to be kind of like a torque, an angular impulse, created because

199
00:11:40,950 --> 00:11:45,772
the impulse is not applied directly below the center of mass, it's applied off to the

200
00:11:45,812 --> 00:11:48,353
side, so there's going to be some induced rotation there.

201
00:11:48,393 --> 00:11:52,895
So I need to also express what the angular effect from that impulse is.

202
00:11:53,435 --> 00:11:53,635
And so...

203
00:11:54,832 --> 00:12:00,357
I have this symbol here, lambda. Lambda represents the sine magnitude of the impulse.

204
00:12:02,019 --> 00:12:06,162
So, actually, I know where the impulse is applied. I know the direction of the impulse.

205
00:12:06,302 --> 00:12:12,228
All I need to figure out is, okay, what is the value of lambda to satisfy the velocity constraint?

206
00:12:14,890 --> 00:12:17,933
All right. So, now if I actually want to solve for lambda...

207
00:12:18,832 --> 00:12:20,792
I need to bring in Newton's Law.

208
00:12:21,493 --> 00:12:24,674
So here I have Newton's Law in impulse form.

209
00:12:25,254 --> 00:12:30,096
So the first one is the linear equation of motion.

210
00:12:31,776 --> 00:12:35,457
It says that the change in linear velocity of the center

211
00:12:35,497 --> 00:12:40,599
mass is related to the impulse, the linear impulse.

212
00:12:41,199 --> 00:12:45,561
And then the second one is the angular equation, and that

213
00:12:45,779 --> 00:12:50,565
That expresses the change in angular velocity in terms of the angular impulse.

214
00:12:50,986 --> 00:12:53,710
And that also involves the inertia tensor I.

215
00:12:55,672 --> 00:12:59,958
All right, and then now I can bring in my velocity constraint.

216
00:13:01,380 --> 00:13:03,362
So I just rearrange things here a little bit.

217
00:13:04,827 --> 00:13:09,150
I have the velocity at the final state, state 2.

218
00:13:09,570 --> 00:13:12,672
So I want the velocity constraint to be satisfied at state 2.

219
00:13:13,452 --> 00:13:16,635
It's too late to do anything about state 1, that's kind of the input.

220
00:13:17,635 --> 00:13:20,857
What we're going to move to, we're going to apply an impulse and then move to state 2.

221
00:13:21,438 --> 00:13:25,120
And at state 2, I want the velocity constraint to be equal to 0.

222
00:13:25,821 --> 00:13:29,423
Alright, so now I actually have enough equations to solve for lambda.

223
00:13:30,864 --> 00:13:31,665
And here's how you do that.

224
00:13:33,126 --> 00:13:37,207
So, Newton's law, I isolate v2 and omega2,

225
00:13:37,847 --> 00:13:39,947
so the linear velocity and angular velocity,

226
00:13:41,467 --> 00:13:46,248
and express those in terms of that unknown impulse lambda.

227
00:13:47,449 --> 00:13:52,990
Okay, so now I can substitute the expression for v2 and omega2

228
00:13:53,870 --> 00:13:55,230
into the velocity constraint.

229
00:13:56,070 --> 00:13:58,971
And so that's what I have there on the lower line.

230
00:14:00,171 --> 00:14:00,691
All right, so...

231
00:14:01,935 --> 00:14:07,459
We can just rearrange those terms and come up with a formula for lambda.

232
00:14:08,579 --> 00:14:13,403
So first I have this collection of terms which I'm calling the effective mass.

233
00:14:14,504 --> 00:14:18,426
And then that's multiplied by the initial velocity constraint.

234
00:14:18,787 --> 00:14:25,592
So if there was no air initially in the velocities, then I wouldn't need to apply any impulse.

235
00:14:26,970 --> 00:14:29,411
If there is some error in the initial velocity,

236
00:14:29,451 --> 00:14:32,573
then I'm going to have some non-zero impulse that I need to apply.

237
00:14:34,054 --> 00:14:38,337
And so that first term there, called the effective mass,

238
00:14:41,439 --> 00:14:45,001
I think of that as kind of the mass of the box

239
00:14:46,342 --> 00:14:48,584
projected onto that constraint axis.

240
00:14:49,204 --> 00:14:54,507
And it is kind of the inertial resistance seen by the impulse.

241
00:14:56,684 --> 00:14:59,025
And it has units of mass, so that kind of works.

242
00:15:03,367 --> 00:15:07,468
Alright, so that was a single constraint that I solved.

243
00:15:08,108 --> 00:15:10,049
In game physics, we're going to have lots of constraints,

244
00:15:10,249 --> 00:15:13,631
and we have to solve all these constraints together.

245
00:15:13,651 --> 00:15:19,133
So this problem is much more difficult,

246
00:15:19,233 --> 00:15:22,354
because when you solve one constraint, that can...

247
00:15:23,147 --> 00:15:25,347
uh... introduced air and other constraints cuz you're

248
00:15:26,167 --> 00:15:28,708
like tweaking the velocities of all these rigid bodies and

249
00:15:29,508 --> 00:15:31,529
and uh... they're all interrelated

250
00:15:31,949 --> 00:15:35,169
so to to actually solve this accurately you have to build

251
00:15:35,950 --> 00:15:39,710
uh... a matrix equation and and and solve that matrix equation

252
00:15:40,171 --> 00:15:41,751
if you had a hundred constraints

253
00:15:42,131 --> 00:15:44,231
you'd have to build and factor a hundred by hundred

254
00:15:44,872 --> 00:15:45,472
uh... matrix

255
00:15:46,132 --> 00:15:49,313
and this will be uh... you know likely too slow for most games

256
00:15:50,222 --> 00:15:58,167
So, therefore, physics programmers often make do with linear time solvers that are local solvers.

257
00:15:58,987 --> 00:16:02,610
So what we do is we go through and solve one constraint at a time,

258
00:16:03,610 --> 00:16:07,933
and then iterate and do that over and over, hoping that the whole thing will converge.

259
00:16:12,576 --> 00:16:18,240
So sequential impulses is a kind of local solver that I'm going to be talking about.

260
00:16:21,201 --> 00:16:24,522
So I'm going to show you an example of how sequential impulses work.

261
00:16:24,762 --> 00:16:28,843
So suppose you had a stack of circles and they're all at rest.

262
00:16:29,903 --> 00:16:34,164
Okay, and then at the beginning of the time step, apply gravity

263
00:16:34,184 --> 00:16:39,906
and then adjust the velocities so they're all moving down at the same speed.

264
00:16:41,887 --> 00:16:47,168
Now to counteract gravity, I need to apply impulses at the contact points

265
00:16:47,368 --> 00:16:49,389
to support the weight of the circles.

266
00:16:53,834 --> 00:16:55,735
And actually, if you think about it,

267
00:16:56,196 --> 00:16:58,858
each contact point needs to support the weight

268
00:16:58,938 --> 00:17:00,339
of all the circles above it.

269
00:17:01,219 --> 00:17:03,441
And so that's represented by these dashed lines.

270
00:17:03,941 --> 00:17:06,383
And then, after one iteration, you

271
00:17:06,403 --> 00:17:08,925
can see the impulses start growing there.

272
00:17:09,405 --> 00:17:10,907
And those are those arrows pointing up.

273
00:17:11,287 --> 00:17:14,709
And they're kind of reaching towards that exact solution.

274
00:17:18,468 --> 00:17:20,509
So there were still some errors, so we iterate again,

275
00:17:20,529 --> 00:17:24,350
and the impulses get a little bit closer to the exact solution.

276
00:17:25,391 --> 00:17:30,232
And I should mention that when we're solving those contact points,

277
00:17:30,492 --> 00:17:31,933
it's kind of in arbitrary order.

278
00:17:32,333 --> 00:17:36,535
You could solve a top-bottom, bottom-up, random, whatever you want.

279
00:17:36,575 --> 00:17:41,917
It doesn't really matter, except in terms of performance for, like, cache-friendliness.

280
00:17:45,505 --> 00:17:47,887
And then, you know, if we iterate some more,

281
00:17:47,947 --> 00:17:51,009
we'll get even closer to the exact solution.

282
00:17:51,069 --> 00:17:52,530
So at some point,

283
00:17:54,751 --> 00:17:56,472
we just got to cut off the iterations

284
00:17:58,093 --> 00:18:00,095
because we have to get on with our game.

285
00:18:01,275 --> 00:18:04,858
So there's going to be some error in those impulses,

286
00:18:04,998 --> 00:18:08,040
and the result of that is the objects

287
00:18:08,080 --> 00:18:09,721
are still kind of moving into each other.

288
00:18:10,161 --> 00:18:12,402
So then when you go update the positions,

289
00:18:12,442 --> 00:18:13,983
you're going to see some overlap.

290
00:18:16,600 --> 00:18:18,782
I'll talk later about how to deal with that overlap.

291
00:18:22,485 --> 00:18:25,949
Alright, so that's kind of end of review.

292
00:18:27,650 --> 00:18:31,694
Now I want to talk about one of the main topics is understanding convergence.

293
00:18:33,415 --> 00:18:36,137
So you can kind of see this iterative solver is kind of converging.

294
00:18:37,539 --> 00:18:40,702
And we need to look at that in more detail to really understand what's going on.

295
00:18:41,463 --> 00:18:44,585
So when I think of convergence for an iterative method,

296
00:18:44,985 --> 00:18:47,247
what I think is like, OK, I had this previous error.

297
00:18:48,227 --> 00:18:49,688
And I'm going to multiply it.

298
00:18:49,728 --> 00:18:52,150
When I do my solution, I'm going to multiply that

299
00:18:52,190 --> 00:18:54,872
by some fraction, alpha.

300
00:18:55,192 --> 00:18:57,313
And hopefully that fraction is less than 1.

301
00:18:57,694 --> 00:19:01,236
So then my error will then decrease each iteration.

302
00:19:04,858 --> 00:19:07,680
If alpha were to be greater than 1, you'd have divergence.

303
00:19:11,483 --> 00:19:15,584
Convergence may be fast in some cases where you have a small alpha,

304
00:19:16,564 --> 00:19:18,985
or it could be slow in other cases where you have a large alpha,

305
00:19:19,025 --> 00:19:20,905
and that's what these curves represent.

306
00:19:22,565 --> 00:19:24,706
We don't have control over alpha directly,

307
00:19:24,786 --> 00:19:29,647
it's just kind of like representative of situations you might see.

308
00:19:29,667 --> 00:19:35,448
And let's look for some of these bad cases,

309
00:19:36,468 --> 00:19:38,128
you know, these large alpha cases.

310
00:19:41,015 --> 00:19:42,875
the difficult situations we run into.

311
00:19:44,496 --> 00:19:47,096
So I'm going to explore convergence

312
00:19:47,156 --> 00:19:48,897
by looking at circle stacks.

313
00:19:49,857 --> 00:19:53,878
Circle stacks are nice because they limit the problem

314
00:19:53,918 --> 00:19:54,718
to one dimension.

315
00:19:54,878 --> 00:19:56,839
So we kind of understand things better.

316
00:19:57,699 --> 00:19:59,879
So in the case of a single circle,

317
00:20:01,800 --> 00:20:03,140
when I solve that constraint, I actually

318
00:20:03,180 --> 00:20:04,581
get the exact solution.

319
00:20:04,701 --> 00:20:08,962
So there's really nothing interesting there.

320
00:20:09,182 --> 00:20:10,562
There's no competing constraints.

321
00:20:13,944 --> 00:20:20,690
OK, so if I go to more circles, things get more interesting.

322
00:20:20,770 --> 00:20:23,632
So I actually created a MATLAB script

323
00:20:24,473 --> 00:20:26,575
that runs the sequential impulses algorithm.

324
00:20:27,535 --> 00:20:29,937
You can get that script and some other scripts

325
00:20:30,418 --> 00:20:31,759
I'm going to have in the presentation

326
00:20:33,280 --> 00:20:35,922
when you go download this later from box2d.org.

327
00:20:36,303 --> 00:20:39,185
And you can run these scripts in a free software called Octave.

328
00:20:42,412 --> 00:20:46,154
So, anyhow, in this case of two circles,

329
00:20:49,275 --> 00:20:51,296
the graph here shows these dashed lines

330
00:20:51,336 --> 00:20:52,716
which are the exact answer,

331
00:20:53,076 --> 00:20:57,158
and then the curves are the contact impulses as I iterate.

332
00:20:57,558 --> 00:20:59,659
So the x-axis is the iteration,

333
00:20:59,879 --> 00:21:03,660
and then the y-axis is the total impulse applied.

334
00:21:04,781 --> 00:21:07,182
So you can see, after about five iterations,

335
00:21:07,202 --> 00:21:08,122
I get 95% accuracy.

336
00:21:08,262 --> 00:21:08,742
So that's not bad.

337
00:21:14,142 --> 00:21:20,469
All right, so mass ratios are often quite a difficult problem

338
00:21:20,529 --> 00:21:21,590
for physics programmers.

339
00:21:21,670 --> 00:21:24,133
So I'm going to start looking at different mass ratios.

340
00:21:24,753 --> 00:21:29,058
So how about if I have a half kilogram circle on top of a

341
00:21:29,158 --> 00:21:30,179
one kilogram circle?

342
00:21:31,080 --> 00:21:33,944
Well, in this case, convergence actually got better.

343
00:21:33,984 --> 00:21:35,345
I only needed three iterations.

344
00:21:39,646 --> 00:21:40,807
Let's flip that around.

345
00:21:41,227 --> 00:21:43,669
So now I have a one kilogram circle on top of a half

346
00:21:43,729 --> 00:21:44,509
kilogram circle.

347
00:21:47,071 --> 00:21:49,253
So now the convergence is much worse.

348
00:21:49,353 --> 00:21:54,056
I need around 10 iterations to get 95% convergence.

349
00:21:57,158 --> 00:22:01,181
Now let's take that to an extreme point of mass ratio of

350
00:22:01,261 --> 00:22:01,941
10 to 1.

351
00:22:02,842 --> 00:22:04,783
Now I need around 50 iterations.

352
00:22:05,944 --> 00:22:07,305
So things are getting quite bad.

353
00:22:08,431 --> 00:22:12,515
with this mass ratio increasing.

354
00:22:14,177 --> 00:22:18,021
So you might wonder, well, how bad is it

355
00:22:18,041 --> 00:22:20,663
if I just increase the mass ratio indefinitely?

356
00:22:20,763 --> 00:22:23,246
How does the number of iterations I need, how does that change?

357
00:22:23,726 --> 00:22:26,569
So what I did is I kind of ran a simulation of simulations.

358
00:22:27,050 --> 00:22:29,732
So I set a mass ratio and then...

359
00:22:31,327 --> 00:22:34,507
Counted how many iterations I needed for 95% convergence.

360
00:22:35,147 --> 00:22:37,988
And then I did that for several mass ratios.

361
00:22:38,028 --> 00:22:39,328
And then I plotted it all out.

362
00:22:39,348 --> 00:22:41,809
And it actually turned out to be a straight line.

363
00:22:42,829 --> 00:22:46,930
So a curve fit said that the number of iterations needed

364
00:22:47,790 --> 00:22:49,811
was three times the mass ratio plus two.

365
00:22:51,511 --> 00:22:53,091
So what that means is, one,

366
00:22:54,152 --> 00:22:56,592
the minimum number of iterations you're ever going to need is two.

367
00:22:58,239 --> 00:23:04,183
Also, as iterations increase, as you double the number of,

368
00:23:04,783 --> 00:23:07,345
I'm sorry, as the mass ratio increases,

369
00:23:07,705 --> 00:23:09,366
as you double the mass ratio,

370
00:23:10,987 --> 00:23:13,408
then you need double the number of iterations.

371
00:23:18,051 --> 00:23:20,052
So why is convergence slow?

372
00:23:20,072 --> 00:23:23,875
So let's do a little thought experiment.

373
00:23:27,899 --> 00:23:31,501
So I have this heavy circle on top of this light circle.

374
00:23:31,521 --> 00:23:35,843
And what does the solver see there?

375
00:23:36,944 --> 00:23:39,265
Why is it slow to converge to that problem?

376
00:23:39,886 --> 00:23:43,268
Well, let's just start out a time step.

377
00:23:44,208 --> 00:23:45,229
So we apply gravity.

378
00:23:45,249 --> 00:23:47,850
And now both these circles are moving down

379
00:23:47,890 --> 00:23:49,011
with the same velocity.

380
00:23:50,752 --> 00:23:53,513
And let's say we're going to solve the bottom contact point

381
00:23:53,573 --> 00:23:53,893
first.

382
00:23:54,394 --> 00:23:57,075
So we solve that bottom contact point for the small circle.

383
00:23:58,415 --> 00:24:01,077
It doesn't know about this big circle on top.

384
00:24:01,117 --> 00:24:04,319
So when I solve the contact for the small circle,

385
00:24:04,359 --> 00:24:07,400
it's just going to apply enough impulse to bring that small circle to rest.

386
00:24:09,201 --> 00:24:10,842
Okay, so now that small circle is at rest,

387
00:24:11,503 --> 00:24:13,724
and now I still have this big circle moving down,

388
00:24:14,084 --> 00:24:16,025
and I'm going to solve that upper contact point.

389
00:24:17,346 --> 00:24:19,847
So, when I solve that upper contact point,

390
00:24:21,508 --> 00:24:23,209
we have this big circle moving down,

391
00:24:23,829 --> 00:24:25,290
there's this tiny circle at rest.

392
00:24:26,120 --> 00:24:28,922
And when I solve for the contact there,

393
00:24:28,942 --> 00:24:31,403
it basically just brushes that small circle out of the way,

394
00:24:31,503 --> 00:24:33,505
and the top circle only slows down a little bit,

395
00:24:33,845 --> 00:24:37,127
because that upper contact doesn't know about the ground below.

396
00:24:39,068 --> 00:24:42,871
So now this top circle is slowed down just a little bit,

397
00:24:42,891 --> 00:24:44,352
the bottom circle is moving down.

398
00:24:44,372 --> 00:24:47,254
I go solve the bottom contact again,

399
00:24:47,314 --> 00:24:48,655
the small circle comes to rest.

400
00:24:49,555 --> 00:24:50,936
And then the same situation,

401
00:24:50,956 --> 00:24:52,617
when I go to solve the top circle...

402
00:24:53,178 --> 00:24:58,141
or top contact again, I'm just taking a tiny bit of the velocity away from that top circle.

403
00:24:58,701 --> 00:25:05,345
So you can see I'm just kind of, I need to bring that top circle to rest by only removing a small amount of its velocity each iteration.

404
00:25:06,126 --> 00:25:11,769
So that's why the convergence gets slow when that mass ratio gets high.

405
00:25:14,151 --> 00:25:18,834
Okay, so we saw that the mass ratios cause a lot of problems for convergence.

406
00:25:21,137 --> 00:25:24,718
When we had just one circle, we only needed basically one iteration.

407
00:25:24,798 --> 00:25:27,800
For two circles, I needed five iterations.

408
00:25:29,040 --> 00:25:31,922
In the case of four circles, I ran a simulation,

409
00:25:32,122 --> 00:25:35,083
and I needed about 20 iterations to get a convergence.

410
00:25:41,607 --> 00:25:45,268
So a nice exercise now you might try,

411
00:25:45,308 --> 00:25:47,610
you can download the script and try if you want, is to...

412
00:25:49,594 --> 00:25:53,636
See, well, as I grow the stack size, how many iterations do I need?

413
00:25:53,656 --> 00:25:55,778
So you can maybe generate a graph of that,

414
00:25:56,558 --> 00:25:58,039
iterations versus stack size.

415
00:26:00,841 --> 00:26:01,422
Alright, so...

416
00:26:03,263 --> 00:26:06,405
we have all these convergence problems with our local solver,

417
00:26:06,725 --> 00:26:07,866
with sequential impulses.

418
00:26:09,087 --> 00:26:10,448
Is there something that we can do

419
00:26:11,629 --> 00:26:12,849
to kind of help it out?

420
00:26:13,690 --> 00:26:14,551
Well, in games,

421
00:26:15,211 --> 00:26:17,452
things don't move a whole lot from frame to frame.

422
00:26:18,764 --> 00:26:20,125
And we have lots of frames.

423
00:26:21,125 --> 00:26:24,986
So maybe we can make use of that coherence

424
00:26:26,087 --> 00:26:30,928
to kind of break up the solution over several time steps.

425
00:26:32,529 --> 00:26:34,750
And so that's the idea of warm starting.

426
00:26:35,350 --> 00:26:39,471
Kind of just taking a few iterations each time step

427
00:26:39,671 --> 00:26:42,412
and then passing the result on to the next time step.

428
00:26:45,472 --> 00:26:47,513
So here's how that works in pseudocode.

429
00:26:47,553 --> 00:26:49,355
So let's say I have my solver,

430
00:26:49,495 --> 00:26:52,197
and it's computing these incremental impulses,

431
00:26:52,638 --> 00:26:57,382
and then adding those impulses up into accumulated impulse.

432
00:26:57,542 --> 00:27:00,304
So I compute an incremental impulse each iteration

433
00:27:00,805 --> 00:27:02,807
that I pass through for that contact.

434
00:27:03,527 --> 00:27:06,350
And then I'm just storing all those incremental impulses up.

435
00:27:06,970 --> 00:27:09,893
And then I just... but I apply that incremental impulse.

436
00:27:11,234 --> 00:27:11,454
Okay.

437
00:27:12,019 --> 00:27:14,261
So now I have that, at the end of the time step,

438
00:27:14,341 --> 00:27:16,623
I have stored this accumulated impulse.

439
00:27:17,364 --> 00:27:19,625
And then I bring that around to the next time step,

440
00:27:20,106 --> 00:27:21,887
and the next time step at the beginning

441
00:27:23,689 --> 00:27:24,670
might apply gravity,

442
00:27:24,930 --> 00:27:28,513
and then I just apply that stored accumulated impulse.

443
00:27:30,014 --> 00:27:31,575
And then I go start my iterations.

444
00:27:32,536 --> 00:27:35,319
So, imagine I had already converged.

445
00:27:35,339 --> 00:27:37,260
I already have the exact...

446
00:27:38,270 --> 00:27:40,691
impulse to support whatever objects are there.

447
00:27:41,511 --> 00:27:44,652
If I... and nothing moves and nothing changes.

448
00:27:45,292 --> 00:27:50,574
If I apply that accumulated impulse at the beginning of the time step,

449
00:27:51,434 --> 00:27:54,896
then that completely counteracts gravity

450
00:27:55,816 --> 00:27:59,077
and the system is completely stable at that point.

451
00:27:59,177 --> 00:28:02,718
And then when I go iterate, those delta impulses actually end up being zero.

452
00:28:03,839 --> 00:28:04,679
So that's how it works.

453
00:28:07,119 --> 00:28:09,040
There is some downside to warm starting.

454
00:28:10,061 --> 00:28:15,525
If you have a heavy load and it's suddenly removed,

455
00:28:16,786 --> 00:28:21,969
then that next time step after you remove that heavy load,

456
00:28:22,009 --> 00:28:23,650
you may not have enough iterations

457
00:28:23,730 --> 00:28:26,852
to kind of back off on that large impulse

458
00:28:26,872 --> 00:28:28,033
you have in your contacts.

459
00:28:28,714 --> 00:28:32,076
And what you'll see in that case is you may see a bounce.

460
00:28:32,436 --> 00:28:35,678
And I'm going to show a demo of some of this stuff.

461
00:28:49,263 --> 00:28:52,645
All right, so this is Box2D.

462
00:28:53,906 --> 00:28:55,106
I created a couple of demos.

463
00:29:00,429 --> 00:29:01,649
Zoom in here a little bit.

464
00:29:03,430 --> 00:29:05,151
OK, I'm going to make some changes.

465
00:29:05,171 --> 00:29:08,352
I'm going to turn off Warm Starting, turn off Continuous,

466
00:29:08,412 --> 00:29:09,173
turn off Sleep.

467
00:29:09,853 --> 00:29:11,434
I'm going to turn off Position Correction.

468
00:29:12,654 --> 00:29:13,555
Let's start this over.

469
00:29:14,555 --> 00:29:16,056
So without Warm Starting.

470
00:29:17,792 --> 00:29:19,332
And I'm doing eight iterations here.

471
00:29:19,352 --> 00:29:23,014
That's just not enough for the solver to compute the right impulse

472
00:29:23,074 --> 00:29:24,815
to support that large circle on top.

473
00:29:25,475 --> 00:29:29,456
So, like I said, you're going to have some big errors in your impulses,

474
00:29:30,017 --> 00:29:31,917
and so your velocities are not right,

475
00:29:31,997 --> 00:29:35,099
so objects move into an overlap state.

476
00:29:38,100 --> 00:29:39,520
Let's turn on warm starting.

477
00:29:41,941 --> 00:29:42,222
All right.

478
00:29:43,817 --> 00:29:48,681
There's some bouncing there, but I do get proper support eventually.

479
00:29:48,701 --> 00:29:56,407
The reason for the bouncing, we were just talking about this yesterday, and I kind of

480
00:29:56,427 --> 00:29:57,028
figured it out.

481
00:29:57,128 --> 00:30:03,473
So when the objects are moving down, you need kind of a large impulse to bring them to rest,

482
00:30:03,933 --> 00:30:04,854
and it's larger.

483
00:30:06,335 --> 00:30:09,097
then the impulse you need just to kind of hold them there

484
00:30:09,317 --> 00:30:10,518
after they've come to rest.

485
00:30:10,538 --> 00:30:14,041
So that's kind of the situation where there's this large load,

486
00:30:14,081 --> 00:30:14,981
then it gets removed,

487
00:30:15,722 --> 00:30:18,945
but then you don't have enough iterations to back off,

488
00:30:19,025 --> 00:30:21,847
and so the impulse is still large,

489
00:30:21,887 --> 00:30:23,388
and then so that causes a bounce.

490
00:30:24,389 --> 00:30:28,792
And let's look at a better example of that effect.

491
00:30:32,235 --> 00:30:34,156
So here I got two little circles

492
00:30:35,798 --> 00:30:35,898
and

493
00:30:38,414 --> 00:30:41,075
I'm going to go down to just two iterations

494
00:30:42,395 --> 00:30:43,636
on the velocity constraints.

495
00:30:46,337 --> 00:30:46,637
All right.

496
00:30:48,737 --> 00:30:51,858
So now I've got this heavy circle

497
00:30:52,098 --> 00:30:53,499
on top of these two little circles.

498
00:30:54,579 --> 00:30:57,820
Warm start is on, so it's converging,

499
00:30:58,140 --> 00:30:58,961
but there's some bounce.

500
00:31:00,301 --> 00:31:04,702
All right, now I'm going to delete that top circle

501
00:31:05,643 --> 00:31:07,783
and watch the two little circles.

502
00:31:09,298 --> 00:31:10,419
See, there was a bounce there.

503
00:31:10,539 --> 00:31:13,020
And that's because there was that stored impulse there

504
00:31:13,680 --> 00:31:15,641
that just couldn't be reduced quickly enough.

505
00:31:16,061 --> 00:31:19,002
And so it was too large and then that caused lift-off.

506
00:31:19,102 --> 00:31:28,185
All right, let's get back.

507
00:31:37,828 --> 00:31:41,049
All right, so next topic is understanding inequality constraints.

508
00:31:41,869 --> 00:31:47,890
So, constraints like contact constraints require special handling.

509
00:31:49,171 --> 00:31:52,071
In this case, the constraint can push, but it can't pull.

510
00:31:52,771 --> 00:31:58,193
So, in the context of sequential impulses, it's not hard to deal with this.

511
00:31:58,253 --> 00:32:00,573
It's not hard at all. We just need to use some clamping.

512
00:32:01,053 --> 00:32:03,574
However, we have to be careful about how we clamp.

513
00:32:06,680 --> 00:32:10,082
So you could just say, well, I'll compute that delta impulse,

514
00:32:10,142 --> 00:32:12,644
and I'm just going to clamp it so that it's always pushing.

515
00:32:12,664 --> 00:32:14,405
It's always greater than 0.

516
00:32:15,526 --> 00:32:16,707
This is actually wrong.

517
00:32:19,829 --> 00:32:23,491
So what you want to do is clamp that accumulated impulse.

518
00:32:23,511 --> 00:32:25,133
So you can think of that accumulated impulse

519
00:32:25,213 --> 00:32:26,694
as the total amount of impulse you

520
00:32:26,714 --> 00:32:29,876
applied at that constraint over the time step.

521
00:32:31,743 --> 00:32:33,984
So you want that thing to be positive.

522
00:32:34,644 --> 00:32:38,665
This will allow the incremental impulses to be negative.

523
00:32:39,145 --> 00:32:40,205
And here's how you do that.

524
00:32:40,945 --> 00:32:45,706
So first, store the old accumulated impulse.

525
00:32:46,447 --> 00:32:49,567
Go ahead and compute the incremental impulse, delta.

526
00:32:50,828 --> 00:32:53,408
Then add that into the accumulated impulse.

527
00:32:54,568 --> 00:32:57,649
And then clamp the accumulated impulse.

528
00:32:58,868 --> 00:33:00,469
And then the next step is the tricky bit.

529
00:33:00,509 --> 00:33:02,810
So I'm going to adjust that incremental impulse

530
00:33:02,930 --> 00:33:07,153
to be the actual change in the accumulated impulse.

531
00:33:08,534 --> 00:33:11,976
And then I go apply that updated incremental impulse.

532
00:33:12,677 --> 00:33:14,117
So there's a few more steps here.

533
00:33:14,638 --> 00:33:16,559
But essentially, all I'm doing is

534
00:33:16,599 --> 00:33:20,321
clamping to achieve the inequality constraint.

535
00:33:22,503 --> 00:33:23,343
So why do that?

536
00:33:24,624 --> 00:33:25,905
It's because of overshoot.

537
00:33:26,765 --> 00:33:27,386
OK, so there's.

538
00:33:28,733 --> 00:33:31,435
Clearly, in the case of warm starting,

539
00:33:31,515 --> 00:33:33,556
you're going to need to do this,

540
00:33:33,816 --> 00:33:36,898
because as objects start to lift off,

541
00:33:38,939 --> 00:33:40,920
the impulse needs to decrease.

542
00:33:40,980 --> 00:33:45,402
We need some way of decreasing the accumulated impulse.

543
00:33:47,323 --> 00:33:49,704
How about in the case where we don't use warm starting?

544
00:33:49,764 --> 00:33:50,845
Do we still need this?

545
00:33:52,886 --> 00:33:55,127
Well, let's try to figure that out.

546
00:33:59,058 --> 00:34:01,199
All right, so I want to start looking for overshoot.

547
00:34:01,879 --> 00:34:04,620
So in the case of a box on a plane,

548
00:34:04,960 --> 00:34:06,381
we'll have two contact points.

549
00:34:07,541 --> 00:34:10,643
And I wrote a script that solves this.

550
00:34:11,183 --> 00:34:12,563
And here's the graph of the solution.

551
00:34:12,623 --> 00:34:14,904
Now, these two contact points, they

552
00:34:14,924 --> 00:34:18,266
should both be supporting half the weight.

553
00:34:18,486 --> 00:34:19,466
So there's no rotation.

554
00:34:19,486 --> 00:34:20,286
You want them balanced.

555
00:34:20,947 --> 00:34:23,508
So they should both be going up to that dashed red line.

556
00:34:24,755 --> 00:34:27,116
And they do, they go up in two iterations,

557
00:34:27,437 --> 00:34:28,797
and there's actually no overshoot.

558
00:34:29,117 --> 00:34:31,498
So you don't, in this case, actually don't need any clamping.

559
00:34:33,219 --> 00:34:35,480
So, that's not the case we need.

560
00:34:36,741 --> 00:34:40,162
How about instead of the box being on this big plane,

561
00:34:40,382 --> 00:34:42,023
it's actually on top of some pole?

562
00:34:43,544 --> 00:34:47,245
Now, you can imagine this in the extreme case,

563
00:34:47,365 --> 00:34:49,166
where the pole gets narrower and narrower.

564
00:34:49,787 --> 00:34:51,727
Then we basically have two contact points,

565
00:34:52,048 --> 00:34:54,008
which are almost on top of each other.

566
00:34:57,063 --> 00:34:59,745
If I have one contact point below the center of mass,

567
00:35:00,005 --> 00:35:01,105
and I go solve that,

568
00:35:01,986 --> 00:35:04,467
it's going to want to support the entire weight of that box.

569
00:35:07,488 --> 00:35:09,349
But, let's say I move that off to the side,

570
00:35:09,409 --> 00:35:12,371
it's still going to be very close to the entire weight of that box.

571
00:35:12,751 --> 00:35:14,492
Now I bring in another contact point,

572
00:35:14,692 --> 00:35:17,153
and when I go to solve it, it's like, well,

573
00:35:19,534 --> 00:35:21,035
the box is not moving down anymore.

574
00:35:21,095 --> 00:35:22,576
Now there's just a small rotation,

575
00:35:22,616 --> 00:35:24,337
so I'm just going to apply a small impulse there.

576
00:35:26,552 --> 00:35:28,593
So let's see how this plays out in a simulation.

577
00:35:32,595 --> 00:35:36,437
Alright, so with the pole at 75% of the width of the box,

578
00:35:38,078 --> 00:35:39,499
already I got some overshoot.

579
00:35:40,220 --> 00:35:44,042
So this shows that we need to clamp the accumulated impulse.

580
00:35:44,482 --> 00:35:47,644
Otherwise, you would never be able to back off of that overshoot

581
00:35:47,704 --> 00:35:50,026
and get to that exact solution.

582
00:35:52,787 --> 00:35:55,809
And in this case, convergence is still good, just two iterations.

583
00:35:57,062 --> 00:35:58,743
How about a 50% width?

584
00:36:00,003 --> 00:36:01,544
Now I've got even more overshoot.

585
00:36:02,565 --> 00:36:07,788
I really need to be able to apply negative incremental

586
00:36:07,868 --> 00:36:11,150
impulses to back off on that overshoot there.

587
00:36:12,171 --> 00:36:14,132
And now I need five iterations or so.

588
00:36:16,833 --> 00:36:17,694
No, just a couple more.

589
00:36:19,015 --> 00:36:19,315
All right.

590
00:36:20,135 --> 00:36:20,556
Now at a 25% width.

591
00:36:23,758 --> 00:36:27,119
I need around 12 iterations, and there's a lot more overshoot.

592
00:36:27,959 --> 00:36:31,080
So this is actually kind of interesting,

593
00:36:31,100 --> 00:36:36,282
because I was looking for a case where I had some overshoot.

594
00:36:36,802 --> 00:36:40,103
But I also found a case where convergence starts to suck.

595
00:36:40,743 --> 00:36:46,225
So this is a case where there's no mass ratio problem here.

596
00:36:46,245 --> 00:36:48,405
I only have one moving object.

597
00:36:48,825 --> 00:36:50,546
Yet I need more and more iterations

598
00:36:50,686 --> 00:36:52,947
as the geometry gets more extreme.

599
00:36:54,250 --> 00:36:57,133
And this type of stuff happens all the time in games.

600
00:36:57,713 --> 00:37:04,179
So, yeah, another case where having a local solver causes trouble.

601
00:37:06,522 --> 00:37:11,506
So, we can kind of address this problem with...

602
00:37:15,664 --> 00:37:16,304
a block solver.

603
00:37:16,384 --> 00:37:20,045
So the idea is, well, I really love that exact solution

604
00:37:20,065 --> 00:37:22,446
that the global solver gets, but I just can't do that

605
00:37:22,606 --> 00:37:23,867
on all my constraints.

606
00:37:24,367 --> 00:37:28,229
But maybe I can apply that kind of matrix methodology

607
00:37:29,589 --> 00:37:31,370
for just a couple constraints at a time.

608
00:37:32,010 --> 00:37:36,652
So what you can actually do is solve for those two contact

609
00:37:36,692 --> 00:37:37,813
points simultaneously.

610
00:37:38,453 --> 00:37:39,173
So yeah, in 2D.

611
00:37:40,384 --> 00:37:42,786
You know, if you have two convex polygons colliding,

612
00:37:42,806 --> 00:37:45,328
you either get zero points, one point, or two points.

613
00:37:47,049 --> 00:37:48,830
So the most I'll ever have to deal with

614
00:37:48,910 --> 00:37:52,393
is two contact points between two colliding polygons.

615
00:37:53,013 --> 00:37:54,875
So in the case of two contact points,

616
00:37:54,895 --> 00:38:00,899
I'm going to try to solve those two impulses simultaneously.

617
00:38:00,919 --> 00:38:04,282
And if you think about it, there's actually four cases.

618
00:38:05,888 --> 00:38:13,152
There's a case where both contacts have a positive impulse,

619
00:38:13,172 --> 00:38:16,234
or one contact is zero and the other is positive,

620
00:38:16,494 --> 00:38:18,135
or vice versa, or they're both zero,

621
00:38:18,175 --> 00:38:19,756
and that means the objects are moving away.

622
00:38:20,236 --> 00:38:24,939
And so what I actually do is solve all four cases,

623
00:38:25,099 --> 00:38:26,680
looking for the case that's valid.

624
00:38:26,780 --> 00:38:29,421
So first I solve a two-by-two matrix,

625
00:38:29,441 --> 00:38:32,182
because I have to solve both constraints simultaneously.

626
00:38:32,202 --> 00:38:33,503
And if those...

627
00:38:34,329 --> 00:38:37,630
Both those impulses come out positive, then I'm done.

628
00:38:38,151 --> 00:38:42,472
Otherwise, I set one constraint to zero,

629
00:38:42,512 --> 00:38:44,873
basically forget about it, and then solve for the other one.

630
00:38:44,953 --> 00:38:48,594
If that's negative, then I switch and try the other contact.

631
00:38:49,075 --> 00:38:52,476
And if that's negative, then the objects must be leaving,

632
00:38:52,796 --> 00:38:53,676
and they're both zero.

633
00:38:54,557 --> 00:38:57,118
So I'm not gonna go into any more detail about this,

634
00:38:57,158 --> 00:38:59,399
but you can actually find this in Box2D.

635
00:39:00,399 --> 00:39:02,120
And I will show a demo of how it works.

636
00:39:21,762 --> 00:39:29,345
I'm going to turn off the position solvers, sleep, continuous.

637
00:39:29,365 --> 00:39:36,489
Okay, so I have it set up so that I can turn on and off the block solver.

638
00:39:36,529 --> 00:39:42,451
So now I just turned it off and we only solve one contact point at a time for this stack of boxes.

639
00:39:45,053 --> 00:39:47,894
So there you can see the asymmetry.

640
00:39:49,665 --> 00:39:51,907
and introduced by just solving one point at a time.

641
00:39:54,309 --> 00:39:55,950
If I could turn on the block solver,

642
00:39:57,991 --> 00:40:00,093
there it almost behaves like a stack of spheres.

643
00:40:00,213 --> 00:40:03,575
It's because I'm solving those contact points simultaneously,

644
00:40:03,655 --> 00:40:09,079
so they're perfectly in sync and completely symmetric there.

645
00:40:11,000 --> 00:40:17,224
So that kind of solves that problem with the convergence.

646
00:40:18,442 --> 00:40:21,786
Like on the pole, if you had a narrow pole, you wouldn't have any convergence problem there.

647
00:40:30,617 --> 00:40:32,340
Alright, let's move on.

648
00:40:32,360 --> 00:40:35,043
Alright, so next topic is...

649
00:40:37,668 --> 00:40:39,630
Well, we started with position constraints.

650
00:40:40,270 --> 00:40:43,432
And then we took the derivative and we got the velocity constraint.

651
00:40:43,492 --> 00:40:47,354
Well, what if I want to work with forces and I want to work with accelerations?

652
00:40:47,375 --> 00:40:49,616
Because that's how Newton's laws are written, right?

653
00:40:49,656 --> 00:40:51,237
That's maybe more intuitive.

654
00:40:51,577 --> 00:40:52,558
And you can actually do that.

655
00:40:52,598 --> 00:40:55,980
You can take one more derivative of the velocity constraint

656
00:40:56,000 --> 00:40:57,681
and you can get the acceleration constraint.

657
00:40:57,741 --> 00:41:00,042
And then you can work with accelerations and forces.

658
00:41:03,885 --> 00:41:04,725
But there's a problem.

659
00:41:05,906 --> 00:41:06,726
So, first of all,

660
00:41:07,754 --> 00:41:10,636
With a rigid body, when you have collision,

661
00:41:11,637 --> 00:41:14,580
the collision happens instantaneously.

662
00:41:16,081 --> 00:41:19,444
So that means that actually you would need infinite forces,

663
00:41:19,584 --> 00:41:21,666
because you need to be able to change the velocities

664
00:41:21,946 --> 00:41:23,888
of those objects instantaneously.

665
00:41:24,268 --> 00:41:27,051
And when you're dealing with acceleration and forces,

666
00:41:27,491 --> 00:41:30,093
you need an infinite force to do that.

667
00:41:30,854 --> 00:41:32,515
So we don't do that.

668
00:41:36,050 --> 00:41:39,473
You could say, well, OK, I'll apply impulses

669
00:41:39,533 --> 00:41:43,077
during collisions, but then I'll use acceleration of forces

670
00:41:43,117 --> 00:41:45,620
when things are in steady contact.

671
00:41:48,242 --> 00:41:49,584
Well, that also doesn't work.

672
00:41:50,785 --> 00:41:53,347
Here's an example of where you can run into trouble.

673
00:41:55,029 --> 00:41:56,891
So let's say you have this rod that's

674
00:41:57,211 --> 00:41:58,473
sliding across the ground.

675
00:42:00,330 --> 00:42:03,091
There's going to be some friction force pushing back on that rod.

676
00:42:03,691 --> 00:42:06,632
And that kind of tweaks the rod and gets it to dig in.

677
00:42:07,112 --> 00:42:09,273
That increases the normal force.

678
00:42:11,294 --> 00:42:13,154
But the normal force and the friction are related.

679
00:42:13,214 --> 00:42:15,635
The stronger the normal force, the stronger the friction.

680
00:42:16,856 --> 00:42:18,276
So then the friction gets larger.

681
00:42:18,296 --> 00:42:20,937
And then the normal force gets larger.

682
00:42:21,617 --> 00:42:23,478
And this becomes this positive feedback cycle.

683
00:42:23,538 --> 00:42:24,598
And they both become infinite.

684
00:42:29,040 --> 00:42:33,162
Yeah, so for this reason, game physics programmers

685
00:42:33,282 --> 00:42:36,443
abandoned working with acceleration constraints

686
00:42:36,483 --> 00:42:37,304
a long time ago.

687
00:42:40,025 --> 00:42:42,826
If we go over to what we know, velocity constraints,

688
00:42:42,906 --> 00:42:43,726
it's no problem.

689
00:42:44,266 --> 00:42:45,307
That rod is digging in.

690
00:42:45,547 --> 00:42:49,208
We can apply a friction impulse to bring that contact point

691
00:42:49,429 --> 00:42:53,390
to zero velocity instantly, and then the rod will tip over.

692
00:42:53,890 --> 00:42:56,691
So it's no problem with velocity constraints.

693
00:42:58,322 --> 00:43:00,864
So the impulses remain finite.

694
00:43:04,487 --> 00:43:06,829
So are velocity constraints the best thing?

695
00:43:07,689 --> 00:43:09,871
Well, they work really well with friction,

696
00:43:10,191 --> 00:43:15,776
because friction is purely just a velocity constraint.

697
00:43:16,737 --> 00:43:18,218
It doesn't care about position.

698
00:43:19,919 --> 00:43:23,902
So that seems to be a sweet spot for rigid body simulation,

699
00:43:24,283 --> 00:43:25,404
but that doesn't mean that.

700
00:43:28,243 --> 00:43:31,465
There might be other choices and other things we have to look at.

701
00:43:32,045 --> 00:43:39,070
So, first of all, the velocity solver is not perfect.

702
00:43:39,450 --> 00:43:44,793
First of all, nonlinearities due to rotation means you're not going to get an exact result.

703
00:43:45,374 --> 00:43:50,537
You have a fixed number of iterations, so you can get into overlap situations very easily

704
00:43:50,617 --> 00:43:52,078
if you're only solving velocities.

705
00:43:54,619 --> 00:43:56,901
So, the sequential impulses algorithm doesn't...

706
00:43:57,689 --> 00:43:59,390
It doesn't do anything to help you with that.

707
00:43:59,410 --> 00:44:03,053
You have to add some additional stuff to deal with overlap.

708
00:44:05,614 --> 00:44:08,616
So one common method for dealing with overlap

709
00:44:11,158 --> 00:44:13,099
is by velocity steering.

710
00:44:13,299 --> 00:44:17,862
Basically, we take the velocity constraint that we have.

711
00:44:18,485 --> 00:44:21,606
And then we add in the position error into that

712
00:44:21,646 --> 00:44:28,509
to try to steer the objects in a path that removes that overlap.

713
00:44:30,129 --> 00:44:33,770
So here you can see I started with the regular contact

714
00:44:33,810 --> 00:44:36,311
constraint, and then I added some stuff below.

715
00:44:37,412 --> 00:44:39,632
So there's this beta factor, which

716
00:44:39,692 --> 00:44:41,013
is kind of like a tuning factor.

717
00:44:42,035 --> 00:44:46,558
And the S in this case is the signed distance.

718
00:44:47,098 --> 00:44:49,459
So in the case of overlap, it would be negative.

719
00:44:50,400 --> 00:44:53,802
And then I've got to divide by the time step.

720
00:44:53,942 --> 00:44:56,463
That makes sure that I have units of velocity.

721
00:44:56,523 --> 00:44:58,885
So length over time.

722
00:45:00,686 --> 00:45:03,667
And then, yeah, beta is a non-dimensional thing.

723
00:45:03,727 --> 00:45:05,588
If you set beta to 1, you're basically saying,

724
00:45:05,608 --> 00:45:08,190
I want to remove all the overlap in one time step.

725
00:45:09,990 --> 00:45:12,471
We don't usually do that because you often,

726
00:45:13,111 --> 00:45:15,792
due to other inaccuracies, you'll get some overshoot.

727
00:45:15,972 --> 00:45:19,393
So, usually use a beta factor less than one.

728
00:45:22,173 --> 00:45:24,994
So what this does is when we feed this

729
00:45:25,114 --> 00:45:27,354
adjusted velocity constraint to the solver,

730
00:45:28,115 --> 00:45:28,855
it's gonna do then,

731
00:45:28,875 --> 00:45:32,656
the impulse will be a little bit stronger,

732
00:45:32,676 --> 00:45:36,917
and then your velocities are gonna get adjusted.

733
00:45:42,334 --> 00:45:45,535
All right, so there's a problem with that.

734
00:45:46,936 --> 00:45:49,037
First of all, you're adding kinetic energy

735
00:45:49,097 --> 00:45:51,378
to deal with position overlap.

736
00:45:52,178 --> 00:45:56,700
And this can actually lead to instabilities in some cases.

737
00:45:57,480 --> 00:46:01,362
Also, it may make your constraints look less solid.

738
00:46:02,783 --> 00:46:06,344
So I like this idea of velocity steering,

739
00:46:06,384 --> 00:46:10,526
but I don't like it feeding into the velocities that I have.

740
00:46:11,496 --> 00:46:16,940
So what you can do is you can completely decouple the position correction problem.

741
00:46:17,140 --> 00:46:24,226
And instead of dealing with the real velocities, use pseudo-velocities and also pseudo-impulses.

742
00:46:25,186 --> 00:46:30,450
So but we can use the same machinery that we had set up for solving velocity constraints

743
00:46:30,930 --> 00:46:32,372
to solve position constraints.

744
00:46:36,498 --> 00:46:37,719
So here's how it works.

745
00:46:37,959 --> 00:46:44,382
So I set up Newton's Law using the pseudo-velocity,

746
00:46:44,582 --> 00:46:45,523
pseudo-impulses.

747
00:46:48,007 --> 00:46:50,328
Then I have like a pseudo velocity constraint,

748
00:46:50,449 --> 00:46:52,490
and I use the same solution technique.

749
00:46:52,990 --> 00:46:59,853
But those pseudo velocities only exist for that one iteration.

750
00:46:59,913 --> 00:47:00,974
So they start out zero.

751
00:47:01,014 --> 00:47:02,635
So there's no concept of momentum.

752
00:47:03,055 --> 00:47:07,097
Also, those impulses, I don't need any warm starting

753
00:47:07,137 --> 00:47:07,457
because.

754
00:47:09,985 --> 00:47:12,926
If the position constraint is satisfied,

755
00:47:13,427 --> 00:47:16,629
then those pseudo-impulses should be zero,

756
00:47:16,989 --> 00:47:18,610
because there's no external loading.

757
00:47:19,250 --> 00:47:24,373
So, actually, when you converge on the position overlap,

758
00:47:24,773 --> 00:47:27,395
those pseudo-impulses go to zero.

759
00:47:29,236 --> 00:47:31,557
You also need to remove things like friction,

760
00:47:32,137 --> 00:47:34,158
other things that are only velocity-dependent.

761
00:47:39,230 --> 00:47:42,693
You also see that in the bottom equation, the pseudo-velocity

762
00:47:42,713 --> 00:47:45,696
constraint, I've removed time, because time doesn't really

763
00:47:45,756 --> 00:47:47,477
mean anything when you don't have momentum

764
00:47:47,537 --> 00:47:51,000
and you're just trying to resolve some overlap.

765
00:47:51,661 --> 00:47:56,204
And actually, you can see that then these pseudo-velocities

766
00:47:56,484 --> 00:48:00,388
are just like delta positions.

767
00:48:01,789 --> 00:48:03,170
They don't have time involved either.

768
00:48:06,433 --> 00:48:08,234
And this method.

769
00:48:10,708 --> 00:48:15,112
It's basically an iterative method for solving a non-linear equation.

770
00:48:15,372 --> 00:48:21,997
Because the position constraint is basically a non-linear equation.

771
00:48:27,762 --> 00:48:32,605
So to resolve positions, now I have this separate solver

772
00:48:32,685 --> 00:48:35,047
that happens after the velocity solver.

773
00:48:36,112 --> 00:48:37,972
So now there's this extra iteration load.

774
00:48:38,572 --> 00:48:45,055
It's not too bad because I found in practice I don't need as many iterations for the velocity solver.

775
00:48:46,255 --> 00:48:48,876
I mean for the position solvers I need for the velocity solver.

776
00:48:50,597 --> 00:48:55,939
So, where the velocity solver I might use 8 iterations, for the position solver I use 2 or 3 iterations.

777
00:48:59,680 --> 00:49:00,160
Alright, so...

778
00:49:02,515 --> 00:49:06,377
We saw that velocity constraints were better than acceleration constraints.

779
00:49:08,959 --> 00:49:11,880
Does that mean position constraints are better than velocity constraints?

780
00:49:13,942 --> 00:49:16,723
Well, in cloth solvers, like a Verlet solver,

781
00:49:17,464 --> 00:49:20,365
we actually deal with position constraints directly.

782
00:49:20,465 --> 00:49:25,068
So, typically you're dealing with these distance constraints between two particles,

783
00:49:25,148 --> 00:49:27,630
and you just, you know, that's a nonlinear constraint,

784
00:49:28,190 --> 00:49:31,812
but you can solve it exactly by either moving the points apart or together.

785
00:49:32,881 --> 00:49:40,784
And so we're not actually solving any velocity constraints there, we're just adjusting positions.

786
00:49:41,604 --> 00:49:46,586
But we still want some concept of momentum, and the way that works in a cloth solver is

787
00:49:46,606 --> 00:49:51,868
you basically record the position at the beginning of the time step, then you go solve all the

788
00:49:51,928 --> 00:49:56,610
distance constraints, you get the new position, and then you just...

789
00:49:57,375 --> 00:50:01,380
Compute the velocity from that change in position and divide by the time step.

790
00:50:01,420 --> 00:50:05,585
So that way the constraints kind of affect the momentum there.

791
00:50:08,188 --> 00:50:11,732
Another example of a position solver is a character solver.

792
00:50:12,593 --> 00:50:15,737
Character solvers are used to move avatars around in the game world.

793
00:50:16,658 --> 00:50:19,520
The main job is to prevent the character from moving through walls.

794
00:50:19,960 --> 00:50:24,023
But the motion may not, you may not want that to be governed by rigid body rules.

795
00:50:24,043 --> 00:50:27,386
You may want, like, gameplay code governing the motion.

796
00:50:27,446 --> 00:50:31,569
So, it's just purely a collision solution method.

797
00:50:34,371 --> 00:50:34,511
So...

798
00:50:35,688 --> 00:50:38,610
What you often see for these character solvers in games is

799
00:50:39,010 --> 00:50:42,392
they will actually use a velocity solver, whether they know it or not.

800
00:50:42,732 --> 00:50:50,558
So you have some, say this character solver is just using a collision circle,

801
00:50:51,318 --> 00:50:54,400
and it's sweeping across the world and it hits some plane.

802
00:50:56,181 --> 00:51:00,064
And it says, well, okay, the way I'm going to handle that is I'm just going to clip

803
00:51:00,684 --> 00:51:04,487
the velocity against that plane, and now, okay, now my velocity is going up that plane.

804
00:51:06,202 --> 00:51:12,524
But I don't know why you would do it this way, because you're still going to have to deal with some position problems.

805
00:51:12,864 --> 00:51:16,185
You may get some overlap. Things may be spawned inside of each other.

806
00:51:16,205 --> 00:51:19,505
So you still have to deal with the position problem.

807
00:51:20,086 --> 00:51:24,067
Also, we don't want any friction sliding along the wall.

808
00:51:24,567 --> 00:51:28,688
So that would be good if I'm doing velocity type of solver to have friction.

809
00:51:29,415 --> 00:51:30,735
Normally we don't want friction.

810
00:51:31,275 --> 00:51:34,056
So we can actually just use a position solver

811
00:51:34,336 --> 00:51:35,456
to solve that same problem.

812
00:51:35,856 --> 00:51:38,217
And that will allow us to deal with overlap as well.

813
00:51:38,697 --> 00:51:40,837
So here's how the position solver would work.

814
00:51:41,317 --> 00:51:43,958
So you start at point P1, and then you

815
00:51:43,998 --> 00:51:45,078
move to the target point.

816
00:51:45,538 --> 00:51:47,859
Along that path, you may do a shape cast, and you say,

817
00:51:47,939 --> 00:51:48,839
oh, there's a plane there.

818
00:51:48,879 --> 00:51:50,019
I need to deal with that plane.

819
00:51:50,519 --> 00:51:54,080
So move to that target point, and then just

820
00:51:54,140 --> 00:51:55,360
project onto the plane.

821
00:51:57,083 --> 00:51:59,324
And that's pretty much it. It is quite simple.

822
00:52:00,905 --> 00:52:05,906
And you can generalize this to deal with multiple planes.

823
00:52:06,486 --> 00:52:10,668
And it actually looks a lot like the position solver.

824
00:52:15,632 --> 00:52:18,594
You can kind of express this as an optimization problem.

825
00:52:18,674 --> 00:52:20,174
I want to minimize the distance

826
00:52:20,755 --> 00:52:23,456
between the final position of the character

827
00:52:23,596 --> 00:52:24,737
and the target position,

828
00:52:25,437 --> 00:52:27,638
subject to a bunch of plane constraints.

829
00:52:28,878 --> 00:52:35,141
And, yeah, here's how the solver is structured in pseudocode.

830
00:52:36,169 --> 00:52:38,292
So we move to the target position,

831
00:52:38,473 --> 00:52:40,055
then for some number of iterations,

832
00:52:40,115 --> 00:52:41,597
we iterate over all the planes.

833
00:52:42,038 --> 00:52:44,101
If I find that the character is behind any plane,

834
00:52:44,141 --> 00:52:45,463
I project it onto the surface.

835
00:52:52,915 --> 00:52:55,137
Any local solver, there's going to be some downside.

836
00:52:55,637 --> 00:53:00,720
So the downside for this kind of local solver is acute angles.

837
00:53:01,500 --> 00:53:04,502
Now you could say, well, I can solve for two planes at once,

838
00:53:04,582 --> 00:53:06,303
and so I can deal with those acute angles.

839
00:53:06,383 --> 00:53:09,545
But in reality, in complex games,

840
00:53:09,565 --> 00:53:12,807
you may get really complex collision,

841
00:53:12,967 --> 00:53:15,188
and you have lots and lots of planes to deal with.

842
00:53:15,628 --> 00:53:17,869
And then you're back to solving some big matrix problem.

843
00:53:20,168 --> 00:53:26,350
It turns out that using the iterative solver works out well in practice,

844
00:53:27,110 --> 00:53:28,710
mainly because it is super cheap.

845
00:53:29,690 --> 00:53:34,131
So I never see that thing be nearly as expensive as doing all the collision detection.

846
00:53:35,831 --> 00:53:38,432
So with acute angles, what happens is

847
00:53:39,592 --> 00:53:42,633
you move to the target point and then you start projecting onto the planes

848
00:53:42,773 --> 00:53:46,273
and then you just see this ping-ponging as you're trying to solve each plane.

849
00:53:46,909 --> 00:53:49,050
So it takes a bit more iterations,

850
00:53:49,110 --> 00:53:51,572
and the more acute the angle, the more iterations you need.

851
00:53:54,334 --> 00:53:54,934
All right, so...

852
00:53:57,195 --> 00:54:00,878
basically, in terms of understanding constraints today,

853
00:54:00,978 --> 00:54:04,600
what I've covered is convergence, inequality,

854
00:54:05,100 --> 00:54:07,121
and acceleration position constraints.

855
00:54:07,141 --> 00:54:10,543
There's other topics for understanding constraints,

856
00:54:10,584 --> 00:54:12,204
but I think this is a good start

857
00:54:12,224 --> 00:54:13,605
at understanding these aspects,

858
00:54:13,705 --> 00:54:16,267
and it will give you a lot of tools to deal with...

859
00:54:17,095 --> 00:54:18,476
making your games more robust.

860
00:54:19,436 --> 00:54:20,556
So thank you.

861
00:54:21,056 --> 00:54:22,096
Here's some references.

862
00:54:22,777 --> 00:54:24,417
You'll be able to download these slides

863
00:54:25,017 --> 00:54:26,857
and the scripts.

864
00:54:28,898 --> 00:54:30,478
And you can reach me on Twitter

865
00:54:31,038 --> 00:54:32,699
or at pox2d.org.

866
00:54:33,479 --> 00:54:34,899
I'll leave the references up

867
00:54:35,159 --> 00:54:38,640
and I'd be happy to answer any questions.

868
00:54:40,220 --> 00:54:43,001
Please step up to Mike if you want to ask a question.

869
00:54:47,690 --> 00:54:50,612
Hi, I don't have a question. I just want to thank you for Box2D.

870
00:54:51,273 --> 00:54:51,693
You're welcome.

871
00:54:55,197 --> 00:54:55,537
Thank you.

872
00:55:08,389 --> 00:55:09,590
Okay, now it's working. Okay.

873
00:55:10,491 --> 00:55:13,574
I just wanted to ask you that you're now working at Blizzard.

874
00:55:14,874 --> 00:55:18,195
Are you now working mainly with 3D physics there?

875
00:55:18,956 --> 00:55:25,199
And what kind of differences do you have added challenges regarding, for example, the constraints in 3D?

876
00:55:26,319 --> 00:55:28,460
3D, the biggest problem is rotations.

877
00:55:28,701 --> 00:55:32,422
Rotations become much more complex in 3D.

878
00:55:32,542 --> 00:55:35,484
But a lot of the same convergence problems exist there.

879
00:55:35,624 --> 00:55:42,427
So you can understand quite a bit about dealing with constraints just by looking at 2D, even in 1D.

880
00:55:44,500 --> 00:55:47,301
That's a big reason why I work on Box2D, actually,

881
00:55:47,361 --> 00:55:50,763
is so I can understand these kind of fundamental problems

882
00:55:50,843 --> 00:55:52,043
at a simpler level.

883
00:55:52,063 --> 00:55:56,565
Hi.

884
00:55:57,665 --> 00:55:59,286
Well, as far as I understand you,

885
00:55:59,666 --> 00:56:03,228
you do not recommend to use acceleration constraints.

886
00:56:03,248 --> 00:56:04,008
Correct.

887
00:56:04,788 --> 00:56:07,729
You recommend to use velocity constraints

888
00:56:07,809 --> 00:56:10,991
for objects in gravity or in some kind of force field.

889
00:56:11,471 --> 00:56:11,611
Yes?

890
00:56:12,664 --> 00:56:17,147
And you recommend to use position constraints for characters.

891
00:56:18,969 --> 00:56:19,870
Yes, yes.

892
00:56:20,650 --> 00:56:21,031
Thank you.

893
00:56:21,051 --> 00:56:23,032
You're welcome.

894
00:56:23,052 --> 00:56:26,816
All right, well thank you very much.

895
00:56:27,436 --> 00:56:30,379
Coming up at 11.15 we're gonna have Erwin Koomans

896
00:56:30,539 --> 00:56:31,520
talking about Featherstone.

