1
00:00:07,098 --> 00:00:12,581
Reminder to do all of your after talk survey stuff.

2
00:00:14,201 --> 00:00:15,542
But let's get right into it.

3
00:00:19,664 --> 00:00:20,464
So I'm Mike Acton.

4
00:00:20,504 --> 00:00:22,385
I'm the engine director at Insomniac Games.

5
00:00:22,686 --> 00:00:26,187
And today I'm going to talk about solving Nintendo's

6
00:00:26,227 --> 00:00:27,028
Coding Game Challenge.

7
00:00:27,048 --> 00:00:28,168
So if you don't know, Coding Game is.

8
00:00:29,519 --> 00:00:32,021
An online site where you do sort of a game,

9
00:00:33,101 --> 00:00:37,305
it's sort of a programming competition site.

10
00:00:37,545 --> 00:00:39,627
So they provide specific challenges.

11
00:00:39,667 --> 00:00:40,748
People go on there and solve them.

12
00:00:41,388 --> 00:00:42,169
It's good for practice.

13
00:00:42,209 --> 00:00:43,950
There's lots of sites like it, lots of hacker sites,

14
00:00:44,010 --> 00:00:45,392
similar kinds of things.

15
00:00:46,693 --> 00:00:50,736
But the fact that Nintendo sponsored a challenge

16
00:00:51,377 --> 00:00:52,898
is the thing that caught my eye specifically.

17
00:00:52,918 --> 00:00:55,080
I'm like, OK, well this probably has something to do with games.

18
00:00:56,861 --> 00:00:57,803
It makes it interesting to me.

19
00:00:58,945 --> 00:01:00,807
All of my steps, all the things I'm about to show you,

20
00:01:00,847 --> 00:01:03,251
including this particular document, are on GitHub.

21
00:01:03,391 --> 00:01:03,932
There's the link.

22
00:01:05,034 --> 00:01:09,801
So you can pull that and follow along if you like.

23
00:01:11,246 --> 00:01:14,829
So, today's talk is about process, not solution.

24
00:01:15,470 --> 00:01:19,053
This, I'm just walking through my personal process

25
00:01:19,653 --> 00:01:20,474
of solving this problem.

26
00:01:21,515 --> 00:01:23,397
There are probably a million other ways of tackling

27
00:01:23,437 --> 00:01:24,237
this particular problem.

28
00:01:24,357 --> 00:01:25,318
This was mine.

29
00:01:26,760 --> 00:01:28,541
I may walk through the solution as part of

30
00:01:28,581 --> 00:01:30,443
talking about the process, but that is not the point.

31
00:01:33,022 --> 00:01:35,164
So I'm gonna walk through basically all the test code,

32
00:01:36,305 --> 00:01:38,447
or at least a significant portion of the test code

33
00:01:38,467 --> 00:01:40,749
and versions that I created while I solved the problem.

34
00:01:41,890 --> 00:01:44,913
So from test zero zero to test one F,

35
00:01:45,593 --> 00:01:46,834
and just sort of work my way through it

36
00:01:46,874 --> 00:01:48,536
and tell you what I was thinking as I was going

37
00:01:49,016 --> 00:01:50,197
and why I was writing each thing.

38
00:01:51,568 --> 00:01:52,729
So, starting with test zero.

39
00:01:53,530 --> 00:01:54,091
Test zero zero.

40
00:01:54,191 --> 00:01:54,952
What's the question?

41
00:01:55,513 --> 00:01:56,273
What am I trying to solve?

42
00:01:56,293 --> 00:01:57,895
Can I get any insight into that?

43
00:01:58,816 --> 00:02:00,118
So, going on to the site.

44
00:02:01,119 --> 00:02:02,381
This was the question that was presented.

45
00:02:02,401 --> 00:02:06,465
The SETI program has received a series of messages

46
00:02:06,505 --> 00:02:07,486
from Alpha Centauri.

47
00:02:07,527 --> 00:02:09,489
The most frequent message seems to be, blah blah blah.

48
00:02:10,410 --> 00:02:12,632
It is not known why any of these messages are encoded,

49
00:02:12,652 --> 00:02:14,755
but there's a good chance that the Alpha Centurions

50
00:02:14,855 --> 00:02:17,258
are trying to evaluate our cognitive abilities

51
00:02:17,298 --> 00:02:19,420
before establishing advanced contact.

52
00:02:20,401 --> 00:02:22,563
Our best engineers are working to encode this messages,

53
00:02:23,144 --> 00:02:23,965
et cetera, et cetera.

54
00:02:23,985 --> 00:02:25,727
So there's a lot of flower, right?

55
00:02:25,747 --> 00:02:28,210
A lot of flower language around the problem.

56
00:02:30,183 --> 00:02:34,765
And at the bottom is presented some pseudocode of the encoding program.

57
00:02:35,825 --> 00:02:38,306
So I read this, right?

58
00:02:38,346 --> 00:02:39,467
Try to get excited about the problem.

59
00:02:40,587 --> 00:02:43,868
So the first thing I need to do is I need to take away all the flowery language.

60
00:02:43,908 --> 00:02:47,130
I need to figure out what it is that this is actually describing.

61
00:02:47,150 --> 00:02:49,231
So to summarize the problem.

62
00:02:58,292 --> 00:03:01,475
We have some function which given A returns B.

63
00:03:02,717 --> 00:03:06,080
In terms of the problem space here, we're given B and F.

64
00:03:06,401 --> 00:03:08,463
And we have to return all the A which satisfy that.

65
00:03:09,524 --> 00:03:13,348
A and B can be 64, 128, 256, or 512 bits.

66
00:03:13,448 --> 00:03:16,091
So it's a pretty straightforward description, problem description.

67
00:03:17,833 --> 00:03:21,216
So in our case, in my case, I called f encode,

68
00:03:22,157 --> 00:03:26,060
and so the inverse of that is decode.

69
00:03:26,480 --> 00:03:30,323
So b equals encode a, and decode b returns some set of a,

70
00:03:30,443 --> 00:03:34,626
things that could have been encoded to create that b.

71
00:03:34,767 --> 00:03:38,269
So taking the pseudocode and the C++ code

72
00:03:38,409 --> 00:03:41,832
that was provided, here's the encode function

73
00:03:41,952 --> 00:03:45,015
as basically as delivered as part of the problem description.

74
00:03:46,792 --> 00:03:49,133
And looking at it, in my process I'm looking at it,

75
00:03:49,153 --> 00:03:52,294
so it says there in comments, magic Centurion operation.

76
00:03:53,275 --> 00:03:54,976
I can't really decipher what's happening

77
00:03:55,296 --> 00:03:57,016
just by looking at this bit of code.

78
00:03:57,717 --> 00:03:59,497
So my goal here is really just to understand

79
00:03:59,537 --> 00:04:01,578
what uncode does before I get deeper

80
00:04:01,638 --> 00:04:03,739
into trying to write a decode function.

81
00:04:05,927 --> 00:04:08,468
That's the most important thing to me, first, is what does Encode do?

82
00:04:09,289 --> 00:04:11,750
So first thing I do is I test Encode with random ints.

83
00:04:12,310 --> 00:04:14,772
And if you saw Squirrel's talk, you know, you know,

84
00:04:14,872 --> 00:04:17,653
getting a good set of random values is important.

85
00:04:18,594 --> 00:04:21,656
And so what I did, and what I generally do, is go to random.org,

86
00:04:21,676 --> 00:04:24,657
which has an amazing set of actually properly random values

87
00:04:24,677 --> 00:04:25,438
that you can just download.

88
00:04:26,038 --> 00:04:29,219
at any given time and use essentially as a noise table.

89
00:04:30,299 --> 00:04:32,400
So I wanted to be able to repeat all of my tests

90
00:04:32,440 --> 00:04:33,601
constantly over and over again,

91
00:04:33,621 --> 00:04:36,282
so I have the same random table that I'm constantly using.

92
00:04:37,282 --> 00:04:38,502
So I just downloaded a set of that,

93
00:04:38,562 --> 00:04:39,923
created a random ints.h,

94
00:04:39,983 --> 00:04:42,164
and now I know for the rest of time here,

95
00:04:42,264 --> 00:04:43,324
all my tests are gonna be the same.

96
00:04:45,288 --> 00:04:48,110
So, for test zero zero, I'm just sort of printing out

97
00:04:48,811 --> 00:04:52,274
what the encode function, this magic encode function does. I just want to have a look at it

98
00:04:52,314 --> 00:04:53,034
and see if there's anything

99
00:04:53,575 --> 00:04:54,035
I can see.

100
00:04:54,616 --> 00:04:57,418
So you can see I'm just looping through my test count, which is my random ints.

101
00:04:57,718 --> 00:05:00,921
I'm calling the encode function, I'm just printing it out. That's it. Printing out the results.

102
00:05:00,941 --> 00:05:01,902
I just want to see what it looks like.

103
00:05:03,503 --> 00:05:03,903
Looks like this.

104
00:05:05,253 --> 00:05:08,735
So I spent a lot of time literally just staring at this, the whole output.

105
00:05:09,055 --> 00:05:10,956
I'm looking for patterns, things that appear,

106
00:05:11,036 --> 00:05:12,216
anything that looks interesting.

107
00:05:12,236 --> 00:05:15,218
And nothing really pops at me at this point.

108
00:05:15,258 --> 00:05:16,959
So now I have to actually dig in deeper.

109
00:05:17,039 --> 00:05:17,359
OK.

110
00:05:17,419 --> 00:05:18,679
I have to actually do some analysis.

111
00:05:18,699 --> 00:05:19,640
There's nothing super obvious.

112
00:05:20,574 --> 00:05:21,894
So that's what test01 is.

113
00:05:22,055 --> 00:05:25,756
Is there any obvious connection between encode, input, and output?

114
00:05:25,776 --> 00:05:27,716
So I'm testing a bunch of obvious stuff,

115
00:05:28,236 --> 00:05:30,997
but the most obvious thing to look for is,

116
00:05:31,257 --> 00:05:37,039
is there a correlation between the bits of the output and the bits of the input?

117
00:05:37,399 --> 00:05:39,079
So I'm testing here, specifically,

118
00:05:39,599 --> 00:05:42,260
what's the probability of a bit of B being on,

119
00:05:42,600 --> 00:05:44,101
given the same bit of A?

120
00:05:44,721 --> 00:05:46,501
And that's just this simple function.

121
00:05:47,542 --> 00:05:51,887
So in pseudocode, all test one does is sort of loop through all the random tests,

122
00:05:51,927 --> 00:05:54,729
and for each bit in each one of the results, it counts up,

123
00:05:55,150 --> 00:05:57,953
here are the bits, here are the counts for all the bits in A,

124
00:05:57,993 --> 00:05:59,334
here are the counts for all the bits in B,

125
00:05:59,594 --> 00:06:03,478
and just calculates the probability of B given A for every single bit.

126
00:06:05,941 --> 00:06:06,842
And so I looked at the results.

127
00:06:07,865 --> 00:06:10,386
So from 0 to 63, all the bits.

128
00:06:12,267 --> 00:06:16,668
If I look at the middle bits here, so basically everything in the middle,

129
00:06:17,748 --> 00:06:18,949
super not interesting, right?

130
00:06:19,209 --> 00:06:20,689
Basically, they're all hovering around 0.5,

131
00:06:21,369 --> 00:06:24,870
so they're all essentially random, given whatever A is,

132
00:06:24,910 --> 00:06:29,652
there's no correlation with B. But the first,

133
00:06:29,672 --> 00:06:31,632
there's sort of a chunk at the top and a chunk of the bottom

134
00:06:31,893 --> 00:06:32,873
that are much more interesting.

135
00:06:34,053 --> 00:06:35,314
And I can see it's sort of scaling up.

136
00:06:35,354 --> 00:06:36,594
So I'll start with, you know, the...

137
00:06:37,259 --> 00:06:39,741
you know, given A, the probability of B being on

138
00:06:40,041 --> 00:06:42,123
is only 23%, so, or 24%.

139
00:06:42,963 --> 00:06:45,726
So it's a sort of high correlation between those two bits.

140
00:06:46,106 --> 00:06:47,247
And it's sort of, you know,

141
00:06:47,687 --> 00:06:50,770
decreasing over the first few bits.

142
00:06:51,250 --> 00:06:52,171
And sort of at the end, too,

143
00:06:52,211 --> 00:06:53,492
there's this sort of bunching up

144
00:06:54,213 --> 00:06:56,174
of a much higher correlation of bits.

145
00:06:56,294 --> 00:06:58,216
So I thought, okay, well, this is super interesting, right?

146
00:07:00,029 --> 00:07:01,110
So maybe there's something I can do with this.

147
00:07:01,851 --> 00:07:04,513
So this is where I went off on a super long tangent, which

148
00:07:04,533 --> 00:07:05,494
I won't really get into.

149
00:07:05,514 --> 00:07:08,336
But this is sort of the state machine generator.

150
00:07:08,356 --> 00:07:09,637
And this is totally a path that you

151
00:07:09,657 --> 00:07:11,539
can take to solve this problem, but it is absolutely

152
00:07:11,559 --> 00:07:13,080
the long way around this problem.

153
00:07:14,441 --> 00:07:17,083
So you just start with what's needed to get the first bit of B

154
00:07:17,143 --> 00:07:17,524
to be set.

155
00:07:17,564 --> 00:07:19,165
So everything that I need to know in order to set,

156
00:07:19,245 --> 00:07:21,007
definitely know that the first bit of B is set.

157
00:07:21,607 --> 00:07:23,669
And then I move on to say, given that I

158
00:07:23,729 --> 00:07:26,871
know what the first bit of B is and what I need to know,

159
00:07:27,332 --> 00:07:31,116
in A, what I need to know to get the second bit of B, et cetera.

160
00:07:31,136 --> 00:07:32,797
And I just sort of loop this in on itself.

161
00:07:33,318 --> 00:07:36,521
You can basically build a state machine generator

162
00:07:36,621 --> 00:07:38,443
based on that, on those facts.

163
00:07:39,524 --> 00:07:41,646
And again, like I said, this is possible.

164
00:07:41,807 --> 00:07:43,048
It is totally solvable this way.

165
00:07:43,108 --> 00:07:44,629
It is just a really, really long way

166
00:07:44,669 --> 00:07:45,650
around solving this problem.

167
00:07:46,912 --> 00:07:48,293
So as I'm deep into this.

168
00:07:49,767 --> 00:07:55,454
this approach. It occurs to me that I missed a super obvious test, and that's test02 here.

169
00:07:56,876 --> 00:08:00,361
Instead of just looking at random outputs, I'm going to recheck with ordered outputs.

170
00:08:02,135 --> 00:08:03,875
So now this is what I'm doing here, test02.

171
00:08:04,475 --> 00:08:06,516
Testing encode with ordered values.

172
00:08:07,356 --> 00:08:11,557
So for my input, A, I'm just setting a fixed upper 32 bits

173
00:08:12,117 --> 00:08:14,338
and the lower 32 bits is just an incrementing value.

174
00:08:14,398 --> 00:08:16,158
So for however many tests I have,

175
00:08:16,198 --> 00:08:17,858
it just starts with zero, one, two, three,

176
00:08:17,878 --> 00:08:19,879
and I encode that and I wanna look at B.

177
00:08:20,519 --> 00:08:22,359
So let's see what that looks like.

178
00:08:23,520 --> 00:08:25,060
Well, dang.

179
00:08:26,020 --> 00:08:27,400
That's a lot more interesting.

180
00:08:27,560 --> 00:08:29,421
There's a lot more correlation going on here.

181
00:08:30,197 --> 00:08:33,158
And if I'm looking at here, right, what's happening here,

182
00:08:33,198 --> 00:08:35,419
the top value of each of these pairs is the input,

183
00:08:35,439 --> 00:08:37,020
the bottom value of each of these pairs is the output.

184
00:08:37,720 --> 00:08:39,641
They're saying there's a lot of similarity

185
00:08:39,701 --> 00:08:40,801
between these two numbers.

186
00:08:41,261 --> 00:08:43,182
So when I'm doing it in an incremental way,

187
00:08:44,122 --> 00:08:46,403
it's a lot clearer that there's some correlation

188
00:08:46,463 --> 00:08:47,664
between the input and the output.

189
00:08:48,224 --> 00:08:49,604
My first impression when I'm looking at it,

190
00:08:49,664 --> 00:08:51,345
maybe this is some kind of gray code,

191
00:08:51,365 --> 00:08:52,325
maybe there's something going on here,

192
00:08:52,345 --> 00:08:53,546
that's sort of my first impression

193
00:08:53,646 --> 00:08:54,426
in just looking at this.

194
00:08:56,770 --> 00:09:00,332
So my next step is, OK, maybe I'll just swap the output

195
00:09:00,732 --> 00:09:03,393
and just display it in some more little-endian format

196
00:09:03,413 --> 00:09:05,414
to see if that changes anything for me visually.

197
00:09:06,574 --> 00:09:10,256
That's all I do, is I just swap the 232 bits just to say,

198
00:09:10,416 --> 00:09:12,297
maybe for me it's a little more natural.

199
00:09:12,377 --> 00:09:13,237
Maybe I see something different.

200
00:09:13,997 --> 00:09:17,099
And so that's all this is, is just

201
00:09:17,119 --> 00:09:18,859
this more little-endian format.

202
00:09:18,879 --> 00:09:21,140
I'm like, OK, well, as I'm looking through these numbers,

203
00:09:23,621 --> 00:09:25,002
I see something super interesting.

204
00:09:26,009 --> 00:09:28,391
here as I'm pouring down through the numbers

205
00:09:28,431 --> 00:09:30,994
I see there's something super interesting about each of the powers

206
00:09:31,014 --> 00:09:33,877
of two like there's there's there's something happening here

207
00:09:33,897 --> 00:09:36,300
the unique to just the powers of two in terms

208
00:09:36,340 --> 00:09:37,581
of the A in terms of the input.

209
00:09:38,963 --> 00:09:41,486
So my next step is let's just

210
00:09:41,666 --> 00:09:43,808
print out the powers of two. Let's just look at that.

211
00:09:43,848 --> 00:09:44,809
Let's see what's happening with that.

212
00:09:46,934 --> 00:09:49,497
So now, test 04.

213
00:09:49,557 --> 00:09:52,020
So test 04, I look at just all the powers of 2.

214
00:09:52,501 --> 00:09:55,144
Now, you can look at this, and even without knowing what's

215
00:09:55,164 --> 00:09:56,826
going on here, you can see that there's a visual pattern.

216
00:09:56,887 --> 00:09:59,991
You can see this left shifting going on

217
00:10:00,071 --> 00:10:01,292
of the inputs and outputs.

218
00:10:01,873 --> 00:10:06,196
So there's clearly something interesting happening in the powers of two.

219
00:10:06,697 --> 00:10:09,299
And in fact, I look at each individual one of these,

220
00:10:09,659 --> 00:10:11,400
and I can see the same thing going on.

221
00:10:11,720 --> 00:10:14,042
So I have a of a0 and a1.

222
00:10:14,262 --> 00:10:17,665
So remember, sort of little Indians, the right side here is a0, and the left side is a1.

223
00:10:19,506 --> 00:10:24,970
And so we start with a0, and it looks like what's happening is b is just sort of the a0 shifted left.

224
00:10:26,391 --> 00:10:30,374
And the amount that's shifted left by is basically the trailing zero count of...

225
00:10:32,068 --> 00:10:38,036
A1. So I have some questions now. Like, is

226
00:10:38,096 --> 00:10:40,239
it, what's happening if A1 is not a

227
00:10:40,279 --> 00:10:40,840
power of two?

228
00:10:43,163 --> 00:10:44,204
So what do I do?

229
00:10:45,438 --> 00:10:50,020
I pick any arbitrary number, I just happen to pick 0F in this case, I pick an arbitrary

230
00:10:50,060 --> 00:10:57,383
number and I just break it up into its constituent powers of two, and in test 05, what I do is

231
00:10:57,443 --> 00:11:05,166
I say print out encoding of 1, 2, 4, and 8, and then the final value, F, and show me what

232
00:11:05,186 --> 00:11:05,586
that looks like.

233
00:11:05,606 --> 00:11:09,408
So I can see what's the correlation between the final value and all the powers of two

234
00:11:09,428 --> 00:11:10,288
that it's made up out of.

235
00:11:11,128 --> 00:11:13,049
So this is what that print out looked like.

236
00:11:14,400 --> 00:11:15,681
So here's a input.

237
00:11:15,721 --> 00:11:18,884
Here's the powers of 1, 2, 4, 8, the powers of 2 that make up

238
00:11:19,084 --> 00:11:20,305
f and f at the bottom.

239
00:11:21,165 --> 00:11:21,926
So I'm looking at this.

240
00:11:21,966 --> 00:11:22,767
I stare at these values.

241
00:11:22,807 --> 00:11:24,648
I look at all the variations of these values.

242
00:11:24,668 --> 00:11:25,749
I'm looking at it, and I see something

243
00:11:25,769 --> 00:11:27,471
very interesting happening here.

244
00:11:27,491 --> 00:11:28,892
And that's this.

245
00:11:29,793 --> 00:11:33,235
I look at the final value, f, at the bottom.

246
00:11:33,416 --> 00:11:36,678
And it's really just the xor down the columns of all

247
00:11:36,698 --> 00:11:38,400
the power of 2 values there.

248
00:11:39,501 --> 00:11:42,703
So the first bit, the 0 bit at the right-hand side

249
00:11:42,763 --> 00:11:43,264
is just really.

250
00:11:44,656 --> 00:11:46,698
one XOR zero, XOR zero, XOR zero.

251
00:11:48,480 --> 00:11:51,263
The second column similarly, it's one XOR one,

252
00:11:51,383 --> 00:11:53,185
XOR zero, XOR zero, zero at the bottom.

253
00:11:53,706 --> 00:11:55,247
And so I see that all the way across.

254
00:11:56,729 --> 00:11:58,491
So I find that very interesting.

255
00:11:58,511 --> 00:12:03,317
So now I have kind of a theory of how this encode works.

256
00:12:05,470 --> 00:12:11,292
So given where A and B are 64 bits, and I can break up A into two 32-bit segments,

257
00:12:11,372 --> 00:12:12,753
it kind of looks like this.

258
00:12:13,613 --> 00:12:16,034
So I loop through all the bits of A0.

259
00:12:16,854 --> 00:12:22,536
If it's on, then B XORs with A1, shifted left by whatever the current bit

260
00:12:22,556 --> 00:12:23,116
that I'm on there.

261
00:12:24,558 --> 00:12:28,802
So this should duplicate the work that we saw, that I saw there.

262
00:12:28,822 --> 00:12:31,344
So now I have to test that.

263
00:12:31,384 --> 00:12:33,806
But first I want to just help myself visualize.

264
00:12:33,826 --> 00:12:37,109
So my next step is really just to re-space things.

265
00:12:37,450 --> 00:12:40,192
This doesn't provide me any value other than visual value.

266
00:12:40,292 --> 00:12:41,914
I sort of, I want to look at the problem a different way,

267
00:12:41,954 --> 00:12:43,035
which is a lot of what I do.

268
00:12:43,115 --> 00:12:45,317
I just print it out in a different way just to look at it.

269
00:12:47,522 --> 00:12:52,065
So with test7, the next thing I wanted to do was just validate across a wider sample

270
00:12:52,085 --> 00:12:52,265
set.

271
00:12:52,285 --> 00:12:53,946
Does what I'm seeing make sense?

272
00:12:54,527 --> 00:12:57,749
Because up to now, I've tested this very limited set, right?

273
00:12:58,810 --> 00:13:04,494
A0, just really small subset of values, and in fact, the last test was just literally

274
00:13:04,534 --> 00:13:05,294
just F, right?

275
00:13:05,414 --> 00:13:06,455
One single value.

276
00:13:07,616 --> 00:13:10,458
And A1 has up to this point I've just had fixed.

277
00:13:12,592 --> 00:13:13,953
So does the theory I currently have,

278
00:13:14,033 --> 00:13:15,634
in terms of what this loop is supposed to do,

279
00:13:15,654 --> 00:13:18,016
hold up across all the sample data?

280
00:13:18,456 --> 00:13:23,079
And does it change if a0 is anything other

281
00:13:23,119 --> 00:13:25,380
than the small subset values?

282
00:13:28,262 --> 00:13:31,924
So I create this alternate version, this encode 232,

283
00:13:32,845 --> 00:13:36,107
which is basically just the code version of the pseudocode

284
00:13:36,127 --> 00:13:36,627
we just saw.

285
00:13:37,908 --> 00:13:39,749
See, nothing unique or special about this.

286
00:13:42,084 --> 00:13:43,005
And I run through...

287
00:13:43,065 --> 00:13:45,407
So Test07 runs through the same random inputs,

288
00:13:45,647 --> 00:13:47,930
runs the original encode, runs this alternate version,

289
00:13:48,090 --> 00:13:49,772
and just checks to see if the results are the same.

290
00:13:49,852 --> 00:13:51,173
So this is pure sanity checking.

291
00:13:51,213 --> 00:13:53,035
Does the thing work the way I expect it to work

292
00:13:53,075 --> 00:13:55,237
across all the sample data that I'm dealing with?

293
00:13:55,858 --> 00:13:56,518
In fact, it does.

294
00:13:56,739 --> 00:13:57,499
It works fine.

295
00:13:57,640 --> 00:13:59,201
So I'm very confident now

296
00:13:59,281 --> 00:14:01,644
that this is essentially the function.

297
00:14:03,966 --> 00:14:06,649
So I want to play with some variations of the encode function at this point.

298
00:14:08,010 --> 00:14:11,834
And so all test 8 here is is just the realization that

299
00:14:12,775 --> 00:14:17,139
I can do this if this branch here and check and shift of the i,

300
00:14:17,279 --> 00:14:18,320
or I can just multiply by a1.

301
00:14:20,601 --> 00:14:22,223
And so this is just me playing with variations.

302
00:14:22,263 --> 00:14:23,404
I know these are two the same.

303
00:14:23,484 --> 00:14:25,367
Like, I know these two things are identical.

304
00:14:26,729 --> 00:14:29,192
But I rerun that test 8.

305
00:14:29,492 --> 00:14:30,474
I want to rerun it anyway.

306
00:14:30,554 --> 00:14:31,094
I create it.

307
00:14:31,155 --> 00:14:31,655
I test it.

308
00:14:31,735 --> 00:14:34,960
I rerun all my tests just for sanity's sake.

309
00:14:35,140 --> 00:14:36,762
And luckily, all the tests pass.

310
00:14:36,882 --> 00:14:38,725
I am still sane.

311
00:14:40,308 --> 00:14:41,268
So, test 9.

312
00:14:42,048 --> 00:14:44,809
So, I want to go back and revisualize everything again,

313
00:14:45,449 --> 00:14:47,430
with all the test inputs,

314
00:14:47,450 --> 00:14:48,510
so with all the random values.

315
00:14:48,530 --> 00:14:50,130
I want to see what it looks like again.

316
00:14:52,571 --> 00:14:54,091
So, test 9 is the same as test 7,

317
00:14:54,511 --> 00:14:56,652
but that encode 232 that I created

318
00:14:57,332 --> 00:14:59,432
just prints out all the steps as it's going.

319
00:14:59,452 --> 00:15:01,753
And so, me injecting a bunch of printfs

320
00:15:01,773 --> 00:15:04,493
into the code that I write is pretty much how I do stuff.

321
00:15:06,354 --> 00:15:09,938
And so this is a bit of the sample output from test 09,

322
00:15:10,278 --> 00:15:12,040
which looks like this, boom.

323
00:15:12,461 --> 00:15:14,403
So printing out at every step what's happening.

324
00:15:14,903 --> 00:15:18,007
So at the top is A1, at the right hand side is A0,

325
00:15:18,067 --> 00:15:20,529
so all the bits in A0, and at the bottom here,

326
00:15:20,589 --> 00:15:21,270
the result of B.

327
00:15:21,490 --> 00:15:24,433
And as I said, each one of these columns

328
00:15:24,474 --> 00:15:25,495
sort of XORs down.

329
00:15:27,076 --> 00:15:27,236
And

330
00:15:28,277 --> 00:15:29,298
So the results are as I expected,

331
00:15:29,318 --> 00:15:30,559
but visually it's super interesting.

332
00:15:30,579 --> 00:15:34,721
Because now I look at this, and I say, well, looking at this way

333
00:15:34,741 --> 00:15:36,322
and looking at a bigger case like this,

334
00:15:36,422 --> 00:15:38,563
a very specific, you know, these test cases,

335
00:15:39,124 --> 00:15:41,065
this looks suspiciously like some kind

336
00:15:41,085 --> 00:15:43,226
of longhand multiplication, right?

337
00:15:43,646 --> 00:15:46,988
But for each place, there's something different going on,

338
00:15:47,088 --> 00:15:47,448
right?

339
00:15:47,588 --> 00:15:50,070
Instead of multiplication, it's really just anding.

340
00:15:50,130 --> 00:15:52,651
Instead of addition, it's sort of an xor.

341
00:15:55,007 --> 00:15:56,788
So, you know, we have this multiplication.

342
00:15:57,488 --> 00:15:59,610
Instead of multiplication, right, we have and,

343
00:15:59,670 --> 00:16:01,831
so only one times one is one.

344
00:16:02,452 --> 00:16:06,174
And for addition, we have this truth table.

345
00:16:07,029 --> 00:16:09,392
So this is what's going on. So the question is what fits this model?

346
00:16:10,694 --> 00:16:13,717
You know, if this isn't really integer multiplication,

347
00:16:14,498 --> 00:16:18,303
but it is some kind of long-hand multiplication, what fits this model?

348
00:16:18,743 --> 00:16:22,348
In fact, there is something that perfectly fits this model.

349
00:16:22,508 --> 00:16:25,291
Multiplication of a polynomial over GF2 fits this model perfectly.

350
00:16:25,772 --> 00:16:31,394
If you don't happen to know that fact, I don't know how you get from what I saw to this.

351
00:16:31,955 --> 00:16:32,995
This is a massive leap.

352
00:16:33,755 --> 00:16:36,857
And the problem is that you can't just search for those tables.

353
00:16:37,257 --> 00:16:38,097
Right? It's very difficult.

354
00:16:38,457 --> 00:16:43,840
So my suggestion is, in the case where I happen to not know these kinds of things,

355
00:16:43,860 --> 00:16:46,841
where I hit this kind of block, and I know there must be something that's called this,

356
00:16:47,522 --> 00:16:51,602
Often what I'll do is I'll write a bit of code that prints out a bunch of numbers in

357
00:16:51,762 --> 00:16:56,883
order and then I can search the integer database online for something that matches those numbers

358
00:16:56,923 --> 00:16:59,544
and I can see what things that fit that model.

359
00:16:59,564 --> 00:17:01,704
So that's generally my approach to those.

360
00:17:02,664 --> 00:17:07,245
So GF2 basically just means a finite field of two elements.

361
00:17:09,666 --> 00:17:13,987
So we can see here if I look up GF2 on Wikipedia, those tables look super, super familiar.

362
00:17:14,127 --> 00:17:16,127
Those are identical tables that we just created.

363
00:17:18,532 --> 00:17:22,056
So as programmers, when we talk about finite fields, as programmers we use finite fields all the time.

364
00:17:23,117 --> 00:17:28,163
So if I were to say you have a uint8 a and we put ff in it,

365
00:17:28,524 --> 00:17:29,765
and I asked you what is a plus two,

366
00:17:30,486 --> 00:17:33,169
probably most of you could tell me what the answer to that question is.

367
00:17:33,710 --> 00:17:35,572
And we know because it just, we know.

368
00:17:36,513 --> 00:17:38,453
that it just wraps around a certain number of finite things.

369
00:17:38,974 --> 00:17:42,635
We know that it's just sort of just mod of 8 bits here.

370
00:17:43,655 --> 00:17:46,596
And in GF2, really all that means is all the math is mod 2.

371
00:17:48,097 --> 00:17:49,077
So 1 bit.

372
00:17:49,837 --> 00:17:52,538
It's super simple, super easy to understand.

373
00:17:53,418 --> 00:17:57,420
Really nice overview of what's happening in finite fields

374
00:17:57,460 --> 00:17:58,880
is this particular paper, which I totally

375
00:17:58,920 --> 00:18:01,261
recommend reading if this is something that interests you.

376
00:18:03,582 --> 00:18:06,484
What does it mean to represent a polynomial over GF2?

377
00:18:07,585 --> 00:18:10,388
So the exponent is implicit in its place, right?

378
00:18:11,549 --> 00:18:12,609
And the coefficient is stored.

379
00:18:12,690 --> 00:18:14,691
And the coefficient here in GF2,

380
00:18:14,751 --> 00:18:17,353
because everything is mod 2, can only be 1 or 0.

381
00:18:17,834 --> 00:18:18,995
So if we take a particular example, 1011...

382
00:18:21,056 --> 00:18:23,117
The exponent is implicit, right?

383
00:18:23,157 --> 00:18:25,298
So we're going from the right to the left,

384
00:18:26,059 --> 00:18:29,140
x to the zero, x to the one, x to the two, x to the three,

385
00:18:29,220 --> 00:18:30,801
sort of as you would expect moving from the right

386
00:18:30,821 --> 00:18:31,181
to the left.

387
00:18:31,801 --> 00:18:33,402
And so that's one, zero, one, one,

388
00:18:33,582 --> 00:18:36,423
which maps to x to the third plus x plus one.

389
00:18:36,443 --> 00:18:38,064
You can see how sort of it maps.

390
00:18:41,452 --> 00:18:43,033
So next test, right?

391
00:18:43,213 --> 00:18:46,476
I want, now I kind of have a model and I have a theory.

392
00:18:46,836 --> 00:18:48,998
I have a theory that what Encode is actually doing

393
00:18:49,638 --> 00:18:52,360
is multiplying polynomials over GF2.

394
00:18:52,440 --> 00:18:55,662
Everything so far in my model fits perfectly to this fact.

395
00:18:57,123 --> 00:18:58,324
I don't care if this is the reality.

396
00:18:58,444 --> 00:18:59,525
The model fits correctly,

397
00:18:59,605 --> 00:19:02,027
so that's as far as I'm concerned is the reality, right?

398
00:19:02,047 --> 00:19:03,528
If the model fits, it's correct.

399
00:19:05,149 --> 00:19:06,270
So I want to create a new function.

400
00:19:07,429 --> 00:19:12,512
called pgf2mul and just rework things in these terms,

401
00:19:12,973 --> 00:19:14,374
knowing that I should get the same results.

402
00:19:14,974 --> 00:19:17,896
So I create this gf2, 0, 0, dot c,

403
00:19:18,416 --> 00:19:21,558
and I start writing things in these terms at this point.

404
00:19:22,319 --> 00:19:25,641
So I create a gf2mul, gf2add, which is just XOR,

405
00:19:25,761 --> 00:19:28,823
and a gf2 shift left logical,

406
00:19:28,863 --> 00:19:30,023
which kind of does as you'd expect

407
00:19:30,063 --> 00:19:31,744
and just shifts the whole value over.

408
00:19:32,385 --> 00:19:36,969
So this is what multiply does, which is very reminiscent of the other version of the encode

409
00:19:37,009 --> 00:19:37,470
that we saw.

410
00:19:37,510 --> 00:19:40,692
It sort of tests that, goes through all the bits, tests the bit.

411
00:19:40,913 --> 00:19:45,837
If the bit is set, then it adds it in, which is the same as XOR, and then it shifts over

412
00:19:46,217 --> 00:19:48,319
the A so we can continue moving along.

413
00:19:48,439 --> 00:19:57,127
So as you can imagine, it's that sort of kind of longhand multiply going on here in a recognizable

414
00:19:57,267 --> 00:19:57,468
form.

415
00:19:59,539 --> 00:20:04,864
I rerun this function against all the same tests and all the tests passed.

416
00:20:04,904 --> 00:20:08,648
So I'm getting exactly the same results, it's just formulated in a different way.

417
00:20:10,066 --> 00:20:13,108
So test OB, it's another sanity test.

418
00:20:13,128 --> 00:20:14,869
Now I want to make sure that after I've

419
00:20:15,089 --> 00:20:16,770
sort of doing all this work and reformulating it,

420
00:20:17,151 --> 00:20:18,912
do all the other expected bit widths work?

421
00:20:19,372 --> 00:20:23,435
I've really just been focused on the 64-bit version right now.

422
00:20:24,015 --> 00:20:26,197
But I want to make sure that all this other stuff works.

423
00:20:26,297 --> 00:20:29,819
So I need to verify these cases where B can be 128 or 256

424
00:20:30,360 --> 00:20:31,280
or 512 bits.

425
00:20:31,860 --> 00:20:34,462
So test OB is the same as the previous test, this test OA

426
00:20:34,482 --> 00:20:34,963
that we just did.

427
00:20:35,903 --> 00:20:38,966
but I've extended it to all the above, all these cases.

428
00:20:39,326 --> 00:20:41,388
I'm using the exact same random number tables,

429
00:20:41,448 --> 00:20:42,849
they're the same random values,

430
00:20:42,869 --> 00:20:44,550
I'm just sort of casting them wider.

431
00:20:45,371 --> 00:20:47,633
So instead of taking the first 32 bits of the table,

432
00:20:47,653 --> 00:20:49,434
I'm taking the second, the first two,

433
00:20:49,494 --> 00:20:52,357
and casting that as 64, the first four,

434
00:20:52,397 --> 00:20:53,418
and casting that as 128.

435
00:20:55,339 --> 00:20:57,101
And so running all the tests passed.

436
00:20:57,121 --> 00:20:58,702
So I'm pretty convinced at this point

437
00:20:58,742 --> 00:20:59,703
that this is in fact the model.

438
00:20:59,743 --> 00:21:01,084
This is in fact what Encode does

439
00:21:01,144 --> 00:21:03,646
across all of the bit depths, I'm pretty good.

440
00:21:05,939 --> 00:21:08,963
So with testoc, now I think I know, pretty sure,

441
00:21:09,544 --> 00:21:12,127
what encode means, what could decode mean?

442
00:21:12,568 --> 00:21:13,389
So this is where I get to the point

443
00:21:13,409 --> 00:21:15,872
where I'm actually trying to solve the actual problem here.

444
00:21:17,254 --> 00:21:19,617
So if encode is GF2 mul, what does decode do?

445
00:21:19,657 --> 00:21:21,319
Well, what's the reverse of multiply?

446
00:21:21,359 --> 00:21:22,861
And that's factor, right?

447
00:21:24,663 --> 00:21:27,045
So now I'm going to take a look at the provided test cases.

448
00:21:28,065 --> 00:21:29,567
So here's test case one that's provided.

449
00:21:30,627 --> 00:21:35,511
And now with my insight into what's

450
00:21:35,551 --> 00:21:37,833
happening in the encode function, a lot of stuff

451
00:21:37,953 --> 00:21:39,133
really becomes a lot more obvious.

452
00:21:40,655 --> 00:21:43,216
So I can look at the input and output,

453
00:21:43,357 --> 00:21:44,597
and I can sort of interpret it.

454
00:21:46,413 --> 00:21:50,378
So I see that the input is some 64-bit polynomial

455
00:21:51,299 --> 00:21:53,201
in sort of little-endian format,

456
00:21:53,982 --> 00:21:57,065
where only this sort of bottom 16 bits

457
00:21:57,366 --> 00:21:58,047
have anything in them.

458
00:21:59,408 --> 00:22:00,810
And I can say, what's factor?

459
00:22:00,870 --> 00:22:02,972
Well, the first is that that same number,

460
00:22:02,992 --> 00:22:03,733
that same number.

461
00:22:04,494 --> 00:22:06,835
as a polynomial times one is it,

462
00:22:07,475 --> 00:22:10,096
and that same number times one is the same value.

463
00:22:10,156 --> 00:22:11,716
So that makes sense in terms of factoring.

464
00:22:12,377 --> 00:22:14,978
And I can presume here that some polynomial

465
00:22:14,998 --> 00:22:19,079
represented by 83 times some polynomial represented by E5

466
00:22:19,419 --> 00:22:21,780
multiplies 273af, and I can see the reverse

467
00:22:21,960 --> 00:22:22,721
immediately underneath it.

468
00:22:23,761 --> 00:22:27,004
And so the thing is though, as I'm looking through these other test cases,

469
00:22:27,044 --> 00:22:29,466
and you can see the same pattern here with one times the same number

470
00:22:29,526 --> 00:22:31,107
and these two numbers that are flipped.

471
00:22:32,628 --> 00:22:36,492
And these two numbers, you know, there's two pairs here that are the same.

472
00:22:37,492 --> 00:22:38,954
As I'm looking through these test cases...

473
00:22:41,148 --> 00:22:42,869
it really, really should have been obvious to me

474
00:22:42,889 --> 00:22:44,470
when I was looking at the test cases originally

475
00:22:45,090 --> 00:22:47,412
that this was sort of a multiply factor thing.

476
00:22:48,333 --> 00:22:49,593
When I see this sort of pairs

477
00:22:49,613 --> 00:22:50,974
and I'm looking at something times one

478
00:22:51,034 --> 00:22:52,976
and it really should have been a lot more obvious

479
00:22:52,996 --> 00:22:53,856
but it totally wasn't.

480
00:22:53,936 --> 00:22:55,637
I totally missed this looking at the original cases.

481
00:22:55,677 --> 00:22:57,999
I had to go through this process for me personally

482
00:22:58,019 --> 00:22:59,860
of visualizing all that data and going through it

483
00:22:59,880 --> 00:23:02,122
and walking through it and recreating in code

484
00:23:02,142 --> 00:23:04,623
in order to then in hindsight

485
00:23:04,723 --> 00:23:06,304
see what's going on in those test cases.

486
00:23:08,126 --> 00:23:09,446
So now with TestOC, moving on.

487
00:23:11,021 --> 00:23:13,162
I want to just print all those tests,

488
00:23:13,182 --> 00:23:14,823
take all those test cases and print them out

489
00:23:15,064 --> 00:23:16,405
in polynomial format.

490
00:23:16,745 --> 00:23:18,506
So this is just for me personally

491
00:23:18,626 --> 00:23:20,308
for visualization purposes.

492
00:23:21,108 --> 00:23:22,789
So go through each of the test cases

493
00:23:22,830 --> 00:23:25,091
and print it out like you see here.

494
00:23:25,892 --> 00:23:28,294
So instead of this value,

495
00:23:28,454 --> 00:23:29,555
instead of these values up top,

496
00:23:29,595 --> 00:23:33,518
it's just printing out the same values in polynomial format.

497
00:23:34,478 --> 00:23:36,280
So I look at this particular case and we said,

498
00:23:36,640 --> 00:23:37,641
all right, well,

499
00:23:38,669 --> 00:23:43,831
7 3af should be a3 times e5 in as polynomials,

500
00:23:44,191 --> 00:23:47,413
which is interpreted as x to the seventh plus x plus one

501
00:23:47,493 --> 00:23:50,474
times x to the seventh plus x to the sixth

502
00:23:50,514 --> 00:23:53,116
plus x to the fifth plus x to the second plus one.

503
00:23:53,176 --> 00:23:55,557
I promise I'm gonna try not to read too many polynomials

504
00:23:55,657 --> 00:23:56,257
in the talk today.

505
00:23:58,449 --> 00:24:00,612
So the first thing I do is say, OK, if this is true,

506
00:24:01,033 --> 00:24:03,235
if this makes sense, then I should

507
00:24:03,255 --> 00:24:06,379
be able to verify this in like three seconds in Mathematica.

508
00:24:06,840 --> 00:24:09,724
So I just take the polynomial, the input polynomial here,

509
00:24:10,305 --> 00:24:12,347
and I cut and paste because I put it in a nice format

510
00:24:12,367 --> 00:24:14,370
that I can cut and paste into Mathematica, cut and paste it.

511
00:24:14,390 --> 00:24:15,712
And I say, factor this.

512
00:24:16,893 --> 00:24:21,016
And luckily enough, Mathematica can do modulus two factoring.

513
00:24:21,116 --> 00:24:22,938
So I just say, factor this, modulus two, boom.

514
00:24:23,338 --> 00:24:24,099
Those are the two values.

515
00:24:24,319 --> 00:24:26,020
In fact, those are the same identical values

516
00:24:26,061 --> 00:24:29,604
as they show up there, which are represented by 83 and E5.

517
00:24:30,164 --> 00:24:31,945
So I'm super confident now

518
00:24:31,986 --> 00:24:33,026
that we're going down the right track,

519
00:24:33,046 --> 00:24:34,608
that this makes sense.

520
00:24:34,888 --> 00:24:36,910
The lesson here is if you have a calculator, use it.

521
00:24:37,570 --> 00:24:39,812
At the very least, to verify what you're doing.

522
00:24:40,988 --> 00:24:45,249
So I go through and I cut and paste and I check all the other test cases as well.

523
00:24:45,289 --> 00:24:46,149
I just paste those in.

524
00:24:46,169 --> 00:24:46,949
Do they make sense?

525
00:24:47,109 --> 00:24:48,270
Am I getting the same values?

526
00:24:49,190 --> 00:24:51,090
And yes, indeed, they're all identical.

527
00:24:51,130 --> 00:24:53,551
They all map to what I expect them to map to.

528
00:24:55,652 --> 00:24:56,492
So test OD.

529
00:24:56,632 --> 00:24:58,292
Start figuring out what decode would need to do.

530
00:24:58,332 --> 00:24:59,153
What's the process like?

531
00:24:59,193 --> 00:24:59,733
What are the steps?

532
00:25:00,233 --> 00:25:02,393
I want to just plug this into Mathematica.

533
00:25:02,433 --> 00:25:03,774
I want to actually do the thing.

534
00:25:03,834 --> 00:25:04,634
So what does it look like?

535
00:25:06,157 --> 00:25:08,704
So at this point I can restate the problem, so I write it down.

536
00:25:09,486 --> 00:25:10,809
So given a polynomial over GF2...

537
00:25:11,831 --> 00:25:14,413
to the n, where n can be one of these bit depths,

538
00:25:16,654 --> 00:25:17,254
64, 128, 256, or 512,

539
00:25:17,314 --> 00:25:20,937
display all the pairs of factors of degree n,

540
00:25:21,717 --> 00:25:22,818
less than n divided by two,

541
00:25:22,838 --> 00:25:24,079
that's sort of a specific constraint

542
00:25:24,219 --> 00:25:26,160
to the problem definition,

543
00:25:26,460 --> 00:25:29,282
is you're just outputting these pairs of factors.

544
00:25:30,223 --> 00:25:31,483
So what if there's more than two factors?

545
00:25:31,523 --> 00:25:32,284
If you're given a polynomial

546
00:25:32,304 --> 00:25:33,465
that has a bunch of different factors,

547
00:25:33,545 --> 00:25:36,447
well, I think the answer here is you just recombine them

548
00:25:36,587 --> 00:25:38,728
until you get a pair that fits the constraint.

549
00:25:39,649 --> 00:25:40,189
So the steps.

550
00:25:41,465 --> 00:25:43,026
Find all the irreducible factors of f,

551
00:25:43,326 --> 00:25:46,569
so the smallest things that I can make up f with.

552
00:25:47,470 --> 00:25:49,952
Recombine those until I get pairs that fit.

553
00:25:50,592 --> 00:25:52,053
Format and sort the results and output.

554
00:25:52,494 --> 00:25:53,574
Seems fairly straightforward,

555
00:25:53,815 --> 00:25:57,938
except that I don't know how to factor polynomials over GF2.

556
00:25:58,018 --> 00:25:59,099
So this is my next step.

557
00:25:59,139 --> 00:26:00,560
How do I figure, what do I do?

558
00:26:00,620 --> 00:26:01,321
How do I figure this out?

559
00:26:01,901 --> 00:26:04,123
So I ask myself, what would Knuth do, right?

560
00:26:06,505 --> 00:26:07,826
So, crack open the book.

561
00:26:08,380 --> 00:26:11,702
I don't know about you, but I find

562
00:26:11,942 --> 00:26:14,123
auto-computer programming super handy for reference.

563
00:26:14,143 --> 00:26:15,684
I find it super handy for when I already,

564
00:26:15,984 --> 00:26:17,585
basically when I already know the answer.

565
00:26:17,605 --> 00:26:19,506
I'm just looking it up, or I'm just reminding myself

566
00:26:19,526 --> 00:26:21,006
I just want to know a finer point.

567
00:26:21,266 --> 00:26:22,747
When I don't actually know the answer,

568
00:26:22,847 --> 00:26:24,508
it's super hard for me to understand

569
00:26:24,608 --> 00:26:25,729
what's going on in there.

570
00:26:27,630 --> 00:26:31,452
And this particular set of solutions is no exception to that.

571
00:26:32,913 --> 00:26:34,814
So, but to point you, give you reference,

572
00:26:34,994 --> 00:26:39,416
volume two, section 462, factorization of polynomials,

573
00:26:39,436 --> 00:26:41,157
which is perfectly what I'm looking for here.

574
00:26:42,357 --> 00:26:44,578
And the finer point of that particular page is this,

575
00:26:45,339 --> 00:26:47,120
this half of the page is pretty much the steps

576
00:26:47,160 --> 00:26:47,780
that we need to do.

577
00:26:49,805 --> 00:26:52,686
But again, in my first glance here,

578
00:26:52,706 --> 00:26:54,747
in my first pass of this section and this page

579
00:26:54,787 --> 00:26:55,868
and this part of this page,

580
00:26:56,328 --> 00:26:58,449
it's super terse because I didn't really understand

581
00:26:58,469 --> 00:26:58,969
what was going on.

582
00:26:58,989 --> 00:27:00,830
I didn't, it was very hard for me to read

583
00:27:00,890 --> 00:27:02,390
because I didn't already know the answer.

584
00:27:03,519 --> 00:27:05,500
But luckily, we're given a hint.

585
00:27:05,660 --> 00:27:10,263
I was given a hint anyway here, which is the name of the thing that I need to Google in

586
00:27:10,303 --> 00:27:12,444
order to understand, which is Berlikamp's factoring algorithm.

587
00:27:12,804 --> 00:27:17,566
All right, so after a bunch of Googling and reading and going, I found this one paper,

588
00:27:17,686 --> 00:27:17,786
right?

589
00:27:17,806 --> 00:27:22,229
There's lots of papers on this particular thing, but I found personally this particular

590
00:27:22,269 --> 00:27:24,570
paper the most useful, the most straightforward description.

591
00:27:26,971 --> 00:27:28,872
And I provide a link here if you're interested.

592
00:27:29,392 --> 00:27:30,932
It's very short, it's like nine pages.

593
00:27:30,952 --> 00:27:32,673
And it has a worked example,

594
00:27:32,753 --> 00:27:34,313
which I always find super useful,

595
00:27:34,353 --> 00:27:35,794
like if you actually work through an example.

596
00:27:37,614 --> 00:27:40,755
So to go back to this now, okay, let's look at step one.

597
00:27:40,815 --> 00:27:42,956
So I know, okay, I kind of got a better idea

598
00:27:42,976 --> 00:27:45,257
of what this means, what Berlecan's factoring algorithm

599
00:27:45,337 --> 00:27:46,657
means because I've read this other paper.

600
00:27:48,118 --> 00:27:49,738
Now let's go back, I'm gonna work on step one.

601
00:27:50,438 --> 00:27:53,839
Step one, B1, ensure that UX is square free.

602
00:27:54,039 --> 00:27:54,340
All right.

603
00:27:55,080 --> 00:27:55,680
What does that mean?

604
00:27:55,980 --> 00:27:58,902
It means we have a polynomial, say, A,

605
00:27:59,362 --> 00:28:03,024
which is made of the factors B squared, C, D.

606
00:28:03,264 --> 00:28:04,905
We're pulling out the squared factors.

607
00:28:04,945 --> 00:28:07,086
In this case, B squared is the factor we're pulling out.

608
00:28:07,446 --> 00:28:08,707
So we end up with two things.

609
00:28:08,727 --> 00:28:12,469
A0 is B squared, and A1 is C, D. So those combined back

610
00:28:12,489 --> 00:28:14,410
together would be A. That's what we mean.

611
00:28:14,450 --> 00:28:17,771
We're pulling out the stuff that is squared out of here.

612
00:28:19,725 --> 00:28:21,466
So, square-free factorization.

613
00:28:22,027 --> 00:28:25,170
ux has a square factor if the GCD of ux

614
00:28:25,550 --> 00:28:28,153
and the derivative of ux is not one.

615
00:28:29,314 --> 00:28:32,817
So, just create steps out of that.

616
00:28:33,638 --> 00:28:36,401
The first is, given some ux, which we're gonna call f,

617
00:28:37,081 --> 00:28:39,504
which I call f, get the derivative of f.

618
00:28:40,173 --> 00:28:42,935
Get the GCD of f and the derivative of f, call that g.

619
00:28:43,355 --> 00:28:46,618
So f is made of g times some h, which we don't know yet,

620
00:28:46,658 --> 00:28:49,741
but since we know g, we can just say f divided by g is that h.

621
00:28:50,101 --> 00:28:51,542
So fairly straightforward process here,

622
00:28:51,882 --> 00:28:55,045
except, which I'll get to in a minute,

623
00:28:55,405 --> 00:28:57,046
let's start with an example with a square in it.

624
00:28:57,907 --> 00:29:00,368
So I just create an example, any example,

625
00:29:00,608 --> 00:29:03,330
fairly complicated one, enough to sort of know

626
00:29:03,370 --> 00:29:04,490
that things are going right or wrong.

627
00:29:04,830 --> 00:29:06,851
In the middle of that, circled at the bottom here,

628
00:29:07,291 --> 00:29:10,913
is a squared factor, just so I know what I'm dealing with.

629
00:29:12,234 --> 00:29:15,555
So I'm gonna pull out that square factor manually,

630
00:29:15,956 --> 00:29:17,637
so just by hand here.

631
00:29:18,077 --> 00:29:20,258
I know what I want in my A, I know what I want in my B,

632
00:29:20,718 --> 00:29:21,819
so I know what's left in my B.

633
00:29:22,059 --> 00:29:23,760
So in testOD, I'm just gonna multiply

634
00:29:23,880 --> 00:29:25,100
all these little things here.

635
00:29:25,907 --> 00:29:28,832
left that are left in B together and print out with the results.

636
00:29:28,892 --> 00:29:29,973
So what should I expect from B?

637
00:29:30,033 --> 00:29:31,395
So I already know how to multiply.

638
00:29:31,436 --> 00:29:32,637
We've already done it a bunch of times.

639
00:29:32,717 --> 00:29:36,042
But again, just to sort of sanity test and verify what I'm doing,

640
00:29:36,082 --> 00:29:36,944
I keep doing it anyway.

641
00:29:37,504 --> 00:29:39,147
So I multiply all these things back together.

642
00:29:39,788 --> 00:29:40,509
And this is what I get.

643
00:29:41,810 --> 00:29:43,311
For B, I know this is what I want to be.

644
00:29:43,371 --> 00:29:45,713
I verify this by, again, throwing it back into Mathematica

645
00:29:45,773 --> 00:29:47,254
and making sure that all the factors are correct.

646
00:29:48,655 --> 00:29:52,257
So after a square-free factorization,

647
00:29:52,377 --> 00:29:53,518
I know that these are the two values

648
00:29:53,538 --> 00:29:56,040
that I should be getting, which is the A and B here.

649
00:29:56,440 --> 00:29:58,001
The A is the squared value that's pulled out.

650
00:29:58,021 --> 00:30:00,043
So I know what I'm looking for.

651
00:30:02,612 --> 00:30:04,252
But I have a bunch of things that I need to figure out how to do.

652
00:30:05,113 --> 00:30:07,934
So for instance, how would you take the derivative

653
00:30:08,314 --> 00:30:10,515
of a polynomial over GF2?

654
00:30:10,695 --> 00:30:11,255
I don't know.

655
00:30:11,375 --> 00:30:12,396
I didn't know at this point.

656
00:30:13,556 --> 00:30:14,596
So let's start there.

657
00:30:15,877 --> 00:30:18,338
So let's just review the regular process really quick.

658
00:30:19,178 --> 00:30:23,600
So we have the derivative of x squared plus x plus 1 with respect to x.

659
00:30:23,660 --> 00:30:25,741
The mechanical process for that is really simple, right?

660
00:30:26,501 --> 00:30:28,722
We multiply each exponent with its coefficient

661
00:30:28,802 --> 00:30:30,323
and subtract 1 from each exponent.

662
00:30:31,123 --> 00:30:31,643
We're left with.

663
00:30:32,824 --> 00:30:35,805
2x plus one, fairly straightforward mechanical process.

664
00:30:36,406 --> 00:30:39,327
But over GF2, it's the same mechanical steps,

665
00:30:39,527 --> 00:30:42,549
but all the math in GF2 is mod two.

666
00:30:42,649 --> 00:30:46,111
So our two, our two in 2x plus one,

667
00:30:46,151 --> 00:30:49,352
the two there is two mod zero, which is zero.

668
00:30:50,273 --> 00:30:51,694
So our derivative of...

669
00:30:52,654 --> 00:30:57,421
x squared plus x plus 1 over GF2 with respect to x is in fact 1,

670
00:30:58,002 --> 00:30:59,484
because the 2x becomes 0.

671
00:31:00,545 --> 00:31:04,791
To put a finer point on it, the process for taking the derivative in GF2

672
00:31:04,891 --> 00:31:06,193
is all the coefficients are 0.

673
00:31:06,634 --> 00:31:07,054
That already.

674
00:31:07,115 --> 00:31:07,816
Everything is mod 0.

675
00:31:08,196 --> 00:31:08,897
Everything is mod 2.

676
00:31:09,998 --> 00:31:14,800
All the even exponents will be multiplied by either zero or one to get the coefficient.

677
00:31:16,120 --> 00:31:20,241
The result is that the coefficient of each one of those will either be even or zero.

678
00:31:20,502 --> 00:31:23,623
All even values are zero, so they're all going to be zero.

679
00:31:24,303 --> 00:31:27,184
So we can just mask out all the even exponents, we don't need any of them.

680
00:31:28,184 --> 00:31:31,725
All the odd exponents will be multiplied by zero or one to get a coefficient.

681
00:31:32,646 --> 00:31:37,327
The resulting coefficient is either odd or zero, or all odd values mod two are one.

682
00:31:38,628 --> 00:31:46,114
So we can reduce, we can just reduce all the odd exponents by one, which is the same as saying shift everything right one place.

683
00:31:48,236 --> 00:31:51,378
So in terms of process, this is what it looks like. So we take this particular example. 101111.

684
00:31:52,599 --> 00:32:02,067
We zero out the even exponents because we know those don't matter because anything, those even numbers all multiply by whatever are going to be even.

685
00:32:03,018 --> 00:32:04,339
and all are going to be zero.

686
00:32:04,399 --> 00:32:06,360
So we just zero, just mask those out.

687
00:32:06,701 --> 00:32:09,423
We just shift everything else over one place,

688
00:32:09,763 --> 00:32:11,825
and we're left with, in this particular example,

689
00:32:13,646 --> 00:32:15,368
x to the fourth plus x to the second plus one,

690
00:32:15,868 --> 00:32:17,169
which is as I'd expect.

691
00:32:19,351 --> 00:32:20,492
Which as far as I'm concerned at this point,

692
00:32:20,552 --> 00:32:21,893
is just witchcraft.

693
00:32:22,273 --> 00:32:25,056
Like the fact that getting the derivative is so easy

694
00:32:25,116 --> 00:32:26,637
and so straightforward is amazing.

695
00:32:29,421 --> 00:32:33,923
So in testOE, I'm just printing out example derivatives

696
00:32:34,703 --> 00:32:36,944
just to check, to see that what I'm doing is right,

697
00:32:36,964 --> 00:32:38,205
and what makes sense, and what's going on.

698
00:32:38,525 --> 00:32:40,406
So I take this A value, and I print the derivative of it,

699
00:32:40,466 --> 00:32:41,486
and it all looks OK.

700
00:32:42,627 --> 00:32:46,609
So the next step, testOF, what do

701
00:32:46,649 --> 00:32:50,710
I need to find the greatest common divisor of two

702
00:32:50,730 --> 00:32:51,371
polynomials?

703
00:32:52,031 --> 00:32:54,552
Because my next step here is g is the GCD of f

704
00:32:54,732 --> 00:32:55,693
and the derivative of f.

705
00:32:57,498 --> 00:33:02,000
So, how do I get the GCD of polynomial over GF2?

706
00:33:02,400 --> 00:33:04,721
Well, in fact, like most things in this process,

707
00:33:04,761 --> 00:33:07,282
it's the same as the GCD of any two polynomials,

708
00:33:07,342 --> 00:33:08,863
only the coefficient math is in GF2,

709
00:33:08,943 --> 00:33:09,883
so everything is mod two.

710
00:33:10,844 --> 00:33:14,045
So, reviewing how to get the GCD,

711
00:33:14,345 --> 00:33:18,867
it's basically GCD of A and B is the GCD of B and A mod B.

712
00:33:21,014 --> 00:33:23,015
So we just go through this process.

713
00:33:23,035 --> 00:33:25,095
We do a mod b, and we check to see if it's 0.

714
00:33:26,356 --> 00:33:29,937
And if it's not 0, we just keep going through the loop.

715
00:33:32,058 --> 00:33:35,319
But a mod b presents a problem, because it

716
00:33:35,819 --> 00:33:38,960
implies that I need to do polynomial division over GF2,

717
00:33:40,021 --> 00:33:41,781
because the mod is just the remainder of the division.

718
00:33:41,861 --> 00:33:44,442
So how do I divide a polynomial over GF2?

719
00:33:44,482 --> 00:33:47,283
Again, it's the same as dividing regular polynomials.

720
00:33:47,923 --> 00:33:49,864
Only coefficient of math is all in GF2.

721
00:33:51,369 --> 00:33:55,532
So if we're going to start with what's how does regular polynomial long division work, right?

722
00:33:55,632 --> 00:33:58,915
We can see here is this particular example. I won't read all of it

723
00:33:59,255 --> 00:34:05,840
But starting with how many times is x plus 1 go into x to the third? We just need that first bit here

724
00:34:05,921 --> 00:34:10,824
We just say it goes in x squared and so we multiply those out and then we go down the process there

725
00:34:11,405 --> 00:34:14,507
But I can visualize that another way and I know lots of people visualize it this way

726
00:34:16,058 --> 00:34:22,142
And you just deal with the components and forget about the coefficients and forget about

727
00:34:22,343 --> 00:34:25,045
all the variables in this particular case.

728
00:34:25,185 --> 00:34:29,008
Just dealing with the coefficients because it's much easier to read and reason about.

729
00:34:29,028 --> 00:34:30,789
So you can see here.

730
00:34:32,311 --> 00:34:37,836
1, minus 6, 11, and minus 6 are the coefficients of the same as x to the third minus 6x to

731
00:34:37,917 --> 00:34:39,899
the second plus 11x minus 6, right?

732
00:34:40,359 --> 00:34:42,341
And 1, 1 there is x plus 1.

733
00:34:43,362 --> 00:34:49,469
So in terms of doing this process, right, how many times does 1, 1 go in, how many times

734
00:34:49,489 --> 00:34:50,730
does it need to be multiplied in order to make 1?

735
00:34:51,171 --> 00:34:52,913
It just needs to be multiplied by 1.

736
00:34:53,173 --> 00:34:54,074
We subtract those out.

737
00:34:54,674 --> 00:34:55,455
We get negative 7.

738
00:34:55,515 --> 00:34:58,638
How many times does 1, 1 need to go to be multiplied by to make

739
00:34:58,698 --> 00:34:59,319
negative 7?

740
00:34:59,739 --> 00:35:00,580
Is negative 7.

741
00:35:00,620 --> 00:35:05,084
So we multiply those, subtract those out, and we get 18 minus 6.

742
00:35:05,184 --> 00:35:06,986
How many times does that need to be multiplied by 1? 18.

743
00:35:07,186 --> 00:35:09,628
And we subtract those, and we have a remainder.

744
00:35:11,570 --> 00:35:12,611
The same process, right?

745
00:35:13,452 --> 00:35:13,632
But.

746
00:35:14,757 --> 00:35:16,317
In GF2, it's going to be a little bit different.

747
00:35:16,818 --> 00:35:19,799
But if we're looking at the process of polynomial division,

748
00:35:20,680 --> 00:35:22,821
we know that we basically need two operations.

749
00:35:23,521 --> 00:35:25,202
We need multiplication and subtraction.

750
00:35:25,302 --> 00:35:26,743
Multiplication we already have.

751
00:35:26,843 --> 00:35:27,803
We already know how to do that.

752
00:35:27,843 --> 00:35:28,444
It's just and.

753
00:35:28,844 --> 00:35:30,485
Subtraction, though, this is the first time

754
00:35:30,525 --> 00:35:32,466
I've had to deal with subtraction in this process.

755
00:35:33,466 --> 00:35:34,767
But everything, again, is mod 2.

756
00:35:34,887 --> 00:35:35,887
So 0 minus 0 is 0.

757
00:35:35,947 --> 00:35:36,928
0 minus 1 is minus 1.

758
00:35:36,968 --> 00:35:37,388
Mod 2 is 1.

759
00:35:39,769 --> 00:35:41,731
1 minus 0 is 1, and 1 minus 1 is 0.

760
00:35:41,911 --> 00:35:44,612
So this is our truth table for subtracting coefficients.

761
00:35:44,972 --> 00:35:46,714
In fact, that truth table is exactly the same

762
00:35:46,754 --> 00:35:48,435
as the one for addition, which is just XOR.

763
00:35:48,495 --> 00:35:51,777
So subtraction and addition in GF2 are exactly the same,

764
00:35:52,557 --> 00:35:54,238
which is super, super interesting and fascinating.

765
00:35:54,558 --> 00:35:56,519
It also means that any code that I write in GF2

766
00:35:56,539 --> 00:35:59,481
will not work in any other finite field definition,

767
00:35:59,561 --> 00:36:01,262
because I am guaranteed to screw that up

768
00:36:02,323 --> 00:36:04,184
and just use addition or subtraction everywhere.

769
00:36:05,855 --> 00:36:07,055
So, test of.

770
00:36:07,656 --> 00:36:09,076
Now I just want to print out a work example.

771
00:36:09,116 --> 00:36:11,877
So I create this pgf2 div print.

772
00:36:12,618 --> 00:36:14,318
It's a version of the divide algorithm

773
00:36:14,358 --> 00:36:16,419
that prints out all the individual steps

774
00:36:16,759 --> 00:36:19,620
as it's dividing two values.

775
00:36:20,981 --> 00:36:23,202
So I'm dividing A by B here,

776
00:36:23,402 --> 00:36:25,082
and it's exactly in the same format

777
00:36:25,563 --> 00:36:26,623
that I showed before.

778
00:36:28,529 --> 00:36:31,292
And part of the reason that format is valuable to me

779
00:36:31,373 --> 00:36:32,974
is it's easier to print F, honestly.

780
00:36:34,256 --> 00:36:38,120
So how many times does the right-hand side need to go?

781
00:36:38,821 --> 00:36:40,803
Does it need to be multiplied to the left-hand side just one?

782
00:36:40,844 --> 00:36:42,025
It's always going to be one or zero.

783
00:36:43,186 --> 00:36:46,951
And we just go down and get our result.

784
00:36:48,205 --> 00:36:50,387
But the fact that I can visualize it and look through all the steps and look

785
00:36:50,407 --> 00:36:53,069
through any particular example is super helpful part of my process.

786
00:36:53,589 --> 00:36:57,012
And it seems like a lot of these steps where I'm printing out a lot of extra

787
00:36:57,032 --> 00:37:00,174
things, I'm printing out a lot of extra steps, you know, is it worth that?

788
00:37:00,334 --> 00:37:01,235
Is it worth me doing?

789
00:37:01,935 --> 00:37:02,776
Inevitably, yes.

790
00:37:02,956 --> 00:37:05,978
Inevitably, it's always worth me going through the extra effort of printing out

791
00:37:06,098 --> 00:37:08,580
a formatted version of what I'm working on.

792
00:37:09,641 --> 00:37:11,282
because eventually I'm gonna hit some bug.

793
00:37:11,682 --> 00:37:13,164
Eventually I'm gonna be stuck on something

794
00:37:13,204 --> 00:37:14,845
and I'm gonna wanna visualize all the steps

795
00:37:14,885 --> 00:37:16,126
and make sure that everything is right

796
00:37:16,486 --> 00:37:18,628
or wondering why this one case doesn't work.

797
00:37:18,708 --> 00:37:20,169
It's almost always worth doing.

798
00:37:21,570 --> 00:37:22,470
So in terms of division,

799
00:37:22,510 --> 00:37:24,012
this is pretty much what it's doing,

800
00:37:24,032 --> 00:37:27,654
which is as you'd expect, as we described.

801
00:37:27,754 --> 00:37:29,135
So we're going through the count.

802
00:37:30,276 --> 00:37:33,318
We're shifting left the quotient by one bit.

803
00:37:34,079 --> 00:37:35,780
We're checking to see if that top bit is set

804
00:37:35,840 --> 00:37:37,842
because we're only gonna be multiplying by zero or one.

805
00:37:38,983 --> 00:37:41,365
And if it's set, we're setting, we're adding,

806
00:37:41,605 --> 00:37:43,566
setting that one quotient bit at the bottom.

807
00:37:44,827 --> 00:37:46,328
And we're shifting the divisor left

808
00:37:46,348 --> 00:37:48,570
to the appropriate amount so that we can subtract

809
00:37:48,830 --> 00:37:49,571
and we're subtracting.

810
00:37:50,952 --> 00:37:52,813
And as you can see here at number six,

811
00:37:53,134 --> 00:37:54,975
in fact I call add instead of subtract.

812
00:37:55,055 --> 00:37:57,157
So that whole guarantee where I would definitely

813
00:37:57,197 --> 00:38:00,619
get things wrong if we're doing anything in not GF2

814
00:38:01,500 --> 00:38:02,201
is definitely true.

815
00:38:03,482 --> 00:38:04,883
But add and subtract are the same in GF2.

816
00:38:06,749 --> 00:38:08,370
All right, so now moving on, test 1.0.

817
00:38:10,432 --> 00:38:12,594
So now I think I have enough parts here

818
00:38:12,614 --> 00:38:15,876
to actually get the GCD of two polynomials over GF2.

819
00:38:16,757 --> 00:38:18,378
I have mod, I have all the things, right?

820
00:38:18,438 --> 00:38:19,059
Can I do this?

821
00:38:20,380 --> 00:38:21,961
In fact, so I build this function.

822
00:38:23,296 --> 00:38:28,143
Pgf2 gcd, which just does pretty much this loop, right?

823
00:38:28,824 --> 00:38:30,886
As you expect, looping through, I get the remainder,

824
00:38:30,906 --> 00:38:32,208
I check to see if the remainder is zero,

825
00:38:32,228 --> 00:38:33,790
if it's done, if it is, I'm done.

826
00:38:33,810 --> 00:38:35,072
If the remainder is one, I'm also done.

827
00:38:37,135 --> 00:38:38,297
If the greatest common divisor is one,

828
00:38:38,317 --> 00:38:39,899
the relative prime, so I can bail out here.

829
00:38:42,319 --> 00:38:43,560
And then I just loop it around.

830
00:38:43,580 --> 00:38:45,942
This is a while loop, so I just keep looping around with the,

831
00:38:46,263 --> 00:38:47,564
until I'm finished.

832
00:38:47,624 --> 00:38:50,066
So this is, we have all the pieces, I can't test this.

833
00:38:50,446 --> 00:38:52,708
Now I want to make sure that, in fact, it's all good,

834
00:38:52,748 --> 00:38:53,148
it's right.

835
00:38:53,769 --> 00:38:55,971
So I get my example here, I print it out,

836
00:38:55,991 --> 00:38:57,812
print out the GCD, so everything's printed out.

837
00:38:58,273 --> 00:39:00,775
And then I cut and paste, again, cut and paste my,

838
00:39:02,316 --> 00:39:04,757
my f here into Mathematica.

839
00:39:05,137 --> 00:39:06,578
I say polynomial GCD,

840
00:39:06,718 --> 00:39:10,120
this value and this value modulus two.

841
00:39:10,340 --> 00:39:11,520
And in fact, the result is the same.

842
00:39:11,600 --> 00:39:13,841
So I can test a bunch of values here,

843
00:39:13,881 --> 00:39:15,562
be fairly confident that what I'm doing is correct.

844
00:39:18,744 --> 00:39:20,344
Now I think, now I have,

845
00:39:20,644 --> 00:39:22,345
now I have division and multiplication,

846
00:39:22,485 --> 00:39:24,686
GCD and derivative.

847
00:39:24,766 --> 00:39:27,027
I think I have all the parts to do square-free factorization.

848
00:39:29,058 --> 00:39:30,838
This, the steps four and five here,

849
00:39:30,918 --> 00:39:32,739
just multiplication, division, so we're good there.

850
00:39:32,759 --> 00:39:33,819
I already know how to do that.

851
00:39:33,879 --> 00:39:36,760
So I jump right into creating GF2 SFF,

852
00:39:36,880 --> 00:39:37,760
square-free factorization.

853
00:39:37,780 --> 00:39:39,020
And I just print out,

854
00:39:39,340 --> 00:39:41,461
test11 just prints out square-free factors.

855
00:39:41,481 --> 00:39:44,142
So I just give it an input value,

856
00:39:44,762 --> 00:39:47,342
and it prints out square-free factors here

857
00:39:47,683 --> 00:39:48,703
in different formats,

858
00:39:49,303 --> 00:39:50,843
different cut-and-pasteable formats.

859
00:39:50,863 --> 00:39:54,484
So starting with binary format and hex format

860
00:39:54,724 --> 00:39:55,885
and polynomial format.

861
00:39:56,565 --> 00:40:01,989
And this last one here, SFF A0 and A1, so two versions in hex.

862
00:40:02,369 --> 00:40:03,190
Is this what we expected?

863
00:40:04,118 --> 00:40:06,259
If we go back to test D, so now I'm reaching back

864
00:40:06,299 --> 00:40:07,360
to one of the previous tests.

865
00:40:07,560 --> 00:40:09,542
And it's nice for me to have all these tests in a row.

866
00:40:09,562 --> 00:40:10,723
So I keep them all together.

867
00:40:11,523 --> 00:40:12,264
It's not just the same.

868
00:40:12,304 --> 00:40:15,006
It's just not like version-controlled versions

869
00:40:15,066 --> 00:40:15,706
of the same file.

870
00:40:15,726 --> 00:40:18,228
I keep them all in a big pile so I can refer back to them

871
00:40:18,368 --> 00:40:18,748
like this.

872
00:40:19,269 --> 00:40:21,310
So back in test D, I said, this is

873
00:40:21,330 --> 00:40:23,552
what I want to have after square-free factorization.

874
00:40:23,612 --> 00:40:25,694
In fact, these two values are identical.

875
00:40:25,714 --> 00:40:27,675
So I'm fairly confident that I'm getting the right answer here.

876
00:40:28,476 --> 00:40:28,656
Test 12.

877
00:40:29,957 --> 00:40:30,977
Now I want to build the matrix.

878
00:40:31,077 --> 00:40:31,998
Q is ascribed in.

879
00:40:33,831 --> 00:40:34,712
Step B2.

880
00:40:34,812 --> 00:40:38,716
So step B2 here says, form the matrix Q as defined by 11 and 12.

881
00:40:39,638 --> 00:40:41,540
This can be one of two ways, depending on whether or not

882
00:40:41,680 --> 00:40:43,622
P is very large as explained below.

883
00:40:43,682 --> 00:40:46,406
Let me talk a little bit about the as explained below part of this.

884
00:40:50,065 --> 00:40:51,847
I definitely felt dumb reading this.

885
00:40:52,668 --> 00:40:54,389
And this is one of those examples where I'm reading it

886
00:40:54,409 --> 00:40:57,092
and I just, it's something just I didn't understand,

887
00:40:57,152 --> 00:40:58,393
something I just missed something,

888
00:40:58,413 --> 00:41:01,876
I just, something is just obscuring my understanding

889
00:41:02,817 --> 00:41:03,598
of this description.

890
00:41:03,618 --> 00:41:06,901
And I just didn't get it, right?

891
00:41:06,961 --> 00:41:08,723
I'm reading and reading, I'm just not getting it.

892
00:41:08,943 --> 00:41:10,364
But again, that's where I reach back to

893
00:41:11,265 --> 00:41:12,246
that other paper that I mentioned,

894
00:41:12,286 --> 00:41:15,569
which sort of helped to clarify what was going on.

895
00:41:16,056 --> 00:41:19,600
But in fact, I'll tell you the real answer here is,

896
00:41:19,620 --> 00:41:21,762
I really, really wasn't getting it to the degree

897
00:41:21,882 --> 00:41:25,385
where I went to a professor of mathematics at UCLA,

898
00:41:25,405 --> 00:41:26,626
and I said, can I just pay you money

899
00:41:27,167 --> 00:41:28,789
to tell me what's going on here?

900
00:41:30,390 --> 00:41:31,191
And he said, yes.

901
00:41:32,692 --> 00:41:34,354
And I'll tell you, often, at times,

902
00:41:34,414 --> 00:41:36,817
professor of mathematics at your local university will take money.

903
00:41:37,929 --> 00:41:43,513
And he just sat down with me and we sat down for like four or five hours and just worked

904
00:41:43,533 --> 00:41:45,375
through all the holes in my understanding.

905
00:41:46,596 --> 00:41:49,458
And totally worth the money, let me tell you.

906
00:41:50,819 --> 00:41:55,382
And that's I think a legitimate way of approaching some problems where I don't know, like, I

907
00:41:55,422 --> 00:41:57,564
don't know what I'm missing, I don't know why, I don't understand this.

908
00:41:58,745 --> 00:41:59,866
And just sort of helping me through.

909
00:42:01,582 --> 00:42:06,946
But to summarize the end results here, I'll tell you how hard it was for me to get this.

910
00:42:08,567 --> 00:42:10,769
And I'm sure this is super clear to tons and tons of people.

911
00:42:10,789 --> 00:42:13,491
I'm sure there are millions of people who this was super clear to.

912
00:42:13,671 --> 00:42:18,434
For me, this moment where I could look at this and understand what it was saying was

913
00:42:18,534 --> 00:42:21,396
huge and worth hundreds of dollars.

914
00:42:23,980 --> 00:42:26,341
So the building that Q matrix looks like this,

915
00:42:27,881 --> 00:42:31,562
which is for I equals zero to the degree of P,

916
00:42:31,602 --> 00:42:33,502
and the degree of P is sort of the largest exponent P,

917
00:42:33,522 --> 00:42:35,343
where P's are polynomial.

918
00:42:36,623 --> 00:42:41,424
Each row of Q is X to the even power,

919
00:42:41,484 --> 00:42:45,524
so I times two mod P, that particular polynomial P

920
00:42:45,685 --> 00:42:47,305
that we're building a Q off of.

921
00:42:48,825 --> 00:42:49,045
So,

922
00:42:50,512 --> 00:42:54,157
This matrix is, I understand what's happening here, right?

923
00:42:54,177 --> 00:42:55,859
I understand what I'm building, I understand it mechanically,

924
00:42:56,200 --> 00:43:00,707
but getting to this point was a huge, long process of understanding.

925
00:43:01,748 --> 00:43:04,812
But in this particular paper, again, this reaches back to the other paper that I mentioned,

926
00:43:05,994 --> 00:43:07,116
there's that worked example.

927
00:43:07,476 --> 00:43:08,317
which is super nice.

928
00:43:09,438 --> 00:43:12,240
This is really, really tiny worked example

929
00:43:12,741 --> 00:43:14,462
because as often in papers, it's really hard

930
00:43:14,522 --> 00:43:15,923
to show a large worked example,

931
00:43:15,963 --> 00:43:16,824
but at least there's something.

932
00:43:17,905 --> 00:43:19,707
So given this particular F,

933
00:43:20,607 --> 00:43:22,009
this particular polynomial at the top,

934
00:43:22,369 --> 00:43:24,351
here is the matrix Q in here.

935
00:43:25,211 --> 00:43:27,033
And this is just print it, that same matrix here,

936
00:43:27,073 --> 00:43:28,754
printed out a different way, more tightly,

937
00:43:29,375 --> 00:43:30,616
but it's the same values above.

938
00:43:31,257 --> 00:43:33,639
So that's the matrix Q where F is X to the fifth

939
00:43:33,679 --> 00:43:35,240
plus X to the fourth plus one.

940
00:43:37,084 --> 00:43:40,387
So in test 12, all I want to do is verify my understanding.

941
00:43:40,627 --> 00:43:43,069
Can I get the same results as that paper?

942
00:43:43,870 --> 00:43:46,753
And I was really, really happy because one,

943
00:43:46,813 --> 00:43:48,615
I got the same results, and two, if that paper,

944
00:43:48,735 --> 00:43:50,657
if there was a bug in that paper

945
00:43:50,677 --> 00:43:51,738
and they printed out something wrong,

946
00:43:51,778 --> 00:43:53,940
I would have never, ever understood this

947
00:43:53,980 --> 00:43:55,782
because that was literally the only example

948
00:43:55,822 --> 00:43:56,583
that I had to work from.

949
00:43:57,063 --> 00:43:57,644
But luckily.

950
00:43:58,430 --> 00:43:59,471
The data in the paper is correct.

951
00:43:59,751 --> 00:44:02,553
I could replicate it and understand

952
00:44:02,593 --> 00:44:03,354
what's happening here.

953
00:44:03,474 --> 00:44:04,935
So the matrix is fairly simple.

954
00:44:05,115 --> 00:44:07,117
x to the 0 mod a, right?

955
00:44:07,717 --> 00:44:09,839
So which is just 1, even power.

956
00:44:09,879 --> 00:44:10,839
So 1 mod a.

957
00:44:10,919 --> 00:44:13,301
My a is x to the fifth plus x to the fourth plus 1.

958
00:44:13,341 --> 00:44:14,262
So we just mod with that.

959
00:44:14,902 --> 00:44:16,123
x to the second mod a.

960
00:44:16,564 --> 00:44:18,285
So that's just, again, even power.

961
00:44:18,325 --> 00:44:22,028
So all the even powers of x mod are a, and that's our result.

962
00:44:24,688 --> 00:44:25,529
So test 13.

963
00:44:26,970 --> 00:44:29,151
I want to create a small but simple example

964
00:44:29,352 --> 00:44:30,152
to factor and solve.

965
00:44:31,373 --> 00:44:33,875
So I start with two simple irreducible factors.

966
00:44:34,856 --> 00:44:35,777
And I multiply them together.

967
00:44:36,077 --> 00:44:38,879
And all I do in test 13 is actually just multiply them

968
00:44:38,899 --> 00:44:40,180
together and print them out.

969
00:44:41,741 --> 00:44:43,683
So it starts with these two irreducible factors,

970
00:44:43,803 --> 00:44:44,504
multiply them together.

971
00:44:44,524 --> 00:44:48,907
I call my pgf2mul, which I've now used a bunch of times.

972
00:44:48,947 --> 00:44:50,468
But again, I'm sanity checking.

973
00:44:50,508 --> 00:44:50,829
Get that.

974
00:44:52,866 --> 00:44:55,847
So for test 14, I want to start breaking down B3.

975
00:44:56,347 --> 00:45:00,288
B3 says, triangularize matrix Q minus 1,

976
00:45:01,428 --> 00:45:02,168
and a bunch of other things.

977
00:45:04,088 --> 00:45:06,029
But to summarize, what step B3 says?

978
00:45:06,049 --> 00:45:09,510
It says, M is Q minus 1, and find the null basis vectors

979
00:45:09,550 --> 00:45:12,970
of M. So I'm going to start with that.

980
00:45:13,370 --> 00:45:14,711
Step 1, Q minus 1.

981
00:45:14,851 --> 00:45:15,631
I'm pretty sure I can do that.

982
00:45:17,085 --> 00:45:20,707
So, in this case, test 14, I'm printing out Q, I, and M.

983
00:45:21,107 --> 00:45:25,129
Q is that matrix I just built, printed out in this example.

984
00:45:25,609 --> 00:45:26,350
I is identity.

985
00:45:26,430 --> 00:45:29,171
I definitely know how to do identity matrix.

986
00:45:29,912 --> 00:45:32,693
And M is Q minus I, so I print those out.

987
00:45:32,813 --> 00:45:34,414
So I'm fairly comfortable with what I'm printing here,

988
00:45:34,634 --> 00:45:35,214
and I'm moving on.

989
00:45:35,475 --> 00:45:36,075
Test 15.

990
00:45:36,635 --> 00:45:37,596
All right, bigger problem.

991
00:45:37,676 --> 00:45:40,717
How do I find the null basis vectors of matrix M?

992
00:45:42,386 --> 00:45:47,029
In fact, super, super excellent walkthrough on this particular link, but I totally recommend

993
00:45:47,049 --> 00:45:49,690
you reading it if you're at all interested in this particular question, because for me,

994
00:45:49,910 --> 00:45:54,874
this really enlightened me, this particular answer to this particular question on math

995
00:45:54,894 --> 00:45:55,474
stacking stage.

996
00:45:56,394 --> 00:45:59,416
It's a process much like matrix inverse.

997
00:46:00,444 --> 00:46:01,925
So to summarize the process though,

998
00:46:02,785 --> 00:46:05,066
you're augmenting M with the identity matrix

999
00:46:05,086 --> 00:46:05,787
of the same size,

1000
00:46:06,667 --> 00:46:09,548
you're transforming M to row reduced echelon form,

1001
00:46:10,869 --> 00:46:13,510
and the null basis vectors are whatever's left on,

1002
00:46:13,850 --> 00:46:14,631
whatever's on the right,

1003
00:46:14,731 --> 00:46:16,591
when the left side of the augmented form is zero.

1004
00:46:17,612 --> 00:46:19,673
It's a fairly straightforward mechanical process.

1005
00:46:20,993 --> 00:46:21,634
So to start with.

1006
00:46:22,448 --> 00:46:24,790
Step A, in that mechanical process,

1007
00:46:24,930 --> 00:46:27,633
augment M with identity of the same size.

1008
00:46:28,033 --> 00:46:28,594
So it looks like this.

1009
00:46:28,954 --> 00:46:31,617
W is just going through each row.

1010
00:46:31,817 --> 00:46:34,059
It's taking M, shifting it left by the degree of P,

1011
00:46:34,499 --> 00:46:36,741
and then inserting the appropriate vector

1012
00:46:36,781 --> 00:46:37,862
of the identity at that point.

1013
00:46:38,323 --> 00:46:40,405
So in test 15, I'm just printing that out.

1014
00:46:40,825 --> 00:46:41,546
I create a new print.

1015
00:46:42,327 --> 00:46:45,910
So I can print stuff in augmented form, which just means I just put a space in the middle

1016
00:46:45,950 --> 00:46:47,151
so I can visualize it a little bit better.

1017
00:46:47,172 --> 00:46:48,713
So it's just this.

1018
00:46:48,793 --> 00:46:52,677
It's the same m on the left and this identity on the right, but it's just this one matrix

1019
00:46:53,017 --> 00:46:55,260
w with also space in the middle for visualization purposes.

1020
00:46:57,536 --> 00:47:01,919
So, now I need a function, I need to get this into row reduced echelon form, which I don't

1021
00:47:01,959 --> 00:47:06,962
happen to have a handy function for, but I can use, I know I can use Gauss-Jordan elimination.

1022
00:47:07,943 --> 00:47:09,143
Super useful description here.

1023
00:47:10,464 --> 00:47:13,586
There's also a calculator, there's lots of online calculators online for reference.

1024
00:47:13,626 --> 00:47:17,449
This particular one I found useful because it sort of dumped all the steps out as well.

1025
00:47:18,570 --> 00:47:21,071
So that as I'm debugging I have something to compare against, which is nice.

1026
00:47:22,572 --> 00:47:26,693
Again, going back to worked examples are really nice and really helpful for me in terms of

1027
00:47:26,733 --> 00:47:27,193
understanding.

1028
00:47:28,853 --> 00:47:35,674
So I create this function, pgf2rref, and a function rrefhtml which prints out all the

1029
00:47:35,714 --> 00:47:40,435
steps and the output so I can visualize it and make sure that what it's doing makes sense.

1030
00:47:41,595 --> 00:47:45,336
But to go over Gauss Jordan elimination, gf2, how does that work?

1031
00:47:45,556 --> 00:47:49,657
It works exactly the same as if you weren't in gf2 except for all the component math is

1032
00:47:49,697 --> 00:47:49,917
mod 2.

1033
00:47:52,118 --> 00:47:53,639
So in terms of mechanical process,

1034
00:47:53,679 --> 00:47:57,220
you mark the first row as the next result row,

1035
00:47:57,240 --> 00:47:58,220
and then you go through a loop.

1036
00:47:58,780 --> 00:48:00,820
So you find the first row with the leftmost bit set,

1037
00:48:02,941 --> 00:48:05,381
and then you swap that in your next result row,

1038
00:48:05,401 --> 00:48:06,321
you call that your pivot row,

1039
00:48:06,341 --> 00:48:11,102
and then you subtract that out from all the other rows.

1040
00:48:11,142 --> 00:48:12,543
So basically, that's the only one

1041
00:48:12,583 --> 00:48:13,643
with that particular bit set.

1042
00:48:13,703 --> 00:48:14,903
And then you just go through that process,

1043
00:48:15,043 --> 00:48:16,324
sort of working your way across the bits

1044
00:48:16,424 --> 00:48:17,064
from left to the right.

1045
00:48:18,064 --> 00:48:20,704
And just remembering your add here is in GF2,

1046
00:48:20,724 --> 00:48:21,525
so it's just XOR.

1047
00:48:23,580 --> 00:48:25,240
So output of test 16.

1048
00:48:25,281 --> 00:48:28,942
The thing about, so in this particular case, again,

1049
00:48:29,202 --> 00:48:32,023
printing out in terms of printing everything out,

1050
00:48:32,103 --> 00:48:33,543
printing everything out in HTML

1051
00:48:33,563 --> 00:48:35,284
so that I can visualize what's happening here.

1052
00:48:35,984 --> 00:48:38,345
So I can, printing it out as it goes,

1053
00:48:38,425 --> 00:48:40,506
marking the first row, highlighting,

1054
00:48:40,626 --> 00:48:43,067
and again, it's printing this out in color

1055
00:48:43,147 --> 00:48:44,187
so that I can see what's going on.

1056
00:48:44,247 --> 00:48:45,988
Highlighting the first, the pivot row.

1057
00:48:46,688 --> 00:48:48,669
It's highlighting the fact that they're swapping,

1058
00:48:48,689 --> 00:48:53,693
so highlighting what it's subtracting from here,

1059
00:48:55,074 --> 00:48:56,916
and then finding the next pivot row, et cetera.

1060
00:48:56,936 --> 00:48:58,317
And so going through all the process.

1061
00:48:58,977 --> 00:49:00,879
And you can see, I can see it sort of working

1062
00:49:01,179 --> 00:49:02,099
its way down here.

1063
00:49:02,120 --> 00:49:03,461
And in fact,

1064
00:49:04,101 --> 00:49:06,322
This was super fascinating to me,

1065
00:49:06,362 --> 00:49:07,462
because I don't think I've, you know,

1066
00:49:07,762 --> 00:49:09,683
looking at this and looking at 64-bit versions

1067
00:49:09,723 --> 00:49:12,364
and 120-bit versions and 512-bit versions,

1068
00:49:13,404 --> 00:49:14,965
I don't think I ever had seen

1069
00:49:14,985 --> 00:49:18,286
some gigantic actual worked examples,

1070
00:49:18,386 --> 00:49:20,487
step-by-step of Gauss-Jordan elimination,

1071
00:49:20,547 --> 00:49:21,427
especially in GF2.

1072
00:49:21,487 --> 00:49:22,647
Like, I'd never seen it before.

1073
00:49:22,967 --> 00:49:24,408
And being able to visualize it and see it

1074
00:49:24,648 --> 00:49:27,509
every single step of the way was amazing.

1075
00:49:27,529 --> 00:49:29,310
And so I played with this for quite a long time,

1076
00:49:29,350 --> 00:49:29,750
to be honest.

1077
00:49:30,610 --> 00:49:31,430
Until you're done.

1078
00:49:32,326 --> 00:49:35,189
And you're left with this matrix M here at the end.

1079
00:49:36,571 --> 00:49:40,295
So the result, and remember it's sort of in augmented form, so I just put the space in

1080
00:49:40,315 --> 00:49:40,836
the middle here.

1081
00:49:43,158 --> 00:49:49,385
And I take this, I also print it out, the same matrix in sort of an easy to paste into

1082
00:49:49,425 --> 00:49:52,789
Mathematica form, which again just throws stuff into my printouts and make it easier

1083
00:49:52,809 --> 00:49:53,669
to paste into Mathematica.

1084
00:49:55,012 --> 00:49:59,881
So, I verify this, I can do a row reduce of that matrix, modulus 2, and verify that the

1085
00:49:59,921 --> 00:50:02,647
result is the same, and it is, so I'm good with that.

1086
00:50:04,773 --> 00:50:07,074
So the next step is to highlight what the null basis vectors are.

1087
00:50:07,095 --> 00:50:08,315
What was the point of doing all this?

1088
00:50:09,076 --> 00:50:11,738
So those are where the left side of the augmented form is zero.

1089
00:50:11,958 --> 00:50:14,840
So I just added, this is just an addition to the debug printing

1090
00:50:14,880 --> 00:50:16,041
where I just highlighted those.

1091
00:50:17,742 --> 00:50:20,944
So here in red, the left side you can see is zero.

1092
00:50:20,984 --> 00:50:22,966
So the right side are the null basis vectors,

1093
00:50:24,306 --> 00:50:27,369
which I then print out here in three different forms,

1094
00:50:27,409 --> 00:50:29,690
in binary, in hex, and polynomial form.

1095
00:50:32,307 --> 00:50:33,890
So now I can sort of go through all the steps.

1096
00:50:33,930 --> 00:50:36,996
I can complete all the steps with B4 and apply it to a simple example.

1097
00:50:38,238 --> 00:50:38,719
So B4 here.

1098
00:50:40,615 --> 00:50:43,658
So calculating the GCD of u of x, which is our f,

1099
00:50:44,198 --> 00:50:47,661
and that one of those null basis vectors minus s,

1100
00:50:47,741 --> 00:50:51,044
where s is in the range of zero and p.

1101
00:50:51,504 --> 00:50:53,426
Now p, again, this is something that threw me

1102
00:50:53,446 --> 00:50:54,046
reading this document.

1103
00:50:54,086 --> 00:50:59,490
P is the power of the field,

1104
00:50:59,510 --> 00:51:00,571
the finite field that we're working with.

1105
00:51:00,591 --> 00:51:02,213
So p is two in this case.

1106
00:51:04,494 --> 00:51:06,794
So it's from where S is from zero to two.

1107
00:51:06,874 --> 00:51:08,355
So S is either zero or one.

1108
00:51:08,855 --> 00:51:12,976
So we're calculating V minus zero or V minus one.

1109
00:51:15,677 --> 00:51:19,638
So for each non-trivial vector V found in B3,

1110
00:51:19,758 --> 00:51:21,918
and the non-trivial vector is anything that's not one.

1111
00:51:22,238 --> 00:51:23,099
One is the trivial version.

1112
00:51:25,776 --> 00:51:28,660
We can find non-trivial factors of our original value

1113
00:51:28,680 --> 00:51:30,863
with GCD of F, so the original F,

1114
00:51:31,184 --> 00:51:33,527
and V, which is one of those null basis vectors,

1115
00:51:34,168 --> 00:51:36,431
and GCD of F and V minus one.

1116
00:51:36,511 --> 00:51:40,717
So multiplying those two things together will give us our F.

1117
00:51:42,899 --> 00:51:44,780
And that's pretty much what this says here.

1118
00:51:44,960 --> 00:51:49,080
It's the product of GCD U of X minus S and U of X,

1119
00:51:50,021 --> 00:51:54,701
where S is in the range of 0 and P, where for our case, P is 2.

1120
00:51:56,482 --> 00:51:58,562
So this is just a simpler way of saying that same thing.

1121
00:51:59,622 --> 00:52:02,723
So highlighting our null basis vectors from test 17,

1122
00:52:03,043 --> 00:52:06,084
again, I'm just highlighting the one non-trivial result.

1123
00:52:06,104 --> 00:52:07,524
The other one is 1, so we're just throwing that away.

1124
00:52:09,473 --> 00:52:12,434
So in test 18, all I'm doing, I can already do GCD.

1125
00:52:12,514 --> 00:52:14,354
I can already get my null basis vectors now.

1126
00:52:14,394 --> 00:52:15,515
I can do all the things.

1127
00:52:15,535 --> 00:52:18,095
So I should just be able to calculate and print,

1128
00:52:18,156 --> 00:52:20,396
get the GCD of these two values, and verify

1129
00:52:20,436 --> 00:52:23,497
that multiplying them together gives me my original value

1130
00:52:23,517 --> 00:52:24,277
back, which it should.

1131
00:52:25,438 --> 00:52:25,918
And it does.

1132
00:52:27,478 --> 00:52:30,179
So I get that one BV, which I'm calling BV,

1133
00:52:30,219 --> 00:52:31,059
that one basis vector.

1134
00:52:31,220 --> 00:52:33,680
I'm getting the GCD of A, which is my original input.

1135
00:52:34,339 --> 00:52:37,782
I didn't print it out there, my original input, and bv plus 0,

1136
00:52:38,302 --> 00:52:41,065
and gdcd of a, my bv plus 1, which are those two

1137
00:52:41,145 --> 00:52:42,025
polynomials there.

1138
00:52:42,686 --> 00:52:44,948
And now I can say, are these what I'm looking for?

1139
00:52:44,968 --> 00:52:46,529
Are these two factors what I'm looking for?

1140
00:52:46,609 --> 00:52:49,491
And if I go back to creating a simple example

1141
00:52:49,531 --> 00:52:50,912
with two irreducible factors, those

1142
00:52:50,932 --> 00:52:53,094
are, in fact, the same exact two irreducible factors.

1143
00:52:53,114 --> 00:52:55,376
So I can compare and say, yes, those are correct.

1144
00:52:55,416 --> 00:52:55,936
It looks good.

1145
00:52:56,056 --> 00:52:57,337
I solved a really simple example.

1146
00:52:57,457 --> 00:52:57,698
Yay.

1147
00:52:59,460 --> 00:53:00,420
So, test 19.

1148
00:53:01,661 --> 00:53:08,524
So test the process on a larger square-free example, which is this one I created before.

1149
00:53:10,825 --> 00:53:15,408
So I had this B, which was square-free, which I created before, which I'm now calling A.

1150
00:53:17,380 --> 00:53:20,643
So it's the same as the previous test, same as test 18, but with this particular value.

1151
00:53:22,105 --> 00:53:28,130
And so I can print it out, I print out everything, you can see much bigger, print out the highlights

1152
00:53:28,190 --> 00:53:30,993
and null basis vectors there, I print out the non-trivial result.

1153
00:53:32,263 --> 00:53:33,364
the non-trivial results here.

1154
00:53:33,424 --> 00:53:34,905
So I'm just throwing out the one already.

1155
00:53:34,965 --> 00:53:36,045
I'm just in the function.

1156
00:53:36,065 --> 00:53:37,226
I don't have to worry about it.

1157
00:53:37,246 --> 00:53:40,168
I'm finding the factors based on those.

1158
00:53:42,869 --> 00:53:46,551
And so I'm doing the pair of GCDs

1159
00:53:46,611 --> 00:53:48,792
here with each one of those basis vectors

1160
00:53:48,832 --> 00:53:49,693
that I found here.

1161
00:53:50,173 --> 00:53:54,556
So each one plus 0 and plus 1, or plus 0 and minus 1.

1162
00:53:54,736 --> 00:53:55,816
It doesn't matter, because they're both the same.

1163
00:53:57,238 --> 00:54:02,142
So, each pair of these GCDs, you see, can be multiplied together to make the original

1164
00:54:02,482 --> 00:54:02,822
value.

1165
00:54:05,384 --> 00:54:09,668
So, each one of those represents, each pair of those represents a list of factors, right,

1166
00:54:09,688 --> 00:54:10,469
potential factors.

1167
00:54:11,149 --> 00:54:14,752
I can multiply any given pair of them back to the original one, but can I get anything

1168
00:54:14,932 --> 00:54:15,753
else out of there?

1169
00:54:16,894 --> 00:54:20,757
So, I want to get factors that actually multiply together to get A. So, really, all I'm going

1170
00:54:20,777 --> 00:54:21,998
to do is say, okay, I know.

1171
00:54:23,028 --> 00:54:26,250
each one of those pairs multiplies together,

1172
00:54:26,370 --> 00:54:27,390
but can I get more out of this?

1173
00:54:27,410 --> 00:54:28,751
I'm just going to loop through all of them

1174
00:54:28,811 --> 00:54:33,354
and just divide them out of A until I can get a list.

1175
00:54:33,374 --> 00:54:36,715
Maybe I get lucky and I can get some additional factors out

1176
00:54:36,735 --> 00:54:37,136
of that, right?

1177
00:54:37,156 --> 00:54:39,357
So I just divide them all out and see whichever

1178
00:54:39,417 --> 00:54:40,297
ones divide out evenly.

1179
00:54:41,518 --> 00:54:43,499
So from that, in test 1A, I can now

1180
00:54:43,579 --> 00:54:46,581
print out a list of non-trivial factors of A.

1181
00:54:46,621 --> 00:54:47,722
These are all the things that I could find,

1182
00:54:47,822 --> 00:54:49,943
so I'm comfortable printing that out at this point.

1183
00:54:51,243 --> 00:54:54,807
But now I realize that non-trivial factors are not the same as irreducible factors.

1184
00:54:55,247 --> 00:54:57,930
So I need to go from non-trivial factors to irreducible factors.

1185
00:54:57,990 --> 00:54:58,631
How do I do that?

1186
00:54:59,171 --> 00:55:02,535
Well, if I can find non-trivial factors, I can find irreducible factors,

1187
00:55:02,635 --> 00:55:05,958
because I can just recurse, right?

1188
00:55:06,078 --> 00:55:08,841
I just get the non-trivial factors of each one of those

1189
00:55:09,121 --> 00:55:12,164
until I can't find any more, and then I have an irreducible factor.

1190
00:55:12,744 --> 00:55:15,685
And so that's in fact what test 1B does.

1191
00:55:15,785 --> 00:55:19,467
For each one of the non-trivial factors, find the non-trivial factors of that until I can't

1192
00:55:19,487 --> 00:55:20,067
find any more.

1193
00:55:20,327 --> 00:55:21,527
That's a pretty straightforward process.

1194
00:55:22,688 --> 00:55:28,210
So I'm left with, at the end of 1B, spitting out a list of irreducible factors of F or

1195
00:55:28,230 --> 00:55:28,310
of A.

1196
00:55:28,470 --> 00:55:31,091
And so I look at this.

1197
00:55:32,165 --> 00:55:34,127
this list here and I compare it against B,

1198
00:55:34,287 --> 00:55:35,368
which I created before,

1199
00:55:36,870 --> 00:55:38,031
and is it what I expected?

1200
00:55:38,051 --> 00:55:41,294
And in fact, this list is identical to this list,

1201
00:55:41,414 --> 00:55:42,355
this list I created here.

1202
00:55:42,415 --> 00:55:44,377
B is identical to the list above here

1203
00:55:44,477 --> 00:55:45,799
of irreducible factors that I found.

1204
00:55:45,859 --> 00:55:47,841
So I'm fairly comfortable that I can find that list.

1205
00:55:48,541 --> 00:55:48,842
Yay.

1206
00:55:48,862 --> 00:55:50,944
Just one scene.

1207
00:55:51,939 --> 00:55:55,001
Put all these pieces together and test factor

1208
00:55:55,021 --> 00:55:58,762
against a larger polynomial with squares in it

1209
00:55:58,922 --> 00:55:59,583
in the first place.

1210
00:56:00,603 --> 00:56:03,284
So if we reach all the way back to creating an example

1211
00:56:03,304 --> 00:56:06,186
with the square in it, which is the thing that we verified here

1212
00:56:06,226 --> 00:56:07,006
that had a square in it.

1213
00:56:09,145 --> 00:56:13,570
Test 1C really just says call GF2 SFF first,

1214
00:56:14,010 --> 00:56:15,532
and then for each one of those square factors,

1215
00:56:15,572 --> 00:56:16,713
each one of the factors that get out of that,

1216
00:56:17,334 --> 00:56:18,875
do the same process 1B,

1217
00:56:18,995 --> 00:56:21,778
which is get all the irreducible factors of those,

1218
00:56:22,659 --> 00:56:24,501
and then just combine everything into a final list.

1219
00:56:25,876 --> 00:56:27,518
So this is what I'm left with here.

1220
00:56:28,379 --> 00:56:30,480
So I'm left with this list of irreducible factors,

1221
00:56:31,922 --> 00:56:34,184
which is the same as the one that we expected

1222
00:56:34,264 --> 00:56:35,445
because we factored it in the first place.

1223
00:56:35,485 --> 00:56:36,486
So it all looks good.

1224
00:56:37,647 --> 00:56:40,429
But now I need an expanded list of irreducible factors.

1225
00:56:40,449 --> 00:56:41,730
So remember, one of those is squared

1226
00:56:41,770 --> 00:56:43,071
because we pulled it out specifically

1227
00:56:43,091 --> 00:56:43,732
because it was squared.

1228
00:56:44,973 --> 00:56:46,635
So it's this particular value that's squared.

1229
00:56:47,535 --> 00:56:50,118
But for my purposes, I want to be able to recombine everything.

1230
00:56:50,138 --> 00:56:52,960
So I want to expand this.

1231
00:56:53,000 --> 00:56:55,463
So really I'm just going through anything that's squared,

1232
00:56:55,503 --> 00:56:58,786
anything that has a power, that has a polynomial squared,

1233
00:56:59,306 --> 00:57:02,869
I'm just going to duplicate it as many times as it's called for.

1234
00:57:03,610 --> 00:57:04,651
So that's all that I'm doing in...

1235
00:57:05,312 --> 00:57:07,513
test 1Ds, I'm just printing out and duplicating

1236
00:57:07,533 --> 00:57:08,474
all the expanded factors.

1237
00:57:09,455 --> 00:57:10,355
And so that's what this is.

1238
00:57:10,555 --> 00:57:12,857
F0, you can see, is the same as F1, hex 67.

1239
00:57:13,057 --> 00:57:15,499
And then the rest of them are as you'd

1240
00:57:15,819 --> 00:57:18,521
as there are some that happen to be B, the section B

1241
00:57:18,961 --> 00:57:22,123
of that original polynomial.

1242
00:57:22,143 --> 00:57:24,445
So going back to the original problem, step all the way back.

1243
00:57:24,685 --> 00:57:27,087
Given a polynomial over GF2 to the n,

1244
00:57:27,147 --> 00:57:28,728
where n is one of those bit depths,

1245
00:57:28,768 --> 00:57:31,430
display all the pairs of factors of degree less than n

1246
00:57:31,490 --> 00:57:32,130
divided by 2.

1247
00:57:32,611 --> 00:57:33,231
Step one.

1248
00:57:33,999 --> 00:57:35,464
Find all the reducible factors of F.

1249
00:57:35,966 --> 00:57:38,916
Finally, I feel comfortable that I can do step one

1250
00:57:38,936 --> 00:57:39,679
at this point.

1251
00:57:41,835 --> 00:57:44,157
But luckily, steps two, three, and four

1252
00:57:44,277 --> 00:57:45,278
are much more straightforward.

1253
00:57:45,838 --> 00:57:47,300
So taking all those irreducible factors

1254
00:57:47,360 --> 00:57:48,801
and just sort of recombining them

1255
00:57:49,701 --> 00:57:53,144
into pairs that fit into the appropriate bit depth.

1256
00:57:54,525 --> 00:57:56,527
So that's all the test 1e does.

1257
00:57:56,567 --> 00:57:59,449
It sort of goes through those lists of irreducible factors

1258
00:57:59,809 --> 00:58:02,951
and recombines them into pairs that fit.

1259
00:58:03,232 --> 00:58:04,493
And that's what it outputs here.

1260
00:58:04,513 --> 00:58:05,774
That's what it looks like.

1261
00:58:06,374 --> 00:58:06,534
So.

1262
00:58:07,415 --> 00:58:08,496
Then I get to test 1f.

1263
00:58:09,556 --> 00:58:12,378
Test 1f, now I go back to the original test cases

1264
00:58:12,458 --> 00:58:15,861
and I say, all right, have I even solved the problem?

1265
00:58:15,881 --> 00:58:17,422
Am I even solving the correct problem here?

1266
00:58:17,682 --> 00:58:19,403
Have I done all the things correctly?

1267
00:58:19,924 --> 00:58:22,366
So let's run it against the original test cases

1268
00:58:22,406 --> 00:58:22,866
to make sure.

1269
00:58:23,186 --> 00:58:24,147
So here's test case three.

1270
00:58:26,140 --> 00:58:27,440
We now know why there's a third,

1271
00:58:27,560 --> 00:58:30,061
I now know why it says 32 instead of 64,

1272
00:58:30,101 --> 00:58:31,562
even though input and output is 64,

1273
00:58:31,622 --> 00:58:33,502
because it's a multiplication of two 32-bit numbers.

1274
00:58:34,963 --> 00:58:39,685
But I run now factoring on that input there,

1275
00:58:40,505 --> 00:58:41,946
and I get my result here,

1276
00:58:42,006 --> 00:58:44,427
which is the same as the output in the provided test case.

1277
00:58:44,467 --> 00:58:47,148
So I'm good, like I feel very good at this point,

1278
00:58:47,208 --> 00:58:48,348
and seems to be solving the right problem.

1279
00:58:48,728 --> 00:58:49,108
Except.

1280
00:58:50,385 --> 00:58:53,426
Sometimes, in the original text, and only sometimes,

1281
00:58:53,526 --> 00:58:54,707
the results include this sort of what

1282
00:58:54,747 --> 00:58:56,908
seems like a totally unnecessary factor with one.

1283
00:58:57,368 --> 00:58:59,789
Like, it's the thing that made it

1284
00:58:59,809 --> 00:59:00,790
so that it should have been obvious

1285
00:59:01,090 --> 00:59:02,991
that it was a factoring problem in the first place,

1286
00:59:03,011 --> 00:59:04,412
but it seems totally unnecessary.

1287
00:59:05,492 --> 00:59:06,813
Obviously, it's going to factor with one.

1288
00:59:07,253 --> 00:59:08,454
Why would you even bother to output that?

1289
00:59:09,694 --> 00:59:10,835
So when do you include that one?

1290
00:59:10,875 --> 00:59:12,516
When do I include that one in the results?

1291
00:59:13,756 --> 00:59:15,837
But I'll leave that particular part of the problem

1292
00:59:15,917 --> 00:59:17,958
as an exercise to the reader.

1293
00:59:19,019 --> 00:59:19,599
And end here.

1294
00:59:20,541 --> 00:59:25,004
As I said, all this stuff is available on this GitHub page.

1295
00:59:25,585 --> 00:59:26,986
Every single one of the tests is there.

1296
00:59:27,026 --> 00:59:28,106
This document is there.

1297
00:59:28,146 --> 00:59:28,727
You can walk through it.

1298
00:59:28,747 --> 00:59:29,387
They all run.

1299
00:59:31,028 --> 00:59:31,749
There's a make file.

1300
00:59:32,249 --> 00:59:32,810
You can do that.

1301
00:59:33,850 --> 00:59:35,451
So you can dig your way through it.

1302
00:59:35,731 --> 00:59:38,193
And I'm happy to take any comments on that.

1303
00:59:38,673 --> 00:59:42,096
Even pull requests if you wanna keep going with test 2.0.

1304
00:59:43,417 --> 00:59:44,057
So that's it, thank you.

