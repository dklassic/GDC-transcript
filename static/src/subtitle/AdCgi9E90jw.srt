1
00:00:05,341 --> 00:00:07,702
Why are we here?

2
00:00:07,702 --> 00:00:10,464
Caves of Qud is a game that I developed.

3
00:00:10,464 --> 00:00:10,945
I'm Brian Buckley.

4
00:00:10,945 --> 00:00:13,126
I'm a co-founder at Freehold Games.

5
00:00:13,126 --> 00:00:17,249
Caves of Qud has a ton of procedural generation.

6
00:00:17,249 --> 00:00:19,650
We use a bunch of normal techniques

7
00:00:19,650 --> 00:00:21,311
that you've heard of, Perlin noise, et cetera.

8
00:00:21,311 --> 00:00:23,513
And we use a few novel techniques.

9
00:00:23,513 --> 00:00:25,894
And today we're gonna talk about a specific one,

10
00:00:25,894 --> 00:00:28,636
wave function collapse, which sounds scary,

11
00:00:28,636 --> 00:00:29,997
but I hope by the end you'll realize

12
00:00:29,997 --> 00:00:31,638
it's not particularly terrifying.

13
00:00:32,320 --> 00:00:36,730
So, we're going to first start by looking at some final results that we get by utilizing

14
00:00:36,730 --> 00:00:40,678
this technique and then we'll go through some slides to talk about how we get there.

15
00:00:41,989 --> 00:00:43,990
So here's a map in Caves of Qud.

16
00:00:43,990 --> 00:00:45,911
If you're not familiar with it, it's a tile-based game.

17
00:00:45,911 --> 00:00:48,952
So each of the maps is 80 by 25 and it's very discreet.

18
00:00:48,952 --> 00:00:51,793
So you can see walls and creatures and plants here

19
00:00:51,793 --> 00:00:54,054
and they're represented in a sort of abstract way.

20
00:00:54,054 --> 00:00:57,355
So here we have a sort of rectilinear palace.

21
00:00:57,355 --> 00:01:00,296
It has sort of an outer wall and inner buildings

22
00:01:00,296 --> 00:01:02,297
and they're populated by various things,

23
00:01:02,297 --> 00:01:05,358
blood splatters and centipedes and gardens.

24
00:01:06,378 --> 00:01:10,441
And here we have an underground map where we have some very narrow corridors, gullies

25
00:01:10,441 --> 00:01:14,544
full of water, little rooms full of water.

26
00:01:14,544 --> 00:01:16,666
This is a very sort of mazy, narrow map.

27
00:01:16,666 --> 00:01:22,110
And here we have a circular tower embedded in some rock salt.

28
00:01:22,110 --> 00:01:25,273
It's filled with bears, I guess, and asphalt.

29
00:01:25,273 --> 00:01:27,214
And a little statuary on the right.

30
00:01:27,214 --> 00:01:30,717
It's got sort of curvy labyrinthine halls.

31
00:01:32,220 --> 00:01:33,500
And here we have a little town.

32
00:01:33,500 --> 00:01:37,343
We've got maybe a big ruined civic structure up north,

33
00:01:37,343 --> 00:01:41,905
and in the south we have a bunch of rectilinear village

34
00:01:41,905 --> 00:01:44,267
buildings adjacent, laid out along a nice forested path.

35
00:01:44,267 --> 00:01:45,287
So these are a wide variety of results,

36
00:01:45,287 --> 00:01:49,870
but they're a result of a single algorithm.

37
00:01:49,870 --> 00:01:53,012
So these each had a very different character.

38
00:01:53,012 --> 00:01:55,753
You had little mazy corridors, you had a...

39
00:01:56,472 --> 00:01:59,314
fairly dispersed village with well-ordered buildings,

40
00:01:59,314 --> 00:02:01,576
you had water-filled gullies,

41
00:02:01,576 --> 00:02:04,738
and instead of using an individual technique

42
00:02:04,738 --> 00:02:05,758
to generate each of these,

43
00:02:05,758 --> 00:02:08,140
we use a powerful new texture synthesis technique

44
00:02:08,140 --> 00:02:10,141
called Wave Function Collapse,

45
00:02:10,141 --> 00:02:13,563
alongside a few other tools that we use

46
00:02:13,563 --> 00:02:15,705
to supplement its weaknesses when applied to maps.

47
00:02:15,705 --> 00:02:17,926
So Wave Function Collapse was developed

48
00:02:17,926 --> 00:02:21,369
by a Russian mathematician named Maxim Gumen,

49
00:02:21,369 --> 00:02:23,730
released open source, MIT licensed,

50
00:02:23,730 --> 00:02:24,851
and the repository's out here.

51
00:02:25,399 --> 00:02:26,320
It's in 20 different languages.

52
00:02:26,320 --> 00:02:28,321
You can go out there and download it now and use it.

53
00:02:28,321 --> 00:02:31,382
Hopefully after this talk, you'll be able to go out there

54
00:02:31,382 --> 00:02:33,223
and build into your projects.

55
00:02:33,223 --> 00:02:35,905
Caves of Qud was its first commercial use.

56
00:02:35,905 --> 00:02:37,105
Bunch of others quickly followed

57
00:02:37,105 --> 00:02:38,046
because it's such a powerful technique.

58
00:02:38,046 --> 00:02:41,928
Wave Function Collapse has two primary modes.

59
00:02:41,928 --> 00:02:46,010
It operates on tiles and it operates on textures.

60
00:02:46,010 --> 00:02:48,332
If you do procedural generation,

61
00:02:48,332 --> 00:02:50,113
you've probably encountered long tile maps

62
00:02:50,113 --> 00:02:52,654
which are based on edge-colored adjacencies.

63
00:02:52,654 --> 00:02:55,235
The tile map generation is sort of similar to that,

64
00:02:56,226 --> 00:02:58,288
the adjacency constraints are much more powerful

65
00:02:58,288 --> 00:02:58,968
than edge coloring.

66
00:02:58,968 --> 00:03:01,230
You can get a much more powerful result.

67
00:03:01,230 --> 00:03:05,634
So if you're interested in tile-based map design,

68
00:03:05,634 --> 00:03:06,915
this is great, we're not gonna talk about it.

69
00:03:06,915 --> 00:03:08,676
Instead, we use texture mode.

70
00:03:08,676 --> 00:03:12,319
Texture mode uses small training inputs.

71
00:03:12,319 --> 00:03:16,182
They can be big, but it's most powerful when they're small.

72
00:03:16,182 --> 00:03:19,445
Maybe eight by eight or 16 by 16 training images,

73
00:03:19,445 --> 00:03:21,566
and they can produce arbitrarily large outputs

74
00:03:21,566 --> 00:03:23,168
with the character of that input training image.

75
00:03:24,820 --> 00:03:26,082
This is pretty amazing.

76
00:03:26,082 --> 00:03:29,086
So on the left, you have three separate inputs.

77
00:03:29,086 --> 00:03:32,751
On the top, you see a rectilinear room hole.

78
00:03:32,751 --> 00:03:35,074
And you can see seven sample outputs here, just bigger.

79
00:03:35,074 --> 00:03:38,178
You can see that each of them has a pretty different layout

80
00:03:38,178 --> 00:03:42,223
that shares structurally the same character as the input.

81
00:03:43,102 --> 00:03:44,963
On the second row, you see some caves.

82
00:03:44,963 --> 00:03:47,223
These are caves that you would typically generate

83
00:03:47,223 --> 00:03:50,324
via cellular automata system or something,

84
00:03:50,324 --> 00:03:52,984
or box filters, something very different

85
00:03:52,984 --> 00:03:56,045
from that first rectilinear room hollow arrangement.

86
00:03:56,045 --> 00:03:58,485
And then third, you see an input texture

87
00:03:58,485 --> 00:04:01,586
that's five by five, simple couple dots and a line,

88
00:04:01,586 --> 00:04:04,527
and you get some very complex quilted patterns,

89
00:04:04,527 --> 00:04:07,727
and this would be some custom line drawing technique.

90
00:04:08,151 --> 00:04:10,976
So instead of having to have three very different algorithms,

91
00:04:10,976 --> 00:04:13,801
you're able to have one single algorithm that's

92
00:04:13,801 --> 00:04:16,446
fed different, very simple training inputs.

93
00:04:16,446 --> 00:04:18,530
So this is something you can pop open MS Paint right

94
00:04:18,530 --> 00:04:21,215
in a training input and throw it through the algorithm.

95
00:04:21,215 --> 00:04:21,615
Very cool.

96
00:04:22,279 --> 00:04:24,460
So I'm gonna run quickly through this text slide.

97
00:04:24,460 --> 00:04:25,921
Don't feel like you have to load this into your brain.

98
00:04:25,921 --> 00:04:27,162
We're gonna walk through it more carefully.

99
00:04:27,162 --> 00:04:28,783
I just wanna prime your system

100
00:04:28,783 --> 00:04:30,584
for what we're gonna talk about.

101
00:04:30,584 --> 00:04:32,345
I'm actually not gonna go way down

102
00:04:32,345 --> 00:04:33,546
to the nuts and bolts of this algorithm.

103
00:04:33,546 --> 00:04:34,887
There are good papers to do that.

104
00:04:34,887 --> 00:04:37,189
I wanna give you a intuitive understanding

105
00:04:37,189 --> 00:04:39,050
of how this algorithm is making decisions

106
00:04:39,050 --> 00:04:40,891
when it's painting its output.

107
00:04:40,891 --> 00:04:42,452
So first, what it does is it chops it up

108
00:04:42,452 --> 00:04:43,753
into end-by-end tiles.

109
00:04:44,669 --> 00:04:45,850
n is something you pick.

110
00:04:45,850 --> 00:04:48,893
Three is a very typical size.

111
00:04:48,893 --> 00:04:53,017
So it's gonna operate on individual three by three tiles.

112
00:04:53,017 --> 00:04:54,959
Chop up your input image into those,

113
00:04:54,959 --> 00:04:57,121
and it's gonna operate on those as its basic atom.

114
00:04:57,121 --> 00:04:58,603
You can choose bigger or smaller atoms

115
00:04:58,603 --> 00:05:01,425
depending on the character you want out of your output.

116
00:05:01,425 --> 00:05:02,467
Then we output.

117
00:05:03,484 --> 00:05:05,624
we set up the output as a superposition

118
00:05:05,624 --> 00:05:07,285
of all those possible tiles.

119
00:05:07,285 --> 00:05:08,965
So you can imagine each element of the output

120
00:05:08,965 --> 00:05:11,086
being superimposed of each of the tiles

121
00:05:11,086 --> 00:05:12,026
that are pulled out of the input.

122
00:05:12,026 --> 00:05:14,107
And this is the character it shares

123
00:05:14,107 --> 00:05:15,767
with quantum wave function collapse.

124
00:05:15,767 --> 00:05:18,608
It's sort of a snide relationship.

125
00:05:18,608 --> 00:05:20,088
It's not anything complicated.

126
00:05:20,913 --> 00:05:23,354
What it does then is it picks one at random to start with

127
00:05:23,354 --> 00:05:26,256
and says, well, of all these possible tiles,

128
00:05:26,256 --> 00:05:29,218
we're going to select the lowest in-by-in entropy area

129
00:05:29,218 --> 00:05:31,420
and pick one at random and collapse it down

130
00:05:31,420 --> 00:05:32,240
to a single tile.

131
00:05:32,240 --> 00:05:34,582
And then it's got some new information.

132
00:05:34,582 --> 00:05:35,762
I know that this tile exists.

133
00:05:35,762 --> 00:05:39,064
These adjacencies are removed from the list.

134
00:05:39,064 --> 00:05:40,806
And then it continues until every output

135
00:05:40,806 --> 00:05:42,367
has only a single selection.

136
00:05:42,367 --> 00:05:43,887
And that's pretty much it.

137
00:05:43,887 --> 00:05:46,269
So, if you didn't catch that, we'll walk through that

138
00:05:46,269 --> 00:05:47,270
in a little more detail here.

139
00:05:47,963 --> 00:05:49,705
So the first thing it does is it identifies

140
00:05:49,705 --> 00:05:50,706
all the in-by-in patterns.

141
00:05:50,706 --> 00:05:52,647
So the example here I'm gonna use

142
00:05:52,647 --> 00:05:55,570
is a very simple three-color training input.

143
00:05:55,570 --> 00:05:57,371
It's got red on the outside, and a green box,

144
00:05:57,371 --> 00:05:58,152
and a blue inside.

145
00:05:58,152 --> 00:05:59,633
And so it's gonna chop it up

146
00:05:59,633 --> 00:06:01,274
into all these three-by-three patterns.

147
00:06:01,274 --> 00:06:02,535
So I'm showing you five here,

148
00:06:02,535 --> 00:06:04,077
but there are obviously a bunch.

149
00:06:04,077 --> 00:06:06,118
And a nine-by-nine box without wrapping,

150
00:06:06,118 --> 00:06:07,980
it's gonna be like 49.

151
00:06:07,980 --> 00:06:10,442
And if you allow wrapping, it's like, what, 81?

152
00:06:10,442 --> 00:06:13,224
If you allow symmetries and rotations, it's much more.

153
00:06:13,224 --> 00:06:16,387
Then it goes through, and for each tile,

154
00:06:16,387 --> 00:06:16,827
it figures out,

155
00:06:17,283 --> 00:06:18,724
where do the other tiles overlap?

156
00:06:18,724 --> 00:06:20,807
And it's gonna use this information

157
00:06:20,807 --> 00:06:23,029
in order to do the propagation.

158
00:06:23,029 --> 00:06:24,291
And so here I'm just showing an example.

159
00:06:24,291 --> 00:06:26,814
You've got two tiles and you can see that

160
00:06:26,814 --> 00:06:28,135
the first tile on the left,

161
00:06:28,135 --> 00:06:30,218
it overlaps with the two tiles below it,

162
00:06:30,218 --> 00:06:31,740
sharing those six red pixels.

163
00:06:33,968 --> 00:06:36,509
So this is an example output of a WFC run.

164
00:06:36,509 --> 00:06:39,750
So let's unpack what we're looking at here a little bit.

165
00:06:39,750 --> 00:06:41,851
On the very left you see the training input.

166
00:06:41,851 --> 00:06:45,072
What you're seeing is the first four steps

167
00:06:45,072 --> 00:06:46,112
of the WFC collapse.

168
00:06:46,112 --> 00:06:49,453
In the very first frame, the white outline box

169
00:06:49,453 --> 00:06:52,014
is the three by three tile it's decided to collapse.

170
00:06:52,014 --> 00:06:55,436
It then steps through one three by three section at a time

171
00:06:55,436 --> 00:06:58,297
and selects an output tile that correctly overlaps

172
00:06:58,297 --> 00:06:59,997
the existing tiles that it knows about

173
00:06:59,997 --> 00:07:01,838
and it steps through the image until all of them

174
00:07:01,838 --> 00:07:03,558
are collapsed from the existing input data.

175
00:07:04,700 --> 00:07:07,122
So to give you a real idea what's going on,

176
00:07:07,122 --> 00:07:09,343
if you look at the area in the box,

177
00:07:09,343 --> 00:07:11,784
it's very clearly green-blue.

178
00:07:11,784 --> 00:07:15,226
That's a single non-superimposed result.

179
00:07:15,226 --> 00:07:19,408
The rest of the blending pixels is a visualization

180
00:07:19,408 --> 00:07:23,850
of the output tiles that remain available for that area,

181
00:07:23,850 --> 00:07:25,551
superimposed on one another.

182
00:07:25,551 --> 00:07:28,213
So pixels that have sort of a green-blue box,

183
00:07:28,213 --> 00:07:30,634
they can still be either green or blue,

184
00:07:30,634 --> 00:07:32,955
depending on what tiles remain to be chosen.

185
00:07:32,955 --> 00:07:34,176
So it's like.

186
00:07:34,704 --> 00:07:36,905
very specifically at this first step,

187
00:07:36,905 --> 00:07:39,887
try to build an intuition for how it makes these decisions.

188
00:07:39,887 --> 00:07:43,830
Let's look at this strip of three pixels here.

189
00:07:43,830 --> 00:07:45,090
Unlike the pixels to the left,

190
00:07:45,090 --> 00:07:47,252
you can see these blue pixels are a little green,

191
00:07:47,252 --> 00:07:49,833
which means they still have some possibility

192
00:07:49,833 --> 00:07:51,334
to become green pixels.

193
00:07:51,334 --> 00:07:52,275
So why is this?

194
00:07:52,275 --> 00:07:55,177
Well, we look to the left of this pattern,

195
00:07:55,177 --> 00:07:58,799
and we see to the left of this pattern in the input

196
00:07:58,799 --> 00:08:00,420
is a strip of blue, blue, green.

197
00:08:02,373 --> 00:08:05,075
And where can we find this in the input pattern?

198
00:08:05,075 --> 00:08:07,497
We can essentially find it in these three places.

199
00:08:07,497 --> 00:08:09,759
We can find it here, each of these magenta boxes

200
00:08:09,759 --> 00:08:14,583
is what the output column we're thinking about might be.

201
00:08:14,583 --> 00:08:16,505
In this case, in the most leftmost case,

202
00:08:16,505 --> 00:08:20,568
you can see left of that is blue, blue, green.

203
00:08:20,568 --> 00:08:22,990
In the second case, left of that is blue, blue, green.

204
00:08:22,990 --> 00:08:24,512
In third case, left of that is blue, blue, green.

205
00:08:24,512 --> 00:08:26,593
So these are all, these could all slot in there.

206
00:08:27,537 --> 00:08:30,118
two of these outputs, that column is blue, blue, green,

207
00:08:30,118 --> 00:08:31,279
and the third possible output,

208
00:08:31,279 --> 00:08:32,860
the column is green, green, green.

209
00:08:32,860 --> 00:08:36,882
And so we can see, here we go.

210
00:08:36,882 --> 00:08:39,064
If we look at two blue, blue, green inputs

211
00:08:39,064 --> 00:08:41,005
and one green, green, green input,

212
00:08:41,005 --> 00:08:43,826
you can see that the probability is two blues

213
00:08:43,826 --> 00:08:46,508
and one green for each of those top two pixels,

214
00:08:46,508 --> 00:08:48,409
and it's always gonna be green in the output.

215
00:08:48,409 --> 00:08:51,911
So you can see that though we've selected that,

216
00:08:52,663 --> 00:08:54,965
initial three by three box, we know quite a bit

217
00:08:54,965 --> 00:08:57,446
about what possible adjacencies exist

218
00:08:57,446 --> 00:08:58,386
based on the input image.

219
00:08:58,386 --> 00:08:59,006
And so, again, looking at this,

220
00:08:59,006 --> 00:09:01,488
you should have a better idea, sort of intuitively,

221
00:09:01,488 --> 00:09:02,028
what it's doing.

222
00:09:02,028 --> 00:09:04,549
Each of these white boxes, it's selecting for sure

223
00:09:04,549 --> 00:09:07,570
what these pixels are, and in each case,

224
00:09:07,570 --> 00:09:10,412
it knows a little bit more about the possibilities

225
00:09:10,412 --> 00:09:12,893
that remain, and it simply sort of flood fills

226
00:09:12,893 --> 00:09:14,674
around the area to make it work.

227
00:09:14,674 --> 00:09:16,675
So let's watch this work, it's fun.

228
00:09:17,321 --> 00:09:19,923
So we have five training inputs on the left.

229
00:09:19,923 --> 00:09:22,566
We have a little white box, a little red box,

230
00:09:22,566 --> 00:09:24,848
sort of more complex temple.

231
00:09:24,848 --> 00:09:28,331
You can watch in real time as it decides,

232
00:09:28,331 --> 00:09:31,654
usually from the edges, what the possibilities are,

233
00:09:31,654 --> 00:09:35,798
and then folds in those overlapping potentials

234
00:09:35,798 --> 00:09:38,080
until we've got a final image.

235
00:09:38,080 --> 00:09:40,122
And you can obviously run this many times

236
00:09:40,122 --> 00:09:41,343
and get a different output each time.

237
00:09:55,013 --> 00:09:58,775
Pretty fun, so you can get big complex outputs

238
00:09:58,775 --> 00:09:59,235
from little inputs.

239
00:09:59,235 --> 00:10:01,597
So that gives you an idea of how the technique works.

240
00:10:01,597 --> 00:10:05,118
Again, you don't have to understand it.

241
00:10:05,118 --> 00:10:06,819
When I started experimenting with it,

242
00:10:06,819 --> 00:10:08,340
I had no clue what was going on.

243
00:10:08,340 --> 00:10:10,140
So I'm sort of a hands-on learner,

244
00:10:10,140 --> 00:10:13,502
so I just tried to give it input and see what happened.

245
00:10:13,502 --> 00:10:16,363
And so this was my first experiment in texture mode.

246
00:10:16,363 --> 00:10:17,684
In respect to building tile maps,

247
00:10:17,684 --> 00:10:20,065
I wanted to build structured output.

248
00:10:20,065 --> 00:10:21,386
So in this case, I was like, well,

249
00:10:21,386 --> 00:10:24,467
can I make it build little square buildings for a village?

250
00:10:24,467 --> 00:10:24,647
So maybe.

251
00:10:25,953 --> 00:10:29,095
I gave it a black box on a white background,

252
00:10:29,095 --> 00:10:31,437
and I did not get a bunch of little square buildings.

253
00:10:31,437 --> 00:10:34,400
And it turns out that's because,

254
00:10:34,400 --> 00:10:35,681
what is the image telling it?

255
00:10:35,681 --> 00:10:37,663
It's telling it basically,

256
00:10:37,663 --> 00:10:39,844
on the order of three by three pixels,

257
00:10:39,844 --> 00:10:41,486
that a line can turn left,

258
00:10:41,486 --> 00:10:42,907
or a line can turn right,

259
00:10:42,907 --> 00:10:43,868
or a line can go straight.

260
00:10:44,353 --> 00:10:45,714
you'll notice that there's no overlaps.

261
00:10:45,714 --> 00:10:49,018
But there's also no training in that image

262
00:10:49,018 --> 00:10:50,860
that tells that there's an inside and an outside

263
00:10:50,860 --> 00:10:51,501
of the square.

264
00:10:51,501 --> 00:10:54,885
There's no spatial relationship between those turns.

265
00:10:54,885 --> 00:10:56,166
And so you get the output there.

266
00:10:57,141 --> 00:11:00,464
I said, well, what if I add a third color?

267
00:11:00,464 --> 00:11:02,085
So now I've got white and I've got black

268
00:11:02,085 --> 00:11:03,006
and I've got red inside.

269
00:11:03,006 --> 00:11:06,428
This suddenly produces the kind of spatial coherence

270
00:11:06,428 --> 00:11:07,449
that I want across the map.

271
00:11:07,449 --> 00:11:09,371
You've got little red filled boxes.

272
00:11:09,371 --> 00:11:09,951
That's awesome.

273
00:11:09,951 --> 00:11:12,573
Because not only do you get the spatial coherence,

274
00:11:12,573 --> 00:11:14,615
but you also get some structural hinting.

275
00:11:14,615 --> 00:11:17,797
The red pixels tell me, hey, that's the inside of a place.

276
00:11:17,797 --> 00:11:18,698
And when you're building a map,

277
00:11:18,698 --> 00:11:20,660
that's a pretty interesting distinction

278
00:11:20,660 --> 00:11:22,561
to be able to pull out of a real simple texture.

279
00:11:22,561 --> 00:11:24,823
Okay, well, and then suddenly I can put furniture inside

280
00:11:24,823 --> 00:11:26,224
and plants outside and that looks.

281
00:11:26,827 --> 00:11:28,488
like already a coherent village

282
00:11:28,488 --> 00:11:29,969
with almost nothing going on.

283
00:11:29,969 --> 00:11:31,609
We've got a three-color texture going into it.

284
00:11:31,609 --> 00:11:32,209
Here's another example.

285
00:11:32,209 --> 00:11:34,410
As I get more comfortable playing with it,

286
00:11:34,410 --> 00:11:36,931
hey, what if I feed a bigger training image?

287
00:11:36,931 --> 00:11:40,693
Do I get noise or do I get something interesting?

288
00:11:40,693 --> 00:11:42,214
I get something interesting, that's cool.

289
00:11:42,214 --> 00:11:43,974
Another example, I said, well,

290
00:11:43,974 --> 00:11:45,635
can I produce sort of naturalistic gardens?

291
00:11:45,635 --> 00:11:49,197
Sure, I mean, these are like eight-second experiments

292
00:11:49,197 --> 00:11:49,777
in MS Paint.

293
00:11:49,777 --> 00:11:53,098
This is, I'm not spending 20 hours learning

294
00:11:53,098 --> 00:11:53,979
to do high-level math.

295
00:11:53,979 --> 00:11:56,260
So maybe I'm in the wrong lecture hall.

296
00:11:58,330 --> 00:11:59,991
Here's an integer shape, and keep this in mind,

297
00:11:59,991 --> 00:12:01,753
because we're gonna return to the star shape.

298
00:12:01,753 --> 00:12:03,595
I added an additional color here,

299
00:12:03,595 --> 00:12:05,998
and you can see you get star-like shapes,

300
00:12:05,998 --> 00:12:08,740
not identical stars, but some variation,

301
00:12:08,740 --> 00:12:09,762
and that's pretty interesting.

302
00:12:11,290 --> 00:12:12,371
how to use this in your code,

303
00:12:12,371 --> 00:12:15,233
probably the most interesting slide for people.

304
00:12:15,233 --> 00:12:17,375
It's not complicated, it's three lines of code.

305
00:12:17,375 --> 00:12:19,978
You initialize the model, you tell it to run,

306
00:12:19,978 --> 00:12:22,160
and you get the output image, and that's it.

307
00:12:22,160 --> 00:12:24,382
And let's take a look at the inputs,

308
00:12:24,382 --> 00:12:26,904
because sometimes the complexity's hidden

309
00:12:26,904 --> 00:12:28,926
in the parameterization.

310
00:12:28,926 --> 00:12:31,308
For WFC it's not, there's not even any complexity there.

311
00:12:31,308 --> 00:12:32,829
You give it the training image,

312
00:12:32,829 --> 00:12:34,311
you say what is the N I want?

313
00:12:34,311 --> 00:12:36,433
I want it to be two or three or four.

314
00:12:36,433 --> 00:12:37,674
How big do I want the output to be?

315
00:12:38,428 --> 00:12:40,369
Do I want the input to wrap across edges?

316
00:12:40,369 --> 00:12:42,150
Do I want the output to wrap across edges?

317
00:12:42,150 --> 00:12:44,731
Do I want it to sample with symmetry?

318
00:12:44,731 --> 00:12:46,292
Symmetry is a little bit interesting,

319
00:12:46,292 --> 00:12:47,372
not very complicated.

320
00:12:47,372 --> 00:12:49,733
If you're, for instance, putting in something

321
00:12:49,733 --> 00:12:50,994
where orientation matters,

322
00:12:50,994 --> 00:12:52,755
and you've got ground at the bottom and sky at the top,

323
00:12:52,755 --> 00:12:53,915
you probably don't want symmetry

324
00:12:53,915 --> 00:12:55,516
unless you want to end up with sky at the bottom.

325
00:12:55,516 --> 00:12:56,777
If you've got buildings

326
00:12:56,777 --> 00:12:58,277
where you don't care about the orientation,

327
00:12:58,277 --> 00:13:00,238
you want to probably crank that symmetry up to eight

328
00:13:00,238 --> 00:13:02,699
where you've got full reflection and rotational symmetry.

329
00:13:05,296 --> 00:13:09,759
Applied to map design, these are not problems with the algorithm per se, but only domain-specific

330
00:13:09,759 --> 00:13:10,639
problems.

331
00:13:10,639 --> 00:13:12,961
What problems did we run into when we tried to use this?

332
00:13:12,961 --> 00:13:15,282
Problem one was homogeny.

333
00:13:15,282 --> 00:13:21,046
Outputs are, as you get bigger and bigger, just completely homogenous in all directions.

334
00:13:21,046 --> 00:13:24,948
They're interesting at the small scale, but you don't really want to walk across an infinite

335
00:13:24,948 --> 00:13:26,589
homogenous plane of these buildings.

336
00:13:26,589 --> 00:13:29,671
Problem two is overfitting, and so we'll return to this star shape.

337
00:13:30,257 --> 00:13:32,299
One of the things you want to do in Maps is have more

338
00:13:32,299 --> 00:13:34,041
interesting details than walls.

339
00:13:34,041 --> 00:13:36,624
You want to have doors, and where the monsters are, and

340
00:13:36,624 --> 00:13:38,826
where the furniture is, et cetera, et cetera.

341
00:13:38,826 --> 00:13:42,350
And you might think that, well, let me add more colors

342
00:13:42,350 --> 00:13:43,031
to the WFC input.

343
00:13:43,031 --> 00:13:45,113
And that, of course, was the first thing I tried.

344
00:13:45,453 --> 00:13:49,276
The reality is as soon as you start adding more and more colors, less of these tiles

345
00:13:49,276 --> 00:13:50,678
tend to overlap.

346
00:13:50,678 --> 00:13:57,864
And so you tend to get very non-varied outputs because the tiles can fit together only in

347
00:13:57,864 --> 00:13:58,584
one particular way.

348
00:13:58,584 --> 00:14:01,647
And so instead you just reflect and rotate the shape across space.

349
00:14:01,647 --> 00:14:03,769
So how did we solve these?

350
00:14:05,477 --> 00:14:08,661
The solution to homogeny was very simple.

351
00:14:08,661 --> 00:14:10,103
We segmented the output space

352
00:14:10,103 --> 00:14:12,705
and then used WFC to fill in details.

353
00:14:12,705 --> 00:14:15,328
So in this case, this very simple example,

354
00:14:15,328 --> 00:14:17,631
we've segmented this map into three high-level chunks

355
00:14:17,631 --> 00:14:20,134
and each of them is filled with a WFC input

356
00:14:20,134 --> 00:14:20,875
with different character.

357
00:14:20,875 --> 00:14:23,558
So this produces a high-level,

358
00:14:24,559 --> 00:14:26,900
graph that's more interesting than a homogenous output.

359
00:14:26,900 --> 00:14:29,322
And then the interiors, that interior detailing,

360
00:14:29,322 --> 00:14:30,843
which can be quite difficult to get

361
00:14:30,843 --> 00:14:33,304
with standard procedural techniques,

362
00:14:33,304 --> 00:14:35,125
can be highly varied because you can pick

363
00:14:35,125 --> 00:14:38,207
from a big library of 500 templates you made in MSPaint

364
00:14:38,207 --> 00:14:40,148
and get some really interesting complex output.

365
00:14:41,396 --> 00:14:42,476
How do we deal with overfitting?

366
00:14:42,476 --> 00:14:45,037
The solution to overfitting was pretty simple,

367
00:14:45,037 --> 00:14:47,718
which was to use the output of WSC

368
00:14:47,718 --> 00:14:50,379
in order to generate high-level wall structure,

369
00:14:50,379 --> 00:14:52,160
and then use a post-processing pass

370
00:14:52,160 --> 00:14:54,741
to generate the more detailed things

371
00:14:54,741 --> 00:14:56,722
like doors and furniture.

372
00:14:56,722 --> 00:14:58,542
You can imagine a bunch of ways to do this.

373
00:14:58,542 --> 00:15:00,603
I'm gonna show you one of the full run-throughs

374
00:15:00,603 --> 00:15:02,964
that we did to get a level in Caves of Qud.

375
00:15:02,964 --> 00:15:04,544
So here's a real simple example.

376
00:15:04,544 --> 00:15:07,325
First, we pick some segmentation.

377
00:15:07,325 --> 00:15:09,386
In this case, we're gonna pick a big circle

378
00:15:09,386 --> 00:15:10,487
in the middle of the map.

379
00:15:11,740 --> 00:15:15,804
We're then gonna run a WFC template to fill the whole map up.

380
00:15:15,804 --> 00:15:17,946
In this case, we're just gonna run a set of buildings.

381
00:15:17,946 --> 00:15:20,468
We're gonna cookie cutter that circle out,

382
00:15:20,468 --> 00:15:23,410
and we are left with some walls.

383
00:15:23,410 --> 00:15:27,834
You can see that this has created some disjoint rooms,

384
00:15:27,834 --> 00:15:30,516
and so what we do is we simply segment this map.

385
00:15:30,516 --> 00:15:32,698
We figure out which are the disconnected spaces,

386
00:15:32,698 --> 00:15:35,781
and then we A star from segment to segment.

387
00:15:35,781 --> 00:15:38,022
Anywhere we pop through a wall, we're gonna place a door.

388
00:15:38,022 --> 00:15:39,163
So you can see in this case, we're.

389
00:15:39,719 --> 00:15:42,682
A-starring here, you've got a little red cross

390
00:15:42,682 --> 00:15:45,966
where the door is punched, and we do it again,

391
00:15:45,966 --> 00:15:49,189
and again, and again, and again.

392
00:15:49,189 --> 00:15:53,174
And once that's done, we are able to build a whole map,

393
00:15:53,174 --> 00:15:55,316
which looks pretty complicated.

394
00:15:55,821 --> 00:15:58,483
You can see now that there's very little going on, right?

395
00:15:58,483 --> 00:16:00,745
We've done a top-level segmentation,

396
00:16:00,745 --> 00:16:03,227
we've filled in the details with WFC,

397
00:16:03,227 --> 00:16:06,190
and we've punched some doors with a pretty simple A star.

398
00:16:06,190 --> 00:16:08,132
And the output is pretty complex.

399
00:16:08,132 --> 00:16:11,795
So let's revisit the initial maps,

400
00:16:11,795 --> 00:16:13,156
which looked complex before,

401
00:16:13,156 --> 00:16:14,837
but let's think about how we did these.

402
00:16:14,837 --> 00:16:15,798
These are each accomplished

403
00:16:15,798 --> 00:16:17,980
through the exact same technique.

404
00:16:17,980 --> 00:16:20,362
In this case, we've got a couple square areas

405
00:16:20,362 --> 00:16:22,224
that were filled with rectilinear WFC output.

406
00:16:22,224 --> 00:16:23,825
That's it, you get this cool-looking palace.

407
00:16:24,809 --> 00:16:26,930
Here we have a full map that's been allowed to run.

408
00:16:26,930 --> 00:16:30,012
We had a tiny little corridor WFC.

409
00:16:30,012 --> 00:16:31,312
It's maybe eight by eight.

410
00:16:31,312 --> 00:16:33,053
We let it just run out across the whole map.

411
00:16:33,053 --> 00:16:36,315
Then we flood fill in some of the edges with dirt.

412
00:16:36,315 --> 00:16:40,417
So this looks like a buried set of gullies.

413
00:16:40,417 --> 00:16:44,459
Here we've just got a circle and a square output

414
00:16:44,459 --> 00:16:47,420
that have been filled with real simple labyrinthian WFC.

415
00:16:47,420 --> 00:16:49,721
And here we have a big square at the top

416
00:16:49,721 --> 00:16:51,322
that's been filled with WFC output.

417
00:16:51,677 --> 00:16:52,938
and a big square at the bottom,

418
00:16:52,938 --> 00:16:54,079
which has been filled with WFC output.

419
00:16:54,079 --> 00:16:58,042
And that's it, and you get this cool little village, right?

420
00:16:58,042 --> 00:16:58,963
Pretty simple.

421
00:17:00,415 --> 00:17:03,056
There are some really good papers in the wild.

422
00:17:03,056 --> 00:17:04,877
Isaac Carth has written a good one called

423
00:17:04,877 --> 00:17:06,457
WFC's Constraint Solving in the Wild.

424
00:17:06,457 --> 00:17:08,858
If you wanna go really deep down

425
00:17:08,858 --> 00:17:11,599
into how the algorithm works, you can go grab that.

426
00:17:11,599 --> 00:17:14,780
The repository is a really excellent resource.

427
00:17:14,780 --> 00:17:16,420
Unlike a lot of repositories,

428
00:17:16,420 --> 00:17:18,301
it's really excellently documented.

429
00:17:18,301 --> 00:17:20,861
It's got source code in 30 different languages

430
00:17:20,861 --> 00:17:23,502
because as you can see, it's like a super easy technique

431
00:17:23,502 --> 00:17:24,883
and a super powerful one.

432
00:17:24,883 --> 00:17:27,703
And so it's very easy to plug into your project and go.

433
00:17:29,019 --> 00:17:40,534
And that is it, I'm Brian Buckley, that was WFC.

434
00:17:40,534 --> 00:17:40,734
Do I have?

435
00:17:40,734 --> 00:17:46,502
Yeah, if you have questions, come to the mics, happy to answer it.

436
00:17:55,778 --> 00:18:04,004
So, how did you deal with communicating the algorithm to people who are more used to traditional

437
00:18:04,004 --> 00:18:11,270
level design tools or more traditional procedural generation approaches, which tend to work

438
00:18:11,270 --> 00:18:16,474
on room chunks or things like that, where there's discrete combat spaces or discrete

439
00:18:16,474 --> 00:18:18,455
spaces for different gameplay styles?

440
00:18:18,455 --> 00:18:22,918
The question is, how would I communicate that to them, or how would you...?

441
00:18:23,039 --> 00:18:25,381
Yeah, how did working with design people

442
00:18:25,381 --> 00:18:28,684
from that background work out for you?

443
00:18:28,684 --> 00:18:31,326
Yeah, well, our team is, so the question is,

444
00:18:31,326 --> 00:18:33,108
how did it work out working with people

445
00:18:33,108 --> 00:18:36,171
who are more interested in discrete level design?

446
00:18:36,171 --> 00:18:38,813
And the answer is we have none of those people on the team.

447
00:18:38,813 --> 00:18:42,256
Okay.

448
00:18:42,256 --> 00:18:43,237
So how did it go with you?

449
00:18:44,332 --> 00:18:47,452
Well, I mean, this was a big challenge for Counter Spy

450
00:18:47,452 --> 00:18:49,713
because we ended up doing room-by-room chunking

451
00:18:49,713 --> 00:18:52,054
because that was easy to build out spaces

452
00:18:52,054 --> 00:18:53,174
and have combat AI work in it.

453
00:18:53,174 --> 00:18:54,394
But I'm curious how you do that.

454
00:18:54,394 --> 00:18:56,535
Yeah, if I can take that question to an adjacent space,

455
00:18:56,535 --> 00:18:57,895
I think there's a tendency to want to have

456
00:18:57,895 --> 00:18:59,336
a little bit more controllability

457
00:18:59,336 --> 00:19:01,176
from a designer's perspective.

458
00:19:01,176 --> 00:19:04,137
These, in Caves of Qud, we let our generative systems

459
00:19:04,137 --> 00:19:06,498
run really wild, and it's part of the aesthetic of the game,

460
00:19:06,498 --> 00:19:07,398
and we can lean into it.

461
00:19:07,957 --> 00:19:09,860
And you can see we do things like we just smash out

462
00:19:09,860 --> 00:19:11,423
put on top of each other, but because our game

463
00:19:11,423 --> 00:19:13,226
is about ruins that have been smashed out

464
00:19:13,226 --> 00:19:16,072
on top of each other, that's great.

465
00:19:16,072 --> 00:19:17,594
I think that, I think that.

466
00:19:18,545 --> 00:19:22,606
the, when you get into the design space where you want more control, the tendency is to

467
00:19:22,606 --> 00:19:26,607
move more towards prefabs which designers have control over.

468
00:19:26,607 --> 00:19:30,988
So you want to lean into like the tile-based techniques in order to fit those prefabs together,

469
00:19:30,988 --> 00:19:36,450
and then allow the designators to design spaces that can work within a particular bound, right?

470
00:19:36,450 --> 00:19:40,051
So within this prefab, this area can be filled in this number way.

471
00:19:40,271 --> 00:19:43,332
So if I'm following you, you're suggesting maybe

472
00:19:43,332 --> 00:19:46,534
when you're doing the spatial partitioning step,

473
00:19:46,534 --> 00:19:49,575
you can do some of that WFC step to do the broad strokes

474
00:19:49,575 --> 00:19:51,956
and then chunk down prefabs into the appropriate size spaces?

475
00:19:51,956 --> 00:19:54,798
Yeah, I would actually say probably the tile-based portion

476
00:19:54,798 --> 00:19:57,559
of WFC, which I didn't talk about,

477
00:19:57,559 --> 00:20:00,260
is probably more interesting to those teams.

478
00:20:00,260 --> 00:20:02,501
I think there's a little bit more controllability

479
00:20:02,501 --> 00:20:03,021
to that output.

480
00:20:03,021 --> 00:20:03,342
Thank you.

481
00:20:05,264 --> 00:20:10,146
Did you try building any constraints into the wave function collapse algorithm itself?

482
00:20:10,146 --> 00:20:14,627
Like no repeating tiles in this region or anything like that?

483
00:20:14,627 --> 00:20:19,909
Because I've experimented with that with some other implementations of this and ran into quite a few problems.

484
00:20:19,909 --> 00:20:24,630
Yeah, the question was, did we build any additional constraints on top of WFC?

485
00:20:24,630 --> 00:20:28,551
The answer is no, because I tried it and I ran into a bunch of problems.

486
00:20:30,540 --> 00:20:33,740
Max is a cool guy and very knowledgeable, obviously,

487
00:20:33,740 --> 00:20:36,301
since he created it, and if you have a specific question

488
00:20:36,301 --> 00:20:38,721
about constraint building, I would actually hit him up

489
00:20:38,721 --> 00:20:40,842
on Twitter and ask, because he's helpful,

490
00:20:40,842 --> 00:20:43,982
but I didn't have time to push past those problems

491
00:20:43,982 --> 00:20:45,783
in this case, and we were able to get really good output

492
00:20:45,783 --> 00:20:48,563
without any kind of complex constraint additions.

493
00:20:48,563 --> 00:20:51,444
I would say there's a great C Sharp library on GitHub

494
00:20:51,444 --> 00:20:53,584
by a guy, Boris the Brave, or whatever.

495
00:20:53,584 --> 00:20:55,585
I think it's linked within that repository.

496
00:20:55,585 --> 00:20:57,405
Works great inside Unity.

497
00:20:57,405 --> 00:20:58,165
Yeah, awesome.

498
00:21:00,479 --> 00:21:09,766
Great talk. I had a question. Did you ever try having like a more detailed training set to be able to have more permutations of different sort of adjacent materials?

499
00:21:09,766 --> 00:21:21,996
Yeah, it's really tricky because the reality is that those bigger training sets like the temple, really you can reduce those quite a bit and still get similar output. Those bigger sets.

500
00:21:22,424 --> 00:21:23,785
unless they're very complicated,

501
00:21:23,785 --> 00:21:25,687
tend to just start repeating the same patterns.

502
00:21:25,687 --> 00:21:28,649
And so a good, because as your training set gets bigger,

503
00:21:28,649 --> 00:21:30,810
the memory impact and the CPU impact

504
00:21:30,810 --> 00:21:32,972
of the collapse gets bigger.

505
00:21:33,567 --> 00:21:36,908
it tends to be best just to try to figure out exactly what the character is and pack it into

506
00:21:36,908 --> 00:21:40,130
as small of a space as possible for actual production.

507
00:21:40,130 --> 00:21:45,133
But, um, so I meant sort of when, um, when you have, like, so when you had multiple covers,

508
00:21:45,133 --> 00:21:47,074
colors, you got the repeating patterns, right? Yeah.

509
00:21:47,074 --> 00:21:53,197
So, uh, by having maybe a bigger training set, maybe you could have more permutations of colors

510
00:21:53,197 --> 00:21:57,059
adjacent to each other to sort of still be able to get the detail, but...

511
00:21:57,219 --> 00:22:01,806
Oh yeah, could you work around overfitting by having a bunch of them with different colors?

512
00:22:01,806 --> 00:22:03,568
Yeah, I think you probably could.

513
00:22:03,568 --> 00:22:08,856
I haven't really experimented with it, but I mean, that would certainly be an effective

514
00:22:08,856 --> 00:22:09,377
use of it, I think.

515
00:22:09,377 --> 00:22:10,078
Something to experiment with.

516
00:22:10,078 --> 00:22:10,979
Any other questions?

