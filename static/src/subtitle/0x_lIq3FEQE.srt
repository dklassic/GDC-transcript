1
00:00:11,931 --> 00:00:29,482
Thank you, you're welcome.

2
00:00:56,859 --> 00:01:14,977
And goodbye.

3
00:01:37,191 --> 00:01:37,751
do

4
00:01:37,751 --> 00:01:38,512
you

5
00:02:42,869 --> 00:02:45,231
Ah, I found one! I found one of the inflatable crocodiles!

6
00:02:45,231 --> 00:02:48,534
Yes! Perfect! Now get the... get the... get the...

7
00:02:48,534 --> 00:02:51,237
Let's see if it pops. Can we make it pop?

8
00:02:51,237 --> 00:02:54,680
Throw a knife into the crocodile.

9
00:02:54,680 --> 00:02:58,503
Okay, that is not enough to pop it. It's quite strong. Get the silenced gum.

10
00:02:58,503 --> 00:03:00,265
Yes! It pops! Yes!

11
00:03:00,265 --> 00:03:07,751
I'm so happy! It has a lovely little pop animation. That's the best thing!

12
00:03:09,130 --> 00:03:12,391
This was the reaction of YouTuber John at the channel

13
00:03:12,391 --> 00:03:13,272
Many a True Nerd.

14
00:03:13,272 --> 00:03:16,673
To me, it's very rewarding to see player reactions like this.

15
00:03:16,673 --> 00:03:19,374
And it is also a reward to the player for

16
00:03:19,374 --> 00:03:22,176
interacting with the world.

17
00:03:22,176 --> 00:03:25,857
This feature of a popping and inflatable crocodile was not

18
00:03:25,857 --> 00:03:29,579
needed to ship this game, but I believe it helped in selling

19
00:03:29,579 --> 00:03:32,520
the story of a detailed game world.

20
00:03:32,520 --> 00:03:35,702
And in hindsight, of course, I wish I'd made Knives cause

21
00:03:35,702 --> 00:03:36,542
deflation as well.

22
00:03:37,773 --> 00:03:40,195
What you just saw was work I did for Hitman

23
00:03:40,195 --> 00:03:42,317
from about two years ago.

24
00:03:42,317 --> 00:03:45,399
My name is Joakim Mellegaard, and I'm a technical artist

25
00:03:45,399 --> 00:03:48,061
at Rare, the studio behind Sea of Thieves.

26
00:03:48,061 --> 00:03:50,944
I started this role in October last year,

27
00:03:50,944 --> 00:03:55,187
and before this, I worked at IO Interactive

28
00:03:55,187 --> 00:03:56,388
on the Hitman franchise.

29
00:03:56,388 --> 00:04:00,492
In this talk, I will be covering a lot of the experience

30
00:04:00,492 --> 00:04:01,973
I gathered while working on Hitman.

31
00:04:07,362 --> 00:04:10,383
Today, I would like to talk about my view and ways

32
00:04:10,383 --> 00:04:11,924
of immersing the player in games.

33
00:04:11,924 --> 00:04:16,426
I will be using examples from tests made in Unreal Engine

34
00:04:16,426 --> 00:04:17,826
as well as my work on Hitman.

35
00:04:17,826 --> 00:04:20,607
But in general, the ideas I'll be presenting

36
00:04:20,607 --> 00:04:22,588
should be transferable to any project.

37
00:04:27,419 --> 00:04:31,362
So hopefully you will be able to take some inspiration, ideas,

38
00:04:31,362 --> 00:04:33,424
or code with you home today.

39
00:04:33,424 --> 00:04:35,946
We will also be looking at examples from other games.

40
00:04:35,946 --> 00:04:38,588
There will be some theoretical elements,

41
00:04:38,588 --> 00:04:41,310
but mostly we'll be looking at practical solutions.

42
00:04:50,780 --> 00:04:53,142
Much like the inflatable crocodile example,

43
00:04:53,142 --> 00:04:56,124
these ants from Skyrim helps in selling the idea

44
00:04:56,124 --> 00:04:59,686
of a highly detailed world.

45
00:04:59,686 --> 00:05:02,608
It is an interaction of discovery.

46
00:05:02,608 --> 00:05:06,490
VFX artist Mark Teer from Bethesda Softworks

47
00:05:06,490 --> 00:05:08,751
told me that these ants can only be found

48
00:05:08,751 --> 00:05:11,333
in a few places around the game world,

49
00:05:11,333 --> 00:05:12,574
but once the player sees them,

50
00:05:12,574 --> 00:05:15,916
it creates an impression of a much more detailed experience

51
00:05:15,916 --> 00:05:17,617
than the one the player would experience

52
00:05:17,617 --> 00:05:18,798
if the ants weren't there.

53
00:05:19,965 --> 00:05:24,128
By adding this effect, Mark made the player think

54
00:05:24,128 --> 00:05:26,450
that details of this delicacy could be seen

55
00:05:26,450 --> 00:05:28,792
around every corner.

56
00:05:28,792 --> 00:05:31,334
Also, other items in the game benefits from this

57
00:05:31,334 --> 00:05:33,376
by having the player believe in an overall

58
00:05:33,376 --> 00:05:35,958
richer experience.

59
00:05:35,958 --> 00:05:38,360
I believe that triggering the player's imagination

60
00:05:38,360 --> 00:05:41,902
with ants and crocodiles is the key to achieving this

61
00:05:41,902 --> 00:05:43,444
from a visual point of view.

62
00:05:43,444 --> 00:05:49,028
These two examples, ants and inflatable crocodiles,

63
00:05:49,519 --> 00:05:53,160
belongs to a category of effects we may label as

64
00:05:53,160 --> 00:05:56,881
cosmetic interactions, meaning they are pretty details you,

65
00:05:56,881 --> 00:06:00,861
as the player, did not necessarily expect to see or

66
00:06:00,861 --> 00:06:03,182
interact with.

67
00:06:03,182 --> 00:06:07,983
Another type, which we will speak much more of today, is

68
00:06:07,983 --> 00:06:08,883
passive interactions.

69
00:06:08,883 --> 00:06:13,664
This type of passive interactions are designed for

70
00:06:13,664 --> 00:06:16,045
grounding the player in the game world.

71
00:06:19,162 --> 00:06:20,423
making them feel part of it.

72
00:06:20,423 --> 00:06:23,364
There are so many experiences in games

73
00:06:23,364 --> 00:06:27,725
which we cannot do, like smell or touch, yet anyway.

74
00:06:27,725 --> 00:06:32,347
And that's why passive interactions must be visualized.

75
00:06:32,347 --> 00:06:37,268
The last category of interactive effects

76
00:06:37,268 --> 00:06:40,169
rewards the players for their actions.

77
00:06:40,169 --> 00:06:41,410
It's about supporting gameplay.

78
00:06:41,410 --> 00:06:45,891
Let's explain that by re-watching

79
00:06:45,891 --> 00:06:48,412
the slightly unpleasant scene.

80
00:06:48,412 --> 00:06:49,052
Sorry about this.

81
00:06:51,312 --> 00:06:54,755
The target is a patient in a hospital awaiting a heart

82
00:06:54,755 --> 00:06:55,255
transplant.

83
00:06:55,255 --> 00:06:58,618
And there are many tools available in the surgery room.

84
00:06:58,618 --> 00:07:02,842
There are, in other words, many ways to get to this target.

85
00:07:02,842 --> 00:07:06,084
Each one leads to the visualization of the player's

86
00:07:06,084 --> 00:07:06,485
decision.

87
00:07:06,485 --> 00:07:11,349
Every decision that the player may take has to be visualized

88
00:07:11,349 --> 00:07:14,591
so that she can experience the outcome of her actions.

89
00:07:22,775 --> 00:07:25,316
These three categories show us what visualizing player

90
00:07:25,316 --> 00:07:27,456
interactions does for the player.

91
00:07:27,456 --> 00:07:30,618
Together, they immerse the player more than any other

92
00:07:30,618 --> 00:07:33,579
element, graphical element, in the game because of their

93
00:07:33,579 --> 00:07:38,341
dynamic nature and direct feedback, whether it being a

94
00:07:38,341 --> 00:07:40,361
passive interaction or an intentional one.

95
00:07:40,361 --> 00:07:45,343
We may speak of immersion quite a bit, but it is valid

96
00:07:45,343 --> 00:07:48,184
to ask why aiming for immersive experiences is

97
00:07:48,184 --> 00:07:49,365
important in the first place.

98
00:07:50,996 --> 00:07:56,720
Psychology studies have shown us that the player reacts more authentically when facing

99
00:07:56,720 --> 00:07:59,621
decisions in game scenarios in comparison to the real world.

100
00:07:59,621 --> 00:08:05,885
And this is likely to be because social constructions don't matter as much in games.

101
00:08:05,885 --> 00:08:09,748
The player is in a flow of joy, having challenges and skill levels met.

102
00:08:09,748 --> 00:08:15,912
This leads to an extreme focus and, as the studies show, even self-actualization.

103
00:08:17,118 --> 00:08:21,020
And perhaps this is why video games are so popular.

104
00:08:21,020 --> 00:08:24,361
As game developers, we of course want to pay attention

105
00:08:24,361 --> 00:08:29,642
to these behaviors and make the player stay in the flow

106
00:08:29,642 --> 00:08:31,303
where these qualities can be triggered.

107
00:08:31,303 --> 00:08:35,044
This is true for anyone in game development, but I think

108
00:08:35,044 --> 00:08:37,545
it's well worth mentioning it in the

109
00:08:37,545 --> 00:08:39,485
context of visual effects.

110
00:08:39,485 --> 00:08:42,366
By keeping the immersion high with our visual effects, we

111
00:08:42,366 --> 00:08:43,706
can enhance the flow of the game.

112
00:08:45,532 --> 00:08:48,054
So, how do you make, and maybe more importantly,

113
00:08:48,054 --> 00:08:51,416
how do you know where to add effects like this?

114
00:08:51,416 --> 00:08:55,960
Start by identifying things that you believe

115
00:08:55,960 --> 00:08:57,421
the player may interact with.

116
00:08:57,421 --> 00:09:00,083
And this can be by being imaginative,

117
00:09:00,083 --> 00:09:02,125
but you will most likely get many ideas

118
00:09:02,125 --> 00:09:04,206
simply by looking around the game world

119
00:09:04,206 --> 00:09:06,508
for items or features that you think could benefit

120
00:09:06,508 --> 00:09:08,670
from an extra level of fidelity.

121
00:09:11,315 --> 00:09:14,557
Know the tools you have at hand and use them wisely and optimize.

122
00:09:14,557 --> 00:09:16,978
Typical tools for creating VFX, as you know,

123
00:09:16,978 --> 00:09:21,701
could be particles, cloth simulations, physics, scripting, shading.

124
00:09:21,701 --> 00:09:25,383
Often, though, VFX creation is about problem solving.

125
00:09:25,383 --> 00:09:28,805
And it can be difficult to know if a certain approach will

126
00:09:28,805 --> 00:09:30,727
succeed beforehand.

127
00:09:30,727 --> 00:09:32,448
It's an iterative process.

128
00:09:33,093 --> 00:09:35,353
If we go back and have a more detailed look

129
00:09:35,353 --> 00:09:38,614
at this inflatable crocodile we saw in the beginning,

130
00:09:38,614 --> 00:09:40,655
we can see that the setup is quite simple.

131
00:09:40,655 --> 00:09:42,995
It was created using a mix of cloth simulation,

132
00:09:42,995 --> 00:09:44,816
shader runtime modification,

133
00:09:44,816 --> 00:09:47,016
and game logic for listening to the gunshots.

134
00:09:47,016 --> 00:09:50,477
The resolution of the cloth simulation is quite low,

135
00:09:50,477 --> 00:09:53,858
so it makes sense to blend in this crumpled normal map

136
00:09:53,858 --> 00:09:57,379
when it deflates.

137
00:09:57,379 --> 00:10:01,900
Another type of interaction is flattening car tires in games.

138
00:10:05,844 --> 00:10:08,446
Apparently it's rewarding shooting tires.

139
00:10:08,446 --> 00:10:11,227
This footage is from The Vision.

140
00:10:11,227 --> 00:10:14,449
And I cannot say for sure how they made it there,

141
00:10:14,449 --> 00:10:16,231
but in Hitman, this effect,

142
00:10:16,231 --> 00:10:19,393
which was made by my former lead, Martin Nilsson,

143
00:10:19,393 --> 00:10:23,795
uses physics constraints, objects transformation,

144
00:10:23,795 --> 00:10:25,156
and finally a vertex shader,

145
00:10:25,156 --> 00:10:27,478
which flattens the tire to the ground,

146
00:10:27,478 --> 00:10:29,639
no matter the orientation of the wheel.

147
00:10:32,810 --> 00:10:34,811
So if you're thinking to yourself now that I have no

148
00:10:34,811 --> 00:10:37,473
idea how to make a shader like that, then simply just do the

149
00:10:37,473 --> 00:10:38,233
first two steps.

150
00:10:38,233 --> 00:10:42,015
Move the wheel down and have the hole being constrained to

151
00:10:42,015 --> 00:10:46,638
the wheel so that the car tilts over a little bit.

152
00:10:46,638 --> 00:10:51,181
This is a good example of when it's better to go with a lower

153
00:10:51,181 --> 00:10:53,942
fidelity version than to not do it at all.

154
00:10:57,083 --> 00:11:00,967
I believe that the player does not care too much for the additional fidelity when she's

155
00:11:00,967 --> 00:11:02,389
been rewarded for her actions.

156
00:11:02,389 --> 00:11:07,655
So the clipping caused here by offsetting the wheel into the ground may not matter too

157
00:11:07,655 --> 00:11:08,416
much to the player.

158
00:11:10,132 --> 00:11:13,593
Another example of player immersion and interaction,

159
00:11:13,593 --> 00:11:16,294
but in a more abstract way, are these computer monitors

160
00:11:16,294 --> 00:11:20,115
showing a video feed from security cameras in the game.

161
00:11:20,115 --> 00:11:24,656
The purpose of the monitors is mainly to immerse the player

162
00:11:24,656 --> 00:11:27,137
and making the room look like a security room.

163
00:11:27,137 --> 00:11:31,239
But they also come with somewhat of a hidden gameplay feature.

164
00:11:31,239 --> 00:11:33,319
I'd like to think that the player's informed

165
00:11:33,319 --> 00:11:35,720
of where cameras are placed in the level

166
00:11:35,720 --> 00:11:37,741
simply by looking at the screens.

167
00:11:38,633 --> 00:11:41,695
and recognizing locations inside the level.

168
00:11:41,695 --> 00:11:44,657
The player is immersed by this live feed,

169
00:11:44,657 --> 00:11:47,459
besides the fact that there are no characters or events taking

170
00:11:47,459 --> 00:11:48,260
place on the screen.

171
00:11:48,260 --> 00:11:52,443
That's because it's not really a live feed, simply.

172
00:11:52,443 --> 00:11:55,685
It's just a screenshot taken from real locations

173
00:11:55,685 --> 00:11:57,746
of security cameras in the level.

174
00:11:57,746 --> 00:12:02,530
The effect is done in three steps.

175
00:12:02,530 --> 00:12:07,673
Zoom in to the image to make space for panning.

176
00:12:08,633 --> 00:12:12,775
apply a fissure effect, which creates a perception of a perspective,

177
00:12:12,775 --> 00:12:14,897
and pan from side to side.

178
00:12:14,897 --> 00:12:22,682
Finally, it can look kind of cool to keep the input signal on the monitor,

179
00:12:22,682 --> 00:12:25,063
rather than completely tearing it off when it's broken.

180
00:12:25,063 --> 00:12:33,648
So, how do we efficiently add this type of effects to the game world?

181
00:12:34,151 --> 00:12:37,815
Procedural development is something that is seen more and more in our industry.

182
00:12:37,815 --> 00:12:43,261
The main selling point for making assets procedurally is the flexibility that comes out of it.

183
00:12:43,261 --> 00:12:52,290
It's simple to manage and change the graphics or behaviors halfway through development

184
00:12:52,290 --> 00:12:56,435
if the asset was designed for being changed in the first place.

185
00:12:57,584 --> 00:13:01,605
Also, this helps keeping the graphics consistent in the game.

186
00:13:01,605 --> 00:13:03,286
Often it aids memory performance,

187
00:13:03,286 --> 00:13:05,846
having assets being reused for many purposes.

188
00:13:05,846 --> 00:13:08,207
And it is also fun and challenging making assets

189
00:13:08,207 --> 00:13:09,587
that are meant to be reused.

190
00:13:09,587 --> 00:13:16,809
This solution was built for having consistent water

191
00:13:16,809 --> 00:13:20,390
puddle decals with ripple interactions in the game

192
00:13:20,390 --> 00:13:23,311
using a procedural approach.

193
00:13:23,311 --> 00:13:25,092
Previously, the environment artists

194
00:13:26,252 --> 00:13:30,636
had been baking the pit,

195
00:13:30,636 --> 00:13:34,039
sorry, had been baking the water plane into the texture

196
00:13:34,039 --> 00:13:36,521
and all the different versions of water shading

197
00:13:36,521 --> 00:13:38,923
affected memory performance

198
00:13:38,923 --> 00:13:40,525
and decreased the asset's flexibility.

199
00:13:40,525 --> 00:13:43,187
So in this procedural solution,

200
00:13:43,187 --> 00:13:45,309
the artist would instead simply

201
00:13:45,309 --> 00:13:46,670
bake out a pit in the ground

202
00:13:46,670 --> 00:13:49,673
and have the shader fill it with water.

203
00:13:52,363 --> 00:13:54,344
The assets support having interactive footsteps

204
00:13:54,344 --> 00:13:57,705
and gunshot ripples caused by the player and NPCs,

205
00:13:57,705 --> 00:13:59,586
as well as environmental effects,

206
00:13:59,586 --> 00:14:01,306
such as dripping from a broken pipe.

207
00:14:01,306 --> 00:14:05,087
It gives the environment artists the ability

208
00:14:05,087 --> 00:14:09,189
to change the water height and mud color procedurally.

209
00:14:09,189 --> 00:14:13,350
The water plane also has wind effects and simple refraction

210
00:14:13,350 --> 00:14:16,351
and a very rough visual effect of sinking into the puddle

211
00:14:16,351 --> 00:14:18,512
by setting the depth bias of the decal high.

212
00:14:23,964 --> 00:14:27,367
to properly understand how this effect is created.

213
00:14:27,367 --> 00:14:28,629
It's worth taking a quick look

214
00:14:28,629 --> 00:14:31,331
at the engine the solution was built for.

215
00:14:31,331 --> 00:14:33,734
The decal system in Glacier,

216
00:14:33,734 --> 00:14:35,215
the engine used to develop Hitman,

217
00:14:35,215 --> 00:14:37,037
offers a flexible way of working with decals

218
00:14:37,037 --> 00:14:42,743
because decals can be transformed in UV space.

219
00:14:42,743 --> 00:14:43,383
Per instance,

220
00:14:48,503 --> 00:14:51,305
per instance in UV space, which allows for optimal use

221
00:14:51,305 --> 00:14:53,927
of draw calls and for having many decals inside one texture.

222
00:14:53,927 --> 00:14:56,949
They also have vertex colors, which the artist

223
00:14:56,949 --> 00:14:57,830
can set per decal.

224
00:14:57,830 --> 00:15:01,052
And this is what I've been using for driving

225
00:15:01,052 --> 00:15:02,833
these procedural effects.

226
00:15:02,833 --> 00:15:06,816
They can also be placed in a template along with other

227
00:15:06,816 --> 00:15:09,358
components, such as scripts, collisions, and volumes.

228
00:15:09,358 --> 00:15:13,400
What all of that means is that we could have the player, the

229
00:15:13,400 --> 00:15:15,782
artist, place puddle decals inside a level.

230
00:15:16,516 --> 00:15:19,779
like they normally would, and automatically spawn ripple

231
00:15:19,779 --> 00:15:23,621
effects when the character walks into them, and even find

232
00:15:23,621 --> 00:15:33,749
electricity current.

233
00:15:33,749 --> 00:15:36,892
Now I will show you in depth how a puddle can be made

234
00:15:36,892 --> 00:15:40,615
procedurally through this interactive demo.

235
00:15:40,615 --> 00:15:42,236
And it will get a bit technical.

236
00:15:46,452 --> 00:15:49,694
What you're looking at is a puddle, as well as a slice of

237
00:15:49,694 --> 00:15:51,876
it, along an axis for visualization purposes.

238
00:15:51,876 --> 00:15:57,119
The artist can set the preferred water height by

239
00:15:57,119 --> 00:16:03,723
changing the decal's alpha value.

240
00:16:03,723 --> 00:16:06,345
We use a height map as the data for driving this effect.

241
00:16:06,345 --> 00:16:13,029
If we look closely, there's a small gradient between there

242
00:16:13,029 --> 00:16:14,670
being water and no water.

243
00:16:15,738 --> 00:16:17,979
And the creation of this gradient is the base

244
00:16:17,979 --> 00:16:21,720
for making this work, so let's get a deeper understanding

245
00:16:21,720 --> 00:16:24,341
of how it's created.

246
00:16:24,341 --> 00:16:29,362
I'm using something called a remap function.

247
00:16:29,362 --> 00:16:32,443
And don't be intimidated by the code,

248
00:16:32,443 --> 00:16:35,524
this function can easily be created

249
00:16:35,524 --> 00:16:38,985
through shader graph nodes, it's just not very presentable.

250
00:16:44,428 --> 00:16:47,231
The purpose of the function is to map

251
00:16:47,231 --> 00:16:49,132
a certain value to another.

252
00:16:49,132 --> 00:16:52,294
Under the code, you can see an example of what happens

253
00:16:52,294 --> 00:16:53,695
when we're running the function.

254
00:16:53,695 --> 00:16:56,738
So we start by having this gradient.

255
00:16:56,738 --> 00:16:59,860
We pass the gradient as the first argument to the function

256
00:16:59,860 --> 00:17:04,363
and values between 0 and 1 as the second and third arguments.

257
00:17:04,363 --> 00:17:07,425
And the result of this is that we get a new gradient that

258
00:17:07,425 --> 00:17:10,127
is more narrow.

259
00:17:10,127 --> 00:17:12,009
So instead of passing a gradient.

260
00:17:13,501 --> 00:17:16,462
to the function, we'll be passing a sample height map.

261
00:17:16,462 --> 00:17:20,124
And then we'll pass the user input, which is the value that

262
00:17:20,124 --> 00:17:24,665
the artist set on the puddle, minus the width we wish the

263
00:17:24,665 --> 00:17:26,366
water line to have.

264
00:17:26,366 --> 00:17:29,668
And that is the same as this width.

265
00:17:29,668 --> 00:17:32,469
Too large a width, and we'll start seeing aliasing.

266
00:17:32,469 --> 00:17:36,850
The water will start to look undefined and too small, and

267
00:17:36,850 --> 00:17:38,011
we'll start seeing aliasing.

268
00:17:40,848 --> 00:17:44,171
And don't pay too much attention to this value.

269
00:17:44,171 --> 00:17:47,414
This just happens to work well for this application.

270
00:17:47,414 --> 00:17:50,617
The last argument will then be the unmodified user input

271
00:17:50,617 --> 00:17:53,639
value, and that will give us a gradient between the two.

272
00:17:53,639 --> 00:17:56,502
That's all very cool.

273
00:17:56,502 --> 00:17:59,985
The puddle will shrink and grow, depending on whatever

274
00:17:59,985 --> 00:18:02,167
value we pass as this first argument.

275
00:18:02,167 --> 00:18:05,810
But we can do a little bit more with this.

276
00:18:05,810 --> 00:18:07,712
We can also add mud coloring.

277
00:18:10,244 --> 00:18:12,865
or perhaps a wet area surrounding the water.

278
00:18:12,865 --> 00:18:16,747
And all of this just by repeating the same code, but

279
00:18:16,747 --> 00:18:26,212
with different offsets.

280
00:18:26,212 --> 00:18:29,673
Now on to the interactive part.

281
00:18:29,673 --> 00:18:30,974
We were inspired by.

282
00:18:32,542 --> 00:18:36,426
Naughty Dog and the way they use render targets,

283
00:18:36,426 --> 00:18:38,307
which was presented in the paper

284
00:18:38,307 --> 00:18:42,050
to the Technical Art of Uncharted 4 in 2016, I think.

285
00:18:42,050 --> 00:18:43,371
So me and Jonas Meyer,

286
00:18:43,371 --> 00:18:46,014
the lead render programmer at Eye Interactive,

287
00:18:46,014 --> 00:18:50,377
we decided to try out something similar.

288
00:18:50,377 --> 00:18:53,540
So what you see are sprite particles

289
00:18:53,540 --> 00:18:55,422
spawned into a top-down buffer.

290
00:18:55,422 --> 00:18:58,344
It's basically a camera

291
00:18:58,344 --> 00:19:00,366
rendering a few defined assets in the game,

292
00:19:00,366 --> 00:19:01,887
and these, in this case, the ripples.

293
00:19:03,695 --> 00:19:06,056
The camera is placed above the player, looking down.

294
00:19:06,056 --> 00:19:13,302
So why does the render target look like vomit?

295
00:19:13,302 --> 00:19:19,046
Well, the clear color is set to the neutral vector in

296
00:19:19,046 --> 00:19:20,987
texture space, which happens to be this color.

297
00:19:20,987 --> 00:19:27,111
On the sprite particles, we simply write a low resolution

298
00:19:27,111 --> 00:19:28,933
representation of ripple normals.

299
00:19:30,006 --> 00:19:32,828
We also write the height value of the ripple to the blue

300
00:19:32,828 --> 00:19:35,050
channel of the render target.

301
00:19:35,050 --> 00:19:38,632
We can then sample the render target inside the puddle

302
00:19:38,632 --> 00:19:38,992
shader.

303
00:19:38,992 --> 00:19:48,559
As you can see here, the water plane is disturbed by the

304
00:19:48,559 --> 00:19:49,700
ripples, the height changes.

305
00:19:49,700 --> 00:19:52,142
We achieve this by.

306
00:19:54,026 --> 00:19:58,560
adding the sample texture, the render target, to the user

307
00:19:58,560 --> 00:20:00,506
input, and scaling it by our preferred value.

308
00:20:05,153 --> 00:20:09,436
Then we replace the second and third inputs of the water and

309
00:20:09,436 --> 00:20:12,178
mud levels with our new disturbed water level.

310
00:20:12,178 --> 00:20:14,940
And notice, note that we choose not to do it for this

311
00:20:14,940 --> 00:20:16,541
wetness level.

312
00:20:16,541 --> 00:20:19,263
And that is simply because we don't have any delta time for

313
00:20:19,263 --> 00:20:22,486
making the wetness sort of crawl back in a realistic

314
00:20:22,486 --> 00:20:26,588
fashion, as you would expect when wet ground dries up.

315
00:20:26,588 --> 00:20:31,031
You notice that

316
00:20:32,272 --> 00:20:33,792
If we set the water level too low,

317
00:20:33,792 --> 00:20:37,254
the ripples will start to look a bit strange,

318
00:20:37,254 --> 00:20:40,416
kind of like if we're, as if we're adding water

319
00:20:40,416 --> 00:20:42,758
to the puddle, which we are.

320
00:20:42,758 --> 00:20:46,120
But if you think about characters, for example,

321
00:20:46,120 --> 00:20:49,321
walking through the puddle, that wouldn't be the case.

322
00:20:49,321 --> 00:20:54,744
So we can fix that, either by scaling the ripple height

323
00:20:54,744 --> 00:20:58,627
by the user input, or completely turning off the effect

324
00:20:58,627 --> 00:21:00,488
when we think it fails.

325
00:21:09,842 --> 00:21:14,924
After this, we can start using our gradients for something.

326
00:21:14,924 --> 00:21:18,225
We set the color of the wet area surrounding the water

327
00:21:18,225 --> 00:21:20,906
by multiplying our color sample, the ground color,

328
00:21:20,906 --> 00:21:22,187
with inverted porosity.

329
00:21:22,187 --> 00:21:26,909
Assuming you don't sample a porosity map and want more

330
00:21:26,909 --> 00:21:31,050
physically accurate results, you can replace the porosity

331
00:21:31,050 --> 00:21:35,112
constants that I have here with the inverted roughness.

332
00:21:38,653 --> 00:21:40,634
of the underlying surface, of the ground.

333
00:21:40,634 --> 00:21:44,056
Perhaps that sounds a bit complicated and confused,

334
00:21:44,056 --> 00:21:46,057
but it's really quite simple.

335
00:21:46,057 --> 00:21:48,838
Think of it as plastic and concrete.

336
00:21:48,838 --> 00:21:51,419
The water would simply drip off plastic

337
00:21:51,419 --> 00:21:52,520
but be absorbed by concrete,

338
00:21:52,520 --> 00:21:53,741
and that is what we're trying to model here.

339
00:21:53,741 --> 00:21:58,343
We then want to find out how bright the mud color is

340
00:21:58,343 --> 00:22:01,204
so that we can define dark colors as transparent.

341
00:22:03,288 --> 00:22:05,729
Because as you may recall, we were using vertex colors

342
00:22:05,729 --> 00:22:06,870
as the input for the shader.

343
00:22:06,870 --> 00:22:10,212
And this means there is no fifth float, which we could

344
00:22:10,212 --> 00:22:14,615
use for defining transparency.

345
00:22:14,615 --> 00:22:17,276
So we will have to define transparency in another way.

346
00:22:17,276 --> 00:22:19,058
And we will do that by having dark colors

347
00:22:19,058 --> 00:22:21,779
represent transparency.

348
00:22:21,779 --> 00:22:27,443
Basically, if the artist would set the mod color to black, we

349
00:22:27,443 --> 00:22:30,565
will read this as fully transparent water.

350
00:22:31,797 --> 00:22:35,381
The dot product of this value here does exactly that,

351
00:22:35,381 --> 00:22:38,505
but those values may vary a little bit

352
00:22:38,505 --> 00:22:40,367
depending on your rendering pipeline.

353
00:22:40,367 --> 00:22:46,735
Note now that we know the brightness of the mud color,

354
00:22:46,735 --> 00:22:48,737
we can interpolate between the wet ground

355
00:22:48,737 --> 00:22:50,399
and the muddy water.

356
00:22:52,968 --> 00:22:55,809
We also have to unpack the ripple normals

357
00:22:55,809 --> 00:22:58,170
since the texture, the render target,

358
00:22:58,170 --> 00:23:00,130
is read in the shader as an unsigned vector

359
00:23:00,130 --> 00:23:02,011
and we need it to be assigned.

360
00:23:02,011 --> 00:23:04,852
And that just means that it goes from zero to one

361
00:23:04,852 --> 00:23:06,132
instead of negative one to one.

362
00:23:06,132 --> 00:23:09,453
And we do that by multiplying the sample by two

363
00:23:09,453 --> 00:23:10,774
and subtracting one.

364
00:23:10,774 --> 00:23:14,535
The set value is set here to one for simplicity,

365
00:23:14,535 --> 00:23:19,436
but you could recalculate a more accurate set value

366
00:23:19,436 --> 00:23:21,977
from x and y if you're required.

367
00:23:26,337 --> 00:23:29,320
We have now finished all the steps of this effect,

368
00:23:29,320 --> 00:23:32,623
and we just need to composite all our layers,

369
00:23:32,623 --> 00:23:33,845
much like you would do in Photoshop,

370
00:23:33,845 --> 00:23:36,687
an encode that's easy as done through Lerps.

371
00:23:36,687 --> 00:23:42,273
Puddles are great fun for the player,

372
00:23:42,273 --> 00:23:44,635
but another amazing thing we can do with this tech

373
00:23:44,635 --> 00:23:48,179
is having the player disturb the local plant life.

374
00:23:53,785 --> 00:23:56,528
What we want to achieve here is to have the sphere bend

375
00:23:56,528 --> 00:24:01,252
and flatten the ferns as it rolls through the vegetation.

376
00:24:01,252 --> 00:24:04,795
This can also be achieved using a render target

377
00:24:04,795 --> 00:24:06,417
as we see here.

378
00:24:06,417 --> 00:24:09,219
To understand what's going on here,

379
00:24:09,219 --> 00:24:12,562
let's start looking at what we write to this render target.

380
00:24:12,562 --> 00:24:16,506
There are two elements which we write to this render target,

381
00:24:16,506 --> 00:24:18,287
the first one being this single quad

382
00:24:18,287 --> 00:24:20,329
aligned with the sphere's position.

383
00:24:23,367 --> 00:24:29,651
On the quad, we draw a vector from the center and outwards.

384
00:24:29,651 --> 00:24:34,134
And along with this single quad, we spawn sprite

385
00:24:34,134 --> 00:24:36,736
particles and give them the velocity of their parent.

386
00:24:36,736 --> 00:24:44,261
These particles are shaded using the

387
00:24:44,261 --> 00:24:45,661
particle direction vector.

388
00:24:46,958 --> 00:24:50,682
and lifetime of the particle, as well as a sine wave

389
00:24:50,682 --> 00:24:53,245
for swaying the vector back and forth like this.

390
00:24:53,245 --> 00:24:57,249
And that is to fake internal movement in delta time

391
00:24:57,249 --> 00:25:01,093
for the bush to reach its undisturbed state

392
00:25:01,093 --> 00:25:03,215
in a bit more realistic fashion.

393
00:25:12,662 --> 00:25:15,644
We use the particle's lifetime to drive the sine wave,

394
00:25:15,644 --> 00:25:19,086
which results in faster swaying in the beginning of its life

395
00:25:19,086 --> 00:25:23,569
and slower swaying in the end of its life.

396
00:25:23,569 --> 00:25:26,491
So if we have another look here at the render target,

397
00:25:26,491 --> 00:25:31,614
you can see that the particles are changing color.

398
00:25:31,614 --> 00:25:33,435
And that is because the vectors are swaying, so to speak.

399
00:25:33,435 --> 00:25:39,179
The blue channel of the particle will be used as a mask

400
00:25:39,179 --> 00:25:40,360
for flattening the plant.

401
00:25:45,860 --> 00:25:49,402
In the plant shader, we will sample and unpack

402
00:25:49,402 --> 00:25:54,024
the render target in a similar way we did for the puddle.

403
00:25:54,024 --> 00:25:57,186
Now, instead of using the vectors for a surface normals

404
00:25:57,186 --> 00:25:58,147
like we did for the puddle,

405
00:25:58,147 --> 00:26:00,588
we will be using them for rotating the plants.

406
00:26:00,588 --> 00:26:03,150
So as you can see here, if the sample color is red,

407
00:26:03,150 --> 00:26:05,611
we will be rotating the plant in a positive x-axis.

408
00:26:05,611 --> 00:26:07,812
And in the absence of red,

409
00:26:07,812 --> 00:26:10,334
we'll be rotating the plant in the negative axis.

410
00:26:13,487 --> 00:26:16,029
When sampling the render target, it makes sense to think

411
00:26:16,029 --> 00:26:18,371
about what coordinates we should use.

412
00:26:18,371 --> 00:26:21,353
I found out for this plant, the rotation vector

413
00:26:21,353 --> 00:26:24,415
should be sampled somewhere between the pivot

414
00:26:24,415 --> 00:26:25,756
and the vertex position.

415
00:26:25,756 --> 00:26:31,941
But this is mainly down to the shape and size of plant.

416
00:26:31,941 --> 00:26:36,805
You can almost see this blend value as the flexibility

417
00:26:36,805 --> 00:26:40,247
of the definition of the plant's flexibility, basically.

418
00:26:40,247 --> 00:26:42,269
So if I set the flexibility to zero,

419
00:26:43,784 --> 00:26:47,048
it means we are sampling at the pivot position only,

420
00:26:47,048 --> 00:26:50,692
and that results in quite a rigid look,

421
00:26:50,692 --> 00:26:54,857
and the intersection between the sphere and the fern

422
00:26:54,857 --> 00:26:56,279
becomes quite noticeable.

423
00:26:56,279 --> 00:27:01,064
However, if we sample the render target

424
00:27:01,064 --> 00:27:02,466
only at the vertex position, the...

425
00:27:04,327 --> 00:27:07,850
Well, the vertices aren't very unified together.

426
00:27:07,850 --> 00:27:10,151
It kind of looks like water or something.

427
00:27:10,151 --> 00:27:12,553
In fact, they're not unified at all.

428
00:27:12,553 --> 00:27:19,378
They're completely independent, as we see here.

429
00:27:19,378 --> 00:27:22,300
So something in between these two extremes

430
00:27:22,300 --> 00:27:24,401
will work for most situations.

431
00:27:40,713 --> 00:27:45,357
So, however, it's worth mentioning that if the plant

432
00:27:45,357 --> 00:27:48,379
was very big, there would be no sense in sampling

433
00:27:48,379 --> 00:27:50,220
only at the pivot position.

434
00:27:50,220 --> 00:27:52,682
And in these cases, it may be worth looking

435
00:27:52,682 --> 00:27:54,924
at introducing baked pivots.

436
00:27:54,924 --> 00:27:56,946
So if the plant looked like this,

437
00:27:56,946 --> 00:27:59,548
we may want these vertices that I've painted blue

438
00:27:59,548 --> 00:28:02,410
to share a pivot to rotate around.

439
00:28:02,410 --> 00:28:05,332
And the easiest way of baking this data

440
00:28:05,332 --> 00:28:07,834
is to write the pivot positions to two UV sets

441
00:28:07,834 --> 00:28:10,036
in which we'll leave that last entry empty.

442
00:28:11,905 --> 00:28:15,126
But you could also write the values to vertex colors

443
00:28:15,126 --> 00:28:15,586
or textures.

444
00:28:15,586 --> 00:28:19,387
It's just going to make it a little bit more complicated to

445
00:28:19,387 --> 00:28:23,628
map those values out in the shader.

446
00:28:23,628 --> 00:28:27,689
Similarly, we would like these vertices to share

447
00:28:27,689 --> 00:28:29,970
a pivot, and so on.

448
00:28:29,970 --> 00:28:31,711
Anyway, that was a side note.

449
00:28:31,711 --> 00:28:34,571
Now back to our plant, and in particular, what we need to do

450
00:28:34,571 --> 00:28:37,892
before we start rotating our positions.

451
00:28:39,347 --> 00:28:41,088
So once we've created our coordinates,

452
00:28:41,088 --> 00:28:43,069
we can go ahead and sample the target,

453
00:28:43,069 --> 00:28:45,951
the render target, and unpack the vector to assigned range,

454
00:28:45,951 --> 00:28:47,952
just like we did for the puddle.

455
00:28:47,952 --> 00:28:51,214
And we could also recreate the sed rotation

456
00:28:51,214 --> 00:28:53,915
in this crude way of adding x and y.

457
00:28:53,915 --> 00:28:56,697
And this is absolutely not a true rotation by any means,

458
00:28:56,697 --> 00:28:58,838
but it makes the plant look a little bit livelier

459
00:28:58,838 --> 00:29:00,439
when it's sort of twisting in sed.

460
00:29:04,528 --> 00:29:09,331
To know the amplitude, how much we would like to rotate a plant, we will also be using x

461
00:29:09,331 --> 00:29:11,292
and y as a base.

462
00:29:11,292 --> 00:29:12,933
The amplitude can be created like this.

463
00:29:12,933 --> 00:29:19,917
It is important to normalize your rotation vector.

464
00:29:19,917 --> 00:29:25,700
And since we don't want this to happen, I added a small number to the vector.

465
00:29:26,855 --> 00:29:29,037
However, this is not the right way of avoiding none.

466
00:29:29,037 --> 00:29:32,000
If you want to be absolutely sure you don't get none, an

467
00:29:32,000 --> 00:29:33,321
if statement is required.

468
00:29:33,321 --> 00:29:36,624
But for the sake of fast performance, we can sometimes

469
00:29:36,624 --> 00:29:37,345
take that risk.

470
00:29:37,345 --> 00:29:41,529
In this case, however, it's completely safe, seeing as the

471
00:29:41,529 --> 00:29:45,632
smallest possible value of the texture is larger than our

472
00:29:45,632 --> 00:29:46,253
addition here.

473
00:29:47,545 --> 00:29:52,967
So if you're wondering what the visual output would be of NAN,

474
00:29:52,967 --> 00:29:57,029
imagine flickering or similar crazy behaviors.

475
00:29:57,029 --> 00:30:01,411
I won't cover how to do the actual rotation here, but you

476
00:30:01,411 --> 00:30:04,932
could find plenty of rotation functions online, or otherwise

477
00:30:04,932 --> 00:30:08,293
you're very likely to have one in your engine already.

478
00:30:12,200 --> 00:30:16,042
So what else do we need to do to achieve this effect?

479
00:30:16,042 --> 00:30:17,764
Well, we also want to flatten the plant.

480
00:30:17,764 --> 00:30:20,926
And we can do that by using the blue channel of the render

481
00:30:20,926 --> 00:30:22,387
target as a mask.

482
00:30:22,387 --> 00:30:25,769
To flatten the plant, we need to know how tall the plant is.

483
00:30:25,769 --> 00:30:29,192
And either define this in a very simple per plant way,

484
00:30:29,192 --> 00:30:32,294
like I'm doing here, or in a procedural way,

485
00:30:32,294 --> 00:30:34,015
by getting the object's head bounds.

486
00:30:34,015 --> 00:30:37,758
That is the preferable way, by the way.

487
00:30:39,105 --> 00:30:41,927
Next, we need to make sure we only flatten the plant

488
00:30:41,927 --> 00:30:44,189
where the flattening mask, the blue channel

489
00:30:44,189 --> 00:30:47,552
of the render target allows.

490
00:30:47,552 --> 00:30:50,334
Now we can add the flattening to our position offset.

491
00:30:50,334 --> 00:30:59,160
This will have vertices that are being masked as flat

492
00:30:59,160 --> 00:31:02,163
to be moved, in this case, 20 centimeters downwards.

493
00:31:03,696 --> 00:31:09,787
But that would also mean that vertices can pass through the ground, which probably is not what we wanted.

494
00:31:09,787 --> 00:31:14,075
The desired result is of course that the plant collides with the ground.

495
00:31:14,075 --> 00:31:15,919
And so let's fix that in one second.

496
00:31:17,075 --> 00:31:19,677
depending on which engine you're using

497
00:31:19,677 --> 00:31:21,939
and if you're outputting an offset

498
00:31:21,939 --> 00:31:24,280
or an absolute position in the vertex shader,

499
00:31:24,280 --> 00:31:27,523
this step may or may not be required.

500
00:31:27,523 --> 00:31:31,346
But in Unreal Engine, which this demo scene was made with,

501
00:31:31,346 --> 00:31:33,348
this is required, so we temporarily want

502
00:31:33,348 --> 00:31:35,790
to add the world positions to our offset.

503
00:31:35,790 --> 00:31:38,872
We can then define a ground height

504
00:31:38,872 --> 00:31:40,553
for the plant to collide with.

505
00:31:41,689 --> 00:31:45,012
This is probably just above the pivot,

506
00:31:45,012 --> 00:31:46,734
but it could also be a terrain height map

507
00:31:46,734 --> 00:31:50,537
if you really wanted that extra super fidelity.

508
00:31:50,537 --> 00:31:53,760
I can also recommend adding a downscaled

509
00:31:53,760 --> 00:31:55,722
RB space height to the ground height,

510
00:31:55,722 --> 00:31:57,984
because otherwise you will be experiencing

511
00:31:57,984 --> 00:32:00,446
quite a bit of set fighting when all the vertices

512
00:32:00,446 --> 00:32:03,189
are compressed to a single height value.

513
00:32:04,797 --> 00:32:10,502
So now we can make sure that the leaves will never go under

514
00:32:10,502 --> 00:32:14,866
the ground by using a max function, which will output

515
00:32:14,866 --> 00:32:18,729
whichever input is larger.

516
00:32:18,729 --> 00:32:23,513
And finally, again, depending on your engine, subtract the

517
00:32:23,513 --> 00:32:27,296
temporary position which we previously added.

518
00:32:27,296 --> 00:32:30,679
So in summary, how to disturb a plant.

519
00:32:30,679 --> 00:32:32,901
Create a render target.

520
00:32:33,712 --> 00:32:36,494
and draw some vectors and a mask to it.

521
00:32:36,494 --> 00:32:39,796
Use the vectors for rotations and a mask for flattening it.

522
00:32:39,796 --> 00:32:53,486
Now onto something a bit different.

523
00:32:53,486 --> 00:32:57,088
Traditionally, we would spawn decals on a shot surface

524
00:32:57,088 --> 00:32:59,070
and it would look something like this.

525
00:33:02,564 --> 00:33:06,407
Yes, these are not the most beautiful textures,

526
00:33:06,407 --> 00:33:10,870
but in general, this approach looks all right.

527
00:33:10,870 --> 00:33:12,812
And with a few texture variations,

528
00:33:12,812 --> 00:33:15,574
it will be difficult to see repetition.

529
00:33:15,574 --> 00:33:18,977
However, the decal often appears to be floating

530
00:33:18,977 --> 00:33:23,501
on the surface and appears like the stamp it really is.

531
00:33:23,501 --> 00:33:23,661
So.

532
00:33:24,849 --> 00:33:28,692
I think we could do a little bit better by using this method,

533
00:33:28,692 --> 00:33:30,874
which I call the destruction buffer.

534
00:33:30,874 --> 00:33:33,896
We're going to get a bit more interesting results.

535
00:33:33,896 --> 00:33:40,141
The idea is that we draw decals, again,

536
00:33:40,141 --> 00:33:42,623
at the impact point of the surface,

537
00:33:42,623 --> 00:33:45,566
just like we would do with normal decals,

538
00:33:45,566 --> 00:33:48,348
but in a separate pass.

539
00:33:48,348 --> 00:33:51,150
We can later use this buffer in our materials

540
00:33:51,150 --> 00:33:53,392
to create more unified destruction effects.

541
00:33:56,020 --> 00:33:58,922
And mind that changes to engine code

542
00:33:58,922 --> 00:34:00,983
will most likely be required in order for this

543
00:34:00,983 --> 00:34:02,043
to be fully implemented.

544
00:34:02,043 --> 00:34:08,106
Anyway, we spawn and draw decals to our standalone decal buffer.

545
00:34:08,106 --> 00:34:10,327
And this is what the buffer looks like.

546
00:34:10,327 --> 00:34:22,392
In the wall shader, we read the buffer

547
00:34:22,392 --> 00:34:25,813
and use the grayscale value to peel off the tiles.

548
00:34:27,391 --> 00:34:31,035
The data describes in more detail how the tile should break

549
00:34:31,035 --> 00:34:35,501
is stored in a texture, which looks like this.

550
00:34:35,501 --> 00:34:37,563
What this texture tells us is that dark values

551
00:34:37,563 --> 00:34:41,928
will peel off easier than bright values.

552
00:34:41,928 --> 00:34:45,453
We start by mapping the destruction buffer to the screen.

553
00:34:49,008 --> 00:34:54,431
We can then sample our buffer, define a width of the peel

554
00:34:54,431 --> 00:34:59,114
effect, and finalize the peel mask using a smooth step.

555
00:34:59,114 --> 00:35:03,778
When our peel mask is created, we can blend between the two

556
00:35:03,778 --> 00:35:07,680
materials, tiles, and concrete in this case.

557
00:35:07,680 --> 00:35:09,601
But we also want some normals to shade the

558
00:35:09,601 --> 00:35:10,802
surface where it's broken.

559
00:35:12,835 --> 00:35:16,081
And since we don't know how the surface will break,

560
00:35:16,081 --> 00:35:18,746
we cannot, we would have to define this

561
00:35:18,746 --> 00:35:20,689
in a procedural way, create these normals

562
00:35:20,689 --> 00:35:22,412
in a procedural way.

563
00:35:22,412 --> 00:35:25,317
And to do that, we will be using

564
00:35:26,225 --> 00:35:27,525
the hardware functions, ddx, ddy.

565
00:35:27,525 --> 00:35:30,065
And these functions are really cool,

566
00:35:30,065 --> 00:35:31,546
because they are aware, if you will,

567
00:35:31,546 --> 00:35:36,647
of the neighboring pixels in their current state.

568
00:35:36,647 --> 00:35:39,167
By using them, we can convert our grayscale peel mask

569
00:35:39,167 --> 00:35:40,928
into pretty decent normals.

570
00:35:40,928 --> 00:35:43,868
And this is kind of the quality you can expect

571
00:35:43,868 --> 00:35:45,569
from creating normals in this way.

572
00:35:45,569 --> 00:35:49,389
They turn out a bit blocky, but still usable.

573
00:35:49,389 --> 00:35:53,310
And we can have a closer look here in real time as well.

574
00:36:01,590 --> 00:36:04,954
You can add an additional layer of fidelity by having the

575
00:36:04,954 --> 00:36:07,536
concrete, in this case, break even more as the

576
00:36:07,536 --> 00:36:17,486
wall takes damage.

577
00:36:17,486 --> 00:36:20,889
I don't know if you've already noticed, but it's worth to

578
00:36:20,889 --> 00:36:24,352
point out that it's quite forgiving in the eye to see

579
00:36:24,352 --> 00:36:26,935
these type of decals fade off.

580
00:36:30,187 --> 00:36:32,509
So let's revise how this wall became broken.

581
00:36:32,509 --> 00:36:36,173
We created a separate decal buffer, a.k.a.

582
00:36:36,173 --> 00:36:42,018
destruction buffer, spawned some decals into it, and then

583
00:36:42,018 --> 00:36:46,562
peeled off the tiles by combining the destruction

584
00:36:46,562 --> 00:36:49,485
buffer and a texture, defining how the

585
00:36:49,485 --> 00:36:50,325
material should break.

586
00:36:50,325 --> 00:36:55,650
So that could be either tiles or wood or whatever you are

587
00:36:55,650 --> 00:36:56,331
about to break.

588
00:37:00,369 --> 00:37:02,711
Now on to something quite different.

589
00:37:02,711 --> 00:37:06,595
Actually not, because we kind of saw this

590
00:37:06,595 --> 00:37:07,716
in the earlier presentation.

591
00:37:07,716 --> 00:37:13,641
So this is one way in how to solve

592
00:37:13,641 --> 00:37:17,504
the problem of having liquid placed in a moving container,

593
00:37:17,504 --> 00:37:23,670
in this case a glass.

594
00:37:31,387 --> 00:37:36,411
There is no fluid simulation going on here.

595
00:37:36,411 --> 00:37:37,812
It's simply a few tricks put together,

596
00:37:37,812 --> 00:37:42,055
and these are the basics for achieving this effect.

597
00:37:42,055 --> 00:37:44,818
Start by filling the container with liquid,

598
00:37:44,818 --> 00:37:47,700
and by that literally, I mean literally,

599
00:37:47,700 --> 00:37:53,685
create a closed liquid mesh inside the 3D model.

600
00:37:53,685 --> 00:37:57,248
Set all the vertices above our defined liquid height

601
00:37:57,248 --> 00:37:57,688
to that height.

602
00:37:59,085 --> 00:38:01,827
you will now notice that some of the vertices

603
00:38:01,827 --> 00:38:04,709
will end up outside the glass.

604
00:38:04,709 --> 00:38:06,950
Now we'll just tilt the glass

605
00:38:06,950 --> 00:38:08,651
to get a better idea of what's going on

606
00:38:08,651 --> 00:38:12,854
and ensure that all vertices stays inside the glass.

607
00:38:12,854 --> 00:38:15,716
And we'll get into how this is done shortly,

608
00:38:15,716 --> 00:38:18,258
but basically it's a matter of finding

609
00:38:18,258 --> 00:38:20,299
the nearest point inside the glass

610
00:38:20,299 --> 00:38:22,361
and that is going to be the radius of the glass.

611
00:38:24,049 --> 00:38:26,011
Now is a good time to tell you that this effect

612
00:38:26,011 --> 00:38:28,753
only really works for cylindrical containers.

613
00:38:28,753 --> 00:38:31,956
To find the nearest inside point of other shapes

614
00:38:31,956 --> 00:38:32,476
is much trickier.

615
00:38:32,476 --> 00:38:38,241
You may also notice that the plane starts to bend slightly.

616
00:38:38,241 --> 00:38:41,904
And I just decided not to fix this

617
00:38:41,904 --> 00:38:45,026
because sometimes it kind of looks like surface tension

618
00:38:45,026 --> 00:38:46,968
and that's a cool side effect.

619
00:38:49,075 --> 00:38:53,138
Finally, the fourth step is to fade off the effect

620
00:38:53,138 --> 00:38:55,981
when it fails, and it will fail in this angle.

621
00:38:55,981 --> 00:39:02,446
Okay, so that's the idea,

622
00:39:02,446 --> 00:39:05,769
but let's run through it in greater detail.

623
00:39:05,769 --> 00:39:08,111
First, we must define the essentials.

624
00:39:08,111 --> 00:39:12,535
The height marked as blue represents how filled the glass is.

625
00:39:12,535 --> 00:39:14,857
The set bounds of the contents marked as green

626
00:39:16,358 --> 00:39:19,481
and the maximum radius of the contents marked as red.

627
00:39:19,481 --> 00:39:28,187
Next, we make sure that the height value can never

628
00:39:28,187 --> 00:39:31,270
go below the lower bounds.

629
00:39:31,270 --> 00:39:34,652
What we will try to do now is to force all the vertices

630
00:39:34,652 --> 00:39:38,035
above our height value to that height.

631
00:39:38,448 --> 00:39:41,949
However, the height that we defined is in local space.

632
00:39:41,949 --> 00:39:45,371
So if we rotated the glass, the vertices wouldn't be aligned

633
00:39:45,371 --> 00:39:49,192
with the horizon, which is the whole point of the effect.

634
00:39:49,192 --> 00:39:53,934
So that's why we need to transform our height value to

635
00:39:53,934 --> 00:39:54,774
world space.

636
00:39:54,774 --> 00:39:57,836
And this essentially creates an infinite plane.

637
00:39:57,836 --> 00:39:59,936
And now we can force the vertices to

638
00:39:59,936 --> 00:40:00,937
our plane like this.

639
00:40:00,937 --> 00:40:06,399
When we've done that, we must go back to local space.

640
00:40:07,462 --> 00:40:11,706
to carry on with the next step, which is to put the vertices back into the glass.

641
00:40:11,706 --> 00:40:17,290
Because as you may recall from my GIF earlier, some of the vertices are outside the glass.

642
00:40:17,290 --> 00:40:20,853
And we would like to put them back in.

643
00:40:20,853 --> 00:40:30,240
We will do this by using the radius of the glass.

644
00:40:30,240 --> 00:40:33,543
But how do we know the radius of the glass?

645
00:40:33,940 --> 00:40:40,143
The radius is breaked into one dimensional texture,

646
00:40:40,143 --> 00:40:40,903
in this case,

647
00:40:40,903 --> 00:40:43,804
in this case, basically the way we do this

648
00:40:43,804 --> 00:40:47,005
is to create a height map from the tip of the glass,

649
00:40:47,005 --> 00:40:48,886
and in other words, measure the distance

650
00:40:48,886 --> 00:40:52,207
from the plane here to the liquid and invert that result.

651
00:40:52,207 --> 00:40:56,969
Once we've done that, we can create some,

652
00:40:56,969 --> 00:40:58,710
we will sample our textures,

653
00:40:58,710 --> 00:41:00,630
but first we need to create some coordinates.

654
00:41:02,823 --> 00:41:04,624
We will reuse our remap function here,

655
00:41:04,624 --> 00:41:07,326
which we previously made,

656
00:41:07,326 --> 00:41:10,808
to map the height to a zero to one range.

657
00:41:10,808 --> 00:41:14,390
So in this image, you can see that the set position,

658
00:41:14,390 --> 00:41:17,192
which is this case in something like 60,

659
00:41:17,192 --> 00:41:19,013
turns into 0.5 in our new range.

660
00:41:19,013 --> 00:41:26,317
We can then sample and multiply the radius texture sample

661
00:41:26,317 --> 00:41:29,819
with our maximum radius,

662
00:41:29,819 --> 00:41:31,540
which we defined on our first slide.

663
00:41:34,190 --> 00:41:37,611
Now before we fix our little problem of having vertices

664
00:41:37,611 --> 00:41:40,792
outside the glass, we need to know if there are

665
00:41:40,792 --> 00:41:42,033
outside the glass.

666
00:41:42,033 --> 00:41:45,234
And we can learn this by measuring the distance from

667
00:41:45,234 --> 00:41:48,815
the vertex to the center of the liquid and comparing that

668
00:41:48,815 --> 00:41:50,035
distance with the radius.

669
00:41:50,035 --> 00:41:55,057
We are now ready to put the liquid back into the glass by

670
00:41:55,057 --> 00:41:59,918
creating a direction vector from the center of the glass

671
00:41:59,918 --> 00:42:01,318
to the vertex and scaling.

672
00:42:02,611 --> 00:42:07,576
it by the radius of the contents and that way we will see that happen.

673
00:42:07,576 --> 00:42:13,522
And I mean, I don't mean literally like this, but this is just a visualization.

674
00:42:13,522 --> 00:42:20,750
But basically what we're doing is to place the vertex in the center of the liquid and

675
00:42:20,750 --> 00:42:23,152
scaling it outwards using the radius.

676
00:42:23,152 --> 00:42:24,213
To fade off the liquid.

677
00:42:25,231 --> 00:42:27,873
When the container rotates too much,

678
00:42:27,873 --> 00:42:29,834
you can use the Zebdo angle

679
00:42:29,834 --> 00:42:32,737
and remap the value range into something usable.

680
00:42:32,737 --> 00:42:38,261
And that is, the same is used for fading off the waves.

681
00:42:38,261 --> 00:42:42,584
Speaking of waves, here is how the wave function was made.

682
00:42:42,584 --> 00:42:45,486
It could have been made in many ways.

683
00:42:45,486 --> 00:42:47,888
The important thing here is that it takes

684
00:42:47,888 --> 00:42:50,790
the orientation of the glass into account.

685
00:42:50,790 --> 00:42:55,073
So that the waves are going in the right direction.

686
00:43:02,308 --> 00:43:06,491
Again, to summarize, fill the container with liquid,

687
00:43:06,491 --> 00:43:11,135
force all vertices above our liquid heights to that height,

688
00:43:11,135 --> 00:43:15,139
put the vertices back into the glass using the radius,

689
00:43:15,139 --> 00:43:17,101
and fade the liquid off when it fails.

690
00:43:17,101 --> 00:43:21,064
I realize that this may be a lot to take in,

691
00:43:21,064 --> 00:43:26,789
so you can download the slides and the demo from this link.

692
00:43:28,900 --> 00:43:31,783
Today we've been looking at cosmetic interactions,

693
00:43:31,783 --> 00:43:34,164
passive interactions, and payoff interactions.

694
00:43:34,164 --> 00:43:35,966
We've been talking theory

695
00:43:35,966 --> 00:43:39,789
and looking at various implementations.

696
00:43:39,789 --> 00:43:41,790
The facts I've been sharing with you today

697
00:43:41,790 --> 00:43:44,493
may not be applicable to your project,

698
00:43:44,493 --> 00:43:46,814
but I think it's well worth mentioning it

699
00:43:46,814 --> 00:43:48,696
in the context of visual effects.

700
00:43:56,385 --> 00:43:58,246
So hopefully the methodology or functions

701
00:43:58,246 --> 00:44:00,147
will be useful to you.

702
00:44:00,147 --> 00:44:03,088
I just want to say thank you to everyone who's been

703
00:44:03,088 --> 00:44:04,749
contributed to making this happen.

704
00:44:04,749 --> 00:44:08,210
And thank you very much for listening.

705
00:44:08,210 --> 00:44:08,510
Thank you.

706
00:44:08,510 --> 00:44:08,811
Thank you.

707
00:44:08,811 --> 00:44:08,991
Thank you.

708
00:44:08,991 --> 00:44:09,431
Thank you very much.

709
00:44:09,431 --> 00:44:09,811
Thank you very much.

710
00:44:09,811 --> 00:44:09,991
Thank you.

711
00:44:09,991 --> 00:44:18,375
Thank you very much.

712
00:44:25,579 --> 00:44:25,739
Hi.

713
00:44:25,739 --> 00:44:27,221
Hi.

714
00:44:27,221 --> 00:44:27,901
Great talk, by the way.

715
00:44:27,901 --> 00:44:35,370
In the example you did with the grass, you said you were using a render target, render

716
00:44:35,370 --> 00:44:41,957
texture to create all the information that the shader is going to use to deform the plants,

717
00:44:41,957 --> 00:44:42,518
right?

718
00:44:42,798 --> 00:44:48,884
How do you account for bigger levels? For example, in your example there was a small square with

719
00:44:48,884 --> 00:44:55,571
about six plants, but if you got like a giant stage with a lot of plants, how do you account for that?

720
00:44:56,137 --> 00:45:02,099
Yes, so the way it works is that the render target is actually following the player, so

721
00:45:02,099 --> 00:45:06,461
you wouldn't see deformation of plants happening in the far distance.

722
00:45:06,461 --> 00:45:12,203
You would only see it close to you, maybe 50 meters at maximum.

723
00:45:12,203 --> 00:45:16,465
So everything is like on a world scale UV?

724
00:45:16,465 --> 00:45:18,826
Something like that?

725
00:45:18,826 --> 00:45:20,427
It is in relation to the world.

726
00:45:20,427 --> 00:45:23,108
The camera is in relation to the world, yeah.

727
00:45:23,108 --> 00:45:23,628
Thanks.

728
00:45:29,894 --> 00:45:32,817
Hey, so I just want to piggyback off that.

729
00:45:32,817 --> 00:45:36,020
With all your render buffers, you have a lot of them just

730
00:45:36,020 --> 00:45:38,562
reserved for minute details in the game.

731
00:45:38,562 --> 00:45:42,005
At any point, did you guys run out of memory for your actual

732
00:45:42,005 --> 00:45:42,906
render fetches?

733
00:45:42,906 --> 00:45:47,891
So in Hitman, the render targets weren't very big.

734
00:45:47,891 --> 00:45:50,133
They were about 512 pixels.

735
00:45:50,133 --> 00:45:52,315
And

736
00:45:54,618 --> 00:45:57,700
We were reusing them for multi-purposes,

737
00:45:57,700 --> 00:46:01,582
so they weren't just used for plants or water,

738
00:46:01,582 --> 00:46:02,863
but to many things,

739
00:46:02,863 --> 00:46:07,246
and we don't need to have many of them, basically.

740
00:46:07,246 --> 00:46:09,407
Cool, thanks.

741
00:46:09,407 --> 00:46:15,230
Anyone else?

742
00:46:15,230 --> 00:46:17,011
Oh, cool.

743
00:46:17,011 --> 00:46:21,674
Thank you very much.

