1
00:00:04,290 --> 00:00:05,631
Good afternoon, everyone.

2
00:00:05,631 --> 00:00:07,391
My name is Geet Shroff.

3
00:00:07,391 --> 00:00:10,032
I'll be kicking off the open world hour here at the summit

4
00:00:10,032 --> 00:00:12,032
today.

5
00:00:12,032 --> 00:00:14,012
So first, a little bit about me.

6
00:00:14,012 --> 00:00:17,673
I started off in the industry in 2004 at EA Sports,

7
00:00:17,673 --> 00:00:21,374
working on central technology and the FIFA soccer

8
00:00:21,374 --> 00:00:25,755
franchise as an animation and AI programmer for a few years.

9
00:00:25,755 --> 00:00:28,136
Then I moved over to Ubisoft Montreal,

10
00:00:28,136 --> 00:00:31,396
where I was the programmer and realization director for AI

11
00:00:31,396 --> 00:00:32,057
on Far Cry 3.

12
00:00:32,933 --> 00:00:35,654
And currently I'm at Avalanche Studios in New York,

13
00:00:35,654 --> 00:00:39,036
working as a programmer, helping lead character development

14
00:00:39,036 --> 00:00:42,677
in AI, player mechanics, and animation.

15
00:00:42,677 --> 00:00:45,998
So the structure of the talk is a little bit high level.

16
00:00:45,998 --> 00:00:48,279
More concepts and techniques I've worked with

17
00:00:48,279 --> 00:00:50,059
and are currently developing.

18
00:00:50,059 --> 00:00:53,300
A lot of these ideas aren't limited to just open world

19
00:00:53,300 --> 00:00:56,461
games, but they apply definitely directly to them.

20
00:00:57,195 --> 00:01:03,559
I'll be focusing on three major themes, particularly the design, behavior, and realization of open-world AI.

21
00:01:03,559 --> 00:01:05,940
And I've tried to be as structured as possible,

22
00:01:05,940 --> 00:01:14,585
but I encourage you to keep these themes in the back of your mind as I go back and forth between them throughout the talk.

23
00:01:14,585 --> 00:01:18,787
So I want to start by first talking about what makes a game an open-world game.

24
00:01:18,787 --> 00:01:26,352
When we think of open-world games, we think about size and scale. We think about freedom, freedom to explore.

25
00:01:26,940 --> 00:01:28,461
to pick and choose what to play,

26
00:01:28,461 --> 00:01:31,464
to kind of pick and choose how we want to play.

27
00:01:31,464 --> 00:01:34,666
We think of a living and breathing simulation that makes up the world.

28
00:01:34,666 --> 00:01:38,310
And all of these things are pretty important elements in open world games today.

29
00:01:39,672 --> 00:01:43,253
And along with those elements, a key ingredient for us

30
00:01:43,253 --> 00:01:45,594
at Avalanche is this idea of a sandbox.

31
00:01:45,594 --> 00:01:49,935
So we want to put the fantasy in the hands of the player.

32
00:01:49,935 --> 00:01:51,475
And we want to allow the player to be

33
00:01:51,475 --> 00:01:53,836
able to craft their own gameplay experiences.

34
00:01:53,836 --> 00:01:55,496
And we want to really try to have

35
00:01:55,496 --> 00:01:57,517
all these systems that interact with each other.

36
00:01:57,517 --> 00:02:02,098
And we want to extend that idea to all aspects of gameplay,

37
00:02:02,098 --> 00:02:05,458
so be it missions, or world sim, or challenges.

38
00:02:05,458 --> 00:02:07,919
And we don't want to limit it to any one of these.

39
00:02:10,040 --> 00:02:12,400
And that sounds great, and it is,

40
00:02:12,400 --> 00:02:14,301
until somebody pees in your sandbox.

41
00:02:14,301 --> 00:02:17,641
So in the sense that we can build this awesome world,

42
00:02:17,641 --> 00:02:20,102
but when somebody else is in charge,

43
00:02:20,102 --> 00:02:21,922
things that you don't expect to happen

44
00:02:21,922 --> 00:02:23,202
are most certainly gonna happen.

45
00:02:23,202 --> 00:02:26,463
And they're probably gonna find their way onto YouTube.

46
00:02:26,463 --> 00:02:30,023
So giving the player control means you as a designer

47
00:02:30,023 --> 00:02:31,224
or developer don't have it.

48
00:02:31,224 --> 00:02:37,145
And that raises obvious challenges for our AI.

49
00:02:37,145 --> 00:02:39,765
We need our AI to be adaptable and reactive.

50
00:02:40,321 --> 00:02:42,863
We need them to scale well, to deal with the size

51
00:02:42,863 --> 00:02:45,525
and all the different contexts in the world.

52
00:02:45,525 --> 00:02:48,848
We need them to be interesting enough and well realized

53
00:02:48,848 --> 00:02:51,550
for the player to be able to engage with them

54
00:02:51,550 --> 00:02:54,612
in a long period of time and discover all the ways

55
00:02:54,612 --> 00:02:56,714
that they can interact with the AI.

56
00:02:56,714 --> 00:02:58,856
And in terms of realization, that's pretty much

57
00:02:58,856 --> 00:03:01,478
what players now expect from all our games,

58
00:03:01,478 --> 00:03:02,719
linear or otherwise.

59
00:03:02,719 --> 00:03:06,082
So I want to start by talking about this idea

60
00:03:06,082 --> 00:03:08,664
of maintaining longevity.

61
00:03:09,621 --> 00:03:13,362
We can think of our games as having several sort of core gameplay loops, right?

62
00:03:13,362 --> 00:03:17,824
You can be in combat, you can be in exploration, you could be in a challenge.

63
00:03:17,824 --> 00:03:23,426
And we want our player to have or create variation in these different loops.

64
00:03:23,426 --> 00:03:26,808
So the challenge is really dealing with repetitiveness

65
00:03:26,808 --> 00:03:31,330
and providing the right motivation that encourages the player to be creative

66
00:03:31,330 --> 00:03:32,890
and keep playing the game.

67
00:03:32,890 --> 00:03:37,652
So we can do things like add constraints that try and create variation.

68
00:03:38,428 --> 00:03:43,949
You know, things like different environments, time limits for our missions, changing the amount of enemies that show up.

69
00:03:43,949 --> 00:03:51,350
All of these things might work, but there's no guarantee that it will cause the player to actually try something different.

70
00:03:51,350 --> 00:03:51,570
Okay?

71
00:03:51,570 --> 00:03:59,512
Well, you know, let's introduce unique and scripted gameplay and force the player to engage in a different form of gameplay.

72
00:03:59,512 --> 00:04:03,553
And while this is important, it works really well for linear and structured games.

73
00:04:03,553 --> 00:04:06,073
And it's a little bit tricky for open world.

74
00:04:06,625 --> 00:04:10,608
So the motivation to repeat a scripted sequence is really low,

75
00:04:10,608 --> 00:04:13,250
and there's a lack of discovery that happens.

76
00:04:13,250 --> 00:04:16,833
You're not going to discover any new elements the second time around.

77
00:04:16,833 --> 00:04:18,654
So what can we do?

78
00:04:18,654 --> 00:04:24,499
So to deal with this, we can start with the player behaviors first.

79
00:04:24,499 --> 00:04:26,701
This idea is not new in any way.

80
00:04:26,701 --> 00:04:30,244
Paul Tesor has actually talked about this in the past,

81
00:04:30,244 --> 00:04:34,627
where he uses AI techniques and representations to actually analyze and profile gameplay.

82
00:04:35,387 --> 00:04:38,188
So we can extend that to the player.

83
00:04:38,188 --> 00:04:41,288
And the idea is to actually represent or script

84
00:04:41,288 --> 00:04:45,789
the intended player up front as sort of a design exercise,

85
00:04:45,789 --> 00:04:49,270
like you would do for any non-player character in the game.

86
00:04:49,270 --> 00:04:51,731
And this is really easy for us to do.

87
00:04:51,731 --> 00:04:53,831
We've developed languages and techniques

88
00:04:53,831 --> 00:04:56,972
on actually how to model perception and behavior.

89
00:04:56,972 --> 00:04:58,792
That's what we do as AI programmers.

90
00:05:00,112 --> 00:05:04,474
So doing this, we can really identify from an AI point of view

91
00:05:04,474 --> 00:05:08,915
what new actual enemy types or new enemy behaviors we're going to need

92
00:05:08,915 --> 00:05:11,516
to motivate the player to do something different,

93
00:05:11,516 --> 00:05:12,276
sort of like input.

94
00:05:12,276 --> 00:05:14,557
And we can see this,

95
00:05:14,557 --> 00:05:18,459
you know, we can see if it can actually be clearly communicated to the player,

96
00:05:18,459 --> 00:05:21,160
sort of like having the right perception in place,

97
00:05:21,160 --> 00:05:24,981
to ensure that the player has the information he needs to make those decisions.

98
00:05:25,607 --> 00:05:32,091
And, you know, to really drive the point home, think of a simple context of even picking a car for a challenge.

99
00:05:32,091 --> 00:05:39,715
If you were to actually script that behavior for an AI, if you didn't give the AI any information about the race,

100
00:05:39,715 --> 00:05:40,716
he's going to pick randomly.

101
00:05:40,716 --> 00:05:46,259
And then he's going to have a really poor experience without knowing, not knowing what the race is about.

102
00:05:46,259 --> 00:05:48,420
And that's the same sort of exercise you go through.

103
00:05:50,541 --> 00:05:57,445
Starting with the player behaviors up front makes the design player-centric, and that's really beneficial for open-world games.

104
00:05:57,845 --> 00:06:03,247
And it's important to remember that we can trust the player to create variation on their own,

105
00:06:03,247 --> 00:06:07,889
as they interact with the systems within the world in unique and different ways.

106
00:06:07,889 --> 00:06:12,832
So, for example, in Far Cry 3, you know, running into an outpost with enemies

107
00:06:12,832 --> 00:06:18,114
when a tiger is actually chasing you is going to create a different combat experience than just

108
00:06:18,114 --> 00:06:22,816
going in alone. It's this overlap of systems which is what's really interesting.

109
00:06:23,397 --> 00:06:27,980
So, the next thing I actually want to talk about is dealing with this variation.

110
00:06:27,980 --> 00:06:32,223
When you introduce freedom, you're going to have to deal with a wide range of situations,

111
00:06:32,223 --> 00:06:34,725
and that is one of the biggest challenges for us.

112
00:06:34,725 --> 00:06:38,307
So if you look at a game like Just Cause 2...

113
00:06:39,608 --> 00:06:44,372
The player here can actually travel extremely fast from one end to the other.

114
00:06:44,372 --> 00:06:47,134
He can choose to get up in the air whenever he wants.

115
00:06:47,134 --> 00:06:52,058
He can drive actual, you know, a wide range of vehicles into different combat situations.

116
00:06:52,058 --> 00:06:54,280
Quite literally anything can happen.

117
00:06:54,280 --> 00:06:57,422
And this makes a lot of things really difficult.

118
00:06:59,560 --> 00:07:06,367
So, you know, things like staging our characters, positioning them, and things like controlling

119
00:07:06,367 --> 00:07:08,610
pace, all of this become very challenging.

120
00:07:08,610 --> 00:07:14,837
And a key kicker here is that it's hard to deliver a consistent player experience that's

121
00:07:14,837 --> 00:07:15,377
positive.

122
00:07:16,074 --> 00:07:20,440
And this is a huge advantage that linear games have over open world games.

123
00:07:20,440 --> 00:07:23,664
You know, they can better control things like setting up pace,

124
00:07:23,664 --> 00:07:27,450
they can set up very specific situations that the player must play through,

125
00:07:27,450 --> 00:07:29,753
and even though it's a singular experience,

126
00:07:29,753 --> 00:07:33,438
they can guarantee that it's a solid and positive experience.

127
00:07:35,045 --> 00:07:43,053
So for our AI and our characters, we definitely need a systemic and non-scripted solution to deal with this problem.

128
00:07:43,053 --> 00:07:46,536
In our current games, we choose to deal with this in layers.

129
00:07:46,536 --> 00:07:52,301
So if we look at this example of AI positioning, here we have a bunch of AI around the player,

130
00:07:52,301 --> 00:07:58,868
and we don't want to lose this idea of a sort of non-linear 360 degree combat situation.

131
00:08:02,524 --> 00:08:08,126
So, our first simple heuristic would be to get within range of the player.

132
00:08:08,126 --> 00:08:09,987
And this can work, has some obvious issues,

133
00:08:09,987 --> 00:08:13,188
you know, the player could end up feeling swarmed,

134
00:08:13,188 --> 00:08:15,609
there's no real feeling of progression,

135
00:08:15,609 --> 00:08:17,490
and with this sort of simple approach,

136
00:08:17,490 --> 00:08:20,931
there's absolutely no control on pacing.

137
00:08:20,931 --> 00:08:22,712
So let's build on top of that.

138
00:08:22,712 --> 00:08:26,474
So first we add a layer of behavioral annotation to the world.

139
00:08:26,474 --> 00:08:28,895
In this case, you know, we can add cover objects.

140
00:08:29,554 --> 00:08:32,936
Data driving behaviors is a constant theme in our solutions,

141
00:08:32,936 --> 00:08:37,819
giving our level designers this control to actually place objects in the world

142
00:08:37,819 --> 00:08:42,622
which have associated behavior allows them to now control and guide positioning

143
00:08:42,622 --> 00:08:44,183
while keeping things systemic.

144
00:08:44,183 --> 00:08:50,928
Associating behavior with the environment also makes it really easy to realize those actions,

145
00:08:50,928 --> 00:08:53,189
and this makes it very convincing for the player.

146
00:08:54,862 --> 00:08:57,283
Well, what about the NPCs that actually don't find

147
00:08:57,283 --> 00:08:58,804
or have any cover?

148
00:08:58,804 --> 00:09:01,666
So we choose to add in a backup behavior,

149
00:09:01,666 --> 00:09:03,928
like utility-based positioning.

150
00:09:03,928 --> 00:09:07,070
So using a simple utility map that's relative to the player

151
00:09:07,070 --> 00:09:09,031
allows for much better positioning

152
00:09:09,031 --> 00:09:11,012
than simply running within range.

153
00:09:11,012 --> 00:09:13,034
And simple heuristics could include

154
00:09:13,034 --> 00:09:15,835
the current occupancy on the map to prevent clustering,

155
00:09:15,835 --> 00:09:17,657
the current distance to the player,

156
00:09:17,657 --> 00:09:19,218
or the distance from where I am

157
00:09:19,218 --> 00:09:21,299
to the new point I want to go to.

158
00:09:21,299 --> 00:09:24,081
All of these things help stage our characters better.

159
00:09:25,878 --> 00:09:29,080
So we've got our environment and we've got our utility fallback.

160
00:09:29,080 --> 00:09:33,103
Now I want to come back to this idea of providing a good player experience,

161
00:09:33,103 --> 00:09:36,285
which is what linear games have over open world games.

162
00:09:36,285 --> 00:09:40,348
So we can actually add a layer to specifically contribute to this.

163
00:09:40,348 --> 00:09:42,789
And I call this on-screen realization.

164
00:09:42,789 --> 00:09:43,790
It's an example of it.

165
00:09:43,790 --> 00:09:47,532
So, you know, focus positioning based on what the player sees.

166
00:09:47,532 --> 00:09:49,454
So some examples of this are...

167
00:09:49,954 --> 00:09:57,177
AIs that are actually on screen choose to pick lateral covers over covers that are actually in front of them or behind them.

168
00:09:57,177 --> 00:10:00,858
And this allows for a lot better staging and realization for our AI.

169
00:10:00,858 --> 00:10:04,160
We can do things like sliding into cover sideways and it looks cool.

170
00:10:04,160 --> 00:10:06,400
And it's engaging for the player.

171
00:10:06,400 --> 00:10:14,043
We can do things like AIs that are actually on screen will choose positions that keep them on screen.

172
00:10:14,043 --> 00:10:18,905
You know, this is really annoying when NPC characters run off screen and you have to chase after them.

173
00:10:19,826 --> 00:10:24,869
Once spotted, AIs can tend to stay within quadrants of positioning,

174
00:10:24,869 --> 00:10:29,692
and so, you know, the player can have this relative knowledge of where they are,

175
00:10:29,692 --> 00:10:30,873
even if they go off-screen.

176
00:10:30,873 --> 00:10:37,017
And, you know, we heavily also use this for behavior synchronization or distribution.

177
00:10:37,017 --> 00:10:40,419
And all of these things really add to that player experience.

178
00:10:43,826 --> 00:10:50,617
Finally, we can add a layer of pseudoscripting to provide our LDs a lot more control if and when they need it.

179
00:10:50,617 --> 00:10:57,608
And I use the term pseudoscripting because what we really want here is to allow our level designers to treat our AI like

180
00:10:58,281 --> 00:11:02,987
We want them to actually be like free-spirited parents when it comes to our systemic AI.

181
00:11:02,987 --> 00:11:09,755
An example of this is like area restrictions, where you can actually keep the AI bound to specific locations,

182
00:11:09,755 --> 00:11:11,917
allowing for better control and pace,

183
00:11:11,917 --> 00:11:16,283
and giving the player a sense of progression, while again keeping things systemic.

184
00:11:17,957 --> 00:11:21,938
So to sort of summarize, try and use a layered systemic approach

185
00:11:21,938 --> 00:11:25,279
to deal with variation and huge heuristics that cater

186
00:11:25,279 --> 00:11:27,199
for the player experience.

187
00:11:27,199 --> 00:11:30,440
So we want to build systems and not moments, systems

188
00:11:30,440 --> 00:11:32,600
that work with and for the player,

189
00:11:32,600 --> 00:11:35,541
not just in specific moments of gameplay.

190
00:11:35,541 --> 00:11:40,822
So slightly shifting our focus now onto behavior specifically.

191
00:11:43,182 --> 00:11:47,166
As players, we want NPCs in our games to behave compellingly.

192
00:11:47,166 --> 00:11:50,670
And this includes having a wide range of actions to perform

193
00:11:50,670 --> 00:11:54,134
and meaningful ways to respond to those different contexts.

194
00:11:54,134 --> 00:11:55,855
And in open world games, we need to worry

195
00:11:55,855 --> 00:11:58,758
about the size of the world and the complexity of decisions

196
00:11:58,758 --> 00:11:59,279
for our NPCs.

197
00:11:59,279 --> 00:12:01,481
And for this next section, I'd like

198
00:12:01,481 --> 00:12:03,924
to go into more details about how we specifically

199
00:12:03,924 --> 00:12:04,724
deal with behaviors.

200
00:12:06,850 --> 00:12:08,872
So for the kinds of games we're making,

201
00:12:08,872 --> 00:12:11,674
the goal is to have an annotated world that

202
00:12:11,674 --> 00:12:14,096
provides enough contextual information to allow

203
00:12:14,096 --> 00:12:16,818
our AI to behave systemically.

204
00:12:16,818 --> 00:12:19,460
So we really wanted a way to represent our behaviors that

205
00:12:19,460 --> 00:12:23,043
reduce complexity and are easy to understand.

206
00:12:23,043 --> 00:12:25,685
And this empowers our designers and our players.

207
00:12:25,685 --> 00:12:29,708
So at Avalanche, we use behavior trees

208
00:12:29,708 --> 00:12:31,110
for our NPCs in our games.

209
00:12:31,792 --> 00:12:36,696
I'm not going to really go into details about the pros and cons of different AI architectures,

210
00:12:36,696 --> 00:12:40,058
but I want to iterate our motivations for doing this and why that helps us.

211
00:12:40,058 --> 00:12:46,343
So, currently, we have our designers that actually do all our behavior scripting.

212
00:12:46,962 --> 00:12:50,504
And behavior trees are extremely designer and developer friendly.

213
00:12:50,504 --> 00:12:54,106
They're easy for our designers to actually understand and script

214
00:12:54,106 --> 00:12:58,009
how the AI will actually behave in different situations.

215
00:12:58,009 --> 00:13:02,411
Within the trees, we can also give them specific control

216
00:13:02,411 --> 00:13:05,953
on how those behaviors will be realized.

217
00:13:05,953 --> 00:13:09,455
So here's an example of a behavior tree in our behavior tree editor.

218
00:13:09,455 --> 00:13:12,737
It's been developed by our very own Joachim Jacobsen.

219
00:13:13,333 --> 00:13:18,275
designers go in there, author, tweak, and debug behaviors directly.

220
00:13:18,275 --> 00:13:23,177
So the tool supports debugging a frame execution through the replay of game frames.

221
00:13:23,177 --> 00:13:27,618
We can pause, go back a few frames, step through, you know, find out what's going on

222
00:13:27,618 --> 00:13:29,819
just the way you would debug a regular program.

223
00:13:29,819 --> 00:13:35,380
These visualization and debugging aspects have vastly improved development time

224
00:13:35,380 --> 00:13:39,262
and made the creation of new behaviors a lot more robust and manageable.

225
00:13:42,255 --> 00:13:46,498
So going into sort of now the advantages of behavior trees

226
00:13:46,498 --> 00:13:49,279
for us, behavior trees inherently

227
00:13:49,279 --> 00:13:52,521
support a predetermined priority of behaviors to execute.

228
00:13:52,521 --> 00:13:55,383
And this works really well for us.

229
00:13:55,383 --> 00:13:58,185
We've chosen to have our NPCs have

230
00:13:58,185 --> 00:14:01,507
a unique set of core deterministic behaviors.

231
00:14:01,507 --> 00:14:03,848
Now this helps us deal with complexity,

232
00:14:03,848 --> 00:14:07,070
and it also keeps our realization cost low

233
00:14:07,070 --> 00:14:09,831
and also makes it easier to debug.

234
00:14:10,544 --> 00:14:14,790
But a key advantage is that it makes it much more obvious to the player.

235
00:14:14,790 --> 00:14:18,315
So making behaviors obvious to the player in our games

236
00:14:18,315 --> 00:14:23,683
allows for them to interact with the AI in meaningful ways.

237
00:14:23,683 --> 00:14:26,486
You know, if the player doesn't understand what's happening,

238
00:14:26,486 --> 00:14:27,288
it isn't happening at all.

239
00:14:30,978 --> 00:14:34,480
Behavior trees also support a multi-layered architecture.

240
00:14:34,480 --> 00:14:37,682
And this makes things like pseudoscripting really easy.

241
00:14:37,682 --> 00:14:40,704
So, you know, we can override and influence behaviors

242
00:14:40,704 --> 00:14:44,987
simply by having a scripted layer exist on top of any level of our tree.

243
00:14:44,987 --> 00:14:50,090
And we do this heavily for staging and setting up our characters,

244
00:14:50,090 --> 00:14:54,213
and also for setting up specific scenes for driving narrative forward in-game.

245
00:14:55,430 --> 00:14:59,551
This layering also helps us maintain context

246
00:14:59,551 --> 00:15:01,812
when handling events that the AI must react to.

247
00:15:01,812 --> 00:15:04,513
Open world games are extremely reactive.

248
00:15:04,513 --> 00:15:07,594
And the advantage of this is that the deeper you are

249
00:15:07,594 --> 00:15:11,455
in the tree, the more clearer the context of the situation.

250
00:15:11,455 --> 00:15:14,416
So we can choose to actually handle these events

251
00:15:14,416 --> 00:15:17,357
at any level, and at that lowest level if we need to,

252
00:15:17,357 --> 00:15:20,998
and have fallback handling in place for other cases.

253
00:15:20,998 --> 00:15:23,939
And this helps us deal with realization and improve it.

254
00:15:27,511 --> 00:15:33,354
So, you know, you might think that having a predetermined set of core behaviors actually limits behavior variety.

255
00:15:33,354 --> 00:15:39,058
And while this seems limiting, we use the concept of sub-behaviors to sprinkle in variation.

256
00:15:39,058 --> 00:15:46,562
So you can think of sub-behaviors as really small mini-behaviors that can either run in parallel with your core behavior

257
00:15:46,562 --> 00:15:53,926
to simply provide realization variety or temporarily actually interrupt a core behavior to perform a specific action.

258
00:15:53,926 --> 00:15:56,027
And the choice is really up to you here.

259
00:15:58,524 --> 00:16:04,948
So we use a lot of these little mini behaviors to create variety and break up behavior synchronization.

260
00:16:04,948 --> 00:16:11,792
Sub behaviors are also really great place to use fuzzy logic in terms of, you know, when you want to choose to actually execute them.

261
00:16:11,792 --> 00:16:16,795
So a quick example here is say you have two NPCs that are running their core cover behavior.

262
00:16:16,795 --> 00:16:23,038
You know, they're peeking and shooting, they're evaluating for better cover, they're doing all that fun stuff.

263
00:16:24,087 --> 00:16:27,569
And one of the NPCs suddenly decides to reposition.

264
00:16:27,569 --> 00:16:30,752
So he simply writes that information onto our blackboard,

265
00:16:30,752 --> 00:16:34,194
as Michael pointed out, just information for everyone

266
00:16:34,194 --> 00:16:36,376
to read.

267
00:16:36,376 --> 00:16:38,798
And the covered behavior itself can simply

268
00:16:38,798 --> 00:16:43,041
have a sub-behavior running that reads this value

269
00:16:43,041 --> 00:16:46,163
and plays a one-off animation to ask him to move forward.

270
00:16:46,163 --> 00:16:49,045
This really doesn't need to be synchronized at all.

271
00:16:49,045 --> 00:16:51,527
It gives the illusion of coordination,

272
00:16:51,527 --> 00:16:53,508
and it adds behavioral variety.

273
00:16:53,911 --> 00:16:57,093
you can choose how often to select these sub-behaviors,

274
00:16:57,093 --> 00:17:00,515
and they have a high chance of actually being reused.

275
00:17:00,515 --> 00:17:03,817
So you can reuse this sub-behavior in a search behavior

276
00:17:03,817 --> 00:17:08,801
or in any other behavior if you choose to.

277
00:17:08,801 --> 00:17:11,803
So, recently we've actually extended our behavior trees

278
00:17:11,803 --> 00:17:14,344
to support external trees.

279
00:17:14,344 --> 00:17:16,906
External trees are behavior trees that can be loaded in

280
00:17:16,906 --> 00:17:18,207
from an external source

281
00:17:18,207 --> 00:17:20,448
and are run through the main behavior tree.

282
00:17:21,083 --> 00:17:24,867
So currently, these are plugged in throughout the environment,

283
00:17:24,867 --> 00:17:26,989
and game objects in the world themselves

284
00:17:26,989 --> 00:17:28,711
can specify these external trees.

285
00:17:28,711 --> 00:17:31,434
And this, again, helps us data drive behavior.

286
00:17:31,434 --> 00:17:33,576
So in my previous example, the sub behavior

287
00:17:33,576 --> 00:17:36,258
I actually talked about of actually playing

288
00:17:36,258 --> 00:17:38,641
that one-off animation, it could actually

289
00:17:38,641 --> 00:17:42,064
be specified in the cover object itself

290
00:17:42,064 --> 00:17:44,707
and executed by the NPC through an external tree.

291
00:17:46,089 --> 00:17:51,802
Other examples of where we use this are contextual actions that are spread across the world of the world

292
00:17:51,802 --> 00:17:55,149
And NPC search for them and interact with with those objects

293
00:17:57,878 --> 00:18:03,060
So, in my final section, I'd like to talk a little bit about how we go about realization

294
00:18:03,060 --> 00:18:05,681
and making our actual characters believable.

295
00:18:05,681 --> 00:18:09,683
So, realization is important because it's the secret sauce.

296
00:18:09,683 --> 00:18:11,283
It's what makes everything come together.

297
00:18:11,283 --> 00:18:15,965
I mean, Daniel Brewer yesterday talked about, you know, how everything came together when

298
00:18:15,965 --> 00:18:17,666
he was building that NPC.

299
00:18:17,666 --> 00:18:21,627
And it includes everything from animation to sounds to barks.

300
00:18:21,627 --> 00:18:25,589
But for the purpose of this presentation, I'd like to focus on behavior and animation.

301
00:18:25,928 --> 00:18:31,122
So the biggest challenges here are maintaining fidelity for a wide range of situations

302
00:18:31,122 --> 00:18:32,986
and dealing with a limited amount of memory.

303
00:18:35,337 --> 00:18:37,318
So when it comes to AI and animation,

304
00:18:37,318 --> 00:18:40,460
it's common practice to have a layered setup, where

305
00:18:40,460 --> 00:18:43,602
your AI and animation systems are quite separated.

306
00:18:43,602 --> 00:18:45,083
Like in most games, in our system,

307
00:18:45,083 --> 00:18:47,904
we use state machines for representing our character

308
00:18:47,904 --> 00:18:49,125
states and animations.

309
00:18:49,125 --> 00:18:52,987
AI info is actually gathered by our behavior trees.

310
00:18:52,987 --> 00:18:55,709
The trees are evaluated, and they can send events

311
00:18:55,709 --> 00:18:57,250
to our state machine.

312
00:18:57,250 --> 00:19:00,051
The NPCs can transition from state to state

313
00:19:00,051 --> 00:19:01,812
and perform their associated actions.

314
00:19:06,461 --> 00:19:10,584
So in our actual system, we have several state machines

315
00:19:10,584 --> 00:19:13,206
that actually link to different animation layers

316
00:19:13,206 --> 00:19:15,008
within the animation system.

317
00:19:15,008 --> 00:19:19,571
While we actually want to keep our animation system separated

318
00:19:19,571 --> 00:19:21,813
from our AI and state logic, there

319
00:19:21,813 --> 00:19:25,176
are actual advantages in keeping the behavior trees and state

320
00:19:25,176 --> 00:19:26,096
machines in sync.

321
00:19:26,763 --> 00:19:30,964
There's a lot of situations I've seen where behavior tree logic continues to run

322
00:19:30,964 --> 00:19:35,546
even when the state machine can't, and more importantly, shouldn't handle the request.

323
00:19:35,546 --> 00:19:38,647
So say, for example, you have an NPC that's sliding into cover.

324
00:19:38,647 --> 00:19:43,228
Well, you probably don't want this character to be running his look-at behavior

325
00:19:43,228 --> 00:19:44,969
and try to look at other characters while doing this.

326
00:19:44,969 --> 00:19:50,311
So it's important to provide this feedback loop from your state machine back to your behavior trees

327
00:19:50,311 --> 00:19:53,812
and have the trees actually understand what state the character is in.

328
00:19:54,492 --> 00:19:57,315
So in our system, we use the concept of state bits

329
00:19:57,315 --> 00:19:59,797
that inform the behavior tree on what state the character is in.

330
00:19:59,797 --> 00:20:02,499
And these state, it's a really simple concept.

331
00:20:02,499 --> 00:20:04,841
The state bits are simply set on entering a state

332
00:20:04,841 --> 00:20:06,663
and are removed when you exit.

333
00:20:06,663 --> 00:20:12,888
We've also extended this idea of data-driving behaviors

334
00:20:12,888 --> 00:20:14,329
to the character system as well.

335
00:20:14,329 --> 00:20:18,232
So previously, our character logic was encapsulated

336
00:20:18,232 --> 00:20:20,294
in what we call character controllers.

337
00:20:20,294 --> 00:20:23,336
These tended to be extremely cumbersome.

338
00:20:24,174 --> 00:20:30,177
and very bug-prone, because they handled a lot of logic and were shared across many states.

339
00:20:30,177 --> 00:20:35,439
So you can imagine a lot of special case branching, and it made debugging a huge pain.

340
00:20:36,502 --> 00:20:41,425
So now we've actually moved over to more of a component-based setup with the introduction of state tasks.

341
00:20:41,425 --> 00:20:44,467
You can think of state tasks as little snippets of code,

342
00:20:44,467 --> 00:20:51,791
and each state can actually pick and choose what state task it wants to run. So anything from handling specific input

343
00:20:51,791 --> 00:20:59,336
to updating camera settings to actually all the way to how we actually update our character motion is now handled in state tasks.

344
00:20:59,993 --> 00:21:03,815
And you know, it's modular and it can be reused.

345
00:21:03,815 --> 00:21:07,777
So this whole thing has been exposed to our scripting system as well,

346
00:21:07,777 --> 00:21:15,961
so we can actually data drive character logic. And this again speeds up development time and helps us deal with handling lots of different character

347
00:21:15,961 --> 00:21:17,242
behaviors and contexts.

348
00:21:20,117 --> 00:21:24,982
Similar to external behavior trees, we also use what we call external state machines.

349
00:21:24,982 --> 00:21:29,586
This is a way for us to actually load in an external state machine,

350
00:21:29,586 --> 00:21:35,691
along with an entire external set of states, transitions, and a default set of animations,

351
00:21:35,691 --> 00:21:39,174
and connect it up to the original state machine to extend it on the fly.

352
00:21:39,875 --> 00:21:43,540
Once we're done with it, we simply disconnect this machine.

353
00:21:43,540 --> 00:21:50,070
So, with this approach, game objects themselves can specify external state machines that they want to use,

354
00:21:50,070 --> 00:21:54,957
and we can actually go in and override those default set of animations.

355
00:21:55,653 --> 00:21:59,895
All of our NPC interactions within the world are handled this way.

356
00:21:59,895 --> 00:22:02,276
So, for example, I'll use ladders as an example.

357
00:22:02,276 --> 00:22:09,599
The ladders can specify an external state machine for interacting with objects.

358
00:22:09,599 --> 00:22:17,483
And the ladder game object itself can override the default set of animations with ladder-specific ones.

359
00:22:17,483 --> 00:22:17,543
So...

360
00:22:19,302 --> 00:22:21,927
the external state machine and the ladder animations

361
00:22:21,927 --> 00:22:24,912
aren't actually loaded in unless the ladders are

362
00:22:24,912 --> 00:22:25,813
part of that location.

363
00:22:25,813 --> 00:22:28,438
And so with an even placement of these interactions

364
00:22:28,438 --> 00:22:31,804
within the world, we can save on memory for our animations.

365
00:22:32,894 --> 00:22:35,675
There are also a whole bunch of non-standardish features

366
00:22:35,675 --> 00:22:38,116
that we do within our animation system,

367
00:22:38,116 --> 00:22:41,158
like heavily relying on warping techniques,

368
00:22:41,158 --> 00:22:44,859
using specific additive and IK systems

369
00:22:44,859 --> 00:22:47,000
that help us improve fidelity and save memory.

370
00:22:47,000 --> 00:22:49,201
But I'll have to save that for another talk.

371
00:22:49,201 --> 00:22:51,562
And you can find me later if you want more info.

372
00:22:51,562 --> 00:22:54,944
But to summarize, if you haven't been

373
00:22:54,944 --> 00:22:57,045
listening for the last half hour,

374
00:22:57,045 --> 00:22:58,185
here are your key takeaways.

375
00:22:59,008 --> 00:23:01,409
Focus on player-centric and systemic solutions

376
00:23:01,409 --> 00:23:02,950
when dealing with open-world AI.

377
00:23:02,950 --> 00:23:08,112
Take advantage of layering, both at a behavior and animation

378
00:23:08,112 --> 00:23:10,954
level, and data drive as much as possible,

379
00:23:10,954 --> 00:23:13,275
not just values or parameters, but don't

380
00:23:13,275 --> 00:23:16,696
be afraid to data drive behavior and character logic as well.

381
00:23:16,696 --> 00:23:20,838
I'd like to thank Niklas Noreen and Omar Shakir for their help

382
00:23:20,838 --> 00:23:22,359
in putting this presentation together.

383
00:23:22,359 --> 00:23:24,500
I'd like to thank all of you as well.

384
00:23:24,500 --> 00:23:26,741
Now, please welcome Aaron Canary, who

385
00:23:26,741 --> 00:23:27,502
will talk about.

386
00:23:27,902 --> 00:23:37,465
Open World AI and Saints Row.

387
00:23:37,465 --> 00:23:45,548
A quick show of hands, who has shipped an open world game?

388
00:23:45,548 --> 00:23:46,408
Maybe 5-10%.

389
00:23:46,408 --> 00:23:53,171
Who is currently working on an open world game?

390
00:23:53,171 --> 00:23:54,411
Probably 30.

391
00:23:55,351 --> 00:23:58,915
She's curious.

392
00:24:05,763 --> 00:24:07,544
So I'm going to be continuing the talk on open-world AI.

393
00:24:07,544 --> 00:24:11,246
I'm going to hit three main topics today,

394
00:24:11,246 --> 00:24:13,327
open-world response, scalability,

395
00:24:13,327 --> 00:24:14,828
and environmental interaction.

396
00:24:14,828 --> 00:24:19,470
I feel like these are unique, but also really important

397
00:24:19,470 --> 00:24:21,231
aspects in making open-world games.

398
00:24:21,231 --> 00:24:23,252
And because it's a short talk, I'll

399
00:24:23,252 --> 00:24:27,094
assume you already know all of the ins and outs of normal AI

400
00:24:27,094 --> 00:24:29,575
and implementation.

401
00:24:30,802 --> 00:24:32,963
So you don't have to take pictures.

402
00:24:32,963 --> 00:24:37,586
These slides will be available on our website.

403
00:24:37,586 --> 00:24:39,727
My name is Aaron Canary.

404
00:24:39,727 --> 00:24:42,109
I started my gaming career on Saints Row 2,

405
00:24:42,109 --> 00:24:44,450
where I made AI intentionally look drunk.

406
00:24:44,450 --> 00:24:48,813
Red Faction Guerrilla, I made a number of gameplay systems

407
00:24:48,813 --> 00:24:50,514
and activities.

408
00:24:50,514 --> 00:24:54,817
Saints Row 3rd, I re-engineered core combat for faster

409
00:24:54,817 --> 00:24:59,800
iteration and implemented a number of special AI behaviors.

410
00:25:01,555 --> 00:25:04,917
And since row four, I was the only AI programmer

411
00:25:04,917 --> 00:25:06,617
before the expansion.

412
00:25:06,617 --> 00:25:09,458
And then after the expansion, I became the AI lead.

413
00:25:09,458 --> 00:25:13,740
But after being at Volition for seven years,

414
00:25:13,740 --> 00:25:18,201
I still feel like the new guy, because we have titles going

415
00:25:18,201 --> 00:25:21,102
back to 1995, and most of those guys are still around.

416
00:25:22,987 --> 00:25:33,650
Also, just to update everyone, we were part of the THQ bankruptcy, but we were bought out by Koch Media.

417
00:25:33,650 --> 00:25:40,972
Volition was picked up by Koch Media. You may know them as Deep Silver, also releasing Dead Island series, among many, many others.

418
00:25:40,972 --> 00:25:50,255
And in case you've been living under a rock, Sancero the Third is a third-person open-world shooter.

419
00:25:52,113 --> 00:25:58,938
adventure series with a comedic plot and a large variety of gameplay activities.

420
00:25:58,938 --> 00:26:00,820
First topic, open world response.

421
00:26:00,820 --> 00:26:06,924
So, in Sandstorm 2 we developed a lot of world systems and spawning systems

422
00:26:06,924 --> 00:26:10,487
that would react to things happening in the world.

423
00:26:10,487 --> 00:26:13,309
When cars caught on fire, fire trucks would come and put the fires out.

424
00:26:14,091 --> 00:26:18,836
When pedestrians died, ambulances would come, revive the pedestrians.

425
00:26:18,836 --> 00:26:24,763
And when pedestrians saw something violent happening, they would pull out their cell phone and call the cops.

426
00:26:24,763 --> 00:26:29,728
And then moments later, the cops would arrive and kind of walk around and see what was going on.

427
00:26:31,653 --> 00:26:34,234
But we also had a system called Notoriety,

428
00:26:34,234 --> 00:26:38,357
and this was to kind of punish the player

429
00:26:38,357 --> 00:26:39,938
for being violent in the open world

430
00:26:39,938 --> 00:26:43,119
and to give that sense of a real place.

431
00:26:43,119 --> 00:26:48,102
And this would spawn police cars, SWAT cars,

432
00:26:48,102 --> 00:26:50,644
boats, Apaches, and tanks.

433
00:26:50,644 --> 00:26:54,946
This tended to escalate quite quickly,

434
00:26:54,946 --> 00:26:56,567
depending on how violent the player was.

435
00:26:58,085 --> 00:27:00,046
But at the end of the project, it

436
00:27:00,046 --> 00:27:04,670
became pretty evident that we spent most of the time

437
00:27:04,670 --> 00:27:07,892
on this large scope of all the things that could come and be

438
00:27:07,892 --> 00:27:08,573
in the world.

439
00:27:08,573 --> 00:27:10,955
And we didn't really focus on the player experience.

440
00:27:10,955 --> 00:27:14,498
So Saints Row 3, we started looking at,

441
00:27:14,498 --> 00:27:16,719
how do we vary the gameplay?

442
00:27:18,503 --> 00:27:21,044
And we developed a number of specialist AI

443
00:27:21,044 --> 00:27:24,385
that would encourage the player to react differently

444
00:27:24,385 --> 00:27:27,846
in these situations, cause the player to dodge,

445
00:27:27,846 --> 00:27:29,586
to kite, to take cover, to flank.

446
00:27:29,586 --> 00:27:35,588
And this really helped break up the pacing of the gameplay,

447
00:27:35,588 --> 00:27:37,869
keep it a little bit more dynamic.

448
00:27:37,869 --> 00:27:41,330
So that's the first key takeaway,

449
00:27:41,330 --> 00:27:42,670
vary your player's response.

450
00:27:45,223 --> 00:27:50,296
And having AI and spawning systems respond to current events

451
00:27:50,296 --> 00:27:54,907
makes the world feel alive, but it's often better to provoke the player to play the game differently.

452
00:27:58,733 --> 00:28:08,659
The early concept of open world combat pacing through the Notoriety system was to spawn a vehicle every X seconds up until you hit a cap.

453
00:28:08,659 --> 00:28:13,362
And to escalate the fight, you would change the spawn rate and the cap.

454
00:28:13,362 --> 00:28:19,485
And this had a problem where we typically called this the trickle or the flood.

455
00:28:19,485 --> 00:28:23,387
Either there was not enough enemies to challenge the player or there was too many enemies.

456
00:28:23,948 --> 00:28:29,293
And this often is very vulnerable to balance changes,

457
00:28:29,293 --> 00:28:34,438
but it's also dependent on who's playing the game,

458
00:28:34,438 --> 00:28:36,460
whether or not they can handle the spawn rate.

459
00:28:39,162 --> 00:28:42,883
And we thought this was pretty dependable. But then in

460
00:28:42,883 --> 00:28:46,904
development SR3 we found there were really big unintended

461
00:28:46,904 --> 00:28:51,125
difficulty spikes. And it took some testing but we found out

462
00:28:51,125 --> 00:28:54,026
that this was actually coming from the ambient system.

463
00:28:54,026 --> 00:28:57,447
Notoriety would spawn six cops to attack the player and the

464
00:28:57,447 --> 00:29:01,108
ambient system would spawn four cops to go get donuts. And these

465
00:29:01,108 --> 00:29:03,869
four cops getting donuts would see the player and turn around

466
00:29:03,869 --> 00:29:07,810
and attack him. So now your easy encounter just doubled in size.

467
00:29:08,852 --> 00:29:18,742
And these kinds of accidental overlaps seem to be happening more and more frequently because we had more spawn systems in Saints Row 3.

468
00:29:18,742 --> 00:29:30,475
We had flashpoints, which were kind of like outposts or static locations in the world where many enemies would spawn and they would kind of loiter there and have some...

469
00:29:31,075 --> 00:29:36,717
activities that they were doing. And this conflicted with notoriety because if you

470
00:29:36,717 --> 00:29:43,460
walked into one of these and you already had 12 enemies and then notoriety, we

471
00:29:43,460 --> 00:29:50,303
changed notoriety so that it would measure how many of these people already

472
00:29:50,303 --> 00:29:54,385
existed and just backfill how many ever it wanted to spawn at the time.

473
00:29:56,125 --> 00:30:02,109
It wasn't until Sans Serif 4 where we finally rewrote the spawning to spawn in waves.

474
00:30:02,109 --> 00:30:05,731
This is kind of your typical survival mode.

475
00:30:05,731 --> 00:30:13,135
But as you can see here, it still doesn't handle the variety of enemies that we had.

476
00:30:13,135 --> 00:30:17,838
On screen here, you can actually pick out seven different enemy types.

477
00:30:17,838 --> 00:30:22,341
And I assure you, there was no designer or piece of data that intended this to happen.

478
00:30:23,955 --> 00:30:30,859
So, we've still got some work to do on it, but the takeaway is to try to have all of your systems work together

479
00:30:30,859 --> 00:30:38,803
to communicate or have a management layer to maintain the big picture of what is attacking the player.

480
00:30:43,695 --> 00:30:57,220
So we kind of had this escalation and we had added some variety and but then we had just kind of you climax and you just stay there forever.

481
00:30:57,220 --> 00:31:01,161
The only way to get rid of this notoriety was to just run away.

482
00:31:01,161 --> 00:31:07,943
You had to go back to your safe house or go to some designated location to make the notoriety stop attacking you.

483
00:31:09,680 --> 00:31:15,764
We really wanted to have the player beat Notoriety as a saint would.

484
00:31:15,764 --> 00:31:20,967
And to do this, we wanted to look at using a dramatic arc.

485
00:31:20,967 --> 00:31:26,590
So that way you can kind of climax and then fall off and have the victory condition

486
00:31:26,590 --> 00:31:30,812
of being really satisfied that you completed something.

487
00:31:32,779 --> 00:31:37,223
But the problem with this was we never really put a resolution on notoriety before

488
00:31:37,223 --> 00:31:42,588
because we didn't want to reward players for just slaughtering police left and right.

489
00:31:42,588 --> 00:31:44,710
Surprisingly, we have morals.

490
00:31:44,710 --> 00:31:50,955
And so in Saints Row IV we changed notoriety to be aliens,

491
00:31:50,955 --> 00:31:55,399
and now it was perfectly okay for us to reward players for killing them.

492
00:31:57,788 --> 00:32:04,732
This resulted in the Warden. This is the capstone AI for the Notoriety system.

493
00:32:04,732 --> 00:32:11,716
And you can see this kind of follows a dramatic arc of there's really intense combat,

494
00:32:11,716 --> 00:32:23,363
followed by some suspense, and then finally some gratification when you finally beat it.

495
00:32:23,363 --> 00:32:26,325
And now you know that Notoriety is done. You have completed it.

496
00:32:28,436 --> 00:32:34,361
Later in production, we found that players wanted to exit Notoriety earlier.

497
00:32:34,361 --> 00:32:36,242
So we came up with the Golden Sid.

498
00:32:36,242 --> 00:32:42,628
This is a high-speed chase where you chase a character through the city,

499
00:32:42,628 --> 00:32:46,571
and it follows the same dramatic arc of high-intensity gratification and relief.

500
00:32:46,571 --> 00:32:55,258
So the takeaway here is to try to make your open world experience rewarding.

501
00:32:56,570 --> 00:33:03,332
and also dramatic pacing and cool animation and effects are a pretty good way to do this.

502
00:33:03,332 --> 00:33:16,696
Saints Row has always been a really fast-paced game and Saints Row 4 introduced superpowers.

503
00:33:17,616 --> 00:33:22,560
So our typical response of spawning a car 100 meters away

504
00:33:22,560 --> 00:33:26,062
and having it drive to you was completely obsolete.

505
00:33:26,062 --> 00:33:30,806
So we needed to find new ways to bring the action to the player

506
00:33:30,806 --> 00:33:32,147
almost instantaneously.

507
00:33:32,147 --> 00:33:36,050
And then also, there was a problem of players

508
00:33:36,050 --> 00:33:38,912
could simply jump over a building

509
00:33:38,912 --> 00:33:41,574
and exit all AI combat.

510
00:33:41,574 --> 00:33:44,837
AI had no ability to follow them or chase them

511
00:33:44,837 --> 00:33:45,998
over top of buildings.

512
00:33:48,227 --> 00:33:52,271
So our first response to this was the teleportals.

513
00:33:52,271 --> 00:33:55,233
These were destructible monster closets

514
00:33:55,233 --> 00:33:58,837
that could spawn anywhere over open nav mesh.

515
00:33:58,837 --> 00:34:00,939
And we could pop these in right in front of the player

516
00:34:00,939 --> 00:34:03,221
and have them start dropping enemies.

517
00:34:03,221 --> 00:34:06,023
And thankfully, this was supported

518
00:34:06,023 --> 00:34:07,024
by the context of our game.

519
00:34:07,024 --> 00:34:13,169
Second method we used was transmogrification,

520
00:34:13,169 --> 00:34:14,891
which is a fun word we made up.

521
00:34:15,413 --> 00:34:19,379
it would transform an existing enemy into a more difficult enemy

522
00:34:19,379 --> 00:34:21,943
and do it in a very obvious, in-your-face way

523
00:34:21,943 --> 00:34:23,646
so the player knew something was going on.

524
00:34:25,808 --> 00:34:32,152
And then the third method we used was enemies just falling from the sky.

525
00:34:32,152 --> 00:34:36,455
We used some camera tricks to get this to happen right in front of the player

526
00:34:36,455 --> 00:34:40,637
and introduce him into combat immediately.

527
00:34:40,637 --> 00:34:45,600
This was also used for a specialist, and I think at one time we had it running on Roddy Piper.

528
00:34:47,371 --> 00:34:52,654
But actually the takeaway here is to be creative.

529
00:34:52,654 --> 00:34:57,097
Try to find ways to present AI to the player that

530
00:34:57,097 --> 00:34:58,838
is in the context of the game and also

531
00:34:58,838 --> 00:35:01,860
sports the mechanics and the pacing of the game.

532
00:35:01,860 --> 00:35:08,284
So the whole takeaway, I'm just going

533
00:35:08,284 --> 00:35:11,606
to wrap all this section up, is to bring

534
00:35:11,606 --> 00:35:13,588
all of your spawning systems together

535
00:35:13,588 --> 00:35:16,830
to provide a varied and rewarding experience.

536
00:35:18,309 --> 00:35:23,536
Next I'm going to go into some scalability challenges we've had in open world games,

537
00:35:23,536 --> 00:35:28,783
and later you'll see how these tie into the environmental interaction.

538
00:35:31,752 --> 00:35:36,033
So one of the systems I've been in charge of iterating on,

539
00:35:36,033 --> 00:35:40,114
on the Saint-Tropez franchise, is line-of-sight processing.

540
00:35:40,114 --> 00:35:48,036
And of course, your line-of-sight is proportional to the number of NPCs you have.

541
00:35:48,036 --> 00:35:48,536
We typically have 75 NPCs.

542
00:35:48,536 --> 00:35:50,657
So, off the top of your head, you might think,

543
00:35:50,657 --> 00:35:54,378
well, worst case is all 75 are attacking the player.

544
00:35:54,378 --> 00:35:59,939
Or 75 are attacking... 72 are attacking you and some friends.

545
00:36:01,452 --> 00:36:06,894
And then, well, we also allow scripting for some reason.

546
00:36:06,894 --> 00:36:10,575
So then there's a base invasion where

547
00:36:10,575 --> 00:36:12,215
you have a large number of allies

548
00:36:12,215 --> 00:36:14,536
and a large number of enemies.

549
00:36:14,536 --> 00:36:17,717
And you can see this is almost growing exponentially.

550
00:36:21,360 --> 00:36:24,503
So in this scenario, this worst case scenario,

551
00:36:24,503 --> 00:36:27,366
you're looking at around 1,500 line of sight checks.

552
00:36:27,366 --> 00:36:30,649
And we throttle them at four per frame.

553
00:36:30,649 --> 00:36:33,692
So this would take 12 seconds to resolve.

554
00:36:33,692 --> 00:36:36,615
And that's way, way too long.

555
00:36:37,500 --> 00:36:42,143
So here's kind of more of an average run of the mill case,

556
00:36:42,143 --> 00:36:42,664
4 versus 17.

557
00:36:42,664 --> 00:36:47,807
And we did a lot of work on iterating

558
00:36:47,807 --> 00:36:52,370
and to see how we can prioritize and filter

559
00:36:52,370 --> 00:36:56,713
which four line-of-sight checks you're going to do every frame.

560
00:36:56,713 --> 00:36:58,695
And this had an additional cost to it.

561
00:36:58,695 --> 00:37:01,897
But here you'll see the green lines

562
00:37:01,897 --> 00:37:04,519
are the completed line-of-sight checks,

563
00:37:04,519 --> 00:37:06,180
and the blue lines are the deferred ones.

564
00:37:07,636 --> 00:37:12,300
And also, if you look down in the corner,

565
00:37:12,300 --> 00:37:14,642
you'll see delays between 1 and 11 seconds.

566
00:37:14,642 --> 00:37:21,928
And then it gets worse.

567
00:37:21,928 --> 00:37:26,231
So with this extreme bias down in the green letters,

568
00:37:26,231 --> 00:37:28,493
or the green numbers, you'll see you can

569
00:37:28,493 --> 00:37:30,474
get reasonable response time.

570
00:37:30,474 --> 00:37:34,438
But this causes some starvation and some AI

571
00:37:34,438 --> 00:37:37,000
that simply just don't respond to anything off screen.

572
00:37:41,133 --> 00:37:41,994
And then this happened.

573
00:37:41,994 --> 00:37:42,034
Um...

574
00:37:42,034 --> 00:37:51,447
They scripted a mission where there were three teams all hostile to each other.

575
00:37:51,447 --> 00:37:53,930
And this just gets worse.

576
00:37:53,930 --> 00:37:57,935
And so now we're looking at even longer response times.

577
00:37:58,673 --> 00:38:01,516
So this happened basically right before we shipped Sensor 3.

578
00:38:01,516 --> 00:38:07,420
And more or less, it was OK because in this scenario,

579
00:38:07,420 --> 00:38:11,062
there was so many things blowing up and so many people

580
00:38:11,062 --> 00:38:12,383
shooting each other.

581
00:38:12,383 --> 00:38:15,326
As long as they weren't standing still doing nothing,

582
00:38:15,326 --> 00:38:16,667
it looked OK.

583
00:38:18,316 --> 00:38:21,257
But Saints Row 4 we started looking at, okay, how can we do

584
00:38:21,257 --> 00:38:25,840
more than four a frame? This is ridiculous. We tried optimizing

585
00:38:25,840 --> 00:38:29,242
and prioritizing things. That didn't work. So let's just try

586
00:38:29,242 --> 00:38:31,763
some brute force methods to see what else we can do. So I

587
00:38:31,763 --> 00:38:37,666
started looking at multi-threaded raycast. And we

588
00:38:37,666 --> 00:38:41,208
wrote our own code to do this. So it would work on up to four

589
00:38:41,208 --> 00:38:45,210
processors or on all the SPUs. And...

590
00:38:47,671 --> 00:38:51,954
And we wanted this to use it for immediate results.

591
00:38:51,954 --> 00:38:55,696
We wanted to just say, OK, do all of these right now.

592
00:38:55,696 --> 00:38:58,878
Do as many as we tell you to do on all the threads.

593
00:38:58,878 --> 00:39:00,279
And just let me know as soon as it's done.

594
00:39:00,279 --> 00:39:06,423
And this actually led to some interesting techniques

595
00:39:06,423 --> 00:39:10,326
I'll get into later, was the flying AI and the jumping AI.

596
00:39:12,451 --> 00:39:16,133
But to get back to the line-of-sight casting,

597
00:39:16,133 --> 00:39:21,716
we had the perception system and the line-of-sight deferred system.

598
00:39:21,716 --> 00:39:26,919
We'd build up a cue, and it would process the four in the main thread.

599
00:39:26,919 --> 00:39:29,120
Same for four, we did the same cue.

600
00:39:29,120 --> 00:39:34,243
However, we determined that while we were processing effects...

601
00:39:34,800 --> 00:39:37,501
there was nothing going on in the worker threads.

602
00:39:37,501 --> 00:39:40,223
So we said, okay, let's push all of them we can

603
00:39:40,223 --> 00:39:42,364
into the worker threads.

604
00:39:42,364 --> 00:39:43,765
But there's more than one thread,

605
00:39:43,765 --> 00:39:48,968
and there's more than one system that is not multithreaded.

606
00:39:48,968 --> 00:39:51,609
So now we're just using up all the idle space

607
00:39:51,609 --> 00:39:52,170
in the worker threads,

608
00:39:52,170 --> 00:39:57,012
and instead of doing four raycasts, we're now doing 80.

609
00:39:57,012 --> 00:39:58,673
So now all of a sudden,

610
00:39:58,673 --> 00:40:00,815
prioritizing doesn't really matter as much

611
00:40:00,815 --> 00:40:02,616
because we can do so many of these.

612
00:40:04,371 --> 00:40:06,133
And what used to take 15 seconds,

613
00:40:06,133 --> 00:40:09,015
now we can do less than one second.

614
00:40:09,015 --> 00:40:11,017
And if you do want to prioritize them,

615
00:40:11,017 --> 00:40:14,140
to just do the guys on screen right in front of you,

616
00:40:14,140 --> 00:40:16,662
you're getting response time of 0.1 seconds.

617
00:40:16,662 --> 00:40:17,883
And this was excellent.

618
00:40:20,047 --> 00:40:24,889
So, takeaway here is to try to multi-thread whatever you can.

619
00:40:24,889 --> 00:40:29,091
When you have this number of NPCs and AI running,

620
00:40:29,091 --> 00:40:33,174
you end up with, you know, N-squared hard problems,

621
00:40:33,174 --> 00:40:35,715
and throwing all the threads you can at it

622
00:40:35,715 --> 00:40:40,518
is sometimes the only way to solve it.

623
00:40:40,518 --> 00:40:43,259
Next I'm going to dig into some architecture changes we made.

624
00:40:48,402 --> 00:40:53,181
As you're probably familiar, finite state machines...

625
00:40:53,181 --> 00:40:53,823
Really fun to use!

626
00:40:54,404 --> 00:40:58,007
and over two projects they kind of get messy.

627
00:40:58,007 --> 00:41:02,389
This was our third game in the series,

628
00:41:02,389 --> 00:41:06,152
and it was, we just called it spaghetti code at that point.

629
00:41:06,152 --> 00:41:09,714
There was so much overhead and just adding,

630
00:41:09,714 --> 00:41:11,275
I just want to add one new action,

631
00:41:11,275 --> 00:41:13,557
and it would take me like a day and a half

632
00:41:13,557 --> 00:41:16,679
to just fill out the blank functions

633
00:41:16,679 --> 00:41:18,180
before I could start writing any code.

634
00:41:18,760 --> 00:41:26,671
and the number of dependencies between the new state and all the other states that already existed.

635
00:41:26,671 --> 00:41:28,153
It was just, it was ridiculous.

636
00:41:28,153 --> 00:41:32,880
And the worst part was the more you add to it, the worse it gets.

637
00:41:33,538 --> 00:41:37,780
So we were done with finite state machines, we needed to look for something else.

638
00:41:37,780 --> 00:41:40,880
I mean, the world has moved on.

639
00:41:40,880 --> 00:41:44,261
So we wanted something to reduce our overhead,

640
00:41:44,261 --> 00:41:45,962
so that we could really pump these things out.

641
00:41:45,962 --> 00:41:49,223
We could work on the real code that we wanted to work on.

642
00:41:49,223 --> 00:41:55,184
And we wanted something more modular, so that we could reuse things very easily.

643
00:41:55,184 --> 00:41:58,205
We were also concerned with performance.

644
00:41:58,205 --> 00:41:59,905
And again, we have 75 NPCs.

645
00:42:01,888 --> 00:42:05,170
And there's also Sans4 is a very fast-paced game.

646
00:42:05,170 --> 00:42:07,851
It's very volatile.

647
00:42:07,851 --> 00:42:11,072
So we had used planners before.

648
00:42:11,072 --> 00:42:12,852
We actually had one in-house.

649
00:42:12,852 --> 00:42:15,973
But we didn't really feel committed to using it

650
00:42:15,973 --> 00:42:19,875
because we didn't want to plan that far ahead.

651
00:42:19,875 --> 00:42:22,876
The game state and the world changes so frequently,

652
00:42:22,876 --> 00:42:24,236
we weren't sure if there was going

653
00:42:24,236 --> 00:42:25,377
to be a strong benefit in it.

654
00:42:25,917 --> 00:42:31,983
And we also wanted something very deterministic.

655
00:42:31,983 --> 00:42:37,108
We don't tend to roll dice because we consider the player the largest random variable.

656
00:42:37,108 --> 00:42:42,994
So, to kind of walk you through this a little bit.

657
00:42:44,292 --> 00:42:51,958
it closely resembles a behavior tree, but like I said, we were already pretty familiar

658
00:42:51,958 --> 00:42:59,884
with a planner. So we started with a list of goals, and you iterate over these list

659
00:42:59,884 --> 00:43:04,367
of goals until you find one that's valid at your current time. And then that list of goals

660
00:43:04,367 --> 00:43:08,830
has a list of actions to go through and try. And we'll go through those until it can find

661
00:43:08,830 --> 00:43:13,454
one. And there was essentially one behavior tree.

662
00:43:14,123 --> 00:43:15,143
for all the AI.

663
00:43:15,143 --> 00:43:20,225
And then this allowed us to work out all the dependencies

664
00:43:20,225 --> 00:43:21,025
we needed to.

665
00:43:21,025 --> 00:43:26,386
And these dependencies were fairly strong because it was,

666
00:43:26,386 --> 00:43:29,447
well, the dependencies were represented in the data.

667
00:43:29,447 --> 00:43:32,088
So it was very easy to iterate on these very quickly

668
00:43:32,088 --> 00:43:34,008
and determine where the problems were.

669
00:43:34,008 --> 00:43:37,249
But this was complicated enough that we kind of

670
00:43:37,249 --> 00:43:40,550
said, after a point, this is programmer only.

671
00:43:40,550 --> 00:43:42,971
Designers don't really want to dig in this deep.

672
00:43:43,622 --> 00:43:48,611
However, designers are, we're highly encouraged to

673
00:43:48,611 --> 00:43:51,917
filter the goals and actions that each AI could do

674
00:43:51,917 --> 00:43:54,963
and tweak the parameters on those goals and actions.

675
00:43:56,407 --> 00:43:58,948
And this became pretty powerful.

676
00:43:58,948 --> 00:44:03,890
The first time we realized the power of this was a producer

677
00:44:03,890 --> 00:44:06,631
came in and said, hey, can you guys

678
00:44:06,631 --> 00:44:11,894
make Burt Reynolds a follower?

679
00:44:11,894 --> 00:44:16,276
So since we, well, but he can't use guns,

680
00:44:16,276 --> 00:44:20,377
and he can't die for legal reasons.

681
00:44:22,324 --> 00:44:26,326
We'd already had invulnerability as a flag in a table,

682
00:44:26,326 --> 00:44:29,849
and we already had melee behaviors

683
00:44:29,849 --> 00:44:32,150
and the movement and stuff that we needed.

684
00:44:32,150 --> 00:44:34,792
So this took about five minutes.

685
00:44:34,792 --> 00:44:37,473
It was just copying around some data in a table.

686
00:44:37,473 --> 00:44:42,877
And Burt Reynolds was done.

687
00:44:42,877 --> 00:44:43,397
Also...

688
00:44:44,982 --> 00:44:48,083
Another explanation of this, if you find yourself writing

689
00:44:48,083 --> 00:44:52,624
is Burt Reynolds in code, you're not doing data driven correctly.

690
00:44:52,624 --> 00:44:57,706
Burt Reynolds is the sum of the parts,

691
00:44:57,706 --> 00:45:04,108
parts that should be reused for other AI down the road.

692
00:45:04,108 --> 00:45:04,508
To

693
00:45:04,508 --> 00:45:07,409
really hit this home, I'll go through the Warden. This is one of the

694
00:45:07,409 --> 00:45:10,310
most unique AI we had in the game and

695
00:45:10,310 --> 00:45:14,071
definitely the one that we iterated on the longest.

696
00:45:14,817 --> 00:45:28,726
However, if you actually break down what his behaviors are, he had 26 behaviors, and 13 of them were completely copied from the Saints Row 3 cop.

697
00:45:28,726 --> 00:45:37,652
Basic movement, getting line of sight, shooting, a lot of these things were exactly the same, had not changed.

698
00:45:39,413 --> 00:45:43,714
And then a lot of the behaviors that we made for the Warden,

699
00:45:43,714 --> 00:45:46,495
we also reused on many, many other AI in the main game

700
00:45:46,495 --> 00:45:47,035
and DLC.

701
00:45:47,035 --> 00:45:50,436
So you can see there's a lot of reuse here.

702
00:45:50,436 --> 00:45:52,417
There's only three behaviors here

703
00:45:52,417 --> 00:45:55,557
that remain completely unique to the Warden.

704
00:45:55,557 --> 00:46:01,259
So takeaway here is make your job easy,

705
00:46:01,259 --> 00:46:02,979
because you're going to be doing it a lot.

706
00:46:02,979 --> 00:46:07,620
And reduce your overhead will pay huge dividends

707
00:46:07,620 --> 00:46:08,160
in the long run.

708
00:46:10,237 --> 00:46:13,980
being data-driven is one really good way to do this.

709
00:46:13,980 --> 00:46:16,823
And focusing on your efficiency upfront

710
00:46:16,823 --> 00:46:20,485
will allow you to be more flexible and creative

711
00:46:20,485 --> 00:46:23,267
down the road.

712
00:46:23,267 --> 00:46:25,789
Next, I'm going to get into environment interaction, which

713
00:46:25,789 --> 00:46:29,913
is talking about how to connect the player and the AI

714
00:46:29,913 --> 00:46:34,456
to his surroundings in a more meaningful way.

715
00:46:34,456 --> 00:46:37,939
And this can be difficult to do in a large city or world.

716
00:46:42,844 --> 00:46:47,068
One of the basic ways we did this was action nodes.

717
00:46:47,068 --> 00:46:53,053
Action nodes are a custom set of animations, props, dialogue.

718
00:46:53,053 --> 00:46:57,818
And these were placed, I think we had nearly 500 of these

719
00:46:57,818 --> 00:47:02,863
placed around the open world and more inside of interiors.

720
00:47:04,478 --> 00:47:11,141
But these were actually really important to experience because it would not only make the world feel alive,

721
00:47:11,141 --> 00:47:15,843
but also kind of ground the player when they're done doing something absolutely ridiculous.

722
00:47:15,843 --> 00:47:20,464
It kind of brings them back down to something normal that they can relate to.

723
00:47:20,464 --> 00:47:24,446
But what I really want to talk about is...

724
00:47:25,167 --> 00:47:28,368
500 action nodes hand placed in the world.

725
00:47:28,368 --> 00:47:31,029
That's a lot of data.

726
00:47:31,029 --> 00:47:35,531
And that takes man weeks to do, even on a good pipeline.

727
00:47:35,531 --> 00:47:38,352
So we're actually focusing a lot of effort

728
00:47:38,352 --> 00:47:40,252
now on how to improve that pipeline

729
00:47:40,252 --> 00:47:43,434
and make that more efficient so we can do more

730
00:47:43,434 --> 00:47:44,854
of these at higher quality.

731
00:47:47,273 --> 00:47:52,157
Next, I'm actually going to hit on reusing markup.

732
00:47:52,157 --> 00:47:58,462
We had some procedural systems, like the roadblock system.

733
00:47:58,462 --> 00:48:03,466
And what this would do is it would find existing road

734
00:48:03,466 --> 00:48:04,166
data in the world.

735
00:48:04,166 --> 00:48:11,492
And we made sets of two, three, and four lane roadblocks.

736
00:48:11,492 --> 00:48:14,855
And it would match these to the existing roads

737
00:48:14,855 --> 00:48:15,596
around the player.

738
00:48:16,196 --> 00:48:22,681
And this was awesome because it was perfectly scalable to the entire world.

739
00:48:22,681 --> 00:48:28,885
We didn't have to add any markup data to the world to get this to work.

740
00:48:28,885 --> 00:48:31,507
So, again, just reuse your markup.

741
00:48:31,507 --> 00:48:34,970
However, there's a caveat to this.

742
00:48:35,835 --> 00:48:42,280
Working without markup or reusing markup as it was not intended to be used can be very tricky.

743
00:48:42,280 --> 00:48:52,487
Here we have an example of a brute who is going over to pick up a propane tank to throw it at the enemy or whatever.

744
00:48:52,487 --> 00:48:56,530
However, the collision data on this is about twice as large as the actual propane tank.

745
00:48:56,530 --> 00:49:00,153
So this doesn't line up. It looks pretty bad.

746
00:49:00,153 --> 00:49:05,196
This was taken from a bug report saying, yeah, this collision data is terrible.

747
00:49:05,701 --> 00:49:12,024
But that's really the point, is that when someone made this collision data,

748
00:49:12,024 --> 00:49:15,346
they weren't thinking about how routes were going to pick up things.

749
00:49:15,346 --> 00:49:19,368
So you have to make some assumptions about your data,

750
00:49:19,368 --> 00:49:24,030
but then you also have to go back and correct it where it is wrong.

751
00:49:24,030 --> 00:49:27,272
We were able to iterate this and fix most of the bugs,

752
00:49:27,272 --> 00:49:29,833
and it was fairly reliable when it shipped.

753
00:49:31,803 --> 00:49:35,066
However, sometimes it's not as easy as marking a propane tank.

754
00:49:35,066 --> 00:49:38,248
When we switched over to Saints Row 4,

755
00:49:38,248 --> 00:49:42,332
it was originally an expansion pack.

756
00:49:42,332 --> 00:49:48,577
And we rethemed the city to be more alien-like.

757
00:49:48,577 --> 00:49:52,640
And the biggest problem for me was

758
00:49:52,640 --> 00:49:56,723
that now players could run up walls and jump on rooftops

759
00:49:56,723 --> 00:49:59,325
where there was no nav mesh, no markup,

760
00:49:59,325 --> 00:50:01,407
because gameplay had not existed there before.

761
00:50:03,137 --> 00:50:09,509
So, how do you have combat without NavMesh?

762
00:50:09,509 --> 00:50:12,535
This was kind of an interesting problem.

763
00:50:14,570 --> 00:50:22,496
So, we invented some jumping code, and this was completely not reliant on NavMesh at all.

764
00:50:22,496 --> 00:50:29,641
This was using, leveraging the Raycast multi-threaded stuff I was talking about earlier,

765
00:50:29,641 --> 00:50:37,067
where you're just gonna do Raycast down from the sky, or down from your height map of where the helicopters fly.

766
00:50:38,395 --> 00:50:44,499
And first thing you can do is find where they hit the ground.

767
00:50:44,499 --> 00:50:47,620
And then run a heuristic to sort which ones are most appealing

768
00:50:47,620 --> 00:50:48,041
to the AI.

769
00:50:48,041 --> 00:50:52,023
And then test jump arcs to multiple of these

770
00:50:52,023 --> 00:50:54,604
at the same time, since we can multi-thread these.

771
00:50:54,604 --> 00:50:57,606
There's a little bit lower cost to batching them up.

772
00:50:57,606 --> 00:51:00,227
And then you can evaluate and choose whichever one

773
00:51:00,227 --> 00:51:02,709
you feel is most appropriate.

774
00:51:04,967 --> 00:51:12,391
Here it is in game. As you can see, the AI is actually jumping down to the ground in this scenario.

775
00:51:12,391 --> 00:51:18,333
And it's running heuristics on all the phases of this to isolate the best end position.

776
00:51:20,135 --> 00:51:24,336
But when we implemented this, the behavior was only intended to be used on the warden.

777
00:51:24,336 --> 00:51:27,696
So we knew there was only one AI running this in the world.

778
00:51:27,696 --> 00:51:32,978
Because we were a little afraid it might be expensive.

779
00:51:32,978 --> 00:51:36,298
But the designers loved it, and they wanted to use it more.

780
00:51:36,298 --> 00:51:40,379
So we determined, well, followers kind of need it to be able to chase the player around.

781
00:51:40,379 --> 00:51:43,780
And, well, specialists need it to chase the player around.

782
00:51:43,780 --> 00:51:48,241
And then it just kind of caught fire in missions and activities,

783
00:51:48,241 --> 00:51:50,022
and everyone just started using it.

784
00:51:50,462 --> 00:51:58,003
And the profiling guy never hunted me down, so I guess it worked out.

785
00:51:58,003 --> 00:52:10,766
And then we also wanted to do flying, because who doesn't want to do flying?

786
00:52:10,766 --> 00:52:15,467
But we didn't have markup data. We didn't have voxels or anything like that.

787
00:52:17,970 --> 00:52:21,595
So we started with just a simple avoidance algorithm.

788
00:52:21,595 --> 00:52:24,999
And well, of course you can say, well, what about the U shape?

789
00:52:24,999 --> 00:52:27,502
How do you get out of U shape without pathfinding?

790
00:52:27,502 --> 00:52:33,429
So we actually just tried, well, let's do a raycast away

791
00:52:33,429 --> 00:52:35,031
from the player every frame.

792
00:52:35,031 --> 00:52:37,134
And we'll cache these up over time.

793
00:52:37,754 --> 00:52:42,917
And then what the AI can actually do is query this cache of raycasts and say,

794
00:52:42,917 --> 00:52:45,499
well, which one of these is further away than me?

795
00:52:45,499 --> 00:52:51,162
And so then they knew, okay, if I move to this position, I will now have line of sight to the player.

796
00:52:51,162 --> 00:52:54,765
And this didn't always work. It worked good enough.

797
00:52:54,765 --> 00:53:01,349
And typically when it didn't work, the AI was stuck in a corner where they couldn't see you

798
00:53:01,349 --> 00:53:05,511
and you couldn't see them, so it wasn't really noticeable.

799
00:53:05,511 --> 00:53:06,792
So, just some little tricks.

800
00:53:08,501 --> 00:53:16,069
Here it is in game. These AI on flying bikes are chasing the player through a tunnel.

801
00:53:16,069 --> 00:53:23,516
And this was really responsive and this is something that our helicopter AI could never do

802
00:53:23,516 --> 00:53:30,463
because they were not that maneuverable and also because there's no height nav mesh in a tunnel.

803
00:53:30,743 --> 00:53:38,872
This was really useful for interiors and very complex overpasses and industrial areas where there's lots of catwalks.

804
00:53:38,872 --> 00:53:42,936
And these guys would just follow you down a rabbit hole if you went down one.

805
00:53:45,091 --> 00:53:51,718
This is really tricky though. I consider this high risk, high reward development

806
00:53:51,718 --> 00:53:57,844
because there's a lot of bugs with it, but when it works, it works everywhere

807
00:53:57,844 --> 00:54:01,848
across the entire city where you don't have to have markup data

808
00:54:01,848 --> 00:54:06,413
that takes up a lot of memory and takes up a lot of time to do it manually.

809
00:54:08,447 --> 00:54:29,412
So, to wrap it up here, I think we should all consider in our open world games how to provide the player with a varied experience, a rewarding experience, with some pacing, how to make the AI and developer

810
00:54:30,637 --> 00:54:34,140
better, faster, stronger, more efficient at their job.

811
00:54:34,140 --> 00:54:37,903
And how to live with or without markup data.

812
00:54:37,903 --> 00:54:41,026
It's a very important question.

813
00:54:41,026 --> 00:54:44,209
And Naya, do we have time for questions?

814
00:54:44,209 --> 00:54:46,631
Five minutes for questions.

815
00:54:46,631 --> 00:54:47,572
All right.

816
00:54:47,572 --> 00:54:48,673
Thank you very much.

817
00:54:56,147 --> 00:54:57,628
OK, great talk.

818
00:54:57,628 --> 00:54:59,888
Question for Jeet.

819
00:54:59,888 --> 00:55:03,629
First, I request, please make a full talk about player

820
00:55:03,629 --> 00:55:06,090
modeling, player modeling.

821
00:55:06,090 --> 00:55:08,531
And the two questions are maybe linked.

822
00:55:08,531 --> 00:55:13,472
Can you talk a little bit about annotation, what annotation,

823
00:55:13,472 --> 00:55:14,112
and what you did?

824
00:55:14,112 --> 00:55:17,994
And do you use the external state machines for anything

825
00:55:17,994 --> 00:55:20,534
else than animation?

826
00:55:20,534 --> 00:55:25,376
OK, so the first question in terms of player modeling,

827
00:55:26,050 --> 00:55:32,005
Basically, that's just a design exercise for you to be able to understand what...

828
00:55:32,735 --> 00:55:36,696
what actual AI components you can actually add

829
00:55:36,696 --> 00:55:39,597
to create variety in the game.

830
00:55:39,597 --> 00:55:42,778
And with regards to external state machines,

831
00:55:42,778 --> 00:55:45,739
it's about really overriding or connecting up.

832
00:55:45,739 --> 00:55:48,179
So the memory itself of the actual state machine

833
00:55:48,179 --> 00:55:49,960
needs to exist as well.

834
00:55:49,960 --> 00:55:52,521
So if you have them specified externally and split

835
00:55:52,521 --> 00:55:56,121
across the world, you can only load in what you need.

836
00:55:56,121 --> 00:55:58,082
So it's more the states themselves and also

837
00:55:58,082 --> 00:55:58,782
the animations.

838
00:55:59,952 --> 00:56:04,595
OK, but can you perceive that an affordance exists in the world

839
00:56:04,595 --> 00:56:07,378
when there is a state machine attached to it?

840
00:56:07,378 --> 00:56:09,179
But because the actual game object

841
00:56:09,179 --> 00:56:12,442
is separated from the state machine, you can.

842
00:56:12,442 --> 00:56:14,844
You can still search for those game objects.

843
00:56:14,844 --> 00:56:18,206
And you can think of things like you only load in,

844
00:56:18,206 --> 00:56:20,388
you only connect up the state machine when you actually

845
00:56:20,388 --> 00:56:22,690
enter trigger volume, for example.

846
00:56:22,690 --> 00:56:25,072
That's when you actually, on the fly, hook it up.

847
00:56:25,072 --> 00:56:25,352
Thanks.

848
00:56:35,271 --> 00:56:39,667
Let's thank him again. That was a lot of information. A lot of really good stuff. Appreciate it.

