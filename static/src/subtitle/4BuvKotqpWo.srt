1
00:00:04,976 --> 00:00:06,437
All right, thanks for coming out.

2
00:00:08,879 --> 00:00:13,243
They wanted me to remind you guys to turn off cell phones and to fill out your evaluation

3
00:00:13,283 --> 00:00:14,344
forms when this is all over.

4
00:00:15,726 --> 00:00:18,268
So my name is Chad Barb.

5
00:00:18,528 --> 00:00:22,632
I'm here to talk about some texture work I did for Titanfall 2.

6
00:00:24,213 --> 00:00:28,157
And hopefully there's some fresh techniques here that might be useful for people and then

7
00:00:28,217 --> 00:00:31,560
also it's a bit of a case study in adding streaming to a AAA game.

8
00:00:37,622 --> 00:00:44,844
So what is texture streaming? I mean, broadly speaking, texture streaming is dynamically loading and unloading texture data as necessary to render.

9
00:00:45,665 --> 00:00:51,247
What you're trying to do is get the most use out of a fixed amount of memory on your GPU or shared memory.

10
00:00:52,407 --> 00:01:06,292
And so it kind of is a form of compression and like most compression, if you notice that it's happening, it's not really working. So a lot of games have texture streaming in some capacity, but they don't, you don't see it, so you don't even realize it. It's pretty pervasive.

11
00:01:07,490 --> 00:01:08,992
Some of the broad common approaches.

12
00:01:09,132 --> 00:01:11,553
There's a manual segmentation approach,

13
00:01:11,634 --> 00:01:12,694
which is sort of the default thing

14
00:01:12,714 --> 00:01:14,596
where you divide your world into various areas.

15
00:01:15,436 --> 00:01:17,578
And as the player wanders around,

16
00:01:17,618 --> 00:01:19,119
you maybe drop or load those areas

17
00:01:19,159 --> 00:01:21,381
or sets of assets associated with those areas.

18
00:01:22,241 --> 00:01:24,203
That's kind of like the Jak and Daxter approach,

19
00:01:24,263 --> 00:01:26,605
but lots of games do similar things.

20
00:01:28,066 --> 00:01:29,447
There's bounding geometry tests.

21
00:01:29,867 --> 00:01:31,849
That's where you have some sort of approximation

22
00:01:31,909 --> 00:01:36,252
of your geometry, visibility of your highest MIP levels.

23
00:01:37,008 --> 00:01:39,269
and you can rapidly evaluate that on the CPU.

24
00:01:39,289 --> 00:01:41,770
I mean, the simplest example of that would be a model radius

25
00:01:41,870 --> 00:01:44,191
where once you get within a certain distance from a model,

26
00:01:44,611 --> 00:01:45,772
you load higher MIP levels.

27
00:01:46,532 --> 00:01:47,953
But you can do more complicated things,

28
00:01:48,073 --> 00:01:50,814
A, B, B trees, arbitrary sorts of geometry

29
00:01:51,474 --> 00:01:54,496
that you can test rapidly.

30
00:01:54,936 --> 00:01:57,617
And then finally, and more and increasingly popular,

31
00:01:57,857 --> 00:01:59,998
is GPU feedback approaches,

32
00:02:00,038 --> 00:02:02,799
where you have some sort of either a separate pass

33
00:02:02,899 --> 00:02:05,200
or some sort of additional part of your texture or your...

34
00:02:05,860 --> 00:02:07,941
that takes notes on what

35
00:02:08,781 --> 00:02:12,143
MIP levels are being actually used and what needs to be loaded

36
00:02:12,364 --> 00:02:13,784
and what's important and what isn't.

37
00:02:14,825 --> 00:02:17,547
And I mean the extreme version of that is like, it's megatextures.

38
00:02:19,448 --> 00:02:20,428
Of course they're also doing

39
00:02:21,069 --> 00:02:23,690
there's kind of two parts to it. There's the part

40
00:02:23,710 --> 00:02:26,752
where you figure out what to load and then the part where you actually load it in.

41
00:02:28,033 --> 00:02:29,554
So there's a lot more to megatextures than just

42
00:02:29,854 --> 00:02:32,595
deciding what's visible. But that's all I'm talking about

43
00:02:32,615 --> 00:02:33,636
with these three points.

44
00:02:35,783 --> 00:02:40,004
Time for 2. Time for 2 is a fast-paced first-person shooter. That means that the

45
00:02:40,024 --> 00:02:42,064
camera is located inside the players head

46
00:02:42,664 --> 00:02:45,985
and the player can move quickly, they can turn quickly, they can hide behind cover,

47
00:02:46,425 --> 00:02:49,185
come out of cover. There's vertical gameplay, they can eject

48
00:02:49,865 --> 00:02:52,306
vertically, rapidly, they can fall rapidly,

49
00:02:53,086 --> 00:02:55,366
obviously. There's...

50
00:02:56,167 --> 00:02:59,827
the game itself is semi-linear. It's not really an open-world game, though the

51
00:02:59,867 --> 00:03:01,388
multiplayer is a little more open than

52
00:03:01,408 --> 00:03:02,468
the single-player.

53
00:03:03,116 --> 00:03:06,678
So that means, because the multiplayer is relatively open

54
00:03:06,698 --> 00:03:07,699
and you can get around quickly,

55
00:03:08,039 --> 00:03:10,601
you know, a fixed, scripted approach

56
00:03:11,061 --> 00:03:12,262
wouldn't necessarily work there.

57
00:03:13,142 --> 00:03:17,245
And also in multiplayer, we had a requirement

58
00:03:17,365 --> 00:03:19,487
of wanting a lot of customized skins and weapons.

59
00:03:20,027 --> 00:03:21,828
So you could be wandering around

60
00:03:21,908 --> 00:03:23,930
and see someone else carrying a gun.

61
00:03:24,530 --> 00:03:26,551
You could see 20 people carrying 20 different guns.

62
00:03:26,731 --> 00:03:28,172
And if any of those people drop that gun

63
00:03:28,192 --> 00:03:30,274
and you go pick it up, you want that to be clear

64
00:03:30,594 --> 00:03:32,395
when it comes up on your first-person view.

65
00:03:34,960 --> 00:03:37,641
And we run at 60 hertz, so we don't,

66
00:03:38,882 --> 00:03:42,484
we have a busy GPU, we don't wanna add work to that,

67
00:03:42,684 --> 00:03:45,546
and we also have a rather busy render thread

68
00:03:45,586 --> 00:03:46,646
that we don't wanna add work to.

69
00:03:47,167 --> 00:03:49,088
So we wanna do this as efficiently as possible.

70
00:03:49,688 --> 00:03:52,130
And all this is running on top of a very mutated

71
00:03:52,170 --> 00:03:53,730
by this point fork of valve source

72
00:03:54,151 --> 00:03:54,911
that we forked around 2010.

73
00:03:57,973 --> 00:03:59,013
So what platforms are we on?

74
00:03:59,423 --> 00:04:00,604
Well, we're on modern consoles.

75
00:04:01,325 --> 00:04:03,466
Most important aspect of those for streaming

76
00:04:03,546 --> 00:04:04,967
is that they have hard drives.

77
00:04:05,507 --> 00:04:07,749
So you get a lot better seek and bandwidth than optical media.

78
00:04:08,509 --> 00:04:11,291
Also, they have modern APIs for dealing with loading

79
00:04:11,311 --> 00:04:12,192
and unloading textures.

80
00:04:12,752 --> 00:04:17,215
And you can do more direct memory access.

81
00:04:18,096 --> 00:04:20,057
You don't necessarily have to go through an API all the time.

82
00:04:21,218 --> 00:04:24,019
On Windows, we're a little bit more in the past.

83
00:04:24,079 --> 00:04:25,821
We target DirectX 11 because we wanted

84
00:04:25,841 --> 00:04:28,122
to have as inclusive a min spec as possible.

85
00:04:30,159 --> 00:04:31,620
So we're missing out on some of the new goodness.

86
00:04:32,400 --> 00:04:35,802
And of course, PC players have a variety of GPUs.

87
00:04:36,603 --> 00:04:38,244
They have a variety of display resolutions.

88
00:04:38,844 --> 00:04:40,965
And they, of course, have a variety of GPU RAM amounts

89
00:04:41,846 --> 00:04:42,286
to work with.

90
00:04:42,346 --> 00:04:43,867
So whatever we do needs to be able to handle

91
00:04:44,527 --> 00:04:45,708
these kind of dynamic

92
00:04:49,610 --> 00:04:50,931
hardware specs.

93
00:04:52,252 --> 00:04:56,153
So another requirement was we didn't want to add a bunch of work for designers and artists.

94
00:04:56,614 --> 00:04:59,775
We wanted artists to be able to map their textures freely on models.

95
00:04:59,915 --> 00:05:03,497
So we didn't want to have a rule set. Don't you know don't do that.

96
00:05:03,637 --> 00:05:07,399
Don't have a don't have a fixed density or.

97
00:05:10,540 --> 00:05:12,081
We also didn't want to let them.

98
00:05:15,402 --> 00:05:16,223
We didn't feel like.

99
00:05:19,435 --> 00:05:21,996
All right, so we wanted them to be able to add

100
00:05:22,036 --> 00:05:24,297
as many MIP levels as they want to a texture

101
00:05:24,837 --> 00:05:26,258
without hurting other textures.

102
00:05:27,899 --> 00:05:30,980
So that we can ship with the highest MIP levels available

103
00:05:31,000 --> 00:05:33,381
so people on PC that have the best rig

104
00:05:33,461 --> 00:05:35,802
can see the best textures and it's not hurting people

105
00:05:36,222 --> 00:05:38,903
that are on lower end computers.

106
00:05:40,604 --> 00:05:42,465
If we did pre-processing, we wanted it to be stable.

107
00:05:43,650 --> 00:05:47,673
We didn't want the case where if you recompile a map,

108
00:05:47,813 --> 00:05:50,235
it would break everything and make everything blurry

109
00:05:50,255 --> 00:05:51,116
and look bad for a while.

110
00:05:51,196 --> 00:05:53,758
So they should be able to do pre-processing weekly

111
00:05:54,138 --> 00:05:56,821
or with some latency on a separate machine.

112
00:05:57,601 --> 00:05:59,303
And we were okay with some manual hinting,

113
00:06:00,343 --> 00:06:03,066
and if necessary, though that turned out

114
00:06:03,086 --> 00:06:04,827
it wasn't really necessary.

115
00:06:05,888 --> 00:06:08,850
And it all needed to work with our asset pipeline,

116
00:06:08,870 --> 00:06:10,432
which includes the ability to do hot swap.

117
00:06:13,114 --> 00:06:13,214
So.

118
00:06:13,859 --> 00:06:17,781
Our strategy, our overview of our strategy is any MIP level below 64 kilobytes is permanent.

119
00:06:18,501 --> 00:06:20,202
MIPs can be added or dropped one by one.

120
00:06:20,702 --> 00:06:25,164
So that's in furtherance of the goal that artists can create arbitrary numbers of MIP levels

121
00:06:25,204 --> 00:06:26,905
so that we just won't use them if they're not needed.

122
00:06:29,406 --> 00:06:32,767
We use pre-computed information to build a list of what's important and unimportant

123
00:06:33,928 --> 00:06:35,288
and we work toward that list each frame.

124
00:06:36,609 --> 00:06:39,970
So the goal of pre-computed information being save GPU, save CPU.

125
00:06:42,557 --> 00:06:45,298
So, core to this algorithm is the idea of a histogram.

126
00:06:45,779 --> 00:06:50,441
So a histogram, in this context, is a coverage metric

127
00:06:50,521 --> 00:06:51,981
per MIP level of a material.

128
00:06:52,582 --> 00:06:57,324
So, we wanted to be able to prioritize MIP levels

129
00:06:57,384 --> 00:07:00,125
by how many pixels on the screen they actually cover,

130
00:07:00,685 --> 00:07:02,046
and not just are they visible or not.

131
00:07:02,743 --> 00:07:09,465
So an example of a problem this solves is you have like a doorway and you have brick behind the doorway and stone around the doorway,

132
00:07:09,685 --> 00:07:13,226
you'd much rather load the high MIP levels for the stone around the door than the brick.

133
00:07:13,326 --> 00:07:17,507
So coverage gives you an idea of how many pixels the player is going to see.

134
00:07:21,888 --> 00:07:26,610
In our case, we pre-compute the coverage per MIP per material.

135
00:07:27,950 --> 00:07:34,012
And the part that complicates that is that the player can have different final screen resolutions

136
00:07:34,592 --> 00:07:37,913
and a material can have a variety of textures that each have their own resolution.

137
00:07:37,973 --> 00:07:43,715
So we assume a nominal 4K texture resolution and a nominal 256 by 256 screen resolution.

138
00:07:44,216 --> 00:07:49,437
And our histogram then is just a value of coverage per the 16 MIP levels at that resolution.

139
00:07:50,118 --> 00:07:55,480
And so most of the operations then just become shifting and scaling those histograms to accommodate.

140
00:07:56,305 --> 00:07:58,307
changing circumstances, which I'll talk about in a minute.

141
00:08:01,611 --> 00:08:02,532
Another problem this solves

142
00:08:03,913 --> 00:08:06,896
related to not being able to text your models wrong

143
00:08:07,457 --> 00:08:09,699
is, for example, if the artist

144
00:08:10,099 --> 00:08:13,763
used fewer texels on an unimportant part of a model

145
00:08:14,084 --> 00:08:15,445
like the bottom of a character's shoe,

146
00:08:16,706 --> 00:08:19,209
we don't want an automated algorithm to decide

147
00:08:19,653 --> 00:08:21,374
hey, we need the finest MIP level available

148
00:08:21,414 --> 00:08:25,176
because this portion is using the highest MIP level

149
00:08:25,216 --> 00:08:26,676
even though really it's just unimportant.

150
00:08:26,716 --> 00:08:29,538
So having coverage gives you the ability

151
00:08:29,578 --> 00:08:30,558
to make smarter decisions.

152
00:08:32,459 --> 00:08:35,100
So the pre-computation for static geometry,

153
00:08:35,400 --> 00:08:37,081
we divide the world into a number of columns

154
00:08:38,062 --> 00:08:40,963
and we use a GPU to render that into a file

155
00:08:41,523 --> 00:08:43,424
and that information is then streamed dynamically

156
00:08:43,724 --> 00:08:45,345
to drive the texture streaming.

157
00:08:46,285 --> 00:08:48,345
For dynamic models, at load time,

158
00:08:48,385 --> 00:08:50,126
we compute texture gradients for each triangle,

159
00:08:50,146 --> 00:08:51,386
so we know what MIP level they use.

160
00:08:52,006 --> 00:08:54,767
We add the area of each triangle to the histogram bin.

161
00:08:56,007 --> 00:09:00,068
So, rather than projecting the triangle,

162
00:09:00,088 --> 00:09:00,868
we just use the area.

163
00:09:00,908 --> 00:09:03,668
We had originally thought about maybe projecting it

164
00:09:03,688 --> 00:09:05,289
based on various rotations of the model,

165
00:09:05,709 --> 00:09:07,969
but it didn't turn out to be much of a benefit.

166
00:09:08,009 --> 00:09:09,870
It actually introduced bugs where a model

167
00:09:09,890 --> 00:09:12,530
would turn around rapidly and something

168
00:09:12,550 --> 00:09:13,210
wouldn't be streamed in.

169
00:09:13,531 --> 00:09:15,211
So we just go with area metric.

170
00:09:18,034 --> 00:09:21,577
And then from there, you can take the GPU data

171
00:09:21,617 --> 00:09:24,540
and combine it with the dynamic data to get your final values,

172
00:09:24,640 --> 00:09:26,742
and we use a manually tweaked scale factor

173
00:09:27,082 --> 00:09:29,624
to bring that area metric into the same domain

174
00:09:29,844 --> 00:09:35,409
as the offline GPU number of pixels visible metric.

175
00:09:36,750 --> 00:09:38,852
So each frame, then, we make sure we've streamed in

176
00:09:38,872 --> 00:09:40,233
the player's column from the disk.

177
00:09:40,875 --> 00:09:42,196
We add the model coverage to it.

178
00:09:42,636 --> 00:09:45,197
We take that coverage and we divide it by the texel count

179
00:09:45,237 --> 00:09:47,638
for the particular MIP level that it's associated with

180
00:09:47,678 --> 00:09:51,819
to get a metric of cost versus benefit.

181
00:09:52,580 --> 00:09:53,920
And from there we can generate a list

182
00:09:53,960 --> 00:09:56,361
of the most important MIP levels that we don't have loaded

183
00:09:56,641 --> 00:09:58,562
and the least important MIP levels that we do have loaded.

184
00:09:59,202 --> 00:10:01,683
And we try to drop less important MIP levels

185
00:10:01,923 --> 00:10:03,264
in order to load important ones.

186
00:10:03,744 --> 00:10:05,165
And this is capped at a sum rate

187
00:10:05,725 --> 00:10:08,866
so that we don't burden the GPU too much.

188
00:10:12,772 --> 00:10:16,676
Oh yeah, an important, so the metric we use, we divide by the texel count, and that has

189
00:10:16,696 --> 00:10:22,762
a really good property where if you have like a, let's say a painting on a wall, and the

190
00:10:22,822 --> 00:10:27,046
artist were to divide that painting into four sections and make each one of those its own

191
00:10:27,086 --> 00:10:31,230
texture, the metric would remain the same, because the texture is smaller and the coverage

192
00:10:31,290 --> 00:10:31,691
is smaller.

193
00:10:32,071 --> 00:10:35,455
So that's, that was an early thing that we discovered.

194
00:10:37,514 --> 00:10:40,676
they could they could we could unwittingly try to make something look

195
00:10:40,696 --> 00:10:44,579
better by putting it in a smaller by making a smaller texture so we kind of

196
00:10:44,939 --> 00:10:48,661
for that by having a a proper cost-benefit metric without property

197
00:10:51,023 --> 00:10:53,904
so as far as choosing probes you run the tool

198
00:10:54,245 --> 00:10:57,327
it instantiates all the static models to computes the bounds of the level

199
00:10:57,807 --> 00:11:01,509
it chops the geometry in a 16-foot square columns the probes are placed at

200
00:11:01,629 --> 00:11:01,930
every

201
00:11:02,150 --> 00:11:05,552
about every upward facing triangle so this is everywhere the player could be

202
00:11:05,612 --> 00:11:06,052
standing

203
00:11:07,309 --> 00:11:09,909
We add in any hint probes that the level designers have placed,

204
00:11:10,049 --> 00:11:12,330
and then we use k-means to combine that

205
00:11:12,710 --> 00:11:14,831
into at most eight probes per column.

206
00:11:16,131 --> 00:11:18,452
Often there's fewer than eight already,

207
00:11:19,152 --> 00:11:20,612
and we also log those locations.

208
00:11:21,632 --> 00:11:23,133
So that goes...

209
00:11:23,373 --> 00:11:25,614
So we upload the static geometry to the GPU once,

210
00:11:26,054 --> 00:11:27,874
and then for each of those probes, we render a cubemap.

211
00:11:28,294 --> 00:11:30,235
We don't have a frame buffer we're rendering into.

212
00:11:30,255 --> 00:11:31,175
We do have a depth buffer,

213
00:11:31,555 --> 00:11:34,596
but we render directly to the histogram

214
00:11:35,056 --> 00:11:36,237
using an unordered access view.

215
00:11:36,974 --> 00:11:39,756
So once per cube face we yeah we render.

216
00:11:39,776 --> 00:11:42,318
I won't go through the code,

217
00:11:42,838 --> 00:11:47,561
but. The unordered access view is basically an array per

218
00:11:47,601 --> 00:11:50,043
material permit level and it just gets built and it's fairly

219
00:11:50,083 --> 00:11:51,904
compact so that doesn't take a lot of bandwidth to pull

220
00:11:51,924 --> 00:11:53,065
those back down from the GPU.

221
00:11:55,286 --> 00:11:57,528
From there we can take all of the probes in that particular

222
00:11:57,568 --> 00:12:02,411
column and we can max them to generate final data for the

223
00:12:02,431 --> 00:12:04,172
column. Take the 512 most important records.

224
00:12:06,223 --> 00:12:08,625
and then put that in a file, bundle those up

225
00:12:08,705 --> 00:12:12,288
so that they can be, you can page in a four by four group

226
00:12:13,189 --> 00:12:17,133
at once, and that's all indexed to stable IDs

227
00:12:17,273 --> 00:12:19,535
and that goes into a file that sits alongside

228
00:12:19,615 --> 00:12:20,796
our level files.

229
00:12:23,458 --> 00:12:24,959
As far as texture assets are managed,

230
00:12:25,360 --> 00:12:27,342
we have a pipeline that generates a single file

231
00:12:27,462 --> 00:12:30,945
per texture asset, so then that's compressed

232
00:12:30,985 --> 00:12:32,626
and swizzled if necessary.

233
00:12:34,495 --> 00:12:39,184
As part of our level RPAC process, which is how we load,

234
00:12:39,244 --> 00:12:41,147
we bundle everything into a big file

235
00:12:41,167 --> 00:12:44,113
that we can just blast into the RAM from disk.

236
00:12:44,627 --> 00:12:48,309
we peel off the streamable portion of those textures

237
00:12:48,649 --> 00:12:51,430
and we put them into a separate star pack file.

238
00:12:51,990 --> 00:12:54,611
And for shipping, there's a single star pack file

239
00:12:54,651 --> 00:12:55,332
for the entire game.

240
00:12:55,812 --> 00:12:58,653
And one side benefit of this, as far as fitting on disc goes,

241
00:12:59,113 --> 00:13:01,654
is that you only have to duplicate the low,

242
00:13:02,114 --> 00:13:04,855
the permanently resident MIP levels across your levels.

243
00:13:04,956 --> 00:13:06,776
So if a texture's used in two levels,

244
00:13:07,296 --> 00:13:10,338
only the MIPs below 64 kilobytes will be shared across those.

245
00:13:12,724 --> 00:13:15,546
will be will be starting out shared a duplicated across this.

246
00:13:16,966 --> 00:13:20,928
So this is the crediting code on broadly speaking this is just

247
00:13:20,988 --> 00:13:23,550
shifting and scaling the histogram to accommodate

248
00:13:25,331 --> 00:13:28,292
varying FOV and varying screen resolution

249
00:13:29,253 --> 00:13:31,614
and varying texture resolutions for the material.

250
00:13:32,755 --> 00:13:35,836
For models it's the same thing except we also have to deal with

251
00:13:36,857 --> 00:13:40,599
a model getting closer and further away from you so.

252
00:13:41,239 --> 00:13:44,401
To handle that, obviously the coverage of a model goes down as it goes further away,

253
00:13:44,561 --> 00:13:46,683
and then it's going to be using coarser MIP levels too.

254
00:13:51,007 --> 00:13:55,150
Finally, we can divide that accumulated coverage by our texel count

255
00:13:56,451 --> 00:14:01,556
to get the metric, which we sort by, and then that drives our loading and unloading,

256
00:14:01,796 --> 00:14:04,478
which has some subtleties, especially handling

257
00:14:07,012 --> 00:14:14,936
dynamic changing buffer sizes. So if it's trying to target an amount of memory and we reduce the amount of memory available, it needs to be able to handle that change.

258
00:14:15,697 --> 00:14:17,458
Or if we increase the amount, obviously.

259
00:14:18,318 --> 00:14:24,101
So in terms of the actual texture resizing, our original approach was we would have a CPU-writable texture.

260
00:14:25,023 --> 00:14:27,665
So we did do kind of the by the book thing of create a CPU

261
00:14:27,725 --> 00:14:30,767
writable texture, map it, asynchronously load into it,

262
00:14:30,907 --> 00:14:34,090
unmap it, copy it to the new GPU texture, copy the old GPU

263
00:14:34,110 --> 00:14:36,752
texture to the new GPU texture, and then get rid of those, the

264
00:14:36,812 --> 00:14:38,533
old GPU texture and the CPU texture.

265
00:14:39,133 --> 00:14:42,756
However, this extra creation of a CPU writable texture

266
00:14:43,156 --> 00:14:46,699
turned out to cost sort of an unpredictable

267
00:14:46,759 --> 00:14:47,820
amount of driver time.

268
00:14:48,520 --> 00:14:52,743
So we changed to just calling createTexture and passing it.

269
00:14:53,471 --> 00:14:56,652
ordinary heap memory. So we load into heap and we pass it into create texture.

270
00:14:59,372 --> 00:15:01,773
Technically that means we're doing an extra copy but

271
00:15:01,933 --> 00:15:05,793
it performs better. And then on the console life's a lot easier.

272
00:15:06,093 --> 00:15:11,934
We can just read things straight into where they'll be used. Our synchronous IO is

273
00:15:11,975 --> 00:15:12,555
its own thread.

274
00:15:13,195 --> 00:15:16,835
It has two requests in flight and textures are the lowest priority item

275
00:15:16,935 --> 00:15:21,936
and we carve up those texture reads into 64k chunks so that we can interrupt

276
00:15:22,196 --> 00:15:22,597
the reads.

277
00:15:23,114 --> 00:15:24,255
to load sound if we need to.

278
00:15:24,856 --> 00:15:26,998
Since the sound is a lot more important

279
00:15:27,558 --> 00:15:28,879
to get low latency on.

280
00:15:30,741 --> 00:15:33,583
So this is a really useful debugging tool.

281
00:15:34,624 --> 00:15:37,767
This is the At-A-Glance Debug Shader.

282
00:15:39,949 --> 00:15:42,811
On the right, I have reduced the amount of texture RAM

283
00:15:44,353 --> 00:15:46,715
available, and on the left we have plenty of RAM available.

284
00:15:47,516 --> 00:15:50,618
And on the left, you're seeing mostly green and aqua.

285
00:15:51,751 --> 00:15:53,753
So there's green here and there's aqua around here.

286
00:15:54,894 --> 00:15:56,635
Green means that for that particular pixel,

287
00:15:56,655 --> 00:15:58,857
we are using the highest MIP level that's currently loaded.

288
00:15:59,177 --> 00:15:59,898
So that's good.

289
00:16:00,698 --> 00:16:02,480
Aqua means that in some sense,

290
00:16:02,500 --> 00:16:03,701
we're kind of wasting space

291
00:16:03,741 --> 00:16:06,243
because we're using a MIP level below what's loaded.

292
00:16:06,483 --> 00:16:08,805
But of course that could be used elsewhere on the screen.

293
00:16:09,826 --> 00:16:11,447
And red, as you can see on this gun,

294
00:16:11,588 --> 00:16:12,949
means that that texture MIP level

295
00:16:12,969 --> 00:16:14,590
that it would like to use just doesn't exist.

296
00:16:15,591 --> 00:16:18,353
On the right, you notice, if you're not colorblind,

297
00:16:18,974 --> 00:16:19,794
that it's yellow.

298
00:16:21,356 --> 00:16:28,061
So that means that we have a lot of pixels that aren't getting

299
00:16:28,101 --> 00:16:29,462
as high a resolution as they'd like.

300
00:16:32,004 --> 00:16:33,946
This is a really great tool for just running around a level

301
00:16:33,986 --> 00:16:36,688
and quickly checking to make sure that everything's

302
00:16:36,708 --> 00:16:37,328
streaming in well.

303
00:16:40,511 --> 00:16:42,893
And then for debugging the offline process,

304
00:16:43,613 --> 00:16:44,474
we can wander around.

305
00:16:44,514 --> 00:16:48,057
We can see the nodes, the probes from which

306
00:16:48,697 --> 00:16:50,859
the pre-computed data was rendered.

307
00:16:51,795 --> 00:16:53,998
We can also get the XYZ coordinates,

308
00:16:54,198 --> 00:16:55,980
and we can feed those XYZ coordinates

309
00:16:56,460 --> 00:16:59,944
into a special mode of the offline tool

310
00:17:00,144 --> 00:17:01,686
that will actually generate a directory

311
00:17:02,026 --> 00:17:04,148
full of PNG files, one per material,

312
00:17:04,529 --> 00:17:08,773
showing which, where that particular material

313
00:17:08,833 --> 00:17:09,414
is visible from.

314
00:17:09,634 --> 00:17:12,256
And in yellow, it's visible, and in red, it's occluded.

315
00:17:15,215 --> 00:17:16,856
So that's really useful for trying to find out

316
00:17:16,936 --> 00:17:18,697
why a particular material isn't loading,

317
00:17:18,737 --> 00:17:20,459
like you're standing somewhere and a material's not loading.

318
00:17:20,799 --> 00:17:22,780
You can look at its cubemap and you can see,

319
00:17:22,800 --> 00:17:24,682
oh, okay, it's occluded, or you can see

320
00:17:24,702 --> 00:17:25,943
that the probe is in a bad place.

321
00:17:27,624 --> 00:17:30,146
Then there's just a bunch of different debugging modes

322
00:17:30,166 --> 00:17:30,666
we can set.

323
00:17:30,726 --> 00:17:33,328
We can tell it to load all the textures, data.

324
00:17:33,368 --> 00:17:34,369
We can tell it to load none of it.

325
00:17:35,670 --> 00:17:36,910
We can change the memory limit,

326
00:17:36,931 --> 00:17:38,652
and that's exposed to PC players.

327
00:17:39,112 --> 00:17:40,573
We can add noise on loaded data,

328
00:17:40,633 --> 00:17:42,414
which doesn't actually turn out to be that useful

329
00:17:42,455 --> 00:17:44,356
because almost everything is gonna be noisy then.

330
00:17:45,869 --> 00:17:49,190
The at-a-glance shader is a lot more useful than that.

331
00:17:50,451 --> 00:17:53,092
And also very useful is we have a window

332
00:17:53,152 --> 00:17:57,153
that runs alongside the game showing you a report.

333
00:17:58,653 --> 00:18:04,235
And here you can see at the top, we have links.

334
00:18:04,255 --> 00:18:06,076
You can click to change the modes,

335
00:18:06,416 --> 00:18:08,737
the various operations modes,

336
00:18:09,217 --> 00:18:11,677
and the amount of texture memory you're actually using.

337
00:18:12,358 --> 00:18:13,958
You can see the number of MIPS loaded.

338
00:18:14,018 --> 00:18:14,478
You can see.

339
00:18:17,186 --> 00:18:20,027
Below it, what columns are loaded?

340
00:18:20,047 --> 00:18:21,648
We have a four element LRU cache

341
00:18:21,688 --> 00:18:23,909
for those bundled together four by four columns.

342
00:18:24,729 --> 00:18:26,990
And then below that, you can see sorted list

343
00:18:27,030 --> 00:18:28,430
of what it thinks is important,

344
00:18:28,470 --> 00:18:31,151
the records of the coverage for each MIP level

345
00:18:31,172 --> 00:18:32,972
for each material, and you can explore that list.

346
00:18:33,472 --> 00:18:35,113
And you can also see a mode where you see

347
00:18:35,173 --> 00:18:36,894
what is currently loaded in total.

348
00:18:37,674 --> 00:18:39,215
So this is the objective,

349
00:18:39,235 --> 00:18:41,556
and then you can also see the current actual.

350
00:18:42,316 --> 00:18:45,437
And also very useful is an IO overview showing you.

351
00:18:45,968 --> 00:18:58,573
The amount of read you've been doing in the last second, 10 seconds, 100 seconds, and the average bandwidth you're using, as well as the mean standard deviation and maximum latency you're encountering between making a request and getting it serviced.

352
00:18:59,573 --> 00:19:04,335
So how long did it take? Our game was in development for two years. This took about 10 months.

353
00:19:06,275 --> 00:19:11,317
There was related work, too, like especially handling PC auto-detection, min-spec and.

354
00:19:11,878 --> 00:19:14,780
talking to driver people and trying to figure out performance issues of that.

355
00:19:16,041 --> 00:19:19,223
There was also the asset pipeline work including being able to patch these

356
00:19:19,983 --> 00:19:23,225
and then there was work on console to figure out how much memory we have

357
00:19:23,886 --> 00:19:28,108
because texture streaming is the thing that gets the rest of the RAM

358
00:19:28,229 --> 00:19:31,251
so anything that affects memory is going to affect the texture streaming budget

359
00:19:31,291 --> 00:19:34,493
pretty much. So how much RAM do we need?

360
00:19:35,013 --> 00:19:38,335
Well empirically it seemed to work pretty well with about 600 megabytes.

361
00:19:39,144 --> 00:19:41,825
And once you get up to a gigabyte, it's pretty hard to find fault at all.

362
00:19:42,806 --> 00:19:46,769
On PC we ship with a variety of settings based on a card database,

363
00:19:47,209 --> 00:19:51,472
which we later shifted to use an actual API to tell us the RAM available.

364
00:19:54,234 --> 00:19:57,036
And then on the console it's just fixed at 928 megabytes.

365
00:19:59,537 --> 00:20:01,939
And that's in addition to about 400 megabytes of permanent MIPS.

366
00:20:02,678 --> 00:20:08,079
which are the below 64k levels, as well as effects, UI,

367
00:20:08,680 --> 00:20:10,980
and some distant environment maps

368
00:20:11,000 --> 00:20:12,101
that didn't make sense to stream.

369
00:20:13,021 --> 00:20:15,422
And then there's about half a meg of performance overhead.

370
00:20:15,442 --> 00:20:17,562
Oh, sorry, housekeeping overhead,

371
00:20:17,842 --> 00:20:20,823
like those pages from the SDBSP and tables

372
00:20:20,863 --> 00:20:21,483
and that kind of stuff.

373
00:20:23,544 --> 00:20:24,784
As far as what ends up on the disk,

374
00:20:24,884 --> 00:20:27,045
our entire streamable set is 21 gigabytes.

375
00:20:27,525 --> 00:20:28,925
For the effect and cause level,

376
00:20:28,986 --> 00:20:30,346
which is the one we travel through time,

377
00:20:31,193 --> 00:20:33,714
you can use up to 12 gigabytes of that.

378
00:20:34,194 --> 00:20:35,354
That's 14,000 MIPS.

379
00:20:35,875 --> 00:20:38,455
And the file that contains the static pre-computed data

380
00:20:38,495 --> 00:20:40,436
with the columns is 37 megabytes.

381
00:20:40,956 --> 00:20:43,556
For MPEden, which is just sort of an average multiplayer

382
00:20:44,076 --> 00:20:46,177
level for us, it's about the same,

383
00:20:46,277 --> 00:20:48,457
but the column file is bigger

384
00:20:48,697 --> 00:20:49,858
because the playing area is bigger.

385
00:20:52,998 --> 00:20:54,679
That doesn't really matter though for the runtime

386
00:20:54,699 --> 00:20:57,599
because it only keeps several K of that

387
00:20:57,739 --> 00:20:58,520
at resident at any time.

388
00:21:00,398 --> 00:21:03,800
So if you think about the 12 gigabytes that we can load

389
00:21:03,980 --> 00:21:06,182
combined with the four gigabytes that are loaded

390
00:21:06,202 --> 00:21:09,004
from the R-Pack, and then you think about the gigabyte

391
00:21:09,544 --> 00:21:11,765
buffer with the four gigabytes that are permanently resident,

392
00:21:11,906 --> 00:21:13,527
you get about a nine to one compression ratio.

393
00:21:13,587 --> 00:21:15,008
So back in the napkin, you have about

394
00:21:15,788 --> 00:21:17,269
one and a half more MIP levels, which is nice.

395
00:21:20,711 --> 00:21:24,234
This is our cruncher, four AMD Radeon R9 Fury Nanos.

396
00:21:25,114 --> 00:21:27,596
And then a CPU that really doesn't matter because

397
00:21:29,092 --> 00:21:30,953
this process barely uses the CPU.

398
00:21:32,153 --> 00:21:34,994
But, lest you think you can run it on your workstation

399
00:21:35,014 --> 00:21:36,215
while you're trying to do something else,

400
00:21:36,875 --> 00:21:38,475
it bogs down the Windows UI

401
00:21:38,495 --> 00:21:40,396
because Windows uses GPU for compositing,

402
00:21:40,476 --> 00:21:42,056
so it makes your computer unusable.

403
00:21:42,757 --> 00:21:43,757
So, we have a cruncher.

404
00:21:44,237 --> 00:21:48,419
And that guy just pulls things from Perforce,

405
00:21:49,339 --> 00:21:52,560
uses Jenkins to render, sorry, well Jenkins drives it,

406
00:21:52,820 --> 00:21:54,120
but it pulls things down from Perforce,

407
00:21:54,560 --> 00:21:56,781
runs our XE on it, and then commits the results.

408
00:21:59,072 --> 00:22:02,054
pretty widely varying amount of time it takes for single player levels from 15

409
00:22:02,395 --> 00:22:04,136
minutes to 2 hours, though an hour is average.

410
00:22:04,816 --> 00:22:06,557
For multiplayer it's closer to 20 minutes

411
00:22:08,058 --> 00:22:11,801
and it's an embarrassingly parallel problem so if you divide, you can

412
00:22:13,602 --> 00:22:16,604
since you only upload the geometry once to these cards and that's fast

413
00:22:17,145 --> 00:22:20,307
you can then just divide the probes up across the cards and there really

414
00:22:20,347 --> 00:22:22,628
isn't a huge bandwidth constraint pulling those

415
00:22:23,509 --> 00:22:23,629
uh...

416
00:22:24,530 --> 00:22:26,131
histograms back down so it

417
00:22:26,511 --> 00:22:27,572
it's about 4x with 4 GPUs.

418
00:22:30,145 --> 00:22:31,786
As far as the actual game run time.

419
00:22:32,767 --> 00:22:33,968
It's about a millisecond,

420
00:22:33,988 --> 00:22:35,509
a little less than a millisecond

421
00:22:35,549 --> 00:22:37,470
in a kind of a typical busy scene.

422
00:22:38,591 --> 00:22:40,352
About half of that's doing the BSP crediting.

423
00:22:40,612 --> 00:22:41,873
There's some time crediting models

424
00:22:41,913 --> 00:22:42,954
and the other half is sorting

425
00:22:42,994 --> 00:22:45,195
and compiling the final list.

426
00:22:45,655 --> 00:22:47,196
There's some optimization opportunities.

427
00:22:47,216 --> 00:22:49,938
We'd like to maybe push things onto some job threads.

428
00:22:50,539 --> 00:22:52,760
We'd like to maybe amortize across multiple frames

429
00:22:52,800 --> 00:22:53,741
because you really don't need

430
00:22:53,761 --> 00:22:56,783
to have an up-to-date list every frame

431
00:22:56,923 --> 00:22:58,984
because your hard drive can't possibly keep up with that.

432
00:23:02,245 --> 00:23:04,126
So how did this affect artists?

433
00:23:05,387 --> 00:23:08,048
Like I said, they disabled it for certain textures,

434
00:23:08,088 --> 00:23:10,910
for effects, and for distance level geometry,

435
00:23:11,050 --> 00:23:12,351
where it just didn't make sense to stream.

436
00:23:13,572 --> 00:23:15,173
They liked that there were 4K textures

437
00:23:15,213 --> 00:23:16,254
available on all platforms.

438
00:23:16,354 --> 00:23:20,736
So PC people with their amazing displays and GPUs

439
00:23:20,776 --> 00:23:21,897
can enjoy their art.

440
00:23:24,599 --> 00:23:25,980
There wasn't a wrong way to make models.

441
00:23:26,140 --> 00:23:26,960
There wasn't busy work.

442
00:23:28,101 --> 00:23:29,702
One thing that became increasingly obvious

443
00:23:29,802 --> 00:23:30,062
as the

444
00:23:31,547 --> 00:23:35,829
effort went on was that they really weren't happy when the guns or the

445
00:23:35,909 --> 00:23:40,631
Titan cockpits weren't completely loaded in. So we call those view models and we

446
00:23:40,691 --> 00:23:44,993
had to handle view models specially. We put a special bump for them that they

447
00:23:45,053 --> 00:23:49,255
almost always will completely load in if they're visible. So that breaks the

448
00:23:49,355 --> 00:23:52,457
artist can't affect the budget requirement. So now anytime they add a

449
00:23:52,497 --> 00:23:58,399
MIP level to a gun or a Titan it's going to definitely take memory and

450
00:23:58,419 --> 00:24:00,620
definitely reduce the amount of memory available to other.

451
00:24:01,317 --> 00:24:03,899
Textures, but that's OK. We just have to be careful there.

452
00:24:04,780 --> 00:24:07,482
And we try to encourage artists not to use all mode all the time.

453
00:24:07,782 --> 00:24:11,646
Like, they like to use all mode because it loads everything in and it looks as good as it can.

454
00:24:12,086 --> 00:24:14,588
But we want them to see what the player's going to see.

455
00:24:15,850 --> 00:24:19,573
As far as designers, we didn't really use very many hints, ultimately.

456
00:24:19,593 --> 00:24:20,634
The...

457
00:24:22,429 --> 00:24:25,671
It saved designer time because usually they have to do kind of a pass late in

458
00:24:25,691 --> 00:24:28,193
the project where they look for textures that aren't used that often and get rid

459
00:24:28,213 --> 00:24:31,435
of them, but now it just doesn't matter because those not used very often

460
00:24:31,455 --> 00:24:35,799
textures will only take 64k or a bit more than 64k of memory.

461
00:24:37,300 --> 00:24:40,663
And we did achieve the goal of having lots of customized skins and guns for multiplayer.

462
00:24:42,944 --> 00:24:46,227
We want to add the ability to hint that they're going to load in a model.

463
00:24:46,587 --> 00:24:47,088
So we don't have a...

464
00:24:49,757 --> 00:24:53,459
a pre-cache kind of facility so we had to do some hacks where maybe they had a model

465
00:24:53,479 --> 00:24:57,121
behind a wall so that when they spawned another one in in front of the player it would already

466
00:24:57,161 --> 00:24:57,542
be loaded.

467
00:24:57,562 --> 00:25:00,363
That wasn't great but that'll get better next game.

468
00:25:03,525 --> 00:25:04,726
The cruncher stopped a lot.

469
00:25:05,346 --> 00:25:09,368
So we need to improve our, we're working on improving our build process a bit and for

470
00:25:09,488 --> 00:25:13,270
these kinds of automatic processes so that people

471
00:25:13,829 --> 00:25:17,871
are aware when they break because we would get bugs and the real cause of the bug was just that

472
00:25:18,391 --> 00:25:25,055
it hadn't run in a week so something like a model or a geometry that had been added recently would

473
00:25:25,095 --> 00:25:30,338
be blurry and it's just because they hadn't run the tool so it had no way of knowing that thing

474
00:25:30,378 --> 00:25:37,602
was even there. And on console also we had to use extra memory for development.

475
00:25:39,071 --> 00:25:43,262
So console bugs were kind of invalid because the buffer was so much smaller than it was

476
00:25:43,302 --> 00:25:45,267
going to be, it was going to end up being.

477
00:25:46,688 --> 00:25:50,329
So on PC then we used the same size we were using on console.

478
00:25:50,410 --> 00:25:52,630
So the PC was the kind of definitive,

479
00:25:53,170 --> 00:25:54,971
how's it going to look experience.

480
00:25:55,431 --> 00:25:56,891
And the amount of memory we had available

481
00:25:56,931 --> 00:26:00,972
was about a normal GPU, so it worked out pretty well.

482
00:26:01,393 --> 00:26:03,393
And of course, PC players with really good cards

483
00:26:03,413 --> 00:26:05,474
will see even better textures.

484
00:26:07,034 --> 00:26:10,455
So effect and cause, that's where you go through time.

485
00:26:10,775 --> 00:26:11,996
You're really going through Z.

486
00:26:12,776 --> 00:26:15,357
So we pop you up and down, and that just worked.

487
00:26:16,920 --> 00:26:20,022
because we have columns and we max between the probes.

488
00:26:20,082 --> 00:26:23,064
So you'd get a probe down here and a probe in the other time

489
00:26:23,584 --> 00:26:27,386
and it would just pull in the data that would be needed.

490
00:26:27,726 --> 00:26:30,128
Even, you know, it would take a little additional load

491
00:26:30,188 --> 00:26:32,389
on the cache because you're loading two sets of textures,

492
00:26:32,469 --> 00:26:33,950
but that can't really be avoided.

493
00:26:34,550 --> 00:26:37,272
Ship to ship, that's massive moving geometry.

494
00:26:37,352 --> 00:26:40,273
So in that level, you have these four ships

495
00:26:40,353 --> 00:26:42,395
that are laid out, or more than four,

496
00:26:42,415 --> 00:26:44,696
but giant ships laid out in the level.

497
00:26:45,616 --> 00:26:45,737
And.

498
00:26:46,642 --> 00:26:49,204
we then sort of translate them at the last minute in the renderer.

499
00:26:50,004 --> 00:26:54,307
So that worked pretty well, but we had to add a hook where the scripters could tell us

500
00:26:54,327 --> 00:26:58,249
which ship you're on, so we could reverse transform the player's camera position

501
00:26:58,289 --> 00:27:01,351
back to where that ship was back when we did the precomputation.

502
00:27:01,751 --> 00:27:03,292
So a bit of a hack, but that worked out.

503
00:27:07,094 --> 00:27:12,857
On PC, some surprises. We ended up shipping with the lowest buffer size of zero, which...

504
00:27:13,676 --> 00:27:16,457
Doesn't look great, but we wanted to be as inclusive as possible.

505
00:27:17,877 --> 00:27:21,198
We also ended up with some hitching due to kind of unpredictable drivers.

506
00:27:21,338 --> 00:27:22,398
So we've been improving that.

507
00:27:23,138 --> 00:27:25,138
We moved texture creation to its own thread.

508
00:27:26,439 --> 00:27:29,479
And we also have a limit where we won't create more than two textures a frame.

509
00:27:34,580 --> 00:27:37,681
On console, at some point we decided maybe we were going to try to

510
00:27:38,041 --> 00:27:40,341
make it so that you could play the game while you...

511
00:27:41,402 --> 00:27:45,524
We're installing it, but that was just way too much bandwidth to expect out of the optical drive.

512
00:27:45,924 --> 00:27:48,145
So we ended up abandoning that.

513
00:27:49,626 --> 00:27:52,908
And of course the buffers needing the space for development like I mentioned.

514
00:27:54,228 --> 00:27:57,970
And we also borrow memory for loading. We borrow memory from movie playback too.

515
00:27:58,191 --> 00:28:01,932
Which is not... so behind the scenes it's dynamically changing the buffer.

516
00:28:02,633 --> 00:28:03,133
And that's fine.

517
00:28:03,693 --> 00:28:06,915
So where does this break down when you start to talk about having less...

518
00:28:07,987 --> 00:28:08,567
Buffer memory?

519
00:28:08,768 --> 00:28:10,628
Well, the biggest one is signage.

520
00:28:11,168 --> 00:28:14,870
So in this case, we have a high contrast, sharp texture,

521
00:28:15,230 --> 00:28:17,971
and it kind of looks bad once you reduce the texture budget.

522
00:28:18,271 --> 00:28:20,932
All this other stuff is reduced too, but it does OK.

523
00:28:21,552 --> 00:28:22,473
How are we going to address that?

524
00:28:23,433 --> 00:28:25,054
We've talked about using distance fields.

525
00:28:25,094 --> 00:28:28,855
That's what we use for our normal UI,

526
00:28:29,275 --> 00:28:30,556
for like text and menus.

527
00:28:31,235 --> 00:28:35,437
And we also talked about maybe generating some kind of an error metric when we do the

528
00:28:35,477 --> 00:28:39,518
mipmap generation to somehow detect when a texture is the kind of thing that degenerates

529
00:28:39,558 --> 00:28:45,700
badly and multiply its metric by some constant.

530
00:28:47,640 --> 00:28:50,761
The other issue we run into is when they make something out of pieces.

531
00:28:51,621 --> 00:28:54,882
Here you can see this little part here, and it comes from this texture.

532
00:28:55,570 --> 00:29:00,952
But because this coverage is relatively small and because we're dividing by this entire

533
00:29:01,692 --> 00:29:04,493
count of texels for this entire texture, that doesn't load in.

534
00:29:05,614 --> 00:29:09,635
Eventually, in this case, we just created a texture map for the entire sign, so this

535
00:29:09,675 --> 00:29:14,537
was kind of a temporary problem, but it's sort of worth exploring that as well.

536
00:29:15,837 --> 00:29:17,058
Some code bugs we encountered.

537
00:29:17,338 --> 00:29:21,379
There was a lot of ways to draw models in our engine, so a couple times things wouldn't

538
00:29:21,419 --> 00:29:24,260
be streaming in and it turned out there was some path we hadn't quite explored.

539
00:29:24,825 --> 00:29:28,006
to get a model into the render list without also doing the accounting.

540
00:29:29,307 --> 00:29:32,007
And then having to deal with hot swap, because

541
00:29:32,027 --> 00:29:36,769
for our hot swap system you have multiple copies of the same texture

542
00:29:37,169 --> 00:29:40,230
resident. Only one's live, but they're all resident. So the

543
00:29:40,610 --> 00:29:43,531
streaming management code had to

544
00:29:44,211 --> 00:29:47,332
kinda keep a pointer to the currently live one and that was additional

545
00:29:47,912 --> 00:29:50,392
work and opportunity to kinda get into a messed up state.

546
00:29:51,253 --> 00:29:51,613
And NANCE.

547
00:29:54,090 --> 00:29:54,590
Love Nance.

548
00:29:56,371 --> 00:29:56,951
So what's next?

549
00:29:57,352 --> 00:29:59,193
Moving to more modern APIs on PC,

550
00:30:00,313 --> 00:30:02,215
augmenting some of this with some GPU feedback.

551
00:30:03,555 --> 00:30:08,198
If we can add cheap instructions to our shader

552
00:30:08,238 --> 00:30:10,239
to kind of take some notes on what's visible

553
00:30:10,479 --> 00:30:12,120
and sort of mix that in, that would be nice.

554
00:30:13,461 --> 00:30:15,502
And then looking into texture compression

555
00:30:15,542 --> 00:30:19,084
beyond kind of GPU DXC compression

556
00:30:19,705 --> 00:30:21,266
and seeing if that's worth the CPU cost.

557
00:30:23,195 --> 00:30:24,976
working better with moving geometry,

558
00:30:25,957 --> 00:30:28,118
streaming more of our textures and streaming geometry

559
00:30:28,158 --> 00:30:29,599
as well, like the actual vertices,

560
00:30:30,200 --> 00:30:31,901
and then finally, yeah, addressing signage,

561
00:30:32,081 --> 00:30:32,782
making it look better.

562
00:30:34,203 --> 00:30:34,903
All right, thank you.

