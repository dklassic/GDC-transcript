1
00:00:06,640 --> 00:00:07,521
Thank you for coming.

2
00:00:07,721 --> 00:00:09,822
Today, I'd like to talk about the system

3
00:00:09,862 --> 00:00:12,663
we developed to support game balancing using AI.

4
00:00:12,683 --> 00:00:18,505
I'm Kazuko.

5
00:00:19,025 --> 00:00:20,786
I'm working at Square Enix Japan.

6
00:00:21,466 --> 00:00:25,348
I worked as a programmer on the development of some console

7
00:00:25,368 --> 00:00:26,148
games before.

8
00:00:27,009 --> 00:00:30,110
Currently, I'm an AI engineer, and my work

9
00:00:30,210 --> 00:00:32,871
is about quality assurance, especially

10
00:00:32,951 --> 00:00:34,852
in the area of game balance using AI.

11
00:00:36,893 --> 00:00:39,033
I'll cover all of this presentation today.

12
00:00:39,713 --> 00:00:41,754
But before it, please let me introduce

13
00:00:41,774 --> 00:00:44,534
a member of our team, Shigeru Awaji.

14
00:00:48,235 --> 00:00:50,755
He is in charge of data visualization and data

15
00:00:50,835 --> 00:00:52,236
analysis in this project.

16
00:00:53,116 --> 00:00:55,916
Our project would never have succeeded without him.

17
00:00:56,757 --> 00:00:58,097
Shigeru, can you introduce yourself?

18
00:00:59,437 --> 00:01:02,878
Hello, I'm Shigeru Awaji, an online backend engineer

19
00:01:03,714 --> 00:01:06,516
In my previous career, I designed and created

20
00:01:06,576 --> 00:01:09,719
general Windows desktop applications and databases,

21
00:01:10,640 --> 00:01:12,822
and I made a career change to the game industry.

22
00:01:13,683 --> 00:01:16,706
By using that knowledge, especially in the last three years,

23
00:01:17,407 --> 00:01:21,190
I have done data analysis work with over 20 projects.

24
00:01:22,391 --> 00:01:23,973
Using AI and simulation results,

25
00:01:24,373 --> 00:01:27,756
we created a tool to visualize the characters' behaviors.

26
00:01:31,008 --> 00:01:34,751
There will be time for Q&A at the end of this presentation.

27
00:01:35,291 --> 00:01:38,593
So Shigeru and I will try to answer them as best as we can.

28
00:01:38,613 --> 00:01:41,275
OK, let's start.

29
00:01:44,658 --> 00:01:46,800
This is the outline of the presentation.

30
00:01:47,680 --> 00:01:51,963
First, I briefly introduce the game targeted for the research.

31
00:01:53,004 --> 00:01:56,707
Next, I explain how we use AI to balance the game

32
00:01:56,787 --> 00:01:59,529
with the different successes and failures we had.

33
00:02:00,924 --> 00:02:03,065
This is a main topic in this presentation,

34
00:02:03,525 --> 00:02:05,965
so I will give a detailed explanation

35
00:02:06,186 --> 00:02:08,306
of the AI algorithm and the results.

36
00:02:10,067 --> 00:02:13,167
After that, I'll show how to configure the system.

37
00:02:14,088 --> 00:02:17,709
Finally, I talk about the future plan of our research.

38
00:02:22,750 --> 00:02:25,591
Our research was about finding a method

39
00:02:25,671 --> 00:02:28,031
to balance the gain, grains, nodes, repage.

40
00:02:29,216 --> 00:02:31,797
It's an action battle game for smartphones.

41
00:02:33,058 --> 00:02:35,520
And the main game loop is the following one.

42
00:02:36,280 --> 00:02:39,782
At first, prepare the party before the battle.

43
00:02:40,863 --> 00:02:42,944
Choose the characters and their equipment.

44
00:02:43,864 --> 00:02:44,765
Then the battles.

45
00:02:45,865 --> 00:02:49,787
It's automated, so the player cannot do anything.

46
00:02:51,508 --> 00:02:52,489
And the post-battle.

47
00:02:53,712 --> 00:02:57,054
The player receives rewards based on the result,

48
00:02:57,774 --> 00:02:59,615
which allows him to become stronger.

49
00:03:00,955 --> 00:03:02,116
Then repeat.

50
00:03:07,278 --> 00:03:09,999
Party consists of four main chapters.

51
00:03:11,300 --> 00:03:14,321
Each chapter is supported by two heroes,

52
00:03:15,081 --> 00:03:18,423
and only the heroes will participate in the battles.

53
00:03:19,363 --> 00:03:21,184
There are a few hundreds of heroes.

54
00:03:26,445 --> 00:03:31,308
Each hero can have some equipment, such as weapons and accessories.

55
00:03:32,248 --> 00:03:39,472
For example, there are about 100 kinds of weapons, and each weapon can utilize up to

56
00:03:39,632 --> 00:03:43,654
five enhanced items out of 65 available choices.

57
00:03:49,717 --> 00:03:55,020
The hero's behavior in battle depends on its hero AI equipment.

58
00:03:56,750 --> 00:04:00,951
Each hero AI contains a predetermined rule set of actions

59
00:04:01,471 --> 00:04:03,472
which can be customized by the player.

60
00:04:06,393 --> 00:04:08,774
It evaluates conditions from the top

61
00:04:09,814 --> 00:04:11,554
until any condition is matched

62
00:04:12,395 --> 00:04:14,716
and execute its associated action.

63
00:04:16,616 --> 00:04:17,897
Though the system is simple,

64
00:04:18,677 --> 00:04:21,538
there are a few dozens of conditions and actions.

65
00:04:22,625 --> 00:04:25,586
And their actual behaviors change depending

66
00:04:25,706 --> 00:04:27,407
on heroes' properties.

67
00:04:28,167 --> 00:04:31,869
As a result, it's difficult to find the best hero

68
00:04:31,989 --> 00:04:33,409
AIs for each hero.

69
00:04:34,510 --> 00:04:36,751
But it's a high potential feature,

70
00:04:37,151 --> 00:04:40,572
as it allows the character to beat stronger characters.

71
00:04:48,395 --> 00:04:51,436
Until now, I explained how to configure a hero.

72
00:04:52,687 --> 00:04:57,091
Eventually, Apati is built by eight heroes like this figure.

73
00:05:03,517 --> 00:05:08,862
So I think you start to understand why balancing grains nodes is a nightmare.

74
00:05:09,623 --> 00:05:15,348
But just in case, let's see a number of possible combinations for Apati to give us a better idea.

75
00:05:16,790 --> 00:05:18,171
We have eight main characters.

76
00:05:19,099 --> 00:05:22,580
80 heroes, 60 weapons, 3 costumes, etc.

77
00:05:23,141 --> 00:05:29,243
And the number of possible combinations is 10 for 182.

78
00:05:30,623 --> 00:05:31,524
A real lie to me.

79
00:05:31,884 --> 00:05:32,224
You see?

80
00:05:33,544 --> 00:05:35,685
Furthermore, the game is actually

81
00:05:35,765 --> 00:05:39,866
updated every one or two weeks with new characters, weapons,

82
00:05:40,046 --> 00:05:40,667
and so on.

83
00:05:42,007 --> 00:05:45,588
And we need to find the balance breakers before each update.

84
00:05:46,309 --> 00:05:47,529
Impossible, right?

85
00:05:53,319 --> 00:05:55,821
In the situation that the amount of data

86
00:05:55,881 --> 00:05:59,102
continues to increase over time, it's

87
00:05:59,182 --> 00:06:02,584
very difficult to adjust game balance by hand.

88
00:06:06,046 --> 00:06:08,868
Our idea for the problem is, let's

89
00:06:08,968 --> 00:06:11,089
try to make the strongest party.

90
00:06:11,990 --> 00:06:15,291
If there are elements that break the balance of the game,

91
00:06:15,972 --> 00:06:18,713
the strongest party must have these elements.

92
00:06:19,874 --> 00:06:21,115
It's a really simple idea.

93
00:06:24,329 --> 00:06:26,650
This methodology of search is called

94
00:06:27,211 --> 00:06:29,472
optimization-based falsification.

95
00:06:30,953 --> 00:06:33,634
It uses global optimization methods

96
00:06:34,094 --> 00:06:36,856
to guide the test toward a possibly small region

97
00:06:37,076 --> 00:06:41,358
in the input space that leads to incorrect system behavior.

98
00:06:42,699 --> 00:06:45,280
In our case, a game balance breaker.

99
00:06:48,142 --> 00:06:51,484
I'll explain an algorithm to find the best combination

100
00:06:51,624 --> 00:06:53,145
of characters and equipment.

101
00:07:00,090 --> 00:07:02,051
First, I'll show the result a little.

102
00:07:03,252 --> 00:07:06,173
The left party is created by our team,

103
00:07:07,253 --> 00:07:09,374
and the right party is the opponent.

104
00:07:10,975 --> 00:07:15,036
The upper bars show each health point.

105
00:07:16,637 --> 00:07:19,718
A party that has more health points is the winner.

106
00:07:27,045 --> 00:07:30,906
Okaji Party, hajimeru yo!

107
00:07:31,847 --> 00:07:33,947
She is the strongest hero in our party.

108
00:07:34,988 --> 00:07:39,630
She is equipped with a weapon that heals her every time she kills an enemy.

109
00:07:40,550 --> 00:07:45,872
And due to her hero AI settings, she uses it frequently in her ultimate skill.

110
00:07:46,912 --> 00:07:51,394
It repositions her far from the enemy, so it's hard to get damaged.

111
00:07:52,733 --> 00:07:57,116
Every time she uses her ultimate skill, she consumes two points.

112
00:07:58,337 --> 00:08:01,180
In the video, as soon as there are two points available,

113
00:08:01,540 --> 00:08:05,423
the hero detects it and directly uses its ultimate.

114
00:08:07,765 --> 00:08:11,648
We never told our method the effect of the ultimate skills

115
00:08:11,949 --> 00:08:15,511
or the meaning of the hero AI conditions and actions.

116
00:08:16,773 --> 00:08:24,377
Nevertheless, the method was able to optimize the play of this hero by only observing the battle results.

117
00:08:35,841 --> 00:08:43,245
To create parties, we use genetic algorithm, which will be referred to as GA in this presentation.

118
00:08:44,813 --> 00:08:51,518
GA is a method for combinational optimization based on biological evolution.

119
00:08:53,099 --> 00:08:57,722
GA simulates evolution of individuals in an environment.

120
00:08:59,883 --> 00:09:04,806
The evolution proceeds by crossover of individuals between each other.

121
00:09:06,087 --> 00:09:12,771
In this process, the better individuals will have a higher probability of being chosen as parents.

122
00:09:14,803 --> 00:09:18,747
Individuals born from good parents tend to be good too.

123
00:09:19,387 --> 00:09:21,969
In the result, after some generations,

124
00:09:22,750 --> 00:09:25,191
all individuals get better in general.

125
00:09:28,034 --> 00:09:30,796
This is a general explanation for GA.

126
00:09:31,316 --> 00:09:33,658
So let's confirm the correspondence

127
00:09:33,778 --> 00:09:34,899
with Grimm's modes.

128
00:09:42,290 --> 00:09:45,272
The environment is a problem we want to solve.

129
00:09:45,852 --> 00:09:49,475
So it is a battle in our case.

130
00:09:52,137 --> 00:09:55,879
An individual is a candidate to solve the problem.

131
00:09:57,660 --> 00:09:58,481
It's a party.

132
00:10:01,223 --> 00:10:03,485
Each individual has a fitness value,

133
00:10:04,065 --> 00:10:08,288
which is a score that represents the degree of adaptation

134
00:10:08,548 --> 00:10:09,729
against the environment.

135
00:10:11,169 --> 00:10:16,474
As the environment is the battle, the fitness is the battle result.

136
00:10:18,216 --> 00:10:21,799
There are many other terms in GA, but these are enough for today.

137
00:10:27,364 --> 00:10:33,770
As a side note, we chose GA not because it's the best algorithm to find the balance breakers.

138
00:10:34,671 --> 00:10:35,752
There are three reasons.

139
00:10:37,845 --> 00:10:41,107
First, a GA is a simple algorithm.

140
00:10:41,728 --> 00:10:44,249
It's easy to understand and implement.

141
00:10:47,531 --> 00:10:50,033
Second, GA has a long history.

142
00:10:51,254 --> 00:10:54,256
We can find many understandable explanations

143
00:10:54,676 --> 00:10:55,717
on different media.

144
00:10:58,078 --> 00:11:02,261
This helps us to save our time to study and implement GA.

145
00:11:06,840 --> 00:11:11,242
Third, we can get the suboptimal solution in limited time.

146
00:11:12,802 --> 00:11:15,383
In game development, the structure

147
00:11:15,643 --> 00:11:17,784
often changes suddenly, right?

148
00:11:19,165 --> 00:11:24,127
So GA outputs an optimal solution at the time.

149
00:11:25,767 --> 00:11:30,189
In conclusion, we use GA because it's

150
00:11:30,349 --> 00:11:32,570
suitable for product development.

151
00:11:37,559 --> 00:11:40,000
Now, let's see the process of GA.

152
00:11:41,701 --> 00:11:45,783
After the initialization, we evaluate the parties,

153
00:11:46,544 --> 00:11:50,366
we select the best parties, we crossbreed them,

154
00:11:51,507 --> 00:11:53,108
and mutate a few of them.

155
00:11:54,668 --> 00:11:57,190
This process is done for each generation.

156
00:11:59,091 --> 00:12:01,853
And after specified conditions have been reached,

157
00:12:02,673 --> 00:12:06,335
or a specified time has elapsed, the algorithm stops.

158
00:12:07,614 --> 00:12:10,916
From here, I'll explain them step by step.

159
00:12:17,961 --> 00:12:19,462
Step one, initialization.

160
00:12:20,463 --> 00:12:22,605
The initialization is a simple part.

161
00:12:24,766 --> 00:12:27,949
GA choose characters and equipment randomly

162
00:12:28,569 --> 00:12:30,310
and create parties using them.

163
00:12:32,589 --> 00:12:34,791
These randomly created individuals

164
00:12:34,991 --> 00:12:38,255
will be the individuals of our first generation.

165
00:12:42,859 --> 00:12:45,862
Step two, evaluation of the parties.

166
00:12:46,783 --> 00:12:50,627
In this step, the algorithm will evaluate each party

167
00:12:50,867 --> 00:12:53,450
on how good they are against the environment,

168
00:12:53,850 --> 00:12:55,632
which is, in this case, the bottles.

169
00:12:57,655 --> 00:13:02,777
So the fitness of each party will be computed based on the result of their battles.

170
00:13:08,280 --> 00:13:10,982
In Grimm's notes, there are different types of battles.

171
00:13:12,362 --> 00:13:17,365
We focused on two types of them, PvE and PvP.

172
00:13:19,146 --> 00:13:24,468
In PvE, the players fight against predetermined parties from the game.

173
00:13:26,038 --> 00:13:29,099
On the other hand, in PvP, the prerogatives

174
00:13:29,359 --> 00:13:31,560
are fine-tuned by other players.

175
00:13:33,260 --> 00:13:36,041
In both cases, the battles are automated.

176
00:13:45,263 --> 00:13:48,963
I summarize the differences between PvE and PvP.

177
00:13:50,124 --> 00:13:52,524
These differences look very small,

178
00:13:53,244 --> 00:13:55,465
but they affect the evaluation methods.

179
00:14:00,680 --> 00:14:04,563
Players fight in PVE to get many materials.

180
00:14:05,823 --> 00:14:08,906
No amount of materials could satisfy the players.

181
00:14:10,007 --> 00:14:13,329
There is no constraint of number of challenges,

182
00:14:15,410 --> 00:14:17,112
and no defeat penalty.

183
00:14:19,754 --> 00:14:23,817
Consequently, it's very important to win quickly.

184
00:14:28,792 --> 00:14:32,473
So, we use these axes for evaluation.

185
00:14:33,833 --> 00:14:37,934
In case of victory, we are going to use the battle time.

186
00:14:39,535 --> 00:14:43,896
In case of defeat, the time is not a good expression

187
00:14:44,296 --> 00:14:45,776
of how good was the party.

188
00:14:46,756 --> 00:14:49,977
We use instead the damage dealt by the party.

189
00:14:53,646 --> 00:14:56,187
As you can see, these evaluation policies

190
00:14:56,387 --> 00:14:58,608
are very specialized for the game.

191
00:15:03,210 --> 00:15:04,731
Next, for PvP.

192
00:15:06,652 --> 00:15:09,813
The players aim to get more arena points.

193
00:15:10,333 --> 00:15:13,795
I won't explain what exactly arena points are,

194
00:15:13,815 --> 00:15:17,537
but the important point is that they

195
00:15:17,617 --> 00:15:21,438
can be won or lost depending on the result of the battle.

196
00:15:24,625 --> 00:15:28,048
And because the number of battles is limited,

197
00:15:29,549 --> 00:15:32,631
the player will want to make the most out of them.

198
00:15:34,713 --> 00:15:39,616
These facts indicate that the important point for PVP

199
00:15:40,196 --> 00:15:43,479
is high and stable winning percentage.

200
00:15:46,821 --> 00:15:49,803
But the player cannot choose the opponent.

201
00:15:55,703 --> 00:15:57,683
To measure the winning percentage,

202
00:15:58,644 --> 00:16:01,264
we let the generated party to fight

203
00:16:01,684 --> 00:16:05,485
against some of the top players from the online leaderboard.

204
00:16:07,466 --> 00:16:11,127
We use the average of the result as evaluation values.

205
00:16:12,487 --> 00:16:15,468
These top players have different fighting styles.

206
00:16:16,248 --> 00:16:20,929
As a result, we can assess the ability of the generated party

207
00:16:21,269 --> 00:16:23,190
to win any PVP match.

208
00:16:31,569 --> 00:16:36,412
So this is the final version of evolution policy in PVP.

209
00:16:37,433 --> 00:16:41,435
For both victory and defeat, we use the difference

210
00:16:41,675 --> 00:16:43,096
of remaining life points.

211
00:16:45,378 --> 00:16:48,680
In the case of close matches, there's

212
00:16:48,780 --> 00:16:51,942
little difference in score between victory or defeat.

213
00:16:52,463 --> 00:16:56,466
Therefore, we add a fixed amount of bonus points

214
00:16:56,626 --> 00:17:00,368
to see a bigger difference between victory and defeat.

215
00:17:03,382 --> 00:17:07,084
This policy is also very specialized for the game.

216
00:17:12,406 --> 00:17:15,787
The evaluation equation is very important and sensitive

217
00:17:16,107 --> 00:17:19,108
for not only GA, but also other learning methods.

218
00:17:21,069 --> 00:17:24,811
It takes a little time to design a good evaluation equation.

219
00:17:25,331 --> 00:17:28,792
We need to think about what is the essence of the game.

220
00:17:30,807 --> 00:17:34,770
we decide not to generalize, but to specialize the equation

221
00:17:34,830 --> 00:17:38,532
to our game to get more accurate evaluation value.

222
00:17:44,316 --> 00:17:49,399
In case of PVE, the victory and defeat evaluation functions

223
00:17:49,579 --> 00:17:53,541
are based on two different units, the time,

224
00:17:53,782 --> 00:17:57,524
in case of victory, and the damage dealt, in case of defeat.

225
00:17:59,076 --> 00:18:02,258
GA needs to compare evaluation values,

226
00:18:02,698 --> 00:18:04,880
but it's difficult to compare the values

227
00:18:05,220 --> 00:18:06,741
if their units are different.

228
00:18:09,082 --> 00:18:12,404
Therefore, we mapped this value to one axis.

229
00:18:15,106 --> 00:18:18,788
For PVP, we handle the evaluation value in the same way.

230
00:18:25,252 --> 00:18:28,614
Now, let's advance to step three in GA.

231
00:18:29,440 --> 00:18:30,901
Select the best parties.

232
00:18:33,002 --> 00:18:36,404
After evaluation process, GA choose parties

233
00:18:36,584 --> 00:18:39,085
to be inherited to the next generation.

234
00:18:41,227 --> 00:18:44,608
As evaluation value are on one dimension now,

235
00:18:45,329 --> 00:18:47,930
we can know easily which parties are better.

236
00:18:49,391 --> 00:18:56,154
We decided that we keep top 80% parties for the next generation

237
00:18:57,135 --> 00:18:58,536
and dispose the others.

238
00:18:59,944 --> 00:19:03,047
This policy keeps the diversity in parties

239
00:19:03,547 --> 00:19:05,769
and avoids falling to a local optimum.

240
00:19:11,313 --> 00:19:14,956
Step four, cross-breed the selected parties.

241
00:19:16,437 --> 00:19:20,000
We represent a party composition as tree structure.

242
00:19:21,781 --> 00:19:26,425
It selects one point to cut in each tree randomly

243
00:19:27,626 --> 00:19:29,367
and swap the crepe subtree.

244
00:19:30,089 --> 00:19:30,870
like this figure.

245
00:19:31,990 --> 00:19:35,493
This is the Wiener method, one-point crossover.

246
00:19:43,418 --> 00:19:47,180
Step five, mutate a part of the parties.

247
00:19:48,941 --> 00:19:52,824
We expect the crossover improves the parties entirely,

248
00:19:52,844 --> 00:19:57,086
but it's a probabilistic method.

249
00:19:58,493 --> 00:20:01,376
Sometimes good elements can disappear.

250
00:20:01,936 --> 00:20:05,139
Also, in the parties randomly generated

251
00:20:05,340 --> 00:20:08,082
in the first generation, there might

252
00:20:08,703 --> 00:20:10,605
be no overpowered elements.

253
00:20:13,207 --> 00:20:16,751
Our mutation method compensates these disadvantages.

254
00:20:17,571 --> 00:20:21,075
The mutation occurs with a 5% probability.

255
00:20:22,056 --> 00:20:22,756
In the mutation.

256
00:20:24,460 --> 00:20:27,022
After selecting a point to cut randomly,

257
00:20:27,422 --> 00:20:32,286
it replaces the subtree with a new randomly generated

258
00:20:32,406 --> 00:20:32,886
subtree.

259
00:20:35,388 --> 00:20:39,691
As this is also a random operation, in most of the case,

260
00:20:40,031 --> 00:20:41,892
mutated parts get worse.

261
00:20:42,693 --> 00:20:46,435
However, rarely very good elements appear,

262
00:20:46,936 --> 00:20:49,998
and they are inherited to subsequent generation.

263
00:20:53,715 --> 00:20:56,978
I guess you feel a bit afraid of the mutation work.

264
00:20:57,678 --> 00:20:59,279
That depends on luck.

265
00:21:00,661 --> 00:21:03,723
That's why I was afraid of the same thing, too.

266
00:21:05,324 --> 00:21:09,687
As an experiment, we ran GA repeatedly

267
00:21:10,188 --> 00:21:12,609
in the same settings except random seed.

268
00:21:14,371 --> 00:21:17,013
There was a hero that always appeared

269
00:21:17,253 --> 00:21:18,494
in the final generations.

270
00:21:19,114 --> 00:21:23,037
But sometimes that hero was not in the initial generations.

271
00:21:26,126 --> 00:21:29,668
This experiment proved that this mutation works well

272
00:21:29,868 --> 00:21:33,850
and is an important process for the coverage of the elements.

273
00:21:42,275 --> 00:21:45,997
Until now, I explained the evaluation of the parties,

274
00:21:46,557 --> 00:21:50,019
the selection of the best parties, their crossover,

275
00:21:50,500 --> 00:21:51,660
and their mutations.

276
00:21:52,940 --> 00:21:57,743
By repeating it many times, GA improves the parties gradually.

277
00:22:04,606 --> 00:22:07,548
This is a more simplified figure of the overview.

278
00:22:09,369 --> 00:22:13,391
Our system repeats the battle, evaluation, and improvement

279
00:22:13,431 --> 00:22:13,831
steps.

280
00:22:15,952 --> 00:22:20,234
As evaluation and improvement are located outside of the game,

281
00:22:22,778 --> 00:22:25,441
We need a communication pipeline with the game.

282
00:22:27,843 --> 00:22:31,326
We use an API to communicate with the game

283
00:22:31,706 --> 00:22:35,089
because we delegate the development of the game

284
00:22:35,189 --> 00:22:37,070
to an external company.

285
00:22:38,972 --> 00:22:42,755
Therefore, using the API is a suitable method for us.

286
00:22:43,336 --> 00:22:46,699
But if all members are in the same development team,

287
00:22:47,099 --> 00:22:50,121
it might be OK to communicate directly in the course.

288
00:22:54,875 --> 00:22:57,455
Before and after the improvement step,

289
00:22:57,956 --> 00:22:59,696
there is a conversion process.

290
00:23:01,897 --> 00:23:04,498
This looks redundant work, but it

291
00:23:04,638 --> 00:23:08,799
allows the improvement steps to be independent from the game

292
00:23:09,599 --> 00:23:12,360
and so that it can be applied to any games.

293
00:23:17,661 --> 00:23:21,963
In short, the battle part is almost the same

294
00:23:22,063 --> 00:23:22,863
as actual game.

295
00:23:24,934 --> 00:23:27,836
Improvement process by GHMB-SHIELD.

296
00:23:30,037 --> 00:23:32,558
If we customize the communication pipeline,

297
00:23:32,918 --> 00:23:35,820
the evaluation, the gene conversion process,

298
00:23:37,600 --> 00:23:39,922
we can apply this method to other genes.

299
00:23:42,003 --> 00:23:45,784
Actually, the evaluation and the conversion are small functions,

300
00:23:46,345 --> 00:23:51,387
so most of the required customization work is in the communication pipeline.

301
00:23:58,848 --> 00:24:01,889
This is one of the results we got for PVE.

302
00:24:03,169 --> 00:24:05,130
A point shows a party.

303
00:24:05,990 --> 00:24:09,511
Blue means victory, and green means defeat.

304
00:24:11,212 --> 00:24:14,313
The evolution proceeds from left to right,

305
00:24:15,053 --> 00:24:18,134
and the vertical axis shows the battle time.

306
00:24:23,136 --> 00:24:24,976
At the beginning of the evolution,

307
00:24:25,937 --> 00:24:27,737
all parties lost their battles.

308
00:24:30,150 --> 00:24:32,110
After the first winning party appeared,

309
00:24:32,130 --> 00:24:36,431
the number of winning parties increases generation

310
00:24:36,631 --> 00:24:39,792
after generation, and the battle time decreases.

311
00:24:41,532 --> 00:24:43,973
PvE battles tend to be easy to win,

312
00:24:44,153 --> 00:24:47,434
so this party evolved without any trouble.

313
00:24:52,375 --> 00:24:54,035
This is a result for PvP.

314
00:24:55,963 --> 00:25:00,325
Please note that the vertical axis changed from battle time to fitness value.

315
00:25:01,285 --> 00:25:04,646
So the higher the fitness value, the better the party.

316
00:25:08,006 --> 00:25:10,687
The fitness score improved continuously too.

317
00:25:11,927 --> 00:25:16,048
On the other hand, there is some sudden growth sometimes.

318
00:25:17,624 --> 00:25:21,531
It's more difficult to win PvP battles than PvE battles.

319
00:25:22,112 --> 00:25:25,939
So this sudden growth happened when the generated parties

320
00:25:25,979 --> 00:25:30,127
solved one of the reasons they were losing the battles before.

321
00:25:35,390 --> 00:25:38,171
This is the best party in this evolution.

322
00:25:38,811 --> 00:25:42,113
However, because the fitness value is computed

323
00:25:42,193 --> 00:25:44,914
based on the result of 15 battles,

324
00:25:45,394 --> 00:25:47,315
there is a certain measure of error.

325
00:25:48,235 --> 00:25:49,956
To confirm the party's strength,

326
00:25:50,776 --> 00:25:53,317
we made it fight in 300 battles.

327
00:25:57,099 --> 00:25:59,540
The upper number is the winning rate

328
00:25:59,740 --> 00:26:02,621
against parties that were used for the evolution.

329
00:26:03,858 --> 00:26:08,001
The lower number is winning rate against the other parties.

330
00:26:09,242 --> 00:26:11,664
Both of them shows high win percentage,

331
00:26:12,344 --> 00:26:14,546
and they're almost the same.

332
00:26:15,427 --> 00:26:18,429
This result indicates the best party

333
00:26:18,469 --> 00:26:21,551
can win against the various parties as planned.

334
00:26:32,343 --> 00:26:38,946
This is a video of a battle where the best party created by G.E.L. fight against the opponent.

335
00:26:39,566 --> 00:26:43,347
The game version is different from the video I showed just a while ago.

336
00:26:43,788 --> 00:26:51,111
So the party composition was changed because new characters and pieces of equipment have been added.

337
00:26:52,691 --> 00:26:54,712
Please watch the strongest party.

338
00:26:59,616 --> 00:27:05,620
I guess some of you have never played this game before, so you may not understand what

339
00:27:05,720 --> 00:27:07,202
is happening on the screen.

340
00:27:07,762 --> 00:27:10,344
But it's the same for me.

341
00:27:10,364 --> 00:27:20,651
Although we can understand just a little, we cannot follow all of the actions by the

342
00:27:21,172 --> 00:27:21,992
8 heroes action.

343
00:27:33,906 --> 00:27:35,487
And to share this presentation,

344
00:27:35,507 --> 00:27:38,710
I explain the detail of the GA algorithm.

345
00:27:39,731 --> 00:27:41,693
GA showed as a strong parties.

346
00:27:42,153 --> 00:27:45,216
However, it's too complex to understand.

347
00:27:46,257 --> 00:27:49,840
Video of battles are also very hard to understand.

348
00:27:51,501 --> 00:27:54,764
We need a better way to visualize this information.

349
00:27:56,080 --> 00:27:59,942
From now, I'll introduce our visualization method

350
00:28:00,122 --> 00:28:03,904
to find the valuable information from enormous amount of data.

351
00:28:15,070 --> 00:28:16,971
Every time that analysis progresses,

352
00:28:17,652 --> 00:28:21,234
every time the game is updated, what you want to check

353
00:28:21,434 --> 00:28:23,615
and what you want to know will change.

354
00:28:24,609 --> 00:28:28,910
Therefore, the visualization is required to be startable

355
00:28:29,090 --> 00:28:32,091
at low cost, easy to be customized.

356
00:28:35,052 --> 00:28:37,873
We are using open source Apache Debian.

357
00:28:38,913 --> 00:28:41,134
Various languages and data sources

358
00:28:41,314 --> 00:28:42,794
are available for this tool.

359
00:28:44,735 --> 00:28:46,656
We can add and change the display

360
00:28:46,696 --> 00:28:49,756
such as table and graph any time we want.

361
00:28:51,537 --> 00:28:55,260
Apache Spark that runs in the background has scalability

362
00:28:55,801 --> 00:28:59,103
that can adapt its memory and CPU usage

363
00:28:59,524 --> 00:29:02,886
to the available CPU and memory with clusters.

364
00:29:04,608 --> 00:29:06,850
We recommend it as it's convenient

365
00:29:06,930 --> 00:29:09,752
to can be used immediately for free.

366
00:29:15,767 --> 00:29:21,489
In this table, we can see the result of 15 matches executed by one party.

367
00:29:24,330 --> 00:29:28,392
Each match results are compressed and displayed in a row.

368
00:29:29,633 --> 00:29:38,916
Specifically, it shows the settings of AI, the type of weapon equipped, and the special activity that occurred in the battle.

369
00:29:40,603 --> 00:29:47,268
The column shows the fitness, so the table also serves as a ranking of grade.

370
00:29:53,152 --> 00:29:54,853
Each row follows this structure.

371
00:29:55,954 --> 00:30:00,377
The first part displays a summary of the battle result.

372
00:30:02,398 --> 00:30:07,281
It is then followed by more detailed information about each chapter,

373
00:30:07,442 --> 00:30:10,163
but I omit it partially in this figure.

374
00:30:16,027 --> 00:30:19,471
Let's see the methods to make information easier to see.

375
00:30:20,372 --> 00:30:24,537
They are dimensionality reduction and abstraction.

376
00:30:32,646 --> 00:30:34,728
First, dimensionality reduction.

377
00:30:36,345 --> 00:30:39,566
Finding the best party is very useful for designers.

378
00:30:40,266 --> 00:30:45,328
Sometimes you want to check how strong is a party with a setting composition,

379
00:30:46,008 --> 00:30:49,269
or you want to find similar parties to the best ones.

380
00:30:51,090 --> 00:30:58,572
Until now, the only way to find similar parties was to take a look at the party composition tables

381
00:30:59,352 --> 00:31:01,493
and find similar parties from here.

382
00:31:02,473 --> 00:31:03,994
This table is one of them.

383
00:31:05,336 --> 00:31:09,359
This table only shows the list of weapons used per party.

384
00:31:12,001 --> 00:31:13,862
Each row corresponds to a party,

385
00:31:14,603 --> 00:31:17,085
and each column to the number of times

386
00:31:17,505 --> 00:31:20,548
a specific type of weapon is equipped in the party.

387
00:31:23,270 --> 00:31:24,711
And as you can see,

388
00:31:24,951 --> 00:31:28,093
it is already very difficult to find similar parties.

389
00:31:31,922 --> 00:31:34,063
We needed a better way to visualize

390
00:31:34,103 --> 00:31:35,304
this kind of information.

391
00:31:36,945 --> 00:31:40,307
In this case, we used the dimension reduction method

392
00:31:40,527 --> 00:31:44,089
called principal component analysis for plotting

393
00:31:44,209 --> 00:31:45,530
multidimensional data.

394
00:31:47,491 --> 00:31:50,713
With this method, we reduced the dimensionality of our

395
00:31:50,833 --> 00:31:55,636
previous table into only two dimensions without losing the

396
00:31:55,716 --> 00:31:56,997
feature that data had.

397
00:32:05,219 --> 00:32:07,661
By performing this conversion, it

398
00:32:07,741 --> 00:32:10,863
is now possible to plot 20-dimensional data

399
00:32:11,023 --> 00:32:15,025
into a two-dimensional xy-coordinate system, which

400
00:32:15,085 --> 00:32:17,327
is easier to understand intuitively.

401
00:32:18,627 --> 00:32:21,649
In this case, the graph shows the similarities

402
00:32:21,769 --> 00:32:22,770
between the parties.

403
00:32:27,493 --> 00:32:31,695
For instance, if we want to find parties similar to one

404
00:32:31,715 --> 00:32:33,296
to the parties at the top.

405
00:32:35,935 --> 00:32:37,875
The green parties located at the top

406
00:32:38,035 --> 00:32:40,736
are all very similar to each other.

407
00:32:40,756 --> 00:32:45,798
Each number correspond to party ID.

408
00:32:47,778 --> 00:32:50,739
On the other hand, if we want to find a party

409
00:32:50,859 --> 00:32:54,080
that is largely different from a green party,

410
00:32:54,860 --> 00:32:57,181
the parties located at the opposite,

411
00:32:57,861 --> 00:33:01,262
in this case, at the bottom left,

412
00:33:03,703 --> 00:33:04,943
will be great candidates.

413
00:33:08,277 --> 00:33:10,398
It takes a little time to use this method

414
00:33:10,538 --> 00:33:13,619
because it requires some data preparation.

415
00:33:14,319 --> 00:33:16,721
But important point is that this method

416
00:33:16,801 --> 00:33:19,862
can help you solve this kind of problem effectively.

417
00:33:26,105 --> 00:33:29,146
Next, this is an example using abstraction.

418
00:33:31,507 --> 00:33:32,868
The content of the frame.

419
00:33:34,064 --> 00:33:39,765
is status, such as the number of ultimate points, attack power, etc.

420
00:33:40,825 --> 00:33:50,188
For example, if a hero has 74,000 health points, is it high? Is it low?

421
00:33:52,909 --> 00:33:59,971
This exact number has no meaning. What is important is to know how high or low

422
00:34:00,971 --> 00:34:02,531
it is relative to the other.

423
00:34:04,667 --> 00:34:07,287
Here, we explain relative evaluation

424
00:34:07,507 --> 00:34:09,388
using standard deviation.

425
00:34:18,211 --> 00:34:21,152
Standard deviation is a measure that

426
00:34:21,232 --> 00:34:24,253
is used to quantify the amount of variation

427
00:34:24,833 --> 00:34:26,253
of a set of data values.

428
00:34:28,325 --> 00:34:31,048
The average is also a well-known measure

429
00:34:31,248 --> 00:34:34,471
to show how relative is a value to the other values.

430
00:34:35,092 --> 00:34:40,397
But it would be affected too much by a few outliers

431
00:34:40,737 --> 00:34:42,779
to express the data properly alone.

432
00:34:44,340 --> 00:34:47,763
Standard deviation helps ranking in accordance

433
00:34:47,843 --> 00:34:49,625
with distribution of the data.

434
00:34:51,390 --> 00:34:57,552
In this slide, C and D are volumes, and HP 74000s

435
00:34:57,852 --> 00:35:01,433
belong to the rank D, which is a little lower

436
00:35:01,473 --> 00:35:02,493
than the average value.

437
00:35:07,714 --> 00:35:11,415
Standard deviation replaces the two detailed numbers

438
00:35:11,635 --> 00:35:15,016
with expression that can be understood at a glance.

439
00:35:24,813 --> 00:35:28,497
What I'll show you next is a change of granularity.

440
00:35:30,178 --> 00:35:32,240
The part highlighted in the figure

441
00:35:32,420 --> 00:35:34,302
is the settings of the Hero AI,

442
00:35:34,963 --> 00:35:37,345
which are compressed into single letters.

443
00:35:40,348 --> 00:35:41,589
What was the Hero AI?

444
00:35:42,409 --> 00:35:44,491
As explained earlier in this presentation,

445
00:35:45,192 --> 00:35:48,055
Hero AI is a rule set that decides

446
00:35:48,175 --> 00:35:50,917
heroes' behavior in the automated battle.

447
00:35:53,957 --> 00:35:55,257
There are many kinds of settings.

448
00:35:56,078 --> 00:36:00,400
We focused only on the actions and ignored the conditions

449
00:36:00,780 --> 00:36:04,662
to represent the equipped hero settings at the simplest level.

450
00:36:10,506 --> 00:36:13,807
In Action AI, we also compress the meanings

451
00:36:13,948 --> 00:36:16,309
so that the pattern stays very simple.

452
00:36:17,009 --> 00:36:20,471
For example, there are some pieces of the hero AI

453
00:36:20,571 --> 00:36:22,232
that trigger ultimate skill.

454
00:36:23,410 --> 00:36:25,351
Ultimate Steel, immediately,

455
00:36:25,912 --> 00:36:28,273
Millennium, close range, long range,

456
00:36:28,954 --> 00:36:30,255
and on the same line.

457
00:36:30,975 --> 00:36:34,077
We grouped all of them into the category U.

458
00:36:35,498 --> 00:36:38,200
It is the same for all other pieces of the Share AI.

459
00:36:43,584 --> 00:36:45,946
If features can be understood at a glance,

460
00:36:46,826 --> 00:36:48,548
comparison becomes easier.

461
00:36:49,934 --> 00:36:53,375
For example, we can know easily that the first hero

462
00:36:53,496 --> 00:36:56,537
in these four parties has similar hero AI

463
00:36:56,977 --> 00:36:59,038
by comparing only six letters.

464
00:37:00,438 --> 00:37:02,579
Letter U means ultimate skill,

465
00:37:03,360 --> 00:37:05,280
and F means full combat attack.

466
00:37:05,360 --> 00:37:09,522
So we can understand that this hero is very aggressive.

467
00:37:11,632 --> 00:37:13,915
Of course, a part of the information is lost

468
00:37:14,116 --> 00:37:15,998
when we abstracted HeroAI,

469
00:37:16,699 --> 00:37:20,344
but tendencies are enough for us in most of the cases.

470
00:37:21,907 --> 00:37:24,530
If the short latest makes us want to know more

471
00:37:24,671 --> 00:37:25,532
about this party,

472
00:37:26,153 --> 00:37:28,836
we can open the page of its detailed information.

473
00:37:34,888 --> 00:37:38,231
There is no information about the conditions of hearing eye,

474
00:37:38,711 --> 00:37:40,753
but we can see a little information

475
00:37:40,993 --> 00:37:43,055
by the order of the letters.

476
00:37:45,157 --> 00:37:49,140
Actions at left side have higher priority and importance

477
00:37:49,300 --> 00:37:51,642
because the conditions associated

478
00:37:51,702 --> 00:37:55,305
with the more left side actions will be evaluated first.

479
00:37:56,830 --> 00:37:59,572
We can know a certain amount of information

480
00:37:59,852 --> 00:38:01,693
about roles played in the battles

481
00:38:02,174 --> 00:38:05,016
by considering not only the complex text data,

482
00:38:05,096 --> 00:38:06,597
but also the order.

483
00:38:13,222 --> 00:38:15,404
This is another example with a change

484
00:38:15,544 --> 00:38:17,285
of granularity of information.

485
00:38:19,647 --> 00:38:21,668
These maps show the battle results

486
00:38:22,149 --> 00:38:24,110
that is used for the calculation

487
00:38:24,330 --> 00:38:26,512
of the fitness in the GA evolution.

488
00:38:35,510 --> 00:38:41,995
In the evaluation I showed today, a fitness value is calculated with the result of 15 battles.

489
00:38:43,016 --> 00:38:48,259
Each party had five different opponents and fought each of them three times.

490
00:38:49,820 --> 00:38:56,165
The symbols at the bottom are the average result of the multiple games for each opponent.

491
00:38:57,650 --> 00:39:03,574
In the example, the winning percentage against enemy 4 is 66%.

492
00:39:04,455 --> 00:39:06,977
So a double circle is shown here.

493
00:39:09,538 --> 00:39:12,160
The battles in the game have a lot of randomness.

494
00:39:13,241 --> 00:39:15,783
Some battle results often change easily.

495
00:39:16,443 --> 00:39:20,246
Therefore, the exact numbers in the winning percentages

496
00:39:20,446 --> 00:39:22,247
do not have big importance.

497
00:39:24,623 --> 00:39:27,625
If the two had a feature that shows color easily,

498
00:39:28,045 --> 00:39:31,468
we wouldn't have used color to show the winning percentage

499
00:39:31,708 --> 00:39:35,470
like a heat map, because it's somehow cool.

500
00:39:36,891 --> 00:39:39,834
Actually, we can understand the rough winning percentage

501
00:39:39,994 --> 00:39:42,896
by the symbols, and it's enough for us.

502
00:39:44,937 --> 00:39:49,200
Like this example, it saves a bit of our limited time

503
00:39:49,560 --> 00:39:52,162
by removing insignificant information.

504
00:40:02,292 --> 00:40:05,195
The third method is summarization,

505
00:40:06,076 --> 00:40:08,518
which extracts the important information

506
00:40:08,638 --> 00:40:10,059
from the large amount of data.

507
00:40:12,121 --> 00:40:15,584
In the example here, you can see the content

508
00:40:15,704 --> 00:40:19,848
of the battle which had been done during the G evolution.

509
00:40:23,651 --> 00:40:26,713
Heroes from the party can be tagged automatically

510
00:40:27,134 --> 00:40:29,396
according to the roles played in the battle.

511
00:40:33,514 --> 00:40:35,155
For instance, in the middle frame,

512
00:40:37,076 --> 00:40:41,139
there is a tag of ace, which is given to the hero

513
00:40:41,419 --> 00:40:44,981
that dealt relatively high damage in that party.

514
00:40:47,083 --> 00:40:52,266
A and H is an abbreviation of attacker and healer,

515
00:40:52,706 --> 00:40:56,589
which will be tagged to the hero who both attack and heal.

516
00:40:59,603 --> 00:41:04,085
The frame on the right said this hero did not join the battle.

517
00:41:05,145 --> 00:41:08,027
Thanks to the tag, we can know that we do not

518
00:41:08,087 --> 00:41:10,007
have to check this hero carefully.

519
00:41:13,549 --> 00:41:16,170
We use the visualization tool at first

520
00:41:16,330 --> 00:41:18,671
to know which battle we should focus on.

521
00:41:19,832 --> 00:41:22,573
Then we watch the video, if required.

522
00:41:24,654 --> 00:41:26,795
Now that we know what we should focus on,

523
00:41:27,495 --> 00:41:28,736
let's see the video again.

524
00:41:38,713 --> 00:41:42,276
This hero, named Sheherazade, was tagged ace,

525
00:41:42,856 --> 00:41:44,478
which means top damage dealer.

526
00:41:46,499 --> 00:41:49,682
Her data also indicates that she's aggressive,

527
00:41:49,902 --> 00:41:51,884
and she buffs attacks and heals.

528
00:41:56,828 --> 00:41:59,450
Her normal attack is not very strong.

529
00:42:08,226 --> 00:42:10,007
She used her ultimate skill here.

530
00:42:13,208 --> 00:42:18,270
Her ultimate heals her ally first, and after that,

531
00:42:22,892 --> 00:42:24,912
a long-range attack occurs.

532
00:42:30,174 --> 00:42:32,155
And she used it again, the ultimate.

533
00:42:35,430 --> 00:42:39,455
The damage is much higher than the damage by the normal attack.

534
00:42:42,859 --> 00:42:44,001
And she used it again.

535
00:42:46,925 --> 00:42:51,350
As a summary, she keeps her party alive while dealing

536
00:42:51,471 --> 00:42:52,973
high damage to the opponent.

537
00:43:03,536 --> 00:43:06,457
Actually, outside the previously introduced hero,

538
00:43:06,917 --> 00:43:09,158
we found a few other strong heroes.

539
00:43:10,058 --> 00:43:11,519
Let me introduce one of them.

540
00:43:16,580 --> 00:43:18,921
This hero, despite being strong,

541
00:43:19,161 --> 00:43:22,522
is not very popular among the player base.

542
00:43:24,743 --> 00:43:26,904
Her ultimate skill costs very little

543
00:43:27,044 --> 00:43:28,865
compared to the previous characters.

544
00:43:31,009 --> 00:43:35,832
Our tool indicates that she's one of the key heroes of some specific parties.

545
00:43:37,073 --> 00:43:38,594
Let's check her in details.

546
00:43:43,237 --> 00:43:47,860
Her ultimate skill is Slow and remains for a long time.

547
00:43:48,621 --> 00:43:55,346
As a result, thanks to its wide collision box, it hits many enemies a lot of times.

548
00:43:58,019 --> 00:44:01,343
The damage is not so high, but her ultimate

549
00:44:01,543 --> 00:44:05,088
pushes back all the opponents on its path

550
00:44:05,108 --> 00:44:07,751
and prevents them from doing anything.

551
00:44:10,434 --> 00:44:13,298
Consequently, despite the opponent

552
00:44:13,378 --> 00:44:17,903
having very strong heroes, they are unable to fight back.

553
00:44:28,316 --> 00:44:31,737
In the end, the video are not what were recorded.

554
00:44:32,937 --> 00:44:35,438
We have a function to replay the battle.

555
00:44:36,818 --> 00:44:39,219
It needs to specify a random seed

556
00:44:39,559 --> 00:44:41,399
and running with fixed frame rate.

557
00:44:42,399 --> 00:44:44,820
The proceeding of the battle is always

558
00:44:44,880 --> 00:44:48,001
the same if we specify the same random seed

559
00:44:48,601 --> 00:44:51,301
and the same party composition by JSON file.

560
00:44:52,815 --> 00:44:58,818
This function makes it possible to watch the battles in the evolution later without recording.

561
00:45:02,220 --> 00:45:08,363
If GA and Visualization 2 are used alone, it will not be useful,

562
00:45:09,043 --> 00:45:10,704
even if it finds bounce breakers.

563
00:45:11,745 --> 00:45:16,407
No game designer believes that it is indeed a failure or a problem

564
00:45:16,607 --> 00:45:20,609
if the only thing they see is numbers and text.

565
00:45:22,002 --> 00:45:23,923
they need a visual proof.

566
00:45:26,005 --> 00:45:28,267
In other words, our visualization tool

567
00:45:28,467 --> 00:45:30,909
only detects potential balance breakers,

568
00:45:31,670 --> 00:45:33,892
and the replay function proves them.

569
00:45:40,417 --> 00:45:43,040
Let's check this process with the previously introduced

570
00:45:43,080 --> 00:45:45,442
space character named Scheherazade.

571
00:45:46,242 --> 00:45:47,483
It's shared balance breaker.

572
00:45:49,694 --> 00:45:52,415
Actually, this character was a popular character

573
00:45:52,535 --> 00:45:54,856
with high evaluation from veteran players.

574
00:45:56,357 --> 00:45:59,898
As the player did, our GA and the visualization too

575
00:46:00,059 --> 00:46:02,640
also found that she's a balance breaker.

576
00:46:03,640 --> 00:46:08,663
However, it's very difficult to get this hero in the game.

577
00:46:10,784 --> 00:46:13,426
After multiple conversation with the designers,

578
00:46:13,967 --> 00:46:17,949
it was concluded that her strength was as designed

579
00:46:18,470 --> 00:46:21,512
and the balance as a whole is working as expected.

580
00:46:29,578 --> 00:46:31,860
When we want to find other balance breakers,

581
00:46:32,340 --> 00:46:34,081
we can do it with a simple operation.

582
00:46:35,564 --> 00:46:38,307
We rerun GA with specific settings

583
00:46:38,668 --> 00:46:42,352
that prevent the use of Scheherazade character

584
00:46:42,552 --> 00:46:43,393
in any party.

585
00:46:45,255 --> 00:46:48,158
GA will search the strongest party with this condition.

586
00:46:59,378 --> 00:47:03,161
This section explains the overall system configuration

587
00:47:03,761 --> 00:47:06,943
and the processing flow from simulation execution

588
00:47:07,464 --> 00:47:08,665
to seeing the result.

589
00:47:10,306 --> 00:47:15,330
First, build a game and deploying it

590
00:47:15,430 --> 00:47:17,031
to the Outplay environment.

591
00:47:19,333 --> 00:47:23,496
And second, the designer executes GA with the tool.

592
00:47:27,008 --> 00:47:31,169
Third, they check the result with a web visualization tool.

593
00:47:32,749 --> 00:47:36,130
They do not have to care about the content in the autoplay

594
00:47:36,210 --> 00:47:36,790
environment.

595
00:47:42,831 --> 00:47:44,792
Inside of the autoplay environment,

596
00:47:45,152 --> 00:47:47,852
we can find all the things I explained earlier.

597
00:47:49,152 --> 00:47:53,173
After the building, computers for the game

598
00:47:53,313 --> 00:47:54,673
have the binary files.

599
00:47:57,894 --> 00:48:00,915
There is a master server to manage the auto battles.

600
00:48:02,295 --> 00:48:05,175
The server stores battle tasks to be run.

601
00:48:08,276 --> 00:48:11,357
The slave computers fetch and run the tasks

602
00:48:12,997 --> 00:48:15,357
and return the result after the battles.

603
00:48:18,718 --> 00:48:22,239
The visualization tool uses the data stored in the server

604
00:48:22,559 --> 00:48:24,619
to show the result to the designer.

605
00:48:33,810 --> 00:48:35,771
That's all for the system configuration.

606
00:48:36,292 --> 00:48:40,054
As much as possible, we made each element of the system

607
00:48:40,234 --> 00:48:45,196
independent to each other, so that we can easily replace one

608
00:48:45,256 --> 00:48:47,377
of them later if we need to.

609
00:48:53,100 --> 00:48:55,042
What about performance for the system?

610
00:48:56,742 --> 00:49:00,745
GA needs to simulate many battles to find strong parties.

611
00:49:02,012 --> 00:49:03,613
How much time does it take?

612
00:49:05,134 --> 00:49:06,836
We tried different approaches.

613
00:49:11,840 --> 00:49:15,903
We created the first simulator to solve the problem.

614
00:49:17,545 --> 00:49:21,488
It is what calculates the result of the battle numerically

615
00:49:22,068 --> 00:49:24,350
by simulating the proceeding of the battle.

616
00:49:27,824 --> 00:49:31,245
The running time was only one second for one battle.

617
00:49:31,665 --> 00:49:37,286
However, we were unable to prove that the simulator was

618
00:49:37,566 --> 00:49:42,127
accurate at 100% because the simulator was a new

619
00:49:42,287 --> 00:49:44,067
implementation of the game loop.

620
00:49:44,847 --> 00:49:49,788
So it may not be exactly the same game loop as it is in the

621
00:49:49,848 --> 00:49:50,588
original game.

622
00:49:53,729 --> 00:49:55,969
Especially when the game was updated.

623
00:49:57,072 --> 00:50:00,194
We need to update manually the simulator game loop.

624
00:50:02,115 --> 00:50:04,957
So it was another heavy burden.

625
00:50:05,837 --> 00:50:08,359
And there was a possibility that we even

626
00:50:08,399 --> 00:50:11,821
forget to update the simulator when we update the game.

627
00:50:14,843 --> 00:50:16,784
We decided to stop using the simulator.

628
00:50:21,185 --> 00:50:24,666
Second idea is to connect the GA directly

629
00:50:25,086 --> 00:50:27,867
to the in-game logic and actually play

630
00:50:27,887 --> 00:50:28,927
the battle in the game.

631
00:50:31,608 --> 00:50:34,969
This idea can guarantee that battle progress will

632
00:50:35,009 --> 00:50:37,170
be the same as in the game.

633
00:50:42,252 --> 00:50:45,433
Also, as I showed, the designer can see the battle

634
00:50:45,573 --> 00:50:46,913
using the replay function.

635
00:50:50,602 --> 00:50:53,364
On the other hand, it takes much time

636
00:50:53,484 --> 00:50:55,266
and many computing resources.

637
00:50:58,768 --> 00:51:02,791
We concluded that accuracy was the most important aspect

638
00:51:02,891 --> 00:51:06,254
for us, and currently we use this solution.

639
00:51:14,880 --> 00:51:19,603
As a conclusion, the requirement of the L-player as follows.

640
00:51:21,830 --> 00:51:26,151
Using in-game logic, it is a necessary condition

641
00:51:26,291 --> 00:51:27,631
to guarantee the accuracy.

642
00:51:29,852 --> 00:51:33,173
The following ones are options, but we strongly

643
00:51:33,253 --> 00:51:34,513
recommend satisfying them.

644
00:51:37,273 --> 00:51:38,714
Supporting acceleration.

645
00:51:39,834 --> 00:51:43,134
The update cycle of games became much shorter

646
00:51:43,174 --> 00:51:44,435
than it used to be.

647
00:51:45,275 --> 00:51:47,435
The shorter the playtime, the better.

648
00:51:51,730 --> 00:51:53,931
executing the program in the cloud.

649
00:51:53,951 --> 00:51:58,753
I said our system is made computer resources.

650
00:51:59,474 --> 00:52:01,034
It will have a problem of budget.

651
00:52:02,235 --> 00:52:04,876
But if the program runs in the cloud,

652
00:52:05,497 --> 00:52:08,398
we can easily start using many resources

653
00:52:08,998 --> 00:52:10,959
and dispose of them soon after.

654
00:52:10,979 --> 00:52:14,361
It reduces the cost to the minimum.

655
00:52:16,462 --> 00:52:20,324
And we don't have to sweat from the fans blowing heat at us.

656
00:52:26,044 --> 00:52:29,568
And of course, these all need to be updated automatically

657
00:52:30,108 --> 00:52:31,450
or by very little work.

658
00:52:39,758 --> 00:52:41,861
Finally, I'd like to talk about

659
00:52:42,041 --> 00:52:44,323
what we want to realize in this feature.

660
00:52:46,119 --> 00:52:52,344
We believe that ideally, the balance of the game should be spiced up time to time,

661
00:52:52,724 --> 00:52:55,847
so the strongest hero is always changing.

662
00:52:57,047 --> 00:53:01,751
To do so, we created a cycle in the correlation of party strength.

663
00:53:03,372 --> 00:53:10,057
However, currently we have no tool to check if the changes we do to the balance of the game

664
00:53:10,318 --> 00:53:14,301
are in line with the cycle of party strength we are aiming for.

665
00:53:16,835 --> 00:53:20,199
We can already let the AI-made parties fight each other,

666
00:53:20,859 --> 00:53:25,425
but we will need new data analysis and data visualization

667
00:53:25,465 --> 00:53:27,968
tools to confirm the cyclic balance.

668
00:53:29,469 --> 00:53:33,173
Also, it would be good to propose party compositions

669
00:53:33,193 --> 00:53:36,317
to players using the result of the data analysis.

670
00:53:45,053 --> 00:53:48,335
Of course, there are still many possibilities in the current system.

671
00:53:49,816 --> 00:53:55,139
We will continue to improve it, especially we focus on data visualization.

672
00:53:56,640 --> 00:54:01,122
The current tool is specialized to visualize only the generated party.

673
00:54:02,003 --> 00:54:07,346
The next major goal is to visualize the regions that G construct the parties.

674
00:54:09,187 --> 00:54:13,129
We are considering using clustering method called k-means.

675
00:54:16,525 --> 00:54:20,228
The clustering makes it possible to see the past progress

676
00:54:20,388 --> 00:54:22,890
of the trial and error by the GA,

677
00:54:22,950 --> 00:54:25,371
so we can know what the GA valued.

678
00:54:26,933 --> 00:54:29,715
The sensitive point is how should we abstract

679
00:54:29,735 --> 00:54:32,277
the party composition for the clustering.

680
00:54:35,539 --> 00:54:38,101
On the other hand, being abstract means

681
00:54:38,241 --> 00:54:40,983
that it makes it difficult to observe

682
00:54:41,023 --> 00:54:43,565
the individual strengths of a party visible.

683
00:54:45,077 --> 00:54:51,159
As a measure for it, we are studying the use of the visualization method called box plot.

684
00:54:52,079 --> 00:54:59,822
Box plots express abstractly while leaving important potentials, such as maximum value,

685
00:54:59,882 --> 00:55:03,743
medium value, and outlier value of growth as a whole.

686
00:55:06,624 --> 00:55:10,005
We would like to continue to report to you about this research.

687
00:55:18,830 --> 00:55:20,991
Let's wrap up the presentation with takeaways.

688
00:55:24,292 --> 00:55:27,392
If you want to balance a game with nightmare amount of data,

689
00:55:28,193 --> 00:55:32,094
finding the strongest elements of your game will help you.

690
00:55:35,814 --> 00:55:38,195
Today I introduced genetic algorithm,

691
00:55:38,535 --> 00:55:42,096
but it's only one of the methods to find strong airlines.

692
00:55:44,657 --> 00:55:46,457
No matter the method you use,

693
00:55:47,302 --> 00:55:50,385
We recommend data visualization and analysis

694
00:55:50,685 --> 00:55:53,968
to understand the strength of the strongest element.

695
00:55:58,452 --> 00:56:01,495
An out-of-play environment is also very important.

696
00:56:02,956 --> 00:56:05,058
If you implement it for your game,

697
00:56:05,539 --> 00:56:08,562
you should use the same logic as actual game

698
00:56:09,042 --> 00:56:10,183
to guarantee the accuracy.

699
00:56:11,730 --> 00:56:18,253
In addition, the outplay function must be updated automatically according to the actual game update.

700
00:56:21,715 --> 00:56:27,137
The most important point is preparing them early in the development.

701
00:56:29,038 --> 00:56:30,759
Are you busy with the game development?

702
00:56:32,520 --> 00:56:38,142
Even if you are too busy now, it's most effective for the budget and the development of your game.

703
00:56:43,233 --> 00:56:45,114
This is a transparency presentation.

704
00:56:52,617 --> 00:56:56,138
I'm sorry, but we're still used to sharing English,

705
00:56:56,198 --> 00:57:00,460
so we'd like to ask you to speak slowly and simply.

706
00:57:00,480 --> 00:57:02,841
It's serious.

707
00:57:12,542 --> 00:57:13,882
Thank you very much, it was great.

708
00:57:14,622 --> 00:57:21,083
How long did it take to fully design

709
00:57:21,303 --> 00:57:23,464
and implement this system?

710
00:57:24,944 --> 00:57:25,464
Thank you.

711
00:57:28,385 --> 00:57:29,225
I couldn't understand.

712
00:57:31,985 --> 00:57:32,845
Well...

713
00:57:32,865 --> 00:57:32,905
Um...

714
00:57:38,666 --> 00:57:42,007
The first prototype finished.

715
00:57:45,083 --> 00:57:55,848
After studying a half of year, and we continue to improve the whole system.

716
00:57:58,290 --> 00:57:59,290
So now it's...

717
00:58:03,132 --> 00:58:10,996
The final version finished by one year?

718
00:58:12,857 --> 00:58:13,338
One year.

719
00:58:15,930 --> 00:58:16,571
About one year.

720
00:58:16,691 --> 00:58:17,211
About one year.

721
00:58:17,611 --> 00:58:18,172
He agreed.

722
00:58:18,292 --> 00:58:20,553
Okay.

723
00:58:20,593 --> 00:58:20,833
Yes.

724
00:58:25,937 --> 00:58:29,699
Have you considered any options for automatically

725
00:58:29,859 --> 00:58:33,601
highlighting the statistical outliers in battle

726
00:58:33,681 --> 00:58:34,522
during the replay?

727
00:58:45,507 --> 00:58:48,569
Sorry, can you change to a more simple one?

728
00:58:49,589 --> 00:58:50,069
I'm sorry.

729
00:58:51,690 --> 00:58:56,814
So, during the replay, it's very difficult to see what's actually happening.

730
00:58:57,354 --> 00:59:03,538
Have you tried finding automatic methods of highlighting those statistical outliers?

731
00:59:03,558 --> 00:59:13,384
I've visualized all the outliers, except for the video.

732
00:59:21,067 --> 00:59:22,568
I think video is best.

733
00:59:24,209 --> 00:59:24,809
Video is best.

734
00:59:27,050 --> 00:59:32,574
So we make visualization for such a video.

735
00:59:32,594 --> 00:59:37,277
And planner want to look video.

736
00:59:45,095 --> 00:59:50,879
So, I want to make more visualization,

737
00:59:51,240 --> 00:59:53,001
but planner want only video.

738
00:59:53,021 --> 00:59:53,101
So,

739
00:59:53,161 --> 00:59:55,482
so now, no idea to system.

740
01:00:14,645 --> 01:00:16,426
Sorry.

741
01:00:18,207 --> 01:00:24,029
Well, video isn't a very good visualization for design.

742
01:00:24,389 --> 01:00:24,649
Sorry.

743
01:00:25,569 --> 01:00:28,550
Other than it, statistics?

744
01:00:31,651 --> 01:00:32,792
Statistics method.

745
01:00:34,912 --> 01:00:36,313
Any other methods?

746
01:00:37,193 --> 01:00:37,833
Did you think?

747
01:00:41,895 --> 01:00:42,915
Is it a question?

748
01:00:43,115 --> 01:00:43,455
It's okay?

749
01:00:44,576 --> 01:00:45,478
Thank you.

750
01:00:47,061 --> 01:00:53,954
Okay, sorry, it's time for...

751
01:00:53,974 --> 01:00:57,139
Thank you for your kind attention.

