1
00:00:11,217 --> 00:00:11,858
Great, thanks Dave.

2
00:00:12,218 --> 00:00:14,502
Okay, so let's get started.

3
00:00:17,988 --> 00:00:20,733
So what is modular AI?

4
00:00:21,194 --> 00:00:21,314
Well.

5
00:00:22,738 --> 00:00:25,561
It's a way to structure your AI architecture.

6
00:00:25,641 --> 00:00:27,102
It's not a specific approach.

7
00:00:27,423 --> 00:00:29,545
In fact, you can take a modular approach

8
00:00:29,585 --> 00:00:32,768
and you can apply it to state machines, behavior trees,

9
00:00:32,848 --> 00:00:35,671
task networks, whatever your decision making structure is.

10
00:00:36,112 --> 00:00:37,713
You can always make that more modular.

11
00:00:38,374 --> 00:00:42,338
In general, it emphasizes small, easily reused modules.

12
00:00:43,359 --> 00:00:47,042
And if you do a good job, if you have a nice modular architecture,

13
00:00:47,322 --> 00:00:50,025
it can be absolutely transformative to your development process.

14
00:00:50,806 --> 00:00:54,709
It can allow you to do things like fast prototyping, rapid iteration,

15
00:00:54,769 --> 00:00:56,951
it's even going to increase the stability of your code base.

16
00:00:57,472 --> 00:01:01,075
So, the nuts and bolts, what we're going to talk about today in this session.

17
00:01:01,876 --> 00:01:04,778
First off, we're going to go through some of the academic underpinnings.

18
00:01:05,139 --> 00:01:08,522
So, we're going to present some of the theory and talk about how this stuff works.

19
00:01:09,362 --> 00:01:13,085
Next, Kevin's going to come up and give some real specific

20
00:01:13,145 --> 00:01:16,668
implementation details, code samples, and really explain

21
00:01:17,068 --> 00:01:17,949
what this looks like.

22
00:01:18,710 --> 00:01:21,172
And finally, Troy Humphreys is going to come up and give an

23
00:01:21,192 --> 00:01:24,675
example from a ship game and show what this looks like in

24
00:01:24,755 --> 00:01:26,196
practice, along with some general

25
00:01:26,256 --> 00:01:27,257
architecture discussion.

26
00:01:27,717 --> 00:01:29,498
So this is going to be a bit of a slow burn.

27
00:01:29,518 --> 00:01:32,000
But by the time we get going, hopefully we've lit a nice

28
00:01:32,060 --> 00:01:34,542
fire, and you're all going to be encouraged to go out and

29
00:01:34,622 --> 00:01:36,484
try to make your own architectures a

30
00:01:36,524 --> 00:01:37,305
little more modular.

31
00:01:39,097 --> 00:01:41,102
So, my name's Christopher Draggart.

32
00:01:41,182 --> 00:01:43,146
I'm an AI programmer at Ubisoft Toronto.

33
00:01:44,720 --> 00:01:50,684
My background, I'm actually sort of a software engineer by training, and it has a lot to

34
00:01:50,784 --> 00:01:53,286
say as a field about modular reuse.

35
00:01:53,306 --> 00:01:56,148
This is something that people have been looking at for 20 years.

36
00:01:56,188 --> 00:01:59,110
There's lots of theories, there's lots of stuff in there.

37
00:01:59,531 --> 00:02:04,434
What we want to do, and in fact what I did during my own PhD research, I took a lot of

38
00:02:04,474 --> 00:02:09,658
those sort of basic software engineering principles, and I applied them to modular AI in particular.

39
00:02:10,699 --> 00:02:21,944
What I want to do in my portion of this session is really show how these first principles can allow you to develop techniques and create a good modularization for your own project.

40
00:02:22,345 --> 00:02:32,209
In fact, I'd like you to be able to think deeply about this topic so that when you're making choices about how to modularize things, you can be working right from first principles and really understand the choices that you're making.

41
00:02:33,570 --> 00:02:34,751
One of the biggest things here...

42
00:02:35,979 --> 00:02:39,020
is understanding modular complexity itself, right?

43
00:02:39,401 --> 00:02:40,281
Where does it come from?

44
00:02:40,461 --> 00:02:42,082
What becomes harder and easier when you're

45
00:02:42,102 --> 00:02:43,203
doing modular approaches?

46
00:02:43,583 --> 00:02:46,445
And importantly, how to manage that and how to reduce it,

47
00:02:46,485 --> 00:02:48,486
because that's what's going to make your modularization

48
00:02:48,526 --> 00:02:49,006
successful.

49
00:02:49,907 --> 00:02:52,788
So let's talk in general about complexity.

50
00:02:53,909 --> 00:02:55,990
This sort of breaks down into two main areas.

51
00:02:56,050 --> 00:02:58,191
The first is essential complexity.

52
00:02:58,652 --> 00:03:01,353
So this is the problem that you're trying to solve.

53
00:03:01,393 --> 00:03:02,614
This is what you're looking at.

54
00:03:02,634 --> 00:03:03,534
This is what you want to do.

55
00:03:05,536 --> 00:03:08,879
The other kind of complexity is accidental complexity.

56
00:03:09,160 --> 00:03:11,042
These are problems created by us, right?

57
00:03:11,082 --> 00:03:13,584
When we say, oh, I want to put this in a special framework

58
00:03:13,624 --> 00:03:15,186
and run it on another thread and do this and that.

59
00:03:15,426 --> 00:03:17,108
You know, all those problems are aside

60
00:03:17,168 --> 00:03:19,511
from the core thing that you want to solve.

61
00:03:19,971 --> 00:03:22,374
So a good solution is going to preserve

62
00:03:22,414 --> 00:03:24,456
that essential complexity and make it

63
00:03:24,476 --> 00:03:25,557
so you're just working on that

64
00:03:25,677 --> 00:03:27,759
and it's going to limit the growth of accidental.

65
00:03:28,734 --> 00:03:30,336
So, let's make this more specific now.

66
00:03:30,356 --> 00:03:31,497
Let's get to the topic at hand.

67
00:03:32,258 --> 00:03:33,899
What drives modular complexity?

68
00:03:35,521 --> 00:03:37,963
First big driver is the module itself.

69
00:03:38,564 --> 00:03:41,927
So, the more complex your module is,

70
00:03:42,608 --> 00:03:44,850
the more complex your modular solution is gonna be.

71
00:03:46,312 --> 00:03:49,514
The interface, what do these modules look like from the outside?

72
00:03:50,274 --> 00:03:51,695
How do we work with these?

73
00:03:51,735 --> 00:03:52,536
How do we understand them?

74
00:03:53,056 --> 00:03:57,279
And finally, what's the process for taking these modules and piecing them together?

75
00:03:57,319 --> 00:03:58,159
How complex is that?

76
00:03:59,180 --> 00:04:02,963
So for the remainder of my talk, I'm going to go through each of those three areas and

77
00:04:03,023 --> 00:04:07,265
just talk about how complexity grows at each level and how we can manage it.

78
00:04:08,646 --> 00:04:10,147
So the first area, the module.

79
00:04:10,668 --> 00:04:14,530
And if there's one thing to take away from my portion, I want it to be this.

80
00:04:15,913 --> 00:04:18,455
Good modules do not try to do too much.

81
00:04:19,235 --> 00:04:21,136
The key to a good modular solution

82
00:04:21,216 --> 00:04:23,617
is to have small, concise modules.

83
00:04:24,237 --> 00:04:26,198
One of the biggest reasons is that a small module

84
00:04:26,539 --> 00:04:28,740
allows you to more easily understand what's going on.

85
00:04:29,060 --> 00:04:30,180
It has a clear purpose.

86
00:04:30,240 --> 00:04:33,482
If you go to reuse it, you can be very clear in understanding

87
00:04:33,642 --> 00:04:34,742
this is what I'm reusing.

88
00:04:34,783 --> 00:04:36,203
This is the functionality I'm getting.

89
00:04:36,483 --> 00:04:37,804
So you want a good small module.

90
00:04:39,405 --> 00:04:44,710
One of the big ways to accomplish this is by limiting the scope of what you try to accomplish within a module.

91
00:04:45,270 --> 00:04:49,874
So, one thing you want to do is try to separate cross-cutting concerns.

92
00:04:50,295 --> 00:04:52,917
So that's a term from aspect-oriented programming.

93
00:04:53,297 --> 00:04:56,680
And the idea is that there might be a functionality that gets repeated.

94
00:04:57,280 --> 00:04:58,921
across a whole bunch of modules, right?

95
00:04:59,402 --> 00:05:02,824
So, an example, let's say we have a melee combat module

96
00:05:02,864 --> 00:05:05,705
that selects a target, and then our range combat module

97
00:05:05,746 --> 00:05:07,887
is also selecting a target, and our flee module

98
00:05:07,907 --> 00:05:10,308
is deciding what target it wants to flee from, right?

99
00:05:10,608 --> 00:05:12,810
The answer here should be pretty clear.

100
00:05:12,890 --> 00:05:16,092
We need to take out that target selection

101
00:05:16,912 --> 00:05:18,533
and actually put it in its own module, right?

102
00:05:18,573 --> 00:05:20,253
So we need a target selection module.

103
00:05:20,493 --> 00:05:22,754
So we separate those sort of functional concerns.

104
00:05:22,834 --> 00:05:24,334
Target selection is its own thing.

105
00:05:24,874 --> 00:05:27,255
Melee combat is its own thing that just attacks

106
00:05:27,295 --> 00:05:28,315
whatever target it's given.

107
00:05:28,615 --> 00:05:30,416
And we make all these modules sort of work

108
00:05:30,536 --> 00:05:34,037
from communicating with that other target selection module.

109
00:05:34,357 --> 00:05:36,398
What's great now is that when you do something like that,

110
00:05:36,858 --> 00:05:37,838
you can then say, you know what?

111
00:05:37,918 --> 00:05:40,279
I want to reuse just the target selection module.

112
00:05:40,299 --> 00:05:41,679
And you have that clean separation.

113
00:05:44,055 --> 00:05:46,716
Another thing you want to do is control the size of your module.

114
00:05:46,756 --> 00:05:48,557
So this is just a more general comment.

115
00:05:49,697 --> 00:05:53,579
Here, we need to do the stuff that we already do as AI programmers.

116
00:05:54,199 --> 00:05:57,161
So traditional abstraction techniques, everything

117
00:05:57,181 --> 00:05:58,341
that we should already know and love.

118
00:05:58,701 --> 00:06:00,402
If you're working with a state machine, for instance,

119
00:06:00,442 --> 00:06:01,983
you want to use hierarchical approaches.

120
00:06:02,343 --> 00:06:04,204
If you have a lot of events going through your system,

121
00:06:04,224 --> 00:06:06,765
you want subsumption, maybe you want layering approaches

122
00:06:06,805 --> 00:06:08,246
to help manage your different modules.

123
00:06:08,826 --> 00:06:12,094
If you're working with behavior trees, use parallelism where appropriate.

124
00:06:12,334 --> 00:06:15,903
You know, all these kind of things that we do, it becomes doubly important in modular

125
00:06:15,943 --> 00:06:17,707
approaches so that we can control the size.

126
00:06:19,249 --> 00:06:22,371
One thing that we don't think about as much as AI programmers

127
00:06:23,031 --> 00:06:24,572
is a well-defined semantics.

128
00:06:25,133 --> 00:06:26,294
So what do I mean by this?

129
00:06:26,714 --> 00:06:28,895
Well, your AI logic should operate

130
00:06:28,935 --> 00:06:31,637
in an understandable and well-defined fashion.

131
00:06:31,998 --> 00:06:33,198
Normally, when we program things,

132
00:06:33,238 --> 00:06:36,341
we can often think about, how is this piece supposed to work?

133
00:06:36,421 --> 00:06:38,122
How does it fit into the rest of my AI?

134
00:06:38,442 --> 00:06:40,664
We can kind of solve that problem, and it works.

135
00:06:40,744 --> 00:06:43,166
But if you can't communicate that,

136
00:06:44,184 --> 00:06:46,045
then you're going to fall apart at the next step,

137
00:06:46,085 --> 00:06:48,407
which is maybe moving that module between engines

138
00:06:48,468 --> 00:06:49,989
or moving it to a different game.

139
00:06:50,389 --> 00:06:52,351
And I'll give an example that really clarifies this.

140
00:06:53,432 --> 00:06:56,915
So let's say we have a super simple state machine.

141
00:06:58,237 --> 00:06:59,438
We have a combat state.

142
00:06:59,458 --> 00:07:00,559
It receives a flea event.

143
00:07:00,599 --> 00:07:02,240
We transition over to the flea behavior.

144
00:07:02,941 --> 00:07:04,242
OK, now let's add some hierarchy.

145
00:07:05,537 --> 00:07:10,522
Now, in the combat state, you can see I've added this fire sub-state, and it actually

146
00:07:10,563 --> 00:07:12,665
has a transition on the flee event as well.

147
00:07:13,246 --> 00:07:17,210
So if we're in that flee state, or sorry, if we're in that fire state and we flee...

148
00:07:18,519 --> 00:07:19,019
What do we do?

149
00:07:19,699 --> 00:07:21,760
Right, your implementation is gonna make some choice.

150
00:07:21,800 --> 00:07:24,102
Do I follow the inner transition or the outer one?

151
00:07:24,402 --> 00:07:25,863
I'm not here to talk about the right way

152
00:07:25,903 --> 00:07:26,683
to do state machines.

153
00:07:27,063 --> 00:07:29,645
The important thing is that when you go to reuse this,

154
00:07:30,405 --> 00:07:32,727
wherever you put this, we have to make the same choice,

155
00:07:32,787 --> 00:07:32,987
right?

156
00:07:33,327 --> 00:07:34,668
Our new context, our new engine,

157
00:07:34,688 --> 00:07:35,888
it has to make the same choice.

158
00:07:35,928 --> 00:07:38,610
So we have to communicate what are,

159
00:07:38,970 --> 00:07:41,131
exactly how these things work, what our semantics are.

160
00:07:42,212 --> 00:07:46,898
This example also applies to custom decorator nodes and behavior trees.

161
00:07:46,958 --> 00:07:51,763
If we want to reuse those, we need to make sure that they're functioned correctly in the new context.

162
00:07:52,344 --> 00:07:55,728
So, moving on, I'm going to talk about the modular interface now.

163
00:07:57,670 --> 00:07:58,211
What does it do?

164
00:07:59,952 --> 00:08:03,094
It should communicate the context for the module,

165
00:08:03,454 --> 00:08:05,255
so the expectation of that module,

166
00:08:05,315 --> 00:08:07,916
what is it trying to get from the rest of the AI,

167
00:08:08,256 --> 00:08:09,877
what is it providing to the AI,

168
00:08:10,217 --> 00:08:12,238
we should be able to understand that from the interface.

169
00:08:12,538 --> 00:08:15,359
If you've done a good job making small, concise modules,

170
00:08:15,759 --> 00:08:18,400
then we should have a clear, easy to understand interface.

171
00:08:19,970 --> 00:08:23,673
The big step here is that we're raising the level of abstraction now.

172
00:08:23,873 --> 00:08:25,895
When we have a good interface and we can work from it,

173
00:08:25,975 --> 00:08:29,258
we don't have to worry about how exactly that module operates anymore.

174
00:08:29,678 --> 00:08:32,421
You can just work directly at that interface level,

175
00:08:32,441 --> 00:08:36,204
which means you can focus on the essential problem of connecting our modules

176
00:08:36,584 --> 00:08:40,608
and not worry about sort of all the accidental stuff of how that behavior works.

177
00:08:41,409 --> 00:08:43,010
So, I've said context a lot.

178
00:08:43,731 --> 00:08:44,451
What do I mean by that?

179
00:08:46,500 --> 00:08:49,141
State machines, for instance, they're an event-based formalism.

180
00:08:50,022 --> 00:08:51,462
I'm just going to work through this example here.

181
00:08:53,904 --> 00:08:56,985
Generally, you tend to think about input events.

182
00:08:57,045 --> 00:08:59,307
They might be generated by other parts of the system.

183
00:08:59,747 --> 00:09:01,708
They would get consumed by our module.

184
00:09:01,728 --> 00:09:04,950
They might also generate output events that would go to other parts of the system.

185
00:09:05,290 --> 00:09:09,752
So then, our interface should tell us what exactly this module is expecting.

186
00:09:10,172 --> 00:09:11,373
So I'm just going to build one out here.

187
00:09:11,413 --> 00:09:14,695
This is for an enemy position tracker module.

188
00:09:15,875 --> 00:09:17,356
We might want to include some metadata.

189
00:09:17,836 --> 00:09:19,596
So a description of the module.

190
00:09:20,096 --> 00:09:22,557
This module is parameterized.

191
00:09:23,037 --> 00:09:25,338
I can control the type of the enemy entity

192
00:09:25,398 --> 00:09:26,178
that I want to track.

193
00:09:27,018 --> 00:09:27,478
And that's about it.

194
00:09:27,518 --> 00:09:29,238
We don't really need to worry about the functionality.

195
00:09:29,819 --> 00:09:31,819
Now, as input, it's going to be looking

196
00:09:31,879 --> 00:09:33,179
for a couple specific events.

197
00:09:33,259 --> 00:09:35,200
The first would be an enemy spotted event.

198
00:09:35,240 --> 00:09:36,600
The second would be an enemy lost.

199
00:09:36,940 --> 00:09:39,101
So basically, this is telling it when to start and stop tracking.

200
00:09:39,681 --> 00:09:41,401
We don't really need to worry about what

201
00:09:41,461 --> 00:09:43,562
it's doing to sort of maintain its own list.

202
00:09:43,622 --> 00:09:45,022
That functionality, it doesn't really matter.

203
00:09:45,562 --> 00:09:47,543
Those events are going to come from some other part

204
00:09:47,583 --> 00:09:49,103
of the system, and we'll be able to use them.

205
00:09:50,844 --> 00:09:53,785
Now, as output, we can then generate this enemy position

206
00:09:53,825 --> 00:09:54,365
changed event.

207
00:09:54,665 --> 00:09:56,626
So maybe you have a cover module, for instance.

208
00:09:56,666 --> 00:09:58,486
It receives this, and it decides whether or not

209
00:09:58,506 --> 00:10:00,207
it needs to re-evaluate cover.

210
00:10:00,907 --> 00:10:03,528
So now we can see how we would take this position tracker

211
00:10:03,548 --> 00:10:05,589
and sort of situate it within a context.

212
00:10:07,269 --> 00:10:09,430
Moving on, a second example here, behavior trees.

213
00:10:09,970 --> 00:10:12,191
So these are a bit different in that they're primarily

214
00:10:12,271 --> 00:10:12,851
data-driven.

215
00:10:16,180 --> 00:10:19,742
What we want to think about here is sort of how our nodes are

216
00:10:19,782 --> 00:10:22,163
communicating with the rest of the behavior tree,

217
00:10:22,183 --> 00:10:23,624
or the rest of your AI architecture.

218
00:10:24,145 --> 00:10:26,826
Well, primarily, they're going to be reading input

219
00:10:27,046 --> 00:10:30,428
off the blackboard to understand the context,

220
00:10:30,869 --> 00:10:32,870
and they're going to be writing output to that blackboard.

221
00:10:33,190 --> 00:10:35,411
So when you think about building an interface here,

222
00:10:35,471 --> 00:10:36,592
we want to capture that data.

223
00:10:36,992 --> 00:10:40,434
But a specific warning, that's not the full story

224
00:10:40,554 --> 00:10:41,675
for behavior trees.

225
00:10:42,976 --> 00:10:45,437
The reason is that there can be a lot of different things going on,

226
00:10:45,997 --> 00:10:48,959
especially in newer behavior trees, where we can have nodes that,

227
00:10:49,579 --> 00:10:53,681
instead of just returning success or failure, they can also run over multiple frames.

228
00:10:54,182 --> 00:10:57,183
Well, the question there becomes, how do we interrupt it?

229
00:10:57,743 --> 00:10:59,624
Where does that interruption come from?

230
00:11:00,785 --> 00:11:04,267
In other situations, you can even have the tree structure itself,

231
00:11:04,327 --> 00:11:05,728
which is providing this interruption.

232
00:11:06,048 --> 00:11:07,669
So somehow we have to deal with this.

233
00:11:08,709 --> 00:11:09,530
I'm going to give an example.

234
00:11:09,570 --> 00:11:11,931
This is something that I've seen in production code.

235
00:11:12,951 --> 00:11:14,972
We have a parallel branch here.

236
00:11:15,632 --> 00:11:17,433
It goes to the top there, and we get

237
00:11:17,453 --> 00:11:19,514
an infinitely repeating decorator.

238
00:11:19,794 --> 00:11:21,174
This is just checking a conditional.

239
00:11:22,075 --> 00:11:23,575
When that conditional becomes false,

240
00:11:23,856 --> 00:11:25,096
this branch is going to fail out,

241
00:11:25,196 --> 00:11:26,877
and we're going to move on to do something else.

242
00:11:27,657 --> 00:11:30,298
But at the same time, we also have another infinitely

243
00:11:30,358 --> 00:11:32,099
repeating decorator, and it's going

244
00:11:32,119 --> 00:11:33,420
to be going through and performing

245
00:11:33,480 --> 00:11:34,860
some behavior at the bottom.

246
00:11:35,783 --> 00:11:37,804
Now, say I really want that behavior at the bottom.

247
00:11:37,824 --> 00:11:38,584
I want to reuse that.

248
00:11:38,605 --> 00:11:39,565
I want to put it somewhere else.

249
00:11:40,085 --> 00:11:42,786
So then I trim that and move it away.

250
00:11:43,266 --> 00:11:45,247
Well, what's going to happen is that I'm

251
00:11:45,267 --> 00:11:47,148
going to introduce a huge bug into my new system

252
00:11:47,648 --> 00:11:49,769
because that bottom branch, it doesn't

253
00:11:49,889 --> 00:11:51,109
know how to stop itself.

254
00:11:51,149 --> 00:11:52,510
That was happening in the top branch.

255
00:11:52,990 --> 00:11:56,172
Right, so I have this sort of functionality that's now split

256
00:11:56,232 --> 00:11:58,373
and there's a dependence between these two branches.

257
00:11:58,773 --> 00:12:00,294
If I want to get that to work correctly,

258
00:12:00,635 --> 00:12:02,156
I'm going to need to reuse the whole thing, right?

259
00:12:02,196 --> 00:12:04,037
I need to include that stop case.

260
00:12:04,557 --> 00:12:05,938
So these are the kind of things that you

261
00:12:05,958 --> 00:12:07,939
need to look out for when you're specifically

262
00:12:07,999 --> 00:12:09,220
trying to use behavior trees.

263
00:12:11,241 --> 00:12:14,564
So I'm going to move on to the third and final area, which

264
00:12:14,584 --> 00:12:16,004
is just an overview of integration.

265
00:12:16,044 --> 00:12:18,586
So this is the process that we actually use

266
00:12:18,626 --> 00:12:19,947
to fit these modules together.

267
00:12:21,005 --> 00:12:24,590
If you've done a good job in creating concise modules,

268
00:12:24,770 --> 00:12:26,892
clear interfaces, then integration

269
00:12:26,932 --> 00:12:27,954
should be straightforward, right?

270
00:12:29,015 --> 00:12:32,399
If you've made mistakes, if you have big, complicated modules,

271
00:12:32,799 --> 00:12:33,961
this part's going to be really hard.

272
00:12:34,461 --> 00:12:37,365
So a lot of your errors are going to become apparent here.

273
00:12:38,126 --> 00:12:39,648
Essentially, what we're trying to do

274
00:12:40,589 --> 00:12:43,691
is connect the output from one module to the input in another.

275
00:12:43,971 --> 00:12:46,472
Right? It's a fairly straightforward thing.

276
00:12:46,893 --> 00:12:49,294
And we should be able to focus explicitly on that.

277
00:12:49,434 --> 00:12:51,636
Everything else is accidental complexity.

278
00:12:52,056 --> 00:12:55,598
So you really want to try and limit anything that detracts from that core problem.

279
00:12:57,737 --> 00:13:05,124
The complexity of this, we can manage it a lot by making sure that module connections are derivable solely from the interface.

280
00:13:05,444 --> 00:13:08,387
So, as programmers, we need to treat this almost like an API, right?

281
00:13:09,108 --> 00:13:13,412
And, in fact, the other thing this does is that this preserves modular encapsulation.

282
00:13:13,452 --> 00:13:15,414
This is just like object-oriented programming now.

283
00:13:15,834 --> 00:13:18,960
where we want to make sure we're working through our high level interface

284
00:13:19,180 --> 00:13:21,704
and we're not creating spaghetti code and digging inside.

285
00:13:22,005 --> 00:13:24,208
So for all the same reasons that, you know,

286
00:13:24,629 --> 00:13:26,252
encapsulation is good in normal code,

287
00:13:26,512 --> 00:13:29,076
it's just as good in modular AI.

288
00:13:30,291 --> 00:13:32,472
So if you do this consistently and if you do it well,

289
00:13:32,513 --> 00:13:34,094
you can start to add tool support, right?

290
00:13:34,534 --> 00:13:35,895
And this can tell you things like,

291
00:13:36,315 --> 00:13:37,936
I have an output from one module

292
00:13:37,956 --> 00:13:39,137
that's not consumed anywhere.

293
00:13:39,477 --> 00:13:41,038
Or I have this data that I'm trying to read

294
00:13:41,078 --> 00:13:42,619
off the blackboard that no one else writes.

295
00:13:42,860 --> 00:13:44,040
You can start to see those errors

296
00:13:44,140 --> 00:13:45,441
really quickly and really easily.

297
00:13:45,942 --> 00:13:47,002
And then that will teach you,

298
00:13:47,022 --> 00:13:48,483
okay, I need to add this module

299
00:13:48,523 --> 00:13:50,325
or I need to have something contributing that data.

300
00:13:52,786 --> 00:13:54,408
One last thing I want to talk about here

301
00:13:54,528 --> 00:13:55,608
is module coupling.

302
00:13:57,350 --> 00:13:58,110
The goal here,

303
00:13:59,255 --> 00:14:01,356
is to create loosely coupled modules.

304
00:14:01,857 --> 00:14:05,159
So these are, when you have a loosely coupled system,

305
00:14:05,539 --> 00:14:09,021
a missing module impairs only that behavior.

306
00:14:10,355 --> 00:14:11,235
What do I mean by that?

307
00:14:11,355 --> 00:14:13,878
Well, if you think about our target selection example

308
00:14:14,098 --> 00:14:15,959
earlier where we had our Melee module,

309
00:14:15,979 --> 00:14:18,862
let's say we take that target selection module

310
00:14:19,022 --> 00:14:19,682
and we pull it out.

311
00:14:20,063 --> 00:14:22,284
So there's now nothing in your AI that selects targets.

312
00:14:22,645 --> 00:14:24,927
Well, I would want my Melee module just to say,

313
00:14:25,027 --> 00:14:26,688
oh, I don't have a target, I'm not gonna do anything.

314
00:14:27,248 --> 00:14:29,490
But other functionality within that AI,

315
00:14:29,570 --> 00:14:30,931
so a wander behavior,

316
00:14:31,132 --> 00:14:32,613
interacting with environmental objects,

317
00:14:32,973 --> 00:14:34,695
all of that should still be able to happen, right?

318
00:14:36,545 --> 00:14:41,730
If you have this approach, then you can really quickly and easily start to add modules to

319
00:14:41,750 --> 00:14:42,791
do fast prototyping.

320
00:14:42,832 --> 00:14:45,474
You can change your composition to rapidly iterate on this.

321
00:14:46,671 --> 00:14:49,433
The alternative is a tightly coupled module.

322
00:14:49,853 --> 00:14:52,515
So this is where maybe one module is actually

323
00:14:52,595 --> 00:14:54,696
calling a function that's written in another one.

324
00:14:54,977 --> 00:14:56,297
If you pull one module out, you're

325
00:14:56,317 --> 00:14:57,778
going to have a compilation failure.

326
00:14:58,339 --> 00:15:01,221
Maybe we have our Mealy module with no target.

327
00:15:01,341 --> 00:15:03,302
It still tries to run, and it crashes.

328
00:15:03,342 --> 00:15:04,042
These kind of things.

329
00:15:04,623 --> 00:15:05,163
You don't want that.

330
00:15:05,203 --> 00:15:06,664
That's what you need to try to avoid.

331
00:15:06,724 --> 00:15:08,625
Everything should be as loosely coupled as possible.

332
00:15:09,186 --> 00:15:10,907
When you have problems like this, a lot of times,

333
00:15:10,987 --> 00:15:13,188
it's caused by broken encapsulation,

334
00:15:13,268 --> 00:15:14,809
or you're not working through the interface.

335
00:15:15,630 --> 00:15:18,331
Or you could have a modular concern,

336
00:15:18,391 --> 00:15:19,952
some kind of functionality that's spread

337
00:15:19,972 --> 00:15:21,232
across multiple modules.

338
00:15:22,913 --> 00:15:25,434
Special cases in general are really dangerous.

339
00:15:26,334 --> 00:15:28,775
I'm just going to go through one straightforward example here.

340
00:15:28,955 --> 00:15:30,276
Let's say we have a sensor module.

341
00:15:30,636 --> 00:15:33,117
And every time our AI spots a new enemy,

342
00:15:33,437 --> 00:15:34,878
it creates this new enemy spotted event.

343
00:15:36,199 --> 00:15:37,539
And then we have a reaction module.

344
00:15:37,699 --> 00:15:39,200
And every time it receives that event,

345
00:15:39,260 --> 00:15:40,280
it's going to play an animation.

346
00:15:40,300 --> 00:15:41,221
It's going to play some reaction.

347
00:15:42,549 --> 00:15:46,671
But we actually run this and we find, oh wait, I'm seeing that reaction way, way, way too often.

348
00:15:47,051 --> 00:15:47,871
I need to turn that down.

349
00:15:48,391 --> 00:15:49,912
So I want to add some hysteresis.

350
00:15:50,132 --> 00:15:51,832
I'm going to make my event system.

351
00:15:51,893 --> 00:15:53,113
All the events are going through there.

352
00:15:53,173 --> 00:15:54,213
So I'm just going to add a filter.

353
00:15:54,573 --> 00:15:56,994
It's going to cap generation of these new enemy spotted events.

354
00:15:57,454 --> 00:15:58,335
No more than one per minute.

355
00:15:58,695 --> 00:15:59,695
So now everything looks good.

356
00:16:00,275 --> 00:16:01,196
But then I go to reuse it.

357
00:16:01,416 --> 00:16:04,617
And I put my sensor and my reaction module in a new context.

358
00:16:05,297 --> 00:16:08,680
and that same bug is going to appear again right because I lost that filtering bit

359
00:16:09,221 --> 00:16:13,625
and there's no obvious way about how this should work right I don't have a filtering module

360
00:16:13,945 --> 00:16:18,169
I haven't created a filtered reaction or anything like that so these kind of things

361
00:16:18,670 --> 00:16:22,393
they're kind of dangerous a lot of times they're because of broken module encapsulation here it's

362
00:16:22,433 --> 00:16:27,358
a functionality that's mixed across a few things but let's say we do all this right

363
00:16:28,947 --> 00:16:30,027
we're going to get a nice payoff.

364
00:16:30,487 --> 00:16:32,168
The first is fast prototyping, right?

365
00:16:32,208 --> 00:16:34,269
We can now quickly and easily add our modules.

366
00:16:35,250 --> 00:16:36,130
We can fine tune.

367
00:16:36,830 --> 00:16:39,412
We can parameterize these module interfaces

368
00:16:40,652 --> 00:16:43,554
so that we can say this specific module and this AI

369
00:16:43,714 --> 00:16:46,135
is going to have this set of parameters,

370
00:16:46,175 --> 00:16:47,515
and this other one is going to be slightly different.

371
00:16:47,776 --> 00:16:50,977
So we don't lose that ability to polish our AI.

372
00:16:52,844 --> 00:16:57,870
And probably the biggest thing here is that the development process, overall, is going to be better, right?

373
00:16:58,190 --> 00:17:00,012
We can reuse existing behavior.

374
00:17:00,473 --> 00:17:04,878
We can get to a baseline very quickly, and that means the bulk of our development time,

375
00:17:05,199 --> 00:17:08,403
we can spend innovating, and we can spend creating new behaviors,

376
00:17:08,723 --> 00:17:11,887
so that you can really try to push the boundary of what your AI can do.

377
00:17:12,908 --> 00:17:14,110
So, I'm just going to summarize.

378
00:17:14,130 --> 00:17:16,392
A good modular approach,

379
00:17:17,133 --> 00:17:18,555
it's going to check all these boxes.

380
00:17:19,016 --> 00:17:22,660
We're going to use small modules that do a nice job separating functional concerns.

381
00:17:23,761 --> 00:17:25,684
We're going to operate with a well-defined semantic,

382
00:17:25,724 --> 00:17:28,107
so we can always understand how this thing should run.

383
00:17:29,028 --> 00:17:31,851
It has a clear interface so that people can understand how to connect it.

384
00:17:33,390 --> 00:17:36,214
All of our connections are going to respect modular encapsulation.

385
00:17:36,995 --> 00:17:41,502
And we're going to use a loose coupling approach so that we can really quickly and easily swap

386
00:17:41,542 --> 00:17:43,004
modules and swap compositions.

387
00:17:43,405 --> 00:17:47,150
So if you've done all that, if you've checked all those boxes, you're off to a great start.

388
00:17:47,691 --> 00:17:47,931
Thank you.

389
00:18:05,432 --> 00:18:06,052
All right, there we go.

390
00:18:06,072 --> 00:18:08,194
So I'm Kevin Dill.

391
00:18:09,435 --> 00:18:11,056
I wanted to start with a little bit of motivation

392
00:18:12,597 --> 00:18:14,499
from my point of view, some of what makes

393
00:18:14,539 --> 00:18:15,980
modular AI so exciting to me.

394
00:18:16,641 --> 00:18:17,922
So as I was thinking about this talk,

395
00:18:17,962 --> 00:18:19,263
and I was thinking about why it works

396
00:18:19,303 --> 00:18:20,944
and what makes it powerful, I remembered a talk

397
00:18:20,984 --> 00:18:23,787
that Chris Hacker gave back in 2008 called

398
00:18:23,827 --> 00:18:24,847
Structure Versus Style.

399
00:18:25,588 --> 00:18:29,912
And he basically made the case that a lot of problems

400
00:18:30,072 --> 00:18:30,812
that we have.

401
00:18:31,533 --> 00:18:36,515
made great progress on have this sort of structure versus style decomposition. And graphics is

402
00:18:36,615 --> 00:18:41,196
one example, where you get the texture map triangle, which is your structure, and then

403
00:18:41,236 --> 00:18:45,538
your style is all the ways you can use textures and triangles, and you get graphics, right?

404
00:18:46,254 --> 00:18:52,382
scenes and beauty and awesomeness. And as a result of this decomposition, graphics,

405
00:18:52,462 --> 00:18:58,489
he argues, has made huge bounding leaps over the last 30 years. And AI has not. So his

406
00:18:58,509 --> 00:19:02,534
suggestion was part of the reason that AI has not made these leaps is that we don't

407
00:19:02,594 --> 00:19:05,618
have a structure versus style decomposition for AI.

408
00:19:06,759 --> 00:19:08,859
So there was a lot of discussion back and forth

409
00:19:08,899 --> 00:19:09,579
in the community.

410
00:19:09,619 --> 00:19:11,180
Some people said Chris is on crack.

411
00:19:11,220 --> 00:19:12,940
Some people said Chris is brilliant,

412
00:19:12,960 --> 00:19:14,441
but I don't know what the structure versus style

413
00:19:14,481 --> 00:19:15,281
decomposition is.

414
00:19:15,961 --> 00:19:18,242
I'd like to suggest that modular AI gives us

415
00:19:18,282 --> 00:19:21,203
the opportunity to have the start of this sort of structure

416
00:19:21,223 --> 00:19:22,463
versus style decomposition.

417
00:19:23,304 --> 00:19:26,565
And I think that's why it allows us to work so much quicker,

418
00:19:26,605 --> 00:19:28,965
and hopefully will continue to progress forward for us.

419
00:19:32,154 --> 00:19:34,395
So I should also mention that everything that I talk about

420
00:19:34,555 --> 00:19:37,415
is going to be pulled out of ideas from the game AI

421
00:19:37,475 --> 00:19:38,015
architecture.

422
00:19:38,795 --> 00:19:41,236
The fact that it's game AI isn't interesting to this community,

423
00:19:41,296 --> 00:19:43,596
but I work for a military simulation company, Lockheed

424
00:19:43,616 --> 00:19:43,916
Martin.

425
00:19:44,577 --> 00:19:46,157
So that's an important distinction to them,

426
00:19:46,217 --> 00:19:49,118
as opposed to traditional, more academic kinds of AI.

427
00:19:50,538 --> 00:19:53,058
This architecture has been used across probably six

428
00:19:53,158 --> 00:19:56,399
very different projects to solve different kinds of AI

429
00:19:56,459 --> 00:19:57,139
problems, right?

430
00:19:57,179 --> 00:19:59,620
Character AI versus flight simulators versus other stuff.

431
00:20:00,182 --> 00:20:03,093
It's been integrated into a bunch of different engines at this point.

432
00:20:03,676 --> 00:20:05,041
And something important to mention is...

433
00:20:06,364 --> 00:20:10,227
I set out, of course, to create an architecture I could reuse, but I never was able to just

434
00:20:10,247 --> 00:20:11,608
sit down and build the architecture.

435
00:20:11,728 --> 00:20:11,948
Ever.

436
00:20:12,068 --> 00:20:15,831
All the work that I've done on this architecture has been done in the context of working on

437
00:20:15,871 --> 00:20:16,372
a project.

438
00:20:16,692 --> 00:20:22,917
And by just making sure that I keep my architecture decoupled from the simulation so I can carry

439
00:20:22,937 --> 00:20:26,700
it with me, or from the game so I can carry it with me from project to project, I've got

440
00:20:26,840 --> 00:20:30,062
all of this, you know, now large reusable code base that's really powerful.

441
00:20:32,200 --> 00:20:34,342
So the agenda for my portion of the talk,

442
00:20:34,362 --> 00:20:36,564
I'm going to talk about what I think modular AI is.

443
00:20:36,704 --> 00:20:38,145
Of course, Chris just gave us a bunch of that.

444
00:20:38,986 --> 00:20:41,228
I'm going to talk about some common conceptual abstractions.

445
00:20:41,388 --> 00:20:43,090
And you know what that means by the time I get there.

446
00:20:43,611 --> 00:20:46,533
I'm going to give just a brief example of a small portion

447
00:20:46,553 --> 00:20:47,474
of a sniper character.

448
00:20:48,195 --> 00:20:49,856
I'm going to give a few implementation details

449
00:20:49,997 --> 00:20:50,737
as time permits.

450
00:20:50,897 --> 00:20:52,459
And then I'll leave you with some parting thoughts.

451
00:20:53,140 --> 00:20:54,641
So the big idea behind modular.

452
00:20:56,134 --> 00:20:59,959
behind modular architectures is that I want to be working at the right level of granularity.

453
00:21:00,319 --> 00:21:04,505
I want to be using sort of bite-sized pieces. And by bite-sized, you know, Chris said, well,

454
00:21:04,525 --> 00:21:08,469
they can't be too big, and that's definitely true. If they're too big, then I can't tune

455
00:21:08,509 --> 00:21:11,833
them and customize them to the needs of the specific instance where I'm sticking them

456
00:21:11,893 --> 00:21:13,576
in. But they also can't be too small.

457
00:21:14,076 --> 00:21:16,918
and lines of C++ code are much too small.

458
00:21:17,038 --> 00:21:19,860
As I'm defining behavior, I don't want to be thinking

459
00:21:19,900 --> 00:21:21,081
about implementation details,

460
00:21:21,101 --> 00:21:22,502
about how do I get the position,

461
00:21:22,582 --> 00:21:24,924
or should I use distance or distance squared,

462
00:21:24,964 --> 00:21:25,424
that kind of stuff.

463
00:21:25,444 --> 00:21:26,745
I don't want to be worried about that

464
00:21:27,105 --> 00:21:28,306
when I'm defining behavior.

465
00:21:28,446 --> 00:21:29,987
That's just as distracting.

466
00:21:31,944 --> 00:21:35,806
Each piece that I plug in should ideally be sort of a single human concept.

467
00:21:35,826 --> 00:21:38,467
So something like, how far away is he?

468
00:21:38,908 --> 00:21:40,268
How long have I been doing this?

469
00:21:40,689 --> 00:21:43,350
Or do I have any grenades left?

470
00:21:43,630 --> 00:21:45,952
But it doesn't have to be just the decision making part.

471
00:21:45,972 --> 00:21:47,092
It could also be the actions.

472
00:21:47,112 --> 00:21:48,113
I want to move over there.

473
00:21:48,633 --> 00:21:49,714
I want to shoot at that guy.

474
00:21:50,234 --> 00:21:50,935
That kind of stuff.

475
00:21:53,335 --> 00:21:54,776
So to get these bite-sized pieces,

476
00:21:54,836 --> 00:21:57,297
we start with what I've been calling conceptual abstractions.

477
00:21:58,858 --> 00:22:02,200
Conceptual abstractions are the different types of pieces

478
00:22:02,240 --> 00:22:03,301
that we might plug together.

479
00:22:03,381 --> 00:22:07,384
So for example, a consideration is one conceptual abstraction.

480
00:22:07,424 --> 00:22:09,945
Considerations evaluate some aspect of the situation,

481
00:22:10,305 --> 00:22:12,227
and then I combine the considerations together

482
00:22:12,287 --> 00:22:13,287
to get an overall decision.

483
00:22:13,808 --> 00:22:15,849
Actions are a different conceptual abstraction.

484
00:22:16,249 --> 00:22:17,650
Actions are the things that I'm going

485
00:22:17,670 --> 00:22:20,212
to do as a result of some decision that I've made.

486
00:22:21,239 --> 00:22:22,820
Once I've got my conceptual abstractions,

487
00:22:22,860 --> 00:22:24,602
then I start to build modular components.

488
00:22:24,983 --> 00:22:27,286
These are implementations of the different abstractions.

489
00:22:27,326 --> 00:22:29,488
So a distance consideration measures the distance

490
00:22:29,528 --> 00:22:32,552
between two points and gives some evaluation of that.

491
00:22:32,692 --> 00:22:35,395
A move action handles moving from one position to,

492
00:22:35,715 --> 00:22:37,918
or moving to some specific distant position.

493
00:22:39,930 --> 00:22:42,853
Another thing just to keep in mind is, no surprise,

494
00:22:42,893 --> 00:22:43,834
this is data driven.

495
00:22:43,854 --> 00:22:46,257
So my implementation is all the C++ side.

496
00:22:46,958 --> 00:22:48,660
And then I've got a configuration,

497
00:22:49,060 --> 00:22:51,723
which I'll often call my behavior specification, where

498
00:22:51,763 --> 00:22:54,727
I'm defining the behavior for a particular character.

499
00:22:54,747 --> 00:22:57,550
And I'm plugging in these modular components

500
00:22:57,670 --> 00:23:00,473
to create decision-making algorithms.

501
00:23:03,633 --> 00:23:05,774
So running through a few common conceptual abstractions,

502
00:23:05,834 --> 00:23:07,415
the first one to talk about is the reasoner.

503
00:23:07,515 --> 00:23:09,796
The reasoner is the big thing that makes decisions.

504
00:23:10,636 --> 00:23:13,918
So it could be any decision-making architecture

505
00:23:13,938 --> 00:23:14,398
that you want.

506
00:23:14,418 --> 00:23:15,458
It could be utility-based.

507
00:23:15,498 --> 00:23:16,419
It could be rule-based.

508
00:23:16,479 --> 00:23:18,620
It could be a finite state machine.

509
00:23:18,960 --> 00:23:20,821
It could just be a sequence of actions

510
00:23:20,861 --> 00:23:22,502
that are always run in the same order,

511
00:23:22,522 --> 00:23:24,383
no matter, you know, no considerations are used,

512
00:23:24,783 --> 00:23:27,004
right, if you want some scripted behavior or something like that.

513
00:23:27,824 --> 00:23:30,925
And different reasoners make sense in different places,

514
00:23:31,045 --> 00:23:31,246
right?

515
00:23:31,626 --> 00:23:35,587
Even if I am doing fighting AI in a shooting game,

516
00:23:36,207 --> 00:23:40,149
I might still have some sequences where I aim, fire,

517
00:23:40,429 --> 00:23:41,209
aim, fire, right?

518
00:23:41,249 --> 00:23:42,170
That's just a sequence.

519
00:23:42,190 --> 00:23:43,690
I don't need to make any decisions in there.

520
00:23:43,710 --> 00:23:46,451
So I'm going to stick in a sequence reasoner

521
00:23:46,471 --> 00:23:47,592
just to do that one little bit.

522
00:23:49,702 --> 00:23:51,582
Considerations evaluate a single aspect

523
00:23:51,622 --> 00:23:52,582
of the current situation.

524
00:23:52,642 --> 00:23:54,043
Again, there are lots of different kinds

525
00:23:54,103 --> 00:23:55,003
of considerations, right?

526
00:23:55,023 --> 00:23:56,083
A distance consideration.

527
00:23:56,483 --> 00:23:58,063
An execution history consideration

528
00:23:58,103 --> 00:23:59,784
looks at how long I've been doing something

529
00:23:59,824 --> 00:24:01,104
or how long since I last did it.

530
00:24:01,864 --> 00:24:04,165
The picker is a particularly interesting consideration.

531
00:24:04,505 --> 00:24:06,605
It goes through all of the entities that I know about,

532
00:24:07,005 --> 00:24:09,006
and it can apply some filters, or it can actually

533
00:24:09,166 --> 00:24:13,427
use a reasoner internally to pick among all of the entities.

534
00:24:13,467 --> 00:24:15,427
So for instance, if I want to pick a target to shoot at,

535
00:24:16,027 --> 00:24:21,251
I could have a picker consideration that picks a target based on how far away it is, how

536
00:24:21,291 --> 00:24:25,653
much cover it has, has it been marked as an officer, because if I'm a sniper I prefer

537
00:24:25,673 --> 00:24:29,476
to shoot at officers, is it firing at me, is it looking at me, whatever else I want

538
00:24:29,496 --> 00:24:34,579
to put into that decision I put inside the picker and then the picker just handles picking

539
00:24:34,619 --> 00:24:38,842
the one entity and scoring based on whether it finds something or not and it also by the

540
00:24:38,882 --> 00:24:42,184
way writes that entity on the blackboard so that I can reuse it when I want to shoot at

541
00:24:42,224 --> 00:24:44,405
it or chase it or run away from it or whatever I'm going to do.

542
00:24:47,244 --> 00:24:49,586
Actions are the things that I'm actually going to do once

543
00:24:49,646 --> 00:24:50,586
an option gets selected.

544
00:24:50,987 --> 00:24:52,788
So things like moving or firing a weapon.

545
00:24:53,168 --> 00:24:55,590
Again, an interesting action is the sub-reasoner action.

546
00:24:56,210 --> 00:24:58,352
The sub-reasoner action contains another reasoner.

547
00:24:58,392 --> 00:25:00,013
So this is how I get my hierarchy, right?

548
00:25:00,313 --> 00:25:02,074
I have a high-level decision that picks,

549
00:25:03,035 --> 00:25:06,838
I want to shoot at enemies, and then a lower-level reasoner

550
00:25:06,958 --> 00:25:10,360
inside of there that handles the aim-fire aspects, perhaps.

551
00:25:12,595 --> 00:25:15,496
Targets are how I specify positions or entities.

552
00:25:15,716 --> 00:25:18,737
I need to use those two things all over the place, right?

553
00:25:19,057 --> 00:25:21,158
A distance consideration measures the distance

554
00:25:21,198 --> 00:25:22,018
between two targets.

555
00:25:22,078 --> 00:25:22,718
What are the targets?

556
00:25:22,738 --> 00:25:23,739
Well, they could be anything, right?

557
00:25:23,759 --> 00:25:25,039
It could be me, right?

558
00:25:25,079 --> 00:25:26,260
The character that's under control.

559
00:25:26,720 --> 00:25:27,880
It could be a named entity.

560
00:25:27,920 --> 00:25:29,701
Maybe the name of the entity is player, right?

561
00:25:29,721 --> 00:25:31,842
I want to measure the distance between myself and the player.

562
00:25:31,882 --> 00:25:33,002
It could be a fixed position.

563
00:25:33,362 --> 00:25:34,363
It could be the camera.

564
00:25:34,792 --> 00:25:37,434
It could be an entity that's been written to the blackboard.

565
00:25:38,175 --> 00:25:39,576
Lots of different kinds of targets

566
00:25:39,677 --> 00:25:42,760
can just be plugged in, not only in the distance consideration,

567
00:25:42,800 --> 00:25:44,882
but in the move action, or the fire action,

568
00:25:45,002 --> 00:25:47,745
or anywhere that I need that sort of thing.

569
00:25:50,040 --> 00:25:51,881
Weight functions are a good example

570
00:25:51,901 --> 00:25:53,282
of the kind of cross-cutting concerns

571
00:25:53,342 --> 00:25:54,502
that Chris was talking about.

572
00:25:55,323 --> 00:25:58,264
So in considerations, I found a lot of considerations

573
00:25:58,304 --> 00:26:00,325
come down to they have a floating point number, right?

574
00:26:00,345 --> 00:26:03,066
A distance consideration is a number, right?

575
00:26:03,447 --> 00:26:04,647
The number, the distance in meters.

576
00:26:06,689 --> 00:26:10,092
execution history consideration also gives me a number. It's the amount of time since

577
00:26:10,112 --> 00:26:15,737
something happened. So I want a standard way to convert from a number to whatever the output

578
00:26:15,757 --> 00:26:19,520
of my consideration is. And I'm not going to tell you what that should be today because

579
00:26:19,540 --> 00:26:23,144
there's not time. But the considerations that I use return three different values.

580
00:26:24,032 --> 00:26:29,494
So, the job of the weight function is to, in some standard way, convert from a floating

581
00:26:29,514 --> 00:26:33,655
point number or an integer, or recently I've added the ability to have entities, so you

582
00:26:33,695 --> 00:26:37,196
can pass an entity into a weight function and it returns an evaluation on the basis

583
00:26:37,236 --> 00:26:40,258
of that, to the output of the...

584
00:26:41,698 --> 00:26:47,344
consideration. So the Boolean weight function, for instance, just says, it treats it as a

585
00:26:47,364 --> 00:26:51,087
Boolean, right? So, for instance, that picker is going to return the number of entities

586
00:26:51,127 --> 00:26:55,731
that it finds. Typically, it uses a Boolean weight function, which says if I find zero

587
00:26:55,851 --> 00:27:00,776
entities, then return this set of weight values, and if I find one or more entities, then use

588
00:27:00,816 --> 00:27:02,958
this other set of weight values, right? Did I find it or not?

589
00:27:03,899 --> 00:27:06,140
The distance consideration could use something like a float

590
00:27:06,160 --> 00:27:07,782
sequence, for instance, if I want to say,

591
00:27:09,023 --> 00:27:11,985
do one set of things if the distance is between 0 and 50,

592
00:27:12,445 --> 00:27:14,347
another if it's between 50 and 100,

593
00:27:14,487 --> 00:27:15,648
and a third if it's over 100.

594
00:27:16,608 --> 00:27:18,870
The float sequence breaks the float into regions,

595
00:27:19,231 --> 00:27:21,032
and then it returns a different set of weight functions

596
00:27:21,072 --> 00:27:21,812
for each regions.

597
00:27:22,413 --> 00:27:24,674
A simple curve is the kind of thing that you hear Dave Mark

598
00:27:24,714 --> 00:27:26,875
talk about all the time, where you want to take the number

599
00:27:27,255 --> 00:27:29,296
and maybe apply some sort of formula to it

600
00:27:29,336 --> 00:27:32,498
to turn it into an S-shaped curve or a parabola.

601
00:27:32,858 --> 00:27:33,798
And then you're going to take that,

602
00:27:33,858 --> 00:27:34,939
maybe you want to normalize it.

603
00:27:34,959 --> 00:27:36,920
You're going to stick it into one of the weight values

604
00:27:36,940 --> 00:27:37,880
that you're going to return.

605
00:27:38,881 --> 00:27:40,321
The simple curve weight function handles

606
00:27:40,341 --> 00:27:41,282
all of that kind of logic.

607
00:27:41,302 --> 00:27:43,183
And there are other special purpose weight functions

608
00:27:43,203 --> 00:27:44,283
that get used in other places.

609
00:27:46,492 --> 00:27:47,873
The last thing I'll mention is a region.

610
00:27:48,293 --> 00:27:51,495
A region is just a standard way to define

611
00:27:51,955 --> 00:27:53,416
some space in the world.

612
00:27:53,436 --> 00:27:54,657
It could be a spawn volume.

613
00:27:55,037 --> 00:27:57,899
It could be for my sniper, if he's firing down

614
00:27:57,939 --> 00:28:00,961
into a marketplace, I could define the kill zone for him.

615
00:28:03,474 --> 00:28:06,336
And I might represent that as a circle, or a rectangle,

616
00:28:06,396 --> 00:28:07,316
or a polygon.

617
00:28:08,217 --> 00:28:10,578
In the latest work that I've been doing on flight

618
00:28:10,598 --> 00:28:13,320
simulators, quite often the military has a line.

619
00:28:13,500 --> 00:28:15,841
And when an aircraft crosses the line,

620
00:28:15,881 --> 00:28:17,122
that changes their behavior.

621
00:28:17,182 --> 00:28:18,763
They change to a different stage of engagement.

622
00:28:18,783 --> 00:28:20,784
So it could be, here's a line in the sand,

623
00:28:20,924 --> 00:28:23,746
and one side is one region, and the other side is the other.

624
00:28:24,426 --> 00:28:26,547
Regions just have to be able to know if you're in the region

625
00:28:26,587 --> 00:28:26,928
or not.

626
00:28:27,088 --> 00:28:28,268
And maybe if you want to do something

627
00:28:28,288 --> 00:28:30,290
like a random wander, it's useful to be

628
00:28:30,330 --> 00:28:32,451
able to pick a random position inside of the region.

629
00:28:34,443 --> 00:28:36,224
So moving on to the sniper example,

630
00:28:38,025 --> 00:28:39,446
imagine that we have a sniper character.

631
00:28:39,526 --> 00:28:41,808
And this is drawn from a real character

632
00:28:41,848 --> 00:28:44,090
that we did build, although it's not exactly out

633
00:28:44,110 --> 00:28:44,830
of that character.

634
00:28:46,351 --> 00:28:48,072
And this sniper does a bunch of different things, right?

635
00:28:48,092 --> 00:28:50,054
He can move away, he can whatever other things

636
00:28:50,094 --> 00:28:50,634
he needs to do.

637
00:28:50,674 --> 00:28:52,556
But one of the most important things he's going to do

638
00:28:52,636 --> 00:28:54,637
is he's going to be in this sort of sniping behavior,

639
00:28:55,037 --> 00:28:56,899
where periodically, every minute or two,

640
00:28:56,939 --> 00:28:58,800
this is military simulation, now not games.

641
00:28:59,460 --> 00:29:01,762
So every minute or two, he wants to take a shot at the enemy.

642
00:29:02,342 --> 00:29:03,803
In games, it would probably be more often.

643
00:29:04,285 --> 00:29:05,926
But also, this is military simulation.

644
00:29:05,946 --> 00:29:08,788
So unlike most game characters, our sniper wants to live.

645
00:29:09,508 --> 00:29:12,349
So if he doesn't have a line of retreat,

646
00:29:12,810 --> 00:29:14,371
he's not going to take a shot.

647
00:29:14,411 --> 00:29:17,032
And that's pretty common for real-world snipers.

648
00:29:17,072 --> 00:29:18,813
If they don't think they have a way to get away,

649
00:29:19,333 --> 00:29:20,474
then they're not going to engage.

650
00:29:21,094 --> 00:29:21,634
Uh-oh.

651
00:29:23,415 --> 00:29:24,856
Hopefully, is there a way to plug in?

652
00:29:25,496 --> 00:29:29,278
Never say, uh-oh, when you're on a mission.

653
00:29:29,378 --> 00:29:30,279
Oh, you don't see why.

654
00:29:30,359 --> 00:29:31,599
Sorry, I just got a bad recording.

655
00:29:34,795 --> 00:29:35,016
All right.

656
00:29:35,717 --> 00:29:37,680
And also, with each additional shot,

657
00:29:37,740 --> 00:29:40,003
he wants to decrease the priority

658
00:29:40,504 --> 00:29:41,546
of taking further shots.

659
00:29:41,606 --> 00:29:44,029
Because every shot increases the risk

660
00:29:44,189 --> 00:29:46,192
that the enemy will figure out where he is.

661
00:29:50,407 --> 00:29:52,768
So he's going to have an option somewhere in some reason,

662
00:29:52,788 --> 00:29:55,730
or it's probably going to be a utility-based reasoner that's

663
00:29:55,811 --> 00:29:58,472
picking the high-level thing he's going to do that

664
00:29:58,512 --> 00:29:59,573
is the take a shot option.

665
00:30:00,014 --> 00:30:02,896
And that option is going to have some considerations on it that

666
00:30:02,936 --> 00:30:04,517
tell us when we should do this thing,

667
00:30:05,277 --> 00:30:06,658
and then some actions that say what

668
00:30:06,698 --> 00:30:08,279
we should do in the case that it gets picked.

669
00:30:08,299 --> 00:30:11,322
Are you guys good down there?

670
00:30:11,722 --> 00:30:14,024
I have to dodge and wait.

671
00:30:14,064 --> 00:30:14,544
This is great.

672
00:30:14,764 --> 00:30:15,865
Extra challenge, right?

673
00:30:15,905 --> 00:30:17,446
You have a line of retreat.

674
00:30:18,501 --> 00:30:19,961
I really know I'm blocked.

675
00:30:20,001 --> 00:30:22,682
I probably shouldn't take any shots.

676
00:30:22,702 --> 00:30:24,042
So the first consideration we're going to have

677
00:30:24,062 --> 00:30:25,763
is an execution history consideration.

678
00:30:26,223 --> 00:30:28,024
The job of this consideration is to make sure

679
00:30:28,064 --> 00:30:30,125
that we only take a shot every minute or two.

680
00:30:31,805 --> 00:30:33,446
So execution history consideration

681
00:30:33,486 --> 00:30:35,366
can be configured in a couple of different ways.

682
00:30:35,766 --> 00:30:38,107
In this case, we're giving it a stopped wait function, which

683
00:30:38,167 --> 00:30:41,108
is the wait function that gets used when the option is not

684
00:30:41,248 --> 00:30:42,069
currently running.

685
00:30:42,529 --> 00:30:45,330
So this consideration is going to do its work when we're not

686
00:30:45,510 --> 00:30:46,930
in the process of taking a shot.

687
00:30:48,765 --> 00:30:51,246
And that execution history consideration

688
00:30:51,286 --> 00:30:52,867
is going to just pass the amount of time

689
00:30:52,907 --> 00:30:55,008
since we were last executing into this wait function.

690
00:30:55,708 --> 00:30:57,369
The wait function is a float sequence,

691
00:30:57,429 --> 00:31:00,311
so it's going to divide that floating point

692
00:31:00,331 --> 00:31:03,672
with possible values into, in this case, two areas.

693
00:31:04,193 --> 00:31:06,474
One that's less than some random amount between 60.

694
00:31:06,514 --> 00:31:09,015
Oh, you guys can't.

695
00:31:09,035 --> 00:31:10,256
You're not going to be able to see the mouse.

696
00:31:10,296 --> 00:31:10,356
60 and 120.

697
00:31:13,263 --> 00:31:17,225
And in the case that it's in between, say, 73 is the number

698
00:31:17,245 --> 00:31:20,307
that's picked, right? Say it's less than 73 seconds, then the

699
00:31:20,347 --> 00:31:23,389
wait values that I'm going to return are to set veto to true.

700
00:31:23,709 --> 00:31:27,090
And veto just says, I don't care what any other consideration

701
00:31:27,151 --> 00:31:30,072
says, you cannot do this right now. Right? It's an absolute

702
00:31:30,092 --> 00:31:35,355
veto. Otherwise, if it's over 73 seconds, then we're going to

703
00:31:35,375 --> 00:31:37,656
set veto to false, which is effectively a no-op. It says,

704
00:31:37,696 --> 00:31:39,737
you know what? I don't care. Right? Ask the other

705
00:31:39,777 --> 00:31:42,038
considerations. Do it if you want. It's up to you.

706
00:31:43,973 --> 00:31:45,655
The next consideration we're going to have

707
00:31:45,855 --> 00:31:48,056
is going to be a picker consideration.

708
00:31:48,777 --> 00:31:51,139
This one is defined globally, partly because there's not

709
00:31:51,179 --> 00:31:53,200
space on the slide, but also because this

710
00:31:53,260 --> 00:31:54,121
is picking a target.

711
00:31:54,441 --> 00:31:56,162
And we likely would have other behaviors

712
00:31:56,202 --> 00:31:58,144
that would also want to pick a target to shoot at

713
00:31:58,224 --> 00:31:59,205
in different situations.

714
00:32:01,361 --> 00:32:03,342
And the picker is going to do the kinds of stuff I said

715
00:32:03,402 --> 00:32:03,862
before, right?

716
00:32:03,882 --> 00:32:05,043
It's going to look at the targets,

717
00:32:05,103 --> 00:32:06,544
check that they're in the marketplace,

718
00:32:06,924 --> 00:32:09,285
check the distance to them, check how much cover they have,

719
00:32:09,325 --> 00:32:11,366
look for ones that it knows to be an officer,

720
00:32:11,426 --> 00:32:15,288
if it happens to know that, and use all of those values

721
00:32:15,368 --> 00:32:16,649
to pick the best target to shoot at.

722
00:32:18,410 --> 00:32:21,091
And then it's going to use a Boolean weight function

723
00:32:21,151 --> 00:32:23,452
to say, if I've got something to shoot at,

724
00:32:24,253 --> 00:32:25,293
then set veto to false.

725
00:32:25,533 --> 00:32:26,674
Otherwise, set veto to true.

726
00:32:26,714 --> 00:32:28,575
If I don't have anything to shoot at, then I can't shoot.

727
00:32:29,546 --> 00:32:32,168
And it's also going to write that target to the blackboard for use later.

728
00:32:33,909 --> 00:32:37,892
The third consideration is another picker that's defined globally.

729
00:32:37,933 --> 00:32:41,375
The names on these, by the way, so globals are defined somewhere else and they're given

730
00:32:41,415 --> 00:32:43,537
a name and the name just tells me which global to stick in.

731
00:32:44,938 --> 00:32:49,061
This one is going to use a region to define my area of retreat and it's going to use a

732
00:32:49,081 --> 00:32:51,583
picker just to check if there are any entities in that area.

733
00:32:52,283 --> 00:32:57,247
It might well cheat and use all entities rather than just using known entities in order to

734
00:32:57,287 --> 00:32:58,808
get the behavior to do what I really want.

735
00:32:59,431 --> 00:33:02,257
and avoid it looking stupid when the player goes,

736
00:33:02,277 --> 00:33:04,681
well, you should have known about that entity, but he didn't.

737
00:33:06,281 --> 00:33:08,042
And last but not least, I'm going

738
00:33:08,062 --> 00:33:10,584
to use an integer variable consideration.

739
00:33:10,624 --> 00:33:12,625
This just looks on the blackboard for a variable

740
00:33:12,665 --> 00:33:15,207
named numShots, which should be an integer.

741
00:33:16,627 --> 00:33:19,409
And then it's going to pass that integer into a basic curve.

742
00:33:19,789 --> 00:33:22,451
The basic curve is going to transform that integer

743
00:33:22,511 --> 00:33:25,893
into something that decreases the priority of this option

744
00:33:26,013 --> 00:33:28,454
with each as the number of shots increases.

745
00:33:29,095 --> 00:33:30,956
So that's how I try and decrease priority

746
00:33:30,996 --> 00:33:32,316
with each successive shot.

747
00:33:33,934 --> 00:33:36,255
If this option gets selected, it's going to do two things.

748
00:33:36,275 --> 00:33:39,417
First, it's going to update that integer variable, numshot.

749
00:33:39,477 --> 00:33:41,178
So in this case, the update we're

750
00:33:41,198 --> 00:33:42,479
going to do is an increment.

751
00:33:42,539 --> 00:33:45,321
This action could also just set it to a static value,

752
00:33:45,341 --> 00:33:46,582
but that's not what we want to do here.

753
00:33:46,962 --> 00:33:49,703
So this is how we keep track of how many shots we've fired

754
00:33:49,743 --> 00:33:51,124
each time this option gets selected.

755
00:33:51,565 --> 00:33:52,845
This action increments the number

756
00:33:52,865 --> 00:33:53,786
of shots that have been fired.

757
00:33:55,197 --> 00:33:58,620
And I also have a global action, because other people might want

758
00:33:58,640 --> 00:34:02,004
to do the same thing, that's going to fire at the target that

759
00:34:02,044 --> 00:34:04,687
we wrote to the blackboard. And that probably has some more

760
00:34:04,727 --> 00:34:07,290
logic inside of it that handles going through whatever sequence

761
00:34:07,350 --> 00:34:09,832
of fire actions, making sure I'm in the right animation and that

762
00:34:09,872 --> 00:34:10,273
sort of thing.

763
00:34:11,875 --> 00:34:12,936
So what does all of this buy me?

764
00:34:14,515 --> 00:34:17,178
The most important thing is that as I'm doing my work,

765
00:34:17,318 --> 00:34:19,219
as I'm specifying behavior, I'm thinking

766
00:34:19,299 --> 00:34:21,161
at the appropriate level of abstraction.

767
00:34:21,201 --> 00:34:24,103
Not too big, not too small, definitely not

768
00:34:24,143 --> 00:34:25,204
implementation details.

769
00:34:26,365 --> 00:34:28,727
So if you look at this execution history consideration,

770
00:34:28,767 --> 00:34:31,249
for instance, I enter about six values.

771
00:34:31,389 --> 00:34:33,611
It's execution history, it's a float sequence,

772
00:34:33,691 --> 00:34:36,754
the minimum and maximum values, and what to set the vetoes true.

773
00:34:37,174 --> 00:34:40,176
And that expands out to probably a couple hundred lines of code.

774
00:34:40,576 --> 00:34:44,258
And it's not just the obvious keeping track of when the last time I did it is,

775
00:34:44,318 --> 00:34:47,379
but also little things like getting that random number

776
00:34:47,479 --> 00:34:50,621
and making sure that that random number is updated at an appropriate time.

777
00:34:50,661 --> 00:34:54,603
So each time I take a shot, I want to pick a new random number for the next shot.

778
00:34:54,903 --> 00:34:57,284
But I don't want to pick that every frame, right?

779
00:34:57,344 --> 00:34:59,125
Because then it's quickly just going to be 60,

780
00:34:59,245 --> 00:35:01,886
because I'm picking it over and over as it gets smaller.

781
00:35:01,906 --> 00:35:03,547
Sooner or later, it's going to be small enough that I fire.

782
00:35:05,788 --> 00:35:08,734
So that's not hard to do, but it's a little bit tricky. You

783
00:35:08,754 --> 00:35:10,839
could introduce a bug there, right? So you'd rather implement

784
00:35:10,859 --> 00:35:12,121
it once and then reuse it.

785
00:35:14,084 --> 00:35:17,767
The other thing to notice is that the values that I'm specifying are the relevant ones.

786
00:35:17,827 --> 00:35:22,091
If I were describing to you when the sniper takes a shot, like I just did, the things

787
00:35:22,131 --> 00:35:26,815
that I would tell you are things like, he's going to take a shot every minute or two,

788
00:35:26,936 --> 00:35:27,136
right?

789
00:35:27,176 --> 00:35:28,277
So what am I putting in here?

790
00:35:28,497 --> 00:35:32,220
You know, the time since the last shot needs to be between one and two minutes, right?

791
00:35:32,981 --> 00:35:37,805
That's exactly the same values that I tell you in my human description of what I'm doing.

792
00:35:39,528 --> 00:35:41,529
This also allows me to have really broad reuse,

793
00:35:41,589 --> 00:35:42,610
both of the code itself.

794
00:35:42,790 --> 00:35:44,290
This execution history consideration

795
00:35:44,310 --> 00:35:45,531
gets used lots of places.

796
00:35:45,891 --> 00:35:48,092
This weight function gets used even more places.

797
00:35:49,152 --> 00:35:50,453
But also the XML.

798
00:35:50,493 --> 00:35:52,173
If there's something that gets reused a lot,

799
00:35:52,493 --> 00:35:55,175
then I can define it globally and then just plug it in.

800
00:35:56,555 --> 00:35:58,156
Since I'm reusing something, I only

801
00:35:58,176 --> 00:35:58,996
have to implement it once.

802
00:35:59,056 --> 00:36:02,237
The time it takes to implement is a cost I pay one time instead

803
00:36:02,257 --> 00:36:03,678
of paying every time I need to do it.

804
00:36:04,599 --> 00:36:05,982
I also get fewer bugs, right?

805
00:36:06,383 --> 00:36:08,669
Every time I write code, there's the chance of introducing a bug.

806
00:36:08,949 --> 00:36:12,177
If I don't need to write some code, I'm not going to introduce a bug, hopefully.

807
00:36:13,357 --> 00:36:15,357
And my code becomes much more mature.

808
00:36:15,397 --> 00:36:17,998
It's much better tested because it's being executed lots of

809
00:36:18,058 --> 00:36:18,718
different ways.

810
00:36:19,118 --> 00:36:22,179
So it's not only more tested, but better tested.

811
00:36:22,259 --> 00:36:23,520
It's tested lots of ways.

812
00:36:23,900 --> 00:36:26,080
And it also becomes more feature rich as I add new

813
00:36:26,120 --> 00:36:28,921
features and new capabilities, like the ability to pick that

814
00:36:29,001 --> 00:36:31,362
random amount of time instead of just specifying a fixed

815
00:36:31,402 --> 00:36:31,982
amount of time.

816
00:36:33,182 --> 00:36:36,043
Now I have that capability and I can reuse it going forward.

817
00:36:36,803 --> 00:36:38,964
And if I wanted it to be an exact amount of time, by the

818
00:36:38,984 --> 00:36:41,204
way, in the XML, I would just put exact equals and then I

819
00:36:41,264 --> 00:36:42,285
would put the exacts time.

820
00:36:44,048 --> 00:36:46,530
So the bottom line is the developer flow, right?

821
00:36:46,550 --> 00:36:48,051
The developer's sort of in this flow

822
00:36:48,091 --> 00:36:51,854
where he's thinking about the concepts that he cares about

823
00:36:51,934 --> 00:36:53,895
or she cares about in the specification

824
00:36:53,915 --> 00:36:58,859
that they're defining, not about implementation details

825
00:36:58,899 --> 00:37:00,960
and low-level stuff that's just a distraction.

826
00:37:03,262 --> 00:37:04,643
So a few implementation details.

827
00:37:07,021 --> 00:37:09,702
Obviously, the biggest thing is polymorphism, right?

828
00:37:09,742 --> 00:37:10,542
No surprises here.

829
00:37:10,562 --> 00:37:13,443
We're going to have a base class for each conceptual abstraction

830
00:37:13,864 --> 00:37:15,044
which defines the interface.

831
00:37:15,664 --> 00:37:18,505
And then everybody else is just going

832
00:37:18,525 --> 00:37:20,966
to interact with a consideration or an action

833
00:37:22,027 --> 00:37:23,647
on the basis of those base classes.

834
00:37:23,667 --> 00:37:26,368
And you guys probably saw I put the simplified versions

835
00:37:26,408 --> 00:37:27,849
of those interfaces in the slides

836
00:37:28,509 --> 00:37:29,689
should you want to go back and find them.

837
00:37:30,770 --> 00:37:33,170
This lets me decouple the interface

838
00:37:33,490 --> 00:37:34,530
from the implementation, right?

839
00:37:34,630 --> 00:37:38,391
So nobody needs to know that this is a distance consideration

840
00:37:38,511 --> 00:37:40,692
or how the distance consideration is implemented.

841
00:37:41,012 --> 00:37:43,232
This also makes it possible for me to inject code

842
00:37:43,292 --> 00:37:44,772
from the simulation or from the game

843
00:37:45,212 --> 00:37:47,753
up into the AI architecture

844
00:37:48,093 --> 00:37:50,153
without the AI architecture knowing anything

845
00:37:50,193 --> 00:37:50,874
about that code.

846
00:37:50,914 --> 00:37:52,334
So the move action, for instance,

847
00:37:52,394 --> 00:37:53,874
is gonna be game-specific, right?

848
00:37:54,234 --> 00:37:56,975
How you go about moving a character around in-game and...

849
00:37:57,335 --> 00:38:01,577
deal with physics and collision and path planning and all of that. That's going to be game specific.

850
00:38:02,118 --> 00:38:06,000
The AI doesn't need to know any of those implementation details. It just knows it has a

851
00:38:06,020 --> 00:38:12,104
move action. It's supposed to give the move action the set of values. You have to have

852
00:38:12,144 --> 00:38:17,507
factories, which handle reading the XML and then creating all of the objects inside of it. So you

853
00:38:17,527 --> 00:38:20,729
have a consideration factory, for instance, which pulls the type...

854
00:38:22,105 --> 00:38:27,968
value off of each consideration and then creates an object of the appropriate type. Um, what

855
00:38:27,988 --> 00:38:32,330
you pass to the factory is not only the XML node but also some contextual data, where

856
00:38:32,350 --> 00:38:37,513
the blackboard is, uh, what entity you belong to, if you're underneath an option, what option

857
00:38:37,553 --> 00:38:41,535
you belong to because the execution history consideration, for instance, needs to know

858
00:38:41,575 --> 00:38:42,595
which option it belongs to.

859
00:38:45,611 --> 00:38:47,852
One nice thing about the factories that we have in Gaia,

860
00:38:47,892 --> 00:38:49,392
because we want to be able to reuse it

861
00:38:49,732 --> 00:38:52,153
across multiple projects, is they

862
00:38:52,193 --> 00:38:53,533
have this notion of constructors.

863
00:38:53,934 --> 00:38:55,454
So a constructor is just an object

864
00:38:55,494 --> 00:38:57,575
that knows how to create some subset

865
00:38:58,035 --> 00:38:59,435
of that conceptual abstraction.

866
00:38:59,475 --> 00:39:01,596
So a consideration constructor knows

867
00:39:01,636 --> 00:39:03,297
how to create a bunch of different kinds

868
00:39:03,337 --> 00:39:04,017
of considerations.

869
00:39:04,357 --> 00:39:06,057
The factory could have multiple constructors,

870
00:39:06,117 --> 00:39:07,218
and it just asks each one.

871
00:39:07,598 --> 00:39:08,579
Do you know how to create this?

872
00:39:08,639 --> 00:39:09,140
OK, you don't.

873
00:39:09,180 --> 00:39:10,501
Next guy, do you know how to create this?

874
00:39:10,521 --> 00:39:13,163
Until it finds one that knows how to create the object

875
00:39:13,183 --> 00:39:13,684
that it needs.

876
00:39:14,184 --> 00:39:16,907
This means that my simulation or my game

877
00:39:17,367 --> 00:39:20,370
can pass a factory into the AI architecture.

878
00:39:20,891 --> 00:39:22,833
So this is how we inject code into the AI.

879
00:39:25,449 --> 00:39:29,990
Last thing I'll say about factories, it's really powerful to have a single implementation, right?

880
00:39:30,070 --> 00:39:33,251
I decided some time ago that duplicate code was of the devil,

881
00:39:33,611 --> 00:39:36,132
and I was going to do everything I can to get duplicate code out,

882
00:39:36,252 --> 00:39:38,152
and so far I have never regretted that decision.

883
00:39:38,912 --> 00:39:40,813
So I'm going to have lots of different factories,

884
00:39:40,893 --> 00:39:43,674
one for considerations, one for regions, one for weight functions.

885
00:39:44,194 --> 00:39:47,015
I want to make sure that I have one set of code that they all execute.

886
00:39:47,375 --> 00:39:50,356
so that I don't have this situation where I have this one factory that's a little funky,

887
00:39:50,376 --> 00:39:53,757
it works in a slightly different way and I have to remember how it gets used, or I have

888
00:39:53,797 --> 00:39:57,339
a bug in one factory and I forget to fix it in the others, or, you know, that kind of

889
00:39:57,379 --> 00:40:01,240
stuff. I don't want to worry about that. The other nice thing is if I do it this way, where

890
00:40:01,260 --> 00:40:04,941
I just have a macro that creates the factory for me, then when I come up with some new

891
00:40:05,001 --> 00:40:09,403
kind of conceptual abstraction, and that happens more often than you might think, I just have

892
00:40:09,423 --> 00:40:13,425
to call the macro, and all the infrastructure is there. It's all created for me.

893
00:40:14,119 --> 00:40:16,341
So this is roughly what that macro looks like for the

894
00:40:16,381 --> 00:40:21,324
factories. I use macros much more widely than this. Macros

895
00:40:21,364 --> 00:40:24,426
are a pain to debug. Figure out how to get your compiler to

896
00:40:24,466 --> 00:40:26,947
expand the macro out for you so that when you need to debug it

897
00:40:27,007 --> 00:40:32,251
you can do that. As I said earlier, I don't have time to

898
00:40:32,291 --> 00:40:34,852
talk about how we combine considerations. But there have

899
00:40:34,872 --> 00:40:37,534
been a bunch of good talks on this. I gave a talk yesterday

900
00:40:37,854 --> 00:40:41,316
on the trigger system, which used a very simple Boolean

901
00:40:41,336 --> 00:40:42,837
approach to combining considerations.

902
00:40:44,591 --> 00:40:49,660
Mike Lewis and Dave Mark last year gave a fantastic talk in which they talked about

903
00:40:49,701 --> 00:40:51,805
how they combined considerations in their architecture.

904
00:40:54,364 --> 00:40:57,147
I gave a talk with Dave a couple years ago,

905
00:40:57,167 --> 00:40:59,990
where I presented a dual utility-based approach.

906
00:41:00,791 --> 00:41:02,833
I really recommend the third, the dual utility-based

907
00:41:02,873 --> 00:41:03,193
approach.

908
00:41:03,694 --> 00:41:04,955
It's straightforward to implement.

909
00:41:05,115 --> 00:41:06,577
It's not hard to get it up and running.

910
00:41:06,997 --> 00:41:08,358
It's extremely flexible.

911
00:41:08,619 --> 00:41:12,022
It lets you do either really hardcore utility-based AI

912
00:41:12,042 --> 00:41:14,324
stuff, or really simple yes or no stuff.

913
00:41:14,384 --> 00:41:16,587
And you saw some examples of both of those in the Sniper.

914
00:41:18,459 --> 00:41:20,580
And it's probably too strong to say it completely

915
00:41:20,640 --> 00:41:22,282
avoids the sort of combinatoric problems

916
00:41:22,322 --> 00:41:24,223
that Mike and Dave have, because it's utility-based,

917
00:41:24,263 --> 00:41:25,044
so of course it doesn't.

918
00:41:25,604 --> 00:41:28,166
But they had a problem where the more considerations you have,

919
00:41:28,327 --> 00:41:30,288
the more it forced the values down when

920
00:41:30,308 --> 00:41:31,389
they multiplied them together.

921
00:41:32,390 --> 00:41:33,731
And the dual utility-based approach

922
00:41:33,771 --> 00:41:35,212
gives you some different options for how

923
00:41:35,232 --> 00:41:36,893
you combine things to try and work around that

924
00:41:36,973 --> 00:41:37,534
in different ways.

925
00:41:39,112 --> 00:41:40,893
But you don't have to pick one way, right?

926
00:41:40,933 --> 00:41:42,374
So a consideration set is the thing

927
00:41:42,414 --> 00:41:43,875
that wraps a bunch of considerations

928
00:41:43,915 --> 00:41:44,876
and combines them together.

929
00:41:45,416 --> 00:41:46,157
It's all in data.

930
00:41:46,257 --> 00:41:48,118
So in the data, you can have a flag that says,

931
00:41:48,439 --> 00:41:49,520
combine in some different way.

932
00:41:49,560 --> 00:41:52,102
Or you could have a different, you

933
00:41:52,142 --> 00:41:54,243
could make a consideration set a conceptual abstraction

934
00:41:54,283 --> 00:41:55,624
and have different consideration sets that

935
00:41:55,684 --> 00:41:57,025
use different types of considerations,

936
00:41:57,586 --> 00:41:59,247
if that's the thing that you feel like you need to do.

937
00:42:00,008 --> 00:42:01,809
What I've done is I have a few flags that

938
00:42:01,869 --> 00:42:03,170
change the way I combine the values,

939
00:42:03,210 --> 00:42:05,892
but I only have the one kind of weight value

940
00:42:05,932 --> 00:42:06,593
that I use everywhere.

941
00:42:09,246 --> 00:42:14,211
So final thoughts. Remember the what does this buy me, right? The important thing is it lets me

942
00:42:14,251 --> 00:42:19,035
think at the right level of abstraction. It keeps me in that good flow, um, so that I can

943
00:42:19,135 --> 00:42:23,199
implement much more quickly. I can iterate much more quickly. Um, I've seen modular

944
00:42:23,259 --> 00:42:27,624
approaches pay off in projects that are three months long, right? When we did the boss AI for

945
00:42:27,744 --> 00:42:32,608
Iron Man, we used a modular architecture and we were very quickly getting to the point where,

946
00:42:32,628 --> 00:42:32,929
you know, it's...

947
00:42:33,569 --> 00:42:39,134
It was a three month project and I don't think we could have hit it if we hadn't had that ability to iterate so quickly.

948
00:42:39,935 --> 00:42:44,438
And it also, you get much more reuse, so your code is better tested, you have fewer bugs,

949
00:42:44,879 --> 00:42:48,702
and your code becomes more feature rich, and it's easier to carry it with you to future projects.

950
00:42:50,162 --> 00:42:52,284
You don't have to throw out your architecture and start over.

951
00:42:53,906 --> 00:42:56,229
Look for opportunities to do something in a modular way

952
00:42:56,369 --> 00:42:57,190
in your architecture.

953
00:42:57,250 --> 00:42:58,952
Weapon selection and target selection

954
00:42:59,052 --> 00:43:02,456
are common cases of plugging in some considerations.

955
00:43:03,216 --> 00:43:06,640
In Red Dead, I was assigned to build the attention system that

956
00:43:06,660 --> 00:43:08,142
got characters looking around in town.

957
00:43:08,622 --> 00:43:11,924
And I decided, even after Iron Man, not to do it modularly,

958
00:43:11,944 --> 00:43:13,545
because I thought it was just going to be very simple.

959
00:43:14,106 --> 00:43:16,147
And we got eaten to death by special cases.

960
00:43:16,187 --> 00:43:18,588
You know, I thought it was just going to be pick something nearby at random

961
00:43:18,628 --> 00:43:21,270
and look at it for a little while and then pick something that's not in the same direction

962
00:43:21,310 --> 00:43:21,850
and look at that.

963
00:43:22,310 --> 00:43:24,932
But there was the, well, when this, you know, when the player does this,

964
00:43:24,972 --> 00:43:25,792
then you should look at them.

965
00:43:26,093 --> 00:43:28,074
But if this event happens, then you should look at that.

966
00:43:28,154 --> 00:43:30,135
But not if this other thing happens, then do that, right?

967
00:43:30,415 --> 00:43:32,656
And so all of those special cases ate us to death.

968
00:43:33,097 --> 00:43:34,738
And I really wish if I could go back in time

969
00:43:34,758 --> 00:43:36,299
that I could have just built it in a modular way.

970
00:43:36,699 --> 00:43:38,901
In the end, Red Dead shipped with a pretty cool attention

971
00:43:38,941 --> 00:43:42,183
system, but it was a lot more work than it could have been.

972
00:43:43,024 --> 00:43:44,525
And if you're going to do one thing,

973
00:43:45,025 --> 00:43:46,086
start with considerations.

974
00:43:46,186 --> 00:43:48,248
Considerations are a really, really powerful way

975
00:43:48,268 --> 00:43:49,148
to lay out your decisions.

976
00:43:51,239 --> 00:43:53,181
Last thing very quickly, the Mars game is out there.

977
00:43:53,201 --> 00:43:54,142
I mentioned this yesterday.

978
00:43:54,162 --> 00:43:54,943
It's open source.

979
00:43:54,983 --> 00:43:58,027
So if you want to see code examples of how all of this

980
00:43:58,067 --> 00:44:00,570
works together, you can go grab the code from GitHub.

981
00:44:00,951 --> 00:44:03,634
It's a simpler modular system, but it

982
00:44:03,714 --> 00:44:04,896
has all of the big ideas in it.

983
00:44:06,238 --> 00:44:06,919
So that's it for me.

984
00:44:07,720 --> 00:44:08,120
On to Troy.

985
00:44:26,315 --> 00:44:26,676
All right.

986
00:44:27,417 --> 00:44:27,937
How's it going?

987
00:44:27,977 --> 00:44:28,958
My name is Troy Humphreys.

988
00:44:29,099 --> 00:44:31,201
I'm the lead AI programmer at Turtle Rock Studios.

989
00:44:31,481 --> 00:44:36,647
And I'm also going to talk about modular AI systems.

990
00:44:36,667 --> 00:44:37,949
So why this talk?

991
00:44:40,305 --> 00:44:43,126
Well, I think game AI architectures are pretty modular.

992
00:44:43,286 --> 00:44:44,726
You know, like we have behavior trees,

993
00:44:44,766 --> 00:44:46,146
finite state machines, planners.

994
00:44:46,567 --> 00:44:48,367
All these things are modular systems,

995
00:44:48,627 --> 00:44:50,448
and modular systems come with a lot of benefits, right?

996
00:44:50,468 --> 00:44:52,228
We get code reuse, flexibility,

997
00:44:52,968 --> 00:44:55,109
ease of character creation, and so on.

998
00:44:55,449 --> 00:44:56,449
And on Evolve,

999
00:44:59,039 --> 00:45:01,822
On Evolve, we used a behavior tree,

1000
00:45:02,503 --> 00:45:05,386
but it wasn't giving us the modularity we wanted.

1001
00:45:05,406 --> 00:45:07,128
It was still hard to get the AI out the door.

1002
00:45:07,988 --> 00:45:10,051
The BT worked fine, but we simply

1003
00:45:10,071 --> 00:45:11,412
weren't getting all the gains we should have been

1004
00:45:11,432 --> 00:45:12,693
getting from a modular system.

1005
00:45:14,055 --> 00:45:15,396
So we decided to fix this.

1006
00:45:15,937 --> 00:45:17,218
We decided to focus on two things.

1007
00:45:17,639 --> 00:45:20,081
First was figuring out why the modular behavior

1008
00:45:20,121 --> 00:45:21,002
tree that we were using.

1009
00:45:21,779 --> 00:45:23,561
wasn't giving us all the benefits that we wanted.

1010
00:45:24,101 --> 00:45:26,584
And we needed to do this without breaking any of the legacy

1011
00:45:26,604 --> 00:45:28,345
characters in the systems, because we were still

1012
00:45:28,386 --> 00:45:29,386
developing a live game.

1013
00:45:29,747 --> 00:45:31,729
We still had DLC characters coming down the pipe.

1014
00:45:32,029 --> 00:45:33,330
And we couldn't mess any of that stuff up.

1015
00:45:37,214 --> 00:45:38,375
So how do you fill up modular?

1016
00:45:38,856 --> 00:45:41,618
So how about a little example to help illustrate this point?

1017
00:45:41,638 --> 00:45:45,602
Do you have a mouse?

1018
00:45:45,722 --> 00:45:46,323
OK, that's better.

1019
00:45:51,017 --> 00:45:52,898
So in our example, we have a forest troll.

1020
00:45:53,138 --> 00:45:55,138
And he's going to do a very simple attack called

1021
00:45:55,218 --> 00:45:56,639
the tree trunk tornado.

1022
00:45:56,659 --> 00:45:59,680
He uplifts the tree and spins around, knocking everybody

1023
00:45:59,740 --> 00:45:59,980
back.

1024
00:46:00,000 --> 00:46:01,800
I think everyone can visualize how

1025
00:46:01,820 --> 00:46:02,740
that would look in their minds.

1026
00:46:03,741 --> 00:46:05,101
But let's get into some details here.

1027
00:46:05,881 --> 00:46:08,962
First, he should only do this attack

1028
00:46:09,042 --> 00:46:10,503
if he's currently surrounded by enemies.

1029
00:46:11,423 --> 00:46:12,723
If he is surrounded by enemies, he's

1030
00:46:12,743 --> 00:46:15,304
going to do a point blank AOE knockback attack.

1031
00:46:15,824 --> 00:46:18,966
And after completion, he's going to be tired.

1032
00:46:19,006 --> 00:46:21,106
We want to set some kind of state of tiredness

1033
00:46:21,266 --> 00:46:23,207
to be used in some other behavior later down the line.

1034
00:46:23,928 --> 00:46:26,389
So we can simply just make a node in the behavior tree

1035
00:46:26,449 --> 00:46:27,509
to handle this stuff, right?

1036
00:46:28,029 --> 00:46:30,670
On start, we can check to see if there's enough enemies.

1037
00:46:31,051 --> 00:46:32,291
If not, we can fail out.

1038
00:46:32,491 --> 00:46:35,572
If so, we can go on and go ahead and play the animated attack

1039
00:46:35,612 --> 00:46:38,694
part, which is triggering animations, playing sounds,

1040
00:46:38,934 --> 00:46:40,334
damage boxes, and things like that.

1041
00:46:41,115 --> 00:46:46,560
And on completion, we can set some states in, like, the blackboard for tired, which we can use later.

1042
00:46:48,082 --> 00:46:50,944
And I think this is a perfectly reasonable implementation,

1043
00:46:51,004 --> 00:46:54,406
right? This could shit. And it's, it is modular. I can

1044
00:46:54,446 --> 00:46:56,428
find other situations in my behavior tree where I might

1045
00:46:56,448 --> 00:46:58,730
want to use this same attack. But we all know

1046
00:46:58,750 --> 00:47:01,492
what happens next, right? Designer comes to you and says,

1047
00:47:01,972 --> 00:47:04,133
all right, I want to tornado in a completely different

1048
00:47:04,174 --> 00:47:06,795
situation, maybe in a combo or getting up from a

1049
00:47:06,815 --> 00:47:08,817
knockdown or something like that. And all of a sudden

1050
00:47:08,857 --> 00:47:10,918
the is surrounded check is causing trouble, right, because

1051
00:47:10,938 --> 00:47:13,340
he doesn't care in those situations if he's surrounded or

1052
00:47:13,380 --> 00:47:13,480
not.

1053
00:47:14,221 --> 00:47:17,284
Sometimes the designer might want the tornado to trigger

1054
00:47:17,324 --> 00:47:19,366
without setting the troll tired, right?

1055
00:47:19,406 --> 00:47:20,327
You might want to be able to use it

1056
00:47:20,367 --> 00:47:21,308
in different situations,

1057
00:47:21,728 --> 00:47:24,811
and all of a sudden our nice little modular attack

1058
00:47:24,971 --> 00:47:26,293
isn't modular anymore.

1059
00:47:29,046 --> 00:47:33,528
So I'm sure you've seen similar examples in some form or another in a lot of codebases.

1060
00:47:33,828 --> 00:47:39,271
We had a lot of this in Evolve. It was getting, it's kind of a death by a thousand cuts type of thing.

1061
00:47:39,591 --> 00:47:43,313
So I started thinking a lot about what had worked on systems I used in the past.

1062
00:47:43,593 --> 00:47:47,455
I've gotten lucky, I've gotten to work with, ship games with hierarchical finite state machines.

1063
00:47:47,995 --> 00:47:50,596
We've shipped games with GOAP, HTN, and behavior trees.

1064
00:47:51,157 --> 00:47:55,839
And every time I think about all those systems, they all had one thing in common when they worked really well.

1065
00:47:56,099 --> 00:47:58,260
They had a really good separation of responsibility.

1066
00:47:59,973 --> 00:48:01,534
So I think separation of responsibilities

1067
00:48:01,594 --> 00:48:02,754
is something we can all get behind.

1068
00:48:02,814 --> 00:48:04,615
We talk about good abstractions all the time

1069
00:48:04,655 --> 00:48:05,515
in software engineering.

1070
00:48:05,916 --> 00:48:08,977
But I want to talk about three AI-centric responsibilities

1071
00:48:08,997 --> 00:48:11,358
that I think are crucial to having a good modular system.

1072
00:48:12,138 --> 00:48:13,879
So let's use our tree trunk tornado example

1073
00:48:14,159 --> 00:48:15,580
to help illustrate these three areas.

1074
00:48:17,281 --> 00:48:18,941
The first responsibility is sensing.

1075
00:48:19,082 --> 00:48:21,142
This is where we translate information about the game

1076
00:48:21,203 --> 00:48:22,743
into something the AI can understand.

1077
00:48:23,484 --> 00:48:25,725
In our example, it's the is surrounded question.

1078
00:48:27,071 --> 00:48:28,692
Breaking the sensing logic out of the tornado

1079
00:48:28,732 --> 00:48:30,892
allows us to ask the same question about different targets,

1080
00:48:31,372 --> 00:48:32,833
which can be useful for other behaviors.

1081
00:48:33,733 --> 00:48:36,174
It also allows us to fire off the tornado

1082
00:48:36,194 --> 00:48:38,055
if the troll's surrounded or not,

1083
00:48:38,135 --> 00:48:39,775
which helps solve the earlier problems

1084
00:48:39,815 --> 00:48:40,696
we had with our designer.

1085
00:48:43,157 --> 00:48:44,797
The next responsibility is acting.

1086
00:48:45,057 --> 00:48:47,678
This is where we see the AI actually do something.

1087
00:48:47,958 --> 00:48:50,859
In our example, it's the animated action part of our attack.

1088
00:48:51,319 --> 00:48:53,000
It's a logic that starts the animations,

1089
00:48:53,200 --> 00:48:55,801
plays effects, sounds, triggers damage zones.

1090
00:48:58,090 --> 00:49:00,932
And now that our sensing logic is out of the attack,

1091
00:49:01,032 --> 00:49:03,814
we can use that same animated attack action

1092
00:49:04,334 --> 00:49:06,336
with different data to do all kinds of different attacks.

1093
00:49:08,077 --> 00:49:09,718
The final responsibility is deciding.

1094
00:49:10,779 --> 00:49:12,239
And when we think of most AI systems,

1095
00:49:12,300 --> 00:49:13,220
this is where they would live.

1096
00:49:13,460 --> 00:49:15,181
Our finance state machines, planners,

1097
00:49:15,321 --> 00:49:17,283
and for us, it's our behavior tree.

1098
00:49:19,965 --> 00:49:24,826
This is going to be the spot where we assemble all the other responsibilities into a reasoning character.

1099
00:49:25,226 --> 00:49:30,187
We do this by defining the why the character will do the things it does and how it will react to them.

1100
00:49:31,227 --> 00:49:36,988
In our example, we would use the animated attack action to do our tornado.

1101
00:49:38,349 --> 00:49:45,390
Then we could decorate that action with a condition using the sensing data that we got from our isSurrounded sensing logic.

1102
00:49:46,707 --> 00:49:48,648
And lastly, we can add an effect that

1103
00:49:48,668 --> 00:49:50,650
would set state on successful completion attack.

1104
00:49:50,690 --> 00:49:53,271
This would satisfy the making the troll tired part.

1105
00:49:54,132 --> 00:49:56,253
So I'm betting a lot of you are probably thinking,

1106
00:49:56,273 --> 00:49:58,434
mm, this sounds a little familiar.

1107
00:49:58,555 --> 00:49:59,195
And you'd be right.

1108
00:49:59,275 --> 00:50:00,776
This is sense plan act.

1109
00:50:01,356 --> 00:50:03,137
But I don't want you to get hung up on the planning part.

1110
00:50:03,217 --> 00:50:04,598
I'm not trying to push planners on you.

1111
00:50:04,758 --> 00:50:05,879
I'll save that for another talk.

1112
00:50:06,479 --> 00:50:08,020
But I wanted to talk about how this

1113
00:50:08,040 --> 00:50:09,681
could be a guide for better modularity,

1114
00:50:10,162 --> 00:50:11,743
regardless of what architecture you're using.

1115
00:50:13,873 --> 00:50:15,635
So let's dive into these areas in more detail

1116
00:50:15,655 --> 00:50:18,077
with some guidelines and kind of what we did

1117
00:50:18,117 --> 00:50:19,398
with our refactor and evolve.

1118
00:50:20,019 --> 00:50:21,520
But first let's talk about something that I think

1119
00:50:21,720 --> 00:50:23,802
helps make all these areas work in concert,

1120
00:50:24,143 --> 00:50:25,364
something called the world state.

1121
00:50:26,825 --> 00:50:28,207
So the world state's kind of like your glue.

1122
00:50:28,787 --> 00:50:31,009
If the game state is the actual data in your game,

1123
00:50:31,450 --> 00:50:33,331
the world state is a simplified representation

1124
00:50:33,512 --> 00:50:35,974
of that state as far as the character's concerned.

1125
00:50:37,157 --> 00:50:38,617
I'm sure you all have different flavors of this.

1126
00:50:38,818 --> 00:50:40,718
Blackboards, contexts, if you're using planners,

1127
00:50:40,738 --> 00:50:41,938
it would be a world state.

1128
00:50:43,258 --> 00:50:46,359
So some guidelines for setting this stuff up.

1129
00:50:46,599 --> 00:50:51,160
Oh, the world state's really just a big block of data.

1130
00:50:51,700 --> 00:50:54,941
It should be easy to write to, easy to read from.

1131
00:50:56,481 --> 00:50:57,161
So some guidelines.

1132
00:50:59,141 --> 00:51:01,282
Every character should be able to have their own set, right?

1133
00:51:01,322 --> 00:51:02,822
Different characters need different information

1134
00:51:02,842 --> 00:51:03,842
to be able to make decisions.

1135
00:51:05,072 --> 00:51:08,359
keep the structure very simple right fast access faster right here

1136
00:51:08,379 --> 00:51:10,864
uh... an array is a perfectly acceptable

1137
00:51:11,245 --> 00:51:11,706
world state

1138
00:51:12,874 --> 00:51:15,456
For Evolve, we split this concept into two things.

1139
00:51:15,756 --> 00:51:18,257
Now, first we use a blackboard,

1140
00:51:18,978 --> 00:51:21,119
is used to represent the simplest enumeration

1141
00:51:21,199 --> 00:51:23,401
of the world state required for the decision system

1142
00:51:23,721 --> 00:51:24,822
to make decisions.

1143
00:51:25,482 --> 00:51:27,103
Let's take the character's health, for example.

1144
00:51:27,563 --> 00:51:29,204
We could use the character's health percentage

1145
00:51:29,584 --> 00:51:30,765
as a value in our world state,

1146
00:51:31,165 --> 00:51:34,668
but 0 to 100% is a lot of state, right?

1147
00:51:35,028 --> 00:51:36,469
We aren't going to be making decisions

1148
00:51:36,629 --> 00:51:38,730
on 101 different states if we're using an int.

1149
00:51:39,050 --> 00:51:40,633
If it's a float, it's even more, right?

1150
00:51:41,193 --> 00:51:43,997
But what we would like to make decisions on

1151
00:51:44,117 --> 00:51:47,021
is if the character's wounded, if he's healthy, if he's dying.

1152
00:51:47,421 --> 00:51:49,304
This is the type of data we want to store on a blackboard,

1153
00:51:49,364 --> 00:51:51,527
because that's the type of data we want to make decisions with.

1154
00:51:53,329 --> 00:51:54,951
The second part of our world state, something

1155
00:51:54,971 --> 00:51:55,832
we call the whiteboard.

1156
00:51:57,863 --> 00:52:02,785
clever. But this is where we put all of our rich data in our

1157
00:52:02,925 --> 00:52:05,867
world states. All the extra data that isn't used to make

1158
00:52:05,887 --> 00:52:09,029
decisions but is used to run behaviors. So this might be

1159
00:52:09,069 --> 00:52:12,250
like the best cover locations, the biggest threats and so on.

1160
00:52:14,026 --> 00:52:14,967
So let's get to sensing.

1161
00:52:15,787 --> 00:52:18,369
This is where we translate the game state into world state.

1162
00:52:18,889 --> 00:52:20,790
This doesn't just mean hearing and vision and things

1163
00:52:20,830 --> 00:52:21,210
like that.

1164
00:52:21,510 --> 00:52:23,552
This can be as simple as taking that health percentage

1165
00:52:23,732 --> 00:52:25,813
and translating it into the health enumeration,

1166
00:52:25,833 --> 00:52:28,735
or as complex as picking good cover locations.

1167
00:52:30,176 --> 00:52:31,456
Some guidelines to help you go.

1168
00:52:32,837 --> 00:52:33,918
Modular and atomic.

1169
00:52:33,938 --> 00:52:35,359
You want to keep these nice and small.

1170
00:52:35,719 --> 00:52:37,040
Sensors shouldn't know about each other.

1171
00:52:37,060 --> 00:52:38,601
No sensitive sensor dependencies.

1172
00:52:39,361 --> 00:52:41,022
Use the world state to communicate if you need to.

1173
00:52:42,558 --> 00:52:44,639
characters should be able to have their own sets of sensors, right?

1174
00:52:44,659 --> 00:52:45,900
If they're going to have different world states,

1175
00:52:45,920 --> 00:52:47,980
they're going to need different sensors to fill that world state.

1176
00:52:49,881 --> 00:52:53,082
Translating game state into world state can be very expensive, right?

1177
00:52:53,102 --> 00:52:56,423
So we want to be able to bin, throttle, defer our work,

1178
00:52:56,824 --> 00:52:58,564
anything we can do to handle that workload.

1179
00:52:59,945 --> 00:53:01,805
Another thing that you should keep in mind is to keep

1180
00:53:02,285 --> 00:53:04,126
sensing out of your deciding loop if it's possible.

1181
00:53:04,666 --> 00:53:05,867
We just said it's expensive.

1182
00:53:05,907 --> 00:53:07,707
We want to be able to quickly make decisions,

1183
00:53:07,747 --> 00:53:08,788
so try to keep that stuff out.

1184
00:53:10,456 --> 00:53:12,618
For Evolve, we ended up making a new sensor manager

1185
00:53:13,039 --> 00:53:14,901
to give us a formal and really easy place

1186
00:53:14,941 --> 00:53:15,841
to do our sensing work.

1187
00:53:16,622 --> 00:53:18,764
It allows us to install sensors per character type.

1188
00:53:19,886 --> 00:53:22,989
It allows sensors to have a different max stale time

1189
00:53:23,449 --> 00:53:24,410
per character type.

1190
00:53:25,311 --> 00:53:29,132
Meaning, this is how long the sensor can go without getting an update.

1191
00:53:29,252 --> 00:53:32,653
This is great because it shows the importance of that sensor to that character type.

1192
00:53:33,113 --> 00:53:38,075
So, as an example, imagine you have a line-of-sight sensor in two characters, a ranged and melee character.

1193
00:53:38,575 --> 00:53:42,196
Well, the ranged character is going to need a higher refresh rate because he needs to constantly check

1194
00:53:42,496 --> 00:53:44,817
to see if he can hit people from range, right?

1195
00:53:44,857 --> 00:53:48,878
The melee guy, not so much. He just needs to know the general location of where the guy is

1196
00:53:49,218 --> 00:53:52,959
and that can be updated kind of slow because he's just going to run up and smack you in the face anyway.

1197
00:53:54,719 --> 00:53:59,823
And to make it even simpler, the time, the way you specify the time is a simple enumeration.

1198
00:54:00,023 --> 00:54:03,186
Something like every frame, a lot, often, sometimes, never.

1199
00:54:03,726 --> 00:54:07,870
Why have our programmers come up with the perfect floating point time to do a refresh

1200
00:54:07,910 --> 00:54:12,634
rate when we're just really just looking for what that sensor's importance is to the character

1201
00:54:12,714 --> 00:54:13,014
using it.

1202
00:54:14,534 --> 00:54:16,536
So our manager will just burn through as many

1203
00:54:16,576 --> 00:54:17,897
sensors as it can and it's a lot of

1204
00:54:17,937 --> 00:54:20,500
time. It favors sensors that are getting closer to

1205
00:54:20,520 --> 00:54:22,723
their stale time. And since we use an enumeration

1206
00:54:22,743 --> 00:54:27,308
for time, we can tune those different frequencies behind the

1207
00:54:27,328 --> 00:54:31,252
scenes without breaking the character's type's needs. We could

1208
00:54:31,272 --> 00:54:32,814
also play with these too if we want

1209
00:54:32,834 --> 00:54:34,175
to do LODing and stuff like that.

1210
00:54:35,897 --> 00:54:38,259
So acting, acting is what makes up

1211
00:54:38,459 --> 00:54:39,680
what the AI actually does, right?

1212
00:54:39,700 --> 00:54:41,121
This is what the player is going to see.

1213
00:54:41,661 --> 00:54:43,243
These are your attacks or reloads,

1214
00:54:43,543 --> 00:54:45,844
your interactions, your tornadoes, things like that.

1215
00:54:46,085 --> 00:54:48,066
Different systems will have different terms for this,

1216
00:54:48,186 --> 00:54:51,108
right, HTN uses operators, GOAP uses actions,

1217
00:54:51,709 --> 00:54:53,570
behavior trees use nodes, states are

1218
00:54:53,610 --> 00:54:54,491
in finite state machines.

1219
00:54:55,823 --> 00:54:59,986
Some guidelines to keep in mind. Operations should be agnostic to the reason they're being

1220
00:55:00,046 --> 00:55:03,428
done. We saw this with the tornado example. If the reason's baked in, it's going to be

1221
00:55:03,508 --> 00:55:08,111
harder to use that tornado elsewhere if that is surrounded check is in there. The only

1222
00:55:08,131 --> 00:55:12,214
conditions that should be baked in are what's actually needed for that action to run or

1223
00:55:12,234 --> 00:55:17,657
that operation to run. So let's say we had a fire gun operation. You need the gun to

1224
00:55:17,677 --> 00:55:20,379
be able to fire it, right? So that's an OK condition to put in there.

1225
00:55:23,710 --> 00:55:26,072
Operations should be agnostic to the world state it references.

1226
00:55:26,932 --> 00:55:28,553
Let's say the troll had a boulder throw, right?

1227
00:55:29,153 --> 00:55:32,495
The boulder throw operation shouldn't care if he's throwing it at an enemy,

1228
00:55:32,535 --> 00:55:33,715
a building, or some other object.

1229
00:55:33,976 --> 00:55:36,197
It just needs a location where to throw that boulder.

1230
00:55:38,038 --> 00:55:40,039
Operations shouldn't try to do more than one thing, right?

1231
00:55:40,059 --> 00:55:43,000
They're just, the more they do, the harder it's going to be to be able to

1232
00:55:43,240 --> 00:55:45,442
find situations where you can reuse that operation.

1233
00:55:47,889 --> 00:55:49,710
Operation shouldn't change the world state.

1234
00:55:50,250 --> 00:55:51,611
Going back to our tornado example,

1235
00:55:52,471 --> 00:55:53,432
there are going to be times that you

1236
00:55:53,452 --> 00:55:55,192
want to be able to do a tornado without the troll getting

1237
00:55:55,512 --> 00:55:55,853
tired.

1238
00:55:56,153 --> 00:55:58,714
So we want to keep that world state change out

1239
00:55:58,754 --> 00:55:59,294
of your acting.

1240
00:55:59,714 --> 00:56:00,555
And why do it?

1241
00:56:00,635 --> 00:56:03,856
If our deciding logic gives us a nice way to do this operation,

1242
00:56:04,316 --> 00:56:06,117
why hide the state change from the person

1243
00:56:06,157 --> 00:56:08,798
looking at your decision logic or your decision structure?

1244
00:56:13,320 --> 00:56:16,422
So for evolve, our acting is the number of BT nodes.

1245
00:56:21,219 --> 00:56:23,702
And what we ended up doing was refactoring a whole bunch of them,

1246
00:56:23,923 --> 00:56:27,387
ripping out the sensing logic and deciding logic out of those acting nodes.

1247
00:56:28,068 --> 00:56:31,413
And if we didn't do that, we just made new nodes that just really focus on acting.

1248
00:56:31,713 --> 00:56:34,036
This gave us smaller and simpler building blocks to work with

1249
00:56:34,437 --> 00:56:35,678
going forward with our new characters.

1250
00:56:37,833 --> 00:56:40,335
The last responsibility is deciding, right?

1251
00:56:40,375 --> 00:56:42,376
This is where we make decisions, or better put,

1252
00:56:42,396 --> 00:56:45,519
this is where we translate world state into action, right?

1253
00:56:45,939 --> 00:56:47,500
It's the behavior systems that we use.

1254
00:56:47,560 --> 00:56:50,663
It's HTN, GOAP, behavior trees, finite state machines,

1255
00:56:51,383 --> 00:56:52,164
kind of, right?

1256
00:56:52,224 --> 00:56:54,806
This is typically the structural part of those systems, right?

1257
00:56:54,846 --> 00:56:57,248
It's the tree structure of behavior trees and HTN.

1258
00:56:57,708 --> 00:56:59,490
It's the graph structure of our finite state machines

1259
00:56:59,550 --> 00:57:01,751
and GOAP, or the priorities of a utility-based system.

1260
00:57:02,949 --> 00:57:05,490
Some guidelines to keep in mind when you're building your deciding logic.

1261
00:57:06,291 --> 00:57:07,271
Deciding should be fast.

1262
00:57:07,651 --> 00:57:08,892
That's hard to argue, but I mean,

1263
00:57:08,912 --> 00:57:12,554
if you want to be able to react to changes in role state as soon as possible.

1264
00:57:12,594 --> 00:57:15,455
So try to keep all the heavy lifting outside of your decision system.

1265
00:57:16,376 --> 00:57:20,758
Deciding should also allow us to define the conditions required to execute operations

1266
00:57:21,198 --> 00:57:23,239
and the effects on succeeding those operations.

1267
00:57:24,700 --> 00:57:25,961
It also should be fast to edit.

1268
00:57:26,021 --> 00:57:27,602
And I don't mean you need an editor, right?

1269
00:57:27,622 --> 00:57:31,163
You just need some clear way of defining your structures and your deciding logic.

1270
00:57:32,288 --> 00:57:34,550
For Evolve, we use a behavior tree described in Bill Merrill's

1271
00:57:35,291 --> 00:57:36,332
Game AI Pro article.

1272
00:57:36,532 --> 00:57:38,334
It's now free on the website.

1273
00:57:38,834 --> 00:57:39,455
It's a great article.

1274
00:57:39,475 --> 00:57:40,476
You should definitely go check it out.

1275
00:57:40,856 --> 00:57:42,638
Luckily, we didn't need to change this at all.

1276
00:57:42,658 --> 00:57:43,318
It just worked.

1277
00:57:43,338 --> 00:57:44,619
We just had to change a lot of the nodes

1278
00:57:44,659 --> 00:57:45,540
and the sensing logic.

1279
00:57:47,602 --> 00:57:49,764
So something I haven't talked about is our blueprints.

1280
00:57:50,384 --> 00:57:53,307
Evolve uses blueprints to have one location where

1281
00:57:53,327 --> 00:57:54,308
they can set up a character.

1282
00:57:54,828 --> 00:57:56,350
This is the integration step that Chris

1283
00:57:56,370 --> 00:57:57,270
was talking about earlier.

1284
00:57:58,195 --> 00:58:00,396
Here we load our designer-treatable data.

1285
00:58:00,776 --> 00:58:03,037
We define our blackboards and install our whiteboards.

1286
00:58:03,357 --> 00:58:04,797
We install the other different components

1287
00:58:04,817 --> 00:58:06,878
that make up that character, their sensors,

1288
00:58:06,898 --> 00:58:08,379
their behavior trees, things like that.

1289
00:58:09,079 --> 00:58:13,061
And as we install our sensors and build our BTs,

1290
00:58:13,321 --> 00:58:14,862
this is where we're going to do all our wire work.

1291
00:58:14,922 --> 00:58:16,422
We're going to tell the sensors where

1292
00:58:16,442 --> 00:58:17,843
to dump their data in the blackboard.

1293
00:58:17,903 --> 00:58:20,204
We're going to tell our decision tree what

1294
00:58:20,384 --> 00:58:22,585
blackboard variables, or behavior tree,

1295
00:58:23,105 --> 00:58:24,526
what blackboard variables to look at.

1296
00:58:28,151 --> 00:58:29,712
This was an incredibly important step to us.

1297
00:58:29,732 --> 00:58:33,594
Like, this is where we were able to build our new system

1298
00:58:33,634 --> 00:58:34,834
side by side our own system.

1299
00:58:36,295 --> 00:58:37,856
If the AI was a blueprint AI,

1300
00:58:38,076 --> 00:58:40,437
we had a whole different initialization call stack

1301
00:58:40,477 --> 00:58:40,917
to run through.

1302
00:58:41,198 --> 00:58:43,279
If they weren't, it went through the old legacy systems.

1303
00:58:43,639 --> 00:58:44,719
And once we had this set up,

1304
00:58:45,059 --> 00:58:47,020
we could quickly start using the new systems

1305
00:58:47,061 --> 00:58:48,981
without worrying about breaking any of our legacy code.

1306
00:58:51,064 --> 00:58:52,986
So, let's talk about the different architectures

1307
00:58:53,507 --> 00:58:55,850
and how they would kind of fit in these areas of responsibility

1308
00:58:56,250 --> 00:58:57,712
because we all don't use the same things.

1309
00:58:58,353 --> 00:59:00,896
And hopefully you're already kind of thinking about your own systems at home,

1310
00:59:01,437 --> 00:59:02,718
how they would fit into this stuff.

1311
00:59:02,858 --> 00:59:04,721
Maybe you're finding some that are crossing these boundaries

1312
00:59:04,761 --> 00:59:05,562
that are giving you trouble.

1313
00:59:06,863 --> 00:59:09,366
So for Evolve, we use our behavior training.

1314
00:59:09,386 --> 00:59:10,508
We've already kind of talked about this.

1315
00:59:11,138 --> 00:59:13,139
So for our sensing, we'll use our sensor manager.

1316
00:59:13,199 --> 00:59:16,301
We have our surrounded sensor, maybe enemy distance sensor,

1317
00:59:16,321 --> 00:59:16,922
things like that.

1318
00:59:17,402 --> 00:59:20,224
For our deciding, our behavior tree is going to live there.

1319
00:59:20,744 --> 00:59:22,125
But if you look, the nodes that we're

1320
00:59:22,325 --> 00:59:24,046
going to be putting in this area are just

1321
00:59:24,086 --> 00:59:26,427
the ones that help define the structure of the behavior tree.

1322
00:59:26,507 --> 00:59:29,409
It's our selectors, our sequencers, and our decorators.

1323
00:59:30,190 --> 00:59:32,812
for acting is basically the rest of our behavior tree nodes.

1324
00:59:32,872 --> 00:59:34,433
Anything that actually does things, right?

1325
00:59:34,453 --> 00:59:37,776
The fire node, reload, animated attack, navigate to.

1326
00:59:38,677 --> 00:59:40,739
The world state's gonna have our blackboard and whiteboard.

1327
00:59:41,079 --> 00:59:42,200
And if you were to follow the data,

1328
00:59:42,340 --> 00:59:43,321
how it flows through this,

1329
00:59:43,641 --> 00:59:45,302
our sensory manager and our sensing logic

1330
00:59:45,342 --> 00:59:47,885
are gonna populate things in our world state.

1331
00:59:48,305 --> 00:59:50,006
It also might reference some of that stuff

1332
00:59:50,026 --> 00:59:51,267
to help to do more sensing.

1333
00:59:52,143 --> 00:59:55,365
our behavior tree is going to pull data from our blackboard

1334
00:59:55,985 --> 00:59:56,805
in order to make decisions.

1335
00:59:56,865 --> 00:59:59,047
And on the completion of different nodes,

1336
00:59:59,267 --> 01:00:02,308
it might apply different changes to that blackboard as well.

1337
01:00:04,309 --> 01:00:05,610
And then when our acting is running,

1338
01:00:05,650 --> 01:00:07,511
our behavior is running, it's going to pull all the data,

1339
01:00:07,571 --> 01:00:09,072
whether from the blackboard or the whiteboard,

1340
01:00:09,812 --> 01:00:11,813
in order to make those behaviors work.

1341
01:00:13,130 --> 01:00:14,953
If we're going to do this with an HTN planner,

1342
01:00:14,973 --> 01:00:17,736
and very similarly a GOAT planner,

1343
01:00:18,878 --> 01:00:20,179
sensing kind of works the same.

1344
01:00:21,241 --> 01:00:23,223
For deciding for HTN domain, we'd

1345
01:00:23,263 --> 01:00:24,605
have a different kind of structure here.

1346
01:00:24,685 --> 01:00:27,108
Our compound task is going to help define the hierarchical

1347
01:00:27,128 --> 01:00:28,169
structure of our domain.

1348
01:00:28,750 --> 01:00:34,052
while the primitive task is going to help define the conditions and effects in order to run the acting operations.

1349
01:00:34,933 --> 01:00:41,456
HCN uses operators, so the operators are all sitting in our acting side and the data flow is going to work roughly the same.

1350
01:00:42,316 --> 01:00:46,758
The world state, they actually use a world state, which is a very simple representation to do their planning.

1351
01:00:48,100 --> 01:00:50,081
Finance state machines, a little trickier.

1352
01:00:50,921 --> 01:00:52,862
Basically what we'd want to do is have a finance state machine

1353
01:00:52,902 --> 01:00:56,123
that kind of goes over both sensing and deciding.

1354
01:00:56,563 --> 01:00:58,424
But the states that...

1355
01:00:59,164 --> 01:01:00,725
But we'll have states specifically designed

1356
01:01:00,765 --> 01:01:02,586
to help sensing data, help collecting that data.

1357
01:01:02,966 --> 01:01:04,106
And then the other states would kind of work

1358
01:01:04,126 --> 01:01:05,907
like a typical finance state machine.

1359
01:01:06,487 --> 01:01:07,968
But what we want to do with those states

1360
01:01:08,128 --> 01:01:09,989
is kind of treat those as wrappers

1361
01:01:10,069 --> 01:01:11,670
to the operator concept

1362
01:01:11,690 --> 01:01:13,310
that we're going to borrow from the HTN stuff.

1363
01:01:13,690 --> 01:01:15,731
So if you look, we have a navigate to enemy state.

1364
01:01:16,452 --> 01:01:18,594
this thing will help define the transitions to other states

1365
01:01:18,634 --> 01:01:21,777
and the data to supply to the NavigateTo operator.

1366
01:01:22,918 --> 01:01:24,599
I still think a world state's a great thing to have

1367
01:01:24,679 --> 01:01:25,580
in a finite state machine.

1368
01:01:25,881 --> 01:01:28,503
It gives you a nice snapshot with everything

1369
01:01:28,543 --> 01:01:30,005
that the AI understands at that point,

1370
01:01:30,285 --> 01:01:32,687
and you can base all your transition stuff

1371
01:01:32,787 --> 01:01:34,028
off this lot of data anyway.

1372
01:01:35,427 --> 01:01:40,494
So, in conclusion, modular systems doesn't really quite mean you're making modular characters.

1373
01:01:41,195 --> 01:01:44,640
Even though you're using a modular system, it may be implementing those modular pieces

1374
01:01:44,981 --> 01:01:46,704
in a very unmodular way.

1375
01:01:47,762 --> 01:01:49,444
should really think in terms of responsibilities.

1376
01:01:50,004 --> 01:01:51,566
When you find something that isn't modular,

1377
01:01:51,586 --> 01:01:53,408
I guarantee you, you've got some sensing

1378
01:01:53,428 --> 01:01:55,430
and you're deciding, or some deciding and you're acting.

1379
01:01:56,070 --> 01:01:57,812
Crossing that responsibility boundary

1380
01:01:57,832 --> 01:01:59,314
is a sure way to shoot yourself in the foot.

1381
01:02:00,395 --> 01:02:02,196
Look for the friction in your system and improve it.

1382
01:02:02,577 --> 01:02:04,679
Make it easy to do your sensing work in the right place.

1383
01:02:04,739 --> 01:02:06,981
Make it easy to do your deciding work in the right place.

1384
01:02:07,061 --> 01:02:08,763
Make it easy to do your acting work in the right place.

1385
01:02:09,724 --> 01:02:11,725
You don't need to start a new project or new code to do it.

1386
01:02:12,265 --> 01:02:15,687
We were able to do it with a live game while making DLC.

1387
01:02:16,827 --> 01:02:19,969
And we're already seeing the benefits from this refactor.

1388
01:02:22,430 --> 01:02:23,090
And you can do this.

1389
01:02:24,111 --> 01:02:26,152
Thanks a lot to Kevin and Chris for all their help,

1390
01:02:26,212 --> 01:02:28,833
and Justin Cherry for the art, and my teams.

1391
01:02:29,233 --> 01:02:29,473
Thank you.

