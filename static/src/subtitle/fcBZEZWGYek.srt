1
00:00:05,560 --> 00:00:07,802
I would like to thank everybody for attending this talk.

2
00:00:07,802 --> 00:00:10,363
There are a lot of great opportunities out there

3
00:00:10,363 --> 00:00:11,864
and I'm flattered that you're here.

4
00:00:11,864 --> 00:00:15,126
I'll let you know that there are a couple of bonus slides

5
00:00:15,126 --> 00:00:16,407
at the end of this presentation

6
00:00:16,407 --> 00:00:17,828
that I won't have time to cover.

7
00:00:17,828 --> 00:00:21,070
However, this talk and its slides will be available

8
00:00:21,070 --> 00:00:23,611
on the GDC Vault.

9
00:00:23,611 --> 00:00:25,152
Or you can just reach out to me directly

10
00:00:25,152 --> 00:00:26,393
if you're interested.

11
00:00:26,393 --> 00:00:28,314
And also, please don't forget to fill out

12
00:00:28,314 --> 00:00:29,955
your evaluation forms at the end.

13
00:00:29,955 --> 00:00:32,296
I'm pretty sure I need the feedback.

14
00:00:32,296 --> 00:00:32,336
So.

15
00:00:35,698 --> 00:00:38,259
Now that you are here, whether intentional

16
00:00:38,259 --> 00:00:40,779
or you just realized that you're in the wrong room,

17
00:00:40,779 --> 00:00:43,920
you're most likely wondering who the hell is this guy?

18
00:00:43,920 --> 00:00:45,321
Well, my name is Peter Dalton

19
00:00:45,321 --> 00:00:48,742
and I am the technical director for Blue Point Games.

20
00:00:48,742 --> 00:00:50,442
As you can tell from the gray in my beard,

21
00:00:50,442 --> 00:00:52,263
I've been around for a little while.

22
00:00:52,263 --> 00:00:56,384
I've been working in the games industry for over 18 years

23
00:00:56,384 --> 00:00:57,785
and I will never leave.

24
00:00:57,785 --> 00:01:01,366
I love my job, I love the insanely hard problems,

25
00:01:01,366 --> 00:01:03,566
and I love the talented people that I'm surrounded by.

26
00:01:04,591 --> 00:01:07,513
Over the 11 plus titles that I have shipped,

27
00:01:07,513 --> 00:01:10,335
my specialties revolve around core engine development,

28
00:01:10,335 --> 00:01:12,837
streaming, memory, performance.

29
00:01:12,837 --> 00:01:14,338
I like to believe that it is my job

30
00:01:14,338 --> 00:01:16,020
to basically make shit happen.

31
00:01:16,020 --> 00:01:16,060
So.

32
00:01:20,110 --> 00:01:23,012
Bluepoint Games, perhaps you've heard of us,

33
00:01:23,012 --> 00:01:25,173
the masters of the remaster.

34
00:01:25,173 --> 00:01:29,135
I have to thank Digital Foundry for that title.

35
00:01:29,135 --> 00:01:32,658
Seriously, the Digital Foundry guys are amazing.

36
00:01:32,658 --> 00:01:34,258
Their technical reviews are spot on,

37
00:01:34,258 --> 00:01:36,660
and Bluepoint is tired of me ranting

38
00:01:36,660 --> 00:01:40,062
about how our frame rate and frame pacing must be perfect,

39
00:01:40,062 --> 00:01:42,003
or Digital Foundry will call us out.

40
00:01:42,003 --> 00:01:46,366
Bluepoint has made a name for itself by remastering games,

41
00:01:46,366 --> 00:01:48,868
many of which I'm hoping you've heard of.

42
00:01:49,641 --> 00:01:54,045
We've been blessed to work with titles that we absolutely love, and from my perspective,

43
00:01:54,045 --> 00:01:58,970
it is insanely awesome that I get to see exactly how these games were made.

44
00:01:58,970 --> 00:02:04,656
At Bluepoint, there are two primary ideals that I try to promote,

45
00:02:04,656 --> 00:02:07,499
with number one being, quality is the foundation of success.

46
00:02:08,460 --> 00:02:11,481
I believe that it is absolutely true for our industry.

47
00:02:11,481 --> 00:02:14,703
If you want long-term sustained success,

48
00:02:14,703 --> 00:02:16,783
you must have quality to feed it.

49
00:02:16,783 --> 00:02:20,025
And number two, every project that we release

50
00:02:20,025 --> 00:02:22,686
must be better than our previous release.

51
00:02:22,686 --> 00:02:25,367
And hopefully you can see this by looking at the titles

52
00:02:25,367 --> 00:02:26,448
at our past projects.

53
00:02:27,694 --> 00:02:31,736
The depth at which we remaster projects has grown exponentially.

54
00:02:31,736 --> 00:02:34,877
Starting with the God of War collection, which involved texture cleanup,

55
00:02:34,877 --> 00:02:39,600
to the Uncharted collection, which involved all aspects of the game being modified.

56
00:02:39,600 --> 00:02:43,101
In fact, for Shadow, we don't call it a remaster.

57
00:02:43,101 --> 00:02:44,422
We coin it a...

58
00:02:44,422 --> 00:02:46,023
remake.

59
00:02:47,343 --> 00:02:49,045
given the complexity of the project.

60
00:02:49,045 --> 00:02:51,187
And moving forward to our next project,

61
00:02:51,187 --> 00:02:53,049
we coin it a re-envisioning,

62
00:02:53,049 --> 00:02:54,911
given that it goes well beyond

63
00:02:54,911 --> 00:02:57,253
what we even thought was possible in Shadow.

64
00:02:57,253 --> 00:03:02,058
Now I wanna take a minute to show you a video

65
00:03:02,058 --> 00:03:03,199
from PSX 2017,

66
00:03:03,199 --> 00:03:06,122
showing a comparison between the original Shadow

67
00:03:06,122 --> 00:03:07,683
and the PS4 remake,

68
00:03:07,683 --> 00:03:09,365
to give you a better sense of what we do.

69
00:04:39,193 --> 00:04:39,657
you

70
00:05:01,645 --> 00:05:08,289
I feel that it is important that people understand a couple of our overarching goals that we

71
00:05:08,289 --> 00:05:10,831
take into each remastering project.

72
00:05:10,831 --> 00:05:15,013
Number one, we have to be true to the design of the original game.

73
00:05:15,013 --> 00:05:19,436
Number two, we have to respect the decisions of the original game team.

74
00:05:19,436 --> 00:05:23,479
And number three, we must not lose the magic of the original game.

75
00:05:23,479 --> 00:05:28,142
And if you say to yourself, I can't find the magic in the original, then what the hell

76
00:05:28,142 --> 00:05:28,802
are you doing?

77
00:05:29,593 --> 00:05:35,381
And number four, we have to acknowledge that it is rarely a black and white answer for

78
00:05:35,381 --> 00:05:39,247
what we do, and as a result, there will be lots of internal debates.

79
00:05:39,247 --> 00:05:43,693
These debates are good and healthy, and most importantly, they show passion.

80
00:05:44,727 --> 00:05:47,848
To help explain our thought process, I like to use an analogy.

81
00:05:47,848 --> 00:05:52,251
As a kid growing up, I used to love watching cartoons.

82
00:05:52,251 --> 00:05:53,772
Who didn't?

83
00:05:53,772 --> 00:05:56,414
I'm sure if you think about it, you had your favorites,

84
00:05:56,414 --> 00:05:59,636
certain shows that stand out in your memories.

85
00:05:59,636 --> 00:06:03,918
Well, in my case, I loved Thundercats and have fond memories.

86
00:06:03,918 --> 00:06:05,859
However, if I go back and watch them now

87
00:06:05,859 --> 00:06:07,400
or try to show them to my kids,

88
00:06:07,400 --> 00:06:09,902
they aren't anything like I remember.

89
00:06:10,482 --> 00:06:14,083
What we're trying to do is bring those memories back to life

90
00:06:14,083 --> 00:06:16,983
and enable others to have similar experiences.

91
00:06:16,983 --> 00:06:20,484
We're trying to recreate the game the original game developer

92
00:06:20,484 --> 00:06:23,945
would have released if they had the technology that we have today.

93
00:06:23,945 --> 00:06:28,206
So, let's take a technical look at the development process

94
00:06:28,206 --> 00:06:31,546
that we use at Bluepoint when remastering a title.

95
00:06:31,546 --> 00:06:34,507
Besides determining whether or not it makes business sense

96
00:06:34,507 --> 00:06:37,887
to remaster a game, there are several key factors that must be considered.

97
00:06:37,887 --> 00:06:38,147
Number one.

98
00:06:40,735 --> 00:06:45,039
We absolutely must have the access to the release package.

99
00:06:45,039 --> 00:06:47,141
For Shadow, this was the final package

100
00:06:47,141 --> 00:06:49,523
that was delivered to Sony for distribution.

101
00:06:49,523 --> 00:06:51,985
This should include all patches, back-end servers.

102
00:06:51,985 --> 00:06:54,748
Basically, we need to be able to run

103
00:06:54,748 --> 00:06:56,089
the retail project in-house.

104
00:06:56,850 --> 00:07:02,437
And number two, we require all the final source code required to rebuild the game's final binaries.

105
00:07:02,437 --> 00:07:03,839
Now, there are exceptions.

106
00:07:03,839 --> 00:07:05,601
We can work around miscellaneous systems.

107
00:07:05,601 --> 00:07:11,268
For example, if we are missing an audio library, chances are we're going to replace the entire system.

108
00:07:11,268 --> 00:07:11,728
So, no biggie.

109
00:07:12,449 --> 00:07:14,772
However, if we are missing gameplay code,

110
00:07:14,772 --> 00:07:17,094
it quickly becomes cost prohibitive

111
00:07:17,094 --> 00:07:19,737
to reverse engineer those libraries.

112
00:07:19,737 --> 00:07:23,642
Other examples include server code, if required as a bonus.

113
00:07:23,642 --> 00:07:25,985
However, we can work around not having it.

114
00:07:25,985 --> 00:07:27,126
Tool pipeline code.

115
00:07:28,307 --> 00:07:34,650
is a bonus. However, we usually don't build our processes around legacy tools and primarily

116
00:07:34,650 --> 00:07:39,133
only use them for reference. And finally, any source assets that were used to build

117
00:07:39,133 --> 00:07:43,816
the original final distribution package is a bonus, but not mandatory.

118
00:07:44,796 --> 00:07:49,239
So, looking at the development process that we go through, the goal for the first month

119
00:07:49,239 --> 00:07:54,862
is to obtain all the required pieces and to rebuild the game's binaries for the original

120
00:07:54,862 --> 00:07:56,283
target platform.

121
00:07:56,283 --> 00:08:00,946
We then send this build to our internal QA and run a whole suite of parity tests.

122
00:08:01,606 --> 00:08:06,390
I should call out that it is critical to the success of the project that we get these first

123
00:08:06,390 --> 00:08:07,271
steps correct.

124
00:08:07,271 --> 00:08:12,615
Small errors here will be magnified as we get into full development, leading to wasted

125
00:08:12,615 --> 00:08:14,577
time and incorrect decisions being made.

126
00:08:14,577 --> 00:08:19,441
Here we feel that taking time to ensure correctness is preparing for success.

127
00:08:20,449 --> 00:08:25,571
Moving forward, once we have parity, we upgrade the original title to its latest SDK to make

128
00:08:25,571 --> 00:08:28,292
life easier, then rerun all parity tests.

129
00:08:28,292 --> 00:08:33,894
Basically, we make incremental changes and verify parity through all steps.

130
00:08:34,762 --> 00:08:36,605
Take Shadow, for example.

131
00:08:36,605 --> 00:08:38,387
Very early on, we decided that we

132
00:08:38,387 --> 00:08:42,612
were going to use the remastered PS3 version as our base.

133
00:08:42,612 --> 00:08:45,976
At that point, QA ran extensive parity tests

134
00:08:45,976 --> 00:08:49,040
between the PS2 and the PS3 version,

135
00:08:49,040 --> 00:08:51,603
combed old bug databases, searched the web for user

136
00:08:51,603 --> 00:08:53,085
feedback, et cetera.

137
00:08:53,085 --> 00:08:53,566
Concurrently,

138
00:08:54,307 --> 00:08:58,773
Engineering got the game up and running on the PS3, converted to the latest SDKs,

139
00:08:58,773 --> 00:09:04,141
we localized all Japanese code comments, rearranged code libraries to make us happy,

140
00:09:04,141 --> 00:09:08,648
and then re-ran all parity tests, and we fixed the issues before moving forward.

141
00:09:09,309 --> 00:09:14,814
At Bluepoint, every developer at their desk has full access to our target platform,

142
00:09:14,814 --> 00:09:21,380
which for Shadow was a PS4, and the original game, which in this case was a PS3 dev kit.

143
00:09:21,380 --> 00:09:26,125
Programmers are expected to debug and play the game on the PS3 dev kit

144
00:09:26,125 --> 00:09:31,350
to determine original code intent and purpose and to diagnose parity issues.

145
00:09:31,350 --> 00:09:33,272
We do the same thing for all other departments.

146
00:09:33,952 --> 00:09:39,717
ART always has full access to both platforms and are expected to be familiar with both.

147
00:09:39,717 --> 00:09:44,341
And in the case of Shadow, QA went the extra mile and threw the PS2 into the mix.

148
00:09:45,333 --> 00:09:48,735
Only after parity is verified do we start porting the code

149
00:09:48,735 --> 00:09:50,856
to the target platform.

150
00:09:50,856 --> 00:09:54,038
Porting is usually a one to two man project

151
00:09:54,038 --> 00:09:56,799
that takes approximately two to three weeks

152
00:09:56,799 --> 00:09:58,720
before we have the code compiling.

153
00:09:58,720 --> 00:10:00,621
During this phase, we are more interested

154
00:10:00,621 --> 00:10:03,683
in just getting everything to compile on the new platform,

155
00:10:03,683 --> 00:10:05,104
not porting it.

156
00:10:05,104 --> 00:10:07,525
Basically, we try not to lie to ourselves

157
00:10:07,525 --> 00:10:09,606
and pretend that we know how everything works,

158
00:10:09,606 --> 00:10:11,287
and instead we're using this time

159
00:10:11,287 --> 00:10:13,648
to familiarize ourselves with the code base.

160
00:10:14,229 --> 00:10:17,030
We create pound defines to disable whole systems,

161
00:10:17,030 --> 00:10:19,672
markup changes we have made to the original code,

162
00:10:19,672 --> 00:10:22,813
with the most important goals being number one,

163
00:10:22,813 --> 00:10:24,755
to get the code to compile and link,

164
00:10:24,755 --> 00:10:26,636
which is harder than it sounds,

165
00:10:26,636 --> 00:10:29,337
and number two, make it trivial to identify

166
00:10:29,337 --> 00:10:31,138
where we have modified original code.

167
00:10:34,237 --> 00:10:36,139
So, congratulations.

168
00:10:36,139 --> 00:10:39,302
After about two months, you have a binary

169
00:10:39,302 --> 00:10:41,964
that you can launch on your target platform.

170
00:10:41,964 --> 00:10:44,006
Not only did you get the game to compile,

171
00:10:44,006 --> 00:10:47,589
you got it to link, which was a huge pain in the ass.

172
00:10:47,589 --> 00:10:50,171
But you can't help but want to play the game,

173
00:10:50,171 --> 00:10:53,154
so you hit run and boom.

174
00:10:54,269 --> 00:10:55,449
Everything blows up.

175
00:10:55,449 --> 00:10:58,870
In fact, the breakpoint that you put at main never got hit.

176
00:10:58,870 --> 00:11:00,311
You blew up during preeminent.

177
00:11:00,311 --> 00:11:03,072
The call stack doesn't make any sense,

178
00:11:03,072 --> 00:11:05,953
and everything feels broken.

179
00:11:05,953 --> 00:11:08,154
Memory is being requested.

180
00:11:08,154 --> 00:11:11,596
You have 32 to 64-bit compatibility issues.

181
00:11:11,596 --> 00:11:14,677
Plenty of code assumptions that a pointer fits in a uint32.

182
00:11:16,570 --> 00:11:18,711
And resource files are being requested.

183
00:11:18,711 --> 00:11:21,112
In fact, where the hell is the file system?

184
00:11:21,112 --> 00:11:23,913
And you have Indian issues everywhere.

185
00:11:23,913 --> 00:11:27,474
And how do you deal with memory map files

186
00:11:27,474 --> 00:11:28,494
that assume a 32-bit pointer?

187
00:11:28,494 --> 00:11:31,215
At this point, you can't help but wonder

188
00:11:31,215 --> 00:11:33,335
what you've gotten yourself into,

189
00:11:33,335 --> 00:11:35,076
and does it make sense to assign this task

190
00:11:35,076 --> 00:11:36,657
to another engineer?

191
00:11:36,657 --> 00:11:38,477
At this point, I must tell myself

192
00:11:38,477 --> 00:11:40,798
to stop being a little bitch and just keep pushing forward.

193
00:11:43,779 --> 00:11:47,641
So, given that the first step is just to get the game to compile on the target platform,

194
00:11:47,641 --> 00:11:51,044
the next step is to get the game to main and then to the main loop.

195
00:11:51,044 --> 00:11:55,426
The main loop will be pretty much commented out at this point, however, our goal is to

196
00:11:55,426 --> 00:11:59,269
get the game running, displaying nothing but a black screen.

197
00:11:59,269 --> 00:12:02,090
Getting to a black screen is a critical milestone for us.

198
00:12:02,090 --> 00:12:06,353
It is really the point at which the entire team of engineers can really start piling

199
00:12:06,353 --> 00:12:09,855
onto the project and looking at their respective domains.

200
00:12:10,900 --> 00:12:15,307
it is the point at which momentum really starts to pick up.

201
00:12:15,307 --> 00:12:16,589
So I want to stop for a second,

202
00:12:16,589 --> 00:12:19,152
and I want to share a little bit of Bluepoint history.

203
00:12:19,152 --> 00:12:21,356
With all the projects that we've worked on

204
00:12:21,356 --> 00:12:23,078
before Shadow of the Colossus,

205
00:12:24,590 --> 00:12:27,632
We would work within the realm of the original code base.

206
00:12:27,632 --> 00:12:30,333
We would rewrite low-level platform code

207
00:12:30,333 --> 00:12:32,254
to work on the new target platform.

208
00:12:32,254 --> 00:12:34,035
We would build a new rendering system

209
00:12:34,035 --> 00:12:36,456
to handle the needs of the game.

210
00:12:36,456 --> 00:12:38,117
Tools and processes would be adapted

211
00:12:38,117 --> 00:12:40,658
to closely fit those of the original development team.

212
00:12:41,278 --> 00:12:43,319
The problem was that with every new project,

213
00:12:43,319 --> 00:12:45,980
it felt like we were completely starting over.

214
00:12:45,980 --> 00:12:49,241
Code would end up being very tied to a specific title

215
00:12:49,241 --> 00:12:51,742
and thus not move from project to project.

216
00:12:51,742 --> 00:12:53,963
The team, art, engineering, including QA,

217
00:12:53,963 --> 00:12:58,685
all needed to relearn processes

218
00:12:58,685 --> 00:13:00,205
as we moved from game to game.

219
00:13:01,065 --> 00:13:05,248
Basically, it started to conflict with our ideal that each project needs to be better

220
00:13:05,248 --> 00:13:06,669
than the previous.

221
00:13:06,669 --> 00:13:10,631
So for Shadow of the Colossus, we completely revamped how we work.

222
00:13:10,631 --> 00:13:15,374
We made a point of building reusable technology and processes that evolve from project to

223
00:13:15,374 --> 00:13:17,235
project rather than being recreated.

224
00:13:17,235 --> 00:13:23,379
This requires a deeper commitment to processes and long-term planning rather than just solely

225
00:13:23,379 --> 00:13:25,060
focusing on immediate goals.

226
00:13:26,112 --> 00:13:29,094
So we took our Bluepoint engine, dusted it off,

227
00:13:29,094 --> 00:13:31,235
and started to make a major investment.

228
00:13:31,235 --> 00:13:33,977
For reference, the Bluepoint engine is a proprietary engine

229
00:13:33,977 --> 00:13:36,018
and has been around for quite a while.

230
00:13:36,018 --> 00:13:38,079
In fact, it has been licensed and used

231
00:13:38,079 --> 00:13:41,141
to ship several titles, however it was time for it to evolve.

232
00:13:42,363 --> 00:13:45,445
Now, getting back to the goal of getting the game running.

233
00:13:45,445 --> 00:13:48,767
We achieve this goal by merging the original code

234
00:13:48,767 --> 00:13:50,128
with the Bluepoint Engine.

235
00:13:50,128 --> 00:13:52,350
Basically, we structure the code libraries

236
00:13:52,350 --> 00:13:54,211
so that the original game is built

237
00:13:54,211 --> 00:13:55,812
on top of the Bluepoint Engine.

238
00:13:55,812 --> 00:13:58,154
This allows the Bluepoint Engine to provide

239
00:13:58,154 --> 00:14:02,197
all platform-centric systems, such as memory, threading,

240
00:14:02,197 --> 00:14:04,198
file I O, rendering, et cetera.

241
00:14:04,939 --> 00:14:10,306
For us, it is key to keep in mind which original game systems we want to port to the target

242
00:14:10,306 --> 00:14:13,951
platforms and which ones will be replaced by Bluepoint systems.

243
00:14:13,951 --> 00:14:17,956
Basically, we don't want to waste time porting a system that will just be replaced in the

244
00:14:17,956 --> 00:14:18,377
future.

245
00:14:19,143 --> 00:14:23,426
With that said, I think it is important to make one clarification.

246
00:14:23,426 --> 00:14:28,290
When it comes to gameplay systems, AI, character logic, etc.,

247
00:14:28,290 --> 00:14:32,393
we want to keep all of the original systems intact.

248
00:14:32,393 --> 00:14:35,316
While we will fully replace core systems,

249
00:14:35,316 --> 00:14:40,520
with gameplay we take a much more surgical approach to fixing and enhancing.

250
00:14:43,205 --> 00:14:48,108
Next, I want to take a minute to discuss Bluepoint's approach to game assets.

251
00:14:48,108 --> 00:14:52,270
While it is ideal that we get the source assets from the original game team,

252
00:14:52,270 --> 00:14:56,372
and we do to varying levels of success, we do not depend upon them.

253
00:14:56,372 --> 00:14:58,093
Rather, we only use them for reference.

254
00:14:58,093 --> 00:15:01,936
The reason that we don't use source assets as a starting point

255
00:15:01,936 --> 00:15:05,058
is that they're often wrong or incomplete.

256
00:15:05,658 --> 00:15:08,401
Teams are notorious for not checking everything

257
00:15:08,401 --> 00:15:10,023
into source control.

258
00:15:10,023 --> 00:15:13,908
Often local file changes or P4 shelf changes

259
00:15:13,908 --> 00:15:15,670
are used to build the final package,

260
00:15:15,670 --> 00:15:18,153
creating very difficult to find parity issues.

261
00:15:18,153 --> 00:15:21,237
This is exaggerated when dealing with patches

262
00:15:21,237 --> 00:15:25,122
as the likelihood of a one-off local change increases.

263
00:15:26,219 --> 00:15:29,540
To eliminate this concern, we spend around two months

264
00:15:29,540 --> 00:15:32,321
extracting all the data within the original distribution

265
00:15:32,321 --> 00:15:36,262
package to BBE-compatible formats.

266
00:15:36,262 --> 00:15:37,802
We also assume that before we ship,

267
00:15:37,802 --> 00:15:41,764
we will have the need to edit every type of data, not just

268
00:15:41,764 --> 00:15:43,464
key file formats.

269
00:15:43,464 --> 00:15:47,325
While this is time consuming, it has several key benefits.

270
00:15:47,325 --> 00:15:49,986
Number one, we know that the data that we have

271
00:15:49,986 --> 00:15:51,746
is exactly the data that's shipped.

272
00:15:52,247 --> 00:15:56,813
And number two, we actually learn a lot about how the game is constructed,

273
00:15:56,813 --> 00:15:59,978
allowing us to make smarter decisions moving forward.

274
00:15:59,978 --> 00:16:03,903
Understanding the content greatly helps us understand the code,

275
00:16:03,903 --> 00:16:07,208
enables us to make decisions that work with the original code,

276
00:16:07,208 --> 00:16:08,390
as opposed to fighting it.

277
00:16:09,304 --> 00:16:15,368
And number three, once we have extracted the key file formats and converted them to BPE formats,

278
00:16:15,368 --> 00:16:19,571
such as models, animations, skeletons, textures, collision data,

279
00:16:19,571 --> 00:16:23,173
these assets are immediately available within our BPE toolset.

280
00:16:23,173 --> 00:16:27,936
And finally, because we are taking full ownership of the data,

281
00:16:29,746 --> 00:16:32,229
We're no longer dependent upon the content pipeline

282
00:16:32,229 --> 00:16:33,430
of the original team.

283
00:16:33,430 --> 00:16:34,691
We don't need their tools,

284
00:16:34,691 --> 00:16:37,074
and we don't need to follow unfamiliar practices.

285
00:16:37,074 --> 00:16:39,156
It is actually quite liberating

286
00:16:39,156 --> 00:16:41,759
that after the extraction is finished,

287
00:16:41,759 --> 00:16:43,941
we follow Bluepoint processes

288
00:16:43,941 --> 00:16:46,103
rather than the processes of a remote team

289
00:16:46,103 --> 00:16:47,164
that we don't understand.

290
00:16:48,272 --> 00:16:57,837
Now, to be completely honest, there are some game-specific file formats that we don't always extract and will take shortcuts.

291
00:16:57,837 --> 00:17:04,061
We do, however, regenerate these files, addressing like Indianness and 64-bit compatibility issues,

292
00:17:04,061 --> 00:17:06,682
and we spend the time to understand and document their purpose.

293
00:17:07,749 --> 00:17:11,293
For example, in Shadow, we did not fully convert

294
00:17:11,293 --> 00:17:13,857
all of the pathing data to BPE formats

295
00:17:13,857 --> 00:17:16,480
because we figured that we would never change this data.

296
00:17:16,480 --> 00:17:18,623
This came back to bite me in the ass,

297
00:17:18,623 --> 00:17:19,765
and I'll tell you more about it later.

298
00:17:22,410 --> 00:17:24,751
So let's take a look at the final results

299
00:17:24,751 --> 00:17:27,212
that we achieved in Shadow in relationship

300
00:17:27,212 --> 00:17:30,654
to how we integrate two distinct engines.

301
00:17:30,654 --> 00:17:33,115
I like to call this the dance.

302
00:17:33,115 --> 00:17:35,116
Without proper planning and coordination,

303
00:17:35,116 --> 00:17:36,817
chaos would take over.

304
00:17:36,817 --> 00:17:38,878
However, with each engine assuming specific

305
00:17:38,878 --> 00:17:43,120
responsibilities, we can create a harmony of technology.

306
00:17:44,635 --> 00:17:46,456
What this diagram is trying to illustrate

307
00:17:46,456 --> 00:17:49,637
is the responsibilities of each engine.

308
00:17:49,637 --> 00:17:53,678
The original shadow engine maintains sole responsibility

309
00:17:53,678 --> 00:17:55,899
for the majority of all gameplay.

310
00:17:55,899 --> 00:17:59,480
If there was a gameplay bug or a behavior

311
00:17:59,480 --> 00:18:01,841
that we wanted to modify, chances are

312
00:18:01,841 --> 00:18:06,382
that we were going to modify the original shadow code base.

313
00:18:06,382 --> 00:18:08,783
On the other side, the Bluepoint engine

314
00:18:08,783 --> 00:18:11,144
handles all core system responsibilities.

315
00:18:12,019 --> 00:18:14,860
memory, threading, platform services,

316
00:18:14,860 --> 00:18:16,020
along with anything visual.

317
00:18:16,020 --> 00:18:18,460
The Bluepoint engine handles the management of the world,

318
00:18:18,460 --> 00:18:20,401
the static geometry in the world,

319
00:18:20,401 --> 00:18:23,522
the particle systems placed, the lighting, et cetera.

320
00:18:23,522 --> 00:18:27,282
It remains the responsibility of the Shadow engine

321
00:18:27,282 --> 00:18:29,423
to create all dynamic game objects,

322
00:18:29,423 --> 00:18:32,243
such as Aggro, Wander, and Colossi,

323
00:18:32,243 --> 00:18:33,924
within the Bluepoint engine

324
00:18:33,924 --> 00:18:35,844
in order to build a complete scene,

325
00:18:35,844 --> 00:18:37,465
which in turn feeds the render.

326
00:18:38,365 --> 00:18:41,227
Take for example Wander, the main character in the game.

327
00:18:41,227 --> 00:18:45,930
The original game has a concept, an object representing Wander,

328
00:18:45,930 --> 00:18:50,072
and also a link to a BP engine representation of Wander.

329
00:18:50,072 --> 00:18:55,255
The original game provides all the simulation logic and pushes matrices

330
00:18:55,255 --> 00:18:58,898
and the required state information over to the Bluepoint representation.

331
00:18:59,658 --> 00:19:03,299
In turn, the Bluepoint representation can add additional functionalities such as head

332
00:19:03,299 --> 00:19:06,220
tracking and drives the render to ensure that everything shows up in the final scene.

333
00:19:06,220 --> 00:19:08,321
So let's take a look at the game and break down a scene starring Colossus 6.

334
00:19:16,532 --> 00:19:18,853
So who is responsible for what?

335
00:19:18,853 --> 00:19:21,874
Shadow is responsible for all dynamic characters

336
00:19:21,874 --> 00:19:24,575
in the scene, in this case, Wander and the Colossus.

337
00:19:24,575 --> 00:19:28,416
Shadow is responsible for AI behaviors.

338
00:19:28,416 --> 00:19:30,596
When QA would report behavioral problems,

339
00:19:30,596 --> 00:19:33,357
we addressed it within the original code base.

340
00:19:33,357 --> 00:19:36,058
Shadow is responsible for collision.

341
00:19:36,058 --> 00:19:38,619
In retrospect, this was perhaps a mistake

342
00:19:38,619 --> 00:19:41,240
and should have been brought over into BPE

343
00:19:41,240 --> 00:19:43,000
in order to make it easier to work with.

344
00:19:43,440 --> 00:19:49,104
And Shadow is responsible for building the animation blend trees and building the final pose.

345
00:19:49,104 --> 00:19:53,286
Shadow has these responsibilities because the simulation is dependent upon the final pose.

346
00:19:53,286 --> 00:19:58,069
It would have been better for us to use BPE systems for animation.

347
00:19:58,069 --> 00:20:02,891
However, at the time, intertwining Shadow and BPE processes was very difficult.

348
00:20:03,914 --> 00:20:07,336
The eye state of the Colossus was determined by shadow code,

349
00:20:07,336 --> 00:20:09,877
passed to BPE code, where it was managed,

350
00:20:09,877 --> 00:20:11,578
used to determine the correct eye color

351
00:20:11,578 --> 00:20:13,999
and drive dynamic shader parameters.

352
00:20:13,999 --> 00:20:17,781
It is the shadow code that handles the simulation

353
00:20:17,781 --> 00:20:20,182
of the bones that hang around Wander's waist.

354
00:20:20,182 --> 00:20:21,983
These were never lifted into BPE,

355
00:20:21,983 --> 00:20:24,365
given that the original coder did such a great job.

356
00:20:25,726 --> 00:20:30,888
So, that is about where the original Shadow Code ends and the BPE engine takes over.

357
00:20:30,888 --> 00:20:33,349
BPE handles all rendering and scene management.

358
00:20:33,349 --> 00:20:38,270
The entire environment and atmospherics that you see are all handled by BPE.

359
00:20:38,270 --> 00:20:42,032
The physics simulation of Wander's poncho is handled by BPE.

360
00:20:44,697 --> 00:20:47,378
It is purely visual and needed improvement,

361
00:20:47,378 --> 00:20:50,059
and thus all aspects were removed from the shadow code

362
00:20:50,059 --> 00:20:52,200
and moved into Bluepoint.

363
00:20:52,200 --> 00:20:54,821
BPE is responsible for the dynamic rings

364
00:20:54,821 --> 00:20:56,522
attached to the colossi.

365
00:20:56,522 --> 00:20:59,083
In the original, the rings are static and misaligned.

366
00:20:59,083 --> 00:21:01,244
They are now dynamic.

367
00:21:01,244 --> 00:21:03,665
And finally, BPE is responsible for all audio

368
00:21:03,665 --> 00:21:05,726
and particles within a scene.

369
00:21:05,726 --> 00:21:07,787
One way to think about our approach

370
00:21:07,787 --> 00:21:10,248
is that we are taking the original game

371
00:21:10,248 --> 00:21:12,849
and overlaying visuals and enhanced gameplay.

372
00:21:15,225 --> 00:21:18,447
Here's another scene with a path node's debug display enabled.

373
00:21:18,447 --> 00:21:21,469
The blue lines simply show available connections

374
00:21:21,469 --> 00:21:23,251
between nodes, while the purple line

375
00:21:23,251 --> 00:21:25,793
shows the navigation path that aggro your horse

376
00:21:25,793 --> 00:21:27,234
will take to get to you.

377
00:21:27,234 --> 00:21:29,115
When we started the game, we figured

378
00:21:29,115 --> 00:21:31,437
that we would not change the layout of the environments

379
00:21:31,437 --> 00:21:34,119
enough that we would have to modify collision.

380
00:21:34,119 --> 00:21:37,161
This game, this became perhaps the biggest lie

381
00:21:37,161 --> 00:21:38,602
that we told ourselves.

382
00:21:38,602 --> 00:21:40,884
Before shipping, all collision within the game

383
00:21:40,884 --> 00:21:41,985
was completely rebuilt.

384
00:21:42,808 --> 00:21:47,710
We also told ourselves that because we were not significantly changing the layout of the environments,

385
00:21:47,710 --> 00:21:50,731
there would be no need for us to modify path information.

386
00:21:50,731 --> 00:21:52,031
This was also a lie.

387
00:21:52,031 --> 00:21:55,313
As the environment started to be finalized,

388
00:21:55,313 --> 00:21:58,754
QA started flagging issues where Agro could no longer path to you

389
00:21:58,754 --> 00:22:01,295
because someone placed a large tree on top of a path node.

390
00:22:02,335 --> 00:22:07,163
In certain areas, Wander could not find lizards because they were now hidden under hills.

391
00:22:07,163 --> 00:22:11,829
In other areas, the hawks and the birds in the game would start flying through mountains

392
00:22:11,829 --> 00:22:13,051
that were now in their paths.

393
00:22:14,155 --> 00:22:16,737
After a bit of digging, it became obvious

394
00:22:16,737 --> 00:22:18,418
that it was not an acceptable solution

395
00:22:18,418 --> 00:22:21,199
to require art to go back and fix the geometry

396
00:22:21,199 --> 00:22:23,161
to match the constraints of the original.

397
00:22:23,161 --> 00:22:25,362
Instead, within the last two months before shipping,

398
00:22:25,362 --> 00:22:27,203
we wrote a tool that allowed for path nodes

399
00:22:27,203 --> 00:22:29,564
to be visualized and edited directly in the game

400
00:22:29,564 --> 00:22:30,865
and serialized back out.

401
00:22:30,865 --> 00:22:33,907
Before this, the pathing logic was the last piece

402
00:22:33,907 --> 00:22:35,728
of untouched code and data.

403
00:22:35,728 --> 00:22:37,969
Well, we didn't necessarily set out to change

404
00:22:37,969 --> 00:22:41,171
every single piece of data loaded by the game.

405
00:22:41,171 --> 00:22:42,092
It became a necessity.

406
00:22:42,957 --> 00:22:46,198
So I guess the moral of the story is to assume

407
00:22:46,198 --> 00:22:48,580
that if something can bite you in the ass, it will.

408
00:22:48,580 --> 00:22:50,801
I think that's a pretty safe mantra

409
00:22:50,801 --> 00:22:52,542
for anyone in engineering.

410
00:22:52,542 --> 00:22:57,885
So Shadow released a year ago this February.

411
00:22:57,885 --> 00:23:00,406
I explicitly don't want this talk to feel like a postmortem,

412
00:23:00,406 --> 00:23:04,108
but more of a sharing of our approach and processes.

413
00:23:04,108 --> 00:23:05,969
My goal is to be completely transparent

414
00:23:05,969 --> 00:23:08,411
and share what worked and where we fell short.

415
00:23:09,071 --> 00:23:12,834
Well, on Shadow, we had a fairly sophisticated worker job system.

416
00:23:12,834 --> 00:23:17,437
We were not able to retrofit enough code to take full advantage of it.

417
00:23:17,437 --> 00:23:23,522
We had this notion of the Shadow code completing its full simulation before moving on to handling

418
00:23:23,522 --> 00:23:24,743
BPE game objects.

419
00:23:26,155 --> 00:23:31,257
The CPU frame was broken up so that Shadow took approximately 70% of the game frame,

420
00:23:31,257 --> 00:23:34,359
and the Bluepoint engine took about the other 30%.

421
00:23:34,359 --> 00:23:40,882
We could find areas to optimize Shadow code by jobifying, however, this basically just

422
00:23:40,882 --> 00:23:49,026
moved code from one core to another and really, without really increasing the CPU saturation.

423
00:23:49,026 --> 00:23:52,447
As a result, we did not get much parallelization within the game code.

424
00:23:53,522 --> 00:23:58,105
Within the Bluepoint Engine, we represent a scene as a tree of game objects,

425
00:23:58,105 --> 00:24:01,708
where each game object contains components that exposes functionality.

426
00:24:01,708 --> 00:24:06,352
To update a scene, we would walk the game object tree and update all components.

427
00:24:06,352 --> 00:24:11,396
The overhead of walking the tree quickly became time-consuming.

428
00:24:11,917 --> 00:24:16,538
To make things worse, we would actually walk the GameObject tree a second time to build

429
00:24:16,538 --> 00:24:18,059
a list of items to render.

430
00:24:18,059 --> 00:24:23,260
This happened during the sync point between the game and the rendering threads, creating

431
00:24:23,260 --> 00:24:24,861
a major bottleneck.

432
00:24:24,861 --> 00:24:29,543
Well, towards the end of Shadow's development, we implemented a couple of Hail Marys to address

433
00:24:29,543 --> 00:24:30,203
the problem.

434
00:24:30,203 --> 00:24:31,823
They were Band-Aids at best.

435
00:24:32,537 --> 00:24:40,726
Moving forward to our next project, we knew that we needed to re-architect how we coordinate the game loops between the two engines.

436
00:24:40,726 --> 00:24:44,010
Basically, it was time to take what we had learned and evolve the dance.

437
00:24:46,763 --> 00:24:51,708
The major breakthrough for us came when we decided to stop treating the original code

438
00:24:51,708 --> 00:24:57,154
base as special, but rather as just another think process that happens at a specific point

439
00:24:57,154 --> 00:24:58,215
in the frame.

440
00:24:58,215 --> 00:25:03,000
You can think of the entire original shadow game code as a component on a game object

441
00:25:03,000 --> 00:25:04,101
exposing functionality.

442
00:25:04,101 --> 00:25:07,044
And fortunately, this is easier said than done.

443
00:25:07,724 --> 00:25:12,925
To evolve to where we are today, beyond Shadow, we had to make the following changes.

444
00:25:12,925 --> 00:25:17,046
Number one, the first thing that we did is we eliminated the need to walk game objects

445
00:25:17,046 --> 00:25:19,507
to determine what needs to be rendered.

446
00:25:19,507 --> 00:25:24,448
Rather, we make components responsible for adding and removing persistent render items,

447
00:25:24,448 --> 00:25:28,609
and we support a command buffer style interface for changing render item parameters

448
00:25:28,609 --> 00:25:30,089
to keep everything thread safe.

449
00:25:31,258 --> 00:25:34,319
Number two, we no longer walk the game object tree

450
00:25:34,319 --> 00:25:35,960
to update components.

451
00:25:35,960 --> 00:25:39,021
Rather, components register think request delegates.

452
00:25:39,021 --> 00:25:41,522
Think requests can be added or removed

453
00:25:41,522 --> 00:25:43,663
at any point from any thread.

454
00:25:43,663 --> 00:25:46,864
A single object can submit as many think requests

455
00:25:46,864 --> 00:25:49,204
as desired based upon demand.

456
00:25:49,204 --> 00:25:52,306
This makes it very easy to create objects

457
00:25:52,306 --> 00:25:54,946
that only need to think for one frame

458
00:25:54,946 --> 00:25:56,607
or under certain conditions.

459
00:25:57,267 --> 00:26:00,790
Think requests can also be invoked at any point.

460
00:26:00,790 --> 00:26:03,052
If not explicitly invoked, they will be invoked

461
00:26:03,052 --> 00:26:05,054
when their bucket is processed.

462
00:26:05,054 --> 00:26:08,036
However, it is trivial to be in the middle of a think request,

463
00:26:08,036 --> 00:26:11,179
start an async job that you need to wait for,

464
00:26:11,179 --> 00:26:14,242
and invoke other think requests to ensure that we never stall.

465
00:26:15,252 --> 00:26:21,814
With these changes and looking back at shadow, now rather than merging the shadow game loop with the blue point game loop,

466
00:26:21,814 --> 00:26:26,716
we would simply have the shadow code register a think request within the correct bucket,

467
00:26:26,716 --> 00:26:31,118
eliminating the distinction between the shadow update and the BPE update.

468
00:26:31,118 --> 00:26:34,959
When the original shadow code needed to wait for async jobs,

469
00:26:34,959 --> 00:26:38,360
it would simply start processing other think requests rather than installing.

470
00:26:40,024 --> 00:26:42,145
This type of behavior is proving to be critical

471
00:26:42,145 --> 00:26:43,425
on our next project.

472
00:26:43,425 --> 00:26:46,926
In fact, this last week, I spent a day rearranging

473
00:26:46,926 --> 00:26:49,547
think request dependencies to fix stalls,

474
00:26:49,547 --> 00:26:52,588
saving approximately two milliseconds within our game loop.

475
00:26:52,588 --> 00:26:54,808
I didn't optimize any code.

476
00:26:54,808 --> 00:26:57,449
Rather, I simply fixed scheduling issues

477
00:26:57,449 --> 00:26:58,790
to increase CPU saturation.

478
00:26:58,790 --> 00:27:02,931
Having the flexibility to easily rearrange a frame's work

479
00:27:02,931 --> 00:27:06,092
to fill dead areas and remove contention

480
00:27:06,092 --> 00:27:07,132
is proving to be awesome.

481
00:27:08,698 --> 00:27:12,420
So here's a diagram showing our current running layout.

482
00:27:12,420 --> 00:27:15,821
It is much easier to use and a lot more flexible.

483
00:27:15,821 --> 00:27:18,242
At this point, my only regret is that we didn't implement

484
00:27:18,242 --> 00:27:19,843
this system earlier.

485
00:27:19,843 --> 00:27:23,004
So rather than looking at Shadow, let's take a look

486
00:27:23,004 --> 00:27:26,626
at how we have evolved and what's next.

487
00:27:26,626 --> 00:27:30,688
So, sorry, I hope you didn't think that I was going

488
00:27:30,688 --> 00:27:32,128
to expose our next project.

489
00:27:32,627 --> 00:27:36,249
I know this isn't funny, well, maybe it is a little bit to me.

490
00:27:36,249 --> 00:27:39,732
While I'm super excited about our next project and the tech

491
00:27:39,732 --> 00:27:43,234
that we are building, I'm pretty sure

492
00:27:43,234 --> 00:27:46,196
Bluepoint would make me walk home all the way to Texas

493
00:27:46,196 --> 00:27:47,077
just to shoot me if I screwed this up.

494
00:27:47,077 --> 00:27:50,099
So next, I want to talk about what

495
00:27:50,099 --> 00:27:53,642
we have learned from past projects

496
00:27:53,642 --> 00:27:55,383
and how it affects our systems.

497
00:27:55,383 --> 00:27:58,706
How we go about creating a harmony of technology

498
00:27:58,706 --> 00:28:01,087
by doing a deep dive into our memory system.

499
00:28:01,908 --> 00:28:03,649
how it is designed with flexibility,

500
00:28:03,649 --> 00:28:06,350
and what steers those decisions.

501
00:28:06,350 --> 00:28:07,971
Before I do so, here's a quick disclaimer.

502
00:28:07,971 --> 00:28:10,433
All of the examples that I'm going to share

503
00:28:10,433 --> 00:28:14,735
are based upon my personal experiences and memories.

504
00:28:14,735 --> 00:28:17,757
And my examples are based on outdated technology

505
00:28:17,757 --> 00:28:19,198
from the companies in question

506
00:28:19,198 --> 00:28:22,540
and don't represent their current technology or processes.

507
00:28:22,540 --> 00:28:25,282
And finally, I apologize in advance

508
00:28:25,282 --> 00:28:27,143
if I misrepresent anyone's work.

509
00:28:31,132 --> 00:28:33,654
So, memory, who needs it?

510
00:28:33,654 --> 00:28:34,215
I'm pretty sure I do.

511
00:28:34,215 --> 00:28:37,698
I've been working or dealing with memory systems

512
00:28:37,698 --> 00:28:38,999
since I started my career.

513
00:28:38,999 --> 00:28:41,801
Over this time, I have tried numerous approaches

514
00:28:41,801 --> 00:28:43,783
and have shifted the way I view memory

515
00:28:43,783 --> 00:28:45,624
based upon the games that I have shipped.

516
00:28:45,624 --> 00:28:47,526
In fact, I wrote an article

517
00:28:47,526 --> 00:28:49,568
for Game Programming Gems years ago.

518
00:28:49,568 --> 00:28:53,811
As I look back, I still embrace the ideas presented,

519
00:28:53,811 --> 00:28:55,513
but I'm a bit embarrassed

520
00:28:55,513 --> 00:28:57,975
that the implementations were so short-sighted.

521
00:28:58,807 --> 00:29:00,988
I actually got my first job in the games industry

522
00:29:00,988 --> 00:29:04,710
working for Beyond Games, creating a Hot Wheels game.

523
00:29:04,710 --> 00:29:07,771
The key to landing this job was a BSP collision system

524
00:29:07,771 --> 00:29:09,932
that I had written that required less than half

525
00:29:09,932 --> 00:29:12,253
the memory footprint of the current system,

526
00:29:12,253 --> 00:29:14,053
basically cutting memory requirements

527
00:29:14,053 --> 00:29:15,974
from six to two megs on a PS2.

528
00:29:15,974 --> 00:29:19,395
If there's one lesson that I learned then

529
00:29:19,395 --> 00:29:21,376
that is just as true today,

530
00:29:21,376 --> 00:29:23,217
it is that proper memory management

531
00:29:23,217 --> 00:29:26,778
is critical to achieving performance and shipping titles.

532
00:29:30,009 --> 00:29:34,310
So let's take a look at Bluepoint's hardest title to date,

533
00:29:34,310 --> 00:29:37,591
shipping Titanfall on the Xbox 360.

534
00:29:37,591 --> 00:29:39,752
What an amazing game Respawn created,

535
00:29:39,752 --> 00:29:42,793
and if you buy me a drink, I have a lot of stories.

536
00:29:42,793 --> 00:29:46,234
If you don't recall, the original Titanfall

537
00:29:46,234 --> 00:29:50,856
was developed by Respawn and released on the PC and Xbox One.

538
00:29:50,856 --> 00:29:53,316
Bluepoint released the Xbox 360 version

539
00:29:53,316 --> 00:29:55,317
approximately two months later.

540
00:29:56,478 --> 00:30:03,227
Simple summary, if I ignore the performance aspect, it is not easy to ship a 5GB Xbox

541
00:30:03,227 --> 00:30:06,051
One game on an Xbox 360 with 512MB.

542
00:30:06,051 --> 00:30:08,455
So how did we do it?

543
00:30:08,455 --> 00:30:11,960
A lot of hard work, or as we like to call it, Blue Point Magic.

544
00:30:12,734 --> 00:30:18,579
The original game used a fixed-size bucket allocator for allocations less than 32 bytes

545
00:30:18,579 --> 00:30:23,744
and DLMalloc for everything else, where all memory allocations were funneled into a single

546
00:30:23,744 --> 00:30:28,269
allocator and dispatched from there, creating a choke point where thread contention became

547
00:30:28,269 --> 00:30:28,990
a major issue.

548
00:30:30,331 --> 00:30:32,553
I know that a lot of people love DLMalloc

549
00:30:32,553 --> 00:30:34,295
and argue that it is sufficient.

550
00:30:34,295 --> 00:30:36,858
Well, it has a lot of great features.

551
00:30:36,858 --> 00:30:39,140
In practice on Titanfall, we found that,

552
00:30:39,140 --> 00:30:41,402
number one, the version of DLMalloc we used

553
00:30:41,402 --> 00:30:43,985
did not have any concept of virtual allocations,

554
00:30:43,985 --> 00:30:46,848
and thus a custom system was required.

555
00:30:47,348 --> 00:30:53,973
Number two, DLMalloc was not ideal for large page-aligned allocations.

556
00:30:53,973 --> 00:30:57,536
DLMalloc works by placing tags at the beginning of allocations.

557
00:30:57,536 --> 00:31:02,859
If you need a texture with 128-byte alignment, the tag can create memory waste.

558
00:31:03,520 --> 00:31:08,867
And number three, due to DLMalloc not being ideal for small allocations, virtual allocs,

559
00:31:08,867 --> 00:31:14,554
or page size allocations, we needed DLMalloc to release unused memory back to other memory

560
00:31:14,554 --> 00:31:14,994
systems.

561
00:31:14,994 --> 00:31:19,680
In practice, we found that DLMalloc held on to more memory than we thought was ideal.

562
00:31:22,369 --> 00:31:26,515
The key to shipping Titanfall from a memory point of view

563
00:31:26,515 --> 00:31:28,056
was memory tracking,

564
00:31:28,056 --> 00:31:31,120
knowing exactly where all memory was at all times,

565
00:31:31,120 --> 00:31:32,803
tracking fragmentation issues,

566
00:31:32,803 --> 00:31:34,104
and tracking memory by category

567
00:31:34,104 --> 00:31:38,229
so that the peaks could be compared from build to build

568
00:31:38,229 --> 00:31:39,030
to determine trends.

569
00:31:40,193 --> 00:31:42,495
From there, we were able to optimize data formats

570
00:31:42,495 --> 00:31:45,117
in nearly every system to cut memory usage.

571
00:31:45,117 --> 00:31:47,118
We reworked the memory system to,

572
00:31:47,118 --> 00:31:49,279
we used a fixed block size allocator

573
00:31:49,279 --> 00:31:51,501
for small allocations, less than 512 bytes.

574
00:31:51,501 --> 00:31:55,103
We used DLMalloc for medium sized allocations,

575
00:31:55,103 --> 00:31:57,704
and several changes were made to DLMalloc

576
00:31:57,704 --> 00:32:00,086
to get it to aggressively release memory.

577
00:32:00,086 --> 00:32:02,868
And we used a large page based allocator

578
00:32:02,868 --> 00:32:06,590
used primarily for textures and large vertex buffers.

579
00:32:07,534 --> 00:32:10,877
And we added a concept of a single frame allocation,

580
00:32:10,877 --> 00:32:13,100
where small allocations would be placed

581
00:32:13,100 --> 00:32:16,083
within unused DXT Mipmap memory.

582
00:32:16,083 --> 00:32:18,625
This memory was only valid for a single frame

583
00:32:18,625 --> 00:32:21,288
and coordinated with the texture streaming system.

584
00:32:21,288 --> 00:32:23,270
Basically, every byte was used.

585
00:32:24,030 --> 00:32:27,471
By the end, we had spreadsheets backed by more spreadsheets

586
00:32:27,471 --> 00:32:30,452
for every level showing max memory usage,

587
00:32:30,452 --> 00:32:32,852
how much memory was available for texture streaming,

588
00:32:32,852 --> 00:32:33,592
et cetera.

589
00:32:33,592 --> 00:32:35,673
Well, I'm still in shock that we pulled it off.

590
00:32:35,673 --> 00:32:38,193
Looking back, the whole system was perhaps

591
00:32:38,193 --> 00:32:42,874
a bit more complicated than it needed to be.

592
00:32:42,874 --> 00:32:45,875
So, Uncharted, what a great project.

593
00:32:45,875 --> 00:32:48,275
Going from a PS3 target to a PS4 target,

594
00:32:48,275 --> 00:32:51,156
how could there be any memory considerations?

595
00:32:51,980 --> 00:32:54,964
Well, there weren't any real memory considerations

596
00:32:54,964 --> 00:32:57,327
provided we kept streaming textures reasonable.

597
00:32:57,327 --> 00:33:00,832
However, there are a couple of key things that we learned.

598
00:33:01,720 --> 00:33:04,501
Number one, all memory was allocated at startup

599
00:33:04,501 --> 00:33:06,541
by the core memory system.

600
00:33:06,541 --> 00:33:09,643
From here, all memory was assigned to specific allocators.

601
00:33:09,643 --> 00:33:11,963
There was a hard-coded table within the code

602
00:33:11,963 --> 00:33:14,584
dictating how much memory each allocator was allotted.

603
00:33:14,584 --> 00:33:18,546
The downside is that when an allocator ran out of memory,

604
00:33:18,546 --> 00:33:21,207
you would play the Russian roulette game

605
00:33:21,207 --> 00:33:23,928
to push memory around until the problem went away,

606
00:33:23,928 --> 00:33:25,188
often over-allocating.

607
00:33:26,243 --> 00:33:29,666
There was no virtual memory support and fragmentation issues were evident.

608
00:33:29,666 --> 00:33:34,329
There was code to handle the shuffling of memory and pointers when defragging,

609
00:33:34,329 --> 00:33:37,751
however, it came across as error-prone and touched numerous systems.

610
00:33:38,647 --> 00:33:42,230
The later Uncharted games adopted a rule

611
00:33:42,230 --> 00:33:45,292
that memory could not be allocated before hitting main.

612
00:33:45,292 --> 00:33:48,235
I loved this ideal, given that it was straightforward

613
00:33:48,235 --> 00:33:50,517
when to create your memory allocator,

614
00:33:50,517 --> 00:33:52,198
and at the end of main you could easily check

615
00:33:52,198 --> 00:33:54,420
to ensure that there were no memory leaks.

616
00:33:54,420 --> 00:33:56,862
And finally, Uncharted introduced the idea

617
00:33:56,862 --> 00:33:59,805
of a tagged heap allocator, which is very similar

618
00:33:59,805 --> 00:34:01,807
to a single frame allocator that we implemented

619
00:34:01,807 --> 00:34:03,848
for Titanfall, just evolved.

620
00:34:06,017 --> 00:34:07,758
So, what were some of the philosophies

621
00:34:07,758 --> 00:34:10,360
that we felt were important when designing

622
00:34:10,360 --> 00:34:12,882
the memory system for the Bluepoint engine?

623
00:34:12,882 --> 00:34:15,604
Number one, we should never run out of memory.

624
00:34:15,604 --> 00:34:17,645
Never expect null from an allocation request.

625
00:34:17,645 --> 00:34:20,968
In fact, we explicitly halt the game if this happens.

626
00:34:20,968 --> 00:34:24,751
Number two, we need smart allocation schemes

627
00:34:24,751 --> 00:34:27,553
to allow for a wide variety of allocation patterns.

628
00:34:27,553 --> 00:34:30,315
Basically, encourage small custom allocators

629
00:34:30,315 --> 00:34:31,876
rather than an Uber allocator.

630
00:34:32,714 --> 00:34:36,057
Number three, allocators should help to eliminate thread contention.

631
00:34:36,057 --> 00:34:42,143
And four, ensure debuggability across all allocators without a lot of custom work.

632
00:34:42,143 --> 00:34:47,768
To us, debuggability in this case means the ability to track and categorize all memory allocations

633
00:34:47,768 --> 00:34:53,313
and tools to help detect and diagnose common memory issues, with the most common being memory stomps.

634
00:34:55,555 --> 00:34:57,957
With these basic philosophies in place,

635
00:34:57,957 --> 00:34:59,878
we built a list of our goals,

636
00:34:59,878 --> 00:35:02,259
and I'm only gonna touch on a couple of the key points.

637
00:35:02,259 --> 00:35:04,560
Number one, we determined that all allocators

638
00:35:04,560 --> 00:35:06,961
should be platform agnostic.

639
00:35:06,961 --> 00:35:10,023
We didn't wanna write custom allocators for each platform.

640
00:35:10,023 --> 00:35:12,324
An allocator should deal with memory patterns,

641
00:35:12,324 --> 00:35:15,706
not the specifics of where the memory came from.

642
00:35:15,706 --> 00:35:19,228
Number two, allocators should be memory agnostic.

643
00:35:19,228 --> 00:35:20,909
Basically, every allocator should work

644
00:35:20,909 --> 00:35:23,550
with both CPU or GPU memory.

645
00:35:25,022 --> 00:35:28,003
While this seems trivial, it does have implications.

646
00:35:28,003 --> 00:35:31,544
During Shadow, our per-frame GPU memory allocators

647
00:35:31,544 --> 00:35:34,565
benefited greatly by removing tags and markers

648
00:35:34,565 --> 00:35:37,386
that were being written directly into the memory blocks

649
00:35:37,386 --> 00:35:38,466
for memory tracking.

650
00:35:38,466 --> 00:35:43,668
Assume that memory will be allocated at any point.

651
00:35:43,668 --> 00:35:45,609
Programmers need power and flexibility

652
00:35:45,609 --> 00:35:48,129
to create great systems.

653
00:35:48,129 --> 00:35:48,770
Number four.

654
00:35:49,592 --> 00:35:52,594
We wanted to eliminate the need for fixed-sized allocators.

655
00:35:52,594 --> 00:35:56,215
Basically, allocators should work with fixed memory blocks,

656
00:35:56,215 --> 00:36:00,097
but also should support growing and shrinking as required.

657
00:36:00,097 --> 00:36:02,178
We want to avoid over-allocating

658
00:36:02,178 --> 00:36:03,698
and the memory Russian roulette game.

659
00:36:06,595 --> 00:36:12,399
To get started, let's look at how we ensure all memory allocations are routed through our memory systems.

660
00:36:12,399 --> 00:36:16,821
We start by overriding system memory routines, which is pretty straightforward.

661
00:36:16,821 --> 00:36:20,864
And second, we create BPE macros to wrap all memory requests.

662
00:36:20,864 --> 00:36:23,706
We choose to use macros for a couple of reasons.

663
00:36:23,706 --> 00:36:27,488
Number one, they are simple, straightforward, and require no additional steps.

664
00:36:27,488 --> 00:36:31,791
Number two, some sort of redirection is required to support malloc and free.

665
00:36:32,532 --> 00:36:39,154
And VirtualAlloc will also require custom wrappers to be platform agnostic, so it's nice to sort of standardize everything.

666
00:36:39,154 --> 00:36:52,239
And then macros also allow us to provide additional features, such as location tracking and passing additional parameters directly to memory requests, such as alignment requirements and requesting specific allocators.

667
00:36:53,380 --> 00:36:55,801
Converting to using macros is not a big undertaking.

668
00:36:55,801 --> 00:36:58,322
I've done it about three times in my career,

669
00:36:58,322 --> 00:37:00,063
and each time it takes about a week.

670
00:37:00,063 --> 00:37:03,284
If you do not redirect and control all allocations

671
00:37:03,284 --> 00:37:07,066
within your code, I highly recommend that you start,

672
00:37:07,066 --> 00:37:10,328
and using macros is the cleanest method that I've found.

673
00:37:10,328 --> 00:37:13,769
And even if you forget to wrap a new or a delete,

674
00:37:13,769 --> 00:37:15,490
it doesn't matter, it'll still get picked up

675
00:37:15,490 --> 00:37:17,211
to overriding the system memory routines.

676
00:37:19,658 --> 00:37:26,721
And finally, to ensure we redirect all memory routines into our system, we simply control all memory.

677
00:37:26,721 --> 00:37:31,602
On consoles, we allocate all physical memory upon initialization.

678
00:37:31,602 --> 00:37:38,344
As a result, if we miss an allocation due to a third-party library, there simply isn't any memory for it to request.

679
00:37:39,097 --> 00:37:41,359
Talking about third-party libraries,

680
00:37:41,359 --> 00:37:45,702
whether audio, physics, video playback, or anything else,

681
00:37:45,702 --> 00:37:47,183
I think there are a couple of mandates

682
00:37:47,183 --> 00:37:49,784
that I believe that we should all insist upon.

683
00:37:49,784 --> 00:37:51,826
Number one being, if a library does not

684
00:37:51,826 --> 00:37:55,028
provide direct control for how it gets its memory,

685
00:37:55,028 --> 00:37:56,869
don't use it.

686
00:37:56,869 --> 00:37:59,631
If you can't control the threading behavior of a library,

687
00:37:59,631 --> 00:38:00,931
don't use it.

688
00:38:00,931 --> 00:38:04,354
And if you can't control how it loads files, don't use it.

689
00:38:05,002 --> 00:38:10,424
There is one third-party library that I would like to call out that we use extensively.

690
00:38:10,424 --> 00:38:14,566
The EASTL, which is a replacement for the standard containers.

691
00:38:14,566 --> 00:38:19,148
I hope that anyone that has been in game development for any amount of time

692
00:38:19,148 --> 00:38:24,171
has at least an opinion on the debate of whether or not to use standard containers.

693
00:38:24,171 --> 00:38:25,651
For us, we don't.

694
00:38:26,452 --> 00:38:28,612
However, we have found an awesome replacement

695
00:38:28,612 --> 00:38:30,673
that provides a lot of really cool features

696
00:38:30,673 --> 00:38:34,415
that, while not always safe, allow for smarter code.

697
00:38:34,415 --> 00:38:36,696
If you haven't checked out the EASTL,

698
00:38:36,696 --> 00:38:38,276
I strongly suggest you do.

699
00:38:38,276 --> 00:38:41,617
So, let's take a look at a diagram

700
00:38:41,617 --> 00:38:44,498
illustrating the flow of memory requests.

701
00:38:44,498 --> 00:38:46,979
As you can see, it all starts

702
00:38:46,979 --> 00:38:49,480
with overriding system allocation routines,

703
00:38:49,480 --> 00:38:52,542
which are redirected into our memory coordinator.

704
00:38:52,542 --> 00:38:53,942
From there, memory requests are funneled

705
00:38:53,942 --> 00:38:55,283
into appropriate allocators.

706
00:38:55,963 --> 00:39:03,667
These allocators manage their own memory pools to service memory requests and fall back to requesting memory pages from the platform page allocator.

707
00:39:03,667 --> 00:39:08,529
Note that the only system that is platform specific is the platform page allocator.

708
00:39:08,529 --> 00:39:15,433
This helps to ensure allocators only deal with memory usage patterns and ensure that we get consistency across all platforms.

709
00:39:17,968 --> 00:39:20,891
So the MC contains some of the hardest hit code

710
00:39:20,891 --> 00:39:21,973
in the entire code base.

711
00:39:21,973 --> 00:39:25,216
Its primary purpose is to redirect memory requests

712
00:39:25,216 --> 00:39:27,078
to the appropriate allocator,

713
00:39:27,078 --> 00:39:29,301
all without creating thread contention.

714
00:39:29,301 --> 00:39:32,164
Thus, it must avoid locking mechanisms.

715
00:39:32,815 --> 00:39:36,197
We are able to achieve this goal by ensuring that the MC is

716
00:39:36,197 --> 00:39:39,559
basically stateless and that the few stack-based variables

717
00:39:39,559 --> 00:39:41,961
that it forwards into the allocators

718
00:39:41,961 --> 00:39:45,183
are all stored using thread-local-storage.

719
00:39:45,183 --> 00:39:46,544
There's one caveat to keep in mind.

720
00:39:46,544 --> 00:39:49,886
Our threaded job system is constructed using fibers

721
00:39:49,886 --> 00:39:51,367
that we switch in and out.

722
00:39:51,367 --> 00:39:55,249
Because we are using thread-local-storage,

723
00:39:55,249 --> 00:39:57,011
we need to prevent fibers from picking up

724
00:39:57,011 --> 00:39:59,572
the wrong set of variables when switched.

725
00:39:59,572 --> 00:39:59,712
So,

726
00:40:00,783 --> 00:40:04,143
Within our job system, if we perform a context switch

727
00:40:04,143 --> 00:40:06,664
and switch out a fiber, we also create a copy

728
00:40:06,664 --> 00:40:09,004
of the memory local thread variables.

729
00:40:09,004 --> 00:40:10,885
Then when the job system switches back

730
00:40:10,885 --> 00:40:12,925
to the previously suspended fiber,

731
00:40:12,925 --> 00:40:17,186
we restore the local thread variables.

732
00:40:17,186 --> 00:40:19,486
That's keeping everyone happy and consistent.

733
00:40:19,486 --> 00:40:22,787
By using thread local variables,

734
00:40:22,787 --> 00:40:24,507
not only do we allow memory requests

735
00:40:24,507 --> 00:40:27,267
to be redirected to any specific allocator,

736
00:40:27,267 --> 00:40:29,968
but it is also at the heart of how we categorize memory.

737
00:40:31,132 --> 00:40:34,095
In our engine, every single allocation is categorized,

738
00:40:34,095 --> 00:40:37,459
even if it is just categorized as a general allocation.

739
00:40:37,459 --> 00:40:39,943
Our strategy is once a category starts

740
00:40:39,943 --> 00:40:41,565
to account for too much memory,

741
00:40:41,565 --> 00:40:44,508
we simply start splitting the category

742
00:40:44,508 --> 00:40:46,230
and refining our tracking.

743
00:40:46,230 --> 00:40:47,091
And finally.

744
00:40:47,743 --> 00:40:50,064
The MC gives us a great single location

745
00:40:50,064 --> 00:40:52,265
to track all out-of-memory issues,

746
00:40:52,265 --> 00:40:54,186
eliminating the need to spread that code

747
00:40:54,186 --> 00:40:55,366
throughout the entire code base,

748
00:40:55,366 --> 00:40:56,707
or throughout the allocators.

749
00:40:56,707 --> 00:40:59,228
One tip that you can see from the code snippet

750
00:40:59,228 --> 00:41:01,109
is that we create a special function

751
00:41:01,109 --> 00:41:03,750
that is never inline to handle out-of-memory issues.

752
00:41:03,750 --> 00:41:05,831
This has actually been really great.

753
00:41:05,831 --> 00:41:07,692
If QA ever encounters a crash,

754
00:41:07,692 --> 00:41:10,693
it is trivial to determine if it was an out-of-memory issue

755
00:41:10,693 --> 00:41:13,374
by directly looking at the extracted call stack.

756
00:41:13,374 --> 00:41:14,455
No need to look at the log

757
00:41:14,455 --> 00:41:16,055
or try to interpret line numbers.

758
00:41:18,732 --> 00:41:22,295
The allocator, or as I like to think about it,

759
00:41:22,295 --> 00:41:23,456
the heart of the system.

760
00:41:23,456 --> 00:41:26,558
This snippet shows a portion of the interface

761
00:41:26,558 --> 00:41:28,480
that all allocators must provide.

762
00:41:28,480 --> 00:41:31,583
The primary idea here that I want to call your attention to

763
00:41:31,583 --> 00:41:35,306
is the fact that we declare all memory routines as protected.

764
00:41:35,306 --> 00:41:37,168
Basically, we want to prevent code

765
00:41:37,168 --> 00:41:39,630
from directly bypassing the memory coordinator.

766
00:41:39,630 --> 00:41:42,692
This helps to ensure that all allocators follow

767
00:41:42,692 --> 00:41:45,575
consistent conventions and are properly registered

768
00:41:45,575 --> 00:41:46,596
with the memory coordinator.

769
00:41:49,907 --> 00:41:55,128
I mentioned earlier, anytime an allocator needs to grow its memory pool to service a

770
00:41:55,128 --> 00:42:00,370
request, it requests new memory pages from our platform page allocator.

771
00:42:00,370 --> 00:42:06,131
For Shadow on the PS4, we determined that 64K pages were the ideal size.

772
00:42:06,131 --> 00:42:09,792
We also aligned all requested pages to 1MB boundaries.

773
00:42:10,352 --> 00:42:14,314
We wanted smaller pages to minimize waste and fragmentation,

774
00:42:14,314 --> 00:42:17,596
but also minimize the TLB issues.

775
00:42:17,596 --> 00:42:20,197
For us, 64K pages was the sweet spot.

776
00:42:20,197 --> 00:42:24,340
I also want to point out that when coding allocators,

777
00:42:24,340 --> 00:42:27,721
we strictly avoid the use of mutexes.

778
00:42:27,721 --> 00:42:30,503
While allocators need to deal with threading issues,

779
00:42:30,503 --> 00:42:32,224
we stick to using atomic locks.

780
00:42:32,224 --> 00:42:34,105
These are significantly faster,

781
00:42:34,105 --> 00:42:36,386
and the restriction of not being reentrant

782
00:42:36,386 --> 00:42:37,487
is easy to work around.

783
00:42:40,282 --> 00:42:44,103
So let's take a look at a few of the different types of allocators that we support.

784
00:42:44,103 --> 00:42:50,285
The dispatch allocator is the default allocator that the majority of all allocations get redirected

785
00:42:50,285 --> 00:42:50,885
to.

786
00:42:50,885 --> 00:42:56,027
It is a very simple redirector that basically looks at the alignment and size requirements

787
00:42:56,027 --> 00:42:59,208
of a request and forwards them to the appropriate allocator.

788
00:42:59,928 --> 00:43:02,708
We use a bucket allocator for small allocations.

789
00:43:02,708 --> 00:43:05,889
We use a heap allocator, which is similar to DLMalloc.

790
00:43:05,889 --> 00:43:10,170
It uses an intrusive red-black tree to store free blocks

791
00:43:10,170 --> 00:43:13,951
and uses a heuristic of preferring recently freed

792
00:43:13,951 --> 00:43:17,292
memory followed by best fit, then adds headers and post

793
00:43:17,292 --> 00:43:20,732
headers to the allocations to provide tracking information.

794
00:43:20,732 --> 00:43:24,033
And to round it off, we use a page allocator for large memory

795
00:43:24,033 --> 00:43:26,414
requests that fit nicely into our 64k pages.

796
00:43:30,482 --> 00:43:33,105
We also have several special use allocators,

797
00:43:33,105 --> 00:43:36,528
a simple ASCII allocator that is only used by tool code.

798
00:43:36,528 --> 00:43:39,891
There is a virtual page allocator

799
00:43:39,891 --> 00:43:41,693
to handle virtual memory requests.

800
00:43:41,693 --> 00:43:43,315
And there is a frame allocator, which

801
00:43:43,315 --> 00:43:46,798
is great for packing multiple requests together

802
00:43:46,798 --> 00:43:49,321
to ensure memory coherency and creating

803
00:43:49,321 --> 00:43:51,263
small blocks of reusable memory.

804
00:43:51,263 --> 00:43:54,446
And let's not forget about the tagged frame allocator, which

805
00:43:54,446 --> 00:43:55,086
is awesome.

806
00:43:57,246 --> 00:43:59,827
Our tagged frame allocator is based upon an allocator

807
00:43:59,827 --> 00:44:04,368
described by Christian Gerling in his 2015 GDC talk.

808
00:44:04,368 --> 00:44:08,149
The basic idea behind the tagged frame allocator

809
00:44:08,149 --> 00:44:11,190
is that we are creating an extremely fast allocators

810
00:44:11,190 --> 00:44:14,151
where allocations are only valid for a short period of time.

811
00:44:14,151 --> 00:44:16,631
These are basically temporary memory allocations

812
00:44:16,631 --> 00:44:19,912
that are valid for n number of frames

813
00:44:19,912 --> 00:44:23,833
where a frame is arbitrarily defined for each allocator.

814
00:44:24,233 --> 00:44:27,455
The fact that we don't need to track the memory

815
00:44:27,455 --> 00:44:31,037
or call free to release memory is a huge win.

816
00:44:31,037 --> 00:44:34,299
Not only is the code requesting the memory easier to write,

817
00:44:34,299 --> 00:44:37,101
the tag frame allocator can take a bunch of shortcuts

818
00:44:37,101 --> 00:44:40,903
knowing that individual free calls do not need to be supported.

819
00:44:40,903 --> 00:44:44,185
It is also impossible to create memory leaks with this allocator.

820
00:44:44,185 --> 00:44:44,745
As we discussed earlier...

821
00:44:48,229 --> 00:44:51,951
One of the primary goals behind allocators

822
00:44:51,951 --> 00:44:55,214
is that they should help to minimize thread contention.

823
00:44:55,214 --> 00:44:57,255
This is achieved using two strategies.

824
00:44:57,255 --> 00:45:00,298
Number one, we use atomic locks rather than mutexes.

825
00:45:00,298 --> 00:45:01,999
And number two,

826
00:45:03,820 --> 00:45:05,862
by using thread local storage.

827
00:45:05,862 --> 00:45:08,003
Several of our allocators use the pattern

828
00:45:08,003 --> 00:45:10,225
illustrated in the code snippet.

829
00:45:10,225 --> 00:45:11,526
For the tag frame allocator,

830
00:45:11,526 --> 00:45:14,168
this allows it to service memory requests

831
00:45:14,168 --> 00:45:18,251
for multiple threads simultaneously without ever locking.

832
00:45:18,251 --> 00:45:20,793
If you've ever had to deal with multi-threaded performance,

833
00:45:20,793 --> 00:45:23,415
this should jump out immediately as a huge win.

834
00:45:26,838 --> 00:45:31,519
Within the Bluepoint Engine, there are more tag frame allocators than any other type of allocator.

835
00:45:31,519 --> 00:45:36,880
Each tag frame allocator is built on top of a tag framed arena,

836
00:45:36,880 --> 00:45:41,061
which allows all tag framed allocators to share a common memory pool,

837
00:45:41,061 --> 00:45:44,742
eliminating over allocation issues.

838
00:45:44,742 --> 00:45:51,043
The tag frame arena will also grow and shrink upon demand, thus all pool sizes are dynamic.

839
00:45:52,144 --> 00:45:54,785
If you don't have anything similar to this in your code

840
00:45:54,785 --> 00:45:57,386
base, I would highly recommend that you make it happen.

841
00:45:57,386 --> 00:46:00,688
And finally, the platform page allocator, or the brains of

842
00:46:00,688 --> 00:46:01,808
the operation.

843
00:46:01,808 --> 00:46:06,230
As we have discussed, this class is responsible for

844
00:46:06,230 --> 00:46:09,512
abstracting away the details of how 64K pages are managed.

845
00:46:09,512 --> 00:46:13,134
In practice, we restrict anyone from accessing this

846
00:46:13,134 --> 00:46:14,154
class directly.

847
00:46:14,154 --> 00:46:16,375
The only customers of this class are the memory

848
00:46:16,375 --> 00:46:17,016
allocators.

849
00:46:18,821 --> 00:46:21,442
On Windows, this is a very simple class

850
00:46:21,442 --> 00:46:23,823
and is built using Virtual Alloc.

851
00:46:23,823 --> 00:46:25,944
The PS4 version is more complex

852
00:46:25,944 --> 00:46:27,885
due to platform considerations.

853
00:46:27,885 --> 00:46:29,906
At the heart of both implementations

854
00:46:29,906 --> 00:46:32,047
is the concept of virtual memory

855
00:46:32,047 --> 00:46:35,688
and mapping physical to virtual addresses on demand.

856
00:46:35,688 --> 00:46:37,369
If you're not familiar with the differences

857
00:46:37,369 --> 00:46:39,450
between virtual and physical memory,

858
00:46:39,450 --> 00:46:40,490
you might want to investigate.

859
00:46:43,255 --> 00:46:45,576
So looking at the platform page allocator,

860
00:46:45,576 --> 00:46:48,058
there's one last problem that I would like to discuss,

861
00:46:48,058 --> 00:46:51,260
which is a problem in every non-Uber memory system

862
00:46:51,260 --> 00:46:52,721
that I've worked with.

863
00:46:52,721 --> 00:46:55,243
Given that we are avoiding an Uber allocator

864
00:46:55,243 --> 00:46:58,044
and embracing numerous allocation patterns,

865
00:46:58,044 --> 00:47:01,046
we need to be able to take any random memory address

866
00:47:01,046 --> 00:47:03,088
and determine which allocator it belongs to.

867
00:47:04,208 --> 00:47:07,650
This is required to properly direct free calls.

868
00:47:07,650 --> 00:47:11,112
While BPE macros allow us to optionally specify

869
00:47:11,112 --> 00:47:14,733
which allocator owns memory when calling BPE free,

870
00:47:14,733 --> 00:47:15,674
this is not ideal.

871
00:47:15,674 --> 00:47:20,496
Instead, we need to support the getMemoryOwner routine.

872
00:47:20,496 --> 00:47:23,997
So, how did we solve this problem?

873
00:47:23,997 --> 00:47:24,898
We threw memory at it.

874
00:47:25,659 --> 00:47:33,326
We break up the problem by realizing that we only need to determine which allocator owns the memory page that contains the memory address in question.

875
00:47:33,326 --> 00:47:43,475
Within the platform page allocator, we use a 1MB block of memory to store a direct lookup table which maps 1TB of virtual memory to its owning allocator.

876
00:47:43,475 --> 00:47:46,118
If you have a better solution, I'd love to hear it.

877
00:47:48,507 --> 00:47:51,209
So what do you get when you put this all together?

878
00:47:51,209 --> 00:47:53,710
Hopefully a game without performance issues

879
00:47:53,710 --> 00:47:55,411
and runs within retail memory.

880
00:47:55,411 --> 00:47:56,972
OK, that isn't going to happen.

881
00:47:56,972 --> 00:48:00,054
But hopefully you have the flexibility and tools

882
00:48:00,054 --> 00:48:02,796
necessary to get there from a memory perspective.

883
00:48:02,796 --> 00:48:05,157
Here's a screenshot showing our memory statistics.

884
00:48:05,157 --> 00:48:09,460
You can see the platform page allocator at the top

885
00:48:09,460 --> 00:48:11,461
and each of the various allocators below.

886
00:48:13,881 --> 00:48:16,585
Here's another screenshot that shows memory category tracking.

887
00:48:16,585 --> 00:48:20,630
I want to call your attention to the outlined black boxes that I've marked up.

888
00:48:21,569 --> 00:48:24,270
Most consoles have a concept of development memory.

889
00:48:24,270 --> 00:48:26,231
Basically, the development kit has more memory

890
00:48:26,231 --> 00:48:27,712
than the retail kits.

891
00:48:27,712 --> 00:48:30,334
We make it very easy at all times

892
00:48:30,334 --> 00:48:34,257
to see where memory usage is in regards to a retail kit.

893
00:48:34,257 --> 00:48:36,458
From the screenshot, you can see that the closest

894
00:48:36,458 --> 00:48:38,799
that we came to running out of memory on a retail kit

895
00:48:38,799 --> 00:48:43,662
was 130 megs, or the equivalent of the max memory of four PS2

896
00:48:43,662 --> 00:48:44,483
games.

897
00:48:44,483 --> 00:48:45,984
There's no way we could run out of memory.

898
00:48:48,838 --> 00:48:53,460
So to finish up, I want to share one additional feature

899
00:48:53,460 --> 00:48:54,620
in Shadow of the Colossus.

900
00:48:54,620 --> 00:48:57,261
It is related to memory and made a significant impact

901
00:48:57,261 --> 00:48:58,941
on development.

902
00:48:58,941 --> 00:49:00,242
Texture streaming.

903
00:49:00,242 --> 00:49:03,243
I'm sure many of you have texture streaming solutions.

904
00:49:03,243 --> 00:49:06,964
We use GPU-based feedback to determine what to stream

905
00:49:06,964 --> 00:49:11,545
and specify a fixed streaming texture memory budget.

906
00:49:11,545 --> 00:49:14,606
For Shadow, we initially set this budget to one gig,

907
00:49:14,606 --> 00:49:17,607
and after some tweaking, most of the game looked great.

908
00:49:18,720 --> 00:49:21,323
Some areas required a higher texture budget

909
00:49:21,323 --> 00:49:23,186
to facilitate its needs.

910
00:49:23,186 --> 00:49:24,968
And some areas would simply crash

911
00:49:24,968 --> 00:49:26,690
due to running out of memory

912
00:49:26,690 --> 00:49:29,474
before even hitting the one gig budget.

913
00:49:29,474 --> 00:49:31,316
It was about halfway through the development

914
00:49:31,316 --> 00:49:33,639
that the team began to stress about memory

915
00:49:33,639 --> 00:49:36,163
and started getting flashbacks of previous projects.

916
00:49:38,776 --> 00:49:40,877
So how did we solve the problem?

917
00:49:40,877 --> 00:49:43,358
We set the texture streaming budget to unlimited.

918
00:49:43,358 --> 00:49:45,999
Problem solved, and now everyone is happy.

919
00:49:45,999 --> 00:49:49,580
Instead of relying upon a fixed memory budget,

920
00:49:49,580 --> 00:49:52,921
the texture manager monitors the total available memory

921
00:49:52,921 --> 00:49:54,822
by querying the platform page allocator

922
00:49:54,822 --> 00:49:56,843
and acting appropriately.

923
00:49:56,843 --> 00:50:00,244
If there is extra memory, stream in more textures.

924
00:50:00,244 --> 00:50:02,785
If no more textures are required,

925
00:50:02,785 --> 00:50:04,306
then there's nothing to do.

926
00:50:04,306 --> 00:50:07,347
And if memory is low, start releasing textures.

927
00:50:08,618 --> 00:50:16,304
I should note that this does require a bit of balancing to avoid ping pong effects and to determine proper memory thresholds.

928
00:50:16,304 --> 00:50:22,788
However, these thresholds are game-specific, not area-specific, so they only needed to be calculated once.

929
00:50:25,426 --> 00:50:28,967
This was really a major turning point for stability

930
00:50:28,967 --> 00:50:32,368
as out-of-memory issues basically disappeared.

931
00:50:32,368 --> 00:50:34,789
Of course, we still had to deal with memory usage issues

932
00:50:34,789 --> 00:50:36,389
where memory was scarce.

933
00:50:36,389 --> 00:50:39,150
However, these areas only needed to be pushed

934
00:50:39,150 --> 00:50:40,651
to an acceptable level,

935
00:50:40,651 --> 00:50:43,272
and the texture manager would auto-calibrate.

936
00:50:43,272 --> 00:50:44,432
Moving forward, we were pushing

937
00:50:44,432 --> 00:50:45,552
our texture streaming solution

938
00:50:45,552 --> 00:50:48,393
beyond what was achievable in Shadow

939
00:50:48,393 --> 00:50:51,994
by prioritizing and loading even higher resolution textures

940
00:50:51,994 --> 00:50:52,935
when memory allows.

941
00:50:55,324 --> 00:50:58,588
So here's a screenshot showing texture streaming stats

942
00:50:58,588 --> 00:51:00,310
at the top of the screen.

943
00:51:00,310 --> 00:51:04,094
Here you can see that we have over 2 gigs of textures loaded.

944
00:51:04,094 --> 00:51:07,118
However, the scene only actually requires about 680 megs

945
00:51:07,118 --> 00:51:10,241
of texture data as the texture manager

946
00:51:10,241 --> 00:51:13,184
tries to maintain a buffer of about 220 megs free.

947
00:51:16,722 --> 00:51:18,663
Here's a more demanding area.

948
00:51:18,663 --> 00:51:21,245
There is 1.3 gigs of textures loaded,

949
00:51:21,245 --> 00:51:25,248
however only 1.13 gigs are required.

950
00:51:25,248 --> 00:51:27,790
During development, the art team would play the game

951
00:51:27,790 --> 00:51:29,572
watching these statistics to verify

952
00:51:29,572 --> 00:51:32,254
that the budgets were satisfied.

953
00:51:32,254 --> 00:51:35,116
By the end, the only questionable area in the game

954
00:51:35,116 --> 00:51:37,838
was the final cut scene where the secret garden is exposed.

955
00:51:40,664 --> 00:51:43,026
And of course, the minute you tell anyone

956
00:51:43,026 --> 00:51:44,907
that the texture budget has exceeded,

957
00:51:44,907 --> 00:51:48,989
you need to be able to show them why and what is loaded.

958
00:51:48,989 --> 00:51:51,791
It is only then that you can properly debate

959
00:51:51,791 --> 00:51:53,232
how big must the eye texture be.

960
00:51:53,232 --> 00:51:53,793
Y'all get that?

961
00:51:53,793 --> 00:51:53,993
Okay, good.

962
00:52:00,792 --> 00:52:03,773
So, once again, I would like to thank you

963
00:52:03,773 --> 00:52:04,794
for your participation.

964
00:52:04,794 --> 00:52:08,516
I'm flattered that I've had this opportunity to ramble on.

965
00:52:08,516 --> 00:52:10,998
And yes, Blue Point Games is hiring.

966
00:52:10,998 --> 00:52:13,359
Basically, if you are a badass,

967
00:52:13,359 --> 00:52:16,021
and you know how to get shit done,

968
00:52:16,021 --> 00:52:17,081
we want to work with you.

969
00:52:17,081 --> 00:52:20,083
Use the email address on the slide and mention my name.

970
00:52:20,083 --> 00:52:22,765
I'll let everyone know that we are best friends

971
00:52:22,765 --> 00:52:24,206
so I can get the recruiting bonus.

972
00:52:24,206 --> 00:52:27,428
And then perhaps it'll be time for me to buy you a beer.

973
00:52:28,693 --> 00:52:33,996
Also remember to fill out the speaker evaluation forms so I know whether or not I should ever do this again.

974
00:52:33,996 --> 00:52:36,937
With that I believe I'm done. I believe we have

975
00:52:36,937 --> 00:52:41,278
eight minutes for questions if anybody has any questions.

976
00:53:04,898 --> 00:53:07,038
I love it, the perfect talk, there's no questions.

977
00:53:07,038 --> 00:53:08,759
That's perfect, let's wrap it up.

978
00:53:08,759 --> 00:53:10,799
Get the hell out of here.

979
00:53:10,799 --> 00:53:12,720
I had a question.

980
00:53:12,720 --> 00:53:13,020
Yeah.

981
00:53:13,020 --> 00:53:14,300
You talk about being lock-free

982
00:53:14,300 --> 00:53:15,821
using atomics in your allocators.

983
00:53:15,821 --> 00:53:19,081
So we still live in a world where there's no standard

984
00:53:19,081 --> 00:53:20,982
lock-free container library that you can,

985
00:53:20,982 --> 00:53:23,783
like, do you guys, did you use a third-party one?

986
00:53:23,783 --> 00:53:26,703
Did you roll stuff in-house?

987
00:53:26,703 --> 00:53:29,964
Yeah, so for the atomic locks,

988
00:53:29,964 --> 00:53:32,785
we basically just sort of rolled our own.

989
00:53:32,785 --> 00:53:33,405
Just using,

990
00:53:35,870 --> 00:53:39,411
you know the, I'm drawing a blank right this second,

991
00:53:39,411 --> 00:53:41,873
but basically just using the atomics that are available

992
00:53:41,873 --> 00:53:43,733
on the different platforms.

993
00:53:43,733 --> 00:53:46,355
It really comes down to like four or five lines of code.

994
00:53:46,355 --> 00:53:48,716
If you were to send me an email, I could send it to you.

995
00:53:48,716 --> 00:53:49,496
It's real simple.

996
00:53:49,496 --> 00:53:52,237
Sure, now I mean, you didn't do unbounded spinning though,

997
00:53:52,237 --> 00:53:54,398
did you, for some of your locks?

998
00:53:54,398 --> 00:53:56,419
They will spin, yes.

999
00:53:56,419 --> 00:53:56,980
Okay.

1000
00:53:56,980 --> 00:53:58,901
Did you ever see stuff where like,

1001
00:53:58,901 --> 00:54:02,002
I've seen like spin lock, it's all fun and games until.

1002
00:54:02,876 --> 00:54:06,838
you know, your spinning core is scheduled and the work you need to be done that it's waiting on to

1003
00:54:06,838 --> 00:54:11,601
get the lock back is, it's not, you know, have you, did you see some of that? Not really, and part of

1004
00:54:11,601 --> 00:54:16,244
it as well as any time that we use atomics, so we'll use the atomics anytime we want, we've got

1005
00:54:16,244 --> 00:54:19,526
a really small portion that we want to get in and out of really fast.

1006
00:54:19,966 --> 00:54:24,467
And we also try to lock it or try to make it so that we're really not calling other functions inside of it.

1007
00:54:24,467 --> 00:54:29,509
So we don't run into this case of I got a lock here, I call this function and then this guy wants to lock.

1008
00:54:29,509 --> 00:54:30,649
And so they're not re-entrant.

1009
00:54:30,649 --> 00:54:33,971
And so we keep those sections very, very small.

1010
00:54:33,971 --> 00:54:37,132
And so we really haven't had any problems with them,

1011
00:54:37,132 --> 00:54:42,913
or having problems of something waiting for any duration of time before it could get back in.

1012
00:54:44,183 --> 00:54:47,665
We also do a lot of performance profiling,

1013
00:54:47,665 --> 00:54:50,587
looking to make sure that in order to maximize CPU

1014
00:54:50,587 --> 00:54:52,428
saturation across all of our cores,

1015
00:54:52,428 --> 00:54:54,989
making sure that they're just for that fact

1016
00:54:54,989 --> 00:54:57,531
that there is nobody that's stalling

1017
00:54:57,531 --> 00:54:58,431
or waiting for too long.

1018
00:54:58,431 --> 00:55:01,773
I guess I've seen when spending goes bad is usually

1019
00:55:01,773 --> 00:55:02,854
when you're oversubscribed.

1020
00:55:02,854 --> 00:55:06,496
I don't know, did you work hard to avoid oversubscription

1021
00:55:06,496 --> 00:55:09,238
on the platform and stuff like that?

1022
00:55:09,238 --> 00:55:09,498
Yes.

1023
00:55:09,498 --> 00:55:12,860
I would say we work hard to avoid it.

1024
00:55:17,117 --> 00:55:19,598
You said your next game is going to be more of a re-envisioning.

1025
00:55:19,598 --> 00:55:23,579
I was wondering if we could get some color on what that kind of means.

1026
00:55:23,579 --> 00:55:26,200
What is a re-envisioning versus a remake?

1027
00:55:26,200 --> 00:55:26,680
Sure.

1028
00:55:26,680 --> 00:55:32,541
So, if you were to take a look at Shadow of the Colossus, it's a PS2 game, right?

1029
00:55:32,541 --> 00:55:35,102
And so, when that was built...

1030
00:55:35,622 --> 00:55:39,426
The side of the hills were very low triangle density.

1031
00:55:39,426 --> 00:55:40,728
Like, what was the environment,

1032
00:55:40,728 --> 00:55:41,529
what was the atmospherics

1033
00:55:41,529 --> 00:55:45,173
that they're actually trying to achieve?

1034
00:55:45,173 --> 00:55:46,434
And when you look at it, a lot of it,

1035
00:55:46,434 --> 00:55:50,459
you feel like your mind fills in a lot of those blanks.

1036
00:55:50,459 --> 00:55:52,882
You look at a green card that's filled on the back

1037
00:55:52,882 --> 00:55:56,045
and you're like, yeah, I assume that's a grass plane, right?

1038
00:55:56,966 --> 00:55:59,828
And so for Shadow, there's a lot of us looking at that

1039
00:55:59,828 --> 00:56:02,529
and then building it out, sort of trying to remake it,

1040
00:56:02,529 --> 00:56:05,811
but sort of figure out what the original was trying to do.

1041
00:56:05,811 --> 00:56:07,773
As we move forward in some of our other stuff,

1042
00:56:07,773 --> 00:56:11,555
we're taking stuff further with not just, you know,

1043
00:56:11,555 --> 00:56:13,977
trying to get the two engines to run simultaneously,

1044
00:56:13,977 --> 00:56:16,918
but more of bringing more and more stuff into our engine

1045
00:56:16,918 --> 00:56:19,140
and repurposing our technology

1046
00:56:19,140 --> 00:56:22,342
so that we have greater control of, you know,

1047
00:56:22,342 --> 00:56:24,403
redoing the complete animation systems.

1048
00:56:25,824 --> 00:56:28,086
upgrading, you know, besides graphics and other things,

1049
00:56:28,086 --> 00:56:31,828
but even starting to upgrade more of the gameplay paths and such,

1050
00:56:31,828 --> 00:56:34,370
which are all, for us, are always very, very tricky.

1051
00:56:34,370 --> 00:56:39,133
We've been very, very fortunate to work on games that we've absolutely loved.

1052
00:56:39,133 --> 00:56:42,695
And for Shadow, like, you wouldn't take that game and say,

1053
00:56:42,695 --> 00:56:46,217
I want to make it like Assassin's Creed, running around, doing stuff.

1054
00:56:46,217 --> 00:56:48,158
You wouldn't do that.

1055
00:56:48,158 --> 00:56:50,500
And so you want to maintain core pieces.

1056
00:56:50,500 --> 00:56:54,362
So it's a very difficult question, but it's just...

1057
00:56:55,035 --> 00:57:02,922
take shadow and I feel like we're about doubling the amount of involvement that we're putting into it.

1058
00:57:02,922 --> 00:57:03,202
Thank you.

1059
00:57:03,202 --> 00:57:13,691
Hi, I would like to ask you how do you deal with frame rate issues, especially with doing the sort of hybrid approach you took with like two game engines running at the same time?

1060
00:57:13,691 --> 00:57:15,533
So how do we deal with frame rate issues?

1061
00:57:17,391 --> 00:57:20,572
We as I mentioned anybody at Blue Point

1062
00:57:20,572 --> 00:57:23,033
has heard me rant about digital foundry at least

1063
00:57:23,033 --> 00:57:25,315
a bazillion times because I don't know if you've

1064
00:57:25,315 --> 00:57:28,156
seen their evaluations where they do the frame rate graph

1065
00:57:28,156 --> 00:57:31,837
and they show it going straight across the screen.

1066
00:57:31,837 --> 00:57:33,918
And I tell the team if we have a single dip

1067
00:57:33,918 --> 00:57:36,399
they're going to find it and I'll lose my mind.

1068
00:57:37,020 --> 00:57:39,141
And so we do a lot of profiling.

1069
00:57:39,141 --> 00:57:41,222
Our QA department is great.

1070
00:57:41,222 --> 00:57:45,564
They take our tools and our third-party PS4 tools,

1071
00:57:45,564 --> 00:57:48,886
and they'll have graphs that are running on their machine.

1072
00:57:48,886 --> 00:57:51,828
So they're playing the game with the frame rate graph,

1073
00:57:51,828 --> 00:57:53,969
and the minute they see any sort of spike

1074
00:57:53,969 --> 00:57:55,970
or anything like that, they go and they capture it,

1075
00:57:55,970 --> 00:57:57,651
create a bug, and off it goes to engineering.

1076
00:57:57,651 --> 00:57:59,752
On Shadow, we have a 60 FPS mode on the Pro Kits.

1077
00:58:04,295 --> 00:58:05,255
in performance mode.

1078
00:58:05,255 --> 00:58:06,996
That was not easy hitting that.

1079
00:58:06,996 --> 00:58:12,099
It's a lot of testing, a lot of looking at CPU captures,

1080
00:58:12,099 --> 00:58:16,202
and exactly what jobs are on what cores when and why,

1081
00:58:16,202 --> 00:58:17,923
and trying to load balance that out.

1082
00:58:17,923 --> 00:58:19,364
And for our next game,

1083
00:58:19,364 --> 00:58:21,505
the big thing that we're really looking at

1084
00:58:21,505 --> 00:58:24,107
is how do we maximize our CPU saturation.

1085
00:58:25,107 --> 00:58:28,488
I feel like we've got a good job system to break stuff up,

1086
00:58:28,488 --> 00:58:31,689
but you find at the same time, like during your frame,

1087
00:58:31,689 --> 00:58:33,809
you've got areas that are, here's the hot spot.

1088
00:58:33,809 --> 00:58:36,530
Everybody wants this last third quarter of the frame,

1089
00:58:36,530 --> 00:58:38,970
and nobody's doing anything over here.

1090
00:58:38,970 --> 00:58:43,271
So a lot of analyzing and rearranging code

1091
00:58:43,271 --> 00:58:46,172
in order to get it to fill in all those spots.

1092
00:58:46,172 --> 00:58:47,772
Yeah, I guess the second question is how,

1093
00:58:47,772 --> 00:58:51,493
when you convert from like 30 FPS game to 60,

1094
00:58:51,493 --> 00:58:54,954
how do you deal with game breaking issues?

1095
00:58:55,454 --> 00:59:05,184
Oh, uh, yes, so, the original game ticked the update at a hard-coded, you know, 30 FPS.

1096
00:59:05,184 --> 00:59:10,049
And so, on the PS2, I don't know, to be honest, I don't know if the game actually ever hit 30.

1097
00:59:10,049 --> 00:59:10,169
Um...

1098
00:59:12,159 --> 00:59:16,041
And so, yeah, the minute we went to 60 or the minute we even locked it at 30,

1099
00:59:16,041 --> 00:59:18,903
we found that you couldn't climb the colossi as well.

1100
00:59:18,903 --> 00:59:23,926
Your grip would fall before getting around some of the edges was twice as hard.

1101
00:59:23,926 --> 00:59:28,589
And so, I really got to, you know, give credit to that to our QA department.

1102
00:59:28,589 --> 00:59:32,892
They test the game like no other and are looking for parity issues.

1103
00:59:32,892 --> 00:59:37,454
They identify those sort of issues and then we go back and we fix them.

1104
00:59:38,199 --> 00:59:42,325
And a lot of times, programmers love when they look at a bug

1105
00:59:42,325 --> 00:59:44,388
and they're like, I don't know why it's behaving this way.

1106
00:59:44,388 --> 00:59:47,593
And it's like, well, go play it on the PS2,

1107
00:59:47,593 --> 00:59:48,634
on a PS2 dev kit.

1108
00:59:48,634 --> 00:59:49,896
And it's like, I don't even know how to make

1109
00:59:49,896 --> 00:59:52,780
that thing run anymore.

1110
00:59:52,780 --> 00:59:53,541
But it has to be done.

1111
00:59:53,541 --> 00:59:53,782
Okay, thank you.

1112
00:59:57,317 --> 01:00:00,438
Hey, Gretel, there's a lot of issues that speak close to my heart.

1113
01:00:00,438 --> 01:00:05,260
So I was wondering if you have any solution, any utility libraries or whatever

1114
01:00:05,260 --> 01:00:09,222
to deal with the 32-bit to 64-bit address space conversion.

1115
01:00:09,222 --> 01:00:13,164
Any libraries that deal with 32 to 64-bit conversions?

1116
01:00:13,164 --> 01:00:17,346
Yeah, any kind of like injection or, you know, remapping of the 32-bit address space

1117
01:00:17,346 --> 01:00:20,787
into 64-bit or something like that to ease the process of porting

1118
01:00:20,787 --> 01:00:23,069
and moving to a 64-bit platform.

1119
01:00:23,069 --> 01:00:23,689
Yeah.

1120
01:00:27,270 --> 01:00:30,013
We don't really use a third-party library to do that.

1121
01:00:30,013 --> 01:00:31,995
It's a lot, at the end it comes down to us

1122
01:00:31,995 --> 01:00:34,717
doing a lot of hard work and updating code.

1123
01:00:34,717 --> 01:00:36,719
The one thing that I would throw out

1124
01:00:36,719 --> 01:00:38,941
that I didn't really talk about,

1125
01:00:38,941 --> 01:00:40,242
but is mentioned in the slides,

1126
01:00:40,242 --> 01:00:43,445
is what we use is we call the T offset pointer.

1127
01:00:43,445 --> 01:00:45,968
Which basically allows us to represent any address

1128
01:00:45,968 --> 01:00:48,770
as a 32-bit number, and then when you actually

1129
01:00:48,770 --> 01:00:51,873
do the lookup, when you dereference it to a pointer,

1130
01:00:51,873 --> 01:00:54,015
we actually add an offset to it.

1131
01:00:55,236 --> 01:01:03,443
We use that a lot in memory mapped files that have to do that so that we don't break everything right out of the gate.

1132
01:01:03,443 --> 01:01:12,270
But even then by the end, they get annoying because now every single pointer dereference is basically a dereference and it's adding and

1133
01:01:12,270 --> 01:01:18,956
I don't know, it's stupid shit like that that just like, why are we wasting processor power drives me crazy.

1134
01:01:18,956 --> 01:01:20,517
And we end up going through and fixing most of them.

1135
01:01:20,517 --> 01:01:20,857
Alright, thanks.

1136
01:01:25,248 --> 01:01:32,531
Yeah, I'm curious about you have the BluePoint engine and then you've got the game engine and I presume you take the BluePoint engine from project to project?

1137
01:01:32,531 --> 01:01:33,292
That is correct.

1138
01:01:33,292 --> 01:01:38,975
And you have the game engine, does it call directly down into the BluePoint engine?

1139
01:01:38,975 --> 01:01:47,839
And how do you keep the BluePoint engine side of things from not having references up into the game that have to be cleaned up from project to project?

1140
01:01:47,839 --> 01:01:48,039
Right.

1141
01:01:48,039 --> 01:01:48,199
So.

1142
01:01:49,753 --> 01:01:53,355
You could say, I've been writing code for a really long time,

1143
01:01:53,355 --> 01:01:56,016
and you could say there's certain things,

1144
01:01:56,016 --> 01:01:57,157
like coding standards.

1145
01:01:57,157 --> 01:01:58,278
It's like a religion.

1146
01:01:58,278 --> 01:01:59,758
What side of the fence do you fall on?

1147
01:01:59,758 --> 01:02:01,999
There's certain things with coding standards

1148
01:02:01,999 --> 01:02:05,181
that I strongly believe in and drive me crazy.

1149
01:02:05,181 --> 01:02:08,362
One of those is dealing with library dependencies.

1150
01:02:08,362 --> 01:02:11,924
If I've got a base library, and I've got my game library,

1151
01:02:11,924 --> 01:02:13,605
there's no way in the code base that I

1152
01:02:13,605 --> 01:02:16,726
allow the core library to start calling up.

1153
01:02:17,267 --> 01:02:22,528
And so we make very explicit rules about what library is built on top of what,

1154
01:02:22,528 --> 01:02:25,209
so we have a very clear hierarchy.

1155
01:02:25,209 --> 01:02:28,630
Then it's going through and we'll add layers in the middle that's sort of like,

1156
01:02:28,630 --> 01:02:33,612
here's a wrapper piece that is basically the bridge between shadow code...

1157
01:02:34,934 --> 01:02:38,416
and the BPE engine working with our components and game objects.

1158
01:02:38,416 --> 01:02:44,979
It can basically go and do, like, reach into Shadow Code, or Shadow Code reaches into it a lot.

1159
01:02:44,979 --> 01:02:49,342
And then I'm okay with that, because at the end I know that whole piece gets thrown away.

1160
01:02:49,342 --> 01:02:50,763
And so I don't incur that debt.

1161
01:02:51,482 --> 01:03:00,088
So it's essentially just a wrapper for it, so that the game can preserve its original engine calls that wrap to calling into the actual Bluepoint engine?

1162
01:03:00,088 --> 01:03:09,474
And if you think about it, like any game engine, it all boils down to you've got a main loop somewhere, you've got a forever loop that's looping, doing whatever.

1163
01:03:09,474 --> 01:03:14,298
And then the Bluepoint engine is similar, it's got a forever loop, they're both basically looping.

1164
01:03:14,758 --> 01:03:16,879
Well now rather than looping, I'm just gonna make this one,

1165
01:03:16,879 --> 01:03:19,019
when it loops it calls in over here, does its thing,

1166
01:03:19,019 --> 01:03:21,200
comes back out over here, goes back to the top and calls,

1167
01:03:21,200 --> 01:03:22,860
and so it just sort of ping-pongs.

1168
01:03:22,860 --> 01:03:25,161
And the next thing you gotta do is come up with

1169
01:03:25,161 --> 01:03:26,862
areas of responsibility.

1170
01:03:26,862 --> 01:03:28,962
And so then you start going to the original game engine,

1171
01:03:28,962 --> 01:03:31,823
and you're like, no, no, no, you don't do anything with audio.

1172
01:03:31,823 --> 01:03:34,224
You don't do anything with rendering.

1173
01:03:34,224 --> 01:03:37,305
You don't do anything, you know, dealing with,

1174
01:03:37,305 --> 01:03:39,446
I don't know, scene management.

1175
01:03:39,446 --> 01:03:41,626
That's all gonna be over here.

1176
01:03:42,451 --> 01:03:49,423
That's the hardest part is defining all those rules and levels of responsibility.

