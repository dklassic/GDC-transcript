1
00:00:11,925 --> 00:00:12,386
Hello, everyone.

2
00:00:13,166 --> 00:00:15,767
Thank you for joining me this afternoon for this dive in Halo Infinite.

3
00:00:16,848 --> 00:00:21,150
Before we begin, I just want to remind you everyone to silence your phones or turn them

4
00:00:21,190 --> 00:00:23,511
off so that we can have a smooth ride.

5
00:00:23,531 --> 00:00:28,713
I'm going to go pretty fast, so try and hang on until the end.

6
00:00:29,033 --> 00:00:30,134
It's going to be worth it, hopefully.

7
00:00:30,334 --> 00:00:31,374
And who knows?

8
00:00:31,394 --> 00:00:32,255
There might even be cake.

9
00:00:37,936 --> 00:00:38,977
My name is Daniele Giannetti.

10
00:00:39,938 --> 00:00:40,859
My pronouns are he and him,

11
00:00:41,299 --> 00:00:44,822
and I'm a principal architect at 343 Industries.

12
00:00:45,043 --> 00:00:47,745
What I mean practically is that I help on a lot of topics

13
00:00:47,785 --> 00:00:49,226
related to simulation in Halo games,

14
00:00:49,847 --> 00:00:52,449
mainly performance, threading, game and engine architecture,

15
00:00:53,190 --> 00:00:55,532
physics, navigation, some streaming, some other stuff.

16
00:00:55,813 --> 00:00:57,134
Probably a bit too many things.

17
00:00:58,755 --> 00:01:00,116
3x3 Industries is the house of Halo,

18
00:01:00,757 --> 00:01:03,059
and over there we deal with all things

19
00:01:03,099 --> 00:01:04,019
related to the franchise.

20
00:01:04,240 --> 00:01:05,961
And the shooter team at 3x3 Industries

21
00:01:06,081 --> 00:01:07,702
is the team that delivered Halo Infinite,

22
00:01:08,363 --> 00:01:09,904
the biggest title from the company yet.

23
00:01:11,305 --> 00:01:12,446
And previous titles from the team

24
00:01:12,526 --> 00:01:14,427
include Halo 4 and Halo 5 Guardians.

25
00:01:16,929 --> 00:01:18,250
Before we jump in, I just wanted to show

26
00:01:18,270 --> 00:01:19,571
a quick video of the game so that we understand

27
00:01:19,591 --> 00:01:20,232
what we're talking about.

28
00:01:21,192 --> 00:01:21,373
Enjoy.

29
00:01:29,107 --> 00:01:29,487
It's enough.

30
00:02:00,353 --> 00:02:04,036
So yeah, Halo Infinite is a first-person online multiplayer

31
00:02:04,056 --> 00:02:04,336
shooter.

32
00:02:05,356 --> 00:02:08,558
And it's a competitive game with some casual-friendly modes

33
00:02:08,618 --> 00:02:08,939
as well.

34
00:02:09,639 --> 00:02:11,280
And at the same time, the Halo Infinite campaign

35
00:02:11,420 --> 00:02:13,561
is a narrative-driven experience that

36
00:02:14,022 --> 00:02:17,324
brings players into the largest open environment

37
00:02:17,344 --> 00:02:17,924
that we ever built.

38
00:02:19,503 --> 00:02:22,927
Today we're going to be focusing on some of the changes that we did on the Halo engine

39
00:02:23,067 --> 00:02:28,472
going from Halo 5 to Halo Infinite, and specifically how we transformed the engine from a single

40
00:02:28,512 --> 00:02:34,518
platform fixed frame rate engine tightly optimized for Xbox One at 60 FPS to a multi-platform

41
00:02:34,658 --> 00:02:35,599
viable frame rate engine.

42
00:02:36,874 --> 00:02:39,636
The Halo Infinite was always shipping on Xbox One.

43
00:02:39,656 --> 00:02:40,597
We knew that from the beginning.

44
00:02:41,138 --> 00:02:44,100
But this time we were also targeting Series X, Series S,

45
00:02:44,380 --> 00:02:45,121
and Windows PC.

46
00:02:45,821 --> 00:02:48,043
Obviously there is a large variability of hardware power

47
00:02:48,123 --> 00:02:49,104
on the right of the slide there.

48
00:02:49,665 --> 00:02:51,626
And we wanted to make sure that the game scaled naturally

49
00:02:51,666 --> 00:02:53,868
and consistently across all their hardware.

50
00:02:54,268 --> 00:02:56,890
And for PC players, we wanted to make sure

51
00:02:56,950 --> 00:02:59,292
that they could really tune their experience

52
00:02:59,633 --> 00:03:00,974
the way they wanted and play at the frame rate

53
00:03:00,994 --> 00:03:02,655
that they wanted, depending on their V-Sync

54
00:03:02,775 --> 00:03:03,496
and other things like that.

55
00:03:04,937 --> 00:03:07,119
So our agenda is gonna start with a deep dive

56
00:03:07,819 --> 00:03:09,220
in Halo 5 tech, our legacy,

57
00:03:09,660 --> 00:03:12,122
and specifically we're gonna be dissecting

58
00:03:12,242 --> 00:03:15,344
the two big challenges with that approach to execution.

59
00:03:15,844 --> 00:03:17,205
Specifically, what aspects of it

60
00:03:17,485 --> 00:03:19,126
made it a fixed framework engine,

61
00:03:19,967 --> 00:03:23,990
and what concerns we had scaling that execution

62
00:03:24,250 --> 00:03:25,571
to CPUs of different size.

63
00:03:26,671 --> 00:03:28,332
This is not a graphics talk.

64
00:03:29,539 --> 00:03:32,882
and I'm mainly going to be focusing on simulation workloads on the CPU.

65
00:03:33,383 --> 00:03:35,004
However, I'm going to be touching on some of the changes

66
00:03:35,024 --> 00:03:36,125
that we did to our renderer,

67
00:03:36,205 --> 00:03:38,047
specifically on the CPU side of our renderer,

68
00:03:38,448 --> 00:03:40,930
because they're crucial to understand the scalability solutions

69
00:03:40,950 --> 00:03:41,611
that we implemented.

70
00:03:42,952 --> 00:03:45,054
After all that and dissecting our solutions to those problems,

71
00:03:45,074 --> 00:03:48,618
we're going to walk together through one frame in the Engine

72
00:03:48,938 --> 00:03:50,360
across a variety of hardware targets.

73
00:03:51,501 --> 00:03:52,502
And then we're going to move on to some Q&A.

74
00:03:54,682 --> 00:03:56,622
Okay, let's start with our legacy, Halo 5 engine.

75
00:03:57,602 --> 00:04:00,543
So the Halo 5 engine being so tightly optimized for Xbox One,

76
00:04:00,643 --> 00:04:02,384
I'm showing an approximate high-level frame

77
00:04:02,724 --> 00:04:03,824
on the Xbox One CPU.

78
00:04:04,664 --> 00:04:06,685
Xbox One has eight physical cores,

79
00:04:06,765 --> 00:04:09,685
however only seven of them are accessible to the title,

80
00:04:10,165 --> 00:04:11,906
with the seventh core, CPU six,

81
00:04:11,946 --> 00:04:13,126
being half-shared with the system.

82
00:04:13,586 --> 00:04:15,807
So only roughly 50% of its bandwidth

83
00:04:15,867 --> 00:04:16,667
is guaranteed to the game.

84
00:04:18,340 --> 00:04:20,562
The Halo 5 engine had two principal threads,

85
00:04:20,842 --> 00:04:22,063
the main thread and the render thread

86
00:04:22,103 --> 00:04:24,566
that were responsible respectively

87
00:04:24,646 --> 00:04:28,329
for moving forward simulation and rendering work on the CPU.

88
00:04:29,750 --> 00:04:32,052
And they were affinitized to CPU zero and one.

89
00:04:33,613 --> 00:04:35,294
And we also had a set of four worker threads

90
00:04:35,795 --> 00:04:37,736
that were affinitized to CPU two through five,

91
00:04:37,997 --> 00:04:40,419
and they were mostly helping out on simulation work,

92
00:04:40,999 --> 00:04:42,220
and they were specialized in the sense

93
00:04:42,240 --> 00:04:44,302
that they were only picking up specific kinds of work,

94
00:04:44,622 --> 00:04:45,203
depending on the thread.

95
00:04:46,592 --> 00:04:49,354
On CPU 6, we relegated all of our latency-tolerant workloads

96
00:04:49,394 --> 00:04:51,016
like streaming, I-O, and things like that.

97
00:04:52,497 --> 00:04:55,159
And in classic two-threaded engine fashion,

98
00:04:55,279 --> 00:04:58,602
we are pipelining execution so that we are simulating frame

99
00:04:58,722 --> 00:05:02,225
N at the same time as we render frame N minus 1.

100
00:05:03,485 --> 00:05:05,947
The simulation frame starts with input sampling right there.

101
00:05:06,968 --> 00:05:09,991
And after a few more things, we move

102
00:05:10,051 --> 00:05:11,352
on to the core of the simulation,

103
00:05:11,932 --> 00:05:12,893
which we called Game Tick.

104
00:05:13,798 --> 00:05:16,940
The Game Tick includes a bunch of stuff

105
00:05:17,581 --> 00:05:20,603
like design scripting updates, the object update,

106
00:05:20,623 --> 00:05:22,564
which updates the logical state of all of our objects,

107
00:05:23,004 --> 00:05:24,906
physics stepping, animation updates,

108
00:05:25,106 --> 00:05:26,607
and transform updates for all the objects.

109
00:05:27,908 --> 00:05:28,789
After the simulation is done,

110
00:05:28,829 --> 00:05:30,109
we publish the results to the renderer,

111
00:05:30,510 --> 00:05:33,332
and in our case, this was a large mem copy

112
00:05:33,352 --> 00:05:34,473
of Game State to the renderer,

113
00:05:34,873 --> 00:05:36,054
so the renderer can operate on it

114
00:05:36,794 --> 00:05:38,976
and render it at the same time as we simulate the next frame.

115
00:05:40,494 --> 00:05:43,637
OK, but what made the Halo 5 engine a fixed frame rate

116
00:05:43,697 --> 00:05:44,118
engine then?

117
00:05:44,618 --> 00:05:46,820
Well, the game tick, just like I showed it,

118
00:05:47,701 --> 00:05:49,763
it always consumed a fixed amount of time.

119
00:05:50,044 --> 00:05:52,106
16.6 is how many seconds of time precisely.

120
00:05:52,866 --> 00:05:55,869
So the engine was hardwired to run at 60 FPS.

121
00:05:56,790 --> 00:05:58,612
So this ran reasonably well for Halo 5,

122
00:05:58,652 --> 00:06:00,854
where that was our only target on Xbox One.

123
00:06:01,655 --> 00:06:03,197
And this is how execution at a high level

124
00:06:03,237 --> 00:06:04,178
could have been on the console.

125
00:06:05,756 --> 00:06:08,117
Here in red, I have drawn the real world time

126
00:06:08,137 --> 00:06:09,818
split in 60 plus 60 second chunks.

127
00:06:10,758 --> 00:06:12,379
And in blue here, we have the simulation

128
00:06:12,519 --> 00:06:13,479
executing on the CPU.

129
00:06:14,400 --> 00:06:16,361
As you can see, if the simulation runs fast enough

130
00:06:16,461 --> 00:06:18,301
and we're able to publish the results to the renderer

131
00:06:18,682 --> 00:06:20,502
in our allotted amount of time for the frame,

132
00:06:21,323 --> 00:06:23,864
and the renderer is able to complete the rendering work

133
00:06:23,904 --> 00:06:25,525
on the CPU in that same amount of time,

134
00:06:25,565 --> 00:06:26,765
or 60 plus 60 seconds,

135
00:06:27,586 --> 00:06:31,027
and the GPU frame can finish in that exact amount of time,

136
00:06:31,727 --> 00:06:33,388
then we're able to maintain our throughput of 60 FPS.

137
00:06:35,385 --> 00:06:38,327
So this was most of the time the case in Halo 5,

138
00:06:38,728 --> 00:06:41,049
and also let's keep an eye on that green box

139
00:06:41,129 --> 00:06:42,831
that shows up at the beginning of the simulation frame.

140
00:06:43,191 --> 00:06:45,472
This is how I'm gonna represent input sampling from now on,

141
00:06:45,833 --> 00:06:47,354
and it's important for future discussions

142
00:06:47,394 --> 00:06:49,615
down in the slide, so keep an eye on it.

143
00:06:50,936 --> 00:06:52,017
Okay, so this is what happened

144
00:06:52,037 --> 00:06:54,038
when execution was working as intended.

145
00:06:54,379 --> 00:06:57,061
But what happened in Halo 5 if we had an execution delay?

146
00:06:57,561 --> 00:07:00,203
Maybe a big explosion or some unexpected workload

147
00:07:00,763 --> 00:07:01,604
coming into the simulation,

148
00:07:02,584 --> 00:07:04,346
since our sandbox is very physics-driven.

149
00:07:05,740 --> 00:07:08,842
Well, we had a strategy in Halo 5 to catch up on the lost time.

150
00:07:09,002 --> 00:07:10,182
We called it multi-ticking.

151
00:07:10,483 --> 00:07:12,263
And it's important to understand how this works,

152
00:07:12,383 --> 00:07:15,805
because we pretty much built our valuable framework

153
00:07:15,845 --> 00:07:16,765
model on top of this.

154
00:07:18,006 --> 00:07:21,368
The idea is, let's accumulate enough delay

155
00:07:22,288 --> 00:07:24,489
so that we're able to consume that time that we have

156
00:07:24,509 --> 00:07:27,410
accumulated and we have to catch up on in an entire additional

157
00:07:27,430 --> 00:07:30,232
game tick, like an additional 16.67 milliseconds of delay.

158
00:07:31,632 --> 00:07:31,752
And.

159
00:07:32,922 --> 00:07:37,102
when that happens, then we're able to perform multiple game ticks in a single frame.

160
00:07:37,803 --> 00:07:42,403
So for instance, here's a long frame. This frame lasts longer than 60.67 milliseconds of time,

161
00:07:42,523 --> 00:07:47,524
and assuming that we have a community enough delay, then here's a multi-tick frame. In this case,

162
00:07:47,564 --> 00:07:52,886
a double-tick frame, we are doing two game ticks and consuming 60.67 milliseconds of time times two,

163
00:07:53,046 --> 00:07:57,486
33.33 milliseconds. Great. So there was no clear

164
00:07:59,352 --> 00:08:01,074
It wasn't a guarantee that we were able to catch up

165
00:08:01,114 --> 00:08:02,535
on the lost time using this strategy.

166
00:08:02,915 --> 00:08:04,837
There was an assumption that the simulation

167
00:08:04,877 --> 00:08:06,138
was fast enough most of the time,

168
00:08:06,678 --> 00:08:08,800
and therefore, with the occasional spike,

169
00:08:08,820 --> 00:08:10,621
we were able to recover on the lost time

170
00:08:10,702 --> 00:08:12,103
using additional game ticks.

171
00:08:13,103 --> 00:08:14,745
But obviously, if the game tick itself,

172
00:08:14,905 --> 00:08:16,827
it takes longer to run on the CPU

173
00:08:16,847 --> 00:08:18,068
than the time is able to consume,

174
00:08:18,128 --> 00:08:19,228
say, 16.6 million seconds,

175
00:08:19,629 --> 00:08:21,070
then we would have accumulated even more delay.

176
00:08:21,731 --> 00:08:23,312
But this assumption held through most of the time,

177
00:08:23,492 --> 00:08:24,853
so this works well enough for Halo 5.

178
00:08:26,423 --> 00:08:28,183
But what is the effect of this approach

179
00:08:28,224 --> 00:08:29,784
to catching up on lost time?

180
00:08:31,285 --> 00:08:33,866
Well, if you focus on those black lines towards the bottom,

181
00:08:34,266 --> 00:08:37,947
that's the time that elapses from input sampling

182
00:08:37,967 --> 00:08:40,368
for a frame to the end of the GPU work for that frame,

183
00:08:40,388 --> 00:08:41,348
which is when we do our present.

184
00:08:42,272 --> 00:08:45,434
While this is not exactly the same as our input to image

185
00:08:45,474 --> 00:08:48,076
on screen latency, it's representative of that quantity.

186
00:08:48,777 --> 00:08:50,539
So as you can see, when we have a spike,

187
00:08:50,919 --> 00:08:52,660
like the first frame, a longer frame,

188
00:08:53,461 --> 00:08:54,942
and when we also do multiple ticks,

189
00:08:55,563 --> 00:08:56,784
like in the second frame on this slide,

190
00:08:57,364 --> 00:09:01,368
the total input to image on screen time is longer.

191
00:09:02,248 --> 00:09:04,670
So effectively, the result on players and player experience

192
00:09:04,730 --> 00:09:06,412
was a small g-thread in input latency.

193
00:09:06,492 --> 00:09:07,313
But if

194
00:09:10,237 --> 00:09:15,224
If our delays were seldom and we were able to quickly catch up and recover, then this

195
00:09:15,244 --> 00:09:15,925
was fine.

196
00:09:15,945 --> 00:09:21,113
It wasn't easy to detect for the players, even professional players, and we were happy

197
00:09:21,133 --> 00:09:21,674
with this for Halo 5.

198
00:09:23,373 --> 00:09:26,375
So here's an x-ray of what happens in the case of a game

199
00:09:26,676 --> 00:09:27,396
double tick frame.

200
00:09:28,117 --> 00:09:29,618
As you can see, we are doing two game ticks.

201
00:09:30,299 --> 00:09:33,121
And it's approximate, but as you can see,

202
00:09:33,161 --> 00:09:35,023
we're duplicating most of our core workloads.

203
00:09:35,163 --> 00:09:37,525
We are doing the design scripting update twice.

204
00:09:38,165 --> 00:09:40,487
We are updating the logical state for all of our objects

205
00:09:40,507 --> 00:09:40,868
twice.

206
00:09:41,268 --> 00:09:42,309
We are updating physics twice.

207
00:09:42,329 --> 00:09:44,090
We are updating the transforms for all of our objects twice.

208
00:09:45,311 --> 00:09:47,593
And obviously, this is expensive.

209
00:09:48,992 --> 00:09:51,253
But obviously, we weren't doing everything twice.

210
00:09:51,293 --> 00:09:52,633
We were simply input once,

211
00:09:52,713 --> 00:09:55,114
where also some other workloads were only done once,

212
00:09:55,194 --> 00:09:56,595
and also we were publishing the simulation

213
00:09:56,695 --> 00:09:57,995
only once to the renderer, of course.

214
00:10:00,016 --> 00:10:00,616
Okay, so great.

215
00:10:00,696 --> 00:10:02,777
So we understand we have game ticks, we can double tick,

216
00:10:03,377 --> 00:10:05,037
but we still have the same core problem.

217
00:10:05,117 --> 00:10:07,078
We are simulating in discrete,

218
00:10:07,118 --> 00:10:08,858
since input is in the same millisecond intervals.

219
00:10:10,379 --> 00:10:12,400
And for Halo Infinite, this was just not good enough.

220
00:10:13,174 --> 00:10:15,495
Yes, we were shipping at 60 FPS on Series X,

221
00:10:15,975 --> 00:10:16,776
at least by default.

222
00:10:17,436 --> 00:10:20,398
But we also wanted to enable 120 FPS performance

223
00:10:20,438 --> 00:10:21,258
mode on the console.

224
00:10:21,998 --> 00:10:25,500
And for PC, we wanted to be able to scale naturally

225
00:10:25,540 --> 00:10:27,341
to the player rigs.

226
00:10:27,581 --> 00:10:29,202
And if they had a massive machine,

227
00:10:29,242 --> 00:10:31,563
then we wanted to scale up to 144 plus FPS

228
00:10:32,624 --> 00:10:34,905
with arbitrarily configurable frame rate.

229
00:10:35,825 --> 00:10:38,266
And we really wanted to show smooth motion

230
00:10:38,607 --> 00:10:39,467
at all those rates.

231
00:10:40,735 --> 00:10:44,036
We didn't want to be constrained by this stuttery 60 FPS simulation upgrade.

232
00:10:45,177 --> 00:10:50,319
On top of that, we also had another requirement, which was a design requirement that the physics-driven

233
00:10:50,339 --> 00:10:53,720
Halo sandbox had to feel the same across all of our targets.

234
00:10:54,580 --> 00:10:56,781
And not only that, it was a design requirement.

235
00:10:56,821 --> 00:10:58,122
It was actually a technical requirement.

236
00:10:58,782 --> 00:10:59,222
Because our...

237
00:11:00,963 --> 00:11:08,047
Gameplay networking model for Halo Infinite actually relies on near determinism for all of our physics driven sandbox the core of our simulation

238
00:11:08,687 --> 00:11:11,229
This is in order to do something that we call deterministic

239
00:11:11,269 --> 00:11:17,772
Reprediction and I'm not gonna get into details of how that that gameplay networking model works, but trust me. This was a requirement for us

240
00:11:20,954 --> 00:11:22,595
Okay, so we're gonna look at how we

241
00:11:23,748 --> 00:11:24,749
how we solve those challenges.

242
00:11:24,829 --> 00:11:28,031
But before we go there, let's talk about the second big challenge of Halo 5 tech,

243
00:11:28,671 --> 00:11:31,613
which we named Tetris Scheduling.

244
00:11:32,793 --> 00:11:34,974
So this is the same picture that I showed at the beginning of the presentation,

245
00:11:35,875 --> 00:11:38,376
the approximate Halo 5 frame on the Xbox One CPU.

246
00:11:39,197 --> 00:11:43,039
If we focus on that box there, we see some workloads running on the worker threads.

247
00:11:43,579 --> 00:11:47,101
We have audio simulation, the AI pre-update, a few other things.

248
00:11:48,552 --> 00:11:50,114
So the AI pre-update specifically

249
00:11:50,294 --> 00:11:52,938
was scheduled early on by the main thread, by the main loop.

250
00:11:53,458 --> 00:11:55,141
It would say, OK, let's do the AI pre-update now

251
00:11:55,321 --> 00:11:56,983
on this worker, let's say worker 2.

252
00:11:57,764 --> 00:11:59,687
And then it would do some more stuff, and sometime later,

253
00:11:59,787 --> 00:12:01,690
it would synchronize with the end of that work

254
00:12:01,750 --> 00:12:04,413
and continue AI execution on the main thread with the AI update.

255
00:12:05,950 --> 00:12:10,232
This was scheduled this way because we knew that early on in the simulation frame, in

256
00:12:10,252 --> 00:12:14,434
that specific spot on the Xbox One CPU, we would have had idle time.

257
00:12:14,734 --> 00:12:18,855
That core would have been able to execute that workload, at least in an average frame.

258
00:12:19,516 --> 00:12:20,516
And this was not the only case.

259
00:12:20,616 --> 00:12:26,259
A lot of workloads were scheduled this way, where we handcrafted this manual schedule

260
00:12:26,279 --> 00:12:29,360
of game systems to try and maximize the utilization of the Xbox One CPU.

261
00:12:31,307 --> 00:12:34,748
But obviously, this solution does not scale well at all

262
00:12:34,788 --> 00:12:36,048
to CPUs of different sizes.

263
00:12:36,589 --> 00:12:37,929
If you consider the scenario where

264
00:12:38,009 --> 00:12:40,990
we have a PC CPU with 20 logical cores,

265
00:12:41,450 --> 00:12:42,991
then we can either change the number of threads,

266
00:12:43,051 --> 00:12:45,192
but then we also have to change this handcrafted schedule

267
00:12:45,212 --> 00:12:46,873
of game systems on the various threads.

268
00:12:47,593 --> 00:12:49,093
Or we cannot change the number of threads

269
00:12:49,133 --> 00:12:51,234
and leave this Xbox One configuration only,

270
00:12:51,694 --> 00:12:53,475
which means that we're going to dramatically underutilize

271
00:12:53,495 --> 00:12:53,895
the hardware.

272
00:12:55,242 --> 00:12:57,883
Similarly, if you have a small PC CPU

273
00:12:58,003 --> 00:12:59,344
with only four logical cores,

274
00:12:59,404 --> 00:13:01,286
then either we have to change the number of threads

275
00:13:01,326 --> 00:13:02,667
and reschedule everything again,

276
00:13:03,267 --> 00:13:05,548
or we can leave this same number of threads,

277
00:13:05,629 --> 00:13:06,609
but there's an assumption here

278
00:13:06,629 --> 00:13:08,490
that we can run all these threads simultaneously,

279
00:13:08,510 --> 00:13:09,711
and that's just not true

280
00:13:09,731 --> 00:13:11,012
if you only have four logical cores,

281
00:13:11,052 --> 00:13:12,713
so you're gonna interfere with your own workloads.

282
00:13:13,934 --> 00:13:15,115
So this didn't scale well at all for us.

283
00:13:15,655 --> 00:13:16,936
But it was also an additional problem,

284
00:13:16,956 --> 00:13:19,838
which was a maintenance problem with this solution.

285
00:13:20,398 --> 00:13:21,119
So let's get into that.

286
00:13:23,372 --> 00:13:26,054
So this is pseudocode that shows what I just described.

287
00:13:26,234 --> 00:13:28,476
Early on in the main loop, we will schedule the AI pre-update.

288
00:13:28,496 --> 00:13:29,697
Then we do some more stuff.

289
00:13:30,057 --> 00:13:31,077
At some point, we wait for it.

290
00:13:31,658 --> 00:13:33,759
And then we perform the AI update on the main loop.

291
00:13:34,480 --> 00:13:34,660
Great.

292
00:13:35,601 --> 00:13:37,462
So for Halo Infinite, let's say that there's a new engineer.

293
00:13:37,482 --> 00:13:38,282
They're writing a system.

294
00:13:38,422 --> 00:13:39,984
This system is updating the player aim vector.

295
00:13:40,004 --> 00:13:41,364
I'm just making things up here.

296
00:13:42,285 --> 00:13:44,427
And they need to take this system every frame.

297
00:13:44,767 --> 00:13:46,108
So they find a spot in the main loop.

298
00:13:46,388 --> 00:13:47,529
They stick it right there.

299
00:13:48,009 --> 00:13:48,709
Everything works great.

300
00:13:51,027 --> 00:13:53,049
Now, someone else comes along, and they're

301
00:13:53,169 --> 00:13:53,949
looking at the system.

302
00:13:54,190 --> 00:13:55,871
And it turns out that the player aim update system is

303
00:13:55,911 --> 00:13:56,451
pretty long.

304
00:13:56,671 --> 00:13:59,093
And because it's sitting on the main loop, it's making our

305
00:13:59,193 --> 00:14:00,514
simulation long pole longer.

306
00:14:00,895 --> 00:14:04,678
So we want to move it to a thread and parallelize it with

307
00:14:04,878 --> 00:14:06,539
the rest of the stuff that is happening on the main loop.

308
00:14:07,580 --> 00:14:11,142
So I'm looking at this code, and I'm like, OK, does the

309
00:14:11,182 --> 00:14:14,605
player aim update system have to finish or have to start

310
00:14:14,805 --> 00:14:16,166
after the pre-update is done?

311
00:14:17,267 --> 00:14:19,489
Does it have to finish before the AI update on the main

312
00:14:19,509 --> 00:14:20,189
thread can execute?

313
00:14:21,122 --> 00:14:23,143
It's really impossible to tell just looking at this code.

314
00:14:23,984 --> 00:14:25,565
And there were a lot of implicit dependencies

315
00:14:25,625 --> 00:14:27,847
that were just implicit in the way the code was written

316
00:14:27,867 --> 00:14:30,450
or the code was scheduled.

317
00:14:31,390 --> 00:14:33,192
And in order for me to do this operation safely

318
00:14:33,232 --> 00:14:36,114
of moving that workload on a thread,

319
00:14:36,134 --> 00:14:38,817
I need to do a deep inspection of all the systems involved

320
00:14:39,337 --> 00:14:40,698
or have that tribal knowledge somehow.

321
00:14:42,178 --> 00:14:43,679
But this is obviously extremely simplified.

322
00:14:44,500 --> 00:14:46,861
Our situation was much more complicated than this,

323
00:14:46,921 --> 00:14:47,961
but this is more representative.

324
00:14:48,641 --> 00:14:50,562
Multiple systems were being added to Halo Infinite,

325
00:14:50,983 --> 00:14:53,544
or rewritten to implement new gameplay functionality.

326
00:14:54,742 --> 00:14:57,664
And we also had branching code paths

327
00:14:57,704 --> 00:14:59,565
that were scheduling workloads differently

328
00:14:59,625 --> 00:15:01,066
depending on the game mode.

329
00:15:01,906 --> 00:15:06,269
So this was quickly becoming a maintenance nightmare for us.

330
00:15:07,089 --> 00:15:08,930
It was very hard to maintain this code efficient

331
00:15:09,010 --> 00:15:10,491
as systems were being added or rewritten,

332
00:15:11,092 --> 00:15:13,113
and new engineers writing new systems

333
00:15:13,873 --> 00:15:14,974
were very hard to onboard.

334
00:15:15,995 --> 00:15:17,916
on how to write efficient code.

335
00:15:18,216 --> 00:15:20,857
So they will default to doing the simplest thing possible,

336
00:15:20,917 --> 00:15:22,197
which was just adding the systems

337
00:15:22,217 --> 00:15:24,718
to the main loop long pole.

338
00:15:27,159 --> 00:15:28,480
Because they were also completely thrown off

339
00:15:28,540 --> 00:15:32,121
by all the overhead of this threaded,

340
00:15:32,241 --> 00:15:33,662
this scheduling works in a threaded manner.

341
00:15:34,622 --> 00:15:35,923
And by this implicit dependencies,

342
00:15:35,943 --> 00:15:37,283
they just didn't have that knowledge required.

343
00:15:38,673 --> 00:15:41,395
So this led to a massive bowl of spaghetti nightmare

344
00:15:41,415 --> 00:15:41,855
maintenance.

345
00:15:42,335 --> 00:15:43,476
I wanted to bring, for this slide,

346
00:15:43,496 --> 00:15:45,897
I wanted to bring a really ugly bowl of spaghetti

347
00:15:45,977 --> 00:15:46,758
to carry the message.

348
00:15:46,858 --> 00:15:48,579
But you should know that I'm Italian,

349
00:15:48,619 --> 00:15:51,301
and I grew up in Italy, so I would never disrespect spaghetti.

350
00:15:52,101 --> 00:15:56,384
So here's a very inviting plate of pasta for you instead.

351
00:15:58,385 --> 00:15:59,806
But believe me, this was actually a really big problem

352
00:15:59,826 --> 00:16:00,086
for us.

353
00:16:01,747 --> 00:16:04,029
OK, so now we can finally move on to Halo Infinite.

354
00:16:09,163 --> 00:16:11,904
We're gonna start discussing how we solve the problem

355
00:16:12,244 --> 00:16:13,464
of achieving viable frame rate.

356
00:16:15,825 --> 00:16:17,406
Remember, we only had the game tick.

357
00:16:17,606 --> 00:16:19,626
The game tick was consuming 16.67 millisecond

358
00:16:19,686 --> 00:16:20,887
intervals of time every time.

359
00:16:21,307 --> 00:16:23,247
And we didn't want to be stuck with this stuttery

360
00:16:23,327 --> 00:16:25,348
simulation of 16.67 millisecond intervals.

361
00:16:26,389 --> 00:16:26,889
So what did we do?

362
00:16:27,689 --> 00:16:29,830
We split the time consumed by the engine

363
00:16:29,950 --> 00:16:31,470
in two different kinds of time.

364
00:16:32,693 --> 00:16:34,514
we kept the concept of fixed update time

365
00:16:34,995 --> 00:16:38,077
that is still consumed in 60.67 millisecond intervals

366
00:16:38,197 --> 00:16:40,919
inside the game tick, just like it happened in Halo 5.

367
00:16:41,660 --> 00:16:45,743
Now, systems that require a fixed update rate

368
00:16:45,803 --> 00:16:48,885
to maintain their behavior consistent,

369
00:16:49,486 --> 00:16:51,747
or that are part of our deterministic network simulation

370
00:16:52,328 --> 00:16:53,549
framework and sandbox,

371
00:16:54,329 --> 00:16:56,251
they are then called fixed update systems,

372
00:16:56,951 --> 00:16:58,853
and they consume fixed update time,

373
00:16:58,933 --> 00:17:00,374
and they're still updated inside the game tick,

374
00:17:00,694 --> 00:17:01,515
just like it happened in Halo 5.

375
00:17:04,027 --> 00:17:06,028
This includes, for instance, our physics simulation,

376
00:17:06,048 --> 00:17:07,388
which is the core of the Halo sandbox.

377
00:17:08,829 --> 00:17:10,990
But we also introduced the concept of valuable update time.

378
00:17:11,630 --> 00:17:12,751
This is the actual time delta

379
00:17:12,771 --> 00:17:14,112
since the beginning of the previous frame.

380
00:17:14,952 --> 00:17:18,354
And for systems that are able to maintain their behavior

381
00:17:18,394 --> 00:17:19,254
more or less consistent

382
00:17:19,334 --> 00:17:21,055
when consuming a different amount of time,

383
00:17:21,315 --> 00:17:23,296
and this time could change every frame potentially,

384
00:17:24,877 --> 00:17:26,678
and systems that are pretty much eye candy

385
00:17:26,698 --> 00:17:27,478
and not really affecting

386
00:17:27,518 --> 00:17:30,400
the deterministic sandbox simulation of Halo.

387
00:17:31,708 --> 00:17:36,470
then we can convert them to consuming this kind of time,

388
00:17:36,610 --> 00:17:38,250
and we call them valuable frame rate systems.

389
00:17:39,131 --> 00:17:40,431
These systems are still updated

390
00:17:40,471 --> 00:17:42,452
as part of the simulation loop,

391
00:17:42,532 --> 00:17:43,913
but they're updated outside of the GameTick.

392
00:17:45,493 --> 00:17:47,414
Also note, in Hello Infinite terminology,

393
00:17:47,554 --> 00:17:50,155
I'm gonna use GameTick and FixedUpdates interchangeably,

394
00:17:50,355 --> 00:17:51,376
since they're synonyms for us,

395
00:17:51,936 --> 00:17:52,956
so I'm gonna use them interchangeably

396
00:17:53,036 --> 00:17:53,997
for the rest of the presentation.

397
00:17:54,957 --> 00:17:55,998
Okay, so let's look at an example.

398
00:17:56,895 --> 00:17:58,936
If the engine is configured in the contrived way

399
00:17:58,976 --> 00:18:02,399
to run at 40 FPS, which I know nobody would ever do this,

400
00:18:02,519 --> 00:18:06,822
but just as an example, then every frame,

401
00:18:06,922 --> 00:18:09,343
if we don't have any performance issues, is 25 milliseconds.

402
00:18:09,904 --> 00:18:11,945
That is going to be the amount of valuable update time

403
00:18:11,965 --> 00:18:13,926
that valuable frame rate systems will consume every frame.

404
00:18:14,807 --> 00:18:17,329
But for fixed update systems that they have to keep on par

405
00:18:17,389 --> 00:18:18,590
with the valuable update timeline,

406
00:18:19,130 --> 00:18:22,452
they are going to have to update three times in two frames,

407
00:18:22,793 --> 00:18:24,634
because three times 16.7 milliseconds is 50 milliseconds.

408
00:18:26,683 --> 00:18:28,284
And so we end up with this really interesting

409
00:18:28,344 --> 00:18:30,684
execution pattern of one or two game ticks

410
00:18:30,764 --> 00:18:31,564
in alternating frames.

411
00:18:36,305 --> 00:18:39,246
So, this is all well and good,

412
00:18:39,506 --> 00:18:41,386
and we understand now that variable frame rate systems,

413
00:18:41,446 --> 00:18:42,546
because they're updating every frame,

414
00:18:42,566 --> 00:18:44,007
and they're consuming the right amount of time,

415
00:18:44,507 --> 00:18:45,467
are regardless of the frame rate,

416
00:18:45,487 --> 00:18:47,247
they're gonna be able to show smooth progress.

417
00:18:47,907 --> 00:18:49,148
But what about fixed update systems?

418
00:18:49,268 --> 00:18:51,148
Those are still some of the systems

419
00:18:51,168 --> 00:18:53,228
that we care the most about, like our physical simulation.

420
00:18:55,115 --> 00:18:57,876
Well, what we did is we introduced an additional system

421
00:18:57,896 --> 00:19:00,237
that we call Twinning, and it's an interpolation system

422
00:19:00,357 --> 00:19:03,479
whose job is to project the result of fixed update systems

423
00:19:03,859 --> 00:19:04,940
from the fixed update timeline

424
00:19:05,020 --> 00:19:06,561
into the variable update timeline.

425
00:19:07,841 --> 00:19:09,882
And this is in order to give the player

426
00:19:09,922 --> 00:19:11,443
the illusion of smooth motion,

427
00:19:11,643 --> 00:19:13,444
even though the simulation is not actually advancing

428
00:19:13,484 --> 00:19:13,924
at that rate.

429
00:19:15,065 --> 00:19:15,805
Let's look at an example.

430
00:19:16,626 --> 00:19:19,147
So here's the game configured to run at 120 FPS.

431
00:19:19,327 --> 00:19:21,808
So this could be Xbox Series X, for instance,

432
00:19:21,909 --> 00:19:22,649
in performance mode.

433
00:19:24,101 --> 00:19:26,342
And assuming that we don't have any performance issue,

434
00:19:26,583 --> 00:19:29,045
just for simplicity, then each frame

435
00:19:29,125 --> 00:19:30,746
is 8.33 milliseconds of time.

436
00:19:31,366 --> 00:19:33,168
And that's the amount of time the variable update systems are

437
00:19:33,188 --> 00:19:34,149
going to consume every frame.

438
00:19:36,491 --> 00:19:39,253
So because fixed update systems only

439
00:19:39,273 --> 00:19:41,235
consume time in discrete intervals of 16.67

440
00:19:41,275 --> 00:19:43,436
milliseconds of time, then we only

441
00:19:43,476 --> 00:19:46,339
need one fixed update every two frames, which

442
00:19:46,399 --> 00:19:47,720
makes 16.67 milliseconds.

443
00:19:48,520 --> 00:19:51,003
And so we end up with this pattern of one or zero

444
00:19:51,043 --> 00:19:52,604
fixed updates in alternating frames at 120 FPS.

445
00:19:54,768 --> 00:19:56,549
And so, after our simulation is complete,

446
00:19:56,689 --> 00:19:58,350
before we publish the results to the renderer,

447
00:19:58,730 --> 00:20:01,291
what we're gonna do is we're gonna interpolate in memory

448
00:20:01,371 --> 00:20:03,552
the results of the two most recent fixed updates

449
00:20:03,852 --> 00:20:04,633
that we have completed.

450
00:20:06,714 --> 00:20:07,654
And this is in order to project

451
00:20:07,734 --> 00:20:09,695
on the variable update timeline at the right time.

452
00:20:10,616 --> 00:20:11,656
So here's an example frame.

453
00:20:12,237 --> 00:20:13,577
Just let's focus on that for a second.

454
00:20:14,078 --> 00:20:16,399
So this frame doesn't actually have any fixed updates,

455
00:20:16,879 --> 00:20:19,220
or even, we're not even stepping physics this frame at all.

456
00:20:20,553 --> 00:20:22,915
But we still have in memory the results for Fix Update 1

457
00:20:23,055 --> 00:20:23,896
and Fix Update 2.

458
00:20:24,436 --> 00:20:25,137
So we can use them.

459
00:20:25,297 --> 00:20:27,719
And we're going to interpolate at the right time

460
00:20:28,199 --> 00:20:29,940
before producing the results that we're

461
00:20:29,960 --> 00:20:30,841
going to send to the renderer.

462
00:20:31,662 --> 00:20:34,264
So in this slide, I have used dark blue and light blue

463
00:20:34,484 --> 00:20:37,326
as a blend to show the blending going into the renderer CPU

464
00:20:37,346 --> 00:20:37,546
frame.

465
00:20:40,280 --> 00:20:41,861
Okay, great, so we understand this strategy,

466
00:20:42,581 --> 00:20:44,162
but let's focus on that input for a second.

467
00:20:44,442 --> 00:20:45,563
This is the input for this frame.

468
00:20:46,324 --> 00:20:48,025
So this input is consumed normally

469
00:20:48,125 --> 00:20:50,206
by variable frame rate systems updating this frame,

470
00:20:50,906 --> 00:20:52,908
but because we're not updating any fixed update systems,

471
00:20:53,748 --> 00:20:54,729
they can't consume this input.

472
00:20:55,389 --> 00:20:56,950
And the fixed update system results

473
00:20:56,990 --> 00:20:59,252
that we're using to draw this frame

474
00:20:59,872 --> 00:21:01,673
are actually coming from previous frames,

475
00:21:01,833 --> 00:21:03,715
so we definitely didn't consume this input

476
00:21:03,755 --> 00:21:04,775
for those fixed update.

477
00:21:06,888 --> 00:21:08,811
So effectively, what this approach interpolation does

478
00:21:08,831 --> 00:21:11,615
is it adds an additional latency to any input

479
00:21:11,635 --> 00:21:13,598
that is affecting fixed update system results.

480
00:21:15,280 --> 00:21:16,762
And that latency has the minimum

481
00:21:16,802 --> 00:21:18,244
of the simplest assembly seconds of time,

482
00:21:18,644 --> 00:21:20,587
which is our update rate for fixed update systems.

483
00:21:22,555 --> 00:21:26,576
Another interesting thing is, notice how some frames have a fixed update and some frames

484
00:21:26,596 --> 00:21:27,496
do not on the simulation.

485
00:21:27,696 --> 00:21:31,497
This means that we have every frame, we have a variable amount of CPU work to do in the

486
00:21:31,537 --> 00:21:33,738
simulation, which could be a performance concern.

487
00:21:34,518 --> 00:21:38,619
Now in practice, this wasn't an issue for us because in all the platforms where we were

488
00:21:38,779 --> 00:21:43,921
aiming for more than 60 FPS, we were not CPU bound typically, so this slight oscillation

489
00:21:43,961 --> 00:21:46,261
of workload was not a big problem for us in practice.

490
00:21:47,813 --> 00:21:50,676
Okay, so going back to that contrived example of 40 FPS,

491
00:21:51,316 --> 00:21:52,577
then the situation is identical.

492
00:21:53,418 --> 00:21:56,180
We are still going to interpolate between the results

493
00:21:56,260 --> 00:21:58,261
of the two most recent fixed updates that we have in memory.

494
00:21:58,822 --> 00:22:00,503
So focusing on that frame there, for instance,

495
00:22:01,063 --> 00:22:02,344
we're gonna interpolate between the results

496
00:22:02,384 --> 00:22:03,665
of fixed to the two and fixed to the three

497
00:22:04,126 --> 00:22:05,907
before publishing the results to the renderer.

498
00:22:06,888 --> 00:22:08,369
And it just so happens that this frame,

499
00:22:08,469 --> 00:22:10,991
these two fixed updates are within the simulation frame

500
00:22:11,711 --> 00:22:13,352
that we are in, but that's just because

501
00:22:13,392 --> 00:22:14,813
the engine is running slower,

502
00:22:14,934 --> 00:22:16,134
because we're at 40 FPS instead of 120 FPS.

503
00:22:17,500 --> 00:22:18,700
but the strategy is exactly the same.

504
00:22:20,181 --> 00:22:21,381
Okay, so we chose to interpolate,

505
00:22:22,222 --> 00:22:23,642
but we could have extrapolated instead.

506
00:22:24,243 --> 00:22:26,484
So with extrapolation, basically what that means is

507
00:22:26,644 --> 00:22:28,865
we start from the fixed update system results

508
00:22:29,345 --> 00:22:30,585
of the latest game tick,

509
00:22:31,066 --> 00:22:32,666
and then we project them forward in time

510
00:22:32,706 --> 00:22:34,407
instead of interpolating between past results.

511
00:22:35,536 --> 00:22:37,557
So if we do that, then we're able to recover

512
00:22:37,637 --> 00:22:39,739
some of that additional input latency

513
00:22:39,759 --> 00:22:41,800
that I talked about for fix of the system results.

514
00:22:42,241 --> 00:22:45,803
However, we can produce incorrect results,

515
00:22:45,923 --> 00:22:47,064
and so we need to have a strategy

516
00:22:47,084 --> 00:22:48,945
to recover on the incorrect extrapolation.

517
00:22:49,626 --> 00:22:51,727
So it is a choice, but we chose to interpolate

518
00:22:51,767 --> 00:22:52,588
and never extrapolate.

519
00:22:53,629 --> 00:22:55,450
Also, what is that we interpolate?

520
00:22:55,990 --> 00:22:57,691
Well, we interpolate all object transforms

521
00:22:57,852 --> 00:22:59,553
and the transforms of all their nodes,

522
00:22:59,753 --> 00:23:02,215
which are basically the limbs of character

523
00:23:02,255 --> 00:23:04,696
and things that represent poses of characters.

524
00:23:06,287 --> 00:23:09,930
And we always do linear interpolation, even for rotations,

525
00:23:10,050 --> 00:23:11,291
because we know that the two samples

526
00:23:11,331 --> 00:23:12,992
that we're interpolating between

527
00:23:13,092 --> 00:23:15,214
are always exactly 16.6 milliseconds apart.

528
00:23:16,034 --> 00:23:17,775
And so it turns out that we didn't actually need

529
00:23:18,096 --> 00:23:21,338
that additional accuracy of SLURP for rotations.

530
00:23:22,959 --> 00:23:24,980
Also, we only process objects

531
00:23:25,000 --> 00:23:27,042
that are actually actively moving in a simulation.

532
00:23:28,002 --> 00:23:30,324
And so objects that are asleep on the ground,

533
00:23:30,344 --> 00:23:32,025
that are not really moving, we don't process at all.

534
00:23:32,466 --> 00:23:33,546
So there's some optimizations in place.

535
00:23:34,990 --> 00:23:36,912
Okay, so focus on Xbox One then.

536
00:23:38,493 --> 00:23:40,635
Because Xbox One was a 30 FPS platform,

537
00:23:41,176 --> 00:23:41,997
or target platform,

538
00:23:42,838 --> 00:23:44,619
then we have to do two fixed updates every frame

539
00:23:44,960 --> 00:23:45,540
in the simulation.

540
00:23:46,902 --> 00:23:50,005
But Xbox One was also one of our hardest CPU targets

541
00:23:50,045 --> 00:23:52,568
for optimization because it's a very slow CPU nowadays.

542
00:23:53,988 --> 00:23:55,849
So what we did in our optimization efforts

543
00:23:55,909 --> 00:23:58,651
is we focused on converting into variable frame rate

544
00:23:59,271 --> 00:24:01,993
as many heavy-hitting CPU systems as possible

545
00:24:02,033 --> 00:24:03,634
that were previously inside the Game Tick.

546
00:24:04,294 --> 00:24:05,996
And we successfully converted a bunch of them,

547
00:24:06,156 --> 00:24:07,637
and there's an incomplete list on the slide,

548
00:24:07,697 --> 00:24:09,898
but mainly we brought out of the Game Tick

549
00:24:10,639 --> 00:24:12,900
design scripting updates, AI logic updates,

550
00:24:13,280 --> 00:24:17,043
a bunch of player updates, audio lights, effects, and more.

551
00:24:21,097 --> 00:24:23,821
And for the systems that had to remain inside the game tick

552
00:24:24,082 --> 00:24:25,484
because they were part of the dissemination

553
00:24:25,504 --> 00:24:26,485
network simulation of the game,

554
00:24:27,106 --> 00:24:29,069
then we focused on shrinking that workloads

555
00:24:29,089 --> 00:24:31,071
as much as possible until they fit into,

556
00:24:31,652 --> 00:24:33,234
until we were able to fit two fixed updates

557
00:24:33,575 --> 00:24:35,898
inside the Xbox One frame in our worst case scenarios.

558
00:24:39,820 --> 00:24:41,541
OK, so we understand our variable frame rate model

559
00:24:41,561 --> 00:24:42,081
a little bit now.

560
00:24:42,261 --> 00:24:44,462
We're going to get to look at it in practice

561
00:24:44,663 --> 00:24:46,543
when we dissect together one frame towards the end

562
00:24:47,304 --> 00:24:47,904
in Halo Infinite.

563
00:24:48,404 --> 00:24:50,745
But before we go there, let's look at our solutions

564
00:24:51,586 --> 00:24:54,267
around achieving maintainable scalability

565
00:24:54,287 --> 00:24:55,768
across CPUs of different size.

566
00:24:57,441 --> 00:25:01,885
Okay, so you remember we had our Tetris scheduling problem

567
00:25:02,045 --> 00:25:04,187
where we had specialized worker threads,

568
00:25:04,227 --> 00:25:06,789
we were trying to handcraft the schedule of game systems

569
00:25:06,809 --> 00:25:08,491
to try and fill up the Xbox One CPU,

570
00:25:09,512 --> 00:25:10,733
and it was just not scaling for us,

571
00:25:10,793 --> 00:25:12,194
it was giving a lot of maintenance grief.

572
00:25:13,375 --> 00:25:13,895
So what did we do?

573
00:25:15,197 --> 00:25:19,661
Well, what we did is instead of explicitly scheduling

574
00:25:19,681 --> 00:25:21,983
the work and creating these implicit dependencies

575
00:25:22,003 --> 00:25:22,683
that we talked about,

576
00:25:23,752 --> 00:25:25,293
Let's declare the work up front,

577
00:25:25,733 --> 00:25:27,575
the work items up front, and call them jobs,

578
00:25:28,215 --> 00:25:29,776
and declare their dependencies up front,

579
00:25:30,016 --> 00:25:30,977
which are job dependencies.

580
00:25:31,557 --> 00:25:33,698
And then let the system implicitly schedule it.

581
00:25:34,699 --> 00:25:36,300
And so we wrote a new job system for this,

582
00:25:37,381 --> 00:25:39,342
and here's a small pseudocode example for it.

583
00:25:39,882 --> 00:25:40,943
The job system's a singleton.

584
00:25:41,903 --> 00:25:43,845
We can create a job graph within the job system,

585
00:25:44,305 --> 00:25:46,706
and I'm adding two jobs to it, job A and job B.

586
00:25:47,867 --> 00:25:49,568
And then I can create a dependency between these two jobs,

587
00:25:50,249 --> 00:25:51,750
specifying that job A has to complete

588
00:25:51,770 --> 00:25:52,690
before job B can start.

589
00:25:54,222 --> 00:25:55,363
and an SMA for execution.

590
00:25:56,223 --> 00:25:59,405
The job system's role is to take this job graph

591
00:25:59,565 --> 00:26:01,606
and run it, execute it, on the available

592
00:26:01,646 --> 00:26:03,927
execution resources according to the dependencies.

593
00:26:05,087 --> 00:26:08,769
So looking at a quick example, here's a simple job graph.

594
00:26:10,246 --> 00:26:12,448
If the job system is given this job graph to execute,

595
00:26:12,608 --> 00:26:15,571
it's going to be able to start job one immediately,

596
00:26:15,651 --> 00:26:16,732
because there's no dependencies on it.

597
00:26:17,152 --> 00:26:19,475
And then when job one is complete, job two and job four

598
00:26:19,515 --> 00:26:23,999
will be able to start and run potentially simultaneously

599
00:26:24,059 --> 00:26:25,340
if there is enough execution resources,

600
00:26:26,781 --> 00:26:27,462
and so on and so forth.

601
00:26:28,465 --> 00:26:30,366
But because we were adding these systems

602
00:26:30,386 --> 00:26:31,306
to an existing code base,

603
00:26:31,346 --> 00:26:33,668
and we still had a lot of legacy thread-driven work,

604
00:26:33,728 --> 00:26:35,389
specifically from the main thread, the rendered thread,

605
00:26:35,929 --> 00:26:37,710
we didn't want to have to rewrite all that.

606
00:26:37,730 --> 00:26:38,471
We didn't have the time.

607
00:26:39,291 --> 00:26:41,613
So what we did is we added a mechanism

608
00:26:41,673 --> 00:26:43,914
to synchronize legacy thread-driven work

609
00:26:44,034 --> 00:26:45,475
with new style jobified work.

610
00:26:46,035 --> 00:26:47,456
And we call this mechanism SyncPoints.

611
00:26:49,277 --> 00:26:51,919
The idea is you can add SyncPoints to a job graph,

612
00:26:52,239 --> 00:26:55,481
and jobs can take predecessor or successor dependencies

613
00:26:55,621 --> 00:26:57,562
on SyncPoints just like they do with other jobs.

614
00:26:58,980 --> 00:27:01,222
And effectively what happens when I'm executing

615
00:27:01,262 --> 00:27:03,924
this job graph here is main thread is executing happily,

616
00:27:03,944 --> 00:27:06,687
and then main thread hits the sync point one

617
00:27:06,847 --> 00:27:07,808
on its execution path.

618
00:27:08,589 --> 00:27:10,891
Main thread is not gonna be able to move beyond

619
00:27:11,131 --> 00:27:14,114
that sync point until job two is also completed.

620
00:27:14,754 --> 00:27:17,097
And similarly, job six will not be able to start

621
00:27:17,557 --> 00:27:20,980
until main thread's execution has moved beyond sync point one.

622
00:27:22,411 --> 00:27:23,992
We can look at a quick code example for that.

623
00:27:24,512 --> 00:27:25,593
So we still have the job graph here,

624
00:27:26,694 --> 00:27:28,275
and this time I'm adding a sync point,

625
00:27:28,355 --> 00:27:29,235
call it sync point X.

626
00:27:30,076 --> 00:27:32,057
And as you can see from the box on the bottom right,

627
00:27:32,578 --> 00:27:33,798
that sync point is triggered

628
00:27:33,858 --> 00:27:35,219
as part of the main threads execution.

629
00:27:35,800 --> 00:27:37,341
So it's effectively splitting

630
00:27:37,481 --> 00:27:39,122
the main threads execution loop

631
00:27:39,402 --> 00:27:42,344
into two logical workloads, workload one and workload two.

632
00:27:44,123 --> 00:27:47,364
And on top of that, I'm then adding two jobs,

633
00:27:47,404 --> 00:27:49,945
job A and job B, and I'm creating dependencies like this.

634
00:27:50,465 --> 00:27:53,685
Job A to sync point X, and sync point X to job B.

635
00:27:54,725 --> 00:27:55,886
So what I've done with this job graph

636
00:27:56,006 --> 00:27:58,266
is I've created a dependency chain

637
00:27:58,366 --> 00:28:02,047
where workload one has to complete before job B can start,

638
00:28:02,647 --> 00:28:04,327
and similarly, job A has to complete

639
00:28:04,367 --> 00:28:05,488
before workload two can start.

640
00:28:06,168 --> 00:28:08,308
So we're able to take this mixed legacy

641
00:28:08,328 --> 00:28:10,408
and new style dependencies with this system.

642
00:28:11,889 --> 00:28:12,909
Okay, so armed with this.

643
00:28:13,933 --> 00:28:16,094
with these new tools, then for the simulation,

644
00:28:16,474 --> 00:28:18,075
we introduced two kinds of job graph.

645
00:28:18,695 --> 00:28:21,076
The frame job graph is responsible

646
00:28:21,716 --> 00:28:24,897
for updating all valuable frame rate systems.

647
00:28:25,277 --> 00:28:28,418
So it gets created and submitted for execution

648
00:28:28,438 --> 00:28:29,538
at the beginning of every frame,

649
00:28:29,859 --> 00:28:31,479
and it updates all the valuable frame rate systems.

650
00:28:32,579 --> 00:28:34,960
And on top of that, that job graph is also responsible

651
00:28:35,040 --> 00:28:36,681
for building and submitting for execution

652
00:28:37,141 --> 00:28:38,661
a number of fixed update job graphs,

653
00:28:38,701 --> 00:28:39,942
depending on how many fixed updates

654
00:28:39,962 --> 00:28:40,762
we want to do this frame.

655
00:28:42,041 --> 00:28:44,984
So for instance, in the case of a frame with two game ticks,

656
00:28:45,064 --> 00:28:46,705
we're going to have the frame job graph doing

657
00:28:46,785 --> 00:28:48,066
variable update systems work.

658
00:28:48,507 --> 00:28:51,029
And then that's going to construct and submit

659
00:28:51,349 --> 00:28:53,371
two fixed update job graphs to perform the two game ticks.

660
00:28:55,763 --> 00:28:59,567
Okay, so job graph systems adoption for us was very good.

661
00:29:00,008 --> 00:29:02,691
It was indeed used as intended to re-implement

662
00:29:03,612 --> 00:29:05,393
a lot of our Tetris schedule systems.

663
00:29:06,074 --> 00:29:07,596
This included all of our AI systems,

664
00:29:08,176 --> 00:29:10,619
our design scripting systems, physics systems,

665
00:29:10,899 --> 00:29:12,481
effects and light simulation, and more.

666
00:29:14,243 --> 00:29:15,944
But even better, it was consistently adopted

667
00:29:16,004 --> 00:29:18,487
for new systems that were being added to Halo Infinite.

668
00:29:20,910 --> 00:29:23,894
An iceberg of the system is because engineers had to write,

669
00:29:23,914 --> 00:29:26,577
had to add all the items of work

670
00:29:26,757 --> 00:29:29,020
and the dependencies up front, then.

671
00:29:30,434 --> 00:29:33,375
they would often end up adding all these jobs

672
00:29:33,435 --> 00:29:35,556
and dependencies for a very high level system

673
00:29:35,596 --> 00:29:36,476
inside a single file.

674
00:29:36,956 --> 00:29:38,857
For instance, we had this AI job schedule.cpp

675
00:29:38,897 --> 00:29:41,237
that contained all of our high level AI workloads

676
00:29:41,717 --> 00:29:42,478
and their dependencies.

677
00:29:42,758 --> 00:29:45,539
So an engineer was able to crack open this file

678
00:29:45,659 --> 00:29:47,859
and understand at a high level how execution

679
00:29:47,879 --> 00:29:49,940
of this overarching system worked.

680
00:29:50,740 --> 00:29:52,601
So this was a nice perk for us.

681
00:29:53,801 --> 00:29:55,982
But an even better result of introducing this system

682
00:29:56,042 --> 00:29:58,642
is that it was actually used to implement

683
00:29:58,742 --> 00:29:59,923
our new multi-threaded renderer.

684
00:30:01,967 --> 00:30:06,109
So Halo 5 had a mostly single-threaded renderer

685
00:30:06,730 --> 00:30:09,651
and used a lot of console-specific tricks

686
00:30:09,711 --> 00:30:12,112
to achieve extremely high execution efficiency

687
00:30:12,432 --> 00:30:13,793
with very low CPU bandwidth.

688
00:30:14,493 --> 00:30:17,795
But for Halo Infinite, we were moving away from console only

689
00:30:18,776 --> 00:30:21,217
and Direct3D for PC has a lot more overhead.

690
00:30:21,657 --> 00:30:23,358
And on top of that, we also wanted to reintroduce

691
00:30:23,378 --> 00:30:25,439
split-screen in the franchise, which obviously means

692
00:30:25,499 --> 00:30:27,080
a lot more CPU work in the renderer.

693
00:30:27,660 --> 00:30:29,161
And we were also adding a whole slew

694
00:30:29,201 --> 00:30:30,201
of new rendering techniques.

695
00:30:31,150 --> 00:30:33,772
So we realized early on that we had to lean heavily

696
00:30:34,132 --> 00:30:36,073
on multi-threaded rendering for Halo Infinite to work

697
00:30:36,193 --> 00:30:36,893
and be performant.

698
00:30:37,613 --> 00:30:38,994
So we used the job system to implement this

699
00:30:39,154 --> 00:30:41,215
and Halo Infinite now has no render thread at all.

700
00:30:41,695 --> 00:30:42,195
It's just jobs.

701
00:30:43,876 --> 00:30:45,217
Here's an in-game visualization.

702
00:30:46,097 --> 00:30:47,738
It's a debug tool that shows job graphs

703
00:30:47,798 --> 00:30:49,259
and here's showing the render job graph.

704
00:30:49,899 --> 00:30:53,961
It's kind of hard to see, but each box here is a job

705
00:30:54,121 --> 00:30:56,622
and the lines between them are dependencies between jobs

706
00:30:57,002 --> 00:30:57,783
for the render job graph.

707
00:30:59,123 --> 00:31:00,864
Even though you probably can't read anything in here,

708
00:31:01,024 --> 00:31:04,326
you can note that there is quite a lot of potential parallelism

709
00:31:04,647 --> 00:31:06,007
between these jobs in the render job graph.

710
00:31:06,588 --> 00:31:08,849
So, you know, this multi-threaded renderer,

711
00:31:08,889 --> 00:31:09,950
it can go pretty parallel,

712
00:31:09,990 --> 00:31:12,472
depending on how much availability

713
00:31:12,512 --> 00:31:13,252
there is on the CPU.

714
00:31:14,053 --> 00:31:15,434
And the blue boxes here in the picture

715
00:31:15,534 --> 00:31:18,516
are part of the render job graph critical path.

716
00:31:19,056 --> 00:31:20,697
So, those are the jobs that you may want to focus on

717
00:31:20,737 --> 00:31:22,498
if you're trying to optimize end-to-end time.

718
00:31:24,010 --> 00:31:25,572
So yeah, in this jobified world,

719
00:31:25,932 --> 00:31:27,794
then our optimization effort became

720
00:31:28,295 --> 00:31:30,236
optimizing jobs that are along the critical path.

721
00:31:30,917 --> 00:31:34,220
Or, if we have available execution resources

722
00:31:34,300 --> 00:31:37,343
because we're not using the CPU as efficiently as we could,

723
00:31:37,984 --> 00:31:39,365
then we can also focus on

724
00:31:41,568 --> 00:31:44,150
either achieving better parallelism

725
00:31:44,190 --> 00:31:45,652
by either reshuffling these jobs

726
00:31:45,912 --> 00:31:48,514
or relaxing their dependencies, if we're able to.

727
00:31:49,804 --> 00:31:54,927
And another thing to note is that other than online inspection tools in-game,

728
00:31:54,947 --> 00:31:58,369
we also had offline inspection tools that allowed us to dump out a job graph

729
00:31:58,389 --> 00:32:02,512
and then look at its topology on our own time without running the game.

730
00:32:04,413 --> 00:32:10,737
Okay, so I mentioned that the job system's role was to schedule jobs

731
00:32:11,818 --> 00:32:13,219
on the available execution resources.

732
00:32:13,479 --> 00:32:16,021
But what are those execution resources in practice?

733
00:32:17,234 --> 00:32:19,676
So, Halo 5, as I showed before, had a set of worker threads

734
00:32:19,716 --> 00:32:21,136
and they were specialized so they were able

735
00:32:21,197 --> 00:32:22,457
to pick up specific kinds of work

736
00:32:22,497 --> 00:32:23,438
depending on the worker thread.

737
00:32:24,459 --> 00:32:26,220
For Halo Infinite, we don't have

738
00:32:26,300 --> 00:32:27,400
specialized worker threads anymore,

739
00:32:27,440 --> 00:32:29,201
we only have generic worker threads.

740
00:32:29,882 --> 00:32:32,704
And the real, we call, we have a pool of these worker threads

741
00:32:32,744 --> 00:32:34,144
that run a high priority and we call them

742
00:32:34,205 --> 00:32:35,125
real-time worker threads.

743
00:32:35,846 --> 00:32:37,727
And these threads are the ones responsible

744
00:32:37,827 --> 00:32:40,048
for picking up and executing all simulation

745
00:32:40,088 --> 00:32:41,409
and rendering jobs in the engine.

746
00:32:43,242 --> 00:32:44,503
So together with the main thread

747
00:32:44,543 --> 00:32:46,224
that is still doing simulation work for us,

748
00:32:46,724 --> 00:32:48,946
then these jobs are, sorry, these threads

749
00:32:49,006 --> 00:32:50,007
are the ones that are responsible

750
00:32:50,047 --> 00:32:51,709
for upkeeping the frame rate of the game.

751
00:32:52,890 --> 00:32:55,372
And these are mainly the execution resources

752
00:32:55,412 --> 00:32:58,354
that the job system targets for its dispatch of jobs.

753
00:33:00,556 --> 00:33:01,276
Other than these threads,

754
00:33:01,317 --> 00:33:02,578
we also have a set of background workers

755
00:33:02,638 --> 00:33:03,959
that are on a lower priority,

756
00:33:04,379 --> 00:33:09,023
and we use them for more latency tolerant work

757
00:33:09,063 --> 00:33:10,704
like disk IONs and some streaming stuff.

758
00:33:12,053 --> 00:33:14,640
And beyond this, we also have a set of third-party

759
00:33:14,661 --> 00:33:16,586
and legacy threads that we like to call Spurious.

760
00:33:17,248 --> 00:33:19,053
We call them Spurious because we wish they didn't exist.

761
00:33:20,755 --> 00:33:23,016
In practice, when you use a lot of third-party software,

762
00:33:23,036 --> 00:33:23,917
there's a lot of third-party software

763
00:33:23,937 --> 00:33:24,997
that likes to create their own threads.

764
00:33:25,998 --> 00:33:27,299
But unfortunately for us,

765
00:33:27,359 --> 00:33:29,820
because we are running these real-time workers

766
00:33:30,481 --> 00:33:34,603
at high priority, and they need to continue executing

767
00:33:34,623 --> 00:33:36,565
in order for us to keep our frame rate stable,

768
00:33:37,325 --> 00:33:40,567
then we really have to be careful about interference

769
00:33:40,667 --> 00:33:42,669
on these real-time workers, like content switch

770
00:33:42,709 --> 00:33:44,690
and other threads coming and stealing our cores.

771
00:33:45,550 --> 00:33:47,391
because they are responsible for executing

772
00:33:47,491 --> 00:33:50,392
all of our simulation rendering works cooperatively,

773
00:33:50,552 --> 00:33:52,413
like the jobs that run cooperatively scheduling.

774
00:33:53,453 --> 00:33:55,134
So what we do for these spurious threads

775
00:33:55,234 --> 00:33:58,395
is we configure them very carefully, one by one,

776
00:33:58,795 --> 00:34:00,856
to try and maximize their disruption

777
00:34:00,916 --> 00:34:02,777
with on real-time workers, depending on the case.

778
00:34:02,897 --> 00:34:05,398
Some of them need some real-time constraints,

779
00:34:05,438 --> 00:34:06,918
some of them can wait a long time,

780
00:34:06,998 --> 00:34:08,579
so we can be more aggressive on those.

781
00:34:10,587 --> 00:34:13,169
Okay, so we're gonna now look at this threading model

782
00:34:13,249 --> 00:34:14,890
and how it adapts to various platforms.

783
00:34:15,831 --> 00:34:17,092
So we're gonna start with Xbox One.

784
00:34:18,353 --> 00:34:20,294
So again, Xbox One, eight physical cores,

785
00:34:20,394 --> 00:34:21,455
seven accessible to the game,

786
00:34:21,635 --> 00:34:24,357
with CPU six, the last core, or seventh core,

787
00:34:24,477 --> 00:34:25,518
being half-shared with the system.

788
00:34:26,979 --> 00:34:29,041
So we still have the main thread up until CPU zero,

789
00:34:30,442 --> 00:34:33,925
and in Halo Infinite, we have now five real-time workers,

790
00:34:34,225 --> 00:34:36,707
generic real-time workers that help out

791
00:34:36,767 --> 00:34:37,828
on simulation and rendering work.

792
00:34:39,952 --> 00:34:42,455
They are affinitized to their own core,

793
00:34:42,735 --> 00:34:44,357
CPU one through CPU five,

794
00:34:45,258 --> 00:34:46,499
and they're on a high priority, as I said.

795
00:34:47,644 --> 00:34:49,385
On top of that, they also,

796
00:34:50,305 --> 00:34:52,146
when they run out of jobs to execute immediately,

797
00:34:52,686 --> 00:34:54,647
we actually don't immediately yield the core.

798
00:34:54,727 --> 00:34:57,468
We spin for a few microseconds, around 200 microseconds,

799
00:34:57,988 --> 00:34:59,588
just in case there's other jobs that are about

800
00:34:59,608 --> 00:35:01,509
to be scheduled because the dependencies are satisfied.

801
00:35:02,269 --> 00:35:05,650
We do this because it turns out that the cost

802
00:35:05,790 --> 00:35:07,271
of putting one of these threads to sleep

803
00:35:07,331 --> 00:35:09,452
and then re-wake it when additional jobs come along

804
00:35:09,672 --> 00:35:12,173
is higher than just most of the time,

805
00:35:12,373 --> 00:35:14,293
spin for a little bit and wait for jobs to come in.

806
00:35:15,867 --> 00:35:17,428
So we use this trick on console because we know

807
00:35:17,448 --> 00:35:18,609
that the hardware is dedicated to us,

808
00:35:18,689 --> 00:35:20,531
so we don't have to worry about interference.

809
00:35:22,613 --> 00:35:24,034
Then we have a set of background worker threads.

810
00:35:24,355 --> 00:35:26,457
These are actually able to roam across CPUs,

811
00:35:26,577 --> 00:35:27,578
but they're on a lower priority,

812
00:35:27,618 --> 00:35:29,780
so they're never gonna interrupt real-time workers.

813
00:35:30,481 --> 00:35:33,143
And often they're gonna find space to run on CPU6,

814
00:35:33,183 --> 00:35:34,244
which is our half-share core.

815
00:35:35,626 --> 00:35:37,567
And then we have our set of spurious worker threads

816
00:35:37,587 --> 00:35:39,069
that are configured on a case-by-case basis.

817
00:35:42,080 --> 00:35:45,063
SiriusX is similar but interestingly different.

818
00:35:45,504 --> 00:35:48,627
So first of all, SiriusX also exposes eight physical cores.

819
00:35:49,832 --> 00:35:52,754
But this time, CPU 6, the seventh core,

820
00:35:52,894 --> 00:35:54,415
is exclusive to the title, so that's good.

821
00:35:55,235 --> 00:35:57,937
On top of that, the console, CSX NS,

822
00:35:58,478 --> 00:36:00,779
offer a optional mode of execution

823
00:36:00,819 --> 00:36:02,100
called simultaneous multithreading,

824
00:36:02,561 --> 00:36:05,423
which allows the game to run two threads simultaneously

825
00:36:05,783 --> 00:36:06,944
on each physical cores,

826
00:36:07,584 --> 00:36:11,527
effectively leveraging two logical cores

827
00:36:11,567 --> 00:36:12,368
for each physical core.

828
00:36:14,773 --> 00:36:17,015
The price you pay then is that the clock rate

829
00:36:17,035 --> 00:36:19,717
slows down a little bit from 3.8 to 3.6 gigahertz,

830
00:36:20,378 --> 00:36:23,481
but it's quite common to get a performance boost using SMT.

831
00:36:24,161 --> 00:36:27,104
So we tested both, and we ended up deciding not to use it,

832
00:36:27,164 --> 00:36:30,267
at least for now, so here Infinite runs without SMT enabled.

833
00:36:31,548 --> 00:36:33,990
But we still create an additional real-time worker thread

834
00:36:34,431 --> 00:36:37,634
on CPU6, because this time the CPU is dedicated to us,

835
00:36:37,734 --> 00:36:40,156
so we can, or exclusive to us, so we can actually

836
00:36:40,616 --> 00:36:41,918
use it as a regular dedicated core.

837
00:36:44,306 --> 00:36:49,230
And just like on Xbox One, we, even on Series X,

838
00:36:49,290 --> 00:36:51,993
spin for a little bit after we run out of jobs to execute.

839
00:36:53,614 --> 00:36:55,796
And this allows us to avoid needless context switch,

840
00:36:56,176 --> 00:36:58,819
or needless and frequent context switches,

841
00:36:59,559 --> 00:37:00,880
and allows us to achieve very high

842
00:37:00,940 --> 00:37:02,181
execution efficiency on the console.

843
00:37:07,043 --> 00:37:08,884
On Windows PC, the situation is very different.

844
00:37:09,365 --> 00:37:11,226
So Windows PC is not a dedicated platform.

845
00:37:11,266 --> 00:37:12,147
It's a shared platform.

846
00:37:12,687 --> 00:37:14,168
And there's other programs running on it.

847
00:37:14,749 --> 00:37:16,810
And the OS may decide at any point

848
00:37:16,910 --> 00:37:18,652
to shrink our available execution resources.

849
00:37:19,512 --> 00:37:21,574
So what that means is that for our CPU execution,

850
00:37:21,594 --> 00:37:23,175
we try to be as flexible as possible.

851
00:37:23,916 --> 00:37:27,678
And in practice, that means that we never authenticize.

852
00:37:27,738 --> 00:37:29,380
We allow any thread to run on any core.

853
00:37:29,480 --> 00:37:31,401
We still prioritize the threads relative to one another.

854
00:37:32,814 --> 00:37:35,416
And we also try and avoid spinning as much as possible

855
00:37:35,496 --> 00:37:37,558
and yield the CPUs as quickly as we can.

856
00:37:37,678 --> 00:37:41,281
And we do this because if we are in that scenario

857
00:37:41,321 --> 00:37:43,783
where the operating system is reducing

858
00:37:43,863 --> 00:37:45,364
our available execution resources

859
00:37:45,784 --> 00:37:48,646
and we have fewer CPU, fewer cores available for executing,

860
00:37:49,347 --> 00:37:51,448
then we really want to make sure that any work

861
00:37:51,488 --> 00:37:54,911
that we get in and executing on the CPUs is useful work.

862
00:37:54,991 --> 00:37:56,652
So we don't want to burn that time spinning

863
00:37:56,892 --> 00:37:58,714
and potentially shooting ourselves in the foot.

864
00:38:00,590 --> 00:38:02,471
Other than that, we obviously still have the main thread

865
00:38:02,551 --> 00:38:03,732
and a set of real-time workers,

866
00:38:03,812 --> 00:38:05,534
and we create one real-time worker

867
00:38:05,594 --> 00:38:08,096
for each logical core available on the machine,

868
00:38:08,696 --> 00:38:11,118
minus one for the main thread, and up to nine.

869
00:38:12,559 --> 00:38:14,441
That number nine was chosen empirically

870
00:38:14,501 --> 00:38:16,382
by just scaling up the number of worker threads

871
00:38:16,422 --> 00:38:19,064
that we were creating, and simply noticing

872
00:38:19,144 --> 00:38:21,466
that when we scaled execution beyond that,

873
00:38:21,906 --> 00:38:24,068
then we started seeing negative returns

874
00:38:24,168 --> 00:38:26,530
on overall performance because of overhead

875
00:38:26,630 --> 00:38:28,031
intrinsic to our scheduling systems.

876
00:38:28,471 --> 00:38:29,112
So we settled for nine.

877
00:38:31,960 --> 00:38:34,662
Okay, so now, finally, we have all the tools that we need

878
00:38:34,702 --> 00:38:36,602
to dissect together one frame in Halo Infinite.

879
00:38:38,383 --> 00:38:39,364
We're gonna start with Xbox One.

880
00:38:44,506 --> 00:38:44,666
Okay.

881
00:38:46,347 --> 00:38:47,728
So, this is a tool called Pix.

882
00:38:49,128 --> 00:38:50,689
And Pix come with the Xbox GDK

883
00:38:51,149 --> 00:38:53,170
for any Xbox One or Xbox Series X developers.

884
00:38:53,570 --> 00:38:56,212
There's also a version for Windows.

885
00:38:56,432 --> 00:38:57,372
It's called Pix for Windows,

886
00:38:57,492 --> 00:39:00,053
and I'm just showing a screenshot of the GDK version here.

887
00:39:00,233 --> 00:39:00,814
It's very similar.

888
00:39:02,103 --> 00:39:04,606
And we use it for all of our profiling on the CPU side,

889
00:39:05,887 --> 00:39:08,089
consoles of course, but also Windows PCs,

890
00:39:08,169 --> 00:39:12,694
and even dedicated servers, which run on Windows VMs

891
00:39:12,734 --> 00:39:14,256
for us, with the machines on the Azure cloud.

892
00:39:15,889 --> 00:39:17,930
So Xbox One being a 30 FPS target,

893
00:39:17,970 --> 00:39:19,630
I'm showing that 33.33 milliseconds

894
00:39:19,650 --> 00:39:20,750
at the top of the slide there.

895
00:39:21,210 --> 00:39:23,651
And then we have one lane for each of our main threads.

896
00:39:23,671 --> 00:39:24,931
So we have the main thread at the top.

897
00:39:25,351 --> 00:39:27,412
We have our five real-time workers just below it,

898
00:39:27,432 --> 00:39:28,112
the big lanes.

899
00:39:28,592 --> 00:39:29,932
And then at the bottom of the slide,

900
00:39:29,992 --> 00:39:31,893
I'm showing a lane for CPU six,

901
00:39:32,013 --> 00:39:34,533
which shows some lower priority threads executing.

902
00:39:36,754 --> 00:39:38,294
Okay, let's start from the beginning of the simulation then.

903
00:39:39,247 --> 00:39:41,348
In this phase, this is where we construct and submit

904
00:39:41,388 --> 00:39:43,609
for execution our frame job graph.

905
00:39:44,509 --> 00:39:46,790
And that green narrow workload inside the circle

906
00:39:46,830 --> 00:39:48,471
is our input sampling, just as promised

907
00:39:48,511 --> 00:39:49,511
at the beginning of the simulation.

908
00:39:52,092 --> 00:39:55,654
Right after that, jobs start up for the simulation

909
00:39:55,814 --> 00:39:59,135
and we have, here's an example of a streaming job.

910
00:39:59,235 --> 00:40:00,896
This is called simulation controller.

911
00:40:01,176 --> 00:40:02,397
It's basically a streaming system,

912
00:40:03,277 --> 00:40:05,058
a system that is part of our streaming systems

913
00:40:05,478 --> 00:40:06,498
that is responsible for

914
00:40:07,580 --> 00:40:11,642
It's responsible for evaluating and computing relevancy

915
00:40:11,682 --> 00:40:12,703
for a bunch of game objects.

916
00:40:15,684 --> 00:40:18,806
And in this scenario, it happens to run on CPU two and four

917
00:40:19,426 --> 00:40:21,547
just because those worker threads

918
00:40:21,567 --> 00:40:22,988
were the ones available for execution.

919
00:40:23,048 --> 00:40:24,309
But any frame, it could be different.

920
00:40:24,829 --> 00:40:26,329
These real-time workers are generic,

921
00:40:26,350 --> 00:40:29,551
so they can pick up any work as they become available.

922
00:40:31,072 --> 00:40:33,793
Here's some additional jobs to check out.

923
00:40:34,013 --> 00:40:36,294
In pink here, this is part of our AI update work.

924
00:40:37,299 --> 00:40:39,580
And this is all jobified, of course,

925
00:40:39,660 --> 00:40:41,100
but in this scenario specifically,

926
00:40:41,420 --> 00:40:43,321
the main thread is trying to get through a sync point,

927
00:40:43,881 --> 00:40:45,941
but it can't because the dependencies are not satisfied.

928
00:40:46,401 --> 00:40:48,402
So what it does instead is it joins execution

929
00:40:48,442 --> 00:40:50,382
and it starts picking up some AI jobs

930
00:40:50,482 --> 00:40:52,143
to continue moving forward the simulation.

931
00:40:54,463 --> 00:40:57,204
These green workloads here are part of our UI update.

932
00:40:57,564 --> 00:40:59,885
This is where we update the logical state of our UI

933
00:41:00,125 --> 00:41:03,946
and construct some of our command lists

934
00:41:04,026 --> 00:41:05,226
necessary for UI rendering.

935
00:41:06,775 --> 00:41:11,476
Okay, so we're still in the viable frame rate part of the frame, and now we move on to the

936
00:41:12,576 --> 00:41:14,237
core game simulation, which is our fixed updates.

937
00:41:14,977 --> 00:41:19,218
Because we run at 30 FPS on Xbox One, we have to do two fixed updates per frame, which should

938
00:41:19,238 --> 00:41:20,378
not be a surprise at this point.

939
00:41:21,258 --> 00:41:26,900
And the main workloads inside the game ticks are object updates, where we update the logical

940
00:41:26,940 --> 00:41:29,940
state of all of our active objects in the simulation.

941
00:41:30,080 --> 00:41:32,181
This includes stuff like vehicle simulation and whatnot.

942
00:41:33,195 --> 00:41:36,338
Then we have our physics update that in the Halo engine

943
00:41:37,059 --> 00:41:40,683
happens simultaneously as the animation sample and blend,

944
00:41:41,304 --> 00:41:43,026
which is the green workload that you can see there.

945
00:41:43,867 --> 00:41:44,608
Not too much this frame.

946
00:41:46,230 --> 00:41:47,831
And then we have our object move phase

947
00:41:47,932 --> 00:41:51,175
where we effectively update all the transforms

948
00:41:51,195 --> 00:41:52,497
for all of our objects and all their poses.

949
00:41:53,910 --> 00:41:56,152
After we are done with the core simulation and the two game

950
00:41:56,192 --> 00:41:58,694
ticks, we move on to an additional variable update

951
00:41:58,754 --> 00:42:00,716
phase of the frame where we update additional systems.

952
00:42:00,756 --> 00:42:02,977
And there's a lot of systems inside these circles,

953
00:42:03,538 --> 00:42:05,099
but I'm just going to call out a few.

954
00:42:05,700 --> 00:42:07,381
You can see some additional pink work there,

955
00:42:07,581 --> 00:42:09,523
which are additional AI jobs.

956
00:42:10,764 --> 00:42:13,226
And the light blue system on worker three

957
00:42:13,466 --> 00:42:16,149
is doing our time of day update.

958
00:42:16,669 --> 00:42:18,210
And then in gray on the main thread

959
00:42:18,751 --> 00:42:22,214
towards the end of that circle is our design scripting update,

960
00:42:22,434 --> 00:42:22,574
which.

961
00:42:23,728 --> 00:42:25,229
As promised, it's a valuable frame rate system now.

962
00:42:26,990 --> 00:42:28,210
Then we do a publish to the renderer.

963
00:42:28,631 --> 00:42:31,252
Our publish operation, as I said,

964
00:42:31,292 --> 00:42:33,573
is a big copy of game state to the renderer.

965
00:42:34,114 --> 00:42:37,836
On Xbox One and Xbox Series X and S, on all our consoles,

966
00:42:37,896 --> 00:42:42,118
we use efficient DMA hardware to try and maximize

967
00:42:42,278 --> 00:42:43,779
memory utilization for this operation

968
00:42:43,819 --> 00:42:45,660
and complete the copy as quickly as we can.

969
00:42:47,000 --> 00:42:50,642
Xbox offers a nice API to do this, so we leverage it.

970
00:42:50,883 --> 00:42:53,304
And this gets the copy done as quickly as we could.

971
00:42:54,785 --> 00:42:55,606
And then we wait a little bit.

972
00:42:56,507 --> 00:42:58,028
We wait because in this scenario,

973
00:42:58,048 --> 00:42:59,590
in this specific frame that I took a picture of,

974
00:43:00,470 --> 00:43:01,812
we are actually a little under budget.

975
00:43:01,992 --> 00:43:03,994
We're not using all of the 33.33 milliseconds

976
00:43:04,014 --> 00:43:05,635
that we have at our disposal for the simulation.

977
00:43:06,336 --> 00:43:08,798
So in order for us to keep consistent input sampling,

978
00:43:08,818 --> 00:43:10,860
we have to wait a little bit before we start the next frame

979
00:43:10,900 --> 00:43:11,741
and input sample again.

980
00:43:12,982 --> 00:43:14,943
And we do this through a software timer

981
00:43:15,044 --> 00:43:16,024
that we call Metronome.

982
00:43:16,064 --> 00:43:17,306
It's a high-precision software timer.

983
00:43:17,746 --> 00:43:19,548
And so this is where we wait for it for the next frame, bit.

984
00:43:21,336 --> 00:43:22,817
As we were doing all that, we also

985
00:43:22,857 --> 00:43:25,099
had all these red workloads running on the same threads

986
00:43:25,140 --> 00:43:25,840
and at the same time.

987
00:43:26,421 --> 00:43:28,883
These are part of the render job graph coming down

988
00:43:28,943 --> 00:43:29,704
from last frame.

989
00:43:29,784 --> 00:43:32,386
So this is the last frame render job graph completing execution.

990
00:43:33,547 --> 00:43:35,449
Also, at the same time as we were doing all that simulation,

991
00:43:35,469 --> 00:43:37,151
we also had this hot pink workload,

992
00:43:38,112 --> 00:43:40,053
which is our audio rendering.

993
00:43:40,774 --> 00:43:43,236
Audio rendering is actually a pretty interesting workload

994
00:43:43,777 --> 00:43:46,479
on slow CPUs, because it's actually pretty CPU hungry.

995
00:43:47,624 --> 00:43:49,265
depending on the case, and for us,

996
00:43:49,726 --> 00:43:52,247
it was crucial to schedule this cooperatively,

997
00:43:52,287 --> 00:43:53,588
just like we do with any other job.

998
00:43:54,008 --> 00:43:55,730
So here it is running on a worker

999
00:43:55,950 --> 00:43:57,151
that runs any other job as well.

1000
00:43:58,151 --> 00:44:00,293
We don't take any context switch for audio rendering either.

1001
00:44:02,514 --> 00:44:05,676
And after we publish our simulation to the renderer,

1002
00:44:05,777 --> 00:44:07,778
we see here the render job graph starting up

1003
00:44:07,838 --> 00:44:09,399
for this frame that we just finished publishing.

1004
00:44:09,959 --> 00:44:11,661
And even though the simulation is not running

1005
00:44:11,681 --> 00:44:13,462
at the same time, you can see that there is

1006
00:44:13,542 --> 00:44:15,663
quite a lot of potential parallelism in our renderer alone.

1007
00:44:17,378 --> 00:44:19,079
But overall, when the hardware is soaked,

1008
00:44:19,479 --> 00:44:22,442
we run pretty much like the left side of the slide,

1009
00:44:22,502 --> 00:44:24,843
which, as you can see, we achieve a pretty decent

1010
00:44:25,003 --> 00:44:26,224
utilization of the Xbox One CPU,

1011
00:44:26,344 --> 00:44:27,325
so we're pretty happy about it.

1012
00:44:29,847 --> 00:44:32,409
Okay, Xbox Series X, it's similar,

1013
00:44:32,489 --> 00:44:33,910
but I'm gonna call out some of the differences.

1014
00:44:33,970 --> 00:44:35,371
So first of all, it has two modes.

1015
00:44:35,611 --> 00:44:38,213
You can run the game in performance mode or quality mode.

1016
00:44:38,473 --> 00:44:40,315
The default is quality mode at 60 FPS.

1017
00:44:40,915 --> 00:44:42,296
So this is what I'm gonna show here.

1018
00:44:42,736 --> 00:44:45,118
And you can see there's 16.7 milliseconds

1019
00:44:45,258 --> 00:44:46,359
of time at the top of the slide.

1020
00:44:47,780 --> 00:44:49,241
There's, calling out some differences,

1021
00:44:49,321 --> 00:44:50,521
we have an additional worker thread

1022
00:44:50,561 --> 00:44:52,521
because that CPU is now dedicated on this console.

1023
00:44:52,841 --> 00:44:53,862
So we create it and we use it

1024
00:44:53,902 --> 00:44:55,222
just like any other real-time worker.

1025
00:44:56,262 --> 00:44:57,282
Also, because we're running at 60,

1026
00:44:57,322 --> 00:44:59,403
we only had to do one game tick every frame,

1027
00:44:59,963 --> 00:45:00,503
and here it is.

1028
00:45:01,063 --> 00:45:01,923
Should not be a surprise now.

1029
00:45:03,464 --> 00:45:05,684
And also note that our wait for the next frame

1030
00:45:05,724 --> 00:45:07,504
is actually very long, in this frame at least.

1031
00:45:08,485 --> 00:45:10,945
And effectively, we're done with the simulation stuff

1032
00:45:11,125 --> 00:45:12,386
in just a handful of milliseconds.

1033
00:45:13,846 --> 00:45:13,986
So...

1034
00:45:15,658 --> 00:45:19,800
First of all, I should point out that we do scale up a lot of our CPU workloads on Series X

1035
00:45:19,860 --> 00:45:22,802
when compared to the lower-end platforms like Xbox One.

1036
00:45:23,863 --> 00:45:26,524
And you can probably notice that there's a lot more relative green here.

1037
00:45:26,584 --> 00:45:29,046
We animate a lot more. We do a lot more rendering, of course.

1038
00:45:29,586 --> 00:45:32,528
We spawn a bunch of critters through the environments that don't exist on Xbox One,

1039
00:45:32,928 --> 00:45:33,668
and so on and so forth.

1040
00:45:34,169 --> 00:45:38,791
But even then, we are usually under budget on Xbox Series X at 60 FPS.

1041
00:45:39,677 --> 00:45:41,980
But this slack is not all bad because it allows us

1042
00:45:42,020 --> 00:45:44,183
to ingest smaller spikes without dropping a frame,

1043
00:45:44,343 --> 00:45:46,546
so that's good, but also it's crucial for us

1044
00:45:46,566 --> 00:45:48,849
to obtain our 120 FPS performance mode.

1045
00:45:49,429 --> 00:45:52,914
So we're happy about having all this time available to us.

1046
00:45:56,117 --> 00:45:58,958
On PC, the topology of how a frame looks in Pix

1047
00:45:58,998 --> 00:46:00,679
is going to be completely different depending on how

1048
00:46:00,719 --> 00:46:01,800
the player configures it.

1049
00:46:02,461 --> 00:46:06,703
Players can configure arbitrary target frame rates.

1050
00:46:07,664 --> 00:46:09,705
And usually they're going to want to align with their monitor

1051
00:46:09,745 --> 00:46:10,245
v-sync rate.

1052
00:46:10,886 --> 00:46:14,728
But they can also configure unlocked frame rate.

1053
00:46:15,409 --> 00:46:16,689
And what unlocked frame rate means

1054
00:46:16,769 --> 00:46:18,811
is that we're going to simulate.

1055
00:46:18,851 --> 00:46:20,372
And then as soon as we finish the simulation frame,

1056
00:46:20,392 --> 00:46:22,673
we're going to carry on and do the next simulation frame,

1057
00:46:23,193 --> 00:46:25,055
even if the renderer is not ready to receive the data.

1058
00:46:26,280 --> 00:46:27,440
So we never wait for a metronome.

1059
00:46:27,781 --> 00:46:29,302
And even though most of the time that's

1060
00:46:29,342 --> 00:46:31,743
not how you're going to want to configure the game,

1061
00:46:33,084 --> 00:46:34,084
we're looking at it as an example

1062
00:46:34,124 --> 00:46:35,065
here to understand how it works.

1063
00:46:36,706 --> 00:46:40,448
So in this scenario, I have an eight logical core machine.

1064
00:46:40,788 --> 00:46:42,910
And I can tell because I have the main thread at the top

1065
00:46:43,050 --> 00:46:45,051
and then seven lanes for seven real time workers.

1066
00:46:45,511 --> 00:46:46,872
So that's eight logical cores total.

1067
00:46:47,782 --> 00:46:49,544
focusing on some interesting differences.

1068
00:46:50,304 --> 00:46:52,186
Here's inside the circle, we can see that the line

1069
00:46:52,246 --> 00:46:53,628
on top of the work is changing color.

1070
00:46:54,389 --> 00:46:56,651
And that is because the thread is indeed

1071
00:46:57,012 --> 00:46:59,434
migrating from CPU to CPU because it's not affinitized,

1072
00:46:59,915 --> 00:47:00,736
like I mentioned before.

1073
00:47:02,978 --> 00:47:05,701
And also, this slide contains three different frames.

1074
00:47:06,853 --> 00:47:08,934
The first two frames are shorter, and here they are.

1075
00:47:09,815 --> 00:47:12,076
And they actually don't contain a game tick.

1076
00:47:12,896 --> 00:47:14,597
And this is because we are, in this scenario,

1077
00:47:14,637 --> 00:47:16,498
running at much higher than 60 FPS.

1078
00:47:16,578 --> 00:47:18,698
So not every frame is going to contain a game tick.

1079
00:47:19,279 --> 00:47:20,939
However, these frames are still going

1080
00:47:20,959 --> 00:47:23,380
to run our tweening systems, our interpolation systems,

1081
00:47:23,420 --> 00:47:24,781
to show a smooth result on screen,

1082
00:47:25,521 --> 00:47:27,122
using the two most recent game ticks

1083
00:47:27,142 --> 00:47:29,743
that they have stored the results in memory for.

1084
00:47:30,964 --> 00:47:32,604
And here's a frame that does contain a game tick,

1085
00:47:33,225 --> 00:47:36,166
where we recognize all of our usual workloads.

1086
00:47:38,379 --> 00:47:40,501
Another important difference on PC versus console

1087
00:47:40,942 --> 00:47:42,684
is the way we publish the simulation to the renderer.

1088
00:47:42,704 --> 00:47:44,606
It's still a large copy of Game State,

1089
00:47:44,966 --> 00:47:46,427
but this time we do not have access

1090
00:47:46,488 --> 00:47:48,109
to high efficiency DMA hardware,

1091
00:47:48,510 --> 00:47:51,072
so instead we perform a parallel mem copy

1092
00:47:51,493 --> 00:47:54,216
using multiple threads to make this copy

1093
00:47:54,316 --> 00:47:55,116
as fast as possible.

1094
00:47:55,717 --> 00:47:57,179
This is in an attempt to maximize

1095
00:47:57,219 --> 00:47:58,580
our memory bandwidth utilization,

1096
00:47:58,920 --> 00:47:59,821
and it works reasonably well.

1097
00:48:02,400 --> 00:48:04,341
Halo Infinite Dedicated Servers, as I said before,

1098
00:48:04,381 --> 00:48:07,123
they're Windows virtual machines hosted on the Azure cloud,

1099
00:48:07,964 --> 00:48:10,306
and they run slightly differently

1100
00:48:10,346 --> 00:48:11,247
depending on the game mode.

1101
00:48:12,207 --> 00:48:15,230
Arena 4v4 servers run at 60 hertz,

1102
00:48:15,290 --> 00:48:16,851
which is our more competitive mode,

1103
00:48:17,131 --> 00:48:18,713
and Big Team Battle servers,

1104
00:48:19,013 --> 00:48:23,116
which is our more casual modes, run at 30 hertz.

1105
00:48:24,937 --> 00:48:28,020
And this is a screenshot from PIX on a dedicated server,

1106
00:48:28,120 --> 00:48:28,780
and as you can see,

1107
00:48:29,744 --> 00:48:31,445
the workloads look very similar.

1108
00:48:32,407 --> 00:48:34,349
And this specifically, it's a big team battle server

1109
00:48:34,369 --> 00:48:37,012
because I'm showing the 33.33 target at the top.

1110
00:48:37,933 --> 00:48:38,894
So it's running at 30 hertz.

1111
00:48:39,615 --> 00:48:41,257
But some differences with.

1112
00:48:43,277 --> 00:48:45,899
with a normal client is that obviously we have no rendering

1113
00:48:45,919 --> 00:48:46,860
to do, so there's no renderer.

1114
00:48:47,180 --> 00:48:50,302
There is no audio work at all, or most of the work

1115
00:48:50,342 --> 00:48:50,823
is disabled.

1116
00:48:51,103 --> 00:48:52,144
There's no UI work to do.

1117
00:48:52,544 --> 00:48:54,085
And there's also no publish.

1118
00:48:54,105 --> 00:48:55,626
We don't publish the simulation because nobody

1119
00:48:55,686 --> 00:48:57,648
is consuming the published data.

1120
00:48:58,568 --> 00:49:00,890
So all those workloads are gone, but the core of the simulation,

1121
00:49:00,910 --> 00:49:02,811
the game fix are still there, and they look exactly the same.

1122
00:49:03,792 --> 00:49:05,333
There is some additional networking stuff

1123
00:49:05,353 --> 00:49:06,994
to do on dedicated servers, so you can probably

1124
00:49:07,014 --> 00:49:08,836
spot some additional networking jobs here.

1125
00:49:11,968 --> 00:49:13,248
Okay, so we concluded our tour

1126
00:49:13,368 --> 00:49:14,509
through one frame in Halo Infinite,

1127
00:49:14,809 --> 00:49:15,909
and let's draw some conclusions.

1128
00:49:16,849 --> 00:49:17,949
So overall, we're pretty happy

1129
00:49:17,969 --> 00:49:19,450
with how our viable frame rate model worked,

1130
00:49:20,130 --> 00:49:23,411
and how it scaled, sorry, how it allowed us

1131
00:49:23,431 --> 00:49:26,412
to achieve smooth motion of any frame rate

1132
00:49:26,432 --> 00:49:27,152
that we could configure,

1133
00:49:27,912 --> 00:49:31,253
while keeping the core deterministic Halo sandbox consistent.

1134
00:49:32,333 --> 00:49:33,334
And at the same time, we're very happy

1135
00:49:33,374 --> 00:49:35,954
with how the job system allowed us to scale

1136
00:49:36,595 --> 00:49:38,015
to CPUs of different sizes

1137
00:49:38,055 --> 00:49:41,156
without having to weave a massive ball of spaghetti code.

1138
00:49:43,798 --> 00:49:44,519
If I wasn't happy about it,

1139
00:49:44,539 --> 00:49:45,641
I wouldn't be here talking about it.

1140
00:49:46,942 --> 00:49:47,903
But it's not all good.

1141
00:49:48,324 --> 00:49:49,004
There's some bad too.

1142
00:49:49,785 --> 00:49:52,408
So first of all, for the variable frame rate migration

1143
00:49:52,428 --> 00:49:54,571
that we did, we should have done a better job

1144
00:49:54,611 --> 00:49:56,173
teaching engineers across the studio.

1145
00:49:57,154 --> 00:49:59,516
And this is because there was a lot of confusion early on

1146
00:49:59,937 --> 00:50:02,420
as we were migrating systems from fixed updates

1147
00:50:02,440 --> 00:50:03,181
to variable frame rate.

1148
00:50:04,505 --> 00:50:05,846
And in terms of what the job system,

1149
00:50:06,206 --> 00:50:07,347
where the job system fell short,

1150
00:50:08,107 --> 00:50:10,929
we were able to define dependencies between jobs

1151
00:50:11,009 --> 00:50:12,210
and their execution dependencies,

1152
00:50:12,230 --> 00:50:15,012
but we were not able to define data dependencies for jobs.

1153
00:50:15,712 --> 00:50:18,014
Which, what that means is that we're not able to define

1154
00:50:18,054 --> 00:50:19,935
that two jobs are using the same piece of data

1155
00:50:19,995 --> 00:50:21,756
in a way that could interfere with one another.

1156
00:50:22,356 --> 00:50:25,018
And in practice, that meant that during development

1157
00:50:25,038 --> 00:50:27,060
we have to track down a fair amount

1158
00:50:27,160 --> 00:50:29,681
of race conditions between jobs.

1159
00:50:30,510 --> 00:50:32,472
And once we figured them out, we solved them

1160
00:50:32,512 --> 00:50:34,495
by introducing additional execution dependencies.

1161
00:50:35,836 --> 00:50:37,858
So in future, we definitely want to introduce

1162
00:50:38,358 --> 00:50:39,640
data dependencies in the job system.

1163
00:50:39,660 --> 00:50:41,381
We want to treat them as a native concept

1164
00:50:41,462 --> 00:50:43,263
that works together with execution dependencies

1165
00:50:43,283 --> 00:50:45,686
to schedule the work in a safe manner always.

1166
00:50:46,206 --> 00:50:47,768
And the idea here is to reduce bugs

1167
00:50:48,248 --> 00:50:49,770
and simplify onboarding for new engineers.

1168
00:50:50,831 --> 00:50:52,772
On top of that, we also want to continue to work

1169
00:50:52,832 --> 00:50:54,693
on converting systems to valuable frame rate

1170
00:50:54,713 --> 00:50:56,153
that could be converted to valuable frame rate.

1171
00:50:56,874 --> 00:50:58,434
And it's not always that simple

1172
00:50:58,494 --> 00:51:01,316
because some systems have portions of themselves

1173
00:51:01,356 --> 00:51:02,576
that could be converted to valuable frame rate,

1174
00:51:02,596 --> 00:51:04,037
so we have to decouple them first.

1175
00:51:04,377 --> 00:51:05,477
But there's still quite a few things

1176
00:51:05,597 --> 00:51:06,838
inside the GameTable that we could convert.

1177
00:51:08,399 --> 00:51:11,640
And moreover, we want to fully jobify our main thread

1178
00:51:12,120 --> 00:51:13,921
and get rid of it just like we did with the render thread.

1179
00:51:15,241 --> 00:51:17,482
And also at that point, we could also get rid

1180
00:51:17,502 --> 00:51:18,563
of sync points altogether

1181
00:51:18,603 --> 00:51:19,603
because we wouldn't need them anymore.

1182
00:51:21,764 --> 00:51:22,845
Okay, so I want to thank all of 343

1183
00:51:22,985 --> 00:51:24,566
for allowing me to be here today.

1184
00:51:25,147 --> 00:51:26,908
And specifically the people on this slide.

1185
00:51:27,309 --> 00:51:29,931
They were either massive parts of implementing these changes

1186
00:51:30,431 --> 00:51:32,253
or they had to deal with me chasing them around

1187
00:51:32,293 --> 00:51:34,354
to optimization work so they deserve a special thank you.

1188
00:51:45,223 --> 00:51:45,503
Thank you.

1189
00:51:45,803 --> 00:51:47,925
We are hiring, so if you are interested in joining us

1190
00:51:47,985 --> 00:51:49,847
and be part of whatever is next in Halo Infinite,

1191
00:51:50,107 --> 00:51:50,928
please check out our website.

1192
00:51:52,636 --> 00:51:55,998
And also, we have a couple more sessions on Halo Infinite

1193
00:51:56,058 --> 00:51:57,599
going on this year at GDC.

1194
00:51:58,339 --> 00:51:59,580
The first one there was actually yesterday,

1195
00:52:00,120 --> 00:52:01,601
but the other two are going to be tomorrow.

1196
00:52:01,621 --> 00:52:03,462
So if you're interested, be sure not to miss them.

1197
00:52:04,563 --> 00:52:06,084
And we can now do some Q&A.

1198
00:52:07,325 --> 00:52:10,647
So I have, while people walk up to the mic, I have this video.

1199
00:52:11,147 --> 00:52:12,108
I'm going to have this video playing.

1200
00:52:12,148 --> 00:52:14,910
This is a video of bloopers from our internal database,

1201
00:52:14,930 --> 00:52:15,990
so it should be pretty fun, hopefully.

1202
00:52:16,010 --> 00:52:21,694
I mean, yes, what's up?

1203
00:52:22,936 --> 00:52:28,339
When designing the job system, what made you go towards bidirectional synchronization points

1204
00:52:28,479 --> 00:52:31,781
instead of a model like using fences to signal one side or the other?

1205
00:52:32,562 --> 00:52:33,102
Well, um...

1206
00:52:34,330 --> 00:52:35,930
I mean, a sync point is just a nomenclature.

1207
00:52:36,150 --> 00:52:38,171
It's not that different from a regular fencer barrier

1208
00:52:38,331 --> 00:52:41,752
in other threading systems.

1209
00:52:42,332 --> 00:52:43,872
But we call the sync points,

1210
00:52:43,912 --> 00:52:46,173
and basically we implement it to work

1211
00:52:46,213 --> 00:52:47,173
just the way we want it to.

1212
00:52:47,413 --> 00:52:50,634
We didn't look at other third-party packages

1213
00:52:50,654 --> 00:52:52,034
to figure out, do they have the constructs

1214
00:52:52,054 --> 00:52:52,895
that we need exactly?

1215
00:52:53,355 --> 00:52:55,335
Because our job system was all in-house anyway,

1216
00:52:55,395 --> 00:52:56,916
so we couldn't really easily adapt it.

1217
00:52:57,276 --> 00:52:59,136
And it needed to be efficient for all these reasons.

1218
00:52:59,416 --> 00:53:00,757
Thanks. Yeah.

1219
00:53:04,570 --> 00:53:08,951
Cool system. I've seen things like this before.

1220
00:53:09,591 --> 00:53:17,593
The thing which we hit was priority necessary between the jobs on the AI side,

1221
00:53:17,613 --> 00:53:22,054
which is like the fixed update, because they're basically a real-time system,

1222
00:53:22,514 --> 00:53:25,735
and your rendering, which is kind of not as much.

1223
00:53:26,055 --> 00:53:28,115
Did you have any priority systems on yours?

1224
00:53:28,275 --> 00:53:32,556
Yeah, so I left this out of the presentation, but our jobs have priorities.

1225
00:53:32,576 --> 00:53:33,056
Okay.

1226
00:53:34,097 --> 00:53:36,920
Basically, we had various levels of priorities

1227
00:53:36,960 --> 00:53:38,942
for simulation work and various levels of priority

1228
00:53:38,982 --> 00:53:39,762
for rendering work.

1229
00:53:40,463 --> 00:53:42,405
And we also, our threads were generic,

1230
00:53:42,425 --> 00:53:44,968
so they were able to pick up any work on any thread,

1231
00:53:45,108 --> 00:53:47,570
but some threads preferred rendering work

1232
00:53:47,690 --> 00:53:49,752
versus some other preferred simulation work.

1233
00:53:50,313 --> 00:53:52,075
So they were able to nicely spread

1234
00:53:52,235 --> 00:53:53,636
on the available execution resources.

1235
00:53:54,237 --> 00:53:54,897
Thank you very much.

1236
00:53:54,958 --> 00:53:56,179
That's totally what I thought you'd.

1237
00:53:59,525 --> 00:54:00,906
Thanks for the presentation, that was great.

1238
00:54:00,926 --> 00:54:03,648
This is more of a curiosity, I guess, than a question.

1239
00:54:03,728 --> 00:54:09,212
I remember there was an issue with animations that has been solved since.

1240
00:54:11,613 --> 00:54:14,636
Animations would play at a different frame rate than the rest of the things going on in the scene.

1241
00:54:14,656 --> 00:54:18,358
I was curious what that had to do with the interpolation that you were describing.

1242
00:54:18,899 --> 00:54:21,960
So you're talking about the Halo 5 animation jitteriness issue?

1243
00:54:21,980 --> 00:54:25,581
No, in my head I'm thinking of the Halo Infinite, the clamber.

1244
00:54:25,941 --> 00:54:26,962
The first person animations?

1245
00:54:26,982 --> 00:54:27,882
Yeah, the first person.

1246
00:54:27,962 --> 00:54:31,784
So that was actually completely independent from anything I talked about in the presentation.

1247
00:54:31,844 --> 00:54:36,266
And it's an interpolation system that is within a built inside animation framework.

1248
00:54:36,926 --> 00:54:41,368
And it was, yeah, there was a bug in there and we didn't notice until it was too late and we fixed it.

1249
00:54:41,408 --> 00:54:42,648
But it took a while to get it out.

1250
00:54:42,788 --> 00:54:44,089
I was just curious, thank you.

1251
00:54:47,805 --> 00:54:54,528
Hello, you mentioned that a part of your optimization process was moving as much as possible out

1252
00:54:54,548 --> 00:54:57,469
of the fixed tick and into the variable tick.

1253
00:54:58,649 --> 00:55:05,632
And it seems like it would be easy to move things into the variable tick that still need

1254
00:55:05,692 --> 00:55:07,213
fixed tick and you only discover that later.

1255
00:55:07,253 --> 00:55:07,773
And I'm wondering...

1256
00:55:08,573 --> 00:55:12,555
how hard it was to debug that kind of thing

1257
00:55:13,256 --> 00:55:15,617
or if new features got added to variable tick

1258
00:55:15,637 --> 00:55:17,157
that should have been added to fixed tick

1259
00:55:17,177 --> 00:55:17,857
and things like that.

1260
00:55:18,758 --> 00:55:20,198
So, it's a good question.

1261
00:55:20,239 --> 00:55:23,520
So, I'm trying to think and I don't think I remember

1262
00:55:24,420 --> 00:55:27,222
any scenario where we basically ended up

1263
00:55:27,262 --> 00:55:28,722
implementing a system at variable frame rate

1264
00:55:28,782 --> 00:55:31,183
and realized that, oh, geez, this needed to be

1265
00:55:31,223 --> 00:55:32,724
an actual fixed-update system because it's part

1266
00:55:32,764 --> 00:55:33,784
of the deterministic simulation.

1267
00:55:33,924 --> 00:55:35,805
Now, it probably happened during development.

1268
00:55:37,686 --> 00:55:40,587
But I think the crux of the situation here

1269
00:55:40,667 --> 00:55:44,488
is because our game ticks are supporting the deterministic

1270
00:55:44,508 --> 00:55:45,468
network simulation for the game.

1271
00:55:45,928 --> 00:55:49,690
So if there is a system that is part of that update that is not

1272
00:55:49,770 --> 00:55:51,690
part of the game ticks, it's going

1273
00:55:51,750 --> 00:55:53,351
to cause really bad desyncs for us.

1274
00:55:53,731 --> 00:55:56,332
So it would have been easy for us to detect that case,

1275
00:55:56,372 --> 00:55:57,932
unless it was a very subtle system.

1276
00:55:59,493 --> 00:56:03,314
But for instance, AI is an example

1277
00:56:03,394 --> 00:56:03,634
where.

1278
00:56:06,459 --> 00:56:08,661
AI is an example of systems that,

1279
00:56:09,481 --> 00:56:11,022
it doesn't have to be part of the deterministic

1280
00:56:11,042 --> 00:56:12,143
network simulation for the game,

1281
00:56:12,223 --> 00:56:14,785
because it runs, most of the stuff runs server side.

1282
00:56:15,385 --> 00:56:16,706
So as long as it's able to maintain

1283
00:56:16,746 --> 00:56:17,727
more or less the same behavior,

1284
00:56:18,187 --> 00:56:19,688
then we can keep it viable for a minute.

1285
00:56:20,789 --> 00:56:20,949
But.

1286
00:56:22,716 --> 00:56:24,617
but portions of that had to be fixed update

1287
00:56:24,917 --> 00:56:26,679
and we were able to immediately tell that

1288
00:56:26,699 --> 00:56:29,140
because those were directly changing the unit properties

1289
00:56:29,260 --> 00:56:32,863
and the unit is part of our core sandbox concepts.

1290
00:56:32,903 --> 00:56:34,824
So overall it was pretty clear.

1291
00:56:35,104 --> 00:56:37,366
It was, I guess it was the other opposite side

1292
00:56:37,406 --> 00:56:38,346
was less clear for us.

1293
00:56:38,446 --> 00:56:41,108
How to take this system that definitely has some stuff

1294
00:56:41,128 --> 00:56:42,609
that doesn't have to be fixed update

1295
00:56:42,669 --> 00:56:44,530
but some parts of it are fixed update

1296
00:56:44,590 --> 00:56:46,212
and how to bring it out safely.

1297
00:56:47,702 --> 00:56:50,342
Gotcha, we're currently struggling with trying to move

1298
00:56:50,362 --> 00:56:53,123
a variable tick system into fixed,

1299
00:56:53,183 --> 00:56:55,963
and so it's kind of the same problem in the opposite

1300
00:56:56,003 --> 00:56:56,303
direction.

1301
00:56:56,323 --> 00:56:56,704
Yeah.

1302
00:56:57,484 --> 00:56:57,764
Thank you.

1303
00:56:57,964 --> 00:56:59,044
Yeah, you're welcome.

1304
00:57:01,545 --> 00:57:03,705
Why did you not set thread affinity on Windows?

1305
00:57:04,605 --> 00:57:08,706
So as I mentioned before, on Windows PC,

1306
00:57:08,746 --> 00:57:10,887
our main goal is to be as flexible as possible.

1307
00:57:11,327 --> 00:57:15,307
And so with thread affinity, if you restrict in any way

1308
00:57:15,908 --> 00:57:16,108
what...

1309
00:57:17,351 --> 00:57:19,432
threads, or what CPU threads want to run on,

1310
00:57:19,792 --> 00:57:21,213
then you're intrinsically less flexible.

1311
00:57:21,593 --> 00:57:23,334
And so what that means is that if the operating system

1312
00:57:23,374 --> 00:57:26,776
decides that, you know what, this core that you really like

1313
00:57:26,796 --> 00:57:27,956
and you want it to be authenticized to,

1314
00:57:28,096 --> 00:57:29,777
I'm gonna use it for some other programs,

1315
00:57:30,437 --> 00:57:33,959
then you lose one of your assumed resources.

1316
00:57:34,139 --> 00:57:36,580
So, non-authentication is just in order for us

1317
00:57:36,620 --> 00:57:38,661
to try and be as flexible as possible,

1318
00:57:38,781 --> 00:57:40,002
in the case of the operating system

1319
00:57:40,042 --> 00:57:41,743
reducing our execution resources on the CPU.

1320
00:57:43,509 --> 00:57:46,510
still gonna have variable amounts of compute,

1321
00:57:46,890 --> 00:57:50,192
even if, like, you know, if you have thread affinity,

1322
00:57:50,232 --> 00:57:51,772
it's better, actually, right?

1323
00:57:51,792 --> 00:57:52,873
Because if you don't have thread affinity,

1324
00:57:52,893 --> 00:57:54,313
you're gonna end up with two things on the same,

1325
00:57:54,473 --> 00:57:55,914
like, you're gonna have two logical cores.

1326
00:57:56,374 --> 00:57:57,035
Right, so if you have.

1327
00:57:57,055 --> 00:57:58,255
With the same worker thread, or two workers.

1328
00:57:58,275 --> 00:58:01,316
Yeah, so if you're, yeah, so if you're trying

1329
00:58:01,356 --> 00:58:03,957
to run multiple threads on a smaller number of CPUs,

1330
00:58:04,077 --> 00:58:05,138
is that what you're saying?

1331
00:58:05,178 --> 00:58:06,958
Yeah, so we still have priority between threads.

1332
00:58:07,359 --> 00:58:09,359
So we could still decide which things have to come first,

1333
00:58:09,800 --> 00:58:10,880
even in the scenario where Windows

1334
00:58:10,940 --> 00:58:12,841
had taken away some of our CPUs, so.

1335
00:58:13,413 --> 00:58:13,493
Yeah.

1336
00:58:13,513 --> 00:58:17,134
And then, how did your gameplay scripting not cause desync?

1337
00:58:17,394 --> 00:58:18,735
You moved that to variable frame rate.

1338
00:58:18,875 --> 00:58:21,076
Yeah, so our gameplay scripting is,

1339
00:58:22,256 --> 00:58:25,458
it doesn't touch any state that is directly part

1340
00:58:25,518 --> 00:58:26,638
of the fixed update.

1341
00:58:27,478 --> 00:58:29,599
It's doing instructions and changing stuff

1342
00:58:29,619 --> 00:58:30,820
that is gonna influence fixed updates,

1343
00:58:30,920 --> 00:58:32,460
but at the end of the story,

1344
00:58:32,560 --> 00:58:34,801
most of our scripting is either server side,

1345
00:58:35,322 --> 00:58:36,662
and the server is doing, I don't know,

1346
00:58:36,702 --> 00:58:39,483
like a progress of the multiplayer match

1347
00:58:39,563 --> 00:58:40,203
and things like that.

1348
00:58:41,004 --> 00:58:42,104
Or if it is client side,

1349
00:58:42,124 --> 00:58:42,204
it's.

1350
00:58:43,437 --> 00:58:45,418
And so for the server side, we basically,

1351
00:58:45,458 --> 00:58:47,319
that script is just changing some variables

1352
00:58:47,479 --> 00:58:49,361
and then the server is replicating them to the client

1353
00:58:49,601 --> 00:58:51,462
inside our Guard.MES network simulation.

1354
00:58:51,962 --> 00:58:53,724
From the client side, we're only doing visual things

1355
00:58:53,804 --> 00:59:06,352
in the scripting side, so yeah.

1356
00:59:06,552 --> 00:59:09,534
I have a, something about me is that I have a past at Havoc

1357
00:59:09,934 --> 00:59:11,956
and so I really lean towards physics bugs.

1358
00:59:14,031 --> 00:59:15,732
Also, yes, the cake was a lie, sorry about that.

1359
00:59:18,174 --> 00:59:21,917
So with the introduction of the variable frame rates

1360
00:59:21,977 --> 00:59:24,679
on the clients, is the server able to account

1361
00:59:24,739 --> 00:59:26,120
for that for hit detection?

1362
00:59:26,940 --> 00:59:29,462
Yeah, so hit detection would probably

1363
00:59:29,522 --> 00:59:30,883
deserve a presentation on its own.

1364
00:59:31,063 --> 00:59:33,265
But yeah, so.

1365
00:59:35,226 --> 00:59:37,907
So on the server side, so hit registration

1366
00:59:38,267 --> 00:59:39,087
is a very interesting topic.

1367
00:59:39,127 --> 00:59:41,167
But yes, the server is doing game ticks

1368
00:59:41,207 --> 00:59:42,168
just like the clients are.

1369
00:59:42,528 --> 00:59:44,208
So the game ticks are the basic way

1370
00:59:44,228 --> 00:59:46,209
in which we advance our network simulation.

1371
00:59:46,829 --> 00:59:49,810
And when the client shoots at someone

1372
00:59:49,990 --> 00:59:52,450
and we want to do hit validation or hit registration

1373
00:59:52,470 --> 00:59:54,011
on the server side, the server side

1374
00:59:54,051 --> 00:59:57,011
is able to emulate the client view at the time

1375
00:59:57,031 --> 00:59:59,092
where the shot happened through that registration

1376
00:59:59,152 --> 01:00:00,032
and confirm the hit.

1377
01:00:00,632 --> 01:00:02,594
And we do that throughout, basically we rewind time

1378
01:00:02,634 --> 01:00:04,356
on the server for the systems that are required

1379
01:00:04,376 --> 01:00:07,419
to do the shot registration so that it matches the timeline

1380
01:00:07,439 --> 01:00:09,701
at the time the client actually shot.

1381
01:00:10,281 --> 01:00:13,284
So does that mean that each client has to also send what,

1382
01:00:13,824 --> 01:00:17,027
like their frame rate as well, so that the server knows

1383
01:00:17,248 --> 01:00:18,989
how far into each frame the client is?

1384
01:00:19,550 --> 01:00:22,192
Yeah, so we do, so the clients don't send

1385
01:00:22,212 --> 01:00:26,116
their frame rate directly, but we do keep track of the,

1386
01:00:27,365 --> 01:00:29,466
of the round trip time per client.

1387
01:00:29,486 --> 01:00:31,626
So we're able to bring them to the right time

1388
01:00:31,666 --> 01:00:32,647
when doing shot registration.

1389
01:00:33,747 --> 01:00:34,427
Okay, thank you.

1390
01:00:34,687 --> 01:00:34,827
Yeah.

1391
01:00:38,808 --> 01:00:41,689
For monitors with variable refresh rate,

1392
01:00:41,949 --> 01:00:45,089
and if you have a fixed update that takes very long time,

1393
01:00:45,149 --> 01:00:47,910
maybe compared to the variable updates,

1394
01:00:48,590 --> 01:00:51,631
does that create some jank where you might have

1395
01:00:51,951 --> 01:00:53,631
very fast frames and then a long one

1396
01:00:53,651 --> 01:00:54,552
that's visible in the monitor?

1397
01:00:54,812 --> 01:00:57,014
Yeah, so this is what would happen if you configure

1398
01:00:57,034 --> 01:00:58,516
the PC in unlocked frame rate.

1399
01:00:59,076 --> 01:01:00,678
But that's why I said that most of the time

1400
01:01:00,698 --> 01:01:01,960
you're not going to want to do it that way.

1401
01:01:01,980 --> 01:01:03,241
You're going to want to specify, OK, I

1402
01:01:03,261 --> 01:01:07,446
want to play at, I don't know, 80 FPS or 110 FPS or whatever,

1403
01:01:08,026 --> 01:01:09,748
depending on your range of VRR.

1404
01:01:10,349 --> 01:01:10,469
And

1405
01:01:13,242 --> 01:01:15,763
And yeah, so as long as the game is able to maintain that,

1406
01:01:15,823 --> 01:01:17,663
and then if you have a really long fixed update,

1407
01:01:17,723 --> 01:01:20,064
or game take, or even a long viable frame rate update,

1408
01:01:20,084 --> 01:01:21,804
you're eventually gonna burst through that.

1409
01:01:22,265 --> 01:01:24,105
But as long as you're able to fall within the ranges,

1410
01:01:24,345 --> 01:01:25,205
then that should be totally fine.

1411
01:01:25,225 --> 01:01:26,486
And the metronome, which is the thing

1412
01:01:26,506 --> 01:01:28,106
that is keeping your intended frame rate,

1413
01:01:28,146 --> 01:01:29,807
is gonna be the thing that slows us down the most.

1414
01:01:33,568 --> 01:01:34,368
Okay, that's it.

1415
01:01:34,948 --> 01:01:35,448
Thank you everyone.

1416
01:01:35,468 --> 01:01:38,889
Thank you.

1417
01:01:38,909 --> 01:01:39,089
Thank you.

1418
01:01:39,109 --> 01:01:39,289
Thank you.

1419
01:01:39,309 --> 01:01:39,549
Thank you.

1420
01:01:40,789 --> 01:01:40,969
Thank you.

1421
01:01:40,989 --> 01:01:41,170
Thank you.

1422
01:01:41,190 --> 01:01:41,370
Thank you.

1423
01:01:41,390 --> 01:01:41,590
Thank you.

