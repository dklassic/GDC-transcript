1
00:00:06,231 --> 00:00:07,931
Hi, my name is Niklas Kray.

2
00:00:08,771 --> 00:00:10,532
I work at a company called R Machinery.

3
00:00:10,552 --> 00:00:15,513
And in this talk, I'm going to talk about tools development and more

4
00:00:15,553 --> 00:00:21,834
specifically what we've done to speed up tools development and make it faster

5
00:00:22,114 --> 00:00:23,474
and make our tools better than before.

6
00:00:26,075 --> 00:00:28,595
I have a long history of writing game engines.

7
00:00:29,335 --> 00:00:33,436
Most well known is probably the BitSquid and Stingray game engine, which

8
00:00:33,496 --> 00:00:34,496
is actually the same engine.

9
00:00:35,688 --> 00:00:37,530
rebranded when Autodesk bought it.

10
00:00:40,214 --> 00:00:47,142
In the last few years I've been working on a new game engine called The Machinery and

11
00:00:48,904 --> 00:00:52,749
been trying to fix all the mistakes of the past game engines that I made.

12
00:00:54,210 --> 00:01:02,337
So in this talk, I'm going to be talking a little bit about the history we've had with BitSquid and Stingray,

13
00:01:03,278 --> 00:01:11,085
our troubles with tools, why it's been so hard for us, and what we can possibly do about it,

14
00:01:11,165 --> 00:01:14,628
and how we attempted to fix it when writing the machinery.

15
00:01:16,228 --> 00:01:19,490
So first, let's start with a brief history of our failures

16
00:01:20,410 --> 00:01:21,630
as when it comes to tools.

17
00:01:23,011 --> 00:01:24,972
In the first version of BitSquid,

18
00:01:26,072 --> 00:01:29,073
our first idea about tools was that we shouldn't

19
00:01:29,353 --> 00:01:30,634
write any tools at all.

20
00:01:32,074 --> 00:01:34,555
Rather, we should just expose sort of public file

21
00:01:34,595 --> 00:01:36,256
formats like JSON files.

22
00:01:36,616 --> 00:01:38,817
And our users could just write their own tools.

23
00:01:39,017 --> 00:01:41,458
As long as they outputted this file format,

24
00:01:41,558 --> 00:01:43,399
they would work together with our runtime

25
00:01:43,459 --> 00:01:44,479
and everything would be fine.

26
00:01:45,606 --> 00:01:48,451
Turns out this wasn't really that great idea.

27
00:01:48,671 --> 00:01:52,518
Users actually do not want to write all the tools themselves.

28
00:01:54,281 --> 00:01:56,505
You would think we would have figured that out before.

29
00:01:57,545 --> 00:02:03,690
starting this game engine, but we didn't really. So we quickly had to scramble and address this

30
00:02:03,770 --> 00:02:09,755
in some way. So our first approach was just, well, let's hack together something quickly in WinForms.

31
00:02:11,557 --> 00:02:16,941
This actually is a pretty speedy way to build tools. You can just put in whatever

32
00:02:17,322 --> 00:02:20,625
check boxes and buttons and dialogue boxes that you need.

33
00:02:21,826 --> 00:02:27,009
But to be honest, it looks kind of ugly, like it's not the nicest look.

34
00:02:27,729 --> 00:02:29,950
And it also turned out pretty messy.

35
00:02:30,010 --> 00:02:35,274
We didn't start with a clear plan of how things should work in the tools and how different

36
00:02:35,314 --> 00:02:36,354
tools should interact.

37
00:02:37,383 --> 00:02:43,546
how things like copy paste and undo and redo and drag and drop and stuff like that was

38
00:02:43,566 --> 00:02:44,187
supposed to work.

39
00:02:44,247 --> 00:02:50,710
So over time, it got kind of hard to maintain and it got kind of messy.

40
00:02:51,130 --> 00:02:55,072
But to be honest, it worked pretty well and it's a fast and nice way to build tools.

41
00:02:56,252 --> 00:02:58,773
But we thought we needed to do something better.

42
00:02:58,893 --> 00:03:05,476
So for sort of the next iteration of tools for the Bitsquid Engine, we decided to go

43
00:03:05,596 --> 00:03:05,816
with...

44
00:03:07,077 --> 00:03:14,565
WPF instead. The reason we made that decision was like that was sort of the recommended UI toolkit

45
00:03:14,705 --> 00:03:24,875
from Windows at that point. I think it still is, but I'm not 100% sure. And using WPF,

46
00:03:24,955 --> 00:03:28,899
our tools suddenly looked a lot better, a lot prettier.

47
00:03:30,381 --> 00:03:35,770
But a result of switching to WPF and moving away from this sort of hacky approach we had

48
00:03:35,790 --> 00:03:39,115
before was that the tools actually took a lot longer to write.

49
00:03:40,043 --> 00:03:41,964
who's also a higher barrier of entry.

50
00:03:43,385 --> 00:03:46,286
WinForms is pretty simple to hack together tools,

51
00:03:46,326 --> 00:03:50,668
pretty straightforward, but to use WPF effectively,

52
00:03:50,708 --> 00:03:51,949
you need to know C-sharp,

53
00:03:52,329 --> 00:03:56,531
you need to know the programming patterns of C-sharp,

54
00:03:57,471 --> 00:03:59,572
and query style programming and stuff like that.

55
00:04:00,113 --> 00:04:01,513
You need to know WPF,

56
00:04:01,533 --> 00:04:03,254
you need to know XAML,

57
00:04:03,714 --> 00:04:07,136
and there's a lot of little subtleties that you need to know.

58
00:04:08,237 --> 00:04:13,438
And as a result of the tools, so our initial plan was we should rewrite everything.

59
00:04:13,478 --> 00:04:18,200
We should just take all our WinForms tool, convert them to WPF and things would be fine.

60
00:04:18,820 --> 00:04:23,541
But this conversion actually took a lot longer than we expected.

61
00:04:24,081 --> 00:04:27,462
I think just our unit editor took like six months or something to rewrite.

62
00:04:28,582 --> 00:04:31,983
And as a result, we never actually completed this rewrite.

63
00:04:32,023 --> 00:04:36,004
So some of the tools you see here, so this is sort of our launcher that

64
00:04:36,244 --> 00:04:37,444
launched all our different tools.

65
00:04:38,344 --> 00:04:41,445
And some of these tools were rewritten to WPF and some were not.

66
00:04:41,505 --> 00:04:47,427
And we sort of had this mix of tools built on top of different frameworks,

67
00:04:47,467 --> 00:04:49,027
which is not great.

68
00:04:50,247 --> 00:04:54,648
And the cause for that was just that it took so long to rewrite everything in WPF.

69
00:04:57,089 --> 00:04:58,510
Then we got acquired by Autodesk.

70
00:04:59,030 --> 00:05:03,131
And one of the requirements or wishes that Autodesk had

71
00:05:03,571 --> 00:05:06,072
was for our editor to be platform independent.

72
00:05:07,272 --> 00:05:09,513
So that meant we couldn't use WPF.

73
00:05:10,134 --> 00:05:14,316
I mean, we could try to do something with Mono, but it didn't look very

74
00:05:14,356 --> 00:05:17,537
nice and promising to go down that route.

75
00:05:18,918 --> 00:05:22,219
So we decided to go with web-based tools.

76
00:05:23,340 --> 00:05:24,681
It seemed reasonable.

77
00:05:25,321 --> 00:05:27,982
Everything would be platform independent, sort of by default.

78
00:05:28,022 --> 00:05:30,023
It would be built on web technology.

79
00:05:31,007 --> 00:05:36,574
We also had the idea that we could, by using web technology, we could sort of reuse web expertise.

80
00:05:36,594 --> 00:05:44,424
There's a lot of people out there who knows how to write UIs using HTML and CSS, and it could be nice to use all of that.

81
00:05:44,844 --> 00:05:47,347
And our tools would run in the browser too, which is kind of nice.

82
00:05:48,448 --> 00:05:52,211
But there were multiple drawbacks with this approach.

83
00:05:53,072 --> 00:05:56,095
Our tech stack, which already was kind of complicated

84
00:05:56,155 --> 00:05:58,477
because we had an engine using C++.

85
00:05:59,377 --> 00:06:01,079
Then we had a scripting language for that engine,

86
00:06:01,099 --> 00:06:01,820
which was Lua.

87
00:06:02,400 --> 00:06:05,823
And then we had C-sharp to run our tools,

88
00:06:06,483 --> 00:06:08,505
which targeted WinForms and WPF.

89
00:06:08,545 --> 00:06:10,467
So that was already kind of complicated.

90
00:06:11,528 --> 00:06:13,269
To this, we now added Chromium.

91
00:06:14,275 --> 00:06:15,175
to run the web tools.

92
00:06:16,537 --> 00:06:21,761
Qt actually was used for the Windows system and some parts

93
00:06:21,801 --> 00:06:22,141
like that.

94
00:06:23,022 --> 00:06:25,283
We had JavaScript, of course, because we need to program

95
00:06:25,503 --> 00:06:26,424
Chromium somehow.

96
00:06:26,905 --> 00:06:28,506
We also had some JavaScript toolkits.

97
00:06:29,647 --> 00:06:35,229
I think we had a bunch of them. Angular was one, but I think we had React there at some point,

98
00:06:35,709 --> 00:06:40,690
and some other JavaScript toolkit too. We had WebSockets to handle the communication

99
00:06:40,751 --> 00:06:46,252
between the engine and the tool. So this is a really deep, heavy tech stack. And as a result

100
00:06:46,292 --> 00:06:52,795
of that, tools took even longer to rewrite, because now there's all of these components

101
00:06:52,815 --> 00:06:54,295
that we need to take care of.

102
00:06:55,633 --> 00:06:59,174
And it ended up being that we never completed this rewrite either.

103
00:06:59,294 --> 00:07:04,455
So not only did we not rewrite all WinForms tools to WPF, we didn't rewrite

104
00:07:04,555 --> 00:07:08,577
all WPF tools or all WinForms tools to the web platform either.

105
00:07:09,337 --> 00:07:14,058
So at the end of sort of the Stingray area, we had this mix where some tools

106
00:07:14,078 --> 00:07:18,379
were in WinForms, some tools were still in WPF and some tools were in the web

107
00:07:18,399 --> 00:07:21,660
interface, so even more complicated at that point.

108
00:07:23,559 --> 00:07:29,026
So, to be honest, Bitsquid and Stingray never had good tools.

109
00:07:29,186 --> 00:07:31,288
The tools were always suffering.

110
00:07:32,781 --> 00:07:38,643
And as we started out with the machinery, that was one of the problems that we really

111
00:07:38,683 --> 00:07:39,283
wanted to fix.

112
00:07:39,303 --> 00:07:44,845
Because I think that every time you start writing a new engine, you kind of want to

113
00:07:44,885 --> 00:07:50,607
like atone for the mistakes that you made in your last engine and find a way of addressing

114
00:07:50,647 --> 00:07:51,627
them and fixing them.

115
00:07:52,047 --> 00:07:54,788
And that's sort of the drive too for making a new engine.

116
00:07:56,449 --> 00:07:59,750
So we identified this as sort of a core problem.

117
00:08:02,095 --> 00:08:03,896
So what were the big problems?

118
00:08:03,916 --> 00:08:07,418
Well, one problem, of course, is we kept changing the frameworks, the underlying

119
00:08:07,438 --> 00:08:13,041
UI framework, and that caused us lots of delays and lots of extra work.

120
00:08:14,282 --> 00:08:18,624
But there's also, so that caused, made us lose a lot of time writing tools.

121
00:08:18,664 --> 00:08:23,847
But there was another problem that tools just in general took too long to write.

122
00:08:24,567 --> 00:08:28,730
I remember on a number of occasions where I would add a feature to the engine.

123
00:08:29,669 --> 00:08:35,092
and it would take me maybe four hours or a work day to add that feature to the engine.

124
00:08:35,973 --> 00:08:42,077
And then to add tooling for that feature could be like a week or two weeks just to do the

125
00:08:42,137 --> 00:08:43,417
work.

126
00:08:44,198 --> 00:08:45,859
It also needs to be scheduled into the...

127
00:08:46,825 --> 00:08:51,166
sort of pipeline for the tools programmers, which means there could be a month or something

128
00:08:51,827 --> 00:08:53,287
before the UI was actually there.

129
00:08:53,647 --> 00:08:57,469
And I always felt like there was like this weird disconnect here.

130
00:08:57,849 --> 00:09:03,811
How was it that it was so much easier to add stuff to the runtime than to add stuff to

131
00:09:03,831 --> 00:09:04,291
the tools?

132
00:09:04,571 --> 00:09:11,894
And it always felt like the tools were slowing us down and like holding us back from writing

133
00:09:11,914 --> 00:09:12,575
an awesome engine.

134
00:09:13,547 --> 00:09:15,389
So we need to fix that somehow.

135
00:09:16,550 --> 00:09:19,752
A third problem that we also had with the Bitsquid and Stingray tools,

136
00:09:19,812 --> 00:09:23,255
especially as we got into the web technology, was bad performance.

137
00:09:24,276 --> 00:09:28,499
So, I mean, writing a game engine, it's all about performance.

138
00:09:28,579 --> 00:09:32,503
It's all about how many characters, how much animation and physics and so on.

139
00:09:32,583 --> 00:09:33,463
Rendering, can you push?

140
00:09:34,500 --> 00:09:37,682
And it's kind of sad if your editor doesn't reflect that.

141
00:09:38,043 --> 00:09:41,925
So if you have a really long startup for your editor, or if it doesn't just feel

142
00:09:42,385 --> 00:09:45,447
snappy when you click on things, it's not nice.

143
00:09:45,467 --> 00:09:48,629
So we wanted to make sure that the performance of the tools

144
00:09:48,769 --> 00:09:49,930
match the performance of the engine.

145
00:09:50,490 --> 00:09:51,450
So how do we fix this?

146
00:09:52,071 --> 00:09:56,073
What are the actual problems that we need to address?

147
00:09:56,573 --> 00:09:58,835
So one of them, changing frameworks.

148
00:09:59,355 --> 00:10:01,836
So why does this happen to begin with?

149
00:10:03,190 --> 00:10:07,752
Sometimes I would say we're changing frameworks because we made an initial

150
00:10:07,812 --> 00:10:14,894
bad decision and using platform-specific technology like WinForms or WPF could

151
00:10:14,914 --> 00:10:16,094
be considered a bad decision.

152
00:10:17,334 --> 00:10:19,595
Maybe it would have been better to go with Qt instead.

153
00:10:19,955 --> 00:10:22,656
Using web technology, maybe that was a bad decision too.

154
00:10:23,336 --> 00:10:26,378
But it's kind of hard to avoid all bad decisions.

155
00:10:26,918 --> 00:10:32,081
You're probably likely at some point to make one or two bad decisions that will

156
00:10:32,261 --> 00:10:34,202
result in you having to change frameworks.

157
00:10:35,123 --> 00:10:39,825
Also, even if you don't make any bad decisions yourself, you sometimes get in

158
00:10:39,845 --> 00:10:45,068
a situation where technology that you've used and sort of depended on gets outdated

159
00:10:45,208 --> 00:10:45,849
or abandoned.

160
00:10:45,889 --> 00:10:47,670
So there's a number of.

161
00:10:48,771 --> 00:10:54,818
different technologies that they get obsolete and they get put into like the legacy scrap pile.

162
00:10:55,238 --> 00:11:00,084
So one of them that we used actually in Stingray was the native client, the Google native client,

163
00:11:01,285 --> 00:11:07,532
and that got abandoned or deprecated and then we need to find another way of handling that.

164
00:11:08,507 --> 00:11:13,610
Now, in theory, if a piece of technology gets sort of abandoned, you could keep

165
00:11:13,710 --> 00:11:18,352
running on it because you have the latest version of it and you probably can still

166
00:11:18,492 --> 00:11:18,812
use it.

167
00:11:20,253 --> 00:11:25,395
But in practice, that's kind of troublesome because it means that since it's not

168
00:11:25,455 --> 00:11:30,778
being maintained anymore by the people who actually made the technology, it means

169
00:11:30,818 --> 00:11:34,880
that you now have the full responsibility of maintaining this framework.

170
00:11:35,900 --> 00:11:37,301
And that can be a big burden.

171
00:11:37,361 --> 00:11:37,561
I mean.

172
00:11:38,828 --> 00:11:43,231
Say you have an engine with like 300,000 or 500,000 lines of code,

173
00:11:43,771 --> 00:11:44,632
you have to maintain that.

174
00:11:44,712 --> 00:11:48,914
But, but suddenly you now also have to maintain like an old version of Chromium

175
00:11:48,954 --> 00:11:50,575
because you want to keep native client.

176
00:11:51,516 --> 00:11:54,758
And that's got like a million or a million and a half lines of codes.

177
00:11:54,798 --> 00:11:57,380
And do you really want to keep fixing bugs in that?

178
00:11:57,500 --> 00:12:01,383
And, and also missing out on, on any new features that come into

179
00:12:01,423 --> 00:12:02,964
like the main branch of Chromium.

180
00:12:03,880 --> 00:12:10,243
So sometimes this just forces you to change technology through no fault of your own.

181
00:12:10,883 --> 00:12:17,426
And the only way of avoiding that is to be less reliant on these frameworks and be really

182
00:12:17,786 --> 00:12:24,248
careful about what frameworks you rely on and your ability of switching them out if necessary.

183
00:12:26,069 --> 00:12:31,771
Another question, why did it take us so long to write tools compared to writing engine code?

184
00:12:32,673 --> 00:12:34,714
Well, we identified a number of factors.

185
00:12:35,795 --> 00:12:41,578
One is just like that every, every little thing you add to your engine needs a UI.

186
00:12:41,658 --> 00:12:45,860
So you add a new parameter somewhere, then it needs, someone needs to design

187
00:12:45,900 --> 00:12:48,181
a little UI for that, that piece.

188
00:12:48,241 --> 00:12:50,982
It needs to be coded, it needs to be tested and so on.

189
00:12:51,402 --> 00:12:54,684
So every little, every, it's just a lot of work to do every little thing.

190
00:12:55,684 --> 00:12:59,689
There's also a lot of features that you sort of expect in a modern UI,

191
00:13:00,050 --> 00:13:04,615
things like undo, redo, unlimited undo, redo, you want copy and paste to work,

192
00:13:04,635 --> 00:13:09,962
you want to drag and drop to work, it needs to work with serialization and saving and loading

193
00:13:10,483 --> 00:13:13,566
and migrating of data and stuff like that.

194
00:13:14,670 --> 00:13:19,535
And all of these little things, each little thing takes time to add.

195
00:13:20,356 --> 00:13:23,159
And it also adds to the size of your code.

196
00:13:23,199 --> 00:13:27,383
So every time you add a new UI box and then you add undo and copy paste for that,

197
00:13:27,423 --> 00:13:30,387
you add more code to your project.

198
00:13:30,487 --> 00:13:35,592
And generally the more code you have to lug around, the less agile you become

199
00:13:35,632 --> 00:13:36,433
and the more slower.

200
00:13:37,489 --> 00:13:41,573
everything becomes because you have to manage all that code and if you want to make some kind of

201
00:13:41,894 --> 00:13:46,018
refactoring you have more code to refactor, more code to debug and profile and so on.

202
00:13:48,240 --> 00:13:54,206
Another problem specifically with the way the Stingray technology was built was that

203
00:13:54,506 --> 00:13:55,767
we have this deep tech stack.

204
00:13:56,720 --> 00:14:02,084
And when you have a deep tech stack like that, it's hard to understand where bugs are happening.

205
00:14:02,144 --> 00:14:06,406
If you run into a bug, you don't really know, well, is this a bug in Angular?

206
00:14:06,466 --> 00:14:07,827
Is it in the JavaScript code?

207
00:14:08,087 --> 00:14:09,108
Is it in the WebSocket?

208
00:14:09,168 --> 00:14:12,490
Is it in Chromium or C-sharp or Lua or the C++?

209
00:14:12,770 --> 00:14:14,712
There's just so many different places to look.

210
00:14:15,392 --> 00:14:18,454
So the problem here is really one of complexity.

211
00:14:19,448 --> 00:14:25,989
The more complexity you add to a project, the more work you have to do for everything.

212
00:14:26,029 --> 00:14:32,151
Like finding bugs becomes more work, finding performance issues becomes more work, refactoring

213
00:14:32,171 --> 00:14:34,431
becomes more work, adding features becomes more work.

214
00:14:34,911 --> 00:14:37,872
So complexity is really your big enemy.

215
00:14:37,912 --> 00:14:39,993
That's really what you want to minimize.

216
00:14:41,634 --> 00:14:48,744
And having all these layers and all these components that are not really ours and that we don't control really adds to the complexity.

217
00:14:49,465 --> 00:14:51,968
Another problem with this complexity too was that...

218
00:14:53,115 --> 00:14:58,459
Since there were so many different components here, only the tool people really had a good

219
00:14:58,600 --> 00:15:03,763
understanding of the tool stack. That means that if a rendering engineer, for instance,

220
00:15:04,144 --> 00:15:09,388
added a new feature to the renderer, they couldn't just go in and add that feature to the UI,

221
00:15:09,488 --> 00:15:12,550
because the UI was too complex for them to

222
00:15:13,130 --> 00:15:14,291
to do things like that quickly.

223
00:15:14,751 --> 00:15:16,591
So the development got very siloed

224
00:15:17,291 --> 00:15:19,792
and you got the tools team and the runtime team

225
00:15:19,832 --> 00:15:21,052
and they were completely separate,

226
00:15:22,172 --> 00:15:23,673
which when you do stuff like that,

227
00:15:23,733 --> 00:15:25,773
it often leads to friction between the teams.

228
00:15:26,433 --> 00:15:30,034
And it also means that stuff that's important for one team,

229
00:15:30,114 --> 00:15:32,714
like a feature that's important to the rendering team

230
00:15:33,095 --> 00:15:35,195
might not be as important to the tools team.

231
00:15:35,215 --> 00:15:38,316
So it ends up being queued on some queue somewhere

232
00:15:38,916 --> 00:15:39,016
and...

233
00:15:39,836 --> 00:15:42,796
You don't know actually when it's going to be implemented and stuff like that.

234
00:15:43,277 --> 00:15:47,757
And I just think things run a lot more efficient when everybody is sort

235
00:15:47,777 --> 00:15:49,478
of able to touch all the code.

236
00:15:49,578 --> 00:15:54,579
So the rendering engineer can actually go in here and add it to the UI.

237
00:15:54,619 --> 00:15:58,699
And then maybe some UI programmer needs to come in later and sort of pretty

238
00:15:58,739 --> 00:16:03,300
things up a little bit, but at least the feature is there and can be accessed.

239
00:16:03,740 --> 00:16:08,601
So people don't constantly keep getting blocked by other people.

240
00:16:10,944 --> 00:16:13,787
Third issue, the performance problems. Why did that happen?

241
00:16:14,927 --> 00:16:21,353
I think a big part of that is that standard web practices didn't always work.

242
00:16:21,753 --> 00:16:26,877
So the way when you have web programmers in, they have their usual way of doing things.

243
00:16:28,038 --> 00:16:31,000
And that doesn't always work when you're building a game editor.

244
00:16:31,161 --> 00:16:38,306
Because game development has way more stuff than your typical HTML application.

245
00:16:39,102 --> 00:16:42,003
Like I said, when it comes to making game engines or games,

246
00:16:42,283 --> 00:16:45,645
we always try to push performance as far as it will go.

247
00:16:46,645 --> 00:16:49,746
And that means you're always sort of running at the brink

248
00:16:49,786 --> 00:16:52,827
of what your computer is able to handle.

249
00:16:54,208 --> 00:16:55,689
And if you do things like...

250
00:16:56,009 --> 00:16:58,732
And this doesn't mean that you necessarily...

251
00:16:58,752 --> 00:17:01,253
It's not possible to do this in the web browser.

252
00:17:02,715 --> 00:17:04,536
Web browser can do amazing things.

253
00:17:04,756 --> 00:17:10,360
And if you write things the right way for the web browser, it might work.

254
00:17:10,420 --> 00:17:14,904
But if you write it sort of the regular, the usual way of doing it, it might not work.

255
00:17:16,515 --> 00:17:29,366
So what would often happen is that some of our UI programmers would create a tool and it would look pretty and it would run nice with like a hundred objects in it.

256
00:17:30,287 --> 00:17:35,912
But then as soon as you put a thousand or ten thousand objects in it, it would break down and run on its knees.

257
00:17:36,533 --> 00:17:44,585
And fixing that was not just an issue of like finding little performance, like profiling it

258
00:17:44,645 --> 00:17:49,432
and finding little performance hotspots. It often required a complete rewrite of the system.

259
00:17:51,855 --> 00:17:56,218
Controls had to be virtualized, data had to be stored in a completely different ways.

260
00:17:56,578 --> 00:18:02,022
Maybe we had to bypass some JavaScript framework because that framework didn't

261
00:18:02,062 --> 00:18:08,786
have a performance mindset. So the rewrite was often, the cost of the rewrite was similar to

262
00:18:09,186 --> 00:18:10,487
writing the system from scratch.

263
00:18:12,500 --> 00:18:15,602
Also, the deep tech stack, again, complicates everything.

264
00:18:15,662 --> 00:18:18,504
It also complicates finding these performance issues.

265
00:18:18,944 --> 00:18:21,846
And the browser, when it comes to performance issues and the browser,

266
00:18:21,886 --> 00:18:24,528
it's more or less a black box.

267
00:18:24,568 --> 00:18:27,990
You don't know, oh, I've wrote my JavaScript code this way and it's

268
00:18:28,030 --> 00:18:29,731
send the JIT into this.

269
00:18:30,381 --> 00:18:36,023
bad path so now everything runs 10 times slower than before and these things can be really hard

270
00:18:36,043 --> 00:18:41,084
to know. They can also change from version to version of the web browser so if you update

271
00:18:41,784 --> 00:18:46,806
Chromium because you need access to some new features then suddenly you might have completely

272
00:18:46,866 --> 00:18:52,367
new performance problems and you need to investigate everything again which makes this really tricky to

273
00:18:52,427 --> 00:18:59,489
keep a good control of the performance. So how do we fix all these things, all these problems?

274
00:19:00,625 --> 00:19:08,909
Well, the thing with too much stuff to write, our idea there was we can automate a lot of this stuff.

275
00:19:08,969 --> 00:19:12,851
So stuff like undo, copy, paste, and stuff like that.

276
00:19:13,691 --> 00:19:19,654
If we define a standardized data model, which is the way we represent the data in our application,

277
00:19:20,134 --> 00:19:23,976
we can define a lot of these operations on that data model.

278
00:19:24,296 --> 00:19:29,138
And that means that the UI doesn't really have to be bothered with it that much.

279
00:19:29,939 --> 00:19:33,042
It doesn't have to do anything specific to do undo, redo.

280
00:19:33,302 --> 00:19:36,025
It can just talk to the data representation and say,

281
00:19:36,305 --> 00:19:39,448
well, undo this action and then the data model can do it.

282
00:19:40,269 --> 00:19:44,373
So that cuts down drastically the amount of work that needs to go into the UI.

283
00:19:45,914 --> 00:19:51,438
Step two, what we did, we really didn't like this deep tech stack and all the complexity

284
00:19:51,778 --> 00:19:54,180
and the problems with changing frameworks that came with that.

285
00:19:54,800 --> 00:20:00,744
So we decided to minimize the tech stack completely, use as few frameworks as possible, and also

286
00:20:01,045 --> 00:20:03,386
own as much of the tech stack as possible.

287
00:20:03,466 --> 00:20:07,429
So it's actually running on our code, not everybody else's codes.

288
00:20:07,629 --> 00:20:12,612
That means we know the code, we can debug it, we can profile it, and we can understand

289
00:20:12,672 --> 00:20:13,713
everything that goes on with it.

290
00:20:15,135 --> 00:20:18,960
make things explicit so instead of these black boxes where you don't know what's happening

291
00:20:19,621 --> 00:20:21,744
you can actually see what's going on in there.

292
00:20:23,306 --> 00:20:26,631
Finally, again to handle this sort of busy work

293
00:20:27,798 --> 00:20:30,400
instead of writing UIs for every little thing,

294
00:20:31,200 --> 00:20:34,202
we try to, as far as possible, sort of auto-generate

295
00:20:34,282 --> 00:20:37,384
and auto-populate the UIs from data.

296
00:20:38,904 --> 00:20:41,706
And so for example, a graph view or a tree view

297
00:20:41,786 --> 00:20:44,287
or a property view, we try to reuse them

298
00:20:44,527 --> 00:20:46,288
from between different systems

299
00:20:46,989 --> 00:20:49,090
and just have them be generated from the data.

300
00:20:49,270 --> 00:20:50,791
So that way, as a programmer,

301
00:20:50,811 --> 00:20:52,732
you don't actually have to write the UI.

302
00:20:52,832 --> 00:20:54,413
It's sort of created for you.

303
00:20:54,673 --> 00:20:55,773
If you can use one of these.

304
00:20:56,514 --> 00:21:03,382
standardized views and components. So I'll explain all these parts as we go on

305
00:21:03,523 --> 00:21:07,768
through this presentation. But that cuts away a lot of the busy work of just

306
00:21:07,828 --> 00:21:12,013
creating UIs for everything and also cuts down the size of the code which is

307
00:21:12,093 --> 00:21:12,674
really nice too.

308
00:21:13,965 --> 00:21:24,213
So start first with this data model, our way of representing data and how we can use that to do things like undo and stuff like that.

309
00:21:24,673 --> 00:21:26,754
So our data model, we call it the truth.

310
00:21:27,800 --> 00:21:32,524
kind of cheekily because it's, we consider it, it's the truth about the state of the

311
00:21:32,564 --> 00:21:39,691
project. It's where you go to find out anything about what the editor is doing. So all the

312
00:21:39,731 --> 00:21:45,076
data, all the data that's handled by the editor is represented in a uniform way, and then

313
00:21:45,096 --> 00:21:51,542
we can define operations on it. So the way the truth is set up, it's based on objects.

314
00:21:52,946 --> 00:21:57,188
of certain types. Each object has a type, each type has a number of properties,

315
00:21:57,888 --> 00:22:02,030
and each of those properties has a type. So, for example, a person object

316
00:22:02,791 --> 00:22:06,492
might have a name property that is a string, an age property that's an

317
00:22:06,572 --> 00:22:11,515
integer, and then a flag that specifies where it's registered or something like that.

318
00:22:14,133 --> 00:22:21,056
So this is kind of a JSON-like model with the way these properties work,

319
00:22:21,496 --> 00:22:24,677
except we have sort of a schema for these different objects.

320
00:22:25,678 --> 00:22:30,179
We also have well-defined ways of representing references between objects,

321
00:22:30,239 --> 00:22:33,821
so an object can refer to another object, and also sub-objects.

322
00:22:34,261 --> 00:22:39,003
So the difference here is that sub-objects are objects that are owned by these objects.

323
00:22:39,697 --> 00:22:43,460
whereas references are external objects that this object just points to.

324
00:22:43,881 --> 00:22:47,264
And that changes how things work when you copy and paste, for instance.

325
00:22:47,304 --> 00:22:51,928
For example, when you copy and paste, you copy all the sub-objects, but you don't copy the references.

326
00:22:53,009 --> 00:22:56,473
So it's nice to have that explicit in the data model too.

327
00:22:58,695 --> 00:23:02,877
So our data model supports multi-threading automatically,

328
00:23:02,957 --> 00:23:06,239
and we do this actually in a lock-free way.

329
00:23:06,259 --> 00:23:09,341
And I'll explain a little bit about the detail of this

330
00:23:09,401 --> 00:23:11,922
because it's important to other things

331
00:23:11,962 --> 00:23:13,223
that we do in our data model too.

332
00:23:14,372 --> 00:23:22,176
So the way we implement lock-free multithreaded access is by dividing the step of changing

333
00:23:22,196 --> 00:23:24,797
the data into two distinct steps.

334
00:23:25,217 --> 00:23:32,041
So first you call write on the object that you want to change and by doing that you will

335
00:23:32,101 --> 00:23:35,723
actually obtain a copy of the object that you can modify.

336
00:23:37,023 --> 00:23:42,485
and all those changes are local to this copy of the object so it doesn't affect any readers of the

337
00:23:42,525 --> 00:23:47,947
data they still see the old object and once you're done with all your changes you call commit on the

338
00:23:48,007 --> 00:23:55,629
object and it will atomically switch out the old object for the new one by just doing an atomic

339
00:23:56,349 --> 00:24:02,471
pointer switch and then all the readers after that all the readers will see the new objects.

340
00:24:03,589 --> 00:24:07,317
So this way the readers can read the data without locking.

341
00:24:07,437 --> 00:24:10,243
And eventually we clean up all the old copies

342
00:24:10,364 --> 00:24:12,208
with a garbage collection procedure.

343
00:24:14,517 --> 00:24:18,919
So undo in our system is actually based on this too,

344
00:24:18,939 --> 00:24:21,380
which is why I presented this sort of complicated

345
00:24:21,620 --> 00:24:23,241
multi-threading approach first.

346
00:24:24,302 --> 00:24:26,343
So undo works in a similar way.

347
00:24:27,063 --> 00:24:29,324
The only thing we do different for undo is that

348
00:24:31,005 --> 00:24:35,267
when we perform like an undoable write,

349
00:24:35,747 --> 00:24:38,528
we save the old object and the new object.

350
00:24:38,548 --> 00:24:41,650
So both these versions in our current undo scope.

351
00:24:42,746 --> 00:24:48,795
And we can save these for multiple objects because one undoable action might affect multiple objects.

352
00:24:50,217 --> 00:24:57,848
And when the user wants to undo something, we simply reinstate the old data that we saved in this undo scope.

353
00:25:01,138 --> 00:25:08,884
We also have a system for prototyping or prefabs that's built into our data model.

354
00:25:08,944 --> 00:25:16,489
The way this works is that any object in the truth can specify another object to act as its prototype.

355
00:25:17,390 --> 00:25:24,455
What this means is that the instance of the prototype will inherit all properties of the prototype,

356
00:25:25,156 --> 00:25:28,058
but if it wants to, it can override some of them locally.

357
00:25:28,784 --> 00:25:36,067
So we could create another instance of a person object here that just overrides the age, for instance.

358
00:25:36,847 --> 00:25:44,950
So this concept is similar to the way like prefabs work in Unity, for instance, where you can use a prefab and you can override.

359
00:25:45,330 --> 00:25:49,812
properties on it but the important thing here is it's actually built in into our

360
00:25:49,832 --> 00:25:54,535
data model so it works with everything it's not just with entities but any kind

361
00:25:54,555 --> 00:25:59,458
of data in the engine can be given this like prototype treatment which is nice

362
00:26:02,840 --> 00:26:08,943
so other things we can do sort of because we have this well-defined data

363
00:26:08,963 --> 00:26:12,786
model is we can do really advanced things such as real-time collaboration

364
00:26:13,908 --> 00:26:18,371
So multiple people on the network can be working in the same project.

365
00:26:18,891 --> 00:26:22,393
And the way this works is that when someone does a commit, so they

366
00:26:22,473 --> 00:26:25,715
change something in the data, we just compute a Delta between the

367
00:26:25,835 --> 00:26:27,316
old and the new version of the object.

368
00:26:27,716 --> 00:26:31,378
And then we transmit this Delta over the wire to our other

369
00:26:31,418 --> 00:26:32,859
collaborators in the session.

370
00:26:33,340 --> 00:26:37,362
And then they will get those changes and they will enact those

371
00:26:37,382 --> 00:26:38,723
changes on their data model.

372
00:26:40,384 --> 00:26:41,684
the data model will be replicated.

373
00:26:42,324 --> 00:26:43,925
This is an example of this.

374
00:26:44,005 --> 00:26:47,846
We have two people working together here over the network,

375
00:26:48,867 --> 00:26:49,787
a host and a client,

376
00:26:50,347 --> 00:26:52,948
and you can see that any action that's performed by

377
00:26:53,468 --> 00:26:56,609
either the host or the client here in this level

378
00:26:56,749 --> 00:27:00,650
is automatically reflected over to the other person.

379
00:27:01,271 --> 00:27:03,631
Again, since this is built into the data model,

380
00:27:04,012 --> 00:27:05,152
it works with everything.

381
00:27:06,332 --> 00:27:08,793
And it also works with if you extend.

382
00:27:09,990 --> 00:27:12,152
our engine with your own data types and your own

383
00:27:13,553 --> 00:27:17,698
your own kind of your own data representation and your own UIs which

384
00:27:17,718 --> 00:27:20,460
you can do with plugins all of this will work

385
00:27:20,841 --> 00:27:22,642
automatically for for your stuff too

386
00:27:23,824 --> 00:27:31,286
So sort of analyze this approach of using a data model in this way.

387
00:27:31,786 --> 00:27:34,426
What are the advantages and disadvantages that we see?

388
00:27:34,947 --> 00:27:38,327
Well, the big advantage of course, is we get all this functionality for free.

389
00:27:38,347 --> 00:27:42,068
We get undo, we get copy paste, we get serialization.

390
00:27:43,648 --> 00:27:46,769
It just works automatically, not just with our data, but with

391
00:27:47,069 --> 00:27:48,570
other people's data in plugins too.

392
00:27:49,630 --> 00:27:55,171
And as we saw here, it's not just these simpler operations like undo and copy-paste,

393
00:27:55,231 --> 00:28:00,372
it also works for really advanced features such as prototyping or real-time collaboration.

394
00:28:01,832 --> 00:28:08,213
So what are the drawbacks? One drawback is that this way of representing the data,

395
00:28:08,513 --> 00:28:14,074
the sort of key value format with objects and properties, doesn't work well for all kinds of

396
00:28:14,094 --> 00:28:17,775
data. So an example of data that's not that...

397
00:28:19,054 --> 00:28:22,847
well represented in this model would be long pieces of text.

398
00:28:23,937 --> 00:28:28,520
I mean, you could do it, you could have an object with a string property and that string

399
00:28:28,540 --> 00:28:30,981
property is just like 200 pages of text.

400
00:28:32,042 --> 00:28:37,185
But it's not really a nice way of representing that data because the way our undo system

401
00:28:37,225 --> 00:28:42,388
works means like if you change one character of that, that big document, you have to make

402
00:28:42,428 --> 00:28:47,791
a complete copy of all those 200 pages of text to do the undo operation.

403
00:28:48,572 --> 00:28:51,253
So it gets pretty inefficient for that kind of data.

404
00:28:53,401 --> 00:28:58,943
But luckily that's not really the kind of data that we deal with a lot in Game Engine.

405
00:29:00,644 --> 00:29:02,244
But yeah, it's a drawback of the system.

406
00:29:03,765 --> 00:29:07,966
Another drawback I would say is that it's a pretty complex system because it needs to

407
00:29:08,026 --> 00:29:14,909
handle all these different things, prototyping, multithreading, and it also sits at the center

408
00:29:15,089 --> 00:29:15,749
of everything.

409
00:29:15,769 --> 00:29:18,610
Because the whole point of having...

410
00:29:19,930 --> 00:29:26,396
a single system that works with all the data is that everything will use it, so everything will

411
00:29:26,476 --> 00:29:33,642
work the same way. So there's really no way for other systems to opt out of using the truth.

412
00:29:34,322 --> 00:29:39,386
So if you wanted to write, for example, a text editor in the machinery, it would have to use

413
00:29:39,587 --> 00:29:44,911
the truth to be able to interop nicely with all these other systems. And so you would have to

414
00:29:45,071 --> 00:29:48,554
figure out, you could probably massage it some way to...

415
00:29:49,762 --> 00:29:55,105
find a way to use the truth to still represent your text object so that it would kind of work.

416
00:29:56,045 --> 00:30:01,787
But yeah, you can't really opt out of using this system. And it's also the complexity of

417
00:30:02,008 --> 00:30:06,990
the system makes it kind of scary to modify the truth and add new features to it because

418
00:30:07,110 --> 00:30:13,412
everything depends on it. The serialized data that's stored on disk depends on it. So you might,

419
00:30:13,813 --> 00:30:16,854
if you mess up, you might destroy people's saved projects.

420
00:30:17,654 --> 00:30:19,275
So it's kind of a scary system to change.

421
00:30:20,016 --> 00:30:24,319
You can't get out of it, even if you would like to, and it sits in the center of everything.

422
00:30:24,619 --> 00:30:28,862
I would say those are the drawbacks. That's sort of the price that you have to pay

423
00:30:29,682 --> 00:30:31,423
to get all this nice stuff for free.

424
00:30:34,325 --> 00:30:36,667
So next I'll talk a little about our tech stack.

425
00:30:37,608 --> 00:30:42,071
As I said, we really want to avoid being dependent on frameworks.

426
00:30:43,078 --> 00:30:45,299
So we built most of our tech stack ourselves.

427
00:30:46,980 --> 00:30:49,782
We also want to keep the tech stack itself

428
00:30:49,842 --> 00:30:50,762
as simple as possible.

429
00:30:51,182 --> 00:30:53,003
If you remember from the Stingray tech stack,

430
00:30:53,023 --> 00:30:56,105
we had a lot of different languages involved,

431
00:30:56,145 --> 00:30:58,786
C++ and C Sharp, Lua and JavaScript.

432
00:30:58,847 --> 00:31:03,149
And we also had like scripts written in Ruby and Python.

433
00:31:03,429 --> 00:31:05,670
So big ball of things.

434
00:31:06,471 --> 00:31:08,252
So for the machinery,

435
00:31:08,332 --> 00:31:09,873
we decided to change that completely

436
00:31:09,913 --> 00:31:10,813
and write everything in C.

437
00:31:12,154 --> 00:31:14,797
Even our little helper scripts are written in C2.

438
00:31:16,218 --> 00:31:19,261
The external libraries we use is very limited.

439
00:31:19,441 --> 00:31:21,243
We basically just use Vulkan.

440
00:31:21,263 --> 00:31:22,224
When it comes to the UI,

441
00:31:22,264 --> 00:31:24,406
we use Vulkan for rendering,

442
00:31:24,767 --> 00:31:27,049
and then we have the platform SDK that we need to

443
00:31:27,169 --> 00:31:30,132
access to get access to input events,

444
00:31:30,192 --> 00:31:31,874
like such as keyboard and mouse events.

445
00:31:32,474 --> 00:31:36,476
And then we have our own API abstractions on top of that,

446
00:31:36,796 --> 00:31:39,698
a 2D layer for doing 2D drawing, and an input layer,

447
00:31:39,738 --> 00:31:43,120
which is our abstraction over the OS input layer.

448
00:31:43,160 --> 00:31:46,802
So it's common for all operating systems.

449
00:31:47,302 --> 00:31:49,423
And then we have our UA system on top of that,

450
00:31:49,483 --> 00:31:51,144
which is an immediate mode UI.

451
00:31:51,744 --> 00:31:53,445
And then we build our applications

452
00:31:53,485 --> 00:31:54,806
and editors on top of that.

453
00:31:56,427 --> 00:31:59,508
So our 2D drawing library.

454
00:32:00,574 --> 00:32:06,189
It has regular 2D drawing operations such as strokeRect and fillRect, etc.

455
00:32:06,510 --> 00:32:08,635
Whatever you need for drawing the UI.

456
00:32:10,005 --> 00:32:12,346
But the way it's implemented is kind of interesting.

457
00:32:12,987 --> 00:32:18,410
We actually, all these drawing operations actually write data directly into a

458
00:32:18,851 --> 00:32:23,614
single vertex buffer and a single index buffer that will contain all the things

459
00:32:23,654 --> 00:32:27,336
that we want to draw in the UI, like rects and text and so on.

460
00:32:28,197 --> 00:32:31,819
And at the end, we just render these buffers with a single draw call.

461
00:32:33,301 --> 00:32:38,667
And if you want to learn more about that, I've got a link to our blog that kind of explains how we actually do this.

462
00:32:38,747 --> 00:32:46,877
But the end result is our drawing is really, really performant since it's just one draw call to draw the entire UI.

463
00:32:52,428 --> 00:32:56,069
Clipping is done by the pixel shader.

464
00:32:56,349 --> 00:32:57,989
So when we want to do clipping,

465
00:32:58,329 --> 00:33:00,870
we write our clip rects to the vertex buffer two,

466
00:33:01,990 --> 00:33:06,011
and then the pixel shader will refer to these clipping rects

467
00:33:06,372 --> 00:33:08,672
and clip the data against it as it's written.

468
00:33:08,712 --> 00:33:11,613
So we do no clipping on the CPU.

469
00:33:11,753 --> 00:33:13,994
It's all happening in the shaders,

470
00:33:14,034 --> 00:33:15,794
which makes that really efficient too.

471
00:33:18,863 --> 00:33:21,504
So overlays, this is kind of a neat trick,

472
00:33:21,544 --> 00:33:23,245
which is why I wanted to mention that.

473
00:33:24,366 --> 00:33:28,849
So when we're drawing something in an immediate mode UI,

474
00:33:28,909 --> 00:33:31,391
it will sort of appear in the order that it's drawn,

475
00:33:32,391 --> 00:33:35,513
but sometimes we have a desire to make stuff appear on top

476
00:33:35,653 --> 00:33:37,034
of stuff that will be drawn later.

477
00:33:37,315 --> 00:33:40,156
For example, if we have a pop-up menu or a context menu,

478
00:33:40,977 --> 00:33:44,279
we want that stuff to sort of float on top of the stuff

479
00:33:44,319 --> 00:33:45,220
that we draw after it.

480
00:33:46,508 --> 00:33:54,051
And the way we handle that, it's not really by doing some complicated layering procedure,

481
00:33:54,071 --> 00:33:54,631
stuff like that.

482
00:33:55,732 --> 00:33:58,573
We just keep two separate index buffers.

483
00:33:59,514 --> 00:34:03,996
So we have one index buffer that contains all sort of our main layer draw call.

484
00:34:04,296 --> 00:34:09,558
And then we have a separate index buffer, which we call the overlay index buffer, where

485
00:34:09,658 --> 00:34:11,639
all the pop-ups drawing happens.

486
00:34:12,787 --> 00:34:15,428
And then at the end, when we want to,

487
00:34:15,808 --> 00:34:18,068
so we just keep a single vertex buffer

488
00:34:18,148 --> 00:34:19,589
or a single primitive buffer.

489
00:34:19,849 --> 00:34:21,730
We call it vertex buffer, primitive buffer,

490
00:34:23,610 --> 00:34:26,511
where all the vertices go into,

491
00:34:27,472 --> 00:34:28,952
but we keep two separate index buffers.

492
00:34:28,992 --> 00:34:31,273
And then at the end, when we're ready to draw anything,

493
00:34:31,553 --> 00:34:33,774
we just concatenate these two index buffers.

494
00:34:34,094 --> 00:34:36,255
So we just put all the overlay stuff at the end

495
00:34:36,735 --> 00:34:37,455
after all the...

496
00:34:38,395 --> 00:34:43,538
the regular stuff has been drawn. And since the index buffer sort of contains all the actual

497
00:34:43,558 --> 00:34:50,562
stuff that's being drawn, by concatenating the index buffer at the end, the effect will be that

498
00:34:50,882 --> 00:34:56,385
all the overlay stuff appears on top of all the regular stuff. So it's kind of an interesting way

499
00:34:56,425 --> 00:35:02,689
that we use the fact that we're drawing everything straight to buffers to do this overlay effect.

500
00:35:03,509 --> 00:35:05,470
One thing to note here is that our

501
00:35:05,930 --> 00:35:11,692
Since we're drawing everything including our overlays with a single draw call our overlays can't actually protrude

502
00:35:11,872 --> 00:35:17,754
Outside your main window as they can in Windows for example so pop-up menu will always be clipped

503
00:35:18,414 --> 00:35:23,936
To the to the main window if you wanted to if you wanted to show it outside

504
00:35:23,956 --> 00:35:28,558
Your sort of main rendering when you have to spawn a new a new window to hold your pop-up

505
00:35:28,578 --> 00:35:30,438
so that's kind of a different technique, but

506
00:35:31,279 --> 00:35:37,903
This is an interesting way of doing it the way you can do it with just a single draw call, even the overlays.

507
00:35:40,244 --> 00:35:43,106
So our UI, as I said before, it's an immediate mode UI.

508
00:35:44,067 --> 00:35:49,510
So that means we're not explicitly creating or destroying UI objects.

509
00:35:49,670 --> 00:35:51,732
That's kind of what we mean by immediate mode.

510
00:35:52,472 --> 00:35:57,095
Instead, we have a single call to draw a control and handle the interaction.

511
00:35:58,016 --> 00:36:04,641
So, for a button, for instance, we have a draw call, we call it with a rectangle and

512
00:36:04,681 --> 00:36:09,465
a text, and it will draw a button with that text in that rectangle, and if the button

513
00:36:09,485 --> 00:36:14,609
was clicked in this frame, it will return true, and otherwise it will return false.

514
00:36:15,630 --> 00:36:19,293
So, with a checkbox, we call the checkbox...

515
00:36:20,794 --> 00:36:23,314
call a function to draw a checkbox, we pass in a flag.

516
00:36:23,795 --> 00:36:28,136
If the checkbox was toggled this frame,

517
00:36:28,896 --> 00:36:31,017
that flag will be toggled by the function.

518
00:36:31,878 --> 00:36:33,258
The important thing to know here about

519
00:36:33,318 --> 00:36:34,438
immediate mode UIs is that

520
00:36:34,799 --> 00:36:37,520
these buttons and checkboxes that we are drawing here,

521
00:36:37,700 --> 00:36:38,980
they're not saved anywhere.

522
00:36:39,320 --> 00:36:40,641
After we've called this function,

523
00:36:40,661 --> 00:36:42,621
there's no memory that there ever was

524
00:36:42,741 --> 00:36:46,203
a button or a checkbox in this place.

525
00:36:47,303 --> 00:36:49,044
So these controls that we're drawing,

526
00:36:49,084 --> 00:36:51,305
they don't really have any existence,

527
00:36:51,365 --> 00:36:53,686
no permanent existence like the next frame,

528
00:36:53,726 --> 00:36:55,687
we might draw a completely different set of controls.

529
00:36:57,428 --> 00:37:01,109
So the way we keep track of what's happening with

530
00:37:01,129 --> 00:37:05,231
the controls is that each control is given a unique ID.

531
00:37:05,291 --> 00:37:08,593
That way, we can keep track of which control the mouse is

532
00:37:08,633 --> 00:37:10,673
currently hovering over or which control

533
00:37:10,693 --> 00:37:12,434
the user is interacting with.

534
00:37:14,055 --> 00:37:17,379
when these controls don't really exist permanently.

535
00:37:19,461 --> 00:37:21,943
So pros and cons of this approach using immediate mode.

536
00:37:23,244 --> 00:37:28,029
I would say the big advantage is that you get a completely straightforward code flow.

537
00:37:28,630 --> 00:37:31,512
So if you want to know if you have like a bug somewhere,

538
00:37:31,933 --> 00:37:33,875
like a control is showing the wrong state,

539
00:37:35,436 --> 00:37:39,817
or a control is being too slow, you can just step through the code and see everything that's

540
00:37:39,837 --> 00:37:46,179
happening from the call to button to every part of the button being drawn and the function returning.

541
00:37:46,199 --> 00:37:52,441
You can see the performance of it, you can see any bugs in it, and you just go in there and do it.

542
00:37:52,881 --> 00:37:57,042
Whereas if you have a retained mode UI, which is like the alternative to immediate mode,

543
00:37:57,462 --> 00:38:02,884
You have some part of the code over here that is setting things up, creating controls, destroying controls.

544
00:38:03,264 --> 00:38:07,425
And then you have some part over here, which is probably deep inside the framework,

545
00:38:08,266 --> 00:38:12,147
where the interaction of the controller or the drawing of the controller actually happens.

546
00:38:12,447 --> 00:38:16,308
And these parts are kind of separate, but what you do over here affects what happens over here.

547
00:38:16,688 --> 00:38:20,049
So if you have performance problems, you kind of need to figure out,

548
00:38:20,770 --> 00:38:26,471
or a bug, you need to figure out how these different parts work together, which is way more complicated.

549
00:38:27,535 --> 00:38:31,797
Another advantage of immediate mode is that there's no need to synchronize state.

550
00:38:32,398 --> 00:38:37,821
So, so with retain mode, you have to have like events getting sent from controls,

551
00:38:37,861 --> 00:38:41,203
and then you have to process those events to change your, your data.

552
00:38:41,883 --> 00:38:43,864
Whereas here we're just drawing the data.

553
00:38:43,884 --> 00:38:47,166
When we draw the control, we pass in, when we draw the checks box,

554
00:38:47,206 --> 00:38:48,727
we pass in the current state.

555
00:38:49,387 --> 00:38:51,929
Um, so we send the data directly from the application.

556
00:38:51,949 --> 00:38:55,351
There's no need of processing events or anything like that.

557
00:38:56,277 --> 00:38:57,418
which I think is a big advantage.

558
00:38:58,378 --> 00:39:01,859
A disadvantage that people often bring up

559
00:39:01,959 --> 00:39:03,680
is that you have to redraw every frame

560
00:39:04,340 --> 00:39:06,081
and that that can be expensive,

561
00:39:07,061 --> 00:39:09,082
just redrawing the UI every frame.

562
00:39:10,342 --> 00:39:13,444
I think that's less of a concern for a 3D application,

563
00:39:13,484 --> 00:39:14,384
like a game editor,

564
00:39:14,824 --> 00:39:16,785
because you typically have a viewport in there.

565
00:39:17,485 --> 00:39:20,626
That viewport typically wants to render every frame anyway,

566
00:39:21,186 --> 00:39:22,727
at least if you have some kind of animation

567
00:39:22,767 --> 00:39:23,767
or anything going on there.

568
00:39:25,714 --> 00:39:28,656
So you're not really wasting any resources,

569
00:39:28,716 --> 00:39:30,818
but by also rendering the UI every frame.

570
00:39:32,039 --> 00:39:34,761
There are also ways to get around rendering every frame

571
00:39:34,841 --> 00:39:35,542
if you need to.

572
00:39:35,822 --> 00:39:37,944
For example, you can render only

573
00:39:37,984 --> 00:39:39,866
when you have actual input actions

574
00:39:40,026 --> 00:39:41,347
that would change the UI.

575
00:39:41,407 --> 00:39:43,069
So if the user moved the mouse

576
00:39:43,129 --> 00:39:45,511
or if the user pressed the keyboard,

577
00:39:47,152 --> 00:39:49,654
you re-render the UI and otherwise you don't do it.

578
00:39:50,984 --> 00:39:56,986
I actually find that with immediate mode UIs it's kind of easier to get good performance

579
00:39:57,546 --> 00:40:03,128
because you can easily match, you don't have to deal with anything that's not visible on

580
00:40:03,148 --> 00:40:03,548
the screen.

581
00:40:03,888 --> 00:40:08,150
For example, if you have a long list of items, like a thousand items in a list.

582
00:40:08,670 --> 00:40:19,358
It's very easy to like just figure out like which items are actually visible right now on the screen like in the rec that I'm drawing this list in right now what items can be seen.

583
00:40:19,898 --> 00:40:23,861
And then you just process those items, you don't have to care about anything else.

584
00:40:24,441 --> 00:40:32,747
Whereas when you're doing retain mode, like if you're doing retain mode in the default setup, if you have a list of 10,000 items, you have to somewhere create these 10,000 items.

585
00:40:34,634 --> 00:40:40,500
and that might be really expensive and the processing of those 10 000 items might be really expensive so to

586
00:40:41,890 --> 00:40:44,511
speed up performance, you might have to resort to some trick like,

587
00:40:44,891 --> 00:40:48,552
I have to use virtualized items where I don't actually create the items

588
00:40:48,832 --> 00:40:51,853
until they're really shown on screen or something like that.

589
00:40:52,754 --> 00:40:56,335
And you have to resort to tricks like that in order to get the

590
00:40:56,375 --> 00:40:59,976
performance back. Whereas with immediate mode,

591
00:41:01,216 --> 00:41:04,077
it's very easy to do this kind of clipping and just do...

592
00:41:04,957 --> 00:41:08,622
just do the processing for the thing that's actually shown on screen.

593
00:41:08,662 --> 00:41:12,808
So I find it a lot easier to get good performance out of an immediate mode UI.

594
00:41:13,189 --> 00:41:16,433
And then a lot easier to actually find where your performance is going to.

595
00:41:17,374 --> 00:41:20,098
But it is a new mindset and it can...

596
00:41:20,922 --> 00:41:28,109
it can take time to get used to and the big thing with a new mindset is that there aren't actually

597
00:41:28,930 --> 00:41:34,575
any objects to talk to because that's what you're used to from a retain mode. You have

598
00:41:34,915 --> 00:41:39,660
a button somewhere and you can sort of message this button and get it to do something but

599
00:41:40,881 --> 00:41:44,164
in the media mode that doesn't exist. So one example of that is

600
00:41:45,095 --> 00:41:48,457
For example, if the user selects copy in the main menu,

601
00:41:48,817 --> 00:41:51,318
if you have a retain mode UI,

602
00:41:51,578 --> 00:41:55,981
you would find out which is the current focused window

603
00:41:56,001 --> 00:41:57,742
or text field or whatever,

604
00:41:58,062 --> 00:42:01,464
and you would send that copy event to that object.

605
00:42:02,004 --> 00:42:04,066
Now you can't do that in retain mode,

606
00:42:04,126 --> 00:42:05,887
cause there's, or in immediate mode,

607
00:42:06,107 --> 00:42:08,028
cause there is no object to send it to.

608
00:42:08,068 --> 00:42:09,649
So how do you do things like that?

609
00:42:09,669 --> 00:42:13,231
You have to like sort of wrap your mind around it.

610
00:42:15,269 --> 00:42:23,273
This shows here the state synchronization, which is really nice.

611
00:42:24,073 --> 00:42:29,615
We have a number of different views here that are all showing the name of this object.

612
00:42:30,336 --> 00:42:34,417
And to sort of synchronize the name between these different views, we don't have to do anything,

613
00:42:34,817 --> 00:42:37,999
because all these views are drawing it straight from the data.

614
00:42:38,759 --> 00:42:58,796
So whenever it's changed in one view, it automatically gets updated into all these other views and they will automatically show this change without the need for processing any events or having any observer, observable patterns or anything like that, which I think is a great advantage of using this model.

615
00:43:02,673 --> 00:43:11,001
As an example of gotchas you run into and how you need to change your thinking when you're dealing with immediate mode,

616
00:43:13,023 --> 00:43:17,267
a problem that pops up sometimes is if you have overlapping objects.

617
00:43:17,908 --> 00:43:26,516
So suppose that we have a graph editor that's based on nodes and you can drag these nodes around.

618
00:43:27,626 --> 00:43:31,087
And suppose that you have two nodes, two overlapping nodes like this,

619
00:43:31,368 --> 00:43:33,408
and you want to process mouse clicks.

620
00:43:34,189 --> 00:43:38,491
If this was in retain mode, we would probably just loop over all these graph

621
00:43:38,571 --> 00:43:43,233
objects that would exist in the UI and check for mouse interactions.

622
00:43:43,673 --> 00:43:46,814
But we can't do that because the objects don't really exist.

623
00:43:47,234 --> 00:43:51,896
Instead, we sort of, we have to process these events as we are drawing each object.

624
00:43:52,855 --> 00:43:56,658
And the problem here is that when we're drawing node one here,

625
00:43:56,878 --> 00:43:58,219
which happens before node two,

626
00:43:58,620 --> 00:44:00,501
because we're drawing everything on order,

627
00:44:00,581 --> 00:44:02,383
so things we draw later appear on top.

628
00:44:02,863 --> 00:44:06,305
So when we're drawing node one here in our immediate mode,

629
00:44:06,706 --> 00:44:07,606
we don't know.

630
00:44:08,460 --> 00:44:10,300
that we're going to draw node two later.

631
00:44:10,820 --> 00:44:13,061
So node one can't just do a test like,

632
00:44:13,361 --> 00:44:16,462
well, if the mouse is inside my rectangle

633
00:44:16,542 --> 00:44:19,543
and the button is pressed, I should process this event.

634
00:44:20,183 --> 00:44:23,824
Because we might draw node two later on top of node one,

635
00:44:24,384 --> 00:44:26,805
in which case node two should actually

636
00:44:26,865 --> 00:44:28,185
process this mouse event.

637
00:44:28,965 --> 00:44:30,146
So how can we fix this?

638
00:44:30,746 --> 00:44:33,587
When you're like stuck in this retain mode object thinking,

639
00:44:33,627 --> 00:44:35,587
this might seem super, super tricky.

640
00:44:36,872 --> 00:44:40,315
But we can actually fix this by introducing a frame delay.

641
00:44:41,236 --> 00:44:45,900
So, the way we do it in the machinery...

642
00:44:46,767 --> 00:44:56,236
is that we keep track of which object the mouse is hovering over.

643
00:44:57,217 --> 00:45:01,401
So, and we do it, we assign it at the end of the frame.

644
00:45:01,902 --> 00:45:09,369
So, we check when we're drawing this node here, we check if the mouse is in the rect of the node.

645
00:45:09,970 --> 00:45:13,713
And if it is, we says, well, the hover for next frame should be our ID.

646
00:45:13,773 --> 00:45:17,796
Remember, our unique ID is how we identify this control in the UI.

647
00:45:18,977 --> 00:45:22,661
And then we check, well, if the hovered object is our object.

648
00:45:23,787 --> 00:45:26,148
and the button is down, then we should process the event.

649
00:45:26,869 --> 00:45:30,050
So let's see how this works when we have two nodes here like this.

650
00:45:30,630 --> 00:45:32,451
So in this case, the first node would go here.

651
00:45:32,871 --> 00:45:35,212
It would see, oh, the rectangle is in...

652
00:45:37,073 --> 00:45:38,094
the mouse is in myRect,

653
00:45:38,514 --> 00:45:39,995
and it would set nextHover,

654
00:45:40,015 --> 00:45:43,156
the hover that we should use for the next frame, to myID.

655
00:45:44,697 --> 00:45:48,078
Then we get to this check, is the hover my ID?

656
00:45:48,659 --> 00:45:49,459
And the button is down.

657
00:45:49,519 --> 00:45:52,480
The hover is not the ID of this control yet,

658
00:45:52,580 --> 00:45:54,821
because we only set the next hover variable,

659
00:45:54,881 --> 00:45:55,842
not the hover variable.

660
00:45:57,062 --> 00:45:58,203
Then it gets to node two.

661
00:45:58,403 --> 00:46:00,904
The node two text is the mouse in my rect,

662
00:46:01,164 --> 00:46:05,946
and it is, which means node two updates next hover

663
00:46:05,986 --> 00:46:07,687
to now point to node two.

664
00:46:07,747 --> 00:46:09,728
So it overwrites what node one did,

665
00:46:10,168 --> 00:46:11,609
and now next hover is node two.

666
00:46:12,249 --> 00:46:16,613
Then we get to the end of the frame, which means we assign nextHover over to hover.

667
00:46:17,034 --> 00:46:20,898
So hover is now assigned to node two, which means the next frame, when we go

668
00:46:20,918 --> 00:46:25,082
through this code again, node two will see, well, hover is actually my ID and

669
00:46:25,102 --> 00:46:28,004
the button is down, so I should process the event.

670
00:46:29,152 --> 00:46:33,273
So we had to do a frame delay here where the mouse click

671
00:46:33,993 --> 00:46:36,013
is not detected the first event

672
00:46:36,133 --> 00:46:38,374
or the hover is not detected the first frame,

673
00:46:38,714 --> 00:46:41,615
it only happens in the second frame.

674
00:46:42,035 --> 00:46:45,336
And this is basically the only way we can do this

675
00:46:45,436 --> 00:46:48,377
because since node one doesn't know

676
00:46:48,417 --> 00:46:49,617
what might be drawn after it,

677
00:46:49,657 --> 00:46:51,777
we have to go through an entire frame

678
00:46:51,857 --> 00:46:53,978
in order to discover all the things

679
00:46:54,498 --> 00:46:55,658
that can potentially be drawn.

680
00:46:56,059 --> 00:46:58,620
after it. So it's a different way of thinking.

681
00:47:01,521 --> 00:47:06,803
And lots of times it's a different way of thinking if you're used to retain mode. And

682
00:47:06,823 --> 00:47:12,286
I've seen a lot of people claim like, well, immediate mode UI seems great, but they can't do

683
00:47:12,346 --> 00:47:12,526
this.

684
00:47:13,566 --> 00:47:16,689
This can be a lot of things sometimes. It's like drag and drop sometimes

685
00:47:16,769 --> 00:47:21,313
It's like other stuff, and and I find that that's not true at all

686
00:47:21,994 --> 00:47:22,234
there's

687
00:47:23,155 --> 00:47:25,597
Always a way to do it in immediate mode

688
00:47:25,617 --> 00:47:30,742
But you have you might have to do a trick like that that like this like introducing a frame delay

689
00:47:31,642 --> 00:47:39,048
Like saving some data somewhere you have to retain some data like we're retaining the hover hover variable here

690
00:47:39,768 --> 00:47:44,612
But you don't have to retain the whole state of controls and stuff that you just have to figure out

691
00:47:45,112 --> 00:47:49,856
What kind of data you have to retain and do then do this sort of frame delay trick

692
00:47:49,916 --> 00:47:53,118
And then you can solve all these problems. It's my my experience

693
00:47:53,539 --> 00:47:58,883
I haven't run into anything that I wanted to do that that can't be done in in immediate mode

694
00:48:00,128 --> 00:48:03,499
So if someone says that to you, immediate mode can't do that.

695
00:48:03,760 --> 00:48:05,125
I encourage you to challenge that.

696
00:48:07,343 --> 00:48:12,125
There are lots of stuff that's really nice in immediate mode that's sort of problematic

697
00:48:12,165 --> 00:48:12,865
in retained mode.

698
00:48:14,005 --> 00:48:15,126
One thing is layouting.

699
00:48:15,706 --> 00:48:20,367
I really don't like layout managers that you have in lots of UI frameworks.

700
00:48:20,808 --> 00:48:22,728
I find them really painful to work with.

701
00:48:22,848 --> 00:48:30,111
Usually trying to get CSS to put controls in the right place is a pain in the ass.

702
00:48:30,951 --> 00:48:36,475
Whereas if we're working in immediate mode, we don't really need a layout manager to do any kind of layouting

703
00:48:37,175 --> 00:48:39,617
We're just working directly with the rectangles here

704
00:48:39,697 --> 00:48:45,401
So we can just split them ourselves and do whatever fancy algorithm we want to split it

705
00:48:45,662 --> 00:48:48,243
Like if we want two equally sized columns

706
00:48:49,784 --> 00:48:50,425
we don't have to

707
00:48:51,246 --> 00:48:52,226
like come up with some

708
00:48:52,927 --> 00:48:55,308
Way of tricking our layout manager into doing that

709
00:48:55,348 --> 00:48:59,251
We just split split the rect in half and we have two equally sized column

710
00:49:00,246 --> 00:49:02,767
So as an example of this here,

711
00:49:03,648 --> 00:49:05,108
we want to do a layout like this.

712
00:49:06,089 --> 00:49:08,350
We just split off a rectangle at the top

713
00:49:08,410 --> 00:49:09,870
to hold our header here.

714
00:49:10,551 --> 00:49:14,532
We split off another rect off that top rect

715
00:49:14,853 --> 00:49:15,813
for the search field.

716
00:49:16,553 --> 00:49:18,914
We split off a rect at the bottom to hold the footer.

717
00:49:19,515 --> 00:49:21,335
And then we use sort of a dynamic splitter

718
00:49:21,395 --> 00:49:25,877
to do this split between the two areas here.

719
00:49:26,918 --> 00:49:32,800
So this is super straightforward in my mind, super straightforward, super easy to understand,

720
00:49:32,860 --> 00:49:38,203
super easy to debug compared to trying to get like a layout manager to do this kind of behavior.

721
00:49:40,464 --> 00:49:44,546
Doing custom controls, super easy too and in immediate mode UI.

722
00:49:45,326 --> 00:49:49,728
To do a custom control, all you have to do is to implement the drawing of the custom control

723
00:49:50,128 --> 00:49:53,770
using all these draw commands, stroke rect, fill rect and so on

724
00:49:54,090 --> 00:49:57,912
and then implement sort of the input interactions like handle, mouse clicks.

725
00:49:58,532 --> 00:50:04,342
keyboard clicks and so on. And in fact there's no distinction really between built-in and custom

726
00:50:04,382 --> 00:50:09,791
controls. Our built-in controls are written in exactly the same way as a custom control would be.

727
00:50:11,734 --> 00:50:17,099
And just to show you an example, this is how this drag number control would be implemented.

728
00:50:17,599 --> 00:50:23,185
I won't go through this in detail because it's a bunch of code, but just to show that

729
00:50:24,486 --> 00:50:29,210
it doesn't need a lot of code to implement something like this, you can do it pretty easily.

730
00:50:30,930 --> 00:50:36,995
So in summary, having the full control of the tech stack like this, it's really nice.

731
00:50:37,515 --> 00:50:39,557
It reduces the complexity a lot.

732
00:50:39,877 --> 00:50:41,979
We don't have to worry about framework changes.

733
00:50:43,059 --> 00:50:44,901
We can step through and debug anything.

734
00:50:45,862 --> 00:50:49,705
There's the same language and APIs used everywhere in the engine.

735
00:50:50,165 --> 00:50:54,889
So there's no artificial barriers separating tools programmers from engine programmers.

736
00:50:55,349 --> 00:50:59,192
Everyone can go in and do anything pretty much, which I like a lot.

737
00:51:01,237 --> 00:51:06,479
The cons of doing things this way, building your own framework, you have to start from scratch.

738
00:51:07,000 --> 00:51:10,602
Like we started with nothing and then we implemented drawing primitives.

739
00:51:11,242 --> 00:51:16,665
So that's really starting from scratch. I would say that's about six man months of work or

740
00:51:16,705 --> 00:51:20,427
something before you're up and running with like a UI that you can actually use.

741
00:51:21,362 --> 00:51:24,665
But we found that that initial cost is soon recuperated,

742
00:51:25,065 --> 00:51:29,689
just in how much time saving we have from not having to deal

743
00:51:29,709 --> 00:51:31,110
with wrestling with the framework,

744
00:51:31,170 --> 00:51:33,291
like wrestling with an external framework

745
00:51:33,331 --> 00:51:36,474
and trying to force it to do what you needed to do.

746
00:51:37,114 --> 00:51:39,556
You could start with an existing immediate mode UI,

747
00:51:39,596 --> 00:51:42,398
like Dare in GUI, for example.

748
00:51:43,359 --> 00:51:45,400
That would be a way of getting started way quicker.

749
00:51:45,420 --> 00:51:47,562
So that might be a good choice for you,

750
00:51:47,622 --> 00:51:49,884
depending on what your situation looks like.

751
00:51:51,082 --> 00:51:56,546
Another con that you might not think about is that doing things your own,

752
00:51:56,866 --> 00:52:00,229
like implementing everything, your own framework, actually requires

753
00:52:00,289 --> 00:52:01,410
a lot of design decisions.

754
00:52:01,870 --> 00:52:05,213
When you use an existing framework, everything is sort of decided for you.

755
00:52:05,253 --> 00:52:07,574
You have a checkbox and it works the way it should work.

756
00:52:08,235 --> 00:52:11,037
Whereas when you write everything yourself, you kind of have to sit down

757
00:52:11,077 --> 00:52:14,139
and think, well, how do I want a checkbox to work?

758
00:52:14,822 --> 00:52:18,425
How does it make sense for a menu to work and so on?

759
00:52:18,445 --> 00:52:23,789
You have to make all these design decisions, which depending on whether

760
00:52:23,909 --> 00:52:27,832
that's something you're attracted to doing or not attracted to doing, that

761
00:52:27,912 --> 00:52:29,574
might not be the right decision for you.

762
00:52:30,174 --> 00:52:31,455
But you should be aware of that.

763
00:52:31,815 --> 00:52:35,778
There's a fair amount of thinking and work that goes into that.

764
00:52:36,726 --> 00:52:44,772
And also, as I said, it kind of requires to rewire your brain a lot to think about UI this way, to do immediate mode.

765
00:52:47,935 --> 00:52:50,797
So the final thing we're doing here, generating UIs.

766
00:52:53,005 --> 00:52:55,908
As I said before, the idea here is we want to reduce the work.

767
00:52:55,948 --> 00:52:58,792
We don't want to create UIs for everything.

768
00:52:58,812 --> 00:53:01,696
We want to drive that automatically somehow.

769
00:53:02,336 --> 00:53:04,599
A typical example of that is the properties panels.

770
00:53:05,180 --> 00:53:10,086
And I think this is something that a lot of editors would do.

771
00:53:11,307 --> 00:53:13,409
they would drive their property panel,

772
00:53:13,749 --> 00:53:15,811
they wouldn't implement it for each object,

773
00:53:15,871 --> 00:53:17,232
it would drive it from data.

774
00:53:18,353 --> 00:53:19,174
That's what we do.

775
00:53:19,834 --> 00:53:22,657
We use a property panel as our default object editor.

776
00:53:23,918 --> 00:53:26,200
The way it works is that we loop over

777
00:53:26,420 --> 00:53:29,422
all the properties of an object and we

778
00:53:29,482 --> 00:53:32,004
draw an appropriate control for each of these properties.

779
00:53:32,925 --> 00:53:35,007
For a Boolean, it might be a checkbox,

780
00:53:35,067 --> 00:53:37,369
for a string, it might be a text box, and so on.

781
00:53:38,727 --> 00:53:41,931
And now using the default control might not work for everything.

782
00:53:42,311 --> 00:53:45,976
For example, things like color, you might want to have a custom control for that.

783
00:53:47,698 --> 00:53:48,539
So how do we do that?

784
00:53:49,040 --> 00:53:53,485
And we get all these properties from the truth, by the way, since we

785
00:53:53,505 --> 00:53:55,268
have a standard data model for that.

786
00:53:56,963 --> 00:54:00,486
So to handle custom properties, we use a system that we called Aspects.

787
00:54:01,427 --> 00:54:05,569
And basically it's just a callback, a function callback identified by an ID.

788
00:54:07,190 --> 00:54:11,713
So each system can define an aspect like this.

789
00:54:12,274 --> 00:54:18,538
So the property, the property tab has defined a callback that's identified by

790
00:54:18,598 --> 00:54:20,619
an aspect called AspectCustomProperties.

791
00:54:21,300 --> 00:54:27,206
So we can if we want an object in the truth to be drawn in a special way in the property panel

792
00:54:27,486 --> 00:54:30,949
all it has to do is to implement this aspect and

793
00:54:31,370 --> 00:54:33,692
Then when we go through all the objects here

794
00:54:33,732 --> 00:54:35,514
we check them or does this object have a

795
00:54:35,974 --> 00:54:42,360
special aspect for interacting with the property panel and if it does that aspect will be called and if it doesn't it will get the

796
00:54:42,641 --> 00:54:43,321
default panel

797
00:54:44,787 --> 00:54:47,809
So this is an example of that for a vector three.

798
00:54:48,229 --> 00:54:49,710
Again, I won't go through the code.

799
00:54:49,770 --> 00:54:53,012
It's just showing that it's pretty easy to do this.

800
00:54:53,552 --> 00:54:56,434
And the nice thing about this is that every control,

801
00:54:57,214 --> 00:55:00,716
everything gets a UI by default

802
00:55:00,836 --> 00:55:02,797
because we map the standard controls to the UI,

803
00:55:03,717 --> 00:55:05,218
but then you can go in and customize it

804
00:55:05,238 --> 00:55:06,959
with a special control if you really need to.

805
00:55:08,440 --> 00:55:12,323
But we take this approach of using generated UIs even further.

806
00:55:12,343 --> 00:55:13,945
It's not just for properties.

807
00:55:14,786 --> 00:55:16,427
We use it for previews, for instance.

808
00:55:17,448 --> 00:55:19,850
So this is controlled by an aspect again.

809
00:55:20,270 --> 00:55:23,053
So any object that want to be able to be previewed,

810
00:55:23,353 --> 00:55:26,756
just adds a preview aspect to the object type in the truth.

811
00:55:27,416 --> 00:55:31,537
And then that preview aspect takes care of drawing the object in this preview window,

812
00:55:32,197 --> 00:55:35,257
spawning entities, drawing UI, playing sounds and so on,

813
00:55:35,277 --> 00:55:37,958
whatever is needed to preview that kind of object.

814
00:55:39,698 --> 00:55:41,038
We use the same thing for trees.

815
00:55:42,239 --> 00:55:44,819
So by default here, we would render,

816
00:55:45,019 --> 00:55:46,819
by default to render a tree view of an object,

817
00:55:46,839 --> 00:55:48,980
we would just render all sub-objects as children.

818
00:55:49,460 --> 00:55:51,380
But if an object wants to customize that,

819
00:55:51,420 --> 00:55:56,261
it can implement the tree view aspect and do its own custom tree drawing.

820
00:55:57,606 --> 00:56:01,109
So here's an example of a full UI using all of this.

821
00:56:02,310 --> 00:56:04,653
So this is our animation state machine editor.

822
00:56:05,033 --> 00:56:07,776
As you can see, there's a lot of pieces of UI here,

823
00:56:08,096 --> 00:56:10,558
but all of these pieces are actually standardized.

824
00:56:10,878 --> 00:56:11,939
So we have a tree view here.

825
00:56:12,180 --> 00:56:13,901
That's our standardized tree view control.

826
00:56:13,921 --> 00:56:17,685
We didn't implement anything special for the state machine.

827
00:56:18,626 --> 00:56:22,248
We have a GraphView, that's our standard GraphView control,

828
00:56:22,789 --> 00:56:26,712
and the state machine is just implementing an aspect of it

829
00:56:26,792 --> 00:56:30,394
to define how its objects get represented in this GraphView.

830
00:56:31,195 --> 00:56:32,136
Same with the properties,

831
00:56:32,176 --> 00:56:33,477
so standard properties control,

832
00:56:33,977 --> 00:56:35,779
and we have a preview control here,

833
00:56:35,799 --> 00:56:38,821
which is our standard preview window as I mentioned earlier.

834
00:56:39,361 --> 00:56:42,564
This way, we can put together a really complex UI by

835
00:56:42,604 --> 00:56:46,286
just reusing all these different parts, which is really nice.

836
00:56:49,227 --> 00:56:50,268
So, conclusion here.

837
00:56:51,208 --> 00:56:54,772
I would say that creating UIs in this way, in this system,

838
00:56:55,212 --> 00:56:56,193
feels a lot faster.

839
00:56:56,233 --> 00:56:58,555
We no longer feel blocked by UI tasks.

840
00:56:58,956 --> 00:57:02,159
And in fact, we could build our entire engine with the UI,

841
00:57:02,199 --> 00:57:05,402
with the editor and everything, by two people in two years,

842
00:57:06,403 --> 00:57:08,084
which I think is really good.

843
00:57:09,425 --> 00:57:14,751
Our data model, it's awesome to get all this stuff for free, but it's also a little bit

844
00:57:14,772 --> 00:57:19,397
scary how it's a central piece of technology that's kind of complex and it's getting more

845
00:57:19,457 --> 00:57:22,861
complex with every piece of functionality that gets added to it.

846
00:57:23,581 --> 00:57:27,726
I think using aspects the way we are is a really great way of customizing object behavior.

847
00:57:27,746 --> 00:57:29,788
I definitely recommend that.

848
00:57:30,951 --> 00:57:33,652
Implementing things yourself is a lot of work.

849
00:57:34,992 --> 00:57:39,334
Functional design, as I said, but I think the payoff is great.

850
00:57:39,414 --> 00:57:40,775
Not being dependent on frameworks,

851
00:57:41,175 --> 00:57:43,155
being able to debug and profile everything,

852
00:57:43,195 --> 00:57:44,096
and being in control.

853
00:57:45,696 --> 00:57:47,477
I would say that we are missing some features

854
00:57:47,517 --> 00:57:49,638
that you would find in a full-fledged toolkit.

855
00:57:50,058 --> 00:57:52,739
We don't have support for right-to-left text,

856
00:57:52,799 --> 00:57:54,459
for instance, for localization.

857
00:57:55,400 --> 00:58:01,703
But I don't worry so much that we don't have a ton of features, as long as these

858
00:58:01,763 --> 00:58:05,844
features would be easy to add when we need them.

859
00:58:06,445 --> 00:58:10,446
So at the point where we start needing this, I'm pretty sure we could implement

860
00:58:10,526 --> 00:58:14,828
it easily, that's the whole point of keeping things simple and being agile.

861
00:58:15,168 --> 00:58:20,611
And I think there's a danger of having lots of features, but having a complex

862
00:58:20,651 --> 00:58:24,933
system that is so complex that you don't actually have time to use these features.

863
00:58:25,653 --> 00:58:32,659
As an example, in Stingray, we used web technology and stuff to be platform independent, but

864
00:58:32,699 --> 00:58:35,541
we never had time to support any other platform than Windows.

865
00:58:36,461 --> 00:58:43,027
And we had right-to-left text that we needed, but we never had time to really start on localization

866
00:58:43,327 --> 00:58:44,348
of the editor at all.

867
00:58:44,948 --> 00:58:51,053
So I think you have to be really careful about how you're spending your time.

868
00:58:51,673 --> 00:58:51,933
And it's...

869
00:58:52,370 --> 00:58:57,973
more important to be simple and to be agile than to have features that you're not using yet.

870
00:58:58,913 --> 00:59:04,477
And all in all, we're really super happy with the way things are going and the speed with which we've

871
00:59:04,497 --> 00:59:10,700
been able to develop UIs and it feels fun to make tools and UIs for the engine, which it

872
00:59:10,720 --> 00:59:14,182
didn't really do before and I'm really pleased and happy with that.

873
00:59:15,893 --> 00:59:18,615
So this would be the time where I would ask for questions.

874
00:59:19,315 --> 00:59:23,437
I can't really do that now since we're in lockdown mode.

875
00:59:24,998 --> 00:59:29,960
But if you have any questions, tweet me at my Twitter handle there.

876
00:59:30,720 --> 00:59:35,062
We have a podcast, an R Machinery podcast that I recommend you can listen to if you

877
00:59:35,082 --> 00:59:36,663
want to find out more stuff that we're doing.

878
00:59:37,103 --> 00:59:40,364
We also have a blog available on our website, rmachinery.com.

879
00:59:41,691 --> 00:59:48,369
and feel happy to read that and contact us if you're interested in looking at the onion or using it.

