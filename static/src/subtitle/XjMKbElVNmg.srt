1
00:00:06,387 --> 00:00:15,815
Hey everyone, I'm Dave Hunt. I'm a technical artist, and this presentation is for the GDC 2020 Technical Arts Summit, which is virtual this year.

2
00:00:15,815 --> 00:00:18,297
I do hope everyone is staying safe and healthy out there.

3
00:00:18,297 --> 00:00:23,061
Here we're going to talk about control rigs.

4
00:00:23,061 --> 00:00:29,486
Now this is the thing that helps animators create animation content.

5
00:00:29,903 --> 00:00:36,707
As a technical artist in my career, I've spent a lot of time building these kind of control rigs for animators in game productions.

6
00:00:36,707 --> 00:00:43,570
So, while the job of the control rig is to help it be easier and faster for animators to create content,

7
00:00:43,570 --> 00:00:49,793
it actually turns out, as we take a look at how this fits into production pipelines,

8
00:00:49,793 --> 00:00:52,775
that it actually introduces a lot of inefficiencies at times

9
00:00:52,775 --> 00:00:57,897
that we may not always be aware of because we're just so used to it working the way it usually does.

10
00:00:59,286 --> 00:01:02,347
So let's take a look at how this is often done

11
00:01:02,347 --> 00:01:04,268
and how the control rigs are built

12
00:01:04,268 --> 00:01:05,748
inside of animation productions.

13
00:01:05,748 --> 00:01:09,349
And let's pay attention to how it actually works

14
00:01:09,349 --> 00:01:10,590
when iteration happens,

15
00:01:10,590 --> 00:01:13,651
because we all know how important iteration

16
00:01:13,651 --> 00:01:15,852
is for creating fun gameplay.

17
00:01:15,852 --> 00:01:20,153
So out of this, let's build a list of requirements

18
00:01:20,153 --> 00:01:23,294
for the control rig that ideally we would like to support

19
00:01:23,294 --> 00:01:26,615
so that we can keep a nice, good iteration cycle

20
00:01:26,615 --> 00:01:28,616
for our creative people on the team.

21
00:01:30,887 --> 00:01:35,368
We do have a pretty good solution here that we've found and that I'd like to share today.

22
00:01:35,368 --> 00:01:43,391
And I want to share how this works in general terms so that anyone could implement this in any tools context that they might be building control rigs in.

23
00:01:43,391 --> 00:01:47,852
And then we'll show how we've implemented this in Unity.

24
00:01:47,852 --> 00:01:51,754
And there's some cool new features available which I'll describe how they work.

25
00:01:51,754 --> 00:01:58,556
For these examples, I'll be using the digital human character from The Heretic.

26
00:01:58,556 --> 00:02:00,797
This is the real-time film made by Unity.

27
00:02:01,380 --> 00:02:08,526
And just wanted to make sure to say that this content example in this presentation is not the film itself.

28
00:02:08,526 --> 00:02:14,111
For that, please check out this link, and you can see it on the Unity website.

29
00:02:14,111 --> 00:02:16,994
Alright, let's get started.

30
00:02:16,994 --> 00:02:22,839
So, what do we mean when we're talking about Freeform animation workflows?

31
00:02:22,839 --> 00:02:26,543
I'll just use an example of laying out a 3D animated scene.

32
00:02:27,134 --> 00:02:31,935
So we might start out with a very simple environment that's blocked in with just basic cubes.

33
00:02:31,935 --> 00:02:36,297
And then we can throw in some motion capture of our character walking.

34
00:02:36,297 --> 00:02:41,058
And this lets us immediately start to make creative choices about the camera angles

35
00:02:41,058 --> 00:02:45,879
and even lighting and scene composition about how we want to tell the story.

36
00:02:45,879 --> 00:02:51,661
So in the next iteration we might get more specific about the environment.

37
00:02:51,661 --> 00:02:56,062
So here we've brought in more of a broken concrete wall to be the environment.

38
00:02:56,777 --> 00:02:58,238
But notice our character is hitting his head.

39
00:02:58,238 --> 00:03:02,719
And wouldn't that be nice if I could put on a control rig right there in the scene

40
00:03:02,719 --> 00:03:06,640
and make some keyframe modifications so that he ducks underneath that wall?

41
00:03:06,640 --> 00:03:12,081
And so once that's done, it can be baked down to the skeleton

42
00:03:12,081 --> 00:03:15,322
and saved as a new animation clip.

43
00:03:15,322 --> 00:03:18,243
Well, as it often happens in productions, they want to iterate.

44
00:03:18,243 --> 00:03:23,145
So here we might have added some new concrete to the wall to break up that silhouette.

45
00:03:23,145 --> 00:03:25,725
And now our character is hitting his head again.

46
00:03:26,254 --> 00:03:30,137
So in this case we need to add a full body control rig.

47
00:03:30,137 --> 00:03:36,642
And I can make some keyframe animation edits so the character reaches out and holds on to the wall while he crouches underneath.

48
00:03:36,642 --> 00:03:40,546
Alright, so now that's looking how we want,

49
00:03:40,546 --> 00:03:43,448
we can save out this new custom animation clip,

50
00:03:43,448 --> 00:03:44,469
and that's ready to go.

51
00:03:44,469 --> 00:03:48,973
In this example, all of these edits were done right here in the scene,

52
00:03:48,973 --> 00:03:53,637
where you have access to all the final rendering output, all the lighting and shading.

53
00:03:54,352 --> 00:03:58,013
If there's anything like cloth simulation or effects, you can see it all right there,

54
00:03:58,013 --> 00:04:01,374
and it actually makes it really nice and direct to do your edits right there.

55
00:04:01,374 --> 00:04:08,336
So why do we call it freeform animation? That's because you can go back and forth

56
00:04:08,336 --> 00:04:12,597
between this loop as much as you want, where we're transferring motion from a skeleton

57
00:04:12,597 --> 00:04:13,758
onto the control rig.

58
00:04:13,758 --> 00:04:17,039
That's where it's easier to make these edits,

59
00:04:17,039 --> 00:04:20,520
and when you're done you can bake it back down to the skeleton,

60
00:04:20,520 --> 00:04:23,981
where it might be more an optimal playback format for runtime.

61
00:04:25,265 --> 00:04:32,708
Of course, if you want to, you can leave those rig constraints active so they can do runtime rigging.

62
00:04:32,708 --> 00:04:37,851
So I'll get into more detail about exactly how this works, but I wanted to give this quick definition up front.

63
00:04:37,851 --> 00:04:42,493
Here's where you can learn more about this.

64
00:04:42,493 --> 00:04:48,515
My good friend Rick Lico, my former colleague, has been a real pioneer of working this way,

65
00:04:48,515 --> 00:04:51,296
and he was innovating these kinds of techniques

66
00:04:51,296 --> 00:04:54,698
even before he came to work at Bungie with me more than 10 years ago.

67
00:04:56,087 --> 00:04:59,809
And these days he's very active with training and education.

68
00:04:59,809 --> 00:05:04,952
He really cares about helping animators find more efficient ways of working.

69
00:05:04,952 --> 00:05:06,453
So in 2018 he did a great GDC talk.

70
00:05:06,453 --> 00:05:11,797
Later that year he joined me at SIGGRAPH for a presentation

71
00:05:11,797 --> 00:05:16,140
where he went into deeper explanation of the technical pipelines and how they work.

72
00:05:16,140 --> 00:05:23,144
And now these days he's opened his new online animation class called Animation Sherpa.

73
00:05:23,144 --> 00:05:25,085
So here's where you can find out all about that.

74
00:05:25,722 --> 00:05:26,803
I highly recommend it.

75
00:05:26,803 --> 00:05:32,545
So let's take a look at the basic animation pipeline

76
00:05:32,545 --> 00:05:37,248
where we would normally set up character creation

77
00:05:37,248 --> 00:05:38,508
for any kind of 3D animation.

78
00:05:38,508 --> 00:05:42,610
Usually it starts with some concept art and designing

79
00:05:42,610 --> 00:05:44,051
and then you do some modeling

80
00:05:44,051 --> 00:05:46,112
and then rigging comes along.

81
00:05:46,112 --> 00:05:49,113
This is where we're going to focus our presentation today.

82
00:05:49,113 --> 00:05:53,095
And rigging pretty much takes place in these two parts

83
00:05:53,095 --> 00:05:53,735
where...

84
00:05:54,463 --> 00:05:57,164
First you need to define the deformations and the skeleton.

85
00:05:57,164 --> 00:06:00,866
And then it's the control rig that gets built.

86
00:06:00,866 --> 00:06:05,687
And this is where the animators base all their content.

87
00:06:05,687 --> 00:06:10,249
Setting keyframes here, making poses, and creating animation.

88
00:06:10,249 --> 00:06:17,791
So first off let's take a look at who will be using this.

89
00:06:17,791 --> 00:06:21,493
In my experience, there's no two animators that are the same.

90
00:06:21,493 --> 00:06:23,753
There's a lot of different backgrounds they come from.

91
00:06:24,410 --> 00:06:27,411
And this results in very different working styles.

92
00:06:27,411 --> 00:06:30,032
Where it's really great to have this variety

93
00:06:30,032 --> 00:06:32,693
because there's a lot of different advantages of different approaches

94
00:06:32,693 --> 00:06:36,915
whether you're more a 2D drawing or a technical animator

95
00:06:36,915 --> 00:06:38,355
or working with motion capture.

96
00:06:38,355 --> 00:06:42,597
There's a lot of different kind of diversity that comes from this

97
00:06:42,597 --> 00:06:46,458
which is great for getting different kinds of motion that's needed for a game.

98
00:06:46,458 --> 00:06:50,739
So we really want the control rig to be able to support all these different ways of working.

99
00:06:50,739 --> 00:06:53,680
In an ideal world, it's going to give them the optimal...

100
00:06:53,928 --> 00:06:58,169
way of interacting with that rig to get a fast and efficient

101
00:06:58,169 --> 00:07:03,651
creation of their creative vision.

102
00:07:03,651 --> 00:07:05,811
And now let's take a look at what they will be creating.

103
00:07:05,811 --> 00:07:10,372
For example in a game, an action game, you might have a player character

104
00:07:10,372 --> 00:07:13,453
that has to do all these different kinds of actions through the game.

105
00:07:13,453 --> 00:07:17,154
And each one of these categories might represent

106
00:07:17,154 --> 00:07:20,775
dozens or even hundreds of animations that goes into creating the full

107
00:07:20,775 --> 00:07:22,856
motion set for the character to go through the game.

108
00:07:24,074 --> 00:07:25,795
And they're all very different actually.

109
00:07:25,795 --> 00:07:29,718
So if we zoom in and look at, for example, first person animation,

110
00:07:29,718 --> 00:07:35,101
where the camera's really close to the hands as they're contacting a prop,

111
00:07:35,101 --> 00:07:38,223
and it's very dynamic because it changes all the time.

112
00:07:38,223 --> 00:07:40,525
Like what's controlling what, and how it needs to move,

113
00:07:40,525 --> 00:07:45,208
and it needs to be very nice and smooth and high fidelity when it's that close to the camera.

114
00:07:45,208 --> 00:07:48,490
So that's a very specific set of needs.

115
00:07:48,490 --> 00:07:50,852
Let's compare that, for example, to locomotion.

116
00:07:52,180 --> 00:07:55,442
And here we can see the characters more at a distance,

117
00:07:55,442 --> 00:07:59,343
and the hands are moving free in this case.

118
00:07:59,343 --> 00:08:02,745
It's more of a whole full-body mechanic that we're looking at,

119
00:08:02,745 --> 00:08:05,726
rather than a detailed close-up interaction.

120
00:08:05,726 --> 00:08:08,187
So really the needs here are very different

121
00:08:08,187 --> 00:08:12,029
for what the Control Rig will need to be able to do for the animator

122
00:08:12,029 --> 00:08:16,091
to get a really nice and efficient way of working.

123
00:08:16,091 --> 00:08:20,873
Here's yet another example, this environment world interaction that we talked about earlier.

124
00:08:20,873 --> 00:08:21,873
So in this example...

125
00:08:22,497 --> 00:08:26,298
Objects are introduced that we're not even there to begin with.

126
00:08:26,298 --> 00:08:31,099
How could we possibly plan for all of this ahead of time?

127
00:08:31,099 --> 00:08:35,020
And most importantly, the Control Rig really needs to

128
00:08:35,020 --> 00:08:37,881
avoid counter-animation in all of these different situations.

129
00:08:37,881 --> 00:08:43,002
So counter-animation is a really important concept

130
00:08:43,002 --> 00:08:46,123
to understand here. So we'll take a look at this example.

131
00:08:46,123 --> 00:08:50,744
Counter-animation is really any time an animator has to fight against the rig

132
00:08:50,744 --> 00:08:52,344
in order to get their desired behavior.

133
00:08:53,025 --> 00:08:59,988
So for example with this prop, he's holding a gun, and in most cases both hands are going to follow that gun wherever it goes.

134
00:08:59,988 --> 00:09:04,671
So here we want the control rig to act as if these hands are child of the gun.

135
00:09:04,671 --> 00:09:09,953
And that's really great for the times when it's in that state.

136
00:09:09,953 --> 00:09:11,354
But how about here when it's reloading?

137
00:09:11,354 --> 00:09:15,515
He takes the hand away, and now it needs to move free.

138
00:09:15,515 --> 00:09:18,217
But if I haven't changed it, it's going to still behave like a child.

139
00:09:19,211 --> 00:09:21,952
So that makes this movement, every time I move the hand,

140
00:09:21,952 --> 00:09:25,594
I have to fight against how its parent is working.

141
00:09:25,594 --> 00:09:28,615
And that is what we call counter animation.

142
00:09:28,615 --> 00:09:31,356
In this case, if animators don't have a way of switching it,

143
00:09:31,356 --> 00:09:34,557
then every single frame, they need to correct it and make

144
00:09:34,557 --> 00:09:35,217
it look right.

145
00:09:35,217 --> 00:09:38,018
And I've even seen people pull out a whiteboard erase marker

146
00:09:38,018 --> 00:09:39,939
and draw on their computer monitor

147
00:09:39,939 --> 00:09:42,200
to make sure it's a smooth arc.

148
00:09:42,200 --> 00:09:43,381
And it's just very inefficient.

149
00:09:43,381 --> 00:09:45,021
And after they're done with that,

150
00:09:45,021 --> 00:09:46,982
it's even harder to make changes.

151
00:09:46,982 --> 00:09:47,522
So that's.

152
00:09:47,963 --> 00:09:52,345
not what we want and the control rig ideally needs to help us avoid this situation.

153
00:09:52,345 --> 00:09:59,789
So one of the ways people try and solve this often is by building what might be called an uber rig.

154
00:09:59,789 --> 00:10:03,030
And this is a big monolithic

155
00:10:03,030 --> 00:10:07,132
file that attempts to plan for all possible situations and make

156
00:10:07,132 --> 00:10:11,655
all the switches that Animator can change in a given situation.

157
00:10:11,655 --> 00:10:16,797
But it really isn't very possible to actually do this in my opinion.

158
00:10:17,859 --> 00:10:25,945
For one, it's really complex, it's slow to work with, it's hard for animators to figure out exactly what will control what.

159
00:10:25,945 --> 00:10:33,750
And it takes a very long time for rigging people to build too, and the longer it takes to build, the more you're blocking creative progress.

160
00:10:33,750 --> 00:10:35,832
So we don't want that.

161
00:10:35,832 --> 00:10:40,195
And I actually even doubt if it's really even possible to think of everything in advanced.

162
00:10:40,195 --> 00:10:44,098
I think that in animation, you'll always be able to find some new situation.

163
00:10:44,812 --> 00:10:47,532
where you need to have a new solution for the rig.

164
00:10:47,532 --> 00:10:54,294
So let's just take a look at this and imagine how it works in a production.

165
00:10:54,294 --> 00:10:59,975
So let's say a rigging person has taken a whole bunch of time to build this

166
00:10:59,975 --> 00:11:03,436
control rig by hand and save a file on disk

167
00:11:03,436 --> 00:11:07,877
that then gets copied out to all these hundreds of animations.

168
00:11:07,877 --> 00:11:11,398
And, uh oh, what happens now when it's time to do iteration?

169
00:11:11,398 --> 00:11:11,638
So.

170
00:11:12,058 --> 00:11:15,961
As all the animations are playing out, it's real common to see

171
00:11:15,961 --> 00:11:20,084
okay, well, it doesn't look as good as we want in the given pose

172
00:11:20,084 --> 00:11:23,807
or maybe the game designers say we're not getting the desired read of the

173
00:11:23,807 --> 00:11:28,950
player experience, so we need to make some changes here.

174
00:11:28,950 --> 00:11:33,994
In an often cases, we're simply fixing the deform rig, so we're adding new bones

175
00:11:33,994 --> 00:11:37,377
that are procedurally controlled to automatically follow other bones in

176
00:11:37,377 --> 00:11:40,679
the skeleton. And these might be called fix up bones,

177
00:11:40,679 --> 00:11:41,820
twist bones,

178
00:11:42,211 --> 00:11:46,993
post-correction. So what we'll do in that case is need to add them to the rig

179
00:11:46,993 --> 00:11:52,295
and then push out updates to all the files where the rig is used in these animations.

180
00:11:52,295 --> 00:11:57,237
So let's plan for this in advance and

181
00:11:57,237 --> 00:12:03,019
make it a requirement that this control rig needs to be able to take updates.

182
00:12:03,019 --> 00:12:07,801
Okay, and there's a lot of common ways this is solved, and one of them is file referencing.

183
00:12:07,801 --> 00:12:11,582
That can be really nice and fast where all of these read from a source file.

184
00:12:12,113 --> 00:12:19,540
that every time an animation is opened, it brings in the latest version of that new source file control rig.

185
00:12:19,540 --> 00:12:24,965
But one of the problems with that is it locks down the hierarchy,

186
00:12:24,965 --> 00:12:29,789
so it's now read-only, and animators really can't change anything on the control rig at that point.

187
00:12:29,789 --> 00:12:34,473
So they're very stuck now with whatever choices a rigging person has made.

188
00:12:36,262 --> 00:12:40,545
There's other ways this can be done too. Instead of file referencing, you can import the rig

189
00:12:40,545 --> 00:12:45,810
and do a copy curves solution, which can work. I mean it does require some tools development

190
00:12:45,810 --> 00:12:50,274
to make a system like that. And there's even other solutions I've seen out there too.

191
00:12:50,274 --> 00:12:58,081
Either way, these are something that's good to account for and build the systems to enable

192
00:12:58,081 --> 00:12:59,062
a nice efficient production.

193
00:12:59,062 --> 00:13:03,886
Let's go farther up the chain now and imagine what happens when...

194
00:13:04,612 --> 00:13:06,793
there's some changes at the 3D modeling stage.

195
00:13:06,793 --> 00:13:11,215
So maybe the art director wants to get a little bit

196
00:13:11,215 --> 00:13:14,577
better proportions so that the poses look better.

197
00:13:14,577 --> 00:13:18,560
In this case, we need to move some bones around on the skeleton.

198
00:13:18,560 --> 00:13:21,201
And we'll have to adjust the skin weights.

199
00:13:21,201 --> 00:13:24,303
And after that's done, this control rig now needs to get rebuilt.

200
00:13:24,303 --> 00:13:28,906
That's a big problem if someone has spent time by hand

201
00:13:28,906 --> 00:13:30,967
in manually constructing this file.

202
00:13:32,103 --> 00:13:36,085
So, and they would have to get it exactly the same

203
00:13:36,085 --> 00:13:41,168
naming and parenting and orientations and everything

204
00:13:41,168 --> 00:13:42,889
in order for animation to still work.

205
00:13:42,889 --> 00:13:47,872
So, let's not let that stop us from iterating.

206
00:13:47,872 --> 00:13:50,153
Let's take another requirement here

207
00:13:50,153 --> 00:13:52,874
that we need to be able to quickly rebuild this rig

208
00:13:52,874 --> 00:13:55,876
and get it exactly the same as it was before

209
00:13:55,876 --> 00:13:57,677
every time the skeleton has been redefined.

210
00:13:59,640 --> 00:14:03,943
So a lot of ways this is solved is by building auto-rigging tools

211
00:14:03,943 --> 00:14:08,727
or having scripts that automatically assemble the rig based on a definition of some sort.

212
00:14:08,727 --> 00:14:13,031
So this is great. It really speeds up iteration

213
00:14:13,031 --> 00:14:18,815
when you can automatically rebuild the rig without having to pull an all-nighter.

214
00:14:18,815 --> 00:14:24,140
And great, now that we've also got a consistent rig since it was built through one of these systems,

215
00:14:24,140 --> 00:14:26,602
we should be able to get it onto the animations.

216
00:14:26,602 --> 00:14:28,903
If we're lucky and the bone...

217
00:14:29,718 --> 00:14:36,403
names and transform parenting orientations can be similar enough,

218
00:14:36,403 --> 00:14:38,464
then animation can still apply.

219
00:14:38,464 --> 00:14:42,106
But if it's too different, then it will end up

220
00:14:42,106 --> 00:14:44,568
changing the way the animation looks.

221
00:14:44,568 --> 00:14:47,670
So there needs to be some fix up here.

222
00:14:47,670 --> 00:14:49,250
And

223
00:14:49,250 --> 00:14:50,711
Ideal World,

224
00:14:50,711 --> 00:14:52,973
we want to be able to preserve that animation

225
00:14:52,973 --> 00:14:56,575
whenever this new control rig is built

226
00:14:56,575 --> 00:14:57,936
on top of a changed skeleton.

227
00:14:59,968 --> 00:15:02,810
So often there's tools to solve this, like Motion Builder,

228
00:15:02,810 --> 00:15:05,432
where you can do offline retargeting

229
00:15:05,432 --> 00:15:08,174
and make some creative choices about how to apply

230
00:15:08,174 --> 00:15:10,435
the old motion onto the new rig.

231
00:15:10,435 --> 00:15:12,337
And maybe in some cases you want to favor

232
00:15:12,337 --> 00:15:13,677
the hands holding an object.

233
00:15:13,677 --> 00:15:15,919
Other times if they're hanging free,

234
00:15:15,919 --> 00:15:18,121
you'll want to use a rotation-based transfer.

235
00:15:18,121 --> 00:15:21,643
So there's a lot of choices that can be made there

236
00:15:21,643 --> 00:15:23,284
to get a quality motion retarget.

237
00:15:23,284 --> 00:15:23,344
So.

238
00:15:27,762 --> 00:15:31,964
Thinking about the rigs again, we're not just animating a single character.

239
00:15:31,964 --> 00:15:35,845
Games mostly often include a whole library of different characters,

240
00:15:35,845 --> 00:15:38,526
and they'll look different too, so they'll have different rigs.

241
00:15:38,526 --> 00:15:43,748
So, the rigging staff will need to be building control rigs for each of these

242
00:15:43,748 --> 00:15:46,629
one of different character shapes and sizes,

243
00:15:46,629 --> 00:15:48,590
including everything from different kinds of people,

244
00:15:48,590 --> 00:15:52,291
because people have very different proportions,

245
00:15:52,291 --> 00:15:55,012
if we want to make it look naturalistic and real.

246
00:15:55,555 --> 00:16:01,718
There's also creatures, can have very different body proportion types and all different kinds of shapes.

247
00:16:01,718 --> 00:16:05,939
Maybe even props, vehicles and weapons.

248
00:16:05,939 --> 00:16:09,280
So in an ideal world we really want to have

249
00:16:09,280 --> 00:16:12,721
a consistent interface for the animators between all these different rigs.

250
00:16:12,721 --> 00:16:17,723
And so how can that be done when there's so many different rigs to build

251
00:16:17,723 --> 00:16:21,264
and the advanced functionality that goes into each one of them

252
00:16:21,264 --> 00:16:25,066
like changing the states if you're still using the Uber Rig solution.

253
00:16:26,389 --> 00:16:31,171
It can be very, a lot of work, and a lot of repetition, and a lot of duplicated work

254
00:16:31,171 --> 00:16:35,632
to get those rigs nice and consistent for the animators to work with.

255
00:16:35,632 --> 00:16:40,714
So a really smart way of working is to make a modular rigging system.

256
00:16:40,714 --> 00:16:44,715
And that way you can share this functionality

257
00:16:44,715 --> 00:16:48,496
and easily make a wide variety of different kinds of character rigs

258
00:16:48,496 --> 00:16:51,197
that feel consistent when the animators work with them.

259
00:16:51,197 --> 00:16:54,038
So how this works...

260
00:16:54,388 --> 00:16:56,809
is that you can build a library of rig parts,

261
00:16:56,809 --> 00:17:00,672
for example, arms and legs and heads and things like that,

262
00:17:00,672 --> 00:17:03,434
and then recombine them in whichever way you want

263
00:17:03,434 --> 00:17:07,856
to apply to these different skeleton proportions and shapes and sizes.

264
00:17:07,856 --> 00:17:12,019
So this is a great way to go. It can be a lot faster,

265
00:17:12,019 --> 00:17:15,421
because once you define a part the first time,

266
00:17:15,421 --> 00:17:20,424
you can benefit from reusing that work in a lot of different ways.

267
00:17:20,424 --> 00:17:20,825
And...

268
00:17:21,081 --> 00:17:25,422
It does end up with a nice and consistent result that the animators get to learn to work with

269
00:17:25,422 --> 00:17:29,142
and even speed up their workflow more by having consistency.

270
00:17:29,142 --> 00:17:33,583
This is highly recommended. It's a good way to go.

271
00:17:33,583 --> 00:17:35,884
And there's a lot of different ways it can be done.

272
00:17:35,884 --> 00:17:40,284
I mean, one way is through scripted rig development.

273
00:17:40,284 --> 00:17:43,525
And another is through templates or prefabs.

274
00:17:43,525 --> 00:17:45,485
And they each have their own advantages.

275
00:17:45,485 --> 00:17:49,426
So we have a nice list of requirements now.

276
00:17:50,558 --> 00:17:54,180
This is what's really going to help us keep a nice iteration on our projects.

277
00:17:54,180 --> 00:17:58,982
Some of the best practices for how to achieve this.

278
00:17:58,982 --> 00:18:03,044
Well, number one, we can rule out the monolithic uberrig solution.

279
00:18:03,044 --> 00:18:08,046
As we've demonstrated, that's just not very practical for a lot of reasons,

280
00:18:08,046 --> 00:18:13,549
and it ends up putting in some bad limitations in the iteration process.

281
00:18:13,549 --> 00:18:17,570
Instead, modular rigging is a great way to go.

282
00:18:17,570 --> 00:18:18,571
And that frees up.

283
00:18:18,932 --> 00:18:21,734
us to build all different shapes and sizes

284
00:18:21,734 --> 00:18:22,855
rigs very quickly

285
00:18:22,855 --> 00:18:24,857
and have a consistent result.

286
00:18:24,857 --> 00:18:29,140
One way or another too we need it to be fast

287
00:18:29,140 --> 00:18:30,661
how rigging gets set up

288
00:18:30,661 --> 00:18:34,325
and we need to regenerate and rebuild that

289
00:18:34,325 --> 00:18:38,188
consistently any time the skeleton changes.

290
00:18:38,188 --> 00:18:40,950
We also need to push updates out to the animations

291
00:18:40,950 --> 00:18:44,333
when either the skeleton or the rig are changed.

292
00:18:44,333 --> 00:18:46,195
And how about this one?

293
00:18:47,720 --> 00:18:50,903
We really would love to be able to preserve animation when the control rig changes,

294
00:18:50,903 --> 00:18:53,445
but we haven't talked about a solution to that yet.

295
00:18:53,445 --> 00:18:59,669
Here's where we want to talk about freeform animation.

296
00:18:59,669 --> 00:19:01,531
And to get more specific about the definition,

297
00:19:01,531 --> 00:19:05,213
we're talking about bidirectional motion transfer.

298
00:19:05,213 --> 00:19:12,058
So, when a constraint like an IK has a solving function,

299
00:19:12,571 --> 00:19:19,313
What's happening there is the bones involved with the IK system are solving to a target location.

300
00:19:19,313 --> 00:19:22,294
We're now introducing the concept of an inverse solve

301
00:19:22,294 --> 00:19:28,856
where the rig controls now are built in with the knowledge of how to follow the skeleton.

302
00:19:28,856 --> 00:19:32,337
So when you have both of those, you can provide a two-way road

303
00:19:32,337 --> 00:19:37,199
where animators can choose to use this however they want in their production.

304
00:19:37,199 --> 00:19:40,780
And like our name suggests, this really frees them up to experiment.

305
00:19:40,870 --> 00:19:48,936
and come up with novel solutions for these interesting situations they'll get into with animation.

306
00:19:48,936 --> 00:19:52,298
So here's a demonstration of how this works.

307
00:19:52,298 --> 00:19:56,741
Here we have a three-bone chain of what might be a leg

308
00:19:56,741 --> 00:20:03,665
extending open and closed with very simple rotation animations based in local space.

309
00:20:03,665 --> 00:20:08,508
So now, we're going to bake-inverse-solve this to an IK control rig.

310
00:20:09,426 --> 00:20:12,028
And the IK control rig has two targets.

311
00:20:12,028 --> 00:20:15,171
There's the end effector target

312
00:20:15,171 --> 00:20:19,074
and the hint, or what might be called a pole vector.

313
00:20:19,074 --> 00:20:22,897
So the inverse solve function for this

314
00:20:22,897 --> 00:20:27,301
is custom, and it can be developed however it's needed for a given constraint.

315
00:20:27,301 --> 00:20:30,383
For the target it's very simple.

316
00:20:30,383 --> 00:20:34,807
We're just going to align the translation and rotation to the end bone's position.

317
00:20:34,807 --> 00:20:38,310
But the hint is a little bit more custom.

318
00:20:38,940 --> 00:20:43,862
We need to do some 3D math here to calculate the position out front of that knee

319
00:20:43,862 --> 00:20:48,703
where it's based on the triangle and extends through the center

320
00:20:48,703 --> 00:20:52,985
and to the length that feels comfortable for animator to interact with.

321
00:20:52,985 --> 00:20:59,307
And if we do that each frame, we can determine the position that it would be nice for it to bake onto.

322
00:20:59,307 --> 00:21:03,268
So here we have exactly that same animation as we saw before.

323
00:21:04,728 --> 00:21:08,992
but transferred onto a control scheme that's now much easier to interact with as an animator.

324
00:21:08,992 --> 00:21:13,395
Now the motion is transferred to world space translation,

325
00:21:13,395 --> 00:21:16,697
where it's very easy for me to do something like this,

326
00:21:16,697 --> 00:21:22,342
and interact with an external object like the ground.

327
00:21:22,342 --> 00:21:24,923
So I even added some animation to the top bone

328
00:21:24,923 --> 00:21:28,206
to show that the foot can stay in contact very easily with the ground.

329
00:21:30,685 --> 00:21:36,488
Now we're done making our edits, we can bake the animation back to the skeleton.

330
00:21:36,488 --> 00:21:40,771
And now it's playing back, once again we'll see exactly the same animation we saw before,

331
00:21:40,771 --> 00:21:44,453
but the keyframes are now put into local space rotation.

332
00:21:44,453 --> 00:21:49,675
In this case, it would be very hard to make an edit and keep the foot on the ground,

333
00:21:49,675 --> 00:21:55,158
because the final position of the foot is the result of all of the parents working together.

334
00:21:57,902 --> 00:22:01,344
But in this format it's going to be easier for playback in runtime,

335
00:22:01,344 --> 00:22:05,206
because often that's the most optimal format for playing it back.

336
00:22:05,206 --> 00:22:13,492
So where this is really useful is, for example, with something like editing motion capture.

337
00:22:13,492 --> 00:22:18,655
So here in this example I've actually exaggerated the driftiness by just turning up keyframe reduction.

338
00:22:18,655 --> 00:22:23,238
So that left foot, or the right foot on the ground there is drifting around a little bit.

339
00:22:24,207 --> 00:22:31,088
If I want to clean that up, I can add a TubeBoneIK constraint and transfer motion to the constraints.

340
00:22:31,088 --> 00:22:33,529
So here we have exactly the same motion.

341
00:22:33,529 --> 00:22:38,450
I can zoom in on the foot, look at those keyframes, and start making some additions.

342
00:22:38,450 --> 00:22:42,010
I'll set one keyframe in the beginning here to lock it down.

343
00:22:42,010 --> 00:22:47,031
And then I'll paste that same keyframe here later where the foot is leaving the ground.

344
00:22:47,031 --> 00:22:53,833
So now I can zoom in and delete the drifty keyframes in the middle.

345
00:22:55,253 --> 00:22:56,594
and keep it solid on the ground.

346
00:22:56,594 --> 00:23:04,737
So I still need to delete the rotation keyframes, that's why it's a little bit drifty.

347
00:23:04,737 --> 00:23:08,839
And if you want to take some more time and polish this, you can make a really nice looking result.

348
00:23:08,839 --> 00:23:17,183
That was a quick demonstration to show how easy it is to make some of these edits.

349
00:23:17,183 --> 00:23:20,144
So what we need here in order to make

350
00:23:21,008 --> 00:23:26,132
a really workable solution is as close as possible to a lossless motion transfer.

351
00:23:26,132 --> 00:23:32,256
Now if I'm using FK, which is Single Translation Rotation Control per joint,

352
00:23:32,256 --> 00:23:35,439
then I can get lossless motion transfer.

353
00:23:35,439 --> 00:23:37,981
This is exactly the same as we saw before.

354
00:23:37,981 --> 00:23:42,044
But that's not the case if we're going to a different kind of control rig,

355
00:23:42,044 --> 00:23:46,727
for example an IK constraint, where there's a lower degree of freedom.

356
00:23:46,727 --> 00:23:50,810
If we're going down from these 5 or 6 bones to only 2 controls...

357
00:23:51,183 --> 00:23:52,885
you can imagine what will happen.

358
00:23:52,885 --> 00:23:55,307
It'll have a close approximation of that,

359
00:23:55,307 --> 00:23:57,568
but it's not possible to get exactly the same.

360
00:23:57,568 --> 00:24:01,111
So, people can use this deliberately

361
00:24:01,111 --> 00:24:04,694
if they're working in an artistic authoring workflow

362
00:24:04,694 --> 00:24:06,115
to get a deliberate result.

363
00:24:06,115 --> 00:24:07,816
Maybe you want to smooth that out

364
00:24:07,816 --> 00:24:11,499
or reduce some of the motion in the middle of that chain.

365
00:24:11,499 --> 00:24:12,600
In that case, you can transfer

366
00:24:12,600 --> 00:24:14,442
to a different kind of control rig.

367
00:24:16,017 --> 00:24:22,178
This is all part of the animation authoring process, which will be up to the artist to use how they want for a given situation.

368
00:24:22,178 --> 00:24:30,120
Now, parent spaces is another really important thing to consider while working this way.

369
00:24:30,120 --> 00:24:37,801
And here's how I'll demonstrate using the simple planetary system to show the importance of working in the correct parent space.

370
00:24:37,801 --> 00:24:44,803
So, with this planetary system here just showing a moon rotating around a planet,

371
00:24:45,312 --> 00:24:48,373
If I'm going to describe this using a flat hierarchy,

372
00:24:48,373 --> 00:24:50,714
then I'll be using world space translation keys.

373
00:24:50,714 --> 00:24:55,175
And that's what it looks like to make keyframes that describe this motion.

374
00:24:55,175 --> 00:25:00,177
So as you can see there, it gets very,

375
00:25:00,177 --> 00:25:03,258
very detailed and precise for the moon's position.

376
00:25:03,258 --> 00:25:07,880
And you could imagine what it'd be like as an artist to say,

377
00:25:07,880 --> 00:25:10,741
well, what if I want the moon to speed up over time?

378
00:25:10,741 --> 00:25:13,882
Then it would be a lot of really detailed keyframing animation

379
00:25:13,882 --> 00:25:15,222
and a lot of counter animation.

380
00:25:15,959 --> 00:25:17,540
to try and get that to look right.

381
00:25:17,540 --> 00:25:21,003
And it's going to be very, very hard to take some time to get it to look just right.

382
00:25:21,003 --> 00:25:24,526
Well that's where it makes a lot more sense to be working in a

383
00:25:24,526 --> 00:25:28,849
ordered hierarchy where there's a parent-child relationship here.

384
00:25:28,849 --> 00:25:32,732
This way the keyframes are local space rotation

385
00:25:32,732 --> 00:25:35,594
and it's simply a keyframe at the start and then

386
00:25:35,594 --> 00:25:39,117
360 degrees at the end, and you can loop it.

387
00:25:39,117 --> 00:25:42,039
You're going to get a nice smooth motion.

388
00:25:42,727 --> 00:25:47,150
and very simple to edit. If I want to make that speed up, I can modify the tangents

389
00:25:47,150 --> 00:25:48,291
or add additional keyframes

390
00:25:48,291 --> 00:25:51,633
and it's very easy to work with, very easy to iterate.

391
00:25:51,633 --> 00:26:01,419
So let's take a look at this again on the example of a first-person animation or a third-person where you're contacting a weapon.

392
00:26:01,419 --> 00:26:03,801
So two hands here start out by following the gun

393
00:26:03,801 --> 00:26:06,542
and that's great when he's holding onto it.

394
00:26:06,542 --> 00:26:10,005
But in the example of our reload animation...

395
00:26:10,784 --> 00:26:12,906
Halfway through he takes his hand away.

396
00:26:12,906 --> 00:26:15,127
And now we really need to be free.

397
00:26:15,127 --> 00:26:19,290
So what I'll do in a freeform animation workflow is

398
00:26:19,290 --> 00:26:21,591
change the parent.

399
00:26:21,591 --> 00:26:25,394
I have a parent constraint, so here I'm going to give it a new target.

400
00:26:25,394 --> 00:26:27,916
Right now it's following the gun.

401
00:26:27,916 --> 00:26:30,517
Let's put it at the character root.

402
00:26:30,517 --> 00:26:31,938
There we go.

403
00:26:31,938 --> 00:26:32,479
And now

404
00:26:32,479 --> 00:26:35,561
I can transfer motion to those constraints.

405
00:26:39,542 --> 00:26:42,023
Here we go on the parent constraint.

406
00:26:42,023 --> 00:26:45,485
And let's do it again on the IK constraint.

407
00:26:45,485 --> 00:26:48,887
Great. Now I have exactly that same animation,

408
00:26:48,887 --> 00:26:52,069
but it's going to be playing back in a different parent space.

409
00:26:52,069 --> 00:26:55,631
And while I'm animating this part where it's free,

410
00:26:55,631 --> 00:26:57,912
I can move the gun and the hand remains unchanged.

411
00:26:57,912 --> 00:27:02,294
So great, that's what we really want for this part of the animation.

412
00:27:04,689 --> 00:27:07,350
I did want to mention too that there's other solutions to this

413
00:27:07,350 --> 00:27:09,471
that might make sense in different situations.

414
00:27:09,471 --> 00:27:12,472
Like for example, you might want to do an animated switch

415
00:27:12,472 --> 00:27:13,993
where it remembers the state

416
00:27:13,993 --> 00:27:15,954
where it's in the beginning of the animation

417
00:27:15,954 --> 00:27:18,695
and halfway through it does a switch to being in a new.

418
00:27:18,695 --> 00:27:20,755
That's totally possible here.

419
00:27:20,755 --> 00:27:23,396
And we're not saying you have to work this way.

420
00:27:23,396 --> 00:27:25,917
But it can be cumbersome in that animated switch example

421
00:27:25,917 --> 00:27:30,059
to manage this state switch where it's the aligned pose.

422
00:27:30,059 --> 00:27:32,960
So it's really a choice of what's going to be faster and easier.

423
00:27:33,613 --> 00:27:39,516
And for short animations like this, there's a lot of advantages to working this way because it's very very fast and direct.

424
00:27:39,516 --> 00:27:43,518
It can allow you to keep a very simple control rig too.

425
00:27:43,518 --> 00:27:50,122
Another one of the challenges working this way is working with baked keyframes.

426
00:27:50,122 --> 00:27:55,465
And this is where our curve here has a keyframe every frame.

427
00:27:55,465 --> 00:28:00,988
And that's what you need to get a high fidelity source quality that's exactly the same as the previous one.

428
00:28:01,997 --> 00:28:04,057
But it's hard to work with as an animator sometimes.

429
00:28:04,057 --> 00:28:06,038
So, a couple solutions to offer.

430
00:28:06,038 --> 00:28:08,439
One of them is keyframe reduction.

431
00:28:08,439 --> 00:28:13,201
You can apply a curve filter that automatically removes keys

432
00:28:13,201 --> 00:28:16,462
and modifies tangents to try and keep the curve looking the same.

433
00:28:16,462 --> 00:28:20,944
But it's a tradeoff between fidelity and easy to work with.

434
00:28:20,944 --> 00:28:24,886
So as you can see in the lower example where there's more keys removed,

435
00:28:24,886 --> 00:28:26,287
the curve actually looks different.

436
00:28:26,287 --> 00:28:27,847
So we're missing some of the detail.

437
00:28:28,723 --> 00:28:33,647
But this is a trade-off that might be worth making if someone wants to modify the curve

438
00:28:33,647 --> 00:28:37,130
and they want something that's easier to interact with.

439
00:28:37,130 --> 00:28:39,532
Another solution is animation layers.

440
00:28:39,532 --> 00:28:45,296
So you can easily make offsets from that baked keyframe.

441
00:28:45,296 --> 00:28:51,421
And then just the delta animation curve is what's worked with by the keyframe animator.

442
00:28:51,421 --> 00:28:54,423
There's a lot less keyframes there to work with.

443
00:28:54,423 --> 00:28:56,004
So that can be faster and more direct.

444
00:28:57,965 --> 00:29:00,466
Both of these have their time and place,

445
00:29:00,466 --> 00:29:02,606
and when you're working with these,

446
00:29:02,606 --> 00:29:04,947
you can choose which one makes the most sense at a given time.

447
00:29:04,947 --> 00:29:09,769
So let's talk about how this is implemented in Unity.

448
00:29:09,769 --> 00:29:12,850
In 2020.1, there are some new features

449
00:29:12,850 --> 00:29:14,770
in the Animation Rigging package.

450
00:29:14,770 --> 00:29:17,391
So these are documented here

451
00:29:17,391 --> 00:29:21,593
on the Bidirectional Motion Transfer documentation page.

452
00:29:21,593 --> 00:29:27,255
The new commands are accessible from the context menu shown here.

453
00:29:28,349 --> 00:29:37,155
And this is right inside of the menu that is both at the constraint level and at the rig level.

454
00:29:37,155 --> 00:29:45,700
You can transfer a group of constraints that are bundled together as a rig all at once from that one command.

455
00:29:45,700 --> 00:29:51,484
We also added some new preferences, so animators can control the keyframe reduction

456
00:29:51,484 --> 00:29:55,547
in both directions when going to the constraint and to the skeleton.

457
00:29:56,305 --> 00:29:59,068
So that's let you choose, for example, you might want to keep

458
00:29:59,068 --> 00:30:02,553
easier to work with keyframes going on to the control rig,

459
00:30:02,553 --> 00:30:06,318
but higher fidelity quality when going back to the skeleton

460
00:30:06,318 --> 00:30:07,719
to preserve exactly what you created.

461
00:30:07,719 --> 00:30:11,865
And all these settings here can be changed at any time

462
00:30:11,865 --> 00:30:13,747
for your workflow that you want to have.

463
00:30:17,047 --> 00:30:21,770
So inside of the AnimationRing package, all of the C-sharp is available in the package

464
00:30:21,770 --> 00:30:28,194
to open up and look through and make modifications if you want, or make custom constraints.

465
00:30:28,194 --> 00:30:31,156
And if you're working with this and building it in your own system,

466
00:30:31,156 --> 00:30:34,638
one good thing to remember is that

467
00:30:34,638 --> 00:30:40,682
not all types of constraints can have an inverse solve, just by the nature of what they are.

468
00:30:40,682 --> 00:30:42,603
For example, some constraints are...

469
00:30:43,727 --> 00:30:48,670
passive, like a twist correction for shoulder, has no animatable controls

470
00:30:48,670 --> 00:30:53,813
so in that case it doesn't make sense to transfer motion to a constraint.

471
00:30:53,813 --> 00:30:57,435
So it's good to keep this as an optional function

472
00:30:57,435 --> 00:31:01,357
that can be implemented for constraints where it would make sense.

473
00:31:01,357 --> 00:31:04,979
Another example are physics-based constraints.

474
00:31:04,979 --> 00:31:10,123
For example, the damped transform or the spring-chained constraint.

475
00:31:10,123 --> 00:31:12,624
Once again, there are no animatable controls on those.

476
00:31:12,994 --> 00:31:16,035
so it wouldn't make sense to have an inverse solve.

477
00:31:16,035 --> 00:31:21,917
Here in the documentation, we've given a description of what you can expect

478
00:31:21,917 --> 00:31:26,438
with the motion transfer, transferring to the constraint.

479
00:31:26,438 --> 00:31:29,499
But all of these constraints can transfer back to the skeleton

480
00:31:29,499 --> 00:31:33,980
because that is simply plotting the keyframes exactly to the bones.

481
00:31:33,980 --> 00:31:41,363
OK, let's take a look at how this can be useful in a game production.

482
00:31:41,363 --> 00:31:42,203
Two examples.

483
00:31:43,332 --> 00:31:47,034
start out with looking at an object interaction.

484
00:31:47,034 --> 00:31:50,516
Here we have an animation of a character pushing a button.

485
00:31:50,516 --> 00:31:54,758
It's really common in games to use runtime rigging for things like this.

486
00:31:54,758 --> 00:31:59,261
So here's what I'm doing with that yellow plus shape

487
00:31:59,261 --> 00:32:01,582
is the end effector of a 2 bone IK system.

488
00:32:01,582 --> 00:32:07,005
And I'm animating the weight of that rig constraint

489
00:32:07,005 --> 00:32:09,606
from 0 to 1, as you can see in the keyframes,

490
00:32:09,606 --> 00:32:13,208
so that it blends on and it has this moment where.

491
00:32:13,887 --> 00:32:16,047
right when it's contacting.

492
00:32:16,047 --> 00:32:16,148
Oops.

493
00:32:16,148 --> 00:32:18,789
Back up a little bit.

494
00:32:18,789 --> 00:32:22,790
Now what I can do is move that Constraint Target

495
00:32:22,790 --> 00:32:25,731
and the hand will always keep contacting it

496
00:32:25,731 --> 00:32:27,092
exactly at the right place.

497
00:32:27,092 --> 00:32:29,613
This is really useful because

498
00:32:29,613 --> 00:32:31,634
that way an animator doesn't have to keep

499
00:32:31,634 --> 00:32:33,835
creating new content

500
00:32:33,835 --> 00:32:35,515
every single time that button is in

501
00:32:35,515 --> 00:32:36,616
a slightly different position.

502
00:32:36,616 --> 00:32:39,037
So this is great.

503
00:32:39,037 --> 00:32:41,538
But what if we try and move it up

504
00:32:41,538 --> 00:32:42,618
really high like this?

505
00:32:44,717 --> 00:32:47,458
It doesn't look so good. We're pushing it too far.

506
00:32:47,458 --> 00:32:51,999
And sometimes runtime rigging has this effect where it feels a bit stiff or robotic.

507
00:32:51,999 --> 00:32:55,859
Or we might just get some bad looking poses.

508
00:32:55,859 --> 00:33:01,520
So in this case, we can use some freeform animation techniques to work with it.

509
00:33:01,520 --> 00:33:08,522
The first thing I might do is blend in a single pose with a control rig like this.

510
00:33:08,522 --> 00:33:12,463
And then, just like I animated the weight of the IK constraint,

511
00:33:12,463 --> 00:33:13,483
I can bake that.

512
00:33:13,759 --> 00:33:14,720
to the skeleton.

513
00:33:14,720 --> 00:33:17,042
And have a nice base to work with

514
00:33:17,042 --> 00:33:19,023
where the pose is going to be much more natural.

515
00:33:19,023 --> 00:33:21,385
I've involved the shoulder,

516
00:33:21,385 --> 00:33:25,088
twisted the spine, I've rotated his head up to look at that,

517
00:33:25,088 --> 00:33:27,910
and I can even drop the hips a little bit or whatever feels right.

518
00:33:27,910 --> 00:33:32,774
Next, I might bring back the runtime rigging IK constraint

519
00:33:32,774 --> 00:33:36,376
and bake animation from that little button press that he gets

520
00:33:36,376 --> 00:33:39,639
so that it actually feels like he's activating the button.

521
00:33:39,639 --> 00:33:43,102
And finally, you can transfer back to the full body control rig.

522
00:33:43,533 --> 00:33:48,174
and make some polished tweaks to the exact interpolations and in-betweens

523
00:33:48,174 --> 00:33:49,855
of how it looks when he's animating.

524
00:33:49,855 --> 00:33:52,715
So now we're done, we can save out this final clip.

525
00:33:52,715 --> 00:33:56,516
And that can be a new button press high animation,

526
00:33:56,516 --> 00:33:59,457
which if we want to we can apply some more

527
00:33:59,457 --> 00:34:02,158
runtime rigging and get some movement within that range.

528
00:34:05,478 --> 00:34:09,760
This was an easy correction to make where it's already looking almost good enough

529
00:34:09,760 --> 00:34:11,682
and we just want to make a couple tweaks

530
00:34:11,682 --> 00:34:16,905
so it's nice and quick to even save out a new animation that way.

531
00:34:16,905 --> 00:34:21,288
Here's another example where we might have an existing run animation

532
00:34:21,288 --> 00:34:24,310
that we got from a motion library somewhere

533
00:34:24,310 --> 00:34:27,311
but we want to transfer it onto our character

534
00:34:27,311 --> 00:34:30,113
and wherever he goes he's carrying this big heavy suitcase

535
00:34:30,113 --> 00:34:32,455
and that just doesn't look so good.

536
00:34:33,041 --> 00:34:38,404
There's no weight at all, and it's going right through his leg.

537
00:34:38,404 --> 00:34:42,025
So we need to make some edits.

538
00:34:42,025 --> 00:34:45,607
So what I'm going to do is first add a Tubo on IK constraint.

539
00:34:45,607 --> 00:34:48,068
Now he's holding on to this suitcase.

540
00:34:48,068 --> 00:34:57,253
Let's set some keyframes and put it in a good position that's looking about right.

541
00:34:57,253 --> 00:34:57,493
OK.

542
00:34:57,493 --> 00:35:01,595
Now, I can play with the weight value of the IK constraint.

543
00:35:01,776 --> 00:35:07,638
And a value right in the middle, something like a 0.6, is going to give a nice blended result.

544
00:35:07,638 --> 00:35:10,739
So I'm inheriting a bit of the motion from the body.

545
00:35:10,739 --> 00:35:14,220
And it's not locked in space like it was before.

546
00:35:14,220 --> 00:35:15,820
So I'll transfer motion to the skeleton,

547
00:35:15,820 --> 00:35:20,781
and then transfer it back to the constraint.

548
00:35:20,781 --> 00:35:22,742
Here I have

549
00:35:22,742 --> 00:35:27,964
the motion transferred onto the IK where I can start making some animation edits.

550
00:35:27,964 --> 00:35:29,664
So I can go into the keyframes now.

551
00:35:30,632 --> 00:35:35,256
And I might want to do something like offset everything in time.

552
00:35:35,256 --> 00:35:37,839
So it moves at a slightly delayed rate,

553
00:35:37,839 --> 00:35:45,846
and it gets a little bit more sense of a bounce and follow-through.

554
00:35:45,846 --> 00:35:48,068
OK, and I want to maybe go into individual curves,

555
00:35:48,068 --> 00:35:51,390
like here's the Translate Y for vertical motion,

556
00:35:51,390 --> 00:35:56,135
and I might exaggerate that a little bit, make it a bit larger and easier to notice.

557
00:35:57,230 --> 00:36:02,274
Okay, and now I can go into something like the Translate Z, which is the forward and back motion.

558
00:36:02,274 --> 00:36:07,839
And I can offset that just a little bit in space.

559
00:36:07,839 --> 00:36:15,585
And now it's up to animation to make some creative choices and add some quality here so it looks believable.

560
00:36:15,585 --> 00:36:24,693
Once I'm done with that single 2-Bone IK constraint, I can bake it back down to the skeleton.

561
00:36:24,693 --> 00:36:24,913
And...

562
00:36:25,800 --> 00:36:27,220
weight down the rig to zero.

563
00:36:27,220 --> 00:36:29,941
So here I have it playing back on just the skeleton.

564
00:36:29,941 --> 00:36:36,444
Next I might want to go in and add a full body control rig.

565
00:36:36,444 --> 00:36:40,046
So I'll transfer motion to the constraints

566
00:36:40,046 --> 00:36:42,767
and start making some modifications.

567
00:36:42,767 --> 00:36:49,350
Because when you're carrying a heavy object like this, it would affect

568
00:36:49,350 --> 00:36:53,392
the hips, the shoulders, the spine would lean over in a direction.

569
00:36:54,136 --> 00:36:58,219
And you can make all of these edits right here by modifying the keyframes.

570
00:36:58,219 --> 00:37:06,406
Great, now we've ended up with a better looking result.

571
00:37:06,406 --> 00:37:12,811
And one thing I wanted to demonstrate next, but I ran out of time, was using physics.

572
00:37:12,811 --> 00:37:17,315
So a really nice thing to do would be putting the Damped Transform constraint on that heavy suitcase.

573
00:37:17,315 --> 00:37:23,860
And that would just give it a little bit more sense of momentum and more realistic follow through.

574
00:37:24,565 --> 00:37:27,427
So you can play with the weight of the Damped Transform

575
00:37:27,427 --> 00:37:31,570
to get it to be softening up that motion just a little bit

576
00:37:31,570 --> 00:37:33,912
and making it feel even heavier and more realistic.

577
00:37:33,912 --> 00:37:38,676
So all of these tools exist within this

578
00:37:38,676 --> 00:37:44,280
nice sandbox of motion editing tools

579
00:37:44,280 --> 00:37:48,443
which is really interesting to think about how to use in combination.

580
00:37:49,128 --> 00:37:53,911
So now that we have the ability to do motion editing using these Freeform Animation workflows,

581
00:37:53,911 --> 00:37:57,392
we can make use of these other parts that exist within Unity.

582
00:37:57,392 --> 00:38:01,614
So the Kinematica Motion Matching solution

583
00:38:01,614 --> 00:38:04,996
can be used to generate a really nice and natural looking

584
00:38:04,996 --> 00:38:07,917
motion controller as the character runs around through the game,

585
00:38:07,917 --> 00:38:13,219
which can be recorded and then baked back down to a single animation clip

586
00:38:13,219 --> 00:38:15,280
where we can go in and make some edits.

587
00:38:15,280 --> 00:38:17,862
Like for example, if we're making a cinematic or a cutscene.

588
00:38:18,673 --> 00:38:22,196
We can then make it look custom in a certain pose.

589
00:38:22,196 --> 00:38:23,797
We can send that back to Kinematica

590
00:38:23,797 --> 00:38:25,779
for some more motion matching,

591
00:38:25,779 --> 00:38:27,200
and then out to the gameplay,

592
00:38:27,200 --> 00:38:29,502
where we can do runtime rigging

593
00:38:29,502 --> 00:38:31,703
and have it interact with the world.

594
00:38:31,703 --> 00:38:35,306
This is all within this ecosystem of tools

595
00:38:35,306 --> 00:38:38,248
that can be interchanged in very creative ways.

596
00:38:38,248 --> 00:38:40,350
And personally, I'm really excited to see

597
00:38:40,350 --> 00:38:43,332
how people will use this and get creative

598
00:38:43,332 --> 00:38:46,775
and do fast iteration to make their creative projects.

599
00:38:49,787 --> 00:38:54,210
So let's take a look once again at these requirements we've put together.

600
00:38:54,210 --> 00:39:01,136
I'm feeling pretty good that the Freeform Animation workflows really help speed up iteration

601
00:39:01,136 --> 00:39:04,399
and they address most of these issues pretty well.

602
00:39:04,399 --> 00:39:08,582
I wouldn't say it's the solution for every single situation,

603
00:39:08,582 --> 00:39:14,087
but it's one of the tools that you can now use to find a solution.

604
00:39:14,087 --> 00:39:17,170
And it really adds a lot of nice flexibility to these workflows.

605
00:39:18,617 --> 00:39:20,678
So looking back at the animation pipeline,

606
00:39:20,678 --> 00:39:26,121
the old way, it was the rigging people's job to build a control rig

607
00:39:26,121 --> 00:39:29,504
and to have to think of all the choices for animators.

608
00:39:29,504 --> 00:39:33,306
What we've done now is give that control to the animators

609
00:39:33,306 --> 00:39:37,149
and let them choose how to assemble control rigs

610
00:39:37,149 --> 00:39:39,510
and use them for their animation however they want.

611
00:39:39,510 --> 00:39:43,272
This really frees up the iterations cycle

612
00:39:43,272 --> 00:39:46,735
and it's really great to be able to have that freedom.

613
00:39:47,658 --> 00:39:52,663
And what we have now is much more like a sandbox instead of a pipeline.

614
00:39:52,663 --> 00:39:54,784
Where we've opened things up for experimentation.

615
00:39:54,784 --> 00:40:01,930
And what that lets animators do is take motion sources as input from all these different places.

616
00:40:01,930 --> 00:40:04,212
You can start with hand keyframe animation.

617
00:40:04,212 --> 00:40:10,037
You can go back and forth to your DCC applications with FBX exporters.

618
00:40:10,037 --> 00:40:13,319
And you can record physics or gameplay.

619
00:40:13,319 --> 00:40:14,480
Do some motion capture.

620
00:40:15,252 --> 00:40:18,515
All of this can be edited using hand keyframing,

621
00:40:18,515 --> 00:40:22,277
which puts it into the artistic control of the animators where it belongs.

622
00:40:22,277 --> 00:40:28,281
So I'm really excited to hear how people will work this way,

623
00:40:28,281 --> 00:40:31,083
and I was hoping we can have some questions and answers here,

624
00:40:31,083 --> 00:40:33,865
but we'll just have to take that to the Unity forums.

625
00:40:33,865 --> 00:40:36,567
And here's the link where you can find that.

626
00:40:36,567 --> 00:40:38,669
Thank you very much for joining us,

627
00:40:38,669 --> 00:40:40,650
and look forward to hearing how it goes.

