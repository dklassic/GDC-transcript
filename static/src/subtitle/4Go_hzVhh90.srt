1
00:00:05,138 --> 00:00:07,039
Hi everyone, let's get started.

2
00:00:07,039 --> 00:00:10,000
Before we actually start, we just need to send you

3
00:00:10,000 --> 00:00:12,542
a reminder to switch off any cell phones

4
00:00:12,542 --> 00:00:15,883
and please remember to fill out the evaluation.

5
00:00:15,883 --> 00:00:16,504
Thanks.

6
00:00:16,504 --> 00:00:17,804
Right, let's get started.

7
00:00:17,804 --> 00:00:18,825
Welcome to our presentation.

8
00:00:18,825 --> 00:00:22,206
Welcome to our presentation, Finding Balance,

9
00:00:22,206 --> 00:00:26,269
Realizing Responsive High-Fidelity Character Movement

10
00:00:26,269 --> 00:00:27,089
in Just Cause 3.

11
00:00:27,779 --> 00:00:31,301
My name is Alex Crowhurst, Lead Animator at Avalanche Studios,

12
00:00:31,301 --> 00:00:35,702
and I'm here with Jeet Shroff, also Lead Character Programmer at Avalanche Studios.

13
00:00:35,702 --> 00:00:40,844
We're super excited to be here today, as we have a rare opportunity to share with you

14
00:00:40,844 --> 00:00:45,346
some of our feature work currently in progress and before the game is released.

15
00:00:45,346 --> 00:00:50,668
So it goes without saying, what you see here today is very much work in progress

16
00:00:50,668 --> 00:00:53,950
and is going to continue to be worked on by the team until the day of release.

17
00:00:56,117 --> 00:00:59,218
So before we dig deep into the presentation,

18
00:00:59,218 --> 00:01:00,839
I think it's important to briefly frame

19
00:01:00,839 --> 00:01:04,640
the overall experience of the Just Cause franchise.

20
00:01:04,640 --> 00:01:06,881
So let's start with the three main pillars

21
00:01:06,881 --> 00:01:07,662
that are the backbone of the series.

22
00:01:07,662 --> 00:01:10,143
At the heart of the franchise

23
00:01:10,143 --> 00:01:12,364
lies an open world sandbox experience

24
00:01:12,364 --> 00:01:14,145
where the player can have complete freedom

25
00:01:14,145 --> 00:01:17,126
to play around with the world and its systems

26
00:01:17,126 --> 00:01:19,747
and just causing havoc and fun everywhere.

27
00:01:22,004 --> 00:01:23,926
The second being fast-paced combat,

28
00:01:23,926 --> 00:01:27,289
where player responsiveness is key to be able to move fluidity

29
00:01:27,289 --> 00:01:29,090
in through high-pressure combat situations.

30
00:01:29,090 --> 00:01:31,873
And finally, vertical gameplay.

31
00:01:31,873 --> 00:01:36,817
Our character has the freedom to move from the land, sea,

32
00:01:36,817 --> 00:01:40,741
and skies seamlessly in any way that they choose.

33
00:01:40,741 --> 00:01:42,802
So coming off from Just Cause 2, we

34
00:01:42,802 --> 00:01:44,644
wanted to push these pillars even further

35
00:01:44,644 --> 00:01:46,666
and take it to our next-gen experience.

36
00:01:48,649 --> 00:01:50,931
And for Just Cause 3, the overall direction

37
00:01:50,931 --> 00:01:53,593
was to ensure we keep all the insane and crazy stuff you

38
00:01:53,593 --> 00:01:56,396
could do, but ground it in a more realistic style.

39
00:01:56,396 --> 00:01:59,859
And with that in mind, one of our key components

40
00:01:59,859 --> 00:02:03,383
we wanted to build on was the realization of characters,

41
00:02:03,383 --> 00:02:05,244
most notably our main character, Rico,

42
00:02:05,244 --> 00:02:08,287
who you can see here in this image,

43
00:02:08,287 --> 00:02:09,448
but the back of him at least.

44
00:02:09,448 --> 00:02:12,972
From a design perspective, there were two main goals

45
00:02:12,972 --> 00:02:13,973
we needed to achieve.

46
00:02:15,392 --> 00:02:17,974
Rico must be highly responsive to player input.

47
00:02:17,974 --> 00:02:20,456
The player needs to feel fully in control

48
00:02:20,456 --> 00:02:22,898
and should never have to wait for an animation

49
00:02:22,898 --> 00:02:24,619
to finish playing to make their next maneuver.

50
00:02:24,619 --> 00:02:28,802
Secondly, we needed to maintain the fluidity of combat.

51
00:02:28,802 --> 00:02:31,284
This means that Rico must maintain the ability

52
00:02:31,284 --> 00:02:34,326
to perform combat actions like aiming and shooting,

53
00:02:34,326 --> 00:02:37,108
even when transitioning between complex mechanics

54
00:02:37,108 --> 00:02:40,390
and states, which results in seamless combat.

55
00:02:40,390 --> 00:02:42,752
Now, neither of these were easy tasks

56
00:02:42,752 --> 00:02:44,193
by any stretch of the imagination.

57
00:02:45,815 --> 00:02:47,316
On the realization end of things,

58
00:02:47,316 --> 00:02:51,258
our main character can do an awful lot in the world.

59
00:02:51,258 --> 00:02:54,099
He has a full range of on-foot locomotion set,

60
00:02:54,099 --> 00:02:56,781
supporting many different kinds of weapons.

61
00:02:56,781 --> 00:03:01,003
He also uses his grapple hook in many different ways

62
00:03:01,003 --> 00:03:03,104
and in any situation.

63
00:03:03,104 --> 00:03:05,385
He can now stunt and traverse on top of

64
00:03:05,385 --> 00:03:10,188
many different vehicles and interact with them as well.

65
00:03:10,747 --> 00:03:13,649
He can free fall, he can parachute, he can now wingsuit,

66
00:03:13,649 --> 00:03:15,490
and that's just the tip of the iceberg.

67
00:03:15,490 --> 00:03:18,553
With what seems an endless amount of mechanics,

68
00:03:18,553 --> 00:03:20,414
we needed a way to help save us time

69
00:03:20,414 --> 00:03:22,516
and cleverly share as much content

70
00:03:22,516 --> 00:03:24,798
as we could across all these features.

71
00:03:24,798 --> 00:03:28,260
Secondly, having such a responsive character

72
00:03:28,260 --> 00:03:31,383
is always going to fight against the realization needed

73
00:03:31,383 --> 00:03:33,664
to give a character believable weight and motion.

74
00:03:33,664 --> 00:03:36,847
So for animation, it's a bit like trying to fit

75
00:03:36,847 --> 00:03:39,389
a square block into a triangle hole.

76
00:03:39,389 --> 00:03:40,350
It just won't fit.

77
00:03:41,994 --> 00:03:48,697
So now that I've given you some background behind the challenges of Just Cause 3,

78
00:03:48,697 --> 00:03:52,919
let's take a look at some of the ways we attacked these issues.

79
00:03:52,919 --> 00:03:57,841
Alright, so in this first section, let's look at how we update the motion of our characters.

80
00:03:57,841 --> 00:04:02,423
And I'd like to start by talking about the different character movement models.

81
00:04:03,905 --> 00:04:05,847
So, first we have game-driven movement.

82
00:04:05,847 --> 00:04:10,393
In this case, the game logic evaluates the motion of the character, which is then fed

83
00:04:10,393 --> 00:04:14,397
into the physics system, which moves the physical representation of the character.

84
00:04:14,397 --> 00:04:19,524
In most cases, this information is also fed into the animation system, which selects and

85
00:04:19,524 --> 00:04:21,946
plays an animation to match the movement of the character.

86
00:04:22,805 --> 00:04:27,086
If the game controller wishes to move the character forward at a certain speed,

87
00:04:27,086 --> 00:04:29,106
depending on the speed,

88
00:04:29,106 --> 00:04:34,848
a forward moving walk or run animation may be selected and played by the animation system.

89
00:04:34,848 --> 00:04:39,469
The key point is that animation does not control or dictate the motion in any way.

90
00:04:39,469 --> 00:04:44,610
The animations could be thought of as well authored on spot.

91
00:04:44,610 --> 00:04:49,231
Using this has some advantages. It provides us with the maximum level of flexibility

92
00:04:49,231 --> 00:04:51,671
as it drives the character independent of the animation.

93
00:04:52,617 --> 00:04:59,719
Motion as well remains highly responsive as we're completely in control.

94
00:04:59,719 --> 00:05:03,121
Alternatively, some games use animation-driven movement, and you guessed it.

95
00:05:03,121 --> 00:05:08,523
In this case, the motion of the character is driven completely by the animation.

96
00:05:08,523 --> 00:05:12,445
Motion itself is also authored as part of the animation.

97
00:05:14,255 --> 00:05:17,496
So we do this through the use of a reference node.

98
00:05:17,496 --> 00:05:20,817
In our system, we refer to this as the root node.

99
00:05:20,817 --> 00:05:24,138
And it sits at the highest point in the skeleton hierarchy.

100
00:05:24,138 --> 00:05:26,819
The root node is an independent bone

101
00:05:26,819 --> 00:05:29,540
and represents the displacement and rotation

102
00:05:29,540 --> 00:05:32,081
of the character's motion during the animation.

103
00:05:32,081 --> 00:05:34,682
The animation itself will contain the transform data

104
00:05:34,682 --> 00:05:36,903
for this bone for every single frame,

105
00:05:36,903 --> 00:05:38,904
just like it would for any other bone.

106
00:05:40,902 --> 00:05:44,683
We generally place this under the hips of the character throughout the animation,

107
00:05:44,683 --> 00:05:46,464
and it can be hand-authored by the animator.

108
00:05:46,464 --> 00:05:49,945
So, in order to move the character in the game,

109
00:05:49,945 --> 00:05:52,506
we need to extract this root motion data out,

110
00:05:52,506 --> 00:05:54,646
and then apply it to the character.

111
00:05:54,646 --> 00:05:57,507
So in this simple example of a walk,

112
00:05:57,507 --> 00:06:00,448
every frame, we simply update the animation

113
00:06:00,448 --> 00:06:04,029
and read the delta displacement or rotations for the root,

114
00:06:04,029 --> 00:06:06,490
which then basically moves the character in the game.

115
00:06:07,657 --> 00:06:13,158
And we refer to this sort of extraction as the extracted motion of the animation.

116
00:06:13,158 --> 00:06:17,559
Animation driven movement certainly has some advantages.

117
00:06:17,559 --> 00:06:23,840
Our characters now look the best, since the movement is updated exactly as it was authored.

118
00:06:23,840 --> 00:06:28,341
The visual representation of the character now matches one to one with the motion.

119
00:06:28,341 --> 00:06:32,262
And it maintains the intentions of the authored content.

120
00:06:33,549 --> 00:06:37,111
A lot of games have now moved over to use this approach in the last few years.

121
00:06:37,111 --> 00:06:42,233
And while it's improved the visual aspects of gameplay, there's some costs.

122
00:06:42,233 --> 00:06:48,735
Our characters now start to feel a little bit unresponsive, both in terms of performing

123
00:06:48,735 --> 00:06:50,656
and controlling an action.

124
00:06:50,656 --> 00:06:53,477
We're now tied sort of to the animation.

125
00:06:53,477 --> 00:06:58,619
And don't get me wrong, some games can totally get away with this if they're slow-paced enough,

126
00:06:58,619 --> 00:07:02,041
and precision and responsiveness isn't that big of an issue.

127
00:07:04,518 --> 00:07:09,039
So, in our case, we're after the fidelity of animation-driven movement,

128
00:07:09,039 --> 00:07:11,400
but to maintain character responsiveness,

129
00:07:11,400 --> 00:07:15,261
our character can't always be fully animation-driven.

130
00:07:15,261 --> 00:07:18,602
In addition, heavily using animation-driven movement

131
00:07:18,602 --> 00:07:21,463
would mean that we need a lot of animation coverage

132
00:07:21,463 --> 00:07:23,323
to account for all the varying use cases

133
00:07:23,323 --> 00:07:26,384
that we encounter in a game like Just Cause 3.

134
00:07:26,384 --> 00:07:29,525
So here we're looking for the balance between these two worlds,

135
00:07:29,525 --> 00:07:32,746
and what we want to do is we want to use the best of both of them together.

136
00:07:35,382 --> 00:07:37,363
So let's quickly dive into representing motion.

137
00:07:37,363 --> 00:07:39,604
Here's a frame of a backpedal animation.

138
00:07:39,604 --> 00:07:44,326
The red arrow here shows the facing direction of the character in world space.

139
00:07:44,326 --> 00:07:47,488
The yellow arrow here shows the moving direction of the character.

140
00:07:47,488 --> 00:07:49,349
Since this is a backpedal, they're opposite.

141
00:07:49,349 --> 00:07:53,251
And finally, we come to speed.

142
00:07:53,251 --> 00:07:56,352
The speed at which the character moves or rotates

143
00:07:56,352 --> 00:07:59,353
will result in the change in displacement

144
00:07:59,353 --> 00:08:02,335
or orientation of the character, as you can see in this video,

145
00:08:02,335 --> 00:08:03,515
as he's backpedaling backwards.

146
00:08:07,132 --> 00:08:14,073
In our system, we can independently update each of these components using different combinations

147
00:08:14,073 --> 00:08:19,495
of these movement models, often midway through the animation.

148
00:08:19,495 --> 00:08:26,017
We also often found that any given use case required its own combination of updating these

149
00:08:26,017 --> 00:08:27,557
components in sort of slightly different ways.

150
00:08:27,557 --> 00:08:35,079
So to do this, one of the techniques we heavily rely on is what we call motion correction.

151
00:08:36,830 --> 00:08:43,254
When updating any of the components of motion, each of our states and even animations within them

152
00:08:43,254 --> 00:08:48,297
can decide which of these components will be either fully driven by the animation's extracted

153
00:08:48,297 --> 00:08:53,400
motion, which of them will be adjusted or corrected, or which of them will be completely

154
00:08:53,400 --> 00:08:57,623
overridden by the game itself. This is what we mean by motion correction.

155
00:08:59,005 --> 00:09:04,967
A fundamental point we rely on is the importance of decoupling the animation's extracted motion

156
00:09:04,967 --> 00:09:07,207
from the animation's pose update.

157
00:09:07,207 --> 00:09:11,908
In other words, instead of directly updating physics with the animation's motion when it's

158
00:09:11,908 --> 00:09:15,389
updated, we need to separate the two and then do this independently.

159
00:09:15,389 --> 00:09:21,490
Now this enables us to modify the extracted motion independent of the animation and then

160
00:09:21,490 --> 00:09:27,231
correct it in order for us, in order for it to suit our game-specific need.

161
00:09:27,231 --> 00:09:27,512
Alright.

162
00:09:27,953 --> 00:09:32,998
So you may think, well if we're already adjusting, we're already overriding the motion,

163
00:09:32,998 --> 00:09:36,321
then why use the extracted motion to correct it?

164
00:09:36,321 --> 00:09:38,222
And why can't we just control the character?

165
00:09:38,222 --> 00:09:42,686
And the key reason here is we want to limit these adjustments

166
00:09:42,686 --> 00:09:46,230
and corrections to be based on the extracted motion as much as possible.

167
00:09:46,230 --> 00:09:50,533
And this will help us preserve the integrity of that original content.

168
00:09:51,425 --> 00:09:56,049
We use these motion correction techniques not only to maintain animation fidelity,

169
00:09:56,049 --> 00:10:00,893
but also to increase animation coverage and keep our motion responsive.

170
00:10:00,893 --> 00:10:06,317
So here's an example of one of our simpler character updates.

171
00:10:06,317 --> 00:10:10,360
And I say typical because it's not always the case,

172
00:10:10,360 --> 00:10:14,203
but generally speaking, the first thing we'll do is gather input.

173
00:10:14,203 --> 00:10:18,526
We do a little bit of motion evaluation to determine what's exactly required.

174
00:10:19,270 --> 00:10:24,431
And then we decouple this. We sample the animation separately, and we extract the motion separately.

175
00:10:24,431 --> 00:10:29,532
After that, based on our evaluation, an additional step is performed to either adjust and correct

176
00:10:29,532 --> 00:10:33,053
the extracted motion based on that evaluation, if we need to do so.

177
00:10:33,053 --> 00:10:38,714
We can then push that over to physics, and if no adjustment or correction is made, you

178
00:10:38,714 --> 00:10:43,255
can think that the character is being fully animation-driven.

179
00:10:43,889 --> 00:10:48,052
If we ignore all the extracted motion and simply move the character ourselves,

180
00:10:48,052 --> 00:10:49,673
then the character is fully game-driven.

181
00:10:49,673 --> 00:10:54,017
Now, as I mentioned, this is a rather typical character update.

182
00:10:54,017 --> 00:10:57,920
We're not limited to doing these corrections before physics by any means.

183
00:10:57,920 --> 00:11:03,164
We have cases where we apply motion correction in various stages of the character frame,

184
00:11:03,164 --> 00:11:07,688
including post-physics, for things like interacting with a moving object.

185
00:11:07,688 --> 00:11:11,911
But just to get the point across, this is an example of one of our simpler character updates.

186
00:11:13,837 --> 00:11:18,920
Alright, so in this next section, I'd like to go over how we use these ideas to realize

187
00:11:18,920 --> 00:11:23,523
our players on-ground movement, looking at some of the typical use cases like starting

188
00:11:23,523 --> 00:11:28,327
to move, stopping and interrupting, and maintaining movement.

189
00:11:28,327 --> 00:11:32,810
It's also worth mentioning that for the purpose of this presentation, we're going to focus

190
00:11:32,810 --> 00:11:34,511
on ground movement.

191
00:11:34,511 --> 00:11:36,893
However, these techniques are not limited to just that.

192
00:11:36,893 --> 00:11:41,896
We've used these techniques throughout realizing a lot of our other character feature sets

193
00:11:41,896 --> 00:11:42,296
as well.

194
00:11:45,686 --> 00:11:50,468
Let's start off by talking about starting to move.

195
00:11:50,468 --> 00:11:55,710
In the case of starting to move, we use transition animations as a way to move the player from

196
00:11:55,710 --> 00:11:57,270
an idle stance.

197
00:11:57,270 --> 00:12:00,511
Now the reasons for this are obvious, if you see in the video.

198
00:12:00,511 --> 00:12:06,294
Animations like this play a big role in visually conveying energy, anticipation, and acceleration

199
00:12:06,294 --> 00:12:09,335
that are needed to get a character to move from an idle stance.

200
00:12:10,452 --> 00:12:15,656
However, we still need to support moving in 360 degrees

201
00:12:15,656 --> 00:12:20,500
in terms of direction and towards varying target speeds.

202
00:12:20,500 --> 00:12:24,283
So from a gameplay perspective, we also want this input

203
00:12:24,283 --> 00:12:25,904
that the player would provide

204
00:12:25,904 --> 00:12:27,986
to feel very immediate and precise.

205
00:12:27,986 --> 00:12:32,369
One way to tackle the visual concerns

206
00:12:32,369 --> 00:12:35,191
would be to simply drive each component,

207
00:12:35,191 --> 00:12:37,753
speed, displacement, and orientation of the character

208
00:12:37,753 --> 00:12:39,595
completely animation-driven.

209
00:12:40,476 --> 00:12:45,459
We tried this approach, and things quickly got sluggish and unresponsive as we became

210
00:12:45,459 --> 00:12:46,980
bound by the physicality of our content.

211
00:12:46,980 --> 00:12:52,624
Especially accelerating to something like your top target speed is going to take time,

212
00:12:52,624 --> 00:12:53,905
and that was too slow for the game.

213
00:12:53,905 --> 00:13:00,849
Also, a given start animation can only rotate the character by a fixed amount.

214
00:13:00,849 --> 00:13:05,853
This made it feel like the character wasn't going in the direction we wanted, especially

215
00:13:05,853 --> 00:13:08,334
if the pad input didn't match up with that authored animation.

216
00:13:09,067 --> 00:13:14,030
In addition, while the animation is still finishing, we feel this, you know, feeling

217
00:13:14,030 --> 00:13:15,290
of being stuck in that direction.

218
00:13:15,290 --> 00:13:21,774
In this case, you can try to add more start animations to cover more angles, and then

219
00:13:21,774 --> 00:13:26,618
you need to account for all the different weapons, different speeds, and then your content

220
00:13:26,618 --> 00:13:28,138
starts to grow.

221
00:13:28,138 --> 00:13:31,981
Another approach could be try to blend all these animations together to create more coverage.

222
00:13:33,480 --> 00:13:42,123
Here we've got a decent starting to run in a zero degree direction, start to run forward.

223
00:13:42,123 --> 00:13:47,485
And here's another animation that starts the character to run at 90 degrees to the left.

224
00:13:47,485 --> 00:13:52,426
Now on their own, both these animations look fairly decent.

225
00:13:52,426 --> 00:13:57,168
When we blend them together to get additional coverage, CF45, things start to look a little

226
00:13:57,168 --> 00:13:57,588
funky.

227
00:13:58,557 --> 00:14:08,924
Now this is clearly an exaggeration, but too often we use this idea of persistently blending animations together for ground-based movement, and that comes with a set of limitations.

228
00:14:08,924 --> 00:14:21,654
If you've ever worked with animation, you know that each animation includes a wide range of subtlety and body movement, and stride, which is the distance between each step when you move.

229
00:14:21,654 --> 00:14:24,576
In order to ensure that these animations blend well,

230
00:14:25,055 --> 00:14:28,436
Usually, you know, you have to make your animator really unhappy

231
00:14:28,436 --> 00:14:33,839
and have him or her heavily dampen or eliminate all these subtleties.

232
00:14:33,839 --> 00:14:38,561
In some cases, the animations need to be authored with the same number of footsteps,

233
00:14:38,561 --> 00:14:42,603
which limits us both from a stylistic and a motion capture perspective.

234
00:14:42,603 --> 00:14:48,266
So this is something we wanted to limit for our on-ground movement,

235
00:14:48,266 --> 00:14:51,648
especially because footsteps, weight, and movement are so tied together.

236
00:14:53,482 --> 00:14:55,243
So here's the technique we use.

237
00:14:55,243 --> 00:14:58,625
It revolves around combining these movement models

238
00:14:58,625 --> 00:15:01,408
and using motion correction all within the same animation.

239
00:15:01,408 --> 00:15:06,151
So the first thing we do is identify these key segments

240
00:15:06,151 --> 00:15:07,973
of our animation.

241
00:15:07,973 --> 00:15:11,315
So here's an example of the start

242
00:15:11,315 --> 00:15:13,497
going from an idle to a run in 180 degrees.

243
00:15:13,497 --> 00:15:16,039
If we step frame by frame, we can

244
00:15:16,039 --> 00:15:19,661
see that the first part of the animation

245
00:15:19,661 --> 00:15:21,483
includes the character actually turning

246
00:15:21,483 --> 00:15:23,264
to face the direction that he wants to go in.

247
00:15:24,295 --> 00:15:26,877
And we can, looking at this, we can basically say,

248
00:15:26,877 --> 00:15:28,939
OK, well this is our turning to face segment.

249
00:15:28,939 --> 00:15:31,961
If we zip back a bit, we can also

250
00:15:31,961 --> 00:15:35,704
see that around midway through the segment,

251
00:15:35,704 --> 00:15:37,666
the character's pushing off his right foot,

252
00:15:37,666 --> 00:15:40,288
and he's starting to move.

253
00:15:40,288 --> 00:15:43,490
And he continues to do this all the way

254
00:15:43,490 --> 00:15:46,893
until the end of the animation, as this is a start to move.

255
00:15:46,893 --> 00:15:49,795
So we can refer to this as our moving section.

256
00:15:49,795 --> 00:15:51,656
So there's a couple of things that

257
00:15:51,656 --> 00:15:53,438
are going on in this one start animation.

258
00:15:54,822 --> 00:15:56,583
Finally, as this is a start again,

259
00:15:56,583 --> 00:15:59,786
he's also accelerating to get up to that target speed.

260
00:15:59,786 --> 00:16:03,888
And the idea we use is during each of these segments,

261
00:16:03,888 --> 00:16:05,570
we can update the components of motion

262
00:16:05,570 --> 00:16:08,872
differently to help alleviate some of the issues

263
00:16:08,872 --> 00:16:10,053
we mentioned before.

264
00:16:10,053 --> 00:16:15,156
So the first thing to look at is creating more coverage

265
00:16:15,156 --> 00:16:16,857
and giving the player a sense of control

266
00:16:16,857 --> 00:16:19,139
without having to sort of persistently blend

267
00:16:19,139 --> 00:16:21,060
those animations together.

268
00:16:21,060 --> 00:16:23,482
To do this, during the turning to face segment,

269
00:16:24,174 --> 00:16:27,237
we can correct the facing angle of the character.

270
00:16:27,237 --> 00:16:31,620
First, we extract the rotation out of the animation,

271
00:16:31,620 --> 00:16:33,402
and then we correct that rotation

272
00:16:33,402 --> 00:16:35,784
to give us the target direction we need.

273
00:16:35,784 --> 00:16:38,766
And this is done by performing a fixed adjustment

274
00:16:38,766 --> 00:16:42,169
to the rotation after the animation's rotation is

275
00:16:42,169 --> 00:16:43,490
extracted every frame.

276
00:16:43,490 --> 00:16:46,873
So let's see an example of how this works.

277
00:16:46,873 --> 00:16:48,855
At the beginning of our turning to face segment,

278
00:16:48,855 --> 00:16:50,376
we've got our character facing forward.

279
00:16:51,573 --> 00:16:56,795
At the end, he's rotated an entire 180 degrees, as authored.

280
00:16:56,795 --> 00:17:00,316
Well, what if the player doesn't want to go directly behind,

281
00:17:00,316 --> 00:17:03,837
and he or she chooses to move the character 150 degrees instead?

282
00:17:03,837 --> 00:17:05,898
All right.

283
00:17:05,898 --> 00:17:09,339
Well, using the same animation, we just need to account for the delta

284
00:17:09,339 --> 00:17:13,060
between the rotation amount from the extracted motion

285
00:17:13,060 --> 00:17:14,521
and the intended target direction.

286
00:17:15,778 --> 00:17:20,580
To account for this delta, you can either add or subtract it out from the extracted rotation

287
00:17:20,580 --> 00:17:25,142
over the course of the turning to face segment, while keeping that movement target fixed.

288
00:17:25,142 --> 00:17:31,205
So in this case, since the extracted rotation is going to overshoot, we need to subtract this delta out.

289
00:17:31,205 --> 00:17:38,848
It's important to split this delta into even rotational corrections over the course of this segment,

290
00:17:38,848 --> 00:17:42,150
to limit any slide or adjustment that the player might notice.

291
00:17:43,703 --> 00:17:49,088
So, on each frame, we extract the animation rotation, and we correct it by that fixed

292
00:17:49,088 --> 00:17:54,352
adjustment that's been calculated and is now evenly being distributed on each frame to

293
00:17:54,352 --> 00:17:56,334
account for the overall delta.

294
00:17:56,334 --> 00:18:02,459
We keep doing this, and by the end of the rotation segment, since we've evenly corrected

295
00:18:02,459 --> 00:18:03,000
out that delta,

296
00:18:03,940 --> 00:18:07,324
the character will end up facing the direction of his or her intention,

297
00:18:07,324 --> 00:18:10,927
even though the extracted rotation was a full 180 degrees.

298
00:18:10,927 --> 00:18:12,809
And this takes care of the facing angle,

299
00:18:12,809 --> 00:18:14,771
or the facing direction of the character,

300
00:18:14,771 --> 00:18:16,613
during the turning-to-face segment.

301
00:18:16,613 --> 00:18:19,076
Well, what about the moving direction

302
00:18:19,076 --> 00:18:20,958
during the turning-to-face segment?

303
00:18:22,310 --> 00:18:25,211
We can see that there is a little bit of a moving portion

304
00:18:25,211 --> 00:18:28,293
that overlaps between the turning to face segment,

305
00:18:28,293 --> 00:18:30,133
and then it continues all the way after,

306
00:18:30,133 --> 00:18:33,175
like we noticed when we saw the animation

307
00:18:33,175 --> 00:18:34,215
be played frame by frame.

308
00:18:36,239 --> 00:18:41,983
Well during this overlap, we simply override the moving direction

309
00:18:41,983 --> 00:18:45,726
to be the same as the target pad at the time of playing the start.

310
00:18:45,726 --> 00:18:49,468
Now this means we don't have to worry about the compensation we're doing

311
00:18:49,468 --> 00:18:52,230
for, or we don't have to worry about compensating

312
00:18:52,230 --> 00:18:54,391
for the correction we're doing in the facing direction.

313
00:18:55,573 --> 00:18:59,255
By updating the facing and moving directions independently,

314
00:18:59,255 --> 00:19:01,236
we can start to move the character sooner

315
00:19:01,236 --> 00:19:04,217
in the direction we want, even if he hasn't fully

316
00:19:04,217 --> 00:19:06,057
rotated to face that direction yet.

317
00:19:06,057 --> 00:19:09,639
We'll see an instance of this a little bit later.

318
00:19:09,639 --> 00:19:12,580
Well, after the turn to face segment is done,

319
00:19:12,580 --> 00:19:13,920
the start isn't finished yet.

320
00:19:13,920 --> 00:19:16,101
The character still needs to continue

321
00:19:16,101 --> 00:19:18,782
to ramp up to get up to that moving target speed.

322
00:19:18,782 --> 00:19:22,063
During this time, we still need to update the facing

323
00:19:22,063 --> 00:19:23,584
and moving directions of the character.

324
00:19:24,950 --> 00:19:28,511
Since there's no more rotation that's coming out of the extracted motion,

325
00:19:28,511 --> 00:19:31,431
the character is displacing in the direction he's facing

326
00:19:31,431 --> 00:19:33,312
for the remainder of the animation.

327
00:19:33,312 --> 00:19:37,673
To control this, we simply override the facing and moving directions

328
00:19:37,673 --> 00:19:41,194
to now be fully game-driven, to match that of the target direction.

329
00:19:41,194 --> 00:19:46,075
So as the player decides to move the pad in another direction,

330
00:19:46,075 --> 00:19:48,815
we procedurally override the facing angle

331
00:19:48,815 --> 00:19:50,696
and implicitly the moving direction

332
00:19:50,696 --> 00:19:52,896
to match that of the intended direction of the pad.

333
00:19:53,725 --> 00:19:59,386
Now we don't want to override this instantly, as this would be visually jarring and unrealistic.

334
00:19:59,386 --> 00:20:04,768
So we smoothly drive the current phasing direction to match that of the target, and we do this

335
00:20:04,768 --> 00:20:09,949
by defining a range of authorable angular acceleration rates.

336
00:20:09,949 --> 00:20:15,390
These rates define how fast this current orientation will become that of the requested pad direction.

337
00:20:18,974 --> 00:20:24,675
These, these rates that I talk about are meant simply to match the responsiveness needs,

338
00:20:24,675 --> 00:20:28,376
as well as keep things consistent across all ground movement.

339
00:20:28,376 --> 00:20:32,077
But you can use different rates to match different situations in the game.

340
00:20:32,077 --> 00:20:36,958
For example, if you're just moving about, you can use a rather responsive sort of curve

341
00:20:36,958 --> 00:20:37,778
or rate.

342
00:20:37,778 --> 00:20:41,079
And if you're doing something like landing from your parachute and then going into a

343
00:20:41,079 --> 00:20:44,980
run, we can reduce the responsiveness to better match up with that of the animation.

344
00:20:45,936 --> 00:20:51,920
You can also choose to use whatever smoothening algorithm you want in these situations.

345
00:20:51,920 --> 00:20:57,964
Overall, this gives us a better responsiveness and control as we can continue to steer the

346
00:20:57,964 --> 00:21:02,727
character in the direction we want without having to interrupt the start early.

347
00:21:02,727 --> 00:21:07,651
And this allows the start to visually settle into movement, which is what, you know, sometimes

348
00:21:07,651 --> 00:21:11,453
you reach the end and you're like, let's just cut everything to make it responsive.

349
00:21:11,453 --> 00:21:12,294
We want to prevent that.

350
00:21:15,160 --> 00:21:16,943
Now this brings us to our last point.

351
00:21:16,943 --> 00:21:19,526
The responsiveness in displacement

352
00:21:19,526 --> 00:21:21,848
is going to be linked to how fast the character can

353
00:21:21,848 --> 00:21:22,309
be displaced.

354
00:21:22,309 --> 00:21:27,055
As you can see in this slide, in the original authored animation,

355
00:21:27,055 --> 00:21:29,658
the character isn't really moving for a good chunk of time

356
00:21:29,658 --> 00:21:30,298
in the beginning.

357
00:21:32,187 --> 00:21:35,289
Well, what we really want to do is we want to translate the character sooner.

358
00:21:35,289 --> 00:21:38,731
We want to extend out this translation or displacement segment.

359
00:21:38,731 --> 00:21:42,833
This will alleviate the feelings of being sluggish, but still cont, and, but,

360
00:21:42,833 --> 00:21:47,275
but still allow us to control when this can actually happen.

361
00:21:47,275 --> 00:21:51,178
Since we're already managing the direction of moving during and

362
00:21:51,178 --> 00:21:53,559
after that sort of turn into face segment,

363
00:21:53,559 --> 00:21:55,980
we know exactly where we want to translate the character.

364
00:21:56,977 --> 00:22:01,859
Now it's also important to note that you don't want to extend this moving segment too far out,

365
00:22:01,859 --> 00:22:05,120
beyond, or, you know, sooner than the turning to face segment.

366
00:22:05,120 --> 00:22:10,963
And the reason for this is you want to kind of piggyback off the animation's visual movement

367
00:22:10,963 --> 00:22:14,345
to hide the fact that we're starting to move the character sooner

368
00:22:14,345 --> 00:22:15,965
than what the animation actually intends.

369
00:22:15,965 --> 00:22:19,947
So, to do this, we need to control the rate of movement,

370
00:22:19,947 --> 00:22:22,828
that is the speed of the character in this case.

371
00:22:24,216 --> 00:22:28,017
For our starts, we do this by overriding the speed of the character via the game,

372
00:22:28,017 --> 00:22:30,858
and evaluate the speed using authorable acceleration curves,

373
00:22:30,858 --> 00:22:32,659
as opposed to that of the animation.

374
00:22:32,659 --> 00:22:38,080
So here we have an acceleration curve from the start animation, it's just an example.

375
00:22:38,080 --> 00:22:45,022
And we can see that the animation begins to move the character with a little bit of a delay.

376
00:22:45,022 --> 00:22:48,623
It might be turning to face, it might be doing whatever it needs to do.

377
00:22:48,623 --> 00:22:52,525
And also, it only reaches a target speed of roughly 3.4 meters per second.

378
00:22:53,296 --> 00:22:57,561
Alright, well let's say our in-game run speed is 4 point meters per second.

379
00:22:57,561 --> 00:23:03,207
We now author an acceleration curve that moves the character 1 faster to get responsiveness,

380
00:23:03,207 --> 00:23:08,773
and also better match up to the target speed, which is going to be variable and change over

381
00:23:08,773 --> 00:23:09,794
the course of your project.

382
00:23:09,794 --> 00:23:12,757
You can keep on reshooting and reworking your content.

383
00:23:13,597 --> 00:23:19,741
These curves are live tunable and are often based on the animation's authored acceleration curve to begin with,

384
00:23:19,741 --> 00:23:22,723
to limit inconsistency that the player again might notice,

385
00:23:22,723 --> 00:23:26,866
since we're overriding the speed from the animation during the start.

386
00:23:26,866 --> 00:23:30,329
Surprisingly, we were able to hide this adjustment,

387
00:23:30,329 --> 00:23:35,493
since the animation that's playing is still conveying the visual intention of the character.

388
00:23:35,493 --> 00:23:37,915
To further help with that fact...

389
00:23:38,638 --> 00:23:42,820
You know, the fact that we're moving the character faster or slower than the animation,

390
00:23:42,820 --> 00:23:51,126
depending on whatever this game curve decides, we apply a technique to visually match the animation's pose to hide this difference.

391
00:23:51,126 --> 00:23:57,289
This is done by correcting the animation's playback rate to match the difference in speed.

392
00:23:57,289 --> 00:24:03,733
Now, since the pose and motion updates are completely independent, we can do this without it affecting the displacement.

393
00:24:05,993 --> 00:24:11,475
When we apply this visual speed correction, we need to use a reference speed that determines

394
00:24:11,475 --> 00:24:16,577
how much to scale the playback rate of the animation. In the case of starts, the target

395
00:24:16,577 --> 00:24:21,759
speed of each authored animation becomes the reference speed. So this goes back to that idea

396
00:24:21,759 --> 00:24:27,741
of using your animation's extracted motion and the way it's authored to influence how you're

397
00:24:27,741 --> 00:24:33,363
going to correct it. This reference speed now becomes the base for how we're actually going

398
00:24:33,363 --> 00:24:34,223
to correct the starts.

399
00:24:36,240 --> 00:24:41,362
In this case, since the target speed is higher than that of the author start animation,

400
00:24:41,362 --> 00:24:43,303
we simply play the animation that much faster.

401
00:24:43,303 --> 00:24:48,985
Here, the playback rate is going to be adjusted to be 1.17 times.

402
00:24:48,985 --> 00:24:52,667
And this is done, again, to be within an acceptable range

403
00:24:52,667 --> 00:24:56,448
to ensure that the animation doesn't look too sped up or too slowed down.

404
00:24:56,448 --> 00:25:00,070
So here we have it all put together in game.

405
00:25:00,808 --> 00:25:04,150
You'll notice the player pad input being displayed on the top right corner,

406
00:25:04,150 --> 00:25:06,070
along with the pad target direction in yellow,

407
00:25:06,070 --> 00:25:10,312
and the current orientation of the character shown in red.

408
00:25:10,312 --> 00:25:15,254
You can kind of see that while he's playing these transition animations and starts,

409
00:25:15,254 --> 00:25:20,316
he's still pretty responsive, and you can still see, you know, good visual intention,

410
00:25:20,316 --> 00:25:28,859
good animation of him moving in the direction he wants.

411
00:25:28,859 --> 00:25:29,819
Here's a closer look.

412
00:25:30,488 --> 00:25:38,411
And to quickly recap, we're updating the orientation direction of our character using animation and motion correcting the rotation,

413
00:25:38,411 --> 00:25:41,332
while the displacement direction remains game-driven,

414
00:25:41,332 --> 00:25:44,452
after which both directions switch to being game-driven,

415
00:25:44,452 --> 00:25:48,794
and speed is completely game-driven using visual speed correction.

416
00:25:48,794 --> 00:25:53,355
We're able to get 360 degrees of coverage using just five animations, a 0, 290s, and 2180s,

417
00:25:53,355 --> 00:25:57,956
and on the NPC side, we're able to get away with just using three.

418
00:25:59,794 --> 00:26:03,858
It's important to note that we also drive all our plant and turn animations,

419
00:26:03,858 --> 00:26:06,720
as well as all our rotate on spots using these techniques

420
00:26:06,720 --> 00:26:09,202
with slightly different combinations and variations.

421
00:26:09,940 --> 00:26:13,944
And you're not limited to just using this fixed adjustment either.

422
00:26:13,944 --> 00:26:19,448
We use dynamic adjustment to deal with aligning to a moving target, for example.

423
00:26:19,448 --> 00:26:22,570
Or you're not limited to using this adjustment to just rotation.

424
00:26:22,570 --> 00:26:27,875
We use adjustments like this that are split across the entire animation to fix up translation

425
00:26:27,875 --> 00:26:31,698
or displacement as well, to end up on a very specific spot, for example.

426
00:26:33,670 --> 00:26:37,796
All right, talking about stopping or landing on a spot,

427
00:26:37,796 --> 00:26:40,620
in this next section, we'll turn our attention

428
00:26:40,620 --> 00:26:41,761
to interruptions and stops.

429
00:26:42,847 --> 00:26:47,828
The motivation for stop realization in the game is very similar to that of the starts.

430
00:26:47,828 --> 00:26:52,430
You know, stops will give the player immediate feedback of releasing the pad, and will communicate

431
00:26:52,430 --> 00:26:58,152
the deceleration and the character's intention, especially when moving at a high speed.

432
00:26:58,152 --> 00:27:04,594
Now in Just Cause 3, the need to stop responsively and with extra precision was uber important.

433
00:27:04,594 --> 00:27:07,895
The design of our world is extremely vertical.

434
00:27:08,742 --> 00:27:11,706
And the gameplay sort of is based around that.

435
00:27:11,706 --> 00:27:13,829
So we need Rico to stop on a dime

436
00:27:13,829 --> 00:27:15,812
when the player decides to release his pad,

437
00:27:15,812 --> 00:27:17,654
even from a run.

438
00:27:17,654 --> 00:27:19,697
Primarily, we want to do this to ensure that the player

439
00:27:19,697 --> 00:27:21,940
doesn't unintentionally get in a situation

440
00:27:21,940 --> 00:27:24,283
where he falls off things, especially in combat,

441
00:27:24,283 --> 00:27:25,585
which can be uber frustrating.

442
00:27:27,203 --> 00:27:31,585
So as Alex will attest to, stopping on a dime is an animator's nightmare.

443
00:27:31,585 --> 00:27:35,465
It's both physically unrealistic and visually unnatural.

444
00:27:35,465 --> 00:27:40,247
If you're using motion capture data, you know, and you want to capture this deceleration,

445
00:27:40,247 --> 00:27:45,428
the data will always have significant motion in it.

446
00:27:45,428 --> 00:27:49,789
In addition to all these issues, we need to deal with stopping from various speeds,

447
00:27:49,789 --> 00:27:52,810
differences in pose, and turning while stopping as well.

448
00:27:53,987 --> 00:27:55,528
So in the case of stopping instantly,

449
00:27:55,528 --> 00:28:00,251
our first approach was to ignore all the extracted motion from the animation.

450
00:28:00,251 --> 00:28:03,574
While this ensured that the character would insta-stop,

451
00:28:03,574 --> 00:28:05,215
it just felt pretty visually jarring.

452
00:28:05,215 --> 00:28:09,578
Kind of pops.

453
00:28:12,637 --> 00:28:18,304
So what we ended up doing was updating the moving direction and speed to be driven via the animation,

454
00:28:18,304 --> 00:28:22,449
which includes a very harsh deceleration curve to convey the change in momentum.

455
00:28:22,449 --> 00:28:26,454
And we could have done this in the game as well, but it would have been very, you know,

456
00:28:26,454 --> 00:28:30,338
pretty much the same thing because we're trying to, you know, get the character to stop very quickly.

457
00:28:31,534 --> 00:28:35,736
Since we didn't want to add extra coverage for all the slight differences in speed,

458
00:28:35,736 --> 00:28:39,918
we play the same stop animation from a general speed range

459
00:28:39,918 --> 00:28:44,560
and account for any differences by using the visual speed correction, similar to the starts.

460
00:28:44,954 --> 00:28:49,076
In this case, though, we correct the animation's playback rate

461
00:28:49,076 --> 00:28:51,997
to match up with the urgency of the current speed

462
00:28:51,997 --> 00:28:54,998
against the initial speed of the stop animation, which

463
00:28:54,998 --> 00:28:56,939
now becomes our reference speed.

464
00:28:56,939 --> 00:28:58,260
So in the case of the starts, we're

465
00:28:58,260 --> 00:29:00,981
using the authored start's target speed

466
00:29:00,981 --> 00:29:02,261
as a reference speed.

467
00:29:02,261 --> 00:29:04,182
But in the case of stops, we're using

468
00:29:04,182 --> 00:29:07,483
the stop authored initial speed as a reference speed.

469
00:29:09,590 --> 00:29:15,232
Finally, the facing direction of the character was corrected similar to the starts, using the fixed adjustment.

470
00:29:15,232 --> 00:29:19,493
And this was necessary when we need Rico to stop and turn at the same time,

471
00:29:19,493 --> 00:29:23,314
and he needs to maintain aiming at a target, for example, while stopping.

472
00:29:23,314 --> 00:29:30,435
On updating the character this way, we began to encounter some blending issues that are worth noting.

473
00:29:31,207 --> 00:29:33,992
Now, these blending issues aren't limited to just the stop case.

474
00:29:33,992 --> 00:29:39,382
They affect all situations where we're relying on the animation's extracted motion

475
00:29:39,382 --> 00:29:43,309
to be used as a basis for correction or analysis.

476
00:29:44,870 --> 00:29:48,092
So the issue is this, that when we transition from one state to another,

477
00:29:48,092 --> 00:29:53,295
and we're using a transition blend, the root's transform data begins to blend as well,

478
00:29:53,295 --> 00:29:55,536
since we just treated like a regular bone.

479
00:29:55,536 --> 00:30:00,299
So in this case, we really want to exclude this blended displacement of the root

480
00:30:00,299 --> 00:30:03,281
of the previous cycle as it continues to blend out.

481
00:30:03,281 --> 00:30:10,506
Otherwise, the character still displaces forward as we're using animation-driven movement here.

482
00:30:10,506 --> 00:30:13,348
And that's not what we want. We want him to stop on spot.

483
00:30:14,944 --> 00:30:17,586
So this could be fixed by simply setting the blend time to 0,

484
00:30:17,586 --> 00:30:19,987
from the movement cycle to the stop.

485
00:30:19,987 --> 00:30:25,391
However, a transition blend of 0, again something animators hate,

486
00:30:25,391 --> 00:30:27,072
would pop the pose and look jarring,

487
00:30:27,072 --> 00:30:29,813
which is again what we're trying to avoid in the first place.

488
00:30:41,510 --> 00:30:45,072
The decoupling of the pose and motion extraction comes to our rescue again.

489
00:30:45,072 --> 00:30:49,274
Here we extend the idea to blend the animation poses

490
00:30:49,274 --> 00:30:54,717
and the extracted motion separately using different blend rates.

491
00:30:54,717 --> 00:30:58,439
So we blend the pose of the movement cycle with the stop animation as we

492
00:30:58,439 --> 00:31:02,162
normally would, but we do not blend any of the

493
00:31:02,162 --> 00:31:06,364
extracted motion of the movement cycle on evaluation or update. And we call this

494
00:31:06,364 --> 00:31:09,486
pose-only blending. Now this helps create the illusion of

495
00:31:09,486 --> 00:31:10,326
deceleration.

496
00:31:11,245 --> 00:31:14,968
and it alleviates the visual harshness of the sudden transition.

497
00:31:14,968 --> 00:31:17,951
You can also extend this idea to poor bone blending,

498
00:31:17,951 --> 00:31:21,834
where you're using different blend rates for different bone masks,

499
00:31:21,834 --> 00:31:24,055
creating the illusion of motion lag

500
00:31:24,055 --> 00:31:30,841
to, say, blend the upper body and lower body at different rates.

501
00:31:30,841 --> 00:31:33,983
Another key problem we had, and I'm sure most of you have encountered,

502
00:31:33,983 --> 00:31:37,506
is dealing with the mismatch of poses that occurs when interrupting

503
00:31:37,506 --> 00:31:39,868
and transitioning from animation states.

504
00:31:42,259 --> 00:31:49,866
So in the case of our stops, we had to deal with the scissoring of feet that occurs when we have to play a stop animation off phase.

505
00:31:49,866 --> 00:31:56,172
And since we can't wait to play that stop animation, we need to interrupt the cycle at any point to play the stop.

506
00:31:56,172 --> 00:32:02,218
You can see the sort of scissoring that will occur in the feet when that happens.

507
00:32:03,458 --> 00:32:06,300
So you could solve this problem by adding more stop coverage,

508
00:32:06,300 --> 00:32:09,262
more animations to best match up with all those differences

509
00:32:09,262 --> 00:32:09,842
in pose.

510
00:32:09,842 --> 00:32:12,164
But we handle these problems through the use

511
00:32:12,164 --> 00:32:13,725
of a technique called pose matching.

512
00:32:13,725 --> 00:32:16,907
So instead of blending animations based on elapsed

513
00:32:16,907 --> 00:32:20,890
time, we blend the two animations based on pose.

514
00:32:20,890 --> 00:32:23,392
In most moving animations, the pose

515
00:32:23,392 --> 00:32:25,733
can be defined by what we call movement phase.

516
00:32:25,733 --> 00:32:31,638
As the foot goes from being planted to going into an upswing,

517
00:32:32,260 --> 00:32:35,243
and then all the way back down to being planted again,

518
00:32:35,243 --> 00:32:40,007
we can think of the foot as being in a swing cycle from plant to plant.

519
00:32:40,007 --> 00:32:41,569
We do this for both feet.

520
00:32:41,569 --> 00:32:48,955
The movement phase of a foot is then defined as the time where the foot is within its swing cycle between 0 and 1.

521
00:32:48,955 --> 00:32:56,722
And now we can use this information to know where in the next animation we should blend into,

522
00:32:56,722 --> 00:32:59,584
so we can match up the poses for both these transitions.

523
00:33:00,437 --> 00:33:05,283
Now this allows us to have an uneven number of steps within all our movement animations.

524
00:33:05,283 --> 00:33:09,968
With that said, for any given set of animations that you want to use this technique,

525
00:33:09,968 --> 00:33:14,633
you need to define your phase to be based on the feature that you're actually trying to match.

526
00:33:14,633 --> 00:33:17,476
So for example, if you're building some kind of punch animation,

527
00:33:17,476 --> 00:33:22,481
then the phase would not be where you are in your kind of arm swing.

528
00:33:23,948 --> 00:33:28,110
This phase information is generated offline and is stored as metadata,

529
00:33:28,110 --> 00:33:30,691
which keeps our runtime calculations to a minimum.

530
00:33:30,691 --> 00:33:33,952
States can also define whether to apply pose matching

531
00:33:33,952 --> 00:33:36,794
when they blend in and also when they blend out.

532
00:33:36,794 --> 00:33:39,795
And looping animations, for instance, will do this.

533
00:33:39,795 --> 00:33:41,856
They'll pose match on both sort of situations

534
00:33:41,856 --> 00:33:47,058
because they have all the phase match data they need for both left and right feet.

535
00:33:47,714 --> 00:33:54,800
Certain transition animations, however, may only want to pose match when transitioning in or when transitioning out.

536
00:33:54,800 --> 00:34:03,989
And this is necessary because you don't want your pose match to skip the most important parts of your animation.

537
00:34:03,989 --> 00:34:09,575
So now when we apply pose matching, we're able to interrupt and transition seamlessly into the stop animation.

538
00:34:10,401 --> 00:34:19,626
In addition, we can save on additional coverage simply by adding an extra step in that original animation and then just let pose matching blend us in.

539
00:34:19,626 --> 00:34:30,572
All right, since we've talked about transition animations to death, let's turn our attention to maintaining movement.

540
00:34:32,663 --> 00:34:37,066
Unsurprisingly, our core movement animations are authored as looping animations,

541
00:34:37,066 --> 00:34:43,890
where the start and end frames are identical to allow us to play these animations again and again, continuously.

542
00:34:43,890 --> 00:34:47,572
Now, our character needs to be able to accelerate and decelerate,

543
00:34:47,572 --> 00:34:50,174
and best match the movement to the magnitude of the thumbstick.

544
00:34:50,174 --> 00:34:54,896
Since the speed of displacement in these animations is fixed as well,

545
00:34:54,896 --> 00:34:57,238
we need to find a way to vary our movement speed.

546
00:34:59,004 --> 00:35:03,849
One way to tackle this is to drive the speed of our character using animation-driven movement,

547
00:35:03,849 --> 00:35:08,854
map input to animations, and then blend these animations together to create the in-between

548
00:35:08,854 --> 00:35:09,835
coverage we need.

549
00:35:09,835 --> 00:35:12,678
And we all know how we feel about persistent blending.

550
00:35:14,026 --> 00:35:21,528
So also in addition, mapping input directly to these animations sometimes can result in that

551
00:35:21,528 --> 00:35:28,090
slow-mo walk or an extremely sped up run if the player is moving the stick in this analog fashion

552
00:35:28,090 --> 00:35:33,371
and then you're mapping that directly to animation. So in Just Cause 3,

553
00:35:33,371 --> 00:35:38,032
our player character can either walk or run when moving on ground.

554
00:35:39,160 --> 00:35:45,005
And the first thing we choose to do is use discrete target speeds of movement.

555
00:35:45,005 --> 00:35:49,048
What this means is that for given ranges within our pad, between 0 and 1,

556
00:35:49,048 --> 00:35:52,911
the character moves at a set target speed.

557
00:35:52,911 --> 00:35:56,795
For example, if the pad input is between 0 and 0.3, say something like 0.2,

558
00:35:56,795 --> 00:36:02,599
then this maps to a fixed target speed of 1.5 meters per second, which is our walk.

559
00:36:02,599 --> 00:36:04,341
Between 0.3 and 1, for example.

560
00:36:05,358 --> 00:36:08,980
We set a fixed target speed of 5.5 meters per second, which is our run.

561
00:36:08,980 --> 00:36:14,724
Now the key reason for doing this is that in these kind of maintaining movement cases,

562
00:36:14,724 --> 00:36:19,046
we don't need our character to move with the control of the pad in an analog way.

563
00:36:19,046 --> 00:36:21,288
In most games, you rarely need this.

564
00:36:21,288 --> 00:36:25,590
The target speeds we pick are also the speeds we want to support gameplay.

565
00:36:26,528 --> 00:36:30,292
We can then go off and build animations specifically for this,

566
00:36:30,292 --> 00:36:33,636
or shoot motion capture for these specific speeds.

567
00:36:33,636 --> 00:36:37,539
By ensuring that our character is always targeting a core movement speed,

568
00:36:37,539 --> 00:36:41,083
we're trying to ensure that we always get the best visual result.

569
00:36:41,083 --> 00:36:44,586
These target speeds now also become our reference speeds,

570
00:36:44,586 --> 00:36:46,008
which I'll talk about a little bit later.

571
00:36:47,423 --> 00:36:49,985
Even though you're always targeting a core movement speed,

572
00:36:49,985 --> 00:36:55,250
our character still needs to accelerate and decelerate between these speeds.

573
00:36:55,250 --> 00:36:59,813
To do this, we update the speed of translation via the game and not animation.

574
00:36:59,813 --> 00:37:04,377
This speed is evaluated using authorable acceleration and deceleration curves,

575
00:37:04,377 --> 00:37:06,059
similar to how we described in the starts.

576
00:37:06,059 --> 00:37:10,923
And here's an example of the curve in our in-game editor.

577
00:37:10,923 --> 00:37:14,906
We then match up animation using speed ranges.

578
00:37:15,787 --> 00:37:16,947
and we apply correction to them.

579
00:37:16,947 --> 00:37:21,970
So here you can see our target speed set up at 1.5 meters per second

580
00:37:21,970 --> 00:37:23,591
and 5.5 meters per second.

581
00:37:23,591 --> 00:37:25,473
Now no matter where you are on the pad,

582
00:37:25,473 --> 00:37:28,775
our character will be targeting either one of these core speeds.

583
00:37:28,775 --> 00:37:33,458
So we go off, we get our animations, in this case we have a walk and a run.

584
00:37:33,458 --> 00:37:36,920
And now we define speed ranges.

585
00:37:36,920 --> 00:37:40,762
Each speed range is associated with a core movement animation.

586
00:37:41,697 --> 00:37:44,759
In this example, we set up a range between 0 and 3.5

587
00:37:44,759 --> 00:37:47,580
to be associated with our walk.

588
00:37:47,580 --> 00:37:51,602
A range between 2.5 and 5.5 is now associated with our run.

589
00:37:51,602 --> 00:37:55,584
If our player was previously walking

590
00:37:55,584 --> 00:37:58,005
and now jams his pad forward, wanting to run,

591
00:37:58,005 --> 00:38:01,687
based on our acceleration curve, our character

592
00:38:01,687 --> 00:38:04,728
would begin to accelerate and pass from one speed range

593
00:38:04,728 --> 00:38:05,148
into another.

594
00:38:06,603 --> 00:38:10,144
If the character needs to move at a speed that's inside, say, the walk range,

595
00:38:10,144 --> 00:38:14,065
then we simply play the animation that's associated with that range,

596
00:38:14,065 --> 00:38:16,506
but then apply visual speed correction again

597
00:38:16,506 --> 00:38:19,587
to correct the playback rate to match the speed of the character

598
00:38:19,587 --> 00:38:21,167
that's being driven by the game.

599
00:38:21,167 --> 00:38:23,688
The reference speeds that I talked about

600
00:38:23,688 --> 00:38:28,229
are these core target speeds now in this case.

601
00:38:28,229 --> 00:38:31,810
So here, we would slightly speed up the playback rate of the walk

602
00:38:31,810 --> 00:38:34,750
to match the fact that the character is going a little bit faster.

603
00:38:36,220 --> 00:38:43,323
In the case where he's in the run range, we would slightly slow down the run to match the fact that we're moving a little bit slower in game.

604
00:38:43,323 --> 00:38:53,106
Now, since this is, again, strictly visual, we can adjust the reference speed as we see fit in game to make sure that it doesn't scale the animations to be too slow or too fast.

605
00:38:55,414 --> 00:38:58,139
To smoothly transition between the two ranges

606
00:38:58,139 --> 00:39:00,283
and prevent either animation from doing that,

607
00:39:00,283 --> 00:39:02,187
from being played too fast or too slow,

608
00:39:02,187 --> 00:39:04,912
we allow the ranges to overlap

609
00:39:04,912 --> 00:39:07,116
to handle the transition between the walk and the run.

610
00:39:08,394 --> 00:39:12,918
And only during this overlap, while the animations are being visually corrected,

611
00:39:12,918 --> 00:39:15,741
we allow the animations to blend together.

612
00:39:15,741 --> 00:39:18,564
Now, since we're always targeting a core movement speed,

613
00:39:18,564 --> 00:39:23,029
the character is never allowed to stay inside this blend,

614
00:39:23,029 --> 00:39:28,054
or even be in a situation where the animation has to be visually speed-corrected for too long.

615
00:39:30,449 --> 00:39:32,791
We can take this idea a little bit further.

616
00:39:32,791 --> 00:39:35,273
We're in situations where we're not aiming or shooting,

617
00:39:35,273 --> 00:39:38,116
and the animations themselves are actually pretty different,

618
00:39:38,116 --> 00:39:39,197
like a walk or a run,

619
00:39:39,197 --> 00:39:41,759
or a relaxed walk and then a run,

620
00:39:41,759 --> 00:39:43,381
where we have different steps and style.

621
00:39:43,381 --> 00:39:46,564
Once we reach that section of overlap,

622
00:39:46,564 --> 00:39:49,266
we just allow the character to transition

623
00:39:49,266 --> 00:39:50,367
from that walk to a run,

624
00:39:50,367 --> 00:39:51,949
and skip the blend altogether.

625
00:39:52,730 --> 00:39:59,632
And this transition animation can be, you know, corrected the exact same way like we've been doing with the starts and the stops,

626
00:39:59,632 --> 00:40:03,413
to keep things super responsive and maintain that sort of high fidelity.

627
00:40:03,413 --> 00:40:09,975
So let's not forget about our facing and moving directions while maintaining movement.

628
00:40:09,975 --> 00:40:17,237
They're game-driven, the same way we correct the facing and moving directions for the starts after that turn-to-face segment,

629
00:40:17,237 --> 00:40:20,198
based on those angular acceleration rates.

630
00:40:21,985 --> 00:40:25,748
We just need to make sure that the animation's root needs

631
00:40:25,748 --> 00:40:29,431
to be animated in a way where we minimize the curvature

632
00:40:29,431 --> 00:40:31,192
within its displacement.

633
00:40:31,192 --> 00:40:33,594
All that means is you kind of want

634
00:40:33,594 --> 00:40:37,036
to keep the character moving sort of like this

635
00:40:37,036 --> 00:40:38,017
in a linear fashion.

636
00:40:38,017 --> 00:40:41,059
That doesn't mean that the character model can't actually

637
00:40:41,059 --> 00:40:42,700
come off the root a little bit, but you

638
00:40:42,700 --> 00:40:45,162
want to minimize sort of that wavy stuff,

639
00:40:45,162 --> 00:40:47,144
because we're actually going to be procedurally correcting

640
00:40:47,144 --> 00:40:47,544
that in-game.

641
00:40:50,223 --> 00:40:57,485
Finally, to top things off, we add a procedural lean to show off the momentum change that's necessary for turning the character in-game.

642
00:40:57,485 --> 00:41:06,347
This leaning is linked to how fast the character is turning and is also clamped and stabilized to prevent it from going out of control.

643
00:41:06,347 --> 00:41:14,029
We've noticed if this sometimes can go unchecked in games, your character starts to feel kind of drunk as he's kind of oscillating back and forth as he's leaning about.

644
00:41:20,680 --> 00:41:27,705
Alright, so solving responsiveness in movement was one thing, but we also needed to make

645
00:41:27,705 --> 00:41:33,108
sure that combat was responsive and seamless as well.

646
00:41:33,108 --> 00:41:37,311
Right, so combining actions.

647
00:41:37,311 --> 00:41:43,615
Being able to combine actions together is a vital way to ensure combat can flow between

648
00:41:43,615 --> 00:41:44,496
features.

649
00:41:44,496 --> 00:41:47,858
I think this image pretty much sums it up to a T.

650
00:41:47,858 --> 00:41:48,519
Rico's in mid-air.

651
00:41:49,320 --> 00:41:52,881
reeling into most likely what is an enemy helicopter,

652
00:41:52,881 --> 00:41:55,843
whilst at the same time firing at a crazy rocket launcher,

653
00:41:55,843 --> 00:42:01,106
and he can do this all throughout the whole of this sequence.

654
00:42:01,106 --> 00:42:03,547
So, if this doesn't give you an essence

655
00:42:03,547 --> 00:42:05,668
of how insane Rico is, I don't know what will.

656
00:42:05,668 --> 00:42:09,370
What this means, though, is that we still need

657
00:42:09,370 --> 00:42:12,691
the animation coverage to support all of these actions.

658
00:42:12,691 --> 00:42:15,813
The way we choose to solve this problem

659
00:42:15,813 --> 00:42:17,213
is to use animation masking.

660
00:42:18,700 --> 00:42:20,661
This allows us to split our base content

661
00:42:20,661 --> 00:42:21,782
into building block chunks,

662
00:42:21,782 --> 00:42:24,824
which are created at compile time

663
00:42:24,824 --> 00:42:26,645
through the use of bone masks.

664
00:42:26,645 --> 00:42:30,367
We then reassemble these animation masks

665
00:42:30,367 --> 00:42:32,088
with our base state machine

666
00:42:32,088 --> 00:42:33,889
to build up the poses we need,

667
00:42:33,889 --> 00:42:35,350
adding no additional cost to runtime.

668
00:42:35,350 --> 00:42:39,253
In addition, animation masking

669
00:42:39,253 --> 00:42:40,754
allows us to be memory efficient.

670
00:42:40,754 --> 00:42:43,635
Data that can be shared is exported out

671
00:42:43,635 --> 00:42:44,596
as a mask only once.

672
00:42:44,596 --> 00:42:47,618
This mask can then be reused as needed.

673
00:42:49,598 --> 00:42:51,780
We can think of our final animation pose

674
00:42:51,780 --> 00:42:53,682
as being built at runtime

675
00:42:53,682 --> 00:42:56,504
from a combination of these bone masks.

676
00:42:56,504 --> 00:42:59,526
So let's dig a little deeper into the example.

677
00:42:59,526 --> 00:43:04,571
Let's imagine this image is an unarmed idle animation.

678
00:43:04,571 --> 00:43:06,352
It has no other dependency,

679
00:43:06,352 --> 00:43:09,034
so it can be a full body animation.

680
00:43:09,034 --> 00:43:11,456
So all bones are included in this set.

681
00:43:11,456 --> 00:43:13,358
However, as we build our content

682
00:43:13,358 --> 00:43:15,619
to hold weapons such as rifles,

683
00:43:15,619 --> 00:43:18,162
we realize that we can probably share some data.

684
00:43:19,237 --> 00:43:21,979
We can reuse the lower body part of the animation,

685
00:43:21,979 --> 00:43:24,841
but we want to adjust the upper body

686
00:43:24,841 --> 00:43:26,802
because if he's standing in idle pose,

687
00:43:26,802 --> 00:43:28,763
we'll need to adjust the spine and the arms

688
00:43:28,763 --> 00:43:32,665
to really match up to hold a rifle.

689
00:43:32,665 --> 00:43:37,268
So as long as the animation is in sync with the lower body,

690
00:43:37,268 --> 00:43:39,269
we should be able to maintain all the nice motion

691
00:43:39,269 --> 00:43:42,271
coming through from the original idle.

692
00:43:42,271 --> 00:43:45,373
We can then base all of our weapon sets off this animation.

693
00:43:45,373 --> 00:43:47,114
So how do we do this?

694
00:43:48,408 --> 00:43:51,488
We firstly mask the original animation into two,

695
00:43:51,488 --> 00:43:54,289
a lower body mask and an upper body mask.

696
00:43:54,289 --> 00:43:57,310
We then share the lower body mask

697
00:43:57,310 --> 00:44:00,190
with a new upper body rifle idle animation

698
00:44:00,190 --> 00:44:02,611
to combine and complete our rifle wielding idle.

699
00:44:02,611 --> 00:44:05,331
So, what if a designer comes up to us and says,

700
00:44:05,331 --> 00:44:08,932
we don't want to add rocket launchers into the game.

701
00:44:08,932 --> 00:44:13,853
We realize that we can probably share the head and torso

702
00:44:13,853 --> 00:44:16,553
of the rifle upper body animation.

703
00:44:18,218 --> 00:44:20,959
as the overall stance is pretty similar to that.

704
00:44:20,959 --> 00:44:24,121
However, wielding an RPG using the rifle arms

705
00:44:24,121 --> 00:44:26,341
is gonna mean that the RPG is gonna start

706
00:44:26,341 --> 00:44:28,122
cutting through Rico's body.

707
00:44:28,122 --> 00:44:33,264
So we further separate the mask

708
00:44:33,264 --> 00:44:35,725
to reuse that rifle head and torso

709
00:44:35,725 --> 00:44:38,546
by creating an armless upper body mask.

710
00:44:38,546 --> 00:44:42,668
We can then create a unique RPG arms only animation in red

711
00:44:42,668 --> 00:44:44,848
to complete our RPG wielding idle.

712
00:44:45,728 --> 00:44:49,030
This accounts for the two different weapon types

713
00:44:49,030 --> 00:44:51,611
we need coverage for.

714
00:44:51,611 --> 00:44:54,692
So what we end up with is a lower body animation

715
00:44:54,692 --> 00:44:56,473
that can be shared across all these cases,

716
00:44:56,473 --> 00:44:59,795
an unarmed upper body animation

717
00:44:59,795 --> 00:45:01,716
that needs to be its own content,

718
00:45:01,716 --> 00:45:03,777
a head torso animation that can be shared

719
00:45:03,777 --> 00:45:06,018
across all weapon types,

720
00:45:06,018 --> 00:45:08,239
and specific arm-only animations

721
00:45:08,239 --> 00:45:09,700
meant for individual weapons.

722
00:45:10,520 --> 00:45:12,581
Splitting up and combining these masks

723
00:45:12,581 --> 00:45:15,023
allows us to minimize animation memory

724
00:45:15,023 --> 00:45:16,504
and eliminates the need for creating

725
00:45:16,504 --> 00:45:18,185
a lot of unique full body animations.

726
00:45:18,185 --> 00:45:21,186
And it's also completely up to the animator

727
00:45:21,186 --> 00:45:25,048
to decide the level of granularity we need.

728
00:45:25,048 --> 00:45:28,270
So here's the result of applying this technique

729
00:45:28,270 --> 00:45:28,970
on Rico in game.

730
00:45:28,970 --> 00:45:32,392
You can see that the masks that I just talked about

731
00:45:32,392 --> 00:45:34,994
all building up to create the final animation

732
00:45:34,994 --> 00:45:35,794
of the character.

733
00:45:38,803 --> 00:45:42,144
So our masking system is pretty robust and flexible.

734
00:45:42,144 --> 00:45:45,646
But we also need a way to overlap all our animations.

735
00:45:45,646 --> 00:45:48,367
So we use animation layering to tackle this problem.

736
00:45:48,367 --> 00:45:51,729
Our animation system allows our characters

737
00:45:51,729 --> 00:45:53,730
to include multiple layers.

738
00:45:53,730 --> 00:45:57,711
The first layer includes our base animation content.

739
00:45:57,711 --> 00:46:01,073
By masking this, we're ensuring that the data here

740
00:46:01,073 --> 00:46:03,814
is only brought into the memory once.

741
00:46:03,814 --> 00:46:04,735
In other instances,

742
00:46:05,226 --> 00:46:08,128
we need to be able to perform additional actions

743
00:46:08,128 --> 00:46:10,571
that can overlap multiple states.

744
00:46:10,571 --> 00:46:14,554
To do this, we add another layer on top of the base layer

745
00:46:14,554 --> 00:46:17,557
to play overlapping animations

746
00:46:17,557 --> 00:46:21,460
that also have no major dependencies on that base content.

747
00:46:21,460 --> 00:46:24,382
So it's ideal for such things like reload animations.

748
00:46:24,382 --> 00:46:26,004
They can be masked on top of the arms,

749
00:46:26,004 --> 00:46:29,246
whilst Ricoh can move through any transition animation

750
00:46:29,246 --> 00:46:30,047
in the base layer.

751
00:46:32,568 --> 00:46:36,389
We then include another layer to handle additive animations

752
00:46:36,389 --> 00:46:39,189
that need to be synced with our base actions.

753
00:46:39,189 --> 00:46:41,810
And this is used for something like

754
00:46:41,810 --> 00:46:43,330
aiming up and down vertically.

755
00:46:43,330 --> 00:46:47,471
And finally, we can add a layer to handle additives

756
00:46:47,471 --> 00:46:50,612
that can also overlap multiple states.

757
00:46:50,612 --> 00:46:53,952
This helps us to give texture to our character's performance.

758
00:46:53,952 --> 00:46:56,133
In this example, let's say Rico is moving

759
00:46:56,133 --> 00:46:58,033
across the top of a jet, stunting or whatever,

760
00:46:58,033 --> 00:47:00,754
and the jet is obviously moving at a fast speed.

761
00:47:01,358 --> 00:47:05,260
So we can enhance this feeling by bringing in an animation additive

762
00:47:05,260 --> 00:47:08,661
that makes Riko's clothes and buckles move and react to the wind.

763
00:47:08,661 --> 00:47:13,102
These layers are then sequentially updated at runtime

764
00:47:13,102 --> 00:47:19,124
with each pose being passed through into the following layer.

765
00:47:19,124 --> 00:47:25,626
Finally creating the final character's pose in-game.

766
00:47:25,626 --> 00:47:26,646
So to wrap things up...

767
00:47:27,158 --> 00:47:36,186
Techniques combining movement models and correcting motion give us the responsiveness and coverage we need, without killing the fidelity of our animation.

768
00:47:36,186 --> 00:47:44,854
Using masking and layering to combine actions gives us the ability to share and reuse animation content and further minimize the amount of authoring we need to do.

769
00:47:47,020 --> 00:47:48,901
Well, we hope this was an insightful look

770
00:47:48,901 --> 00:47:50,923
into our techniques and systems.

771
00:47:50,923 --> 00:47:53,304
And we hope to share our aiming, movement,

772
00:47:53,304 --> 00:47:56,045
and other feature set solutions with you at a later time,

773
00:47:56,045 --> 00:47:58,067
hopefully post-launch.

774
00:47:58,067 --> 00:48:01,388
But for now, we cannot wait for you to play this game

775
00:48:01,388 --> 00:48:03,029
and push and experiment with our mechanics.

776
00:48:03,029 --> 00:48:04,830
So thank you very much,

777
00:48:04,830 --> 00:48:06,772
and we can invite the room for questions.

778
00:48:16,507 --> 00:48:17,850
Do you have my email if you have any questions?

779
00:48:17,850 --> 00:48:17,910
Hi.

780
00:48:17,910 --> 00:48:24,683
Going back to your phase matching portion,

781
00:48:24,683 --> 00:48:27,729
you're talking about you identify.

782
00:48:28,432 --> 00:48:32,495
phases in your animation where the foot's planted or in full swing.

783
00:48:32,495 --> 00:48:34,717
I was just curious how you guys do that.

784
00:48:34,717 --> 00:48:40,442
Is it automated by a script or do the animators actually manually identify those moments?

785
00:48:40,442 --> 00:48:45,106
So what we do is, so the question was how do we actually figure out how to generate

786
00:48:45,106 --> 00:48:46,908
the phase match data.

787
00:48:46,908 --> 00:48:51,432
And currently, basically, we have the animators add a key on all plants.

788
00:48:51,972 --> 00:48:54,414
And then we have a script that basically runs and looks

789
00:48:54,414 --> 00:48:57,956
at the height between plants to kind of decide what the swing

790
00:48:57,956 --> 00:48:59,197
is actually going to be.

791
00:48:59,197 --> 00:49:00,558
So for things like walks and runs,

792
00:49:00,558 --> 00:49:02,600
we use different height values to kind of know

793
00:49:02,600 --> 00:49:04,701
what the max swing will be.

794
00:49:04,701 --> 00:49:06,843
And then for now, because all our walk and run content

795
00:49:06,843 --> 00:49:09,244
is roughly of the same height, that script kind of

796
00:49:09,244 --> 00:49:10,785
gives us good enough phase match data.

797
00:49:10,785 --> 00:49:13,847
And it doesn't have to be perfect, because we're actually

798
00:49:13,847 --> 00:49:15,889
blending as well, but it's good enough.

799
00:49:15,889 --> 00:49:18,891
And you could make that as complicated as you need it

800
00:49:18,891 --> 00:49:21,053
to be, but this was good enough for us.

801
00:49:21,053 --> 00:49:21,393
Thank you.

802
00:49:22,600 --> 00:49:23,161
Great talk.

803
00:49:23,161 --> 00:49:26,864
I was curious how you guys handled

804
00:49:26,864 --> 00:49:28,886
interruptions of transition animations.

805
00:49:28,886 --> 00:49:30,767
If you need to change your mind mid-transition,

806
00:49:30,767 --> 00:49:31,228
how'd you deal with that?

807
00:49:31,228 --> 00:49:31,488
Sure.

808
00:49:31,488 --> 00:49:36,432
The question was, how do we deal with transition animations

809
00:49:36,432 --> 00:49:36,732
to interrupt?

810
00:49:37,553 --> 00:49:38,514
sets of movement, I guess.

811
00:49:38,514 --> 00:49:41,515
And I mean, we just play the animation, right?

812
00:49:41,515 --> 00:49:45,217
So basically, again, using kind of these segments,

813
00:49:45,217 --> 00:49:48,038
we can kind of define interruption segments as well.

814
00:49:48,038 --> 00:49:50,899
Hey, when is it OK to start interrupting this animation?

815
00:49:50,899 --> 00:49:53,600
And you don't want to kind of push that interruption segment

816
00:49:53,600 --> 00:49:55,681
to be too far out, because then you're

817
00:49:55,681 --> 00:49:57,562
fighting with responsiveness again.

818
00:49:57,562 --> 00:50:00,623
But say something like a start, I kind of hinted to it.

819
00:50:00,623 --> 00:50:03,064
And in the video, it had some plant

820
00:50:03,064 --> 00:50:04,405
and turns that were also playing.

821
00:50:04,905 --> 00:50:07,487
So, say for example you're playing a start,

822
00:50:07,487 --> 00:50:10,429
and suddenly you decide to go in the other direction.

823
00:50:10,429 --> 00:50:12,411
We play a plant and turn animation

824
00:50:12,411 --> 00:50:13,652
to get you out of the start.

825
00:50:13,652 --> 00:50:15,213
And then while you're doing that,

826
00:50:15,213 --> 00:50:17,115
you're doing the exact same movement correction

827
00:50:17,115 --> 00:50:19,757
on that plant and turn to now correct it

828
00:50:19,757 --> 00:50:21,398
in whatever direction you wanted to go

829
00:50:21,398 --> 00:50:23,200
and start steering the plant and turn itself.

830
00:50:23,200 --> 00:50:25,742
So, you have that coverage to allow you

831
00:50:25,742 --> 00:50:28,144
to interrupt animations, and then you use

832
00:50:28,144 --> 00:50:30,286
the exact same techniques on all that content

833
00:50:30,286 --> 00:50:32,287
to give you the responsiveness.

834
00:50:32,287 --> 00:50:34,529
Were you continually adjusting the?

835
00:50:35,264 --> 00:50:38,887
the rotation, angular rotation, throughout the transition animations?

836
00:50:38,887 --> 00:50:40,027
Or was it a snapshot?

837
00:50:40,027 --> 00:50:41,248
That's a good point.

838
00:50:41,248 --> 00:50:43,189
We don't want to do that all the time.

839
00:50:43,189 --> 00:50:44,190
In some cases we do.

840
00:50:44,190 --> 00:50:49,093
But when it comes to starts and plants, you kind of want a little bit of time where the

841
00:50:49,093 --> 00:50:53,076
character actually isn't being kind of spun in a different direction.

842
00:50:53,076 --> 00:50:57,119
Because then again, you're going to break the animation believability.

843
00:50:57,119 --> 00:51:01,021
Like if I'm turning this way and the game suddenly makes me go that way, it's going

844
00:51:01,021 --> 00:51:01,962
to break.

845
00:51:01,962 --> 00:51:04,904
So you kind of want to wait at least until it's a good time to do that.

846
00:51:04,964 --> 00:51:06,445
and then either plant off this foot,

847
00:51:06,445 --> 00:51:09,786
and then allow correction using these kind

848
00:51:09,786 --> 00:51:12,287
of data-driven segments that I talked about.

849
00:51:12,287 --> 00:51:12,387
Cool.

850
00:51:12,387 --> 00:51:14,488
Thank you.

851
00:51:14,488 --> 00:51:14,528
Hi.

852
00:51:14,528 --> 00:51:19,251
Did you guys have, for your start animations,

853
00:51:19,251 --> 00:51:21,492
did you have stand to walk animations?

854
00:51:21,492 --> 00:51:21,732
Yes.

855
00:51:21,732 --> 00:51:24,693
And if you did, how did you handle

856
00:51:24,693 --> 00:51:27,674
if the player moves to a run speed

857
00:51:27,674 --> 00:51:29,455
in the middle of the start animation?

858
00:51:30,171 --> 00:51:35,133
Right, so I mean, based on that pad input that I talked about, if the target speed actually

859
00:51:35,133 --> 00:51:39,655
happens to just be a walk, and you happen to be in an idle, we just play a start to

860
00:51:39,655 --> 00:51:41,536
walk start instead.

861
00:51:41,536 --> 00:51:44,037
And are those not long enough that the player can't...

862
00:51:44,654 --> 00:51:47,955
try to go into a run in the middle of the start?

863
00:51:47,955 --> 00:51:48,595
Yeah, exactly.

864
00:51:48,595 --> 00:51:50,815
So while I'm playing that walk start,

865
00:51:50,815 --> 00:51:52,236
if I happen to jam my stick again,

866
00:51:52,236 --> 00:51:54,596
I can either play a transition if I want to,

867
00:51:54,596 --> 00:51:57,817
or I can just allow that to blend the kind of same way

868
00:51:57,817 --> 00:51:58,877
we talked about.

869
00:51:58,877 --> 00:52:00,898
But actually, in the case of if you're already

870
00:52:00,898 --> 00:52:04,639
playing an animation, like a transition animation,

871
00:52:04,639 --> 00:52:07,579
you want to just interrupt it with another kind of start

872
00:52:07,579 --> 00:52:09,940
to run transition.

873
00:52:09,940 --> 00:52:11,680
That would be better than actually blending it,

874
00:52:11,680 --> 00:52:12,901
because it will look weird if you blend

875
00:52:12,901 --> 00:52:14,401
the animation to a cycle.

876
00:52:14,881 --> 00:52:15,842
Okay, thank you.

877
00:52:15,842 --> 00:52:18,724
I love Just Cause 2, thanks.

878
00:52:18,724 --> 00:52:20,886
One of the cool things is

879
00:52:20,886 --> 00:52:22,767
very organic environments, you can do a lot.

880
00:52:22,767 --> 00:52:25,109
Is there like a maximum angle

881
00:52:25,109 --> 00:52:26,530
that the character can run up and

882
00:52:26,530 --> 00:52:29,152
at what point do you just kick him to a slide

883
00:52:29,152 --> 00:52:31,033
as opposed to letting him free-nab up

884
00:52:31,033 --> 00:52:32,054
every surface?

885
00:52:32,054 --> 00:52:34,756
Sorry, the question was what is the

886
00:52:34,756 --> 00:52:37,158
max angle that the character can run up and down?

887
00:52:37,158 --> 00:52:37,358
Yeah.

888
00:52:37,358 --> 00:52:40,821
Yeah, I mean we want to definitely have

889
00:52:40,821 --> 00:52:42,682
I'm not exactly sure what the design

890
00:52:43,374 --> 00:52:49,539
I mean, we try to get the character to support as much movement as possible, especially going

891
00:52:49,539 --> 00:52:51,061
up and down.

892
00:52:51,061 --> 00:52:57,387
And we, you know, especially in this game, we're using techniques like IK and stuff like

893
00:52:57,387 --> 00:53:00,230
that to help extend that range further.

894
00:53:00,230 --> 00:53:04,213
But the locomotion system would handle that to allow you to basically move up a slope

895
00:53:04,213 --> 00:53:06,155
as well as go down.

896
00:53:06,155 --> 00:53:06,255
Right.

897
00:53:06,255 --> 00:53:06,395
Hi.

898
00:53:06,395 --> 00:53:06,936
Hi.

899
00:53:06,936 --> 00:53:08,317
My question is about network.

900
00:53:08,796 --> 00:53:11,718
So you guys develop a lot of solutions.

901
00:53:11,718 --> 00:53:14,821
How much of these solutions worked on a network

902
00:53:14,821 --> 00:53:16,362
with multiple players?

903
00:53:16,362 --> 00:53:17,543
On a network?

904
00:53:17,543 --> 00:53:22,987
We haven't tried that yet.

905
00:53:22,987 --> 00:53:23,188
Hi.

906
00:53:23,188 --> 00:53:26,010
I have a question about the mocap system.

907
00:53:26,010 --> 00:53:29,893
And how do you guys measure that it's 5.5 miles an hour

908
00:53:29,893 --> 00:53:31,094
or 1.3 is in a treadmill?

909
00:53:31,094 --> 00:53:34,737
Or do you guys eyeball it?

910
00:53:35,448 --> 00:53:36,469
You want to answer that?

911
00:53:36,469 --> 00:53:42,016
Yeah, I mean, we went through an iterative process of trying to find out what speed would

912
00:53:42,016 --> 00:53:44,179
work really well for our character.

913
00:53:44,179 --> 00:53:48,825
First of all, we had him sprinting around the world and it was just way too fast.

914
00:53:48,825 --> 00:53:53,291
We actually needed to slow him down quite a bit to be able to be quite responsive.

915
00:53:53,792 --> 00:53:56,872
So, you know, we took that to the motion capture data.

916
00:53:56,872 --> 00:53:59,193
We kind of found the data that was good to play.

917
00:53:59,193 --> 00:54:02,754
And we set out, like, yeah, we need it to be this speed.

918
00:54:02,754 --> 00:54:07,735
But luckily the tech allows us to be able to, like, manipulate it within those realms.

919
00:54:07,735 --> 00:54:09,935
So, you know, it's good in that way.

920
00:54:09,935 --> 00:54:10,516
Okay.

921
00:54:10,516 --> 00:54:13,616
So you fudged it a little bit, the mo-captures, to get to the right speed?

922
00:54:13,616 --> 00:54:14,116
Yes.

923
00:54:14,116 --> 00:54:14,256
Okay.

924
00:54:14,256 --> 00:54:14,577
Cool.

925
00:54:14,577 --> 00:54:15,157
Awesome.

926
00:54:15,157 --> 00:54:15,337
Thanks.

927
00:54:15,337 --> 00:54:15,757
Cool.

928
00:54:15,757 --> 00:54:17,057
All right.

929
00:54:17,057 --> 00:54:19,118
Thanks a lot, everyone.

930
00:54:19,118 --> 00:54:21,938
Thank you.

