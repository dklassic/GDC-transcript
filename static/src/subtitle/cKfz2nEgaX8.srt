1
00:00:04,649 --> 00:00:07,830
Hello, my name is Jafar Soltani.

2
00:00:08,330 --> 00:00:10,971
I'm lead software engineer working for Rare Games Studio.

3
00:00:11,551 --> 00:00:12,691
We are part of Microsoft.

4
00:00:13,031 --> 00:00:14,972
And today I'm going to talk about Rare's journey

5
00:00:15,512 --> 00:00:18,793
in adopting continuous delivery for our latest title called

6
00:00:18,913 --> 00:00:19,413
Sea of Thieves.

7
00:00:22,554 --> 00:00:25,114
Is there anybody here who doesn't work in games industry?

8
00:00:28,615 --> 00:00:29,175
Just a couple.

9
00:00:30,196 --> 00:00:32,416
So this slide should be familiar to most of you.

10
00:00:32,496 --> 00:00:33,336
I'll quickly go through that.

11
00:00:35,479 --> 00:00:38,802
Games are developed as monolithic applications in C++.

12
00:00:40,063 --> 00:00:42,245
And we use three main phases.

13
00:00:42,285 --> 00:00:44,147
And we use waterfall process to develop games.

14
00:00:44,967 --> 00:00:47,329
We have a pre-production or prototyping phase

15
00:00:47,409 --> 00:00:49,211
when the size of the team is quite small.

16
00:00:50,011 --> 00:00:53,034
And the purpose is to come up with the idea about the game,

17
00:00:53,074 --> 00:00:55,376
come up about the story, define what the game is about,

18
00:00:55,896 --> 00:00:57,337
prove other technology, and come up

19
00:00:57,377 --> 00:00:58,398
with the roadmap for the game.

20
00:00:59,720 --> 00:01:01,901
And once we get the funding and green light,

21
00:01:02,161 --> 00:01:03,982
we go into production phase.

22
00:01:04,602 --> 00:01:07,504
That's where the size of the team increases significantly.

23
00:01:08,744 --> 00:01:12,045
And the main purpose here is to develop as many features

24
00:01:12,085 --> 00:01:14,026
as possible that we defined earlier on.

25
00:01:15,467 --> 00:01:17,688
That can last sometimes between one to two years.

26
00:01:19,080 --> 00:01:21,841
And once that's finished, we go into bug fixing phase.

27
00:01:21,901 --> 00:01:24,202
That's where we're getting close to the release date,

28
00:01:24,482 --> 00:01:25,503
and we can't really move that.

29
00:01:26,403 --> 00:01:28,424
And at the same time, we face a mountain of bugs,

30
00:01:28,464 --> 00:01:31,245
maybe about 10,000 bugs that we have to now go and fix

31
00:01:31,665 --> 00:01:32,425
for that release date.

32
00:01:34,166 --> 00:01:36,627
And at this point, everybody crunches.

33
00:01:36,687 --> 00:01:38,228
Everybody work long hours.

34
00:01:39,588 --> 00:01:40,489
It's quite stressful.

35
00:01:40,629 --> 00:01:43,330
People make a lot of sacrifices to make sure a game is out

36
00:01:43,710 --> 00:01:44,950
on time at high quality.

37
00:01:46,516 --> 00:01:49,978
And at this stage, we heavily rely on manual testing

38
00:01:50,638 --> 00:01:52,999
to prove that the game works and catch bugs for us.

39
00:01:55,200 --> 00:01:58,421
And usually, for AAA games, we have one big release

40
00:01:58,742 --> 00:02:00,703
followed by a handful of updates.

41
00:02:01,243 --> 00:02:03,444
And the main team moves on to the next project.

42
00:02:03,484 --> 00:02:06,205
And they don't have to worry about maintainability

43
00:02:07,045 --> 00:02:07,686
of the code base.

44
00:02:11,427 --> 00:02:13,208
Could you raise your hand if you're familiar with Sea

45
00:02:13,228 --> 00:02:14,589
of Thieves or you play Sea of Thieves?

46
00:02:15,890 --> 00:02:16,070
Good.

47
00:02:20,705 --> 00:02:23,167
So Sea of Thieves is a multiplayer cooperative

48
00:02:23,267 --> 00:02:27,290
adventure game that we are working on at Rare.

49
00:02:27,771 --> 00:02:30,934
And the idea is that there is no predefined story.

50
00:02:30,974 --> 00:02:34,076
There are emergent stories that develop as a result of simple

51
00:02:34,136 --> 00:02:34,977
mechanics in the game.

52
00:02:35,638 --> 00:02:38,220
And you go and form a crew with your friends or with strangers,

53
00:02:38,300 --> 00:02:39,481
and you go on an adventure.

54
00:02:41,243 --> 00:02:44,105
For this game, we decided to change our business model

55
00:02:44,185 --> 00:02:45,666
and develop this game as a service.

56
00:02:46,858 --> 00:02:48,878
The difference between developing this game as a

57
00:02:48,898 --> 00:02:51,759
service compared to traditional process that I just explained

58
00:02:51,819 --> 00:02:54,379
is, as opposed to working for three years and then release

59
00:02:54,419 --> 00:02:56,980
the game at the end, we're supposed to release the game

60
00:02:57,000 --> 00:02:57,640
much earlier.

61
00:02:58,360 --> 00:03:01,720
And by involving our community and our players, we evolve the

62
00:03:01,740 --> 00:03:04,681
game based on their feedback that hopefully leads to a

63
00:03:04,701 --> 00:03:06,721
better game that is more fun for our players.

64
00:03:09,382 --> 00:03:13,563
So far, we've done over 150 releases of Sea of Thieves to

65
00:03:13,583 --> 00:03:14,883
our technical alpha players.

66
00:03:16,190 --> 00:03:18,431
And that's by far the most number of releases that any

67
00:03:18,471 --> 00:03:20,092
title have done on Xbox platform.

68
00:03:22,834 --> 00:03:24,875
And our game is live this week.

69
00:03:24,915 --> 00:03:26,356
It came out earlier this week.

70
00:03:27,976 --> 00:03:30,198
And this is the amazing team at Rare who

71
00:03:30,218 --> 00:03:31,058
worked on the project.

72
00:03:35,661 --> 00:03:38,042
Now I'm going to talk about why we decided to adopt

73
00:03:38,062 --> 00:03:38,863
continuous delivery.

74
00:03:41,550 --> 00:03:43,571
Because we changed our business model, it meant that we wanted

75
00:03:43,591 --> 00:03:46,974
to sustainably deliver new features to our players

76
00:03:47,155 --> 00:03:48,155
over a long period of time.

77
00:03:48,215 --> 00:03:49,857
And we know that every time we wanted to release,

78
00:03:50,778 --> 00:03:51,478
we used to crunch.

79
00:03:51,638 --> 00:03:52,959
So if we didn't change anything, we

80
00:03:52,979 --> 00:03:54,881
would have had continuous crunch as opposed

81
00:03:54,901 --> 00:03:55,822
to continuous delivery.

82
00:03:56,242 --> 00:03:59,845
So it was quite important that we reduce the crunch as much

83
00:03:59,885 --> 00:04:02,047
as possible and therefore have happier developers.

84
00:04:03,589 --> 00:04:06,131
We wanted to get fast feedback from our players

85
00:04:06,331 --> 00:04:09,113
so then we can deliver a better quality game that is more fun.

86
00:04:11,044 --> 00:04:13,605
And on top of that, we wanted to reduce the cost of having

87
00:04:13,805 --> 00:04:14,865
large manual testing.

88
00:04:15,645 --> 00:04:18,626
I did not even rely on them to prove the game works.

89
00:04:19,386 --> 00:04:22,607
The problem with relying on testing to tell us if the game

90
00:04:22,627 --> 00:04:25,668
works or not is what we found is the moment we don't have

91
00:04:25,688 --> 00:04:29,329
that manual testing, our developers were not feeling

92
00:04:29,389 --> 00:04:31,549
confident to go and make any changes to the code base

93
00:04:31,609 --> 00:04:34,110
because they were not sure if they're going to introduce any

94
00:04:34,170 --> 00:04:35,050
new issues or not.

95
00:04:38,863 --> 00:04:42,084
I wanted to clarify a distinction between doing

96
00:04:42,144 --> 00:04:45,425
continuous delivery and doing frequent releases.

97
00:04:46,265 --> 00:04:49,245
There are probably some games out there that release

98
00:04:49,305 --> 00:04:51,666
regularly, but that doesn't necessarily mean that they are

99
00:04:51,726 --> 00:04:52,866
doing continuous delivery.

100
00:04:53,906 --> 00:04:57,067
The difference is, for those companies, they still use the

101
00:04:57,107 --> 00:05:00,247
traditional process to develop their features.

102
00:05:00,768 --> 00:05:01,788
They've reduced the time.

103
00:05:02,288 --> 00:05:04,688
So as opposed to spending three years, they spent, let's

104
00:05:04,708 --> 00:05:05,328
say, three months.

105
00:05:05,428 --> 00:05:08,069
And they plan these features that overlap with each other.

106
00:05:09,140 --> 00:05:10,801
So then they can release them, let's say,

107
00:05:10,901 --> 00:05:11,821
one month from each other.

108
00:05:11,841 --> 00:05:15,283
And on the other hand, when we are doing continuous delivery,

109
00:05:15,943 --> 00:05:18,684
we might still choose to release once every month.

110
00:05:18,844 --> 00:05:21,665
But we have other candidates that if we choose to,

111
00:05:21,825 --> 00:05:22,645
we can still release.

112
00:05:23,425 --> 00:05:24,746
When you're doing continuous delivery,

113
00:05:24,786 --> 00:05:26,286
you can easily go from, let's say,

114
00:05:26,326 --> 00:05:28,667
releasing once a month to releasing once every two weeks,

115
00:05:29,348 --> 00:05:31,168
because you have many candidates to choose from.

116
00:05:31,668 --> 00:05:33,329
Whereas in the traditional process,

117
00:05:33,789 --> 00:05:35,210
you don't really have any other candidates.

118
00:05:35,250 --> 00:05:37,290
So you can't easily go from releasing once a month

119
00:05:37,350 --> 00:05:38,611
to releasing once every two weeks.

120
00:05:42,232 --> 00:05:44,493
Now I'm going to talk about how we are adopting continuous

121
00:05:44,513 --> 00:05:44,913
delivery.

122
00:05:48,275 --> 00:05:51,336
Our developers are responsible for quality of their work and

123
00:05:51,396 --> 00:05:52,497
prove that a feature works.

124
00:05:53,357 --> 00:05:56,479
We found that it's very inefficient to manually verify

125
00:05:56,519 --> 00:05:56,879
the game.

126
00:05:57,079 --> 00:05:59,160
It can take days until we get feedback whether

127
00:05:59,180 --> 00:06:00,541
the game works or not.

128
00:06:01,361 --> 00:06:03,442
So therefore, our developers write automated tests.

129
00:06:04,463 --> 00:06:07,504
We have about 40,000 automated tests, and we run about 4

130
00:06:07,724 --> 00:06:08,484
million tests a day.

131
00:06:10,144 --> 00:06:13,687
90% of our tests are unit tests, written in C++.

132
00:06:14,307 --> 00:06:17,430
And the remaining 10% are larger tests

133
00:06:17,890 --> 00:06:19,211
that test bigger systems.

134
00:06:19,292 --> 00:06:20,813
Like these are end-to-end tests.

135
00:06:21,173 --> 00:06:23,315
Some of them are performance tests and memory tests.

136
00:06:23,935 --> 00:06:24,776
Take longer to run.

137
00:06:26,397 --> 00:06:27,879
And when our developers fix bugs,

138
00:06:28,359 --> 00:06:30,461
they usually try to add some tests

139
00:06:30,641 --> 00:06:31,862
to prove that they fixed the bug.

140
00:06:36,456 --> 00:06:39,181
We work hard to make sure our game is always shippable.

141
00:06:39,762 --> 00:06:42,666
We prioritize fixing bugs and broken tests

142
00:06:42,947 --> 00:06:44,289
over working on new features.

143
00:06:45,672 --> 00:06:48,915
If our build is broken or we have an incident, which means

144
00:06:48,935 --> 00:06:51,277
we can't ship the game, we lock our depot.

145
00:06:51,417 --> 00:06:53,959
We don't let other people to add changes on top of that.

146
00:06:54,720 --> 00:06:57,042
I'm not sure if you have experienced this or not, but

147
00:06:57,242 --> 00:06:59,965
we were seeing that a lot of times if somebody's trying to

148
00:07:00,005 --> 00:07:02,607
investigate when the build is broken and somebody else adds

149
00:07:02,827 --> 00:07:04,909
more changes on top of that, it makes that investigation

150
00:07:04,949 --> 00:07:05,550
more difficult.

151
00:07:05,970 --> 00:07:06,911
So we wanted to avoid that.

152
00:07:07,011 --> 00:07:08,112
So therefore, we locked the depot.

153
00:07:08,712 --> 00:07:11,695
And what we do is we try to identify the change that

154
00:07:11,715 --> 00:07:13,336
caused the problem and back that out.

155
00:07:13,917 --> 00:07:16,579
Again, what we found is it's a lot less stressful

156
00:07:16,599 --> 00:07:18,481
for our developers if they come up

157
00:07:18,501 --> 00:07:20,602
with a fix in their own time, as opposed

158
00:07:20,622 --> 00:07:22,704
to trying to fix the build while everybody's blocked.

159
00:07:24,165 --> 00:07:27,508
And we have build lights and TV screens across the studio

160
00:07:27,548 --> 00:07:29,790
to notify everybody when the build is broken.

161
00:07:30,351 --> 00:07:32,092
So you can't really miss that.

162
00:07:36,082 --> 00:07:38,143
And as a result of this, the quality of the game

163
00:07:38,703 --> 00:07:40,384
looks something like this green line.

164
00:07:40,964 --> 00:07:42,765
Compare that to traditional process

165
00:07:42,825 --> 00:07:45,387
where the quality is low generally

166
00:07:45,427 --> 00:07:46,828
for most of the project.

167
00:07:46,908 --> 00:07:49,569
And it only gets to the high level

168
00:07:49,689 --> 00:07:51,570
towards the end of the project when you're fixing bugs.

169
00:07:52,051 --> 00:07:53,111
And that's one of the main reasons

170
00:07:53,131 --> 00:07:55,072
that we can't really ship the game when

171
00:07:55,112 --> 00:07:58,554
we are at the state for most of the project

172
00:07:58,574 --> 00:08:02,316
because the quality is very low compared to the green line

173
00:08:02,336 --> 00:08:02,476
there.

174
00:08:06,834 --> 00:08:09,776
We tried to make sure our builds, as much as possible,

175
00:08:10,217 --> 00:08:11,658
have a small number of changes in them.

176
00:08:11,678 --> 00:08:14,940
Because what we found is when something goes wrong,

177
00:08:15,260 --> 00:08:17,382
and there's only, let's say, a handful of changes in there,

178
00:08:18,063 --> 00:08:21,085
it's a lot easier to know which change broke the build as

179
00:08:21,165 --> 00:08:23,086
opposed to when we have 500 changes in there,

180
00:08:23,126 --> 00:08:24,287
or let's say even more.

181
00:08:25,588 --> 00:08:28,030
On top of that, when we have so many changes,

182
00:08:28,230 --> 00:08:29,952
they might interact badly with each other.

183
00:08:29,972 --> 00:08:33,834
And so what we found is actually the risk

184
00:08:34,155 --> 00:08:36,456
grows exponentially the more changes we have.

185
00:08:37,824 --> 00:08:39,365
And on top of that, our developers

186
00:08:39,425 --> 00:08:42,445
try to break down their work into smaller chunks

187
00:08:42,725 --> 00:08:45,786
so they can ideally submit once a day.

188
00:08:45,806 --> 00:08:53,288
Now I'm going to talk about what traditionally we

189
00:08:53,348 --> 00:08:55,089
used to set up our branches.

190
00:08:56,339 --> 00:08:59,461
We used to break the game into different features

191
00:08:59,561 --> 00:09:01,903
and form teams around each feature.

192
00:09:02,663 --> 00:09:05,285
And each feature team used to go to their own branch

193
00:09:05,945 --> 00:09:07,286
and work on the feature.

194
00:09:07,306 --> 00:09:09,267
And once that was completed, they

195
00:09:09,287 --> 00:09:11,569
would merge it back into main or trunk.

196
00:09:11,989 --> 00:09:13,530
And at some point before the release,

197
00:09:13,550 --> 00:09:16,752
we used to create a QA branch, fix the bugs,

198
00:09:17,713 --> 00:09:19,674
and then create a release branch and release from there.

199
00:09:21,635 --> 00:09:23,456
So there were some problems with this approach.

200
00:09:25,766 --> 00:09:28,507
We could get really painful merge conflicts,

201
00:09:28,727 --> 00:09:31,949
especially if you're working, let's say,

202
00:09:31,989 --> 00:09:33,550
on a feature branch for a month or two months,

203
00:09:33,590 --> 00:09:35,531
and now we want to merge all of that back.

204
00:09:37,892 --> 00:09:41,314
And on top of that, because we are using centralized source

205
00:09:41,334 --> 00:09:44,295
control systems like Perforce, merge conflicts

206
00:09:44,515 --> 00:09:46,316
are not easy to resolve.

207
00:09:49,785 --> 00:09:51,326
Some people argue that if you use git,

208
00:09:51,726 --> 00:09:53,047
it helps with merge conflicts.

209
00:09:53,807 --> 00:09:56,889
But the problem is that about 95% of the content of the game

210
00:09:57,809 --> 00:09:58,749
is binary files.

211
00:09:58,809 --> 00:10:00,610
And as I'm sure you're aware, it's

212
00:10:00,650 --> 00:10:02,531
very difficult to measure these binary files.

213
00:10:02,551 --> 00:10:05,672
So if two people end up changing the same binary files

214
00:10:05,712 --> 00:10:08,234
in different branches, when we try to measure them back,

215
00:10:08,754 --> 00:10:10,335
we have to overwrite one or the other one.

216
00:10:12,355 --> 00:10:14,676
On top of that, we might get semantic conflicts.

217
00:10:15,908 --> 00:10:18,169
Semantic conflicts means if somebody goes, let's say,

218
00:10:18,650 --> 00:10:21,552
try to refactor a function and split it into two

219
00:10:21,592 --> 00:10:25,054
because it was too long, everything might merge fine.

220
00:10:25,435 --> 00:10:27,916
But we're not going to know that that functionality is not

221
00:10:27,976 --> 00:10:30,678
complete until later on when it gets into QA branch.

222
00:10:32,099 --> 00:10:33,861
And again, because we don't really get any feedback

223
00:10:33,921 --> 00:10:36,943
until changes are in QA branch, the feedback loop

224
00:10:37,143 --> 00:10:37,964
is extremely long.

225
00:10:38,304 --> 00:10:40,385
We're not going to know if our feature works well or not

226
00:10:40,505 --> 00:10:41,806
until maybe weeks.

227
00:10:44,238 --> 00:10:47,301
And on top of that, if we identify critical issues

228
00:10:48,001 --> 00:10:50,243
that requires fixes, now we have to go and integrate

229
00:10:50,263 --> 00:10:52,766
that change into many, many branches.

230
00:10:55,408 --> 00:10:58,972
And this is kind of the idea behind continuous integration.

231
00:10:59,867 --> 00:11:02,549
as well, where it says that if something is painful,

232
00:11:02,569 --> 00:11:04,570
let's say like marriage conflicts, our natural reaction

233
00:11:04,630 --> 00:11:08,252
is to do them as few times as possible.

234
00:11:08,392 --> 00:11:10,593
Let's say you do a marriage and it's really painful.

235
00:11:10,633 --> 00:11:12,934
You don't want to do this again for another three months.

236
00:11:13,495 --> 00:11:15,996
But actually what happens is the next time you're going to

237
00:11:16,016 --> 00:11:17,297
do this is even more difficult.

238
00:11:17,837 --> 00:11:20,799
So what we should do instead is we should resist that

239
00:11:20,839 --> 00:11:24,641
temptation and try to do that integration as often as

240
00:11:24,681 --> 00:11:25,841
possible, ideally daily.

241
00:11:26,895 --> 00:11:29,096
So therefore, we use the trunk-based development,

242
00:11:29,616 --> 00:11:33,137
where all the features are developed simultaneously

243
00:11:33,537 --> 00:11:33,957
on main.

244
00:11:35,338 --> 00:11:36,278
And we release from main.

245
00:11:36,298 --> 00:11:37,379
We don't create release branches.

246
00:11:37,419 --> 00:11:39,819
So everything is work on main and released from there.

247
00:11:41,440 --> 00:11:44,861
And what allows us to work this way is using feature toggles.

248
00:11:46,382 --> 00:11:47,762
We use two types of toggles.

249
00:11:48,803 --> 00:11:50,303
The first one is compile-time toggle.

250
00:11:51,336 --> 00:11:54,619
which we define the toggles that we want to switch on

251
00:11:54,659 --> 00:11:55,420
at compile time.

252
00:11:55,920 --> 00:11:57,521
And then when the game is compiled,

253
00:11:57,541 --> 00:11:59,583
we would compile out the feature that we don't

254
00:11:59,623 --> 00:12:00,624
want to ship to players.

255
00:12:01,445 --> 00:12:04,167
This allows us to have in progress features

256
00:12:04,227 --> 00:12:05,568
and hide them when we release.

257
00:12:07,250 --> 00:12:11,213
We also use dynamic toggle, where all the features are

258
00:12:11,313 --> 00:12:13,955
still compiled in, and we ship them to our players.

259
00:12:14,356 --> 00:12:15,136
But then we choose.

260
00:12:15,875 --> 00:12:19,440
to switch that feature on or off based on some criteria.

261
00:12:19,460 --> 00:12:22,123
Let's say we want to test a feature that we're just

262
00:12:22,143 --> 00:12:24,565
developing, and we want to give it to a small number of players

263
00:12:25,146 --> 00:12:27,829
to learn something quickly or prove that it works

264
00:12:27,869 --> 00:12:28,670
and build confidence.

265
00:12:28,991 --> 00:12:30,733
So we use dynamic toggles for that purpose.

266
00:12:32,134 --> 00:12:34,657
And here is an example of implementation

267
00:12:34,717 --> 00:12:35,518
of compile toggle.

268
00:12:36,639 --> 00:12:39,020
We use JSON files to define our features.

269
00:12:39,940 --> 00:12:42,640
And in our C++ code, it's a simple if statement.

270
00:12:42,660 --> 00:12:45,241
So it checks to see if it's enabled, do this,

271
00:12:45,321 --> 00:12:46,181
otherwise do that.

272
00:12:49,061 --> 00:12:51,442
With dynamic toggle, it's slightly more complicated.

273
00:12:51,742 --> 00:12:55,983
We still use the same JSON file to define these features.

274
00:12:57,103 --> 00:12:59,883
And the way it works is when our server starts,

275
00:13:00,103 --> 00:13:03,084
it talks to our services to get the list of features

276
00:13:03,104 --> 00:13:03,804
that are toggled on.

277
00:13:05,347 --> 00:13:07,547
And when the client starts, it talks to the same set

278
00:13:07,587 --> 00:13:09,347
of services to get the list as well.

279
00:13:10,167 --> 00:13:12,768
And when clients try to join the server,

280
00:13:13,648 --> 00:13:15,088
they send the list to the server.

281
00:13:15,128 --> 00:13:16,549
And server compares the two lists.

282
00:13:16,829 --> 00:13:19,709
If they match, it allows the client to join the server.

283
00:13:20,049 --> 00:13:21,510
Otherwise, it will reject the client.

284
00:13:22,510 --> 00:13:23,830
That was quite intentional, because we

285
00:13:23,870 --> 00:13:27,071
didn't want different clients with different set of toggles

286
00:13:27,111 --> 00:13:28,111
to be playing with each other.

287
00:13:31,992 --> 00:13:34,812
We also tried to continuously improve our cycle time.

288
00:13:35,953 --> 00:13:38,895
Cycle time is the time it takes from somebody deciding

289
00:13:38,915 --> 00:13:43,216
to make a change, analyze their work, implement their work,

290
00:13:43,596 --> 00:13:46,417
get it reviewed and submitted to our source control system.

291
00:13:46,437 --> 00:13:49,258
Our CI server to verify the change,

292
00:13:50,499 --> 00:13:51,919
and pass the manual verification,

293
00:13:51,979 --> 00:13:54,640
and finally is released to retail or production.

294
00:13:57,582 --> 00:13:58,762
And here are some of the benefits

295
00:13:59,002 --> 00:14:00,323
of having a short cycle time.

296
00:14:01,863 --> 00:14:04,064
By having short cycle time, we can get fast feedback.

297
00:14:05,084 --> 00:14:07,107
which we can find out if we can release, let's say,

298
00:14:07,127 --> 00:14:08,528
make a change and give it to our players.

299
00:14:08,568 --> 00:14:10,951
We can soon find out if it works or not, which hopefully

300
00:14:10,971 --> 00:14:12,313
leads to better quality game.

301
00:14:13,894 --> 00:14:16,317
It allows us to work in small batches, which

302
00:14:16,417 --> 00:14:17,939
leads to lower risk.

303
00:14:18,420 --> 00:14:22,244
Because we don't need to worry about piling a lot of change.

304
00:14:22,284 --> 00:14:24,026
Because we are going to release regularly, because

305
00:14:24,086 --> 00:14:25,048
it's so easy to do that.

306
00:14:26,451 --> 00:14:28,493
It also reduces handovers.

307
00:14:28,513 --> 00:14:30,075
If we want to have fast cycle time,

308
00:14:30,115 --> 00:14:32,438
we cannot afford to pass the work to different teams

309
00:14:32,938 --> 00:14:34,620
and hand it over to them, which means

310
00:14:34,640 --> 00:14:36,202
we have to restructure our teams.

311
00:14:36,683 --> 00:14:37,984
Therefore, they are cross-functional.

312
00:14:38,084 --> 00:14:41,889
And the team is responsible for the end-to-end time

313
00:14:42,009 --> 00:14:42,890
and the whole process.

314
00:14:43,170 --> 00:14:45,232
We're working on the feature until we give it to players

315
00:14:46,033 --> 00:14:46,994
and get feedback from that.

316
00:14:48,425 --> 00:14:50,507
And in addition, if you find a problem,

317
00:14:52,188 --> 00:14:54,449
we find a critical bug, we can easily

318
00:14:54,769 --> 00:14:56,450
respond and release a patch.

319
00:15:00,513 --> 00:15:03,434
Deployment pipeline is the implementation

320
00:15:04,115 --> 00:15:07,537
of our process for working and delivering these features.

321
00:15:08,557 --> 00:15:11,079
And for this project, for Sea of Thieves,

322
00:15:11,757 --> 00:15:14,980
We formed a new team of mainly generalist engineers

323
00:15:15,740 --> 00:15:17,301
to implement this deployment pipeline.

324
00:15:17,341 --> 00:15:19,043
And that's the team that I lead at Rare.

325
00:15:21,084 --> 00:15:24,246
And here are some of the examples of the things we do.

326
00:15:26,028 --> 00:15:27,429
We've developed our test framework.

327
00:15:28,570 --> 00:15:31,092
We are responsible for our workflow, for our developers,

328
00:15:31,132 --> 00:15:32,953
for our artists to make changes and get them

329
00:15:32,993 --> 00:15:34,054
into source control system.

330
00:15:35,175 --> 00:15:37,696
We look after our infrastructure and implement our pipeline.

331
00:15:39,503 --> 00:15:41,504
And here are some specific things we've done to improve

332
00:15:41,524 --> 00:15:42,285
the cycle time.

333
00:15:43,745 --> 00:15:46,327
We've developed a system to identify flaky tests.

334
00:15:46,547 --> 00:15:50,229
Flaky tests are tests that you run them once, they fail, we

335
00:15:50,269 --> 00:15:52,090
run them again on the same set of change, and

336
00:15:52,130 --> 00:15:53,031
this time they pass.

337
00:15:53,551 --> 00:15:54,412
So you're not really sure.

338
00:15:54,452 --> 00:15:55,453
They're not deterministic.

339
00:15:56,473 --> 00:15:57,974
I'll talk about them in later slides.

340
00:15:58,835 --> 00:16:01,056
We implemented the feature toggle in our code base.

341
00:16:02,457 --> 00:16:04,878
We regularly try to improve our build time and our cook

342
00:16:04,898 --> 00:16:05,098
time.

343
00:16:06,334 --> 00:16:08,755
And we have tried to parallelize running our test

344
00:16:08,775 --> 00:16:09,636
across many machines.

345
00:16:14,518 --> 00:16:17,580
Next practice we do is tackling technical debt.

346
00:16:19,861 --> 00:16:23,263
If on the traditional process, when we don't address

347
00:16:23,563 --> 00:16:26,944
technical debt, the velocity looks like this red line here.

348
00:16:28,133 --> 00:16:30,855
And velocity is the rate that we can deliver features to our

349
00:16:30,875 --> 00:16:31,275
players.

350
00:16:32,035 --> 00:16:33,916
At the beginning, the velocity might be high.

351
00:16:34,356 --> 00:16:36,718
We can work on features easily.

352
00:16:37,178 --> 00:16:41,520
But what we find is after a while, as the code base grows,

353
00:16:41,820 --> 00:16:44,341
it takes longer and longer to work on features and develop

354
00:16:44,381 --> 00:16:44,561
them.

355
00:16:45,762 --> 00:16:47,823
On the other hand, when we're dealing with technical debt,

356
00:16:48,223 --> 00:16:51,125
the velocity looks more like this green line, where maybe

357
00:16:51,165 --> 00:16:53,366
at the beginning, the velocity is lower.

358
00:16:54,357 --> 00:16:57,099
But over time, as the code base grows and more people work

359
00:16:57,139 --> 00:16:59,220
on the project, the velocity doesn't drop.

360
00:16:59,280 --> 00:17:00,921
It actually might even increase.

361
00:17:02,021 --> 00:17:04,302
And the important thing here is that there's a point in

362
00:17:04,342 --> 00:17:06,603
time when these two lines crosses.

363
00:17:06,784 --> 00:17:10,145
And the people who argue against tackling technical

364
00:17:10,185 --> 00:17:13,167
debt, they think that their project would be done before

365
00:17:13,207 --> 00:17:14,287
these two lines crosses.

366
00:17:14,908 --> 00:17:17,249
But what we found is, unless the project's going to last

367
00:17:17,289 --> 00:17:19,630
maybe three to six months, you're definitely going to

368
00:17:19,650 --> 00:17:20,831
cross this point.

369
00:17:21,171 --> 00:17:23,392
So it's well worth the effort to tackle technical debt.

370
00:17:26,740 --> 00:17:30,283
But at the same time, we don't have zero technical debt

371
00:17:30,323 --> 00:17:30,844
all the time.

372
00:17:31,484 --> 00:17:34,767
Sometimes we intentionally accumulate some technical debt

373
00:17:35,427 --> 00:17:37,949
because let's say we want to prioritize delivering

374
00:17:38,010 --> 00:17:41,012
a feature to our players quickly to learn something from that.

375
00:17:41,472 --> 00:17:43,174
But what we do is, once that's done,

376
00:17:43,374 --> 00:17:44,995
we go back and pay that technical debt.

377
00:17:49,336 --> 00:17:53,799
I would argue that continuous improvement is probably our most important practice, because

378
00:17:53,819 --> 00:17:59,482
we're trying to build a learning organization to learn from mistakes, problems, and failures,

379
00:18:00,042 --> 00:18:01,083
and get better every day.

380
00:18:02,784 --> 00:18:08,007
Our teams do regular retrospectives, usually every two weeks, which they sit down and talk

381
00:18:08,047 --> 00:18:11,869
about what went well, what went wrong, and what can they do to improve.

382
00:18:13,230 --> 00:18:16,972
If something happens, which means that we can't ship the game, like we have an incident,

383
00:18:17,821 --> 00:18:19,882
We usually do blameless postmortems,

384
00:18:19,942 --> 00:18:22,324
when the purpose isn't there to blame somebody who

385
00:18:22,344 --> 00:18:24,265
caused the issue, but to understand

386
00:18:24,845 --> 00:18:26,646
why we ended up in this situation

387
00:18:26,686 --> 00:18:30,728
and how we can avoid this so we're not in the same situation

388
00:18:30,768 --> 00:18:32,169
again in future.

389
00:18:33,870 --> 00:18:35,991
And more importantly, we try to allocate time

390
00:18:36,492 --> 00:18:39,153
to complete the actions that we identify.

391
00:18:40,052 --> 00:18:44,077
in these meetings, because what we found is if we just sit down and talk about these problems,

392
00:18:44,618 --> 00:18:48,564
but we don't allocate time, then people will stop coming to these meetings and they will

393
00:18:48,584 --> 00:18:49,305
lose faith in it.

394
00:18:50,947 --> 00:18:53,270
And these sort of practices that I just explained here.

395
00:18:54,409 --> 00:18:56,471
We didn't have these when we started the project.

396
00:18:56,491 --> 00:18:58,493
We didn't sit down and say, these are the things we want to do.

397
00:18:59,213 --> 00:19:02,396
What we did instead was we read what other people have done,

398
00:19:02,977 --> 00:19:05,299
talked to them, especially from other industries,

399
00:19:05,919 --> 00:19:07,401
and applied them to our own context,

400
00:19:08,101 --> 00:19:09,763
and kept the practices that made sense

401
00:19:09,963 --> 00:19:11,545
and helped us solve our problems.

402
00:19:12,205 --> 00:19:14,727
And I fully expect, probably in a year's time,

403
00:19:15,548 --> 00:19:17,610
we would maybe be adopting some new practices,

404
00:19:17,850 --> 00:19:21,133
because we want to keep adapting to our situation.

405
00:19:24,568 --> 00:19:26,429
Now I'm going to talk about challenges

406
00:19:26,449 --> 00:19:28,490
we've had in adopting continuous delivery.

407
00:19:31,791 --> 00:19:34,973
One of our first challenges was changing our developer's

408
00:19:35,033 --> 00:19:37,594
mindset to adopt testing mindset.

409
00:19:39,015 --> 00:19:41,156
We're coming from a place where some of our developers

410
00:19:41,196 --> 00:19:43,477
would argue that they know their area of code base

411
00:19:43,517 --> 00:19:45,378
so well that they can easily make changes

412
00:19:45,478 --> 00:19:46,799
without introducing new bugs.

413
00:19:48,170 --> 00:19:51,332
But what we wanted to do was promote shared code ownership.

414
00:19:51,852 --> 00:19:53,834
We wanted everybody to feel confident

415
00:19:53,854 --> 00:19:55,675
that they can go and make changes

416
00:19:55,695 --> 00:19:57,116
to different areas of the code base.

417
00:19:57,676 --> 00:19:59,177
So therefore, we had to have some tests

418
00:19:59,578 --> 00:20:01,979
to catch issues if they're not familiar with our code base.

419
00:20:03,020 --> 00:20:06,082
So what we did was we started with a small core team who

420
00:20:06,162 --> 00:20:07,303
all believed in this idea.

421
00:20:08,404 --> 00:20:10,565
And we gradually added more people to the team.

422
00:20:11,886 --> 00:20:13,067
And everybody who joined the team

423
00:20:13,487 --> 00:20:15,709
went through an onboarding process, including

424
00:20:15,749 --> 00:20:16,510
some test training.

425
00:20:18,069 --> 00:20:20,250
We also had a separate prototype team

426
00:20:20,651 --> 00:20:23,072
using different code base and even different game engine.

427
00:20:24,553 --> 00:20:26,594
Because what we found is, in the past,

428
00:20:26,894 --> 00:20:29,536
that prototype code could end up being the production code.

429
00:20:29,616 --> 00:20:31,257
And by actually having separate code base,

430
00:20:31,877 --> 00:20:34,299
our developers had to go and re-implement that feature

431
00:20:34,779 --> 00:20:35,780
using a different level of code.

432
00:20:39,787 --> 00:20:42,889
We also do mandatory code reviews for every check-ins.

433
00:20:43,410 --> 00:20:45,591
And as part of that code review, we always

434
00:20:45,611 --> 00:20:49,134
check to make sure we have adequate testing when

435
00:20:49,294 --> 00:20:50,275
people try to make changes.

436
00:20:54,858 --> 00:20:55,539
Commit stage.

437
00:20:55,799 --> 00:20:57,840
Having a fast commit stage is another challenge for us.

438
00:20:58,401 --> 00:21:01,583
Commit stage is the first stage of our pipeline.

439
00:21:02,143 --> 00:21:04,425
And its job is to reject changes.

440
00:21:05,606 --> 00:21:07,306
that would invalidate our release candidates

441
00:21:07,646 --> 00:21:08,667
as quickly as possible.

442
00:21:09,247 --> 00:21:12,008
And here is an example of the things we do in commit stage.

443
00:21:13,728 --> 00:21:14,468
We compile code.

444
00:21:14,488 --> 00:21:15,789
We sync from source control system.

445
00:21:15,829 --> 00:21:19,530
We compile code and cook assets and create our build artifacts.

446
00:21:20,170 --> 00:21:22,550
And we run a small set of tests to prove

447
00:21:22,610 --> 00:21:24,431
that game largely still works.

448
00:21:25,311 --> 00:21:27,652
And then we use these artifacts that are generated for later

449
00:21:27,732 --> 00:21:29,092
stages of our pipeline.

450
00:21:30,159 --> 00:21:33,040
You have to bear in mind that just because commit stage pass

451
00:21:33,080 --> 00:21:35,160
doesn't mean that we can ship the game,

452
00:21:35,200 --> 00:21:37,480
because we have other tests, like as I mentioned,

453
00:21:37,500 --> 00:21:39,141
like performance tests that we run later on,

454
00:21:39,561 --> 00:21:40,801
that give us better indication.

455
00:21:43,862 --> 00:21:46,882
And our developers wait for when they commit their change

456
00:21:47,222 --> 00:21:51,003
for the commit stage to pass before they start the new work,

457
00:21:51,503 --> 00:21:53,364
go home, go to meeting, or go to lunch,

458
00:21:53,484 --> 00:21:55,764
because we expect them to deal with it if anything goes wrong.

459
00:21:59,646 --> 00:22:03,307
And here are some of the lessons we've learned in trying to deal

460
00:22:03,347 --> 00:22:04,728
with having a fast commit stage.

461
00:22:06,088 --> 00:22:07,449
We need to continuously improve.

462
00:22:08,049 --> 00:22:10,530
We made a mistake in this project to begin with,

463
00:22:10,610 --> 00:22:13,311
where we spent some time trying to improve the commit stage,

464
00:22:13,851 --> 00:22:15,212
and it reached an acceptable level.

465
00:22:15,852 --> 00:22:16,372
Then we stopped.

466
00:22:16,392 --> 00:22:17,752
We moved on to do some other work.

467
00:22:18,213 --> 00:22:19,833
But what we found was, after a couple of months,

468
00:22:19,893 --> 00:22:21,234
we were back to where we were before.

469
00:22:21,794 --> 00:22:24,955
So we tried to continuously improve commit stage.

470
00:22:25,295 --> 00:22:27,456
Because as people add more code, add more tests,

471
00:22:27,516 --> 00:22:29,096
and more content, everything takes longer.

472
00:22:31,512 --> 00:22:33,513
Sometimes, some of our optimization

473
00:22:33,653 --> 00:22:35,714
can lead to having more complicated systems.

474
00:22:36,234 --> 00:22:39,115
So every time we try to look at an optimization

475
00:22:39,155 --> 00:22:41,236
in a solution, we assess it to see

476
00:22:41,296 --> 00:22:44,117
does it improve the complexity or reduces

477
00:22:44,157 --> 00:22:45,937
the complexity of our system.

478
00:22:47,278 --> 00:22:49,759
And generally, we go in favor of the solutions that reduce

479
00:22:49,779 --> 00:22:50,959
the complexity of our system.

480
00:22:52,762 --> 00:22:55,405
And we want to monitor the stability and confidence

481
00:22:55,445 --> 00:22:57,206
in the build as we optimize it, because we

482
00:22:57,226 --> 00:23:00,249
don't want to have a fast commit stage that people don't really

483
00:23:00,289 --> 00:23:03,091
trust, because we stopped running tests because they

484
00:23:03,111 --> 00:23:04,072
were taking too long to run.

485
00:23:06,134 --> 00:23:09,377
And we try to identify and stop doing unnecessary work,

486
00:23:09,938 --> 00:23:12,180
as opposed to trying to do those unnecessary work quickly.

487
00:23:14,341 --> 00:23:16,003
And here are some specific things

488
00:23:16,043 --> 00:23:18,365
that make commit stage long.

489
00:23:20,049 --> 00:23:21,470
As I'm sure many of you have experienced,

490
00:23:21,510 --> 00:23:23,831
compiling large C++ codebase takes a very long time.

491
00:23:24,271 --> 00:23:26,892
So we use distributed build systems

492
00:23:26,952 --> 00:23:28,953
where it distributes all the compiled tasks

493
00:23:29,013 --> 00:23:31,334
on different machines and then bring the results back

494
00:23:31,374 --> 00:23:32,855
and link on the machine.

495
00:23:34,436 --> 00:23:35,676
We work really hard to make sure

496
00:23:35,716 --> 00:23:38,097
we can reliably use incremental build,

497
00:23:38,518 --> 00:23:40,799
and this goes back to what I was saying earlier

498
00:23:40,919 --> 00:23:42,700
about stop doing unnecessary work.

499
00:23:43,840 --> 00:23:45,801
Let's say in a build, if you only change 5% of our codebase,

500
00:23:47,575 --> 00:23:50,218
We don't need to go and compile that 95% of the code

501
00:23:50,258 --> 00:23:51,059
if they haven't changed.

502
00:23:51,339 --> 00:23:53,281
We should be able to rely on incremental build

503
00:23:53,702 --> 00:23:56,284
and only compile that 5% of our code that's changed.

504
00:23:58,046 --> 00:24:00,889
We have a, relatively speaking, huge build farm,

505
00:24:01,089 --> 00:24:05,594
about 150 physical PCs that help with this.

506
00:24:05,654 --> 00:24:09,818
They have two CPUs with 64 to 128 gigabytes of memory

507
00:24:09,858 --> 00:24:10,879
with NVMe drives.

508
00:24:15,037 --> 00:24:19,279
As much as we like, we cannot afford to run all of those 40,000 tests that we have.

509
00:24:19,559 --> 00:24:24,181
So we need to make sure we identify and prioritize the tests that are most valuable for us.

510
00:24:26,122 --> 00:24:30,884
And to begin with, what we did was we prioritized running tests that were failing more often

511
00:24:31,364 --> 00:24:34,005
in our commit stage and stopped running tests that were not failing.

512
00:24:34,025 --> 00:24:37,707
And that was a good start, but then there were some problems with this.

513
00:24:37,827 --> 00:24:41,148
Let's say an area of code base has been stapled and nobody's been changing it.

514
00:24:42,082 --> 00:24:43,162
So we stopped running those tests.

515
00:24:43,242 --> 00:24:45,222
But as soon as somebody went and made some changes

516
00:24:45,242 --> 00:24:47,923
to that area, now they didn't have any coverage

517
00:24:47,983 --> 00:24:48,843
in our commit stage.

518
00:24:49,183 --> 00:24:51,463
And they would find out later on when we run the test

519
00:24:51,523 --> 00:24:52,384
at later stages.

520
00:24:52,644 --> 00:24:54,504
So the feedback loop was too long.

521
00:24:56,064 --> 00:24:59,805
So instead, what we did is we developed another system that

522
00:24:59,845 --> 00:25:02,626
runs each test and creates a map to see

523
00:25:02,646 --> 00:25:04,126
which code files it covers.

524
00:25:05,226 --> 00:25:08,447
And then when we try to run the commit stage on a build,

525
00:25:08,787 --> 00:25:10,307
it looks at the changes in that build.

526
00:25:11,279 --> 00:25:13,523
and see which files are there, look at this map,

527
00:25:14,164 --> 00:25:16,188
and find the test that covers those code files

528
00:25:16,268 --> 00:25:17,771
and only runs those tests.

529
00:25:18,592 --> 00:25:21,057
We found that that gives us much better confidence

530
00:25:21,137 --> 00:25:21,838
in the tests that we run.

531
00:25:26,378 --> 00:25:28,859
Game packages are quite big these days,

532
00:25:28,879 --> 00:25:30,580
between 100 to 150 gigabytes.

533
00:25:31,220 --> 00:25:33,021
And we may not need the whole game package

534
00:25:33,121 --> 00:25:35,122
to run some of our unit tests, but still there

535
00:25:35,142 --> 00:25:37,483
are tests that we run in our pipeline that

536
00:25:37,503 --> 00:25:38,943
requires the whole game package.

537
00:25:38,983 --> 00:25:42,244
So having just fast network connection to transfer this

538
00:25:42,545 --> 00:25:42,845
helps.

539
00:25:44,345 --> 00:25:46,346
Our build agents have local cache

540
00:25:46,586 --> 00:25:48,087
to store these build artifacts.

541
00:25:48,607 --> 00:25:51,688
Let's say an agent downloads a build artifact

542
00:25:51,708 --> 00:25:52,488
to run some tests.

543
00:25:53,263 --> 00:25:55,404
At one stage of our pipeline, and later on,

544
00:25:55,464 --> 00:25:57,805
it tries to run another set of tests on the same build.

545
00:25:58,465 --> 00:26:00,426
As opposed to have to go and download the build again,

546
00:26:00,446 --> 00:26:02,407
they can use their local cache.

547
00:26:04,627 --> 00:26:06,268
And our build agents can serve artifacts

548
00:26:06,288 --> 00:26:08,489
between each other, which helps from all the agents going

549
00:26:08,529 --> 00:26:10,129
to the server to download the build.

550
00:26:14,150 --> 00:26:16,611
Flaky tests has been another big problem for us,

551
00:26:17,532 --> 00:26:18,712
especially when we started.

552
00:26:19,667 --> 00:26:22,089
we were not sure how to write good tests.

553
00:26:22,609 --> 00:26:24,551
So a lot of tests that we wrote at the beginning

554
00:26:25,852 --> 00:26:26,973
end up being flaky.

555
00:26:27,514 --> 00:26:29,435
And here is the problem with having flaky tests.

556
00:26:30,176 --> 00:26:31,297
Because when we have flaky tests,

557
00:26:31,938 --> 00:26:34,380
they infect our automated tests.

558
00:26:35,441 --> 00:26:37,543
And when they fail, you're not sure

559
00:26:37,643 --> 00:26:40,445
if it's because of a change, a break you introduced,

560
00:26:40,565 --> 00:26:41,606
or because of flakiness.

561
00:26:42,607 --> 00:26:45,289
And what's even worse, it can also fail other people's build.

562
00:26:46,366 --> 00:26:48,987
Which means that then developers lose confidence in

563
00:26:49,027 --> 00:26:49,527
our system.

564
00:26:50,428 --> 00:26:52,368
And therefore, they are not feeling comfortable when

565
00:26:52,408 --> 00:26:56,490
making changes, which means that eventually, they are

566
00:26:56,570 --> 00:26:57,970
slower to develop new features.

567
00:27:02,452 --> 00:27:04,373
And here are some of the lessons we've learned in

568
00:27:04,393 --> 00:27:05,613
dealing with flaky tests.

569
00:27:07,194 --> 00:27:10,135
Actually, having fewer deterministic tests is much

570
00:27:10,195 --> 00:27:12,276
better than having lots of tests that are flaky.

571
00:27:13,582 --> 00:27:16,064
And we try to work hard to make sure these flaky tests

572
00:27:16,104 --> 00:27:17,345
don't infect our pipeline.

573
00:27:18,206 --> 00:27:19,427
And we try to quarantine them.

574
00:27:20,127 --> 00:27:23,029
And we either try to fix them and move them out of quarantine,

575
00:27:23,610 --> 00:27:25,972
or we just go and delete them if they're not valuable

576
00:27:26,012 --> 00:27:28,274
and they don't provide coverage for us.

577
00:27:31,456 --> 00:27:33,037
Here are some of the common causes

578
00:27:33,858 --> 00:27:35,679
of having flaky tests for us.

579
00:27:37,340 --> 00:27:40,863
Using random weights, let's say sleep for five seconds.

580
00:27:42,540 --> 00:27:46,322
As an example, let's say the service starts as a test.

581
00:27:46,942 --> 00:27:48,563
It's waiting for a client to launch.

582
00:27:48,823 --> 00:27:49,983
So it waits for five seconds.

583
00:27:50,063 --> 00:27:51,484
Everything might be fine at the beginning.

584
00:27:52,124 --> 00:27:54,605
But as you add more content, the client takes longer to

585
00:27:54,645 --> 00:27:57,426
boot, which means that when it gets close to that five

586
00:27:57,466 --> 00:27:59,307
seconds, sometimes you might fail or pass.

587
00:27:59,327 --> 00:28:01,308
Because sometimes it might just go over five seconds.

588
00:28:01,688 --> 00:28:02,669
And sometimes it's not.

589
00:28:06,070 --> 00:28:07,431
And tests that are not isolated.

590
00:28:08,402 --> 00:28:12,043
They can fail depending on what tests ran before them.

591
00:28:12,983 --> 00:28:16,604
Let's say if a test relies on some state to be set, but it

592
00:28:16,624 --> 00:28:19,986
doesn't set them, depending on what tests ran before, those

593
00:28:20,086 --> 00:28:22,646
other tests might be overriding those states.

594
00:28:22,847 --> 00:28:25,287
So these tests might randomly fail or pass depending on what

595
00:28:25,307 --> 00:28:26,448
other tests ran before them.

596
00:28:29,012 --> 00:28:32,394
And for some of our tests that we rely on external dependencies,

597
00:28:32,714 --> 00:28:35,036
like some remote services, they can just

598
00:28:35,076 --> 00:28:38,317
fail if that remote service goes down without actually us

599
00:28:38,657 --> 00:28:39,578
introducing any issue.

600
00:28:45,241 --> 00:28:48,283
So another challenge here is how much time we

601
00:28:48,303 --> 00:28:49,583
should allocate for improvement.

602
00:28:50,804 --> 00:28:52,065
We have three types of work.

603
00:28:52,805 --> 00:28:54,086
The first category is

604
00:28:54,760 --> 00:28:57,682
planned work or the work that we do, that we plan to do,

605
00:28:57,702 --> 00:28:59,023
like, let's say develop features.

606
00:28:59,643 --> 00:29:01,864
And that's the kind of work that, let's say,

607
00:29:01,904 --> 00:29:04,606
business and production wants us to spend most of our time.

608
00:29:06,007 --> 00:29:09,329
But the reality is that we also have to do some unplanned work.

609
00:29:09,589 --> 00:29:10,549
Let's say fix bugs.

610
00:29:10,629 --> 00:29:13,111
If a game crashes, there are serious problems

611
00:29:13,131 --> 00:29:15,812
that we have to go and deal with that prevents us

612
00:29:15,872 --> 00:29:18,053
from actually developing feature.

613
00:29:19,854 --> 00:29:21,896
The third category is the improvement work.

614
00:29:22,854 --> 00:29:25,016
And these are the work that would address the root cause

615
00:29:25,196 --> 00:29:28,018
of those bugs or the incidents that we've had.

616
00:29:29,419 --> 00:29:32,041
And there is no rule about how much time

617
00:29:32,061 --> 00:29:33,482
we should spend for each category,

618
00:29:33,982 --> 00:29:36,324
but there is a very good feedback mechanism there.

619
00:29:36,944 --> 00:29:39,386
If we notice that we spend too much time

620
00:29:39,426 --> 00:29:41,708
doing unplanned work, it means that we are probably

621
00:29:41,748 --> 00:29:44,270
not spending enough time doing improvement work,

622
00:29:44,330 --> 00:29:46,671
which indicates that we need to spend more time

623
00:29:46,772 --> 00:29:47,572
doing improvement work.

624
00:29:51,741 --> 00:29:53,942
And here are some of the challenges

625
00:29:54,883 --> 00:29:57,024
we've had in releasing weekly with confidence.

626
00:29:59,646 --> 00:30:02,248
As I mentioned, game packages are quite big.

627
00:30:02,308 --> 00:30:03,949
So we want to make sure every time we release,

628
00:30:04,469 --> 00:30:06,911
our patch sizes are as small as possible.

629
00:30:07,751 --> 00:30:09,952
To make our life simpler, we only

630
00:30:09,993 --> 00:30:12,594
allow one version of the game that everybody

631
00:30:12,694 --> 00:30:13,735
use at any given time.

632
00:30:13,855 --> 00:30:15,916
We don't allow different versions of the game to be live.

633
00:30:16,932 --> 00:30:20,921
Which means that every time somebody wants to play and we have released an update, they have to go and update.

634
00:30:21,663 --> 00:30:25,953
And if that update is, let's say, 20 gigabytes, people would soon stop playing our game.

635
00:30:29,244 --> 00:30:31,605
The other challenge is delivering new features

636
00:30:31,685 --> 00:30:32,166
regularly.

637
00:30:32,186 --> 00:30:35,629
Because traditionally, like let's say designers, they want

638
00:30:35,669 --> 00:30:39,171
to only release the feature to players when the whole

639
00:30:39,291 --> 00:30:40,652
experience is complete.

640
00:30:41,413 --> 00:30:43,415
But that might take, let's say, three to six months

641
00:30:43,435 --> 00:30:44,576
sometimes for a big feature.

642
00:30:45,116 --> 00:30:47,878
So it requires a change in mindset to say, how can I

643
00:30:47,918 --> 00:30:50,720
break this experience that might take three months into

644
00:30:50,780 --> 00:30:53,663
smaller chunks that we can still release, ideally weekly,

645
00:30:54,143 --> 00:30:57,305
to our players, but still is the full experience when it's

646
00:30:57,325 --> 00:30:57,746
completed.

647
00:31:00,679 --> 00:31:07,489
As much as we like to, we cannot prevent issues going out to our players, because games are

648
00:31:07,529 --> 00:31:08,351
complex systems.

649
00:31:09,163 --> 00:31:12,025
Therefore, we try to minimize the impact of something

650
00:31:12,065 --> 00:31:13,006
when something goes wrong.

651
00:31:13,766 --> 00:31:16,788
As an example, let's say one of our services is down,

652
00:31:16,908 --> 00:31:19,889
which means players cannot buy or sell items in the game.

653
00:31:20,670 --> 00:31:22,551
We don't want the game to crash every time somebody

654
00:31:22,571 --> 00:31:25,212
goes into a shop to, let's say, buy or sell items.

655
00:31:25,892 --> 00:31:28,754
It's much better if game detects that and, let's say,

656
00:31:28,774 --> 00:31:31,075
puts a sign on the shop to say shopkeeper is away,

657
00:31:31,195 --> 00:31:31,856
come back later.

658
00:31:31,876 --> 00:31:34,857
And it removes that sign when the service is back online.

659
00:31:37,152 --> 00:31:40,513
And the other thing is, we try to identify these issues

660
00:31:40,873 --> 00:31:42,654
as quickly as possible, so then we can,

661
00:31:42,834 --> 00:31:44,354
thanks to having fast cycle time,

662
00:31:44,795 --> 00:31:46,155
we can respond quickly to them.

663
00:31:48,856 --> 00:31:50,597
And finally, the certification process.

664
00:31:52,338 --> 00:31:54,498
Platform holders like Microsoft,

665
00:31:54,899 --> 00:31:57,419
they have a certification process and certification team.

666
00:31:58,300 --> 00:32:01,521
Traditionally for us, that process could take one week,

667
00:32:01,541 --> 00:32:02,521
sometimes up to two weeks.

668
00:32:02,861 --> 00:32:04,862
So our release frequency is bound by that.

669
00:32:05,542 --> 00:32:07,723
So for this project, because we wanted to release regularly,

670
00:32:07,783 --> 00:32:11,364
we started a lot of conversation with the certification team.

671
00:32:11,984 --> 00:32:13,524
And we did a great collaboration with them,

672
00:32:13,804 --> 00:32:16,145
where they evolved their process.

673
00:32:17,105 --> 00:32:19,285
And as opposed to, again, trying to prevent these issues

674
00:32:19,626 --> 00:32:20,466
from going out.

675
00:32:21,419 --> 00:32:23,741
they trusted us that we can do it ourselves.

676
00:32:24,302 --> 00:32:27,665
And instead, they agreed to monitor some key metrics

677
00:32:27,725 --> 00:32:29,106
for us in retail.

678
00:32:29,847 --> 00:32:31,989
And as long as those key metrics, let's say crash rate

679
00:32:32,049 --> 00:32:34,711
as an example, was below a certain level,

680
00:32:35,592 --> 00:32:37,334
they trusted us to keep releasing.

681
00:32:38,054 --> 00:32:40,937
And the agreement was if they find a problem,

682
00:32:40,977 --> 00:32:43,960
suddenly let's say crash rate increases significantly,

683
00:32:44,912 --> 00:32:48,353
Then they can jump in and have a conversation to understand what has gone wrong.

684
00:32:48,973 --> 00:32:52,494
And we got to a point right now, from this point, that we have a build.

685
00:32:52,834 --> 00:32:56,095
Until it's available for our players to play, it's about six hours.

686
00:32:56,435 --> 00:32:58,235
That's much improvement from what we had before.

687
00:32:58,255 --> 00:32:59,655
That was a week, sometimes two weeks.

688
00:33:03,156 --> 00:33:05,297
And here are some of the takeaways from my talk.

689
00:33:06,957 --> 00:33:10,118
We try to work in small batches to reduce the risk.

690
00:33:12,239 --> 00:33:14,501
of releasing regularly, because we want to make sure

691
00:33:14,521 --> 00:33:17,022
we can release regularly and safely so we can learn fast,

692
00:33:17,342 --> 00:33:18,683
and therefore have better quality game

693
00:33:18,723 --> 00:33:20,064
that is more fun for our players.

694
00:33:21,845 --> 00:33:24,627
As much as we like to, we cannot prevent issues.

695
00:33:25,247 --> 00:33:27,209
So we are prepared for something to go wrong,

696
00:33:28,049 --> 00:33:30,190
but instead, we work really hard to make sure

697
00:33:30,210 --> 00:33:33,512
we can respond really quickly to these incidents.

698
00:33:34,653 --> 00:33:36,254
And we try to continuously improve.

699
00:33:37,275 --> 00:33:39,756
So every day we are better than the day before.

700
00:33:41,899 --> 00:33:44,461
And we are not done with continuous delivery by no means.

701
00:33:45,001 --> 00:33:46,842
We've been on this journey for four or five years,

702
00:33:47,783 --> 00:33:50,264
and there are still room for much improvements.

703
00:33:50,804 --> 00:33:51,925
So we're going to carry on improving.

704
00:33:54,386 --> 00:33:58,389
Before I go, I wanted to talk about two books

705
00:33:58,409 --> 00:33:59,990
that have been very influential on me

706
00:34:00,070 --> 00:34:00,990
and my friends at Rare.

707
00:34:02,131 --> 00:34:05,413
Continuous Delivery book by James Humble and Dave Farley.

708
00:34:05,853 --> 00:34:08,335
It's a great book that goes through much more detail

709
00:34:08,355 --> 00:34:10,076
about the principles that I talked about here.

710
00:34:11,295 --> 00:34:13,376
And The Goal by Goldratt, which talks

711
00:34:13,436 --> 00:34:14,697
about theory of constraint.

712
00:34:15,197 --> 00:34:18,539
It's an amazing book if you're working on improving your

713
00:34:18,559 --> 00:34:22,540
cycle time and optimizing your pipeline by reducing bottlenecks.

714
00:34:25,542 --> 00:34:29,604
The authors of Continuous Delivery Book have a test,

715
00:34:29,944 --> 00:34:35,586
which they say, if you can ship your product to your audience

716
00:34:36,146 --> 00:34:39,048
by push of a button when you are on the beach having a cocktail.

717
00:34:39,845 --> 00:34:41,766
It's a good indication that you're doing a good job.

718
00:34:42,586 --> 00:34:43,867
Well, we released the game this week.

719
00:34:44,487 --> 00:34:46,368
I'm not at the beach having a cocktail, but I'm here at the

720
00:34:46,388 --> 00:34:47,489
conference giving you a talk.

721
00:34:47,549 --> 00:34:50,050
So I don't think we could have done this if you were not

722
00:34:50,090 --> 00:34:53,812
practicing these continuous delivery practices.

723
00:34:55,993 --> 00:34:57,954
So thank you for your time and listening to me.

724
00:35:06,258 --> 00:35:07,459
Does anybody have any questions?

725
00:35:09,490 --> 00:35:09,590
Hi.

726
00:35:10,270 --> 00:35:13,553
You mentioned about bringing your small core team on board

727
00:35:13,793 --> 00:35:15,235
and starting bringing more people.

728
00:35:15,755 --> 00:35:18,477
How long did that process take in terms of timeline,

729
00:35:18,497 --> 00:35:20,359
and what was the size of the team

730
00:35:20,399 --> 00:35:21,480
you started with and growing?

731
00:35:22,220 --> 00:35:24,943
I think it was about four or five developers when we started,

732
00:35:25,463 --> 00:35:26,724
and then we gradually added more.

733
00:35:27,805 --> 00:35:29,587
I cannot remember exactly how long it took,

734
00:35:29,807 --> 00:35:33,070
but maybe after the first month, then we

735
00:35:33,090 --> 00:35:35,331
brought new developers, but it was gradual.

736
00:35:35,752 --> 00:35:37,193
It wasn't sudden like sudden job.

737
00:35:40,325 --> 00:35:42,725
Hi, I've got a question about the automated testing

738
00:35:42,765 --> 00:35:43,325
that you're doing.

739
00:35:44,266 --> 00:35:45,846
Were you doing test-driven development

740
00:35:45,906 --> 00:35:47,687
where you're writing the tests first,

741
00:35:48,147 --> 00:35:49,987
or were you retrospectively adding

742
00:35:50,007 --> 00:35:52,168
the tests to new features?

743
00:35:52,588 --> 00:35:54,808
And a subsequent question, for legacy systems,

744
00:35:55,248 --> 00:35:56,909
how did you implement tests for them?

745
00:35:56,949 --> 00:35:58,089
Did you ensure coverage for them,

746
00:35:58,169 --> 00:35:59,469
or did you just leave them as is?

747
00:36:00,070 --> 00:36:05,331
So I think very few people did test-driven development.

748
00:36:06,210 --> 00:36:08,051
Not everybody did that, but the important thing

749
00:36:08,091 --> 00:36:10,353
was when they were trying to check in their changes,

750
00:36:10,453 --> 00:36:11,794
we made sure there was some tests there.

751
00:36:12,615 --> 00:36:14,716
The important thing for us was that when somebody added

752
00:36:15,137 --> 00:36:17,238
some change, there was some accompanying tests for that.

753
00:36:17,939 --> 00:36:19,280
There are some other benefits with doing

754
00:36:19,300 --> 00:36:22,522
test-driven development, which leads to more modular code,

755
00:36:23,083 --> 00:36:25,565
smaller functions that are testable.

756
00:36:26,005 --> 00:36:29,047
So it has other benefits there, but we didn't mandate that.

757
00:36:29,488 --> 00:36:31,770
We left them up to developers, and I think very few did that.

758
00:36:33,277 --> 00:36:36,039
And your second question, could you repeat that again?

759
00:36:36,559 --> 00:36:39,300
About legacy systems, were you testing legacy systems in the

760
00:36:39,320 --> 00:36:40,521
same way as new features?

761
00:36:41,942 --> 00:36:42,162
No.

762
00:36:42,302 --> 00:36:44,703
So for the area especially that we were not touching, we

763
00:36:44,723 --> 00:36:46,964
didn't bother adding any tests because we couldn't.

764
00:36:47,184 --> 00:36:51,546
And we were using Unreal, which is a huge legacy code.

765
00:36:51,607 --> 00:36:53,487
So we didn't try to go and add a lot of

766
00:36:53,527 --> 00:36:54,408
tests for Unreal code.

767
00:36:55,208 --> 00:36:55,428
Thank you.

768
00:36:59,551 --> 00:37:04,955
Hey, yeah, fabulous talk. Thank you. I could ask a hundred questions, but I'm specifically and you mentioned

769
00:37:04,975 --> 00:37:08,118
You've done a lot of work to make sure that you could trust incremental builds

770
00:37:08,338 --> 00:37:11,580
That's right. You could talk a little bit about what work. Did you do?

771
00:37:11,941 --> 00:37:17,005
because one of the problems we had because we were had about 150 agents and

772
00:37:17,705 --> 00:37:21,148
The state of the bill wasn't the same because if an agent wasn't used for a while

773
00:37:21,948 --> 00:37:24,410
then the cash could have been quite out of date or

774
00:37:25,327 --> 00:37:27,348
Because our developers do personal builds, which they

775
00:37:27,408 --> 00:37:30,830
upload their changes by our CI system to be tested before

776
00:37:30,850 --> 00:37:31,291
they come in.

777
00:37:31,331 --> 00:37:34,913
So some of those arch files might be newer and doesn't

778
00:37:34,973 --> 00:37:36,794
match the code that exists there.

779
00:37:36,874 --> 00:37:40,716
So we did a lot of work to make sure we're not in this

780
00:37:40,736 --> 00:37:43,177
situation where somebody can do a personal build, affect

781
00:37:43,197 --> 00:37:45,479
some arch files, and we end up using that arch file that

782
00:37:45,499 --> 00:37:47,520
doesn't match the source code in our game.

783
00:37:48,300 --> 00:37:48,961
That was the main thing.

784
00:37:49,021 --> 00:37:51,222
Did a lot of cleanup work to make sure they work reliably.

785
00:37:51,242 --> 00:37:52,223
AUDIENCE MEMBER 2. Cool.

786
00:37:54,744 --> 00:37:54,944
Thank you.

787
00:37:55,530 --> 00:38:02,073
So when you ship a version, I suppose any time that happens,

788
00:38:02,113 --> 00:38:04,534
you still have features, some other features still

789
00:38:04,854 --> 00:38:08,756
in progress, which you turn off with your toggles.

790
00:38:09,596 --> 00:38:13,518
Do you do anything to prevent shipping content belonging

791
00:38:13,578 --> 00:38:15,298
to those half-done features?

792
00:38:16,819 --> 00:38:20,120
So for content, if they are not referenced by the game,

793
00:38:20,561 --> 00:38:22,982
because if it's at the very early stage that is just

794
00:38:23,002 --> 00:38:23,682
being prototyped.

795
00:38:24,451 --> 00:38:25,692
They're not referenced by the games,

796
00:38:25,732 --> 00:38:26,772
therefore they're not being shipped.

797
00:38:27,393 --> 00:38:29,774
But if they start to be referenced in the game,

798
00:38:29,834 --> 00:38:30,574
we would ship them.

799
00:38:31,635 --> 00:38:32,996
So that's one of the things that we can improve.

800
00:38:33,016 --> 00:38:34,857
Because essentially, yes, we are shipping some content

801
00:38:34,877 --> 00:38:36,457
that are not being referenced by the game yet,

802
00:38:36,978 --> 00:38:37,638
or used by the game.

803
00:38:38,619 --> 00:38:42,320
So do you have some mechanism, if you turn a feature off,

804
00:38:43,341 --> 00:38:45,582
then it's no longer referenced?

805
00:38:45,662 --> 00:38:46,203
Do you detect?

806
00:38:46,263 --> 00:38:47,523
No, no, we don't have that yet, no.

807
00:38:48,064 --> 00:38:48,364
Right.

808
00:38:48,564 --> 00:38:49,824
But that's something that we can definitely do.

809
00:38:50,685 --> 00:38:50,765
OK.

810
00:38:51,385 --> 00:38:51,685
Thank you.

811
00:38:52,246 --> 00:38:52,546
You're welcome.

812
00:38:54,002 --> 00:38:54,182
Hi.

813
00:38:55,443 --> 00:38:56,703
Hello.

814
00:38:58,063 --> 00:39:00,944
How do you deal with version and content mismatches

815
00:39:01,024 --> 00:39:05,285
between client and server when you have a bunch of content

816
00:39:05,345 --> 00:39:08,166
creators and a bunch of client developers,

817
00:39:08,186 --> 00:39:10,987
a bunch of server developers all trying

818
00:39:11,007 --> 00:39:13,607
to work on their own boxes with their own features?

819
00:39:14,688 --> 00:39:17,328
Do you have a shared environment that everyone is hitting?

820
00:39:17,368 --> 00:39:19,989
Or is everyone setting up the services on their own boxes

821
00:39:20,049 --> 00:39:20,469
locally?

822
00:39:23,381 --> 00:39:26,743
So everybody work, like we don't keep multiple versions,

823
00:39:26,803 --> 00:39:29,184
because everybody work on the trunk or main,

824
00:39:29,945 --> 00:39:31,006
we just have the same version.

825
00:39:31,046 --> 00:39:33,427
So if we, let's say, change an asset format,

826
00:39:33,487 --> 00:39:35,348
everybody who update will get that version.

827
00:39:36,689 --> 00:39:37,589
Does that answer your question?

828
00:39:37,970 --> 00:39:42,592
No, like, say I'm making that change, right?

829
00:39:42,732 --> 00:39:42,973
Sure.

830
00:39:43,193 --> 00:39:47,956
And I want to manually test it,

831
00:39:47,996 --> 00:39:48,976
just like quick,

832
00:39:51,329 --> 00:39:56,972
smoke test it without having to like figure out exactly how I'm going to like automated test it.

833
00:39:58,493 --> 00:40:02,876
Is there a way I can set up the game and services end to end so I can do that?

834
00:40:03,516 --> 00:40:07,338
Yes, so we have we developed some tools that allow to improve the local workflow.

835
00:40:08,448 --> 00:40:10,308
that you can just press a button that

836
00:40:10,348 --> 00:40:12,989
compiles this client, the server, set up the services,

837
00:40:13,049 --> 00:40:13,809
and cook the assets.

838
00:40:13,829 --> 00:40:16,610
So then, yes, you can then ideally even deploy to your Xbox

839
00:40:16,650 --> 00:40:18,190
and test it on your Xbox or your PC.

840
00:40:18,210 --> 00:40:20,031
Yes, we developed a tool to allow us to do that.

841
00:40:20,611 --> 00:40:22,371
Because manually doing it was quite difficult.

842
00:40:24,232 --> 00:40:24,972
One quick question.

843
00:40:26,132 --> 00:40:30,633
How many people are currently working in this one branch

844
00:40:31,194 --> 00:40:31,614
depot?

845
00:40:31,834 --> 00:40:33,034
I think probably about 150 people.

846
00:40:33,054 --> 00:40:33,114
Wow.

847
00:40:36,720 --> 00:40:40,242
How do you deal with the problem of the build's been broken

848
00:40:40,442 --> 00:40:44,323
and now it's unlocked and everybody just dumps

849
00:40:44,403 --> 00:40:45,183
all their stuff in?

850
00:40:45,663 --> 00:40:47,884
So what we found is the longer it's locked,

851
00:40:47,904 --> 00:40:50,685
the more the chance of people dumping a lot of things.

852
00:40:50,725 --> 00:40:53,026
So that's why we try to back out the change.

853
00:40:53,046 --> 00:40:54,787
Because if somebody tried to come up with a fix,

854
00:40:54,847 --> 00:40:55,767
it would take a lot longer.

855
00:40:56,407 --> 00:40:58,488
So we try to usually deal with the build break

856
00:40:58,688 --> 00:40:59,848
within 10 minutes or so.

857
00:41:00,409 --> 00:41:01,769
So we don't keep the depot locked

858
00:41:01,829 --> 00:41:02,910
for a long period of time.

859
00:41:03,730 --> 00:41:04,150
Great, thanks.

860
00:41:04,670 --> 00:41:04,890
Thank you.

861
00:41:06,957 --> 00:41:13,079
Hey, I wonder when do make code review before integrating commit to trunk or after so yes

862
00:41:13,179 --> 00:41:19,202
It is before before we do that so we do the code review if it passes then you're allowed to check in your changes

863
00:41:19,262 --> 00:41:23,124
to your truck

864
00:41:23,284 --> 00:41:23,964
How do you deal with the

865
00:41:24,324 --> 00:41:30,667
Multiplicative like complexity of different feature toggles so say there's five features that could be on and off are you

866
00:41:31,263 --> 00:41:33,525
testing all the different configurations of those?

867
00:41:33,585 --> 00:41:36,627
Or do you just, you don't know the test pass for it until a

868
00:41:36,667 --> 00:41:38,868
month later when you do finally turn it on?

869
00:41:39,569 --> 00:41:40,309
That's a good question.

870
00:41:40,369 --> 00:41:44,872
So what we tend to do, first of all, we try to keep that

871
00:41:44,972 --> 00:41:46,453
set as small as possible.

872
00:41:47,173 --> 00:41:50,235
So if a feature is done, we try to remove the toggle so

873
00:41:50,255 --> 00:41:50,896
it's always on.

874
00:41:51,996 --> 00:41:56,399
But also we treat the whole set as one set, because it

875
00:41:56,419 --> 00:41:57,640
makes the testing a lot easier.

876
00:41:58,420 --> 00:41:59,081
So if, let's say.

877
00:42:00,130 --> 00:42:03,232
We make a bill and there's a problem with one of the features that we toggled on.

878
00:42:03,712 --> 00:42:05,213
You just switch off all of the features.

879
00:42:06,234 --> 00:42:08,535
Because otherwise testing them would be very difficult.

880
00:42:08,675 --> 00:42:10,136
The combination could be.

881
00:42:11,197 --> 00:42:13,478
I mean, the test matrix would be very complicated very soon.

882
00:42:13,538 --> 00:42:15,779
So yes, we just to again to make our lives easier.

883
00:42:15,839 --> 00:42:18,041
We just treat them as a set that we switch all of them off.

884
00:42:18,441 --> 00:42:19,842
I see. Cool. Thank you.

885
00:42:20,706 --> 00:42:22,589
I thank you for the informative talk.

886
00:42:22,749 --> 00:42:23,029
Thank you.

887
00:42:23,089 --> 00:42:25,472
I had a question on the unit testing.

888
00:42:25,512 --> 00:42:28,316
Can you elaborate further as far as,

889
00:42:29,898 --> 00:42:32,822
are your developers bringing to the table

890
00:42:33,022 --> 00:42:34,904
initially with the start of a project

891
00:42:35,265 --> 00:42:37,207
their own set of unit tests?

892
00:42:39,233 --> 00:42:43,554
Are they sharing or propagating unit tests across the team,

893
00:42:43,614 --> 00:42:47,875
especially if there's one where it's found to be a key metric

894
00:42:47,995 --> 00:42:51,856
or a key set of tasks that they're evaluating

895
00:42:51,896 --> 00:42:52,816
that could be shared?

896
00:42:53,316 --> 00:42:55,516
I guess I'm looking for more information as far

897
00:42:55,556 --> 00:42:58,857
as the continuous development improvements

898
00:42:58,937 --> 00:43:00,117
and process improvements.

899
00:43:03,198 --> 00:43:04,338
If that didn't make sense.

900
00:43:05,875 --> 00:43:07,936
I'll try to rephrase myself, I apologize.

901
00:43:07,956 --> 00:43:08,456
It's okay.

902
00:43:08,516 --> 00:43:10,357
Basically, your developers,

903
00:43:10,457 --> 00:43:12,778
especially if they're newer ones on the team,

904
00:43:13,858 --> 00:43:15,599
they're focusing on unit testing.

905
00:43:15,699 --> 00:43:19,180
Are they bringing to the table their own set of unit tests

906
00:43:19,240 --> 00:43:20,441
and can those be shared?

907
00:43:21,061 --> 00:43:22,841
Or are they developing them on the fly?

908
00:43:23,999 --> 00:43:26,320
Yes, they develop them as they work on a code, yes.

909
00:43:27,060 --> 00:43:27,520
OK.

910
00:43:28,201 --> 00:43:31,582
But as I said, we had this problem with flaky tests.

911
00:43:31,782 --> 00:43:34,123
And the main reason was because when we started,

912
00:43:34,163 --> 00:43:35,783
we didn't know how to write good tests.

913
00:43:35,823 --> 00:43:38,244
So a lot of these unit tests that we wrote were flaky.

914
00:43:39,225 --> 00:43:41,605
But people learned from that and improved.

915
00:43:41,685 --> 00:43:43,446
Therefore, the tests that they added later on

916
00:43:43,486 --> 00:43:44,666
were much more deterministic.

917
00:43:44,947 --> 00:43:46,007
OK, thank you.

918
00:43:46,387 --> 00:43:48,068
You're welcome.

919
00:43:48,088 --> 00:43:49,228
Hi, good talk.

920
00:43:49,988 --> 00:43:50,829
Because you have 150 developers on head,

921
00:43:54,114 --> 00:43:57,415
When you're refactoring for technical debt, a ubiquitous

922
00:43:57,535 --> 00:43:59,597
feature that's ubiquitous across the code base, touching

923
00:43:59,637 --> 00:44:03,099
lots of files, interacting with lots of other systems,

924
00:44:03,859 --> 00:44:08,181
did you run into any issues or have any tips on dealing with

925
00:44:08,522 --> 00:44:11,443
changes that need to be made to reduce technical debt that

926
00:44:11,483 --> 00:44:14,385
actually affect a lot of developers because it affects

927
00:44:14,425 --> 00:44:15,185
a lot of systems?

928
00:44:17,067 --> 00:44:19,931
Yeah, so that was one of the problems we had as well.

929
00:44:19,951 --> 00:44:22,955
Fortunately, not many people had to do that,

930
00:44:23,155 --> 00:44:25,438
so the number of people had to deal with this was small.

931
00:44:27,020 --> 00:44:29,804
The trick was, again, using feature toggles.

932
00:44:30,225 --> 00:44:32,328
As opposed to, let's say, editing.

933
00:44:33,682 --> 00:44:36,884
tens or hundreds of files and submit them together,

934
00:44:37,364 --> 00:44:39,926
how they can ideally try to use feature toggles

935
00:44:39,966 --> 00:44:41,067
to hide some of their stuff.

936
00:44:41,087 --> 00:44:43,728
So they don't suddenly have to commit all of them together.

937
00:44:43,748 --> 00:44:45,309
It goes back to what I was saying about

938
00:44:45,930 --> 00:44:47,871
breaking down the work into smaller increments

939
00:44:48,471 --> 00:44:51,253
so they can make a few changes, submit that,

940
00:44:51,293 --> 00:44:53,014
then make another change, submit that,

941
00:44:53,134 --> 00:44:54,875
and touch a smaller number of files

942
00:44:54,915 --> 00:44:55,996
as opposed to going quite big.

943
00:44:56,016 --> 00:44:57,277
But sometimes you can't avoid that.

944
00:44:57,917 --> 00:44:59,778
Sometimes you have to do that, and it's very painful,

945
00:44:59,818 --> 00:45:02,620
but we try to minimize that as much as possible.

946
00:45:03,781 --> 00:45:05,703
Well, sorry, I don't have any specific kind of hint,

947
00:45:05,763 --> 00:45:09,065
other than try to minimize that as much as you can.

948
00:45:09,386 --> 00:45:11,868
Thank you.

949
00:45:12,008 --> 00:45:12,268
Hello?

950
00:45:12,749 --> 00:45:12,949
Hi.

951
00:45:13,509 --> 00:45:17,553
Where does Data Worker fit into all that?

952
00:45:17,953 --> 00:45:18,153
Sorry?

953
00:45:18,233 --> 00:45:19,754
Like, how do you manage your data?

954
00:45:20,015 --> 00:45:22,277
Because this is very code-oriented.

955
00:45:22,377 --> 00:45:23,137
Yes, sorry.

956
00:45:23,157 --> 00:45:25,279
So that's in the same trunk in main.

957
00:45:25,459 --> 00:45:27,361
So all our data, everything is there as well.

958
00:45:27,659 --> 00:45:32,782
But your, for example, your, uh, I don't know, your audio designer, uh, they can't really

959
00:45:32,842 --> 00:45:37,145
code themselves automatic testing. So who does it for them?

960
00:45:37,433 --> 00:45:38,353
No, they write some tests.

961
00:45:38,593 --> 00:45:38,814
Really?

962
00:45:39,074 --> 00:45:39,254
Yes.

963
00:45:40,054 --> 00:45:42,455
Our Sun Sound guys, they write some tests as well.

964
00:45:43,036 --> 00:45:44,316
But there's a difference, because you

965
00:45:44,336 --> 00:45:46,397
have the source sound and then this being converted

966
00:45:46,417 --> 00:45:47,338
that we use in the game.

967
00:45:47,758 --> 00:45:49,439
They don't need to write tests for the source sounds.

968
00:45:49,739 --> 00:45:52,060
It's only for the when it, they can easily

969
00:45:52,100 --> 00:45:54,181
work on the source file as much as they like

970
00:45:54,221 --> 00:45:55,421
without having to add any tests.

971
00:45:55,842 --> 00:45:57,322
But when they try to hook it into the game,

972
00:45:57,943 --> 00:45:59,503
that's when they need to put some tests to it.

973
00:46:00,079 --> 00:46:03,381
OK, so for example, for your level design and your,

974
00:46:03,661 --> 00:46:07,423
I don't know, VFX, your customization.

975
00:46:07,944 --> 00:46:10,085
So they all write their own tests to make sure

976
00:46:10,105 --> 00:46:10,925
that nothing's broken?

977
00:46:11,005 --> 00:46:11,166
Yeah.

978
00:46:11,406 --> 00:46:12,726
But obviously, the tests that they write

979
00:46:13,427 --> 00:46:15,268
is at a different level to what programmers write.

980
00:46:15,308 --> 00:46:16,349
And sometimes the programmers have

981
00:46:16,369 --> 00:46:17,949
to go and help these guys to write tests,

982
00:46:18,110 --> 00:46:21,031
or ask programmers to write a test for them.

983
00:46:21,151 --> 00:46:25,154
But we encourage our artists to write some tests if they can.

984
00:46:25,234 --> 00:46:27,075
And also, they try to do code reviews as well.

985
00:46:27,715 --> 00:46:28,736
It's quite fun for artists.

986
00:46:29,817 --> 00:46:30,137
Thank you.

987
00:46:30,157 --> 00:46:31,378
You're welcome.

988
00:46:32,578 --> 00:46:32,858
Hi.

989
00:46:33,218 --> 00:46:35,399
When you said that you were toggling these switches

990
00:46:35,739 --> 00:46:37,560
on and off to enable code, did you

991
00:46:37,600 --> 00:46:40,541
mention if that is its own, like you have a pull request

992
00:46:40,581 --> 00:46:42,221
and a code review on that change?

993
00:46:42,301 --> 00:46:44,322
Or is there like an out-of-band way

994
00:46:44,362 --> 00:46:45,582
that you update those switches?

995
00:46:46,540 --> 00:46:48,341
No, it's part of the same change.

996
00:46:48,361 --> 00:46:51,144
Let's say you want to toggle a feature on,

997
00:46:51,284 --> 00:46:54,546
but it needs some small pieces left.

998
00:46:54,926 --> 00:46:56,228
You complete it, and then it allows

999
00:46:56,248 --> 00:46:57,328
you to toggle the feature on.

1000
00:46:57,428 --> 00:47:00,651
So you include that change along with the toggle

1001
00:47:01,091 --> 00:47:02,713
along with your change, your last change.

1002
00:47:02,773 --> 00:47:04,694
And you submit both of them together and it gets reviewed.

1003
00:47:04,714 --> 00:47:08,637
Because sometimes these toggles, when you want to turn them on,

1004
00:47:08,677 --> 00:47:10,779
you usually have to check with other people

1005
00:47:10,819 --> 00:47:13,441
from other disciplines as well and make sure they sign off.

1006
00:47:15,598 --> 00:47:20,260
Because like potentially you releasing this feature now to your players. So you want to make sure that

1007
00:47:20,280 --> 00:47:40,930
this a production signed off on that as well. But usually be encouraged to like the last change that enables us now releases toggle feature to a players to 10 to talk along along with that change together to make that change atomic awesome. If anything goes wrong, then we can back out and the talk all this office. Oh yeah, great thanks.

1008
00:47:44,951 --> 00:47:47,572
hey, for your targeted testing, so you said you had 40,000

1009
00:47:47,753 --> 00:47:51,395
tests, but you don't run the entire test suite, when you're

1010
00:47:51,455 --> 00:47:54,456
doing your targeted testing, was that based on code coverage

1011
00:47:54,816 --> 00:47:58,438
and was that a hand curated map or was that, you used a code

1012
00:47:58,458 --> 00:48:00,279
coverage tool to then map that in?

1013
00:48:00,987 --> 00:48:04,149
So we used to use a code coverage tool.

1014
00:48:04,249 --> 00:48:06,770
And when we stopped using that, so we came up, we wrote

1015
00:48:06,810 --> 00:48:09,291
our own tool, which, as I said, it runs each test.

1016
00:48:11,092 --> 00:48:13,934
Basically, once a day, it runs all the tests, each test, and

1017
00:48:13,974 --> 00:48:16,235
then tracks which code files it touches.

1018
00:48:17,275 --> 00:48:18,176
So it's all automated.

1019
00:48:18,216 --> 00:48:20,257
We don't do that manually, because it's going to take a

1020
00:48:20,297 --> 00:48:22,438
long time to create that map and maintain that.

1021
00:48:22,998 --> 00:48:25,099
And that was all internally developed by you guys?

1022
00:48:25,119 --> 00:48:25,519
Yes, that's right.

1023
00:48:25,799 --> 00:48:27,140
You guys are way too fun.

1024
00:48:27,660 --> 00:48:27,920
Thank you.

1025
00:48:30,084 --> 00:48:32,886
So what if you wanted to upgrade the Unreal Engine?

1026
00:48:33,186 --> 00:48:33,866
Could you do that?

1027
00:48:34,426 --> 00:48:35,287
Did you already do that?

1028
00:48:35,607 --> 00:48:36,808
Yes, we did a couple of times.

1029
00:48:37,428 --> 00:48:40,430
But then at some point we stopped because it was taking

1030
00:48:40,450 --> 00:48:42,571
far too long to integrate a new version of Engine.

1031
00:48:42,971 --> 00:48:44,612
But because we had these tests, again, they were

1032
00:48:44,632 --> 00:48:46,213
helping us, because otherwise it would have been very

1033
00:48:46,253 --> 00:48:49,295
difficult to integrate a new version and try to release.

1034
00:48:50,435 --> 00:48:52,717
We got to a point where in the same week that we integrated

1035
00:48:52,757 --> 00:48:55,218
a new version of Engine, we also released the game a

1036
00:48:55,278 --> 00:48:57,959
couple of days later to our internal audience.

1037
00:48:58,782 --> 00:48:59,883
But it was thanks to these tests.

1038
00:49:00,083 --> 00:49:01,764
Otherwise, it would have been very difficult to test them.

1039
00:49:02,204 --> 00:49:02,404
Right.

1040
00:49:02,424 --> 00:49:04,445
So your test kind of covered most of that?

1041
00:49:06,146 --> 00:49:10,308
It covered the area that we were modifying and we were

1042
00:49:10,328 --> 00:49:10,848
changing.

1043
00:49:11,108 --> 00:49:14,470
I mean, it was quite common that we take a new version and

1044
00:49:14,510 --> 00:49:15,591
then something would be broken.

1045
00:49:15,631 --> 00:49:17,812
But again, we were trying to detect them as early as

1046
00:49:17,872 --> 00:49:19,633
possible and trying to respond to those issues.

1047
00:49:20,413 --> 00:49:20,593
All right.

1048
00:49:20,613 --> 00:49:23,375
So you feel it's possible to do that, that's doable?

1049
00:49:23,675 --> 00:49:23,855
Yes.

1050
00:49:24,275 --> 00:49:24,695
OK, cool.

1051
00:49:26,339 --> 00:49:33,523
Hey, great talk. Two questions. Firstly, does this involve both the client and the whole

1052
00:49:33,543 --> 00:49:41,366
back end part of the game? Okay, cool. And secondly, do the same teams, is there one team

1053
00:49:41,386 --> 00:49:47,269
that implements on both the client and the back end? So they write tests for everything and

1054
00:49:47,349 --> 00:49:53,432
integrate? Cool, thanks. Hi, when a test gets broken, who fixes it? I'm not sure. I'm not

1055
00:49:55,803 --> 00:49:58,665
the tests that are broken, the person who caused the break.

1056
00:49:58,765 --> 00:50:01,988
So as I said, we try to keep the number of changes in a

1057
00:50:02,028 --> 00:50:03,049
build as small as possible.

1058
00:50:03,089 --> 00:50:05,451
So it should be really easy to identify if you look at a

1059
00:50:05,491 --> 00:50:06,491
couple of changes in there.

1060
00:50:07,250 --> 00:50:09,071
you should be able to easily identify who broke it

1061
00:50:09,131 --> 00:50:10,032
and then you ask the person.

1062
00:50:10,052 --> 00:50:12,593
Okay, and do you have any dedicated people

1063
00:50:12,693 --> 00:50:16,795
to basically take care of the automated tests,

1064
00:50:16,855 --> 00:50:18,776
the framework, is there a dedicated team for that

1065
00:50:18,856 --> 00:50:19,916
or is it the responsibility?

1066
00:50:19,936 --> 00:50:20,877
For the test framework.

1067
00:50:21,737 --> 00:50:23,598
Well, the framework and the tests themselves,

1068
00:50:23,798 --> 00:50:24,998
do you have any dedicated?

1069
00:50:25,359 --> 00:50:27,620
So tests, the test framework, tools and everything,

1070
00:50:27,640 --> 00:50:30,881
they are in the same depot, in the same main branch.

1071
00:50:31,621 --> 00:50:33,922
And the deployment pipeline team are responsible

1072
00:50:33,983 --> 00:50:35,443
for writing the test framework.

1073
00:50:36,185 --> 00:50:37,805
But at the same time, we don't write the tests.

1074
00:50:38,165 --> 00:50:40,026
Our developers write the tests because they want to prove

1075
00:50:40,046 --> 00:50:40,786
that their feature works.

1076
00:50:40,846 --> 00:50:42,506
Otherwise, I could do it manually, and they don't want

1077
00:50:42,526 --> 00:50:43,266
to do that manually.

1078
00:50:43,626 --> 00:50:43,806
OK.

1079
00:50:44,026 --> 00:50:46,167
So there's no one that's actually dedicated to working

1080
00:50:46,287 --> 00:50:48,207
exclusively only on writing tests?

1081
00:50:48,367 --> 00:50:49,248
On fixing tests, no.

1082
00:50:49,448 --> 00:50:50,508
Or writing tests, no.

1083
00:50:50,548 --> 00:50:51,008
OK, thanks.

1084
00:50:51,048 --> 00:50:52,368
You're welcome.

1085
00:50:54,709 --> 00:50:58,670
Hey, at one point you had said that prototyping is critical

1086
00:50:58,850 --> 00:51:02,450
to effective testing.

1087
00:51:02,730 --> 00:51:04,651
Could you elaborate a little bit more on what you mean by

1088
00:51:04,711 --> 00:51:05,211
prototyping?

1089
00:51:06,178 --> 00:51:07,478
I'm not sure you recall what I mean.

1090
00:51:10,619 --> 00:51:19,402
So I don't recall the specific instance, but there is something that came that came up where you said there was prototyping was important. Might have been when you were bringing team members on.

1091
00:51:19,422 --> 00:51:23,663
Let me see, I think you probably.

1092
00:51:26,524 --> 00:51:27,224
Let me see is it.

1093
00:51:31,102 --> 00:51:36,329
You mean the third point there, which having a separate prototype. Yeah, yeah, right there so.

1094
00:51:36,349 --> 00:51:45,981
So what as I mentioned so the what we found in the past was when we are working on prototype the quality level is quite different for production.

1095
00:51:46,822 --> 00:51:47,042
Code.

1096
00:51:47,910 --> 00:52:02,778
But you don't have a right test if you put a lot of things because you want to quickly test stuff and I see if that feels right and that kind of stuff so we didn't want them to kind of put that level of quality for prototype so having separate code base and using even different game engine.

1097
00:52:03,599 --> 00:52:04,339
It allowed them to.

1098
00:52:05,153 --> 00:52:06,993
work on that and kind of be isolated.

1099
00:52:07,014 --> 00:52:09,014
But at the same time, what we found in the past

1100
00:52:09,054 --> 00:52:12,916
was that could easily end up being the version we use in production.

1101
00:52:13,476 --> 00:52:15,497
Because it might be difficult to justify,

1102
00:52:15,817 --> 00:52:17,297
because somebody might say,

1103
00:52:17,357 --> 00:52:19,218
oh, but this works, kind of works,

1104
00:52:19,358 --> 00:52:20,078
why don't we use that?

1105
00:52:20,538 --> 00:52:22,799
So having this separation, they had no choice.

1106
00:52:22,819 --> 00:52:25,380
They had to go and re-implement that feature

1107
00:52:25,420 --> 00:52:26,280
that they just prototyped

1108
00:52:26,881 --> 00:52:29,121
in the production code with tests and everything.

1109
00:52:29,341 --> 00:52:30,142
Great, that makes sense. Thanks.

1110
00:52:30,182 --> 00:52:31,462
Does that answer your question? Yeah. Cool.

1111
00:52:32,523 --> 00:52:33,783
That was a great talk. Thank you.

1112
00:52:35,595 --> 00:52:39,678
I was thinking in terms of the commits themselves, presumably each commit is from a single developer?

1113
00:52:39,698 --> 00:52:40,419
That's right.

1114
00:52:40,999 --> 00:52:44,382
So how much, how weighty is each commit?

1115
00:52:45,262 --> 00:52:50,826
Because frequently you'd use feature branches for working on something for maybe a couple

1116
00:52:50,846 --> 00:52:51,306
of days.

1117
00:52:51,807 --> 00:52:54,849
Do you see individual commits having that much work in or are they smaller?

1118
00:52:55,120 --> 00:52:56,761
No, they are quite small, because we

1119
00:52:56,801 --> 00:52:59,422
encourage our developers to do check-ins every day.

1120
00:52:59,442 --> 00:53:00,983
Not everybody does it.

1121
00:53:01,003 --> 00:53:02,824
Some people do, but some people don't.

1122
00:53:02,944 --> 00:53:05,546
On average, I think we do about three to four check-ins each.

1123
00:53:05,746 --> 00:53:07,787
Like our developers do three to four check-ins a week,

1124
00:53:08,888 --> 00:53:10,389
which means if they're not doing it every day,

1125
00:53:10,429 --> 00:53:11,270
they do it every other day.

1126
00:53:11,290 --> 00:53:14,531
And therefore, then the number of changes, like files

1127
00:53:14,551 --> 00:53:16,513
they have, is relatively small.

1128
00:53:17,493 --> 00:53:19,635
And they don't use another feature branch or anything.

1129
00:53:19,655 --> 00:53:20,715
Everybody work on trunk.

1130
00:53:21,178 --> 00:53:23,759
Right, and when you code review on one of those commits,

1131
00:53:24,120 --> 00:53:26,481
presumably that's obviously in line with development.

1132
00:53:26,581 --> 00:53:29,663
So I would do a commit, someone is there ready to review it

1133
00:53:29,683 --> 00:53:30,664
pretty much straight away.

1134
00:53:31,084 --> 00:53:32,805
So they do the review before they commit.

1135
00:53:33,626 --> 00:53:37,168
And again, one thing we found is the smaller the change,

1136
00:53:37,668 --> 00:53:38,969
easier for people to review.

1137
00:53:38,989 --> 00:53:40,830
Because if you try to review and it's small,

1138
00:53:40,910 --> 00:53:43,372
it's a lot easier for people to reason about and review that.

1139
00:53:43,392 --> 00:53:46,033
Because we had often, sometimes we had this problem where

1140
00:53:47,014 --> 00:53:49,036
If the change was too big, the person reviewing it

1141
00:53:49,056 --> 00:53:50,637
will send it back and ask the person

1142
00:53:50,677 --> 00:53:52,459
to break it into smaller chunks.

1143
00:53:52,779 --> 00:53:54,961
So they review different pieces, as opposed

1144
00:53:54,981 --> 00:53:56,922
to having this one big change that they want to review.

1145
00:53:57,223 --> 00:53:57,503
Right.

1146
00:53:57,783 --> 00:54:00,786
So does the review process have much latency

1147
00:54:01,266 --> 00:54:02,287
to that commit process?

1148
00:54:02,467 --> 00:54:02,607
Yeah.

1149
00:54:03,047 --> 00:54:03,268
Right.

1150
00:54:03,308 --> 00:54:04,589
So that's one problem we had.

1151
00:54:04,889 --> 00:54:08,032
And one way to tackle that was to encourage developers

1152
00:54:08,052 --> 00:54:09,753
to have smaller changes.

1153
00:54:10,213 --> 00:54:12,854
Because more people are willing to review smaller changes

1154
00:54:12,894 --> 00:54:14,134
than bigger changes.

1155
00:54:14,434 --> 00:54:15,495
So it helped, definitely helped.

1156
00:54:15,695 --> 00:54:16,355
Great, thank you.

1157
00:54:16,755 --> 00:54:18,635
You're welcome.

1158
00:54:19,016 --> 00:54:21,056
First, thanks for the talk.

1159
00:54:21,096 --> 00:54:23,597
Great talk and excellent discussion from the group here.

1160
00:54:24,297 --> 00:54:25,717
I'm going to be selfish.

1161
00:54:25,757 --> 00:54:26,557
I have two questions.

1162
00:54:26,757 --> 00:54:28,978
Sure, we have four or five minutes.

1163
00:54:29,218 --> 00:54:29,338
OK.

1164
00:54:29,398 --> 00:54:32,119
First, for the delivery pipeline team,

1165
00:54:33,831 --> 00:54:37,753
Is it a single team supporting all your programs and your entire studio?

1166
00:54:37,813 --> 00:54:38,393
Yes, that's right.

1167
00:54:38,553 --> 00:54:39,254
Okay, excellent.

1168
00:54:39,954 --> 00:54:41,215
And then, second question.

1169
00:54:42,415 --> 00:54:49,258
When you and the team at Rare first decided to stand up this team and kind of restructure

1170
00:54:49,839 --> 00:54:55,942
your approach to development, how did you, the engineering team and leadership,

1171
00:54:57,362 --> 00:55:01,610
kind of build a business case to get buy-in from the entire studio.

1172
00:55:01,851 --> 00:55:07,321
So our software director also was quite supportive in this, and the leadership team.

1173
00:55:08,994 --> 00:55:11,996
But at the same time, because we were changing the business model,

1174
00:55:12,576 --> 00:55:16,258
and we knew that we have to sustainably deliver new features

1175
00:55:16,318 --> 00:55:20,080
for a long period of time, we couldn't really rely on manual testing.

1176
00:55:20,460 --> 00:55:23,922
The type of game that we have, we can't really manually test everything.

1177
00:55:24,362 --> 00:55:28,084
So, these were the main reasons that we had for

1178
00:55:28,444 --> 00:55:32,246
adopting testing specifically, because we couldn't really rely, otherwise we had to

1179
00:55:32,827 --> 00:55:35,948
I don't know hire how many testers for 4 years,

1180
00:55:36,128 --> 00:55:37,309
which we didn't want to do.

1181
00:55:38,493 --> 00:55:39,113
Excellent, thank you.

1182
00:55:39,233 --> 00:55:39,593
You're welcome.

1183
00:55:40,274 --> 00:55:40,514
Hello?

1184
00:55:41,314 --> 00:55:42,154
Hi, great talk.

1185
00:55:42,234 --> 00:55:42,634
Thank you.

1186
00:55:42,834 --> 00:55:44,635
I have a quick question that's sort of tangential to the talk

1187
00:55:44,655 --> 00:55:44,795
here.

1188
00:55:44,815 --> 00:55:48,537
You mentioned briefly that you would release toggles

1189
00:55:48,577 --> 00:55:51,478
to the world with a small set of players having them turned on.

1190
00:55:51,678 --> 00:55:51,798
Yes.

1191
00:55:51,978 --> 00:55:53,258
Can you discuss a little bit of detail

1192
00:55:53,298 --> 00:55:55,079
about how friends playing together

1193
00:55:55,139 --> 00:55:56,220
deal with these different toggles?

1194
00:55:57,160 --> 00:56:00,521
So people with different toggles,

1195
00:56:00,621 --> 00:56:01,822
we don't let them to play together,

1196
00:56:02,882 --> 00:56:04,943
because the server will reject the clients that

1197
00:56:04,983 --> 00:56:05,823
have different versions.

1198
00:56:06,970 --> 00:56:11,752
And the way we implemented it is we actually used this

1199
00:56:11,932 --> 00:56:14,072
concept of title IDs for Xbox games.

1200
00:56:14,232 --> 00:56:15,873
And actually, we had two title IDs.

1201
00:56:15,953 --> 00:56:18,974
One title ID for these features that we wanted to

1202
00:56:18,994 --> 00:56:20,234
give to a small number of players.

1203
00:56:20,994 --> 00:56:23,415
And then we used the other title ID that goes to a wider

1204
00:56:23,455 --> 00:56:25,596
audience, which meant that actually they couldn't play

1205
00:56:25,616 --> 00:56:26,396
with each other as well.

1206
00:56:27,332 --> 00:56:29,333
So in that case, end users know already

1207
00:56:29,353 --> 00:56:31,093
that they're playing two different versions of the game.

1208
00:56:31,353 --> 00:56:34,174
It's not actually like an A-B test to evaluate necessarily.

1209
00:56:34,194 --> 00:56:36,414
So it's not like kind of transparent or anything like

1210
00:56:36,434 --> 00:56:36,774
that.

1211
00:56:36,894 --> 00:56:38,255
It is actually, you need to know that you

1212
00:56:38,295 --> 00:56:41,476
are playing this kind of almost bleeding age version

1213
00:56:41,636 --> 00:56:43,456
or this kind of more stable version.

1214
00:56:43,556 --> 00:56:46,577
But again, I mentioned there are room to improvement.

1215
00:56:46,717 --> 00:56:47,997
That's one of the things we try to do,

1216
00:56:48,617 --> 00:56:49,938
how we can avoid that so we don't

1217
00:56:49,958 --> 00:56:51,258
need to keep two title IDs.

1218
00:56:51,278 --> 00:56:54,359
How we can do the same thing with just using one title ID.

1219
00:56:54,379 --> 00:56:55,899
So these are the things that we are going to work on.

1220
00:56:56,537 --> 00:56:59,142
So in that sense, it's a relatively limited test realm

1221
00:56:59,182 --> 00:57:00,344
in that sort of situation?

1222
00:57:00,424 --> 00:57:01,005
OK, cool.

1223
00:57:01,166 --> 00:57:01,466
Thank you.

1224
00:57:01,987 --> 00:57:02,368
You're welcome.

1225
00:57:05,574 --> 00:57:06,216
Thank you for your time.

