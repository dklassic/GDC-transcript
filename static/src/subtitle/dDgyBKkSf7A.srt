1
00:00:05,921 --> 00:00:08,062
All right, everyone. Welcome to my talk.

2
00:00:08,062 --> 00:00:10,924
My name is Rupert Renard. I'm an Australian game developer.

3
00:00:10,924 --> 00:00:13,085
I'll be talking about the wind simulation of God of War today.

4
00:00:13,085 --> 00:00:15,807
I've been programming games for around 12 years now.

5
00:00:15,807 --> 00:00:19,889
I've worked on 12 ship titles and half a dozen canceled titles.

6
00:00:19,889 --> 00:00:22,131
Some of the games I've worked on you may have heard about,

7
00:00:22,131 --> 00:00:24,012
such as God of War, The Legend of Zelda,

8
00:00:24,012 --> 00:00:26,813
Deus Ex, Mass Effect 3, Develop 2, and Scooby-Doo.

9
00:00:26,813 --> 00:00:30,576
I've worked in a variety of programming positions.

10
00:00:30,576 --> 00:00:31,896
I'm currently at Sony Santa Monica.

11
00:00:32,587 --> 00:00:33,887
as a graphics and engine programmer,

12
00:00:33,887 --> 00:00:35,328
where we shipped God of War in April 2018,

13
00:00:35,328 --> 00:00:36,729
and it did pretty well.

14
00:00:36,729 --> 00:00:42,432
Wind is starting to become a standard feature

15
00:00:42,432 --> 00:00:44,133
in games these days.

16
00:00:44,133 --> 00:00:46,255
Most times the wind is just a generic sine wave,

17
00:00:46,255 --> 00:00:48,116
animating some bushes back and forth,

18
00:00:48,116 --> 00:00:50,637
and we decided to go a little deeper.

19
00:00:50,637 --> 00:00:51,938
By building our wind system, over time,

20
00:00:51,938 --> 00:00:55,160
we started to have a reasonable, decent amount of customers

21
00:00:55,160 --> 00:00:57,121
wanting to dynamically change their state

22
00:00:57,121 --> 00:00:58,822
based on the winds around their location.

23
00:00:59,657 --> 00:01:02,799
Our particle system was one of the early adopters.

24
00:01:02,799 --> 00:01:05,220
Particles getting pushed around the world.

25
00:01:05,220 --> 00:01:07,901
Hair, leaves, and fur were grouped together

26
00:01:07,901 --> 00:01:10,302
in another system, able to bend and sway

27
00:01:10,302 --> 00:01:11,282
in localized clusters.

28
00:01:11,282 --> 00:01:15,084
Audio emitters changed the way they behaved

29
00:01:15,084 --> 00:01:18,585
based on the intensity of the wind.

30
00:01:18,585 --> 00:01:20,346
And our cloth system also experimented

31
00:01:20,346 --> 00:01:21,847
with being affected by the wind.

32
00:01:21,847 --> 00:01:24,268
The goal was to have a dynamic living world

33
00:01:24,268 --> 00:01:26,269
where nothing less than hard stone

34
00:01:26,269 --> 00:01:28,590
was susceptible from being affected by wind.

35
00:01:31,117 --> 00:01:34,498
I've recorded some footage from the final game to demonstrate some of the wind effects

36
00:01:34,498 --> 00:01:38,641
we have, as well as to demonstrate that the game can get pretty windy at times, and it's

37
00:01:38,641 --> 00:01:41,803
a useful effect to have in order to help set up mood.

38
00:01:41,803 --> 00:01:45,284
Basically, it looks like if it's moving in the world, then there's a really good chance

39
00:01:45,284 --> 00:01:49,567
it's being animated dynamically based on the wind simulation, otherwise it might be a baked

40
00:01:49,567 --> 00:01:50,708
animation.

41
00:01:50,708 --> 00:01:54,550
We wanted the wind to be subtle for most cases, and be obvious in others.

42
00:02:13,976 --> 00:02:15,038
and

43
00:02:15,038 --> 00:02:15,678
and

44
00:02:15,678 --> 00:02:27,052
and

45
00:02:27,052 --> 00:02:28,494
and

46
00:02:28,494 --> 00:02:28,875
and

47
00:02:28,875 --> 00:02:29,435
and

48
00:02:29,435 --> 00:02:29,656
and

49
00:03:12,198 --> 00:03:14,659
We prototyped the fluid simulation on the CPU.

50
00:03:14,659 --> 00:03:17,301
We're based off an old tech paper from GDC 2003

51
00:03:17,301 --> 00:03:22,223
called Real-Time Fluid Dynamics for Games by Josh Stahm.

52
00:03:22,223 --> 00:03:23,824
The tech paper, however, took a few shortcuts.

53
00:03:23,824 --> 00:03:26,426
These shortcuts were beneficial

54
00:03:26,426 --> 00:03:28,107
at the time the paper was written,

55
00:03:28,107 --> 00:03:30,248
but created some very obvious quality issues.

56
00:03:30,248 --> 00:03:33,109
We felt like these quality issues weren't acceptable anymore

57
00:03:33,109 --> 00:03:34,550
especially since we have the performance

58
00:03:34,550 --> 00:03:36,391
available to avoid it.

59
00:03:36,391 --> 00:03:39,353
So now we have the ability to do a proper fluid simulation

60
00:03:39,353 --> 00:03:41,374
without these shortcuts and achieve high quality.

61
00:03:42,430 --> 00:03:45,173
But the paper itself was an amazing source of information

62
00:03:45,173 --> 00:03:48,056
as a starting point, and it still is today.

63
00:03:48,056 --> 00:03:50,598
We have a three-tiered system for most of our wind sampling

64
00:03:50,598 --> 00:03:50,939
systems.

65
00:03:50,939 --> 00:03:54,122
Static wind is a global vector applied uniformly

66
00:03:54,122 --> 00:03:56,764
to everything in the scene.

67
00:03:56,764 --> 00:03:58,206
It's capable of changing over time

68
00:03:58,206 --> 00:04:00,087
and also as the player moves around the world.

69
00:04:00,087 --> 00:04:03,571
We feed static wind sometimes with a scrolling noise texture.

70
00:04:04,868 --> 00:04:07,830
Dynamic wind is the focus of this talk.

71
00:04:07,830 --> 00:04:10,792
It's a 3D volume that contains detailed fluid simulation

72
00:04:10,792 --> 00:04:11,652
that surrounds the player.

73
00:04:11,652 --> 00:04:14,254
It's always aligned to world coordinates

74
00:04:14,254 --> 00:04:15,435
and shifts as the player moves.

75
00:04:15,435 --> 00:04:18,717
Counter wind is a simple mechanism

76
00:04:18,717 --> 00:04:21,839
used to fake wind application on things that are moving.

77
00:04:21,839 --> 00:04:23,660
It's simply the negative velocity vector

78
00:04:23,660 --> 00:04:24,821
of the object that is moving.

79
00:04:25,503 --> 00:04:29,465
If an object is moving roughly at the same speed and direction as the static or dynamic

80
00:04:29,465 --> 00:04:34,367
wind, this will counteract the wind, hence the name, and give the appearance that the

81
00:04:34,367 --> 00:04:36,228
object isn't being affected by wind.

82
00:04:36,228 --> 00:04:43,851
This is ideal, since the object is roughly in sync with the static or dynamic wind itself.

83
00:04:43,851 --> 00:04:47,232
So we combine these three tiers like so for an object that is sampling.

84
00:04:47,232 --> 00:04:51,874
The static wind vector is added, the dynamic wind volume is sampled with the object's position,

85
00:04:51,874 --> 00:04:53,995
and the object's velocity is subtracted.

86
00:04:57,015 --> 00:04:58,796
Our 3D volume is a 32 by 16 by 32 texels,

87
00:04:58,796 --> 00:05:02,118
which covers around one meter cubed per texel.

88
00:05:02,118 --> 00:05:04,919
We had a very, very strict time budget for simulation

89
00:05:04,919 --> 00:05:07,581
and other wind processing on the GPU,

90
00:05:07,581 --> 00:05:09,882
so our resolution is mostly tailored to fit this budget.

91
00:05:09,882 --> 00:05:14,485
We opted for a uniform 3D volume out of simplicity

92
00:05:14,485 --> 00:05:17,547
instead of a complicated hierarchical volume.

93
00:05:17,547 --> 00:05:22,009
Our volume also needed to be large enough in world space

94
00:05:22,009 --> 00:05:24,551
to contain the player interactions,

95
00:05:24,551 --> 00:05:25,771
such as throwing the axe.

96
00:05:26,667 --> 00:05:32,150
Since our game takes place mostly on a horizontal game plane, we opted for more resolution horizontally

97
00:05:32,150 --> 00:05:37,093
than vertically, but we still wanted enough vertical resolution to encompass trees that

98
00:05:37,093 --> 00:05:42,416
the player can walk past or interact with via throwing the axe.

99
00:05:42,416 --> 00:05:46,238
Try throwing the axe directly up, the leaves will be affected by it.

100
00:05:46,238 --> 00:05:49,620
We have 5 iterations of diffusion, each frame.

101
00:05:50,447 --> 00:05:52,988
Diffusion can be tightly packed and highly performant,

102
00:05:52,988 --> 00:05:54,249
so we went with five iterations.

103
00:05:54,249 --> 00:05:57,250
There's no real reason why we picked five specifically,

104
00:05:57,250 --> 00:05:59,430
we just felt like we got a good quality performance

105
00:05:59,430 --> 00:06:02,731
ratio with it.

106
00:06:02,731 --> 00:06:04,192
We have several types of motors,

107
00:06:04,192 --> 00:06:07,213
which are used to inject velocity into the volume.

108
00:06:07,213 --> 00:06:09,094
Some motor types were specifically crafted

109
00:06:09,094 --> 00:06:10,554
for certain scenarios in the game.

110
00:06:12,142 --> 00:06:13,783
We have full forward and reverse advection.

111
00:06:13,783 --> 00:06:16,005
These really do complement each other well

112
00:06:16,005 --> 00:06:18,367
and I highly recommend taking the time to have both

113
00:06:18,367 --> 00:06:20,008
and avoid preferring one over the other.

114
00:06:20,008 --> 00:06:24,271
This is one of the shortcuts I mentioned earlier.

115
00:06:24,271 --> 00:06:26,112
We also used to simulate pressure,

116
00:06:26,112 --> 00:06:27,813
which was eventually scrapped.

117
00:06:27,813 --> 00:06:29,174
Some of the effects artists

118
00:06:29,174 --> 00:06:31,075
didn't like the way particles were moving.

119
00:06:31,075 --> 00:06:32,957
We deduced it to pressure.

120
00:06:32,957 --> 00:06:34,678
We turned pressure off for the whole studio

121
00:06:34,678 --> 00:06:35,478
and nobody complained.

122
00:06:37,222 --> 00:06:40,242
Simulating pressure is actually one of the more difficult simulations to implement,

123
00:06:40,242 --> 00:06:45,123
since it's a finite quantity and cannot go negative. I was more than happy to remove it.

124
00:06:45,123 --> 00:06:48,724
But for the sake of this presentation, I will include pressure as a demonstration

125
00:06:48,724 --> 00:06:50,785
that you can add extra attributes fairly easily.

126
00:06:50,785 --> 00:06:58,927
We have separate 3D volume textures for each attribute. I might just point out velocity

127
00:06:58,927 --> 00:07:03,348
is considered a three-dimensional attribute, so we have separate textures for each axis.

128
00:07:04,266 --> 00:07:08,029
This actually proved to be incredibly beneficial for performance.

129
00:07:08,029 --> 00:07:10,831
You can see we have a very slim number of attributes.

130
00:07:10,831 --> 00:07:13,834
This was mostly enforced by our tight timing budget.

131
00:07:13,834 --> 00:07:19,138
But we also weren't really willing to dive into any of the more exotic fluid simulation attributes such as heat.

132
00:07:19,138 --> 00:07:25,623
In order to properly execute the simulation, we needed to double buffer each of the textures.

133
00:07:25,623 --> 00:07:31,008
Combining all the textures needed for simulation, we ended up with about 384 kilobytes worth of storage.

134
00:07:34,739 --> 00:07:37,662
We ended up swizzling the way we access the 3D textures.

135
00:07:37,662 --> 00:07:40,885
Textures have restrictions on their width and height.

136
00:07:40,885 --> 00:07:43,327
Notably, they must be a multiple of four.

137
00:07:43,327 --> 00:07:46,230
However, 3D textures are able to have finer control

138
00:07:46,230 --> 00:07:48,533
on the amount of slices, aka depth, that they have.

139
00:07:48,953 --> 00:07:53,978
Originally we took the naive approach and had world X and Y slices along the Z axis,

140
00:07:53,978 --> 00:07:58,423
but we preferred having our world X and Z axis be treated uniformly,

141
00:07:58,423 --> 00:08:03,628
and we wanted finer control of the Y axis. This meant that the texture restrictions

142
00:08:03,628 --> 00:08:07,692
led to our 3D volume to actually be world X and Z slices along the world Y axis.

143
00:08:07,692 --> 00:08:10,415
You can see this in the diagram on the right.

144
00:08:11,387 --> 00:08:16,450
The texture is 2D slices along world Y of world X and Z dimensions.

145
00:08:16,450 --> 00:08:21,133
The shader code needed to be adjusted in order to sample and write to the textures.

146
00:08:21,133 --> 00:08:22,875
I've provided some demonstration code for this.

147
00:08:22,875 --> 00:08:30,639
Diffusion is the step to spread the attributes with neighboring cells over time.

148
00:08:30,639 --> 00:08:31,440
Think of it as a blur.

149
00:08:31,440 --> 00:08:36,323
You can also think of it as a mechanism to bring a fluid simulation to an equilibrium.

150
00:08:36,980 --> 00:08:39,921
It's used to transfer energy between neighboring cells

151
00:08:39,921 --> 00:08:44,082
as they directly affect one another due to proximity.

152
00:08:44,082 --> 00:08:46,143
Diffusion requires double buffering

153
00:08:46,143 --> 00:08:47,663
as you're diffusing one iteration

154
00:08:47,663 --> 00:08:49,744
at a time to a separate buffer.

155
00:08:49,744 --> 00:08:52,785
Multiple diffusion steps can simply ping-pong

156
00:08:52,785 --> 00:08:55,746
between the double buffers.

157
00:08:55,746 --> 00:08:58,006
We found that by separating our velocity attribute

158
00:08:58,006 --> 00:08:59,687
into three separate textures,

159
00:08:59,687 --> 00:09:02,848
we were able to achieve incredibly efficient performance

160
00:09:02,848 --> 00:09:03,368
with diffusion.

161
00:09:05,915 --> 00:09:10,498
While the overall bandwidth is the same regardless if you separate the axis or not, we can achieve

162
00:09:10,498 --> 00:09:14,601
faster iteration with separation. Without the separation, you would need to wait for

163
00:09:14,601 --> 00:09:20,406
the first diffusion iteration to completely finish before you can start the second. Instead,

164
00:09:20,406 --> 00:09:21,526
this now only occurs per axis.

165
00:09:21,526 --> 00:09:27,951
Our shader ends up with dealing with less bandwidth per thread, caused by less data

166
00:09:27,951 --> 00:09:32,695
per thread, which means fewer vGPRs per thread, which means better occupancy potential.

167
00:09:33,660 --> 00:09:37,843
Having fewer VGPRs is also highly preferred for shaders that want to run asynchronously.

168
00:09:37,843 --> 00:09:45,829
You can schedule the first diffusion iteration of the X-axis.

169
00:09:45,829 --> 00:09:50,453
Queued behind that is the first iteration of the Y-axis.

170
00:09:50,453 --> 00:09:51,914
Behind that, the Z-axis.

171
00:09:51,914 --> 00:09:53,835
Behind that, the second iteration starts.

172
00:09:53,835 --> 00:09:59,560
The second iteration of the X-axis only has to wait for the first iteration of the X-axis

173
00:09:59,560 --> 00:10:00,180
to complete.

174
00:10:00,950 --> 00:10:02,732
were able to fully utilize the GPU

175
00:10:02,732 --> 00:10:05,914
and minimize any stalling between iterations.

176
00:10:05,914 --> 00:10:07,716
We absorbed the stalls between iterations

177
00:10:07,716 --> 00:10:09,017
by doing more work on other axes.

178
00:10:09,017 --> 00:10:16,202
Motors are the main source of generating wind in our volume.

179
00:10:16,202 --> 00:10:18,624
Various motor types were supplied to the designers.

180
00:10:18,624 --> 00:10:21,146
Some were tailor-made for certain scenarios.

181
00:10:21,146 --> 00:10:23,908
Most of the motors were applied as analytical shapes.

182
00:10:23,908 --> 00:10:27,271
The directional motor simply generates wind

183
00:10:27,271 --> 00:10:29,613
in certain direction at a specified strength.

184
00:10:30,772 --> 00:10:34,155
Omni behaves radially from a central point and can be outwards or inwards.

185
00:10:34,155 --> 00:10:37,278
Vortex behaves sort of like a tornado.

186
00:10:37,278 --> 00:10:40,761
Wind is generated around an axis.

187
00:10:40,761 --> 00:10:44,004
A moving motor generates wind purely based on its movement.

188
00:10:44,004 --> 00:10:47,708
The direction of wind generated is a cone shape in the direction of movement and the

189
00:10:47,708 --> 00:10:49,549
strength is scaled from the movement speed.

190
00:10:49,549 --> 00:10:53,693
The cylinder was a very custom shape with multiple functions.

191
00:10:54,792 --> 00:10:58,413
The radius at both ends of the cylinder were customizable.

192
00:10:58,413 --> 00:11:00,234
The direction could be either unprojected,

193
00:11:00,234 --> 00:11:02,454
that is parallel to that cylinder axis,

194
00:11:02,454 --> 00:11:03,754
or the direction was projected,

195
00:11:03,754 --> 00:11:05,895
and would deviate from the cylinder axis

196
00:11:05,895 --> 00:11:07,295
based on the change of radius,

197
00:11:07,295 --> 00:11:11,276
sort of like a perspective projection matrix.

198
00:11:11,276 --> 00:11:14,397
Pressure motor, we simply inject or withdrew

199
00:11:14,397 --> 00:11:15,817
directly from the pressure attribute.

200
00:11:15,817 --> 00:11:18,038
It could create nice explosion effects,

201
00:11:18,038 --> 00:11:19,098
but was unfortunately dropped

202
00:11:19,098 --> 00:11:20,498
with the whole pressure simulation.

203
00:11:21,711 --> 00:11:24,235
We had some aliasing problems along the way.

204
00:11:24,235 --> 00:11:25,937
Very similar to aliasing problems

205
00:11:25,937 --> 00:11:28,741
commonly found in rasterization.

206
00:11:28,741 --> 00:11:30,684
Designers were creating very small motors

207
00:11:30,684 --> 00:11:32,787
with a large one meter per cube resolution

208
00:11:32,787 --> 00:11:34,850
of the wind volume, we couldn't properly handle it.

209
00:11:35,544 --> 00:11:41,349
We had a few options to help this scenario, but we ended up with keeping the very simple

210
00:11:41,349 --> 00:11:44,352
alias version for performance and continuity reasons.

211
00:11:44,352 --> 00:11:48,556
One solution we proposed was to simply scale the intensity of the motor the further away

212
00:11:48,556 --> 00:11:49,917
it was from the texel center.

213
00:11:49,917 --> 00:11:54,561
But the preferred solution, which we will likely adopt in the future, is to estimate

214
00:11:54,561 --> 00:11:59,846
how much of each texel is contained within the motor and scale the intensity based on

215
00:11:59,846 --> 00:12:00,387
that.

216
00:12:00,387 --> 00:12:02,448
Here I've supplied some sample code of our wind motors.

217
00:12:05,508 --> 00:12:11,129
Advection is the process of transferring energy based on velocity, in this case between texels.

218
00:12:11,129 --> 00:12:16,890
You advect all the attributes by the velocity attribute, including advecting velocity by itself.

219
00:12:16,890 --> 00:12:21,151
Using advection, velocity pushes the energy of the attributes around your simulation and behaves

220
00:12:21,151 --> 00:12:26,752
like momentum. We can do similar performance tricks on advection like we did with diffusion.

221
00:12:26,752 --> 00:12:30,713
We're able to run this advection through separation of axis and keep register pressure low.

222
00:12:31,830 --> 00:12:35,031
Both forward and reverse are important to our simulation quality.

223
00:12:35,031 --> 00:12:39,612
But both forward and reverse advection require being able to read-write to multiple texels

224
00:12:39,612 --> 00:12:41,832
in one iteration and this causes contention.

225
00:12:41,832 --> 00:12:47,954
Contention means multiple threads are trying to access the same resource at the same time.

226
00:12:47,954 --> 00:12:51,015
Solving this on a single-threaded CPU is fairly trivial.

227
00:12:51,015 --> 00:12:54,256
Solving this on a multi-threaded GPU is difficult.

228
00:12:54,256 --> 00:12:58,577
In our case, we have potentially multiple threads trying to write to the same texel

229
00:12:58,577 --> 00:12:59,537
at the same time.

230
00:13:00,520 --> 00:13:04,522
How to resolve these writes is case specific but in our case we simply need to sum the

231
00:13:04,522 --> 00:13:05,082
results.

232
00:13:05,082 --> 00:13:12,064
Unfortunately the hardware doesn't let us do atomic arithmetic on floating point values

233
00:13:12,064 --> 00:13:16,205
so the first solution I came up with was to spin on a compare and exchange instruction.

234
00:13:16,205 --> 00:13:20,007
While not ideal, this did work and the performance actually surprised me a bit.

235
00:13:20,007 --> 00:13:20,707
It wasn't too bad.

236
00:13:20,707 --> 00:13:26,029
I would consider the performance to be shippable.

237
00:13:26,029 --> 00:13:27,049
You can see in the example code.

238
00:13:28,810 --> 00:13:34,732
The first attempt is guessing the current value of 0, adding our value, and attempting

239
00:13:34,732 --> 00:13:37,873
the compare and exchange to update the value in memory.

240
00:13:37,873 --> 00:13:41,994
If the compare and exchange fails, we can use the old value it gave us as our new current

241
00:13:41,994 --> 00:13:46,155
value, add again, and compare and exchange again.

242
00:13:46,155 --> 00:13:50,076
But by borrowing some old school technique, we can do better.

243
00:13:50,076 --> 00:13:54,197
As I said in the previous slides, the hardware doesn't allow atomic arithmetic on floating

244
00:13:54,197 --> 00:13:54,998
point values.

245
00:13:55,587 --> 00:14:01,131
floating point. Why not try fixed point, as suggested by our tech director, Florian Strauss.

246
00:14:01,131 --> 00:14:06,556
We used 16.16 pixel fixed point format, which gave us plenty of precision in both the upper

247
00:14:06,556 --> 00:14:11,780
and lower end. All of the shader ALU ops would still behave in floating point, but when it

248
00:14:11,780 --> 00:14:15,663
came to storing and loading the values to memory, we would do the conversion to and

249
00:14:15,663 --> 00:14:16,324
from fixed point.

250
00:14:18,477 --> 00:14:20,497
While this wouldn't decrease the contention itself,

251
00:14:20,497 --> 00:14:21,598
that's out of our hands here,

252
00:14:21,598 --> 00:14:23,518
but we were able to reduce the overhead

253
00:14:23,518 --> 00:14:25,999
of trying to store these scatter writes.

254
00:14:25,999 --> 00:14:28,960
We saved approximately 40 microseconds right off the top

255
00:14:28,960 --> 00:14:30,641
and notice we got significant improvements

256
00:14:30,641 --> 00:14:32,781
in cases where we expect lots of contention,

257
00:14:32,781 --> 00:14:35,022
approximately 130 microseconds worth.

258
00:14:35,022 --> 00:14:40,884
These time savings proved to be well worth the precision loss

259
00:14:40,884 --> 00:14:42,005
which wasn't even noticeable.

260
00:14:46,633 --> 00:14:49,636
On store, we would simply scale our floating point values

261
00:14:49,636 --> 00:14:51,957
by the precision we needed, convert to integer,

262
00:14:51,957 --> 00:14:54,539
and then use Atomic Integer Add available to us,

263
00:14:54,539 --> 00:14:55,400
and it worked great.

264
00:14:55,400 --> 00:15:00,423
The wind simulation is quite literally the first thing

265
00:15:00,423 --> 00:15:01,684
that is run in our GPU frame.

266
00:15:01,684 --> 00:15:04,987
It takes about one-tenth of a millisecond

267
00:15:04,987 --> 00:15:06,768
if it is run on the main graphics pipe,

268
00:15:06,768 --> 00:15:09,290
but it is actually run asynchronously

269
00:15:09,290 --> 00:15:12,112
at the same time as our post-space deformers,

270
00:15:12,112 --> 00:15:12,892
custom render targets,

271
00:15:12,892 --> 00:15:15,114
and some particle maintenance shaders.

272
00:15:15,983 --> 00:15:21,563
It's run first because some of the results are required for our depth pass, which is the first main pass used to draw the scene.

273
00:15:24,022 --> 00:15:26,743
Here you can see the timing of our wind simulation.

274
00:15:26,743 --> 00:15:28,623
Please note, all times are taken as if they were run

275
00:15:28,623 --> 00:15:29,844
on the main graphics pipe.

276
00:15:29,844 --> 00:15:33,004
That is to say, all compute work that normally runs

277
00:15:33,004 --> 00:15:36,265
on the async pipes are being run on the graphics pipe here.

278
00:15:36,265 --> 00:15:38,366
In blue, we have our diffusion steps.

279
00:15:38,366 --> 00:15:39,606
In red, our motor application.

280
00:15:39,606 --> 00:15:42,807
In orange, we set up the forward advection pass,

281
00:15:42,807 --> 00:15:44,107
which is this clearing the memory,

282
00:15:44,107 --> 00:15:46,148
which will accumulate the forward advection results.

283
00:15:46,148 --> 00:15:48,728
In yellow, we do the forward advection itself.

284
00:15:50,813 --> 00:15:53,375
In green, we set up the reverse advection pass,

285
00:15:53,375 --> 00:15:54,496
but instead of clearing,

286
00:15:54,496 --> 00:15:57,118
we duplicate the current advection results.

287
00:15:57,118 --> 00:16:00,320
So in cyan, we perform the reverse advection itself.

288
00:16:00,320 --> 00:16:02,481
Finally, in purple, we export the results

289
00:16:02,481 --> 00:16:05,583
for easy access on the GPU and CPU.

290
00:16:05,583 --> 00:16:07,985
You can see each pass has very low amount of VGPR

291
00:16:07,985 --> 00:16:11,307
and SGPR pressure, ideal for running asynchronously.

292
00:16:11,307 --> 00:16:15,210
A reminder that the diffusion pass is five iterations.

293
00:16:16,240 --> 00:16:18,880
So the total is 43.2 microseconds.

294
00:16:18,880 --> 00:16:23,982
It averages out to around 8.64 microseconds per iteration.

295
00:16:23,982 --> 00:16:27,603
You can also see the diffusion has very good scheduling.

296
00:16:27,603 --> 00:16:30,643
This is the separation of axis working for you.

297
00:16:30,643 --> 00:16:33,984
I think if we had larger volume than our 16 by 32 size,

298
00:16:33,984 --> 00:16:38,305
we could better demonstrate some of the high performance

299
00:16:38,305 --> 00:16:40,386
this simulation can achieve.

300
00:16:42,218 --> 00:16:44,318
We simply don't have enough data to process

301
00:16:44,318 --> 00:16:45,999
in order to properly max out the GPU.

302
00:16:45,999 --> 00:16:49,540
Hopefully, the visual results of the game

303
00:16:49,540 --> 00:16:52,320
have proven we should consider a large timing budget

304
00:16:52,320 --> 00:16:53,780
next time around.

305
00:16:53,780 --> 00:16:57,481
In hindsight, I realize I could have very easily absorbed

306
00:16:57,481 --> 00:16:59,302
both of the setup steps for advection

307
00:16:59,302 --> 00:17:02,042
by using a little bit more memory for an additional buffer.

308
00:17:02,042 --> 00:17:05,823
This could have also reduced some of the synchronization

309
00:17:05,823 --> 00:17:09,104
between the steps, perhaps saving around 10 microseconds.

310
00:17:11,131 --> 00:17:16,476
Just for fun, I decided to double the resolution on each axis, giving us 8 times more resolution

311
00:17:16,476 --> 00:17:20,180
overall, and to time it to see how it pans out.

312
00:17:21,037 --> 00:17:25,978
As you can see from the results, it scales quite nicely, except for the export stage.

313
00:17:25,978 --> 00:17:28,959
The export stage is heavily bound by the texture addressor unit.

314
00:17:28,959 --> 00:17:33,661
I didn't have much time to investigate this any further, but I suspect it's because it's

315
00:17:33,661 --> 00:17:39,123
effectively reading 3 lots of 32-bit textures and writing 2 lots of 64-bit textures.

316
00:17:39,123 --> 00:17:40,644
It's bandwidth heavy with very little ALU.

317
00:17:40,644 --> 00:17:44,125
You can async that with some ALU-heavy shader work.

318
00:17:44,125 --> 00:17:48,226
Here I've shown the timing of our full frame.

319
00:17:48,914 --> 00:17:52,395
You can see the win section is tiny in comparison with the rest of the frame.

320
00:17:52,395 --> 00:17:56,416
Please note, this is also with all async compute turned off.

321
00:17:56,416 --> 00:18:00,017
I've done this so you can see how it all fits together.

322
00:18:00,017 --> 00:18:02,617
This is also why postEffects shows up twice.

323
00:18:02,617 --> 00:18:07,099
We kicked one lot of postEffects to run on top of our transparent pass.

324
00:18:07,099 --> 00:18:10,960
Speaking of transparence, this scene had very little, which is why it's a very small sliver

325
00:18:10,960 --> 00:18:11,660
on the timeline.

326
00:18:15,438 --> 00:18:19,641
Being able to temporarily cut out the simulation and override it with a global uniform vector

327
00:18:19,641 --> 00:18:21,503
was very useful.

328
00:18:21,503 --> 00:18:25,966
It lets us make sure that the different systems responding to the wind were all visually relative

329
00:18:25,966 --> 00:18:27,307
to each other as much as possible.

330
00:18:27,307 --> 00:18:32,870
Authoring assets to portray movement at x meters per second isn't easy.

331
00:18:32,870 --> 00:18:37,353
This helped us find the assets that weren't correctly set up.

332
00:18:37,353 --> 00:18:42,357
They may behave too strongly or weakly to the wind compared to the assets around them.

333
00:18:43,201 --> 00:18:45,402
We could also crank up the override speed

334
00:18:45,402 --> 00:18:47,704
and easily find assets that hadn't been set up

335
00:18:47,704 --> 00:18:49,045
to be affected by wind at all yet.

336
00:18:49,045 --> 00:18:52,066
I wrote a small particle emission system,

337
00:18:52,066 --> 00:18:53,527
which would cause particles to emit

338
00:18:53,527 --> 00:18:55,488
directly in front of the camera and follow the wind.

339
00:18:55,488 --> 00:18:59,231
The goal was to mimic plucking some grass from the ground

340
00:18:59,231 --> 00:19:01,552
and dropping it, watching how the wind affects it,

341
00:19:01,552 --> 00:19:03,774
sort of like what sportsmen do.

342
00:19:03,774 --> 00:19:06,115
However, I don't think anyone ever used it.

343
00:19:06,115 --> 00:19:09,057
Being able to lock the volume in its current position

344
00:19:09,057 --> 00:19:10,618
proved useful on several occasions.

345
00:19:13,525 --> 00:19:16,286
Being able to visualize the 3D volume as 2D slices

346
00:19:16,286 --> 00:19:18,346
was by far the most important debugging feature

347
00:19:18,346 --> 00:19:19,747
we had available.

348
00:19:19,747 --> 00:19:21,487
It lets me sanity check the simulation,

349
00:19:21,487 --> 00:19:24,688
as well as give peace of mind for when artists or designers

350
00:19:24,688 --> 00:19:26,828
say they think something may be wrong with it.

351
00:19:26,828 --> 00:19:30,389
Designers also found the visualization useful, too.

352
00:19:30,389 --> 00:19:32,209
Here you can see the green fan in the scene.

353
00:19:32,209 --> 00:19:33,890
That's a directional motor.

354
00:19:33,890 --> 00:19:36,990
It's blowing wind in the direction it's facing.

355
00:19:36,990 --> 00:19:37,830
We also here have a Jotun,

356
00:19:37,830 --> 00:19:40,151
whose attacks are able to generate wind.

357
00:19:40,998 --> 00:19:45,761
Kratos' axe swings also generate wind, as do his axe throws.

358
00:19:45,761 --> 00:19:50,864
As for the colours of the slices, mid grey means zero wind, strong red means strong positive

359
00:19:50,864 --> 00:19:54,566
X, and no red at all means strong negative X.

360
00:19:54,566 --> 00:20:05,693
So red, green, blue indicate the X, Y, Z axis.

361
00:20:05,693 --> 00:20:07,875
We also have a second visualisation mode.

362
00:20:09,308 --> 00:20:11,449
where we show the magnitude of the wind is red.

363
00:20:11,449 --> 00:20:13,510
The more red, the larger the magnitude,

364
00:20:13,510 --> 00:20:28,519
and black means no wind.

365
00:20:28,519 --> 00:20:29,920
We also supplied two methods

366
00:20:29,920 --> 00:20:31,401
for sampling the volume around the camera

367
00:20:31,401 --> 00:20:33,702
and display the results on screen.

368
00:20:33,702 --> 00:20:35,984
This was mostly used by myself and Sean Feely

369
00:20:35,984 --> 00:20:37,064
from our tech art department.

370
00:20:37,880 --> 00:20:40,923
We used it to validate sampling and other obscure situations.

371
00:20:40,923 --> 00:20:45,126
One method would sample a wind volume around Kratos

372
00:20:45,126 --> 00:20:52,372
at a specified interval and draw the vectors in world space.

373
00:20:52,372 --> 00:20:58,637
We can also draw the magnitude of the wind

374
00:20:58,637 --> 00:20:59,718
as text instead of a vector,

375
00:20:59,718 --> 00:21:01,559
although that text might be a bit hard

376
00:21:01,559 --> 00:21:02,640
to read on this presentation.

377
00:21:14,063 --> 00:21:27,649
We can also change how many samples we take, as well as the spacing between them.

378
00:21:27,649 --> 00:21:32,411
The second method draws vectors in the exact location the volume cells are in.

379
00:21:32,411 --> 00:21:35,712
This can get a little overwhelming visually, but you do get used to it.

380
00:21:35,712 --> 00:21:41,494
But it's not really meant to be used by anyone other than myself.

381
00:22:03,278 --> 00:22:06,881
There are various customers to the wind simulation results.

382
00:22:06,881 --> 00:22:10,224
Most read the simulation results on the GPU in the same frame.

383
00:22:10,224 --> 00:22:13,887
Things such as hair, leaves, fur, and particles

384
00:22:13,887 --> 00:22:15,929
were all able to update their simulation immediately

385
00:22:15,929 --> 00:22:17,390
after the wind.

386
00:22:17,390 --> 00:22:19,051
However, there were a few systems on the CPU

387
00:22:19,051 --> 00:22:22,554
which needed the wind simulation results too.

388
00:22:22,554 --> 00:22:23,995
We don't want the wind customers to have

389
00:22:23,995 --> 00:22:25,957
to sample the attribute textures individually.

390
00:22:25,957 --> 00:22:27,278
That's three separate samples.

391
00:22:28,246 --> 00:22:30,847
So we ran a shader to combine the velocity attributes

392
00:22:30,847 --> 00:22:33,187
into a unified 16-bit per channel texture

393
00:22:33,187 --> 00:22:37,488
and export it as XYZ magnitude.

394
00:22:37,488 --> 00:22:39,729
But we really had two exported textures,

395
00:22:39,729 --> 00:22:41,689
one for the GPU in its GPU-preferred

396
00:22:41,689 --> 00:22:43,290
tiled and swizzled form,

397
00:22:43,290 --> 00:22:46,450
and one as a double-buffered linear texture for CPU access.

398
00:22:46,450 --> 00:22:49,731
The audio and cloth simulations, which ran on the CPU,

399
00:22:49,731 --> 00:22:52,132
had to read from the previous frame's wind results,

400
00:22:52,132 --> 00:22:54,192
but this was acceptable to us.

401
00:22:54,933 --> 00:23:00,719
There is another GDC talk which goes into more details on how the hair, leaves and fur behaves,

402
00:23:00,719 --> 00:23:04,663
and I highly recommend you check it out.

403
00:23:04,663 --> 00:23:06,906
The Beaufort scale was of great help to us.

404
00:23:06,906 --> 00:23:11,551
It's generally considered a scale of 0 to 12, where 0 is no wind and 12 is hurricane force.

405
00:23:12,526 --> 00:23:16,887
It gives very nice descriptions of what you would expect to see visually on land and at

406
00:23:16,887 --> 00:23:19,228
sea at certain speeds of wind.

407
00:23:19,228 --> 00:23:23,969
It would range from descriptions like leaves rustle for the Beaufort scale of 2, which

408
00:23:23,969 --> 00:23:30,451
is about 2 meters per second, or small trees begin to sway for Beaufort 5, which is around

409
00:23:30,451 --> 00:23:31,452
9 meters per second.

410
00:23:31,452 --> 00:23:34,993
If you're going to author assets for wind, I highly recommend you check out the Beaufort

411
00:23:34,993 --> 00:23:35,213
scale.

412
00:23:38,908 --> 00:23:42,149
So in conclusion, I've hoped I've convinced you of several things.

413
00:23:42,149 --> 00:23:47,091
Firstly, Wind is a good tool you can use to help bring your world alive

414
00:23:47,091 --> 00:23:49,612
and add a little bit more interaction between the world and the player.

415
00:23:49,612 --> 00:23:52,393
It doesn't have to cost you much either.

416
00:23:52,393 --> 00:23:54,533
We achieved a lot in a fraction of a millisecond.

417
00:23:54,533 --> 00:23:57,374
You can get pretty decent quality results

418
00:23:57,374 --> 00:24:00,455
and also keep the simulation very stable.

419
00:24:00,455 --> 00:24:04,397
Forward and reverse advection complement each other well.

420
00:24:04,397 --> 00:24:05,097
Please use both.

421
00:24:06,695 --> 00:24:09,776
Old school techniques like Fixpoint will never truly go away.

422
00:24:09,776 --> 00:24:14,158
They always have a nice little niche to fit into.

423
00:24:14,158 --> 00:24:15,718
Finally, having good debugging tools

424
00:24:15,718 --> 00:24:17,699
will make the whole thing go a lot smoother,

425
00:24:17,699 --> 00:24:22,321
especially being able to visualize the slices.

426
00:24:22,321 --> 00:24:24,462
We've come a long way in 15 years.

427
00:24:24,462 --> 00:24:26,243
What was once done on the CPU

428
00:24:26,243 --> 00:24:28,744
can now be easily done on the GPU.

429
00:24:28,744 --> 00:24:32,025
We have distinct advantages available to us on the GPU.

430
00:24:32,025 --> 00:24:34,486
It's another tool to have on your belt, so use it.

431
00:24:36,422 --> 00:24:40,025
Please go and see Sean Filly's talk on interactive wind and vegetation.

432
00:24:40,025 --> 00:24:41,727
His talk starts where mine leaves off.

433
00:24:41,727 --> 00:24:45,209
If you like my talk and I've managed to convince you to have wind in your own game,

434
00:24:45,209 --> 00:24:49,313
or maybe you're still on the fence and still need a bit more convincing,

435
00:24:49,313 --> 00:24:50,514
you must attend this talk.

436
00:24:50,514 --> 00:24:53,476
Sean's talk will focus a lot on the customers of wind,

437
00:24:53,476 --> 00:24:55,398
which I've only very lightly covered here.

438
00:24:55,398 --> 00:24:59,281
Things such as foliage, air, fur, trees,

439
00:24:59,281 --> 00:25:00,942
leaves, and how they interact with the wind.

440
00:25:01,732 --> 00:25:05,235
He'll cover things we worked on, such as leveraging compute workloads

441
00:25:05,235 --> 00:25:08,338
to update the state of dynamically animated objects

442
00:25:08,338 --> 00:25:10,259
and logarithmically binned flow maps,

443
00:25:10,259 --> 00:25:14,223
and go into detail on what goes on in the vertex shader for wind objects,

444
00:25:14,223 --> 00:25:18,547
covering topics such as dual height field grass interaction.

445
00:25:18,547 --> 00:25:20,649
He will also speak on some of the miscellaneous topics,

446
00:25:20,649 --> 00:25:23,892
such as card clustering and big O log n flood fill,

447
00:25:23,892 --> 00:25:25,293
and a bunch of other topics.

448
00:25:27,253 --> 00:25:28,374
Thanks, everyone, for attending.

449
00:25:28,374 --> 00:25:30,335
I'd just like to take a few moments to thank others

450
00:25:30,335 --> 00:25:32,196
who helped out in various ways.

451
00:25:32,196 --> 00:25:33,657
Big thank you to Sean Feely.

452
00:25:33,657 --> 00:25:35,918
He did more work than you can possibly imagine

453
00:25:35,918 --> 00:25:38,960
in making Wind and God of War a success.

454
00:25:38,960 --> 00:25:42,502
Florian Strauss, Dale Sun, and the rest of the rendering team.

455
00:25:42,502 --> 00:25:44,224
Jack Mulholland and Andreas Frederiksen.

456
00:25:44,224 --> 00:25:48,106
Sorry. We're hiring in a bunch of positions.

457
00:25:48,106 --> 00:25:50,007
Please check out our website.

458
00:25:50,007 --> 00:25:53,089
We have job openings in a lot of departments,

459
00:25:53,089 --> 00:25:55,811
and you can help join us on our next project.

460
00:25:57,082 --> 00:26:02,103
We also have a bunch of other talks we're giving from the studio.

461
00:26:02,103 --> 00:26:07,885
I believe we are currently around here.

462
00:26:07,885 --> 00:26:18,308
So we've got all these left to go.

463
00:26:18,308 --> 00:26:18,988
Any questions?

464
00:26:18,988 --> 00:26:24,809
Please come up to the microphones.

465
00:26:24,809 --> 00:26:25,150
Hi, good talk.

466
00:26:25,150 --> 00:26:25,450
Please, sorry.

467
00:26:25,994 --> 00:26:26,294
Go ahead.

468
00:26:26,294 --> 00:26:26,374
OK.

469
00:26:26,374 --> 00:26:30,257
You talk about some motors there.

470
00:26:30,257 --> 00:26:36,982
These motors are, you got some from where or you developed it?

471
00:26:36,982 --> 00:26:39,004
The motors are applied in shader code.

472
00:26:39,004 --> 00:26:42,226
And we set them up, sorry, the question was about motors

473
00:26:42,226 --> 00:26:43,147
and how to place them.

474
00:26:43,147 --> 00:26:44,188
Is that correct?

475
00:26:44,188 --> 00:26:44,848
Yeah, yeah.

476
00:26:44,848 --> 00:26:49,452
If you developed these motors or you got it from the.

477
00:26:50,507 --> 00:26:57,050
I don't know, any tool that you already have online or even from inside the engine?

478
00:26:57,050 --> 00:27:00,272
No, everything was inside our own engine and was custom built by ourselves.

479
00:27:00,272 --> 00:27:04,394
So we would place the motors inside of Maya scenes.

480
00:27:04,394 --> 00:27:06,736
I think we could also place them in script.

481
00:27:06,736 --> 00:27:10,238
And basically they would be applied in shader code on the GPU at runtime.

482
00:27:10,238 --> 00:27:12,259
Does that answer your question?

483
00:27:12,259 --> 00:27:12,459
Okay.

484
00:27:12,459 --> 00:27:12,999
Excellent.

485
00:27:12,999 --> 00:27:13,640
Yes, thank you.

486
00:27:14,620 --> 00:27:14,920
Go ahead.

487
00:27:14,920 --> 00:27:20,001
Yeah, the area is not too big, so how did you do the fade outs that you didn't see like

488
00:27:20,001 --> 00:27:20,942
pops or something like that?

489
00:27:20,942 --> 00:27:22,662
Because you see this in the textures.

490
00:27:22,662 --> 00:27:25,943
So the question is on the range of the wind volume.

491
00:27:25,943 --> 00:27:28,924
So we have the wind volume, which surrounds the player camera.

492
00:27:28,924 --> 00:27:32,125
It's actually pushed a little bit forward, so it's not directly in the center of the

493
00:27:32,125 --> 00:27:32,425
camera.

494
00:27:32,425 --> 00:27:36,587
It's pushed forward so you can see most of it, but the static wind is what covers outside

495
00:27:36,587 --> 00:27:37,227
of that volume.

496
00:27:37,787 --> 00:27:39,810
So that's why we have a three-tiered approach.

497
00:27:39,810 --> 00:27:41,953
The static wind is mostly for everything

498
00:27:41,953 --> 00:27:45,438
that you can see as far as your frustum plane will allow.

499
00:27:45,438 --> 00:27:48,383
And the dynamic volume is what's surrounding the player

500
00:27:48,383 --> 00:27:51,487
and follows the player, and that's the interactable part.

501
00:27:51,487 --> 00:27:52,208
Is that it?

502
00:27:52,208 --> 00:27:52,389
Yeah.

503
00:27:52,949 --> 00:27:54,911
Yeah, no problems with pops or something.

504
00:27:54,911 --> 00:27:55,031
No.

505
00:27:55,031 --> 00:27:55,792
Okay, thanks.

506
00:27:55,792 --> 00:27:56,132
No problem.

507
00:27:56,132 --> 00:27:56,753
All right, go ahead.

508
00:27:56,753 --> 00:27:56,993
Sorry.

509
00:27:56,993 --> 00:28:02,157
Do you handle interaction with terrain or static objects at all?

510
00:28:02,157 --> 00:28:09,263
So a slope would push the wind upwards if it was blowing in that direction or...

511
00:28:09,263 --> 00:28:10,805
Sorry, what's the question?

512
00:28:10,805 --> 00:28:13,987
Do you handle interaction with terrain or static objects?

513
00:28:13,987 --> 00:28:17,931
So if there's a slope or a boulder, it would push the wind...

514
00:28:18,932 --> 00:28:21,272
Oh, OK, interactions with the world.

515
00:28:21,272 --> 00:28:23,733
We thought about it, but ultimately we

516
00:28:23,733 --> 00:28:26,074
didn't really have any places to justify doing that.

517
00:28:26,074 --> 00:28:29,035
So the wind volume is actually completely unobstructed.

518
00:28:29,035 --> 00:28:29,175
Thanks.

519
00:28:29,175 --> 00:28:30,996
No problem.

520
00:28:30,996 --> 00:28:32,877
Go ahead.

521
00:28:32,877 --> 00:28:36,698
How much did you iterate on the scale of the wind volume,

522
00:28:36,698 --> 00:28:39,379
and how did you decide to make that cut off?

523
00:28:39,837 --> 00:28:43,479
So the question is about the scale of the wind volume and how we arrived at that.

524
00:28:43,479 --> 00:28:44,480
That's a good question.

525
00:28:44,480 --> 00:28:49,624
I guess it was mostly tailored to make sure that how far the axe can be thrown by Kratos

526
00:28:49,624 --> 00:28:50,985
would be the limit, because it's actually quite far.

527
00:28:50,985 --> 00:28:54,227
And so that's also why we pushed the camera forward, because the axe throw is usually

528
00:28:54,227 --> 00:28:56,769
forward, you know, you can't really throw it behind you.

529
00:28:56,769 --> 00:29:00,952
So the bound of the volume itself is mostly defined by that, but also, again, the timing

530
00:29:00,952 --> 00:29:03,294
restrictions we had in the game.

531
00:29:03,294 --> 00:29:04,455
So that's a good question.

532
00:29:04,455 --> 00:29:04,915
Thank you, Tom.

533
00:29:04,915 --> 00:29:05,756
You're welcome.

534
00:29:05,756 --> 00:29:06,256
Thanks, everyone.

535
00:29:06,256 --> 00:29:07,177
Thanks for listening.

536
00:29:07,177 --> 00:29:08,258
And we'll see you next time.

537
00:29:08,258 --> 00:29:08,318
Bye.

538
00:29:10,046 --> 00:29:10,346
Go ahead.

539
00:29:10,346 --> 00:29:10,567
Great talk.

540
00:29:10,567 --> 00:29:11,087
Thank you.

541
00:29:11,087 --> 00:29:15,811
How did you send the motor information into the shaders?

542
00:29:15,811 --> 00:29:17,753
Was it via textures or?

543
00:29:17,753 --> 00:29:18,874
Oh, good question.

544
00:29:18,874 --> 00:29:25,380
It was applied as constants, sorry.

545
00:29:25,380 --> 00:29:26,641
Yes, not textures, not buffers.

546
00:29:26,641 --> 00:29:28,043
It's in the shader constants.

547
00:29:28,043 --> 00:29:28,283
Thanks.

548
00:29:31,876 --> 00:29:39,166
Hi, sorry, so related to that question, so were the motors, some motors like the fan, was that placed in the level by designers?

549
00:29:39,166 --> 00:29:40,007
Yes, it was.

550
00:29:40,007 --> 00:29:46,596
And how, so then if you had like a lot of these in a level, how would you like only consider the relevant ones?

551
00:29:47,033 --> 00:29:48,453
That's a good question.

552
00:29:48,453 --> 00:29:54,336
So we basically just tested all of the motors on the CPU and we filled up the buffers that

553
00:29:54,336 --> 00:29:55,837
we had in the shader.

554
00:29:55,837 --> 00:29:58,198
Sorry, I said buffers to him, but it's an array.

555
00:29:58,198 --> 00:29:59,778
What I meant was an array.

556
00:29:59,778 --> 00:30:06,521
So we would effectively pre-filter the closest motors on the CPU, then set them in the array

557
00:30:06,521 --> 00:30:10,703
on the shader constants, and then that's how the GPU would find them.

558
00:30:10,703 --> 00:30:11,484
Makes sense, thank you.

559
00:30:11,484 --> 00:30:13,184
No problem.

560
00:30:13,184 --> 00:30:14,025
Any final questions?

561
00:30:16,163 --> 00:30:16,987
All right, thank you, everyone.

