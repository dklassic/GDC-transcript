1
00:00:07,203 --> 00:00:11,747
Good afternoon, everyone. If I could have your attention really quick, before I get

2
00:00:11,767 --> 00:00:17,772
started with the talk proper, I want to share two quick notes with you. First, please silence

3
00:00:17,812 --> 00:00:25,899
cell phones, laptops, anything else that might make a disruptive noise. Second, this is mentioned

4
00:00:25,919 --> 00:00:29,162
in a few places in the program. One second.

5
00:00:33,285 --> 00:00:34,366
All right. Sure, sure.

6
00:00:35,486 --> 00:00:39,427
So it is mentioned in a couple spots in the program and at the door, but there are also

7
00:00:39,467 --> 00:00:40,548
a few spots where it's not mentioned.

8
00:00:40,908 --> 00:00:42,368
This is a two-hour talk.

9
00:00:43,388 --> 00:00:45,929
We are going to run until 5 including Q&A.

10
00:00:47,470 --> 00:00:49,290
Obviously, there's a whole bunch of sessions at 4.30.

11
00:00:49,510 --> 00:00:51,211
Some of you may be very attached to those sessions.

12
00:00:51,951 --> 00:00:52,852
I have good news for you.

13
00:00:52,892 --> 00:00:56,213
The slides should run about an hour and 20, and then we'll do Q&A.

14
00:00:56,313 --> 00:00:58,753
So if you're willing to skip Q&A, catch it on GDC Vault.

15
00:00:59,054 --> 00:00:59,994
You should be able to catch a 4.30 talk.

16
00:01:04,193 --> 00:01:08,195
Thirdly and lastly, I've been asked that if possible, if you could all scoot towards the

17
00:01:08,235 --> 00:01:10,476
center of your sections as latecomers come in.

18
00:01:10,536 --> 00:01:14,097
We want to allow them to enter the audience with minimal disruption.

19
00:01:21,960 --> 00:01:25,081
With that, welcome to I Shot You First.

20
00:01:26,361 --> 00:01:31,183
I am both honored and incredibly excited to be here today to talk to you about the gameplay

21
00:01:31,223 --> 00:01:32,303
networking of Halo Reach.

22
00:01:34,177 --> 00:01:38,439
When I started working on Reach three long years ago, I knew very little of what I'm

23
00:01:38,459 --> 00:01:42,140
going to describe to you in this talk, and I would have killed to get my hands on it.

24
00:01:43,701 --> 00:01:46,982
I hope that you will find its lessons useful in your own games.

25
00:01:49,203 --> 00:01:54,105
The very first thing that you're probably wondering is, who the heck am I to be talking

26
00:01:54,125 --> 00:01:54,645
to you about this?

27
00:01:55,125 --> 00:01:55,905
I'm David Aldridge.

28
00:01:57,046 --> 00:01:58,606
I'm the lead networking engineer at Bungie.

29
00:01:59,927 --> 00:02:02,768
I spent approximately three years working on Halo Reach networking.

30
00:02:04,434 --> 00:02:08,317
I've been in the games industry for quite a long time before that, starting with this

31
00:02:08,377 --> 00:02:11,399
gem over ten years ago.

32
00:02:13,661 --> 00:02:17,683
The second thing you're probably all wondering is what is Halo Reach?

33
00:02:20,045 --> 00:02:23,948
Fortunately, I have prepared a small video here to show you what you're missing.

34
00:02:28,271 --> 00:02:28,711
Sound.

35
00:02:31,553 --> 00:02:32,954
Please pardon the technical difficulties.

36
00:03:08,308 --> 00:03:16,674
Killing spree.

37
00:03:16,714 --> 00:03:17,474
Lost the lead.

38
00:03:17,514 --> 00:03:18,255
Double kill.

39
00:03:18,315 --> 00:03:19,216
Triple kill.

40
00:03:48,783 --> 00:03:51,144
So that's Halo Reach. We're pretty proud of it.

41
00:03:53,345 --> 00:03:56,006
So there's three things that I want you to walk out of this talk with.

42
00:03:56,166 --> 00:03:59,067
Three things that if I do my job, you will leave here with.

43
00:03:59,547 --> 00:04:06,150
First, we're gonna talk about a proven architecture for scalable gameplay networking.

44
00:04:06,730 --> 00:04:08,511
Proven across three Halo titles.

45
00:04:09,613 --> 00:04:13,236
This word scalable is very, very key here, and we're going to return to it again and

46
00:04:13,276 --> 00:04:13,536
again.

47
00:04:14,817 --> 00:04:16,818
There are many ways to do networking that are not scalable.

48
00:04:18,480 --> 00:04:23,484
We have a way that we have been, we have had very good luck with scaling across games with

49
00:04:23,544 --> 00:04:26,206
very, very large numbers of objects and very diverse gameplay mechanics.

50
00:04:28,427 --> 00:04:33,671
Second, we're going to talk about how to design solid networking for your game mechanics.

51
00:04:34,669 --> 00:04:38,472
which includes things like ensuring that your game mechanic design and your network design

52
00:04:38,592 --> 00:04:41,313
work hand in hand to reach the highest possible quality.

53
00:04:43,655 --> 00:04:49,419
Third, we're going to talk about how to measure and optimize your networking systems, something

54
00:04:49,439 --> 00:04:56,603
that is incredibly important. There are a few things that I want to get

55
00:04:56,643 --> 00:04:58,845
out of the way up front that this talk is not about.

56
00:04:59,485 --> 00:05:02,227
Since there's the word networking in the title, there are certain expectations.

57
00:05:03,903 --> 00:05:07,766
First, we're not talking about Halo's campaign or Firefight networking. We're specifically

58
00:05:07,806 --> 00:05:14,131
talking about the competitive multiplayer experience, 16 players, PvP. Campaign and Firefight

59
00:05:14,191 --> 00:05:16,692
use a different networking model that we'll touch on very, very briefly, but we won't

60
00:05:16,713 --> 00:05:21,536
go into any detail on. Second, we're not talking about sockets.

61
00:05:22,217 --> 00:05:25,739
We're not talking about traversing a gnat and punching a hole in a firewall and connecting

62
00:05:25,759 --> 00:05:29,742
to a remote machine. Everyone has to solve this problem once, but it's not really that

63
00:05:29,782 --> 00:05:32,785
interesting in the long run. Third...

64
00:05:33,768 --> 00:05:37,110
We're not going to talk about what we call high-level networking at Bungie, things like

65
00:05:37,170 --> 00:05:40,672
matchmaking, getting players together into games, creating your online ecosystem.

66
00:05:44,734 --> 00:05:47,376
Without further ado, let's go into the gameplay networking architecture.

67
00:05:48,977 --> 00:05:49,217
All right.

68
00:05:49,297 --> 00:05:50,297
So what is gameplay networking?

69
00:05:50,377 --> 00:05:53,039
What is this problem we're trying to solve here?

70
00:05:55,080 --> 00:05:56,601
I sat down and I tried to write a definition.

71
00:05:56,761 --> 00:05:57,661
This is what I came up with.

72
00:05:58,142 --> 00:05:58,822
It's a little wordy.

73
00:05:59,722 --> 00:06:00,503
It's very explicit.

74
00:06:02,425 --> 00:06:04,267
I don't actually like this definition very much at all.

75
00:06:05,247 --> 00:06:09,911
Communicating sufficient information, perceptually shared reality, this sounds almost like you

76
00:06:09,931 --> 00:06:11,812
could test an algorithm against it.

77
00:06:11,912 --> 00:06:12,493
That's crazy.

78
00:06:12,533 --> 00:06:14,114
Gameplay networking does not really work this way.

79
00:06:14,394 --> 00:06:16,856
In practice, this is what gameplay networking is, in my opinion.

80
00:06:18,577 --> 00:06:23,501
Technology to help multiple players sustain the belief that they're playing a fun game

81
00:06:23,541 --> 00:06:23,841
together.

82
00:06:25,002 --> 00:06:26,363
What underlies that does not matter.

83
00:06:31,133 --> 00:06:32,214
How can we solve this problem?

84
00:06:32,274 --> 00:06:36,417
How can we create some technology so that players believe they're playing a game together?

85
00:06:36,818 --> 00:06:38,899
There are some simple approaches, simpler approaches.

86
00:06:38,959 --> 00:06:42,522
Nothing is really ever simple, but simplifying approaches that will make your life easier.

87
00:06:42,862 --> 00:06:47,146
First, you can use lockstep, also called deterministic or input passing methods.

88
00:06:47,386 --> 00:06:49,628
This is what Halo's campaign and firefight networking use.

89
00:06:50,929 --> 00:06:54,512
In this model, you rely on the complete determinism of your game loop.

90
00:06:54,972 --> 00:06:59,596
You pass the non-deterministic player controller inputs over the wire, and voila, everyone's

91
00:06:59,636 --> 00:07:00,837
running in the same game simulation.

92
00:07:01,910 --> 00:07:07,474
The downsides to this are that your input latency from the controller to the game includes

93
00:07:07,594 --> 00:07:10,817
the network round trip time to the host of the game.

94
00:07:12,358 --> 00:07:15,921
This means that for first-person shooters, you end up with significant input latency

95
00:07:15,941 --> 00:07:18,603
when you try to shoot your gun or jump or operate on the world in any way.

96
00:07:19,363 --> 00:07:23,587
Unacceptable in a multiplayer context where players are fighting each other.

97
00:07:25,809 --> 00:07:27,170
The second way you can make your life easier.

98
00:07:27,667 --> 00:07:32,649
is to use reliable transport protocols, whether TCP or a homegrown reliable UDP to try to

99
00:07:32,689 --> 00:07:37,431
reduce the latency of it. This can make your life much, much easier because you don't have

100
00:07:37,471 --> 00:07:41,572
to worry about things being reordered or lost in the wild woolly Internet.

101
00:07:43,793 --> 00:07:48,214
This works very well as long as you have relatively simple network state or you're willing to

102
00:07:48,315 --> 00:07:52,356
use a very large amount of bandwidth and restrict the number of machines and Internet connections

103
00:07:52,376 --> 00:07:53,076
that can play your game.

104
00:07:57,277 --> 00:08:00,018
You can always send all of the network state about your game.

105
00:08:02,159 --> 00:08:04,560
Specifically, you can always send it atomically.

106
00:08:05,220 --> 00:08:07,881
What this means is you will not have problems where the network

107
00:08:07,921 --> 00:08:10,022
state of one object is out of sync with the network

108
00:08:10,042 --> 00:08:10,562
state of another.

109
00:08:10,762 --> 00:08:14,104
You can guarantee that remote clients will receive the entire

110
00:08:14,144 --> 00:08:15,905
network state of the world in a consistent way.

111
00:08:16,365 --> 00:08:18,546
This fixes an enormous class of bugs.

112
00:08:18,586 --> 00:08:20,087
The Quake 3 model is famous for this.

113
00:08:21,590 --> 00:08:24,593
This works very, very well as long as you can express the total network state of your

114
00:08:24,613 --> 00:08:27,395
game in no more than a few hundred bytes, let's say.

115
00:08:29,036 --> 00:08:30,978
Does not work with very large numbers of objects.

116
00:08:33,680 --> 00:08:37,843
Unfortunately for us, and the reason I'm here to talk to you today, Halo has to solve the

117
00:08:37,924 --> 00:08:38,624
hard problem.

118
00:08:40,365 --> 00:08:44,869
We have hundreds of networked objects, every one of which can stop a bullet, every one

119
00:08:44,909 --> 00:08:47,191
of which can affect the gameplay in a critical way.

120
00:08:48,192 --> 00:08:50,934
We have a highly competitive skill-based action game.

121
00:08:51,243 --> 00:08:53,904
that players devote thousands of hours to mastering.

122
00:08:55,665 --> 00:08:58,586
We do not use dedicated servers to minimize latency between peers.

123
00:08:59,687 --> 00:09:01,688
Players expect the game to always work.

124
00:09:02,248 --> 00:09:06,930
For many of you from the PC world, players on PCs can tolerate a certain amount of futzing

125
00:09:06,970 --> 00:09:07,911
with their connection.

126
00:09:07,951 --> 00:09:13,073
You can show them some interesting debug information like lag indicators, things like that.

127
00:09:13,273 --> 00:09:15,374
The console audience doesn't really tolerate much of this at all.

128
00:09:16,455 --> 00:09:17,455
It pretty much just has to work.

129
00:09:19,947 --> 00:09:23,448
And lastly, the sort of the death knell for any of these methods for Halo multiplayer

130
00:09:23,828 --> 00:09:29,749
is this n squared problem that comes up in so many contexts across engineering.

131
00:09:30,709 --> 00:09:36,010
For n players, we have to send the network game state to n minus one remote machines.

132
00:09:37,130 --> 00:09:40,811
And the amount of things occurring in the game world is proportional to the number of

133
00:09:40,851 --> 00:09:43,191
players because they're all shooting, they're all creating havoc.

134
00:09:44,192 --> 00:09:47,712
This leads us to a classic almost n squared graph, something like this.

135
00:09:48,567 --> 00:09:52,792
Where the very lower left there is the amount of bandwidth that you would need to transmit

136
00:09:52,872 --> 00:09:55,655
everything that was happening in the world if you were in a two-player game.

137
00:09:56,195 --> 00:09:59,939
And the far right, 100 times, is the amount you would need for a 16-player game.

138
00:10:02,622 --> 00:10:04,404
This is totally infeasible for Halo.

139
00:10:04,665 --> 00:10:08,469
We've graphed this out and it comes out to something ludicrous like 20 megabits a second

140
00:10:08,509 --> 00:10:08,869
of data.

141
00:10:13,103 --> 00:10:15,764
Fortunately, we are not the first game to have faced this problem.

142
00:10:15,944 --> 00:10:20,085
And even more fortunately, one of the games that did wrote a beautiful paper over ten

143
00:10:20,125 --> 00:10:21,705
years ago and presented it at GDC.

144
00:10:22,885 --> 00:10:28,766
The Tribes Engine Networking Model by Mark Von Meier and Tim Gift, they outlined a host

145
00:10:28,806 --> 00:10:31,587
client model resilient to cheating, like most PVP games.

146
00:10:33,587 --> 00:10:37,188
The key attribute of their model that made it really interesting for us and made it the

147
00:10:37,288 --> 00:10:40,348
only model or the top model when we were considering a model for Halo.

148
00:10:41,406 --> 00:10:46,830
is that their protocols for how they communicate about the game over the network are all about

149
00:10:47,090 --> 00:10:49,071
semi-reliable data delivery.

150
00:10:50,172 --> 00:10:57,357
They're all about providing networked state that is not fully reliable so that you're

151
00:10:57,397 --> 00:10:58,458
not forced to resend.

152
00:11:00,720 --> 00:11:03,762
Specifically they support this idea of persistent state and transient events.

153
00:11:03,802 --> 00:11:05,943
We'll go into detail on what those are and what they're used for.

154
00:11:06,784 --> 00:11:11,087
And the result of all this, the result of having these semi-reliable guarantees.

155
00:11:11,835 --> 00:11:16,937
is that the whole thing is highly scalable to match available bandwidth. We never have

156
00:11:16,997 --> 00:11:22,058
to build up a huge latency debt because we flooded the connection with too much data.

157
00:11:25,200 --> 00:11:31,022
All right. Before I can tell you about how our system works, I have to define three key

158
00:11:31,042 --> 00:11:35,703
terms. Gameplay networking terms, unfortunately, are not that standardized. So let's get our

159
00:11:35,723 --> 00:11:39,405
terms straight right up front. First, replication.

160
00:11:40,384 --> 00:11:42,065
Replication is a term that we use at Bungie.

161
00:11:42,125 --> 00:11:44,986
I haven't heard it used elsewhere, but it might very well be.

162
00:11:45,006 --> 00:11:50,487
It specifically is the idea of taking some state that exists on one box and then transmitting

163
00:11:50,567 --> 00:11:54,008
sufficient information over the network so that it can be replicated on the other box.

164
00:11:54,929 --> 00:11:57,289
The analogy to think of is like a Star Trek replicator.

165
00:11:58,130 --> 00:12:03,351
You take a description of a cup of hot earl gray tea and you encode it in the replicator

166
00:12:03,391 --> 00:12:06,052
and the replicator can create a copy of it that appears to match.

167
00:12:06,477 --> 00:12:08,799
Basically, that's what we mean when we use the word replication.

168
00:12:09,019 --> 00:12:12,221
We are going to give you a description of the object or what's happening with the object,

169
00:12:12,582 --> 00:12:14,583
and then it's going to appear and look to you to be real.

170
00:12:17,505 --> 00:12:18,926
Second term, authority.

171
00:12:21,668 --> 00:12:22,629
This is fairly intuitive.

172
00:12:23,950 --> 00:12:27,052
This is the idea of who's the host, who has the authority over objects.

173
00:12:27,392 --> 00:12:30,575
For almost all objects, for almost all things, because we're a host-client game and because

174
00:12:30,595 --> 00:12:34,017
we're very sensitive to cheating and to attack surfaces for cheating.

175
00:12:34,482 --> 00:12:36,683
The host has almost all the authority in our game.

176
00:12:36,723 --> 00:12:42,805
He has authority over object health, damage events, projectile positions, things like

177
00:12:42,845 --> 00:12:42,985
that.

178
00:12:43,506 --> 00:12:47,167
Clients can exert some limited authority over their own bipeds, and we'll talk about that

179
00:12:47,227 --> 00:12:47,507
as well.

180
00:12:49,848 --> 00:12:52,529
Thirdly, prediction.

181
00:12:54,370 --> 00:12:58,331
Prediction is what you do in between receiving updates about an object.

182
00:12:58,932 --> 00:13:02,933
In this little animation I've got here, if you assume that this moving circle is an object

183
00:13:03,253 --> 00:13:03,793
and this is a...

184
00:13:04,363 --> 00:13:09,886
simulation occurring on a client machine, and the green stars are updates coming in

185
00:13:09,926 --> 00:13:13,888
from the host about where this object really is and what direction it's really moving.

186
00:13:14,628 --> 00:13:18,770
All the movement of the object in between the green stars and afterwards and predictably

187
00:13:18,810 --> 00:13:22,451
bouncing off walls and things like that, that's all prediction.

188
00:13:22,491 --> 00:13:26,153
That's all us applying rules and guesses about what we think is going to happen with the

189
00:13:26,233 --> 00:13:26,533
object.

190
00:13:26,553 --> 00:13:28,954
I'm going to throw this word around a little bit.

191
00:13:30,855 --> 00:13:31,095
Okay.

192
00:13:32,015 --> 00:13:32,836
That was pretty painless.

193
00:13:32,896 --> 00:13:33,716
Now we're that much closer.

194
00:13:34,213 --> 00:13:36,934
to looking at how we network beautiful things like this.

195
00:13:43,775 --> 00:13:44,655
Networking stack.

196
00:13:44,675 --> 00:13:47,916
If there's any old school network programmers in the room, you're probably expecting this

197
00:13:47,936 --> 00:13:48,716
to come up a little sooner.

198
00:13:49,496 --> 00:13:51,817
But it doesn't look much like the OSI networking stack.

199
00:13:53,277 --> 00:13:53,897
Let's run through it.

200
00:13:53,917 --> 00:13:56,538
At the very highest level, we have the game code.

201
00:13:56,718 --> 00:13:58,998
Everything everyone else works on who's not on the networking team.

202
00:13:59,618 --> 00:14:00,418
It simply runs the game.

203
00:14:02,297 --> 00:14:04,839
The next level below the game we call the game interface.

204
00:14:05,479 --> 00:14:09,542
The game interface is responsible for scraping the game, for extracting all the data from

205
00:14:09,562 --> 00:14:12,324
the game that we might potentially want to replicate.

206
00:14:12,344 --> 00:14:20,951
The prioritization layer then takes all that data that game interface has gathered and

207
00:14:20,991 --> 00:14:23,192
decides what stuff is most important to send.

208
00:14:25,995 --> 00:14:28,596
Once the prioritization layer has selected what to send...

209
00:14:29,300 --> 00:14:33,241
We hand it off to the replication layer, which implements essentially the tribe's protocols.

210
00:14:33,641 --> 00:14:35,262
Again, we're going to look at all this in more detail.

211
00:14:38,263 --> 00:14:40,344
Below that, we have things we're not going to look at in detail.

212
00:14:40,364 --> 00:14:44,665
The channel manager, which has flow and congestion control to keep us from flooding players'

213
00:14:44,685 --> 00:14:45,066
connections.

214
00:14:45,686 --> 00:14:48,207
And the transport layer, which looks like everybody else's transport layer.

215
00:14:48,227 --> 00:14:49,467
It's just a cross-platform socket layer.

216
00:14:52,088 --> 00:14:52,328
Okay.

217
00:14:52,928 --> 00:14:57,830
In this talk, we're going to cover these three layers specifically in pretty good depth.

218
00:14:58,943 --> 00:15:00,444
We're not going to talk about anything below or above.

219
00:15:03,666 --> 00:15:07,988
OK, some meat, some actual real algorithms instead of just overviews.

220
00:15:08,389 --> 00:15:09,029
State data.

221
00:15:09,609 --> 00:15:13,191
This is the first tribes protocol and the one that accounts for the vast majority of

222
00:15:13,251 --> 00:15:13,792
our bandwidth.

223
00:15:14,832 --> 00:15:17,974
State data provides this very specific guarantee.

224
00:15:19,435 --> 00:15:23,698
Eventually, the most current state will arrive.

225
00:15:25,259 --> 00:15:27,840
Sounds simple, but it's incredibly powerful.

226
00:15:28,865 --> 00:15:29,446
What does this mean?

227
00:15:30,106 --> 00:15:34,048
Let's say I was the host and my position on this stage was being replicated out to all

228
00:15:34,068 --> 00:15:34,868
of you as clients.

229
00:15:35,748 --> 00:15:38,730
Let's say further that this position is being replicated as state data.

230
00:15:39,890 --> 00:15:43,592
If I start in this position and you all know that I'm here, we start from time zero, everything's

231
00:15:43,632 --> 00:15:47,474
in sync, and then I walk across the stage, then I stop.

232
00:15:48,994 --> 00:15:52,656
State data guarantees that if I stand here for long enough and the connection is not

233
00:15:52,696 --> 00:15:56,278
dropped, you will all eventually see me appear at this location.

234
00:15:57,151 --> 00:16:02,295
does not guarantee any of the intermediate locations that will be sent. All the intermediate

235
00:16:02,315 --> 00:16:07,979
information can be dropped based on available bandwidth. So this is used for all the vast

236
00:16:08,019 --> 00:16:11,942
majority of properties in our game, objects, positions, health, timers, tons and tons of

237
00:16:11,962 --> 00:16:17,366
properties. The second replication protocol is called

238
00:16:17,486 --> 00:16:24,772
events. Events are all about justifying state data

239
00:16:24,812 --> 00:16:26,933
transitions with richer data.

240
00:16:28,680 --> 00:16:32,582
Events have much, much better screenshots than state data, as you can see, because events

241
00:16:32,622 --> 00:16:37,304
are all about telling you about why something happened, why someone's health died or dropped,

242
00:16:37,364 --> 00:16:41,747
why someone died, why a warthog has just lost a wheel, all these sorts of things.

243
00:16:43,408 --> 00:16:48,351
The event reliability guarantee is nonexistent.

244
00:16:49,011 --> 00:16:53,854
Unlike state data, which guarantees the eventual delivery of the most up-to-date state, events

245
00:16:54,194 --> 00:16:55,374
have no guarantees whatsoever.

246
00:16:55,494 --> 00:16:57,055
Every event could potentially be dropped.

247
00:16:59,957 --> 00:17:04,199
This is important because events are describing transitions.

248
00:17:06,021 --> 00:17:10,164
If you are not in a location where you can currently see the transition occurring, like

249
00:17:10,204 --> 00:17:14,727
if you are, for example, outside this room, you don't care about transitions that are

250
00:17:14,767 --> 00:17:15,527
occurring within this room.

251
00:17:15,547 --> 00:17:17,028
You only care about the final state.

252
00:17:17,068 --> 00:17:19,230
So if you were to enter the room, you would see the updated state.

253
00:17:22,732 --> 00:17:24,633
Last replication protocol, control data.

254
00:17:25,619 --> 00:17:30,002
Control data is all about improving the accuracy of our prediction systems.

255
00:17:31,443 --> 00:17:37,547
For control data, we take a subsample of the player's controller inputs and a few other

256
00:17:37,627 --> 00:17:42,230
useful things, and we transmit that sort of as frequently as we can from the client to

257
00:17:42,250 --> 00:17:44,111
the host and reflect it back out to all clients.

258
00:17:45,172 --> 00:17:49,475
What this lets us do is it lets us infer changes in the game or predict changes in the game

259
00:17:50,456 --> 00:17:52,617
far in advance of when they would actually change the game.

260
00:17:52,897 --> 00:17:54,838
For example, if I'm running forward...

261
00:17:55,448 --> 00:17:58,429
And then I push the left stick to start strafing left.

262
00:17:59,389 --> 00:18:03,550
You won't actually see a change in my object for several frames plus acceleration time

263
00:18:03,630 --> 00:18:06,251
plus however long until it actually moves more than one pixel, you know, whatever.

264
00:18:06,271 --> 00:18:07,731
A significant amount of time.

265
00:18:08,491 --> 00:18:11,932
Control data allows us to transmit the fact that I'm pushing my stick left

266
00:18:13,113 --> 00:18:15,553
so that everyone else can start to predict that I'm going to begin to strafe

267
00:18:15,573 --> 00:18:17,534
to improve the accuracy of their prediction.

268
00:18:18,634 --> 00:18:20,214
This is a very, very tiny amount of data.

269
00:18:20,515 --> 00:18:22,855
Control data for one player is something like 20 bits.

270
00:18:25,002 --> 00:18:27,643
very, very carefully hand-packed data because it's sent so often.

271
00:18:30,164 --> 00:18:34,425
Okay. Let's look at the big picture, putting together all these protocols in one. We have

272
00:18:34,445 --> 00:18:40,648
a host box and a client box, as all good networking diagrams should. Firstly, the client sends

273
00:18:40,688 --> 00:18:46,109
control data to the host. This includes both his stick inputs and the current information

274
00:18:46,129 --> 00:18:49,651
about where he thinks he is in the world, like my biped is currently in a certain location.

275
00:18:49,931 --> 00:18:52,332
This is how the client exerts most of his agency in the world.

276
00:18:54,831 --> 00:18:56,992
Second, clients will transmit events to the host.

277
00:18:57,312 --> 00:19:00,574
These are transient things the client can do that he needs the host's permission to

278
00:19:00,614 --> 00:19:02,635
do or that he needs the host to execute.

279
00:19:02,675 --> 00:19:05,617
He needs the host to actually change the world in response to these things he's trying to

280
00:19:05,657 --> 00:19:05,797
do.

281
00:19:09,379 --> 00:19:12,081
From host to client, this picture is a little bit bigger.

282
00:19:12,801 --> 00:19:16,383
We have control data, which is stripped down to just the minimum at this point, just the

283
00:19:16,423 --> 00:19:18,584
controller inputs that are useful for prediction.

284
00:19:20,565 --> 00:19:21,546
We have state data.

285
00:19:21,566 --> 00:19:23,267
This is the vast majority of all our bandwidth.

286
00:19:23,985 --> 00:19:28,347
This is transmitting all of the final states, all the current states of everything that

287
00:19:28,607 --> 00:19:29,967
is important over time.

288
00:19:31,168 --> 00:19:34,350
And we have events, which are just like what the client sends to the host.

289
00:19:34,410 --> 00:19:37,651
They are justifications for the state data transitions that occurred.

290
00:19:38,732 --> 00:19:39,632
So let's take an example.

291
00:19:40,452 --> 00:19:43,294
Right here we have in state data, the warthog now has a broken windshield.

292
00:19:43,874 --> 00:19:45,395
That's a piece of state data that's transmitted.

293
00:19:45,435 --> 00:19:46,795
Windshield state is now broken.

294
00:19:47,536 --> 00:19:51,117
If that was the only thing we transmitted and we didn't transmit, this warthog just

295
00:19:51,137 --> 00:19:52,198
took damage at this point.

296
00:19:54,410 --> 00:19:55,631
You would just see the windshield permute.

297
00:19:56,732 --> 00:19:59,534
Maybe there would be some fake effects to cover it up, but we wouldn't really know why

298
00:19:59,554 --> 00:20:00,395
the windshield got broken.

299
00:20:01,215 --> 00:20:05,699
If you have the event, you see beautiful sparks, you see all the appropriate transitions, you

300
00:20:05,739 --> 00:20:10,883
have special sound effects, you know, all the beautiful flavor material that describes

301
00:20:11,003 --> 00:20:13,044
why the state data transition took place.

302
00:20:14,805 --> 00:20:15,066
Okay.

303
00:20:17,327 --> 00:20:18,928
Again, I've beat this drum several times now.

304
00:20:18,948 --> 00:20:20,350
You're going to hear me beat it several more times.

305
00:20:20,830 --> 00:20:22,971
Replication is never fully reliable.

306
00:20:24,629 --> 00:20:30,313
Unreliability enables aggressive prioritization, which lets us deal with the fact that we don't

307
00:20:30,333 --> 00:20:34,335
really have an object cap, which lets us deal with the fact that we have 200 synchronized

308
00:20:34,475 --> 00:20:36,276
objects or more in a 16-player game.

309
00:20:36,296 --> 00:20:37,477
I mean, it peaks at well over 2,000.

310
00:20:37,877 --> 00:20:42,140
So what can we do with prioritization?

311
00:20:42,880 --> 00:20:49,844
We can give the power to our flow control layer, to the guy who is looking at the current

312
00:20:49,904 --> 00:20:50,805
connection status.

313
00:20:51,383 --> 00:20:57,348
and figuring out whether it's safe to currently send data without causing packet loss or a

314
00:20:57,388 --> 00:20:58,068
latency spike.

315
00:21:00,790 --> 00:21:03,272
We can give this flow control layer that full authority.

316
00:21:03,532 --> 00:21:05,254
He decides when to send a packet.

317
00:21:05,434 --> 00:21:07,736
He decides when it's safe and how big it should be.

318
00:21:08,736 --> 00:21:12,819
When he decides to send a packet, he talks to the replication layer and says, hey, we're

319
00:21:12,839 --> 00:21:13,560
sending a packet now.

320
00:21:13,600 --> 00:21:14,961
What would you like to write?

321
00:21:15,621 --> 00:21:18,263
Replication fills up the packet, however big it is.

322
00:21:19,031 --> 00:21:20,932
Obviously we don't have room to fit all our data.

323
00:21:20,992 --> 00:21:21,433
We never do.

324
00:21:21,493 --> 00:21:23,494
We don't really have 20 megabit connections.

325
00:21:23,534 --> 00:21:26,856
And even if we did, we wouldn't have the perf to actually encode it all into a packet.

326
00:21:27,677 --> 00:21:29,778
So we write high-priority data first, of course.

327
00:21:30,138 --> 00:21:31,819
We write data in priority order.

328
00:21:33,761 --> 00:21:34,001
All right.

329
00:21:34,941 --> 00:21:38,724
We've sold our souls in terms of complexity to get this wonderful prioritization system.

330
00:21:38,784 --> 00:21:41,145
So let's take a quick look at what its capabilities are.

331
00:21:41,986 --> 00:21:43,447
It's sort of what you would expect.

332
00:21:43,707 --> 00:21:46,949
It's similar to the problem of culling, of like figuring out what stuff is important

333
00:21:46,969 --> 00:21:47,349
to render.

334
00:21:47,389 --> 00:21:48,830
It's a softer problem.

335
00:21:50,156 --> 00:21:53,878
But basically we're looking at, hey, what stuff is close to this client?

336
00:21:54,639 --> 00:21:55,679
What stuff is he looking at?

337
00:21:55,859 --> 00:21:57,060
What stuff could hurt him?

338
00:21:57,500 --> 00:21:59,862
What stuff has he recently damaged?

339
00:21:59,882 --> 00:22:02,403
Because that's a pretty strong indicator of interest.

340
00:22:03,704 --> 00:22:09,387
There's some really unintuitive stuff you get in here, which we have evolved over time.

341
00:22:10,428 --> 00:22:15,591
Things like, oh, grenades, as they fly through the air, are prioritized based on how likely

342
00:22:15,611 --> 00:22:17,292
they are to damage a particular player.

343
00:22:18,303 --> 00:22:19,364
That seemed reasonable to us.

344
00:22:19,404 --> 00:22:20,804
If it's not going to damage you, why do you care?

345
00:22:22,065 --> 00:22:28,568
But we discovered significant lag artifacts on the player's own grenades, because players

346
00:22:28,708 --> 00:22:32,849
watch their own grenades like hawks, even though they are completely irrelevant to them

347
00:22:32,869 --> 00:22:33,509
after they've thrown them.

348
00:22:33,529 --> 00:22:34,710
They can't affect them in any way.

349
00:22:34,770 --> 00:22:35,330
Well, that's not true.

350
00:22:36,191 --> 00:22:37,771
In general, they can't affect them in any way.

351
00:22:39,112 --> 00:22:40,312
You can shoot grenades out of the air.

352
00:22:40,892 --> 00:22:41,933
Crazy sandbox designers.

353
00:22:45,250 --> 00:22:49,231
There's tons and tons of these special cases that we have sort of built up over the years

354
00:22:50,651 --> 00:22:53,712
in response to player feedback to give the best behavior that we can.

355
00:22:54,672 --> 00:22:55,913
Let's look at a quick example of this.

356
00:22:56,493 --> 00:22:59,173
This is a screenshot just taken from a Halo Reach game.

357
00:23:00,034 --> 00:23:03,815
This player here in the lower left has just killed the player who is now ragdolling and

358
00:23:03,835 --> 00:23:04,895
falling to the ground below him.

359
00:23:07,196 --> 00:23:12,297
Let's take a look at the network prioritization of data about these objects to the guy who's

360
00:23:12,317 --> 00:23:12,817
still alive.

361
00:23:13,299 --> 00:23:15,940
So everything we're going to see is about sending data to the guy who's still alive.

362
00:23:17,420 --> 00:23:20,201
Firstly we have a prioritization overlay, which I'm sure most of you cannot read.

363
00:23:20,221 --> 00:23:20,681
Don't worry.

364
00:23:21,682 --> 00:23:25,043
This is our in-game debugger that sort of shows all of our prioritization decisions

365
00:23:25,163 --> 00:23:25,703
as they occur.

366
00:23:29,144 --> 00:23:29,744
Some examples.

367
00:23:30,664 --> 00:23:31,525
The dead body.

368
00:23:31,585 --> 00:23:32,845
So first off, the legend.

369
00:23:33,425 --> 00:23:34,946
There's three numbers here for each object.

370
00:23:35,066 --> 00:23:36,746
First is the final priority.

371
00:23:36,786 --> 00:23:39,927
This is the final, like, literally if this number is higher, you get to go in the packet

372
00:23:39,987 --> 00:23:40,287
first.

373
00:23:41,028 --> 00:23:41,888
Second, relevance.

374
00:23:42,452 --> 00:23:45,934
Relevance is sort of a pure measure of how noticeable something is without regard to

375
00:23:45,974 --> 00:23:46,994
its importance to the game.

376
00:23:48,855 --> 00:23:49,976
Third, update priority.

377
00:23:50,036 --> 00:23:54,398
This is in milliseconds and this tells us, hey, how often should we try to send updates

378
00:23:54,418 --> 00:23:55,059
about this object?

379
00:23:55,199 --> 00:23:58,801
So zero means we're sending updates as fast as we can about this dead body.

380
00:23:58,981 --> 00:24:01,422
Every single packet gets an opportunity to send something.

381
00:24:02,743 --> 00:24:08,066
The 1.0 relevance is basically maxed out, and that's because we know that players watch

382
00:24:08,386 --> 00:24:10,647
ragdolls fall for a few seconds after they kill people.

383
00:24:10,668 --> 00:24:11,128
They're proud.

384
00:24:13,946 --> 00:24:17,968
.5 is a fairly high total priority. There's tons and tons of range that has to be encapsulated

385
00:24:17,988 --> 00:24:23,491
into the priority range due to things like stacked bonuses. So .5 is actually a fairly

386
00:24:23,531 --> 00:24:28,953
high priority in this scenario. Conversely, we can look at this gun here. This

387
00:24:29,113 --> 00:24:35,336
strange pink thing is a covenant needle rifle. The update period for this is 127 milliseconds.

388
00:24:36,557 --> 00:24:38,958
So we're trying to send updates about eight times a second about this gun.

389
00:24:39,641 --> 00:24:44,442
Its relevance is almost as high, 0.97, because it's quite obvious, it's in the player's face,

390
00:24:44,462 --> 00:24:46,222
it's very, very close to his screen, it's on screen.

391
00:24:47,022 --> 00:24:51,943
But the priority is much, much lower than it was for the biped, 0.22.

392
00:24:53,424 --> 00:24:58,185
That's because priority mixes in all the information that we have gleaned about what is actually

393
00:24:58,225 --> 00:25:00,725
important to the player over and above what is noticeable.

394
00:25:02,045 --> 00:25:04,626
Guns when they're falling, generally not that important to players.

395
00:25:05,583 --> 00:25:08,726
They might go pick them up, but in general, they're watching the body, they're watching

396
00:25:08,746 --> 00:25:10,187
projectiles in flight, they're not watching the gun.

397
00:25:11,588 --> 00:25:15,651
Even lower priority example, this is a grenade, same shot, same exact moment in time, dead

398
00:25:15,671 --> 00:25:16,432
body in the background there.

399
00:25:17,012 --> 00:25:22,857
This is a grenade, inactive grenade that was dropped by the guy when he died, sitting in

400
00:25:22,897 --> 00:25:24,759
the water behind the shooter.

401
00:25:24,819 --> 00:25:26,000
This grenade is off screen.

402
00:25:28,241 --> 00:25:31,484
We're trying to send updates about this grenade about three times a second here, this 339,

403
00:25:31,584 --> 00:25:32,225
about three times a second.

404
00:25:34,825 --> 00:25:40,227
Relevance 0.73 still seems fairly high, from a zero to one range.

405
00:25:42,008 --> 00:25:47,230
0.73 is not actually that high because the relevance range has to encapsulate everything

406
00:25:47,290 --> 00:25:53,372
from objects that are near to you to unthreatening, noncritical, on-your-team objects that are

407
00:25:53,392 --> 00:25:54,873
across an enormous map.

408
00:25:56,133 --> 00:25:59,554
So that's why you see like a 0.73 here instead of a 0.0, just because it's an off-screen

409
00:25:59,574 --> 00:25:59,874
grenade.

410
00:26:00,935 --> 00:26:02,415
And the end result priority is quite low.

411
00:26:02,960 --> 00:26:06,682
So this grenade is going to get updated maybe three times a second if we have bandwidth,

412
00:26:06,722 --> 00:26:07,603
certainly not more than that.

413
00:26:11,005 --> 00:26:11,265
All right.

414
00:26:13,826 --> 00:26:15,147
That's the core of our architecture.

415
00:26:16,688 --> 00:26:22,391
This idea of using unreliable protocols to enable prioritization to give us unlimited

416
00:26:22,591 --> 00:26:26,173
scalability is the core of Bungie's approach to Halo.

417
00:26:29,935 --> 00:26:31,296
Unfortunately, our job is not over.

418
00:26:31,436 --> 00:26:32,217
We have to actually...

419
00:26:33,072 --> 00:26:38,696
design the individual pieces of gameplay networking. And this is actually quite difficult. Let's

420
00:26:38,716 --> 00:26:55,847
look at some examples. Firstly, throwing a grenade. Not that exciting. Pretty similar

421
00:26:55,888 --> 00:26:59,770
to a lot of other first-person shooters. What happens when we throw a grenade? Well,

422
00:27:00,960 --> 00:27:05,162
This is a sequence diagram, which is a tool we use quite a bit when we're analyzing how

423
00:27:05,182 --> 00:27:06,703
we're going to network a gameplay mechanic.

424
00:27:06,723 --> 00:27:08,364
Let's take a look at it.

425
00:27:08,605 --> 00:27:13,227
In terms of a single box, if we were throwing a grenade, what does it look like?

426
00:27:13,327 --> 00:27:16,930
Well, from the controller, the player presses the left trigger, very simple.

427
00:27:17,550 --> 00:27:20,852
That gets consumed by the simulation loop at some point fairly quickly.

428
00:27:21,653 --> 00:27:23,414
And then a grenade throw animation begins.

429
00:27:24,374 --> 00:27:28,677
There is some lead-up telegraph animation while the player winds up and throws.

430
00:27:29,397 --> 00:27:33,678
And then at a key release frame, somewhere around here with his hand, the grenade is

431
00:27:33,738 --> 00:27:38,579
detached, aimed at a target using the player's current facing directions and other code,

432
00:27:39,320 --> 00:27:39,860
and then launched.

433
00:27:41,120 --> 00:27:43,441
Exactly how you would think a grenade throw would work.

434
00:27:43,481 --> 00:27:44,101
It's beautiful.

435
00:27:44,121 --> 00:27:45,261
This is how it's worked since Halo 1.

436
00:27:48,022 --> 00:27:49,622
How can we network this grenade throw?

437
00:27:49,662 --> 00:27:52,123
There's actually a surprisingly wide variety of options.

438
00:27:55,176 --> 00:27:56,096
Let's try something simple.

439
00:27:56,416 --> 00:28:00,897
Now, we know, we've talked to design, we've played Halo, so we know, we played the prototype

440
00:28:00,917 --> 00:28:04,678
at that time for Halo, so we know grenades are very important to the game.

441
00:28:05,278 --> 00:28:07,158
We know we want them to be host adjudicated.

442
00:28:07,398 --> 00:28:08,659
We want them to be authoritative.

443
00:28:09,979 --> 00:28:11,619
We don't want to allow players to cheat with grenades.

444
00:28:13,159 --> 00:28:15,320
So let's try this sort of permission slip approach.

445
00:28:15,780 --> 00:28:17,980
We send a grenade throw request to the host.

446
00:28:19,141 --> 00:28:23,541
Once he confirms that we are allowed to throw a grenade, we do our whole animation and throw

447
00:28:23,561 --> 00:28:23,862
a grenade.

448
00:28:25,732 --> 00:28:27,153
Will this be a good networking approach?

449
00:28:28,253 --> 00:28:28,553
It won't.

450
00:28:28,713 --> 00:28:30,793
But how do we know that for sure?

451
00:28:31,554 --> 00:28:35,315
One of the most useful analysis tools is to use these sequence diagrams but with two boxes

452
00:28:35,735 --> 00:28:39,056
instead of looking at the controller with a single machine picture.

453
00:28:41,996 --> 00:28:42,196
Okay.

454
00:28:42,596 --> 00:28:46,177
First thing that happens, the client pushes a button and sends a message to the host.

455
00:28:46,357 --> 00:28:47,658
I would like to throw a grenade now.

456
00:28:48,738 --> 00:28:54,419
Very first thing you'll notice, this arrow is tilted unlike all sequence diagram standards.

457
00:28:54,499 --> 00:28:55,400
Why on earth is it tilted?

458
00:28:55,730 --> 00:28:57,991
It's because we are dealing with a distributed state machine.

459
00:28:58,331 --> 00:29:03,633
This period is the one-way network latency from the client to the host.

460
00:29:03,913 --> 00:29:08,035
These tilts of these arrows are the key that makes this sequence diagram tool so useful

461
00:29:08,075 --> 00:29:12,197
to us because you can see all the potential overlaps of all the pieces of your mechanic,

462
00:29:12,778 --> 00:29:15,159
all the different ways it could be networked, all the vulnerabilities.

463
00:29:16,279 --> 00:29:16,499
Okay.

464
00:29:16,539 --> 00:29:17,040
So what happens?

465
00:29:17,480 --> 00:29:17,980
Pretty simple.

466
00:29:18,340 --> 00:29:19,381
The host gets the request.

467
00:29:19,421 --> 00:29:20,801
He says, okay, you can throw a grenade.

468
00:29:20,821 --> 00:29:21,522
That sounds fine.

469
00:29:22,642 --> 00:29:23,563
Starts your throw animation.

470
00:29:23,623 --> 00:29:25,343
When he reaches your release frame, he throws a grenade.

471
00:29:27,745 --> 00:29:30,206
So that you're happy, he sends back a, yeah, that's cool.

472
00:29:30,226 --> 00:29:31,167
You're starting your grenade throw.

473
00:29:31,187 --> 00:29:32,467
Go ahead and start your throw animation.

474
00:29:33,948 --> 00:29:34,969
You start your throw animation.

475
00:29:35,469 --> 00:29:37,770
You play your delay for a certain period of time.

476
00:29:39,511 --> 00:29:40,612
You reach your release frame.

477
00:29:41,272 --> 00:29:43,093
About the same time you reach your release frame, you'll get

478
00:29:43,133 --> 00:29:44,334
a message from the host that, hey, this

479
00:29:44,394 --> 00:29:45,594
grenade totally exists.

480
00:29:46,355 --> 00:29:46,995
Everything's cool.

481
00:29:49,496 --> 00:29:50,217
We have a problem here.

482
00:29:51,538 --> 00:29:53,959
We are waiting our round trip time before we're giving the

483
00:29:54,039 --> 00:29:56,580
client any feedback on his button press.

484
00:29:58,403 --> 00:29:59,584
Players hate this.

485
00:30:02,385 --> 00:30:03,846
Players hate it with a passion.

486
00:30:05,667 --> 00:30:07,588
This is totally and completely unacceptable,

487
00:30:07,808 --> 00:30:08,868
so we have to find a better way.

488
00:30:10,469 --> 00:30:11,770
Okay, let's try something new,

489
00:30:11,830 --> 00:30:12,870
something a little more direct,

490
00:30:12,890 --> 00:30:14,671
a little bit less asking for permission.

491
00:30:15,612 --> 00:30:16,952
We'll just throw a grenade locally.

492
00:30:17,112 --> 00:30:18,993
We'll just let the player, like, he hits the button,

493
00:30:19,073 --> 00:30:20,674
he runs his animation, he throws a grenade,

494
00:30:21,074 --> 00:30:22,595
and we'll ask the host to also throw a grenade

495
00:30:22,615 --> 00:30:24,056
so that everybody else in the game can tell

496
00:30:24,096 --> 00:30:25,416
that we have a grenade in flight.

497
00:30:26,277 --> 00:30:26,957
What does this look like?

498
00:30:27,938 --> 00:30:28,638
Sequence diagram.

499
00:30:29,499 --> 00:30:30,039
Button press.

500
00:30:30,079 --> 00:30:31,459
We start our throw animation immediately.

501
00:30:31,480 --> 00:30:32,520
It's nice and responsive.

502
00:30:32,540 --> 00:30:33,801
Everybody's happy and playtests.

503
00:30:33,921 --> 00:30:34,421
It's so good.

504
00:30:35,121 --> 00:30:36,602
Tell the host I've begun a grenade throw.

505
00:30:38,563 --> 00:30:40,124
Host does the same thing as he did before.

506
00:30:40,964 --> 00:30:41,944
Triggers his throw animation.

507
00:30:43,405 --> 00:30:44,566
On the release frame, he throws a grenade.

508
00:30:46,727 --> 00:30:47,367
Where's the lag?

509
00:30:50,228 --> 00:30:51,789
Where are we hiding?

510
00:30:54,631 --> 00:30:58,113
the fact that the host is adjudicating the grenade throw, or is adjudicating the fact

511
00:30:58,153 --> 00:31:01,094
that in the end, the grenade's damage will be owned by the host.

512
00:31:03,375 --> 00:31:06,056
The answer is, there isn't any lag in this scenario.

513
00:31:06,116 --> 00:31:08,718
We have not hidden the lag anywhere in this diagram.

514
00:31:08,738 --> 00:31:13,080
We have never asked the host for permission, which means, does not mean that we've succeeded.

515
00:31:14,300 --> 00:31:15,261
You do not want this.

516
00:31:15,381 --> 00:31:17,002
You very much do not want this.

517
00:31:19,383 --> 00:31:21,484
This means you have incurred latency debt.

518
00:31:22,244 --> 00:31:23,085
You have created...

519
00:31:23,595 --> 00:31:29,517
an artifact, a dissimilarity, an asynchronicity in your simulation, which you will have to

520
00:31:29,597 --> 00:31:30,978
pay for in some way.

521
00:31:31,958 --> 00:31:36,500
Either you will have unhappy players due to inconsistent results in the game, or you will

522
00:31:36,560 --> 00:31:39,881
have some sort of warp later on, or you'll have additional code complexity to try to

523
00:31:39,921 --> 00:31:41,142
reconcile things in flight.

524
00:31:41,702 --> 00:31:43,482
You have to pay for this sort of thing somehow.

525
00:31:46,604 --> 00:31:46,864
Okay.

526
00:31:46,884 --> 00:31:49,005
So let's look at the actual way we do grenade throws.

527
00:31:51,908 --> 00:31:55,170
Just like in the second option, we predict the throw animation.

528
00:31:55,290 --> 00:31:59,653
So as soon as you push the trigger button on a client machine, you immediately begin

529
00:32:00,233 --> 00:32:00,753
your throw.

530
00:32:00,873 --> 00:32:02,695
There's no controller input latency.

531
00:32:03,575 --> 00:32:05,236
But we do not predict the grenade release.

532
00:32:05,436 --> 00:32:06,217
We wait for the host.

533
00:32:07,498 --> 00:32:09,339
This means that all grenades in flight will be real.

534
00:32:09,359 --> 00:32:10,259
The host is authoritative.

535
00:32:10,279 --> 00:32:11,740
We haven't incurred any lag debt.

536
00:32:14,382 --> 00:32:15,723
But where is the lag in this view?

537
00:32:16,743 --> 00:32:17,084
Somewhere.

538
00:32:17,104 --> 00:32:18,304
We're paying for a round-trip time.

539
00:32:18,384 --> 00:32:18,845
Let's take a look.

540
00:32:20,595 --> 00:32:25,038
Similar to before, client pushes a button, tells the host, host does it, so far so good.

541
00:32:26,618 --> 00:32:33,162
Oh, but at the moment when the client reaches his release frame, he does not throw the grenade,

542
00:32:33,182 --> 00:32:36,043
because as we said, the host must be authoritative over all grenades in flight.

543
00:32:36,544 --> 00:32:37,564
He deletes the grenade.

544
00:32:37,604 --> 00:32:41,846
So he gets to here and the grenade vanishes from his hand and he continues his animation.

545
00:32:43,107 --> 00:32:46,409
At the same time as he reached that release frame and deleted the grenade, he sends off

546
00:32:46,429 --> 00:32:47,249
a message to the host.

547
00:32:47,329 --> 00:32:49,230
Please create a grenade with this aiming information.

548
00:32:51,342 --> 00:32:55,903
Round-trip time later, the host comes back and says, yep, this grenade object got created.

549
00:32:56,763 --> 00:32:58,824
Here's its position and velocity, and the grenade appears.

550
00:33:02,265 --> 00:33:03,025
Where we put the lag.

551
00:33:04,246 --> 00:33:04,926
Fairly straightforward.

552
00:33:05,006 --> 00:33:05,446
It's right here.

553
00:33:06,827 --> 00:33:08,407
You can tell, you can see this pattern over and over.

554
00:33:08,467 --> 00:33:09,388
It's a call and response.

555
00:33:09,408 --> 00:33:11,868
It's a please do this thing, okay, here's the feedback from it.

556
00:33:12,148 --> 00:33:12,969
Clearly round-trip time.

557
00:33:14,629 --> 00:33:15,970
How is this better than the other way?

558
00:33:16,530 --> 00:33:19,731
Well, that's where networking becomes a bit more of an art than a science.

559
00:33:20,883 --> 00:33:24,526
This is much, much better than the original solution where we asked for permission before

560
00:33:24,566 --> 00:33:26,148
we triggered the animation for two reasons.

561
00:33:27,269 --> 00:33:30,551
One, players are extremely sensitive to input lag.

562
00:33:31,272 --> 00:33:34,414
They're extremely sensitive to anything, any button they can push on the controller that

563
00:33:34,434 --> 00:33:37,057
doesn't cause some reaction immediately in the game.

564
00:33:38,017 --> 00:33:40,940
So having that arm start moving immediately is infinitely preferable.

565
00:33:42,701 --> 00:33:49,366
Second, during the time of this lag, during the time between the normal release frame

566
00:33:49,867 --> 00:33:55,912
and the frame when the grenade actually appears, round-trip time later, there's a giant arm

567
00:33:56,652 --> 00:34:02,356
on the screen. It's covering like a third of the screen. It's moving really fast. It's

568
00:34:02,416 --> 00:34:06,919
got really high-res textures on it. It's got all my custom crap on it that I've bought

569
00:34:06,939 --> 00:34:12,784
with all my credits. It's really distracting. Not only that, I'm probably not looking at

570
00:34:12,844 --> 00:34:15,726
what's in my hand. I'm probably still looking down my crosshair just to make sure that I'm

571
00:34:15,786 --> 00:34:19,368
aiming my grenade correctly. Players don't notice.

572
00:34:20,705 --> 00:34:27,231
They literally don't see this. This can get up to 100, even 150 milliseconds. Casual players

573
00:34:27,251 --> 00:34:34,298
can get even to 200 before they notice anything. This is completely shippable. This is how

574
00:34:34,318 --> 00:34:36,120
we've shipped grenade throwers for three games now.

575
00:34:39,763 --> 00:34:44,027
Fortunately, having such beautiful grenade throw networking allows us to get results

576
00:34:44,107 --> 00:34:44,468
like this.

577
00:35:03,507 --> 00:35:08,028
Okay. That may have been a little, that grenade example may have been a little artificial.

578
00:35:08,068 --> 00:35:13,130
We never actually shipped any of those earlier sort of made up methods of networking grenades,

579
00:35:13,151 --> 00:35:16,932
the suboptimal methods. Let's look at some trickier gameplay examples. Let's look at

580
00:35:16,972 --> 00:35:21,634
some features that actually were in reach, that had multiple iterations of networking,

581
00:35:21,694 --> 00:35:25,335
some of which we shipped in our public beta, that were deeply flawed.

582
00:35:26,996 --> 00:35:30,978
Okay. First up, armor lock. Let's take a look at what armor lock is.

583
00:35:42,589 --> 00:35:44,370
Armor lock is an invincibility shield.

584
00:35:45,911 --> 00:35:46,751
Player pushes a button.

585
00:35:48,952 --> 00:35:53,835
There's an intro animation during which he drops into this locked pose.

586
00:35:56,256 --> 00:35:59,858
At the end of that intro animation, which is three frames long, incidentally, very important,

587
00:36:00,278 --> 00:36:04,861
three frames, he gets invulnerability and also infinite mass.

588
00:36:07,862 --> 00:36:10,864
He has that for some period of time and then he'll release the button or run out of energy

589
00:36:10,904 --> 00:36:11,764
and his shield will go away.

590
00:36:14,210 --> 00:36:15,050
Seems like a fun mechanic.

591
00:36:16,311 --> 00:36:17,151
How should we network this?

592
00:36:17,492 --> 00:36:18,552
First version we did.

593
00:36:19,533 --> 00:36:25,296
All the animations, the entry into an armor lock pose and the appearance of the blue shield

594
00:36:25,536 --> 00:36:30,219
and the infinite mass in the physics simulation, all were predicted by clients.

595
00:36:30,759 --> 00:36:34,882
So you locally, when you decided to use armor lock, would activate all the attributes of

596
00:36:34,962 --> 00:36:36,183
armor lock in your simulation.

597
00:36:37,063 --> 00:36:37,724
This felt great.

598
00:36:38,524 --> 00:36:42,727
This played great in our system link play tests, in our LAN play tests in the office.

599
00:36:43,670 --> 00:36:44,691
We had this in for a few months.

600
00:36:45,171 --> 00:36:48,292
And then we started doing take-homes where we load the game up into boxes and take it

601
00:36:48,332 --> 00:36:49,393
home and play together.

602
00:36:51,173 --> 00:36:52,474
And we discovered where the lag was.

603
00:36:54,295 --> 00:36:55,855
Let's look at Armour Lock V1.

604
00:36:56,535 --> 00:36:57,936
The client pushes a button.

605
00:36:58,016 --> 00:36:59,337
He begins his animation immediately.

606
00:36:59,397 --> 00:37:00,197
Everything is responsive.

607
00:37:00,217 --> 00:37:01,237
There's a three-frame delay here.

608
00:37:02,078 --> 00:37:04,058
Tells the host, hey, I've activated my Armour Lock.

609
00:37:05,039 --> 00:37:06,019
Host runs the intro.

610
00:37:08,680 --> 00:37:12,502
When the intro animation completes on the client, he gets invulnerability as depicted

611
00:37:12,522 --> 00:37:13,302
by this green box.

612
00:37:15,271 --> 00:37:17,432
When it completes on the host, he also gets invulnerability.

613
00:37:21,274 --> 00:37:22,394
On system link, this worked great.

614
00:37:25,035 --> 00:37:25,876
What's the vulnerability?

615
00:37:25,916 --> 00:37:26,576
Where's the lag?

616
00:37:26,936 --> 00:37:27,516
Well, it's right here.

617
00:37:30,538 --> 00:37:34,339
Grenade explodes on the host at this very, very special time.

618
00:37:36,500 --> 00:37:37,061
What does this do?

619
00:37:37,121 --> 00:37:39,342
Well, the host evaluates it and says, okay, grenade exploded.

620
00:37:39,942 --> 00:37:40,862
You're not invulnerable yet.

621
00:37:40,882 --> 00:37:43,263
You're still playing your intro animation.

622
00:37:45,936 --> 00:37:46,656
So I'm going to damage you.

623
00:37:46,996 --> 00:37:49,878
Hey, by the way, this grenade blew up, you just took damage.

624
00:37:52,999 --> 00:37:55,380
The client says, oh sure, that makes sense, I took damage.

625
00:37:55,460 --> 00:37:56,300
No, he does not.

626
00:37:56,381 --> 00:37:57,841
He says, what the hell?

627
00:38:00,802 --> 00:38:01,723
I was armor locked.

628
00:38:02,763 --> 00:38:03,684
I did the right thing.

629
00:38:03,744 --> 00:38:04,724
I saw the grenade coming.

630
00:38:04,764 --> 00:38:05,464
I pushed the button.

631
00:38:05,484 --> 00:38:06,265
I saw it flying through the air.

632
00:38:06,445 --> 00:38:06,905
Pushed the button.

633
00:38:06,925 --> 00:38:07,465
I was armor locked.

634
00:38:07,485 --> 00:38:08,806
I saw the beautiful blue shield.

635
00:38:09,326 --> 00:38:10,147
This is bullshit.

636
00:38:16,233 --> 00:38:16,873
So this was no good.

637
00:38:16,913 --> 00:38:17,934
We had very furious players.

638
00:38:19,674 --> 00:38:20,535
I just explained the lag.

639
00:38:20,555 --> 00:38:21,435
So version 2.

640
00:38:21,835 --> 00:38:22,536
Let's try it again.

641
00:38:23,196 --> 00:38:24,637
That version 1 never saw the light of day.

642
00:38:24,697 --> 00:38:25,717
No, that's too terrible.

643
00:38:25,737 --> 00:38:26,458
We would never ship that.

644
00:38:27,118 --> 00:38:27,598
Version 2.

645
00:38:27,738 --> 00:38:32,661
Let's have the animation be controlled by the client, sort of inspired by the grenade

646
00:38:32,681 --> 00:38:33,001
approach.

647
00:38:33,441 --> 00:38:36,062
We'll let the client immediately start his intro animation.

648
00:38:38,133 --> 00:38:42,176
But once he reaches the frame where he would normally enable the shield, he does not enable

649
00:38:42,196 --> 00:38:42,596
the shield.

650
00:38:42,676 --> 00:38:43,757
He stays unshielded.

651
00:38:43,797 --> 00:38:45,118
There's no beautiful blue shield.

652
00:38:45,238 --> 00:38:46,259
There's no infinite mass.

653
00:38:47,039 --> 00:38:49,521
He waits for the host to tell him that he's actually invincible.

654
00:38:51,322 --> 00:38:53,543
This is the method we shipped in our public beta.

655
00:38:55,945 --> 00:38:57,105
Where did we move the lag to here?

656
00:38:57,806 --> 00:38:59,427
Well, let's take a look at the sequence diagram.

657
00:39:00,548 --> 00:39:03,750
Client begins his animation on button press, yada, yada.

658
00:39:04,170 --> 00:39:04,790
Tell the host.

659
00:39:04,970 --> 00:39:05,831
Host runs the intro.

660
00:39:08,056 --> 00:39:11,078
Client finishes his inter-animation, does not turn on his shield, as we said.

661
00:39:12,419 --> 00:39:17,502
Host completes, turns on the real shield, and then he tells the client, hey, you're

662
00:39:17,582 --> 00:39:20,324
invulnerable now, you can turn on your blue shield and your infinite mass, everything's

663
00:39:20,384 --> 00:39:20,664
great.

664
00:39:22,785 --> 00:39:25,647
There's a really ominous hole there in that diagram.

665
00:39:27,028 --> 00:39:31,351
And indeed, same exact vulnerability, just a little less obvious.

666
00:39:32,291 --> 00:39:33,372
Grenade explodes here.

667
00:39:33,392 --> 00:39:36,654
Hey, by the way, you got damaged again, just like last time.

668
00:39:37,632 --> 00:39:42,274
The client did not have a blue shield, so he doesn't have any real strong reason to

669
00:39:42,314 --> 00:39:43,574
believe that he's invulnerable.

670
00:39:43,755 --> 00:39:46,296
So in some sense this is consistent networking.

671
00:39:46,316 --> 00:39:47,636
This is correct networking.

672
00:39:49,197 --> 00:39:51,698
Players unfortunately are not very understanding of this.

673
00:39:53,139 --> 00:39:55,900
And they say, why does my armor lock not work properly?

674
00:39:56,020 --> 00:39:57,881
Like this mechanic is broken.

675
00:40:01,483 --> 00:40:02,463
This shipped in our public beta.

676
00:40:02,483 --> 00:40:06,225
A million people played this and they told us loud and clear this was not acceptable.

677
00:40:07,821 --> 00:40:09,301
Well, actually, they told us loud and clear.

678
00:40:09,321 --> 00:40:11,862
And also, we data mined their use of equipment and discovered

679
00:40:11,882 --> 00:40:13,463
that Armor Lock was not as popular as the others.

680
00:40:14,523 --> 00:40:15,744
So we knew we had a problem.

681
00:40:15,764 --> 00:40:16,444
We needed to fix this.

682
00:40:18,465 --> 00:40:19,345
Lag shows up there.

683
00:40:19,365 --> 00:40:21,786
It's this wonderful period of sort of broken mechanics from

684
00:40:21,806 --> 00:40:22,646
the player's perspective.

685
00:40:24,927 --> 00:40:29,729
So we implemented a version 3 for ship with one last tweak,

686
00:40:30,129 --> 00:40:31,649
one very evil tweak.

687
00:40:33,730 --> 00:40:34,170
Let's take a look.

688
00:40:35,218 --> 00:40:36,039
Same thing as before.

689
00:40:36,279 --> 00:40:37,860
Client begins his animation.

690
00:40:37,921 --> 00:40:39,722
He does not turn on his shield when he finishes it.

691
00:40:42,064 --> 00:40:44,205
Tells the host standard stuff.

692
00:40:44,225 --> 00:40:45,046
Oh, this is different.

693
00:40:47,568 --> 00:40:48,368
What did we just do?

694
00:40:48,989 --> 00:40:53,052
We just said, instead of waiting for the three-frame delay

695
00:40:53,472 --> 00:40:56,475
to trigger invulnerability on the host,

696
00:40:56,875 --> 00:40:59,957
we shrink that three-frame delay by the measured round-trip

697
00:40:59,997 --> 00:41:02,359
time between the host and the using client.

698
00:41:05,435 --> 00:41:06,095
What does this mean?

699
00:41:06,516 --> 00:41:08,436
Well, it means this.

700
00:41:09,236 --> 00:41:12,597
We activate the shield on the host early, before the intro

701
00:41:12,617 --> 00:41:13,697
animation actually ends.

702
00:41:13,937 --> 00:41:16,738
So somewhere up here, the shield will activate instead

703
00:41:16,758 --> 00:41:17,758
of down here where it should.

704
00:41:19,439 --> 00:41:22,459
And then we tell the client, and lo and behold, it lines up

705
00:41:22,479 --> 00:41:24,980
with where he expects to see his armor lock activate.

706
00:41:25,580 --> 00:41:26,780
It's almost like we planned that.

707
00:41:27,160 --> 00:41:27,501
And we did.

708
00:41:27,561 --> 00:41:28,661
But it's obvious, right?

709
00:41:28,681 --> 00:41:31,722
By shrinking the frame delay by round trip time, we've

710
00:41:31,802 --> 00:41:32,422
paid for the lag.

711
00:41:34,747 --> 00:41:39,710
We have brought the host time stream up forward in time so that the client can see a consistent

712
00:41:39,750 --> 00:41:40,331
view of the world.

713
00:41:42,572 --> 00:41:44,013
And we haven't incurred latency debt.

714
00:41:44,613 --> 00:41:45,614
The world's consistent.

715
00:41:46,554 --> 00:41:48,656
There's not something out of sync that's waiting to bite us later.

716
00:41:49,556 --> 00:41:50,497
So what did we just do?

717
00:41:50,517 --> 00:41:52,378
We have grenades that can explode.

718
00:41:52,398 --> 00:41:53,138
Everything's fine.

719
00:41:53,158 --> 00:41:54,459
Everyone's always in sync.

720
00:41:54,999 --> 00:41:55,740
Everything works great.

721
00:41:56,901 --> 00:41:57,541
Players are happy.

722
00:41:59,802 --> 00:42:00,323
What do we do?

723
00:42:01,804 --> 00:42:03,585
This feels too good to be true.

724
00:42:05,358 --> 00:42:09,841
What we did was we broke the game mechanic in a very targeted way.

725
00:42:10,361 --> 00:42:14,343
We went in there and we grabbed the frame delay number that the designers had so carefully

726
00:42:14,383 --> 00:42:19,025
tweaked with so much love, and we slammed over it for networking.

727
00:42:19,265 --> 00:42:21,606
We actually changed the way the game played.

728
00:42:21,626 --> 00:42:23,307
We changed the real simulation.

729
00:42:24,808 --> 00:42:30,150
This is pretty much the only other way that we have yet found, that you can hide latency

730
00:42:30,250 --> 00:42:33,052
other than paying for a round-trip time or reconciling afterwards.

731
00:42:33,708 --> 00:42:43,554
You can change game mechanics. Fortunately, we got away with this. Because players, it

732
00:42:43,594 --> 00:42:50,038
was discovered once again, somewhat by luck, players do not care that someone else's armor

733
00:42:50,058 --> 00:42:54,921
lock activates a couple frames early. Sometimes they care, but rarely. They care tremendously

734
00:42:54,961 --> 00:42:59,103
that their armor lock activates on exactly the correct frame because they are very attuned

735
00:42:59,123 --> 00:42:59,703
to that timing.

736
00:43:02,953 --> 00:43:06,815
So we got away with it. We shifted the lag. By changing the game mechanic, we shifted

737
00:43:06,855 --> 00:43:11,158
the inconsistency from the player who cares a lot, who's using Armor Lock, to the host

738
00:43:11,218 --> 00:43:14,220
and all the other players in the game who don't care as much.

739
00:43:17,662 --> 00:43:19,423
This let us ship another wonderful feature.

740
00:43:40,276 --> 00:43:48,621
Double kill. Remember the infinite mass I mentioned? That's why they wanted that. Turns

741
00:43:48,661 --> 00:43:53,624
out when a rigid body hits something with infinite mass, you know, the infinite mass

742
00:43:53,644 --> 00:43:57,466
doesn't give. The rigid body has to give entirely. So we deal with more or less infinite damage.

743
00:43:59,308 --> 00:44:06,472
All right. Third example. Another reach mechanic that shipped with somewhat broken networking

744
00:44:06,492 --> 00:44:09,093
in the beta. Assassinations. Let's look at what these are.

745
00:44:14,292 --> 00:44:25,537
These were a signature multiplayer feature for us in Reach.

746
00:44:25,998 --> 00:44:31,600
We wanted to provide an exciting way to sort of take a, take a small risk and humiliate

747
00:44:31,620 --> 00:44:32,081
another player.

748
00:44:34,882 --> 00:44:38,124
So what does this mean in terms of what, sort of the high level of problem we're trying

749
00:44:38,144 --> 00:44:38,524
to solve?

750
00:44:39,284 --> 00:44:40,125
If two bipeds

751
00:44:40,490 --> 00:44:42,551
that are happily running along in their own simulations.

752
00:44:42,591 --> 00:44:45,272
They're both predicting their current positions,

753
00:44:45,692 --> 00:44:46,572
assuming they're both clients.

754
00:44:47,153 --> 00:44:49,253
They are somewhat ahead of what the host believes.

755
00:44:49,273 --> 00:44:51,274
They're ahead by one-way network time

756
00:44:51,314 --> 00:44:53,495
to the host of the host's current simulation.

757
00:44:54,795 --> 00:44:56,676
And then suddenly, out of the blue,

758
00:44:57,156 --> 00:44:58,677
we need to force these two bipeds

759
00:44:58,737 --> 00:45:01,538
to perform a joint, perfectly synchronized animation

760
00:45:01,818 --> 00:45:03,378
with very, very tiny error margins.

761
00:45:05,148 --> 00:45:09,009
The animators have carefully scripted this so that the knife slides exactly between the

762
00:45:09,049 --> 00:45:11,989
13th and 14th rib of the elite, whatever their anatomy is.

763
00:45:13,430 --> 00:45:15,130
They do not we can't fudge this.

764
00:45:15,250 --> 00:45:16,830
This has to be precisely accurate.

765
00:45:18,951 --> 00:45:21,591
This turned out to be something we had never really done before in multiplayer.

766
00:45:23,592 --> 00:45:26,793
So we implemented a system which we shipped in the public beta.

767
00:45:28,353 --> 00:45:30,914
Local prediction of participant positions and orientations.

768
00:45:30,954 --> 00:45:31,654
What do I mean by this?

769
00:45:32,114 --> 00:45:32,934
What this means is...

770
00:45:35,256 --> 00:45:40,139
When the assassination order comes down from the host, which says, these two players have

771
00:45:40,179 --> 00:45:47,383
just begun assassinating each other, each individual box is permitted to make that assassination

772
00:45:47,403 --> 00:45:53,046
occur in whatever location is most convenient, most pretty for them, based on their current

773
00:45:53,086 --> 00:45:54,867
beliefs about the positions of those two objects.

774
00:45:55,608 --> 00:45:59,210
So everyone runs the assassination in a slightly different spot, potentially with a slightly

775
00:45:59,250 --> 00:46:01,171
different animation so that it can fit in that spot.

776
00:46:02,705 --> 00:46:05,927
And we thought this would be great because it would minimize lag on the way into the

777
00:46:05,987 --> 00:46:06,447
animation.

778
00:46:06,607 --> 00:46:10,289
It would solve this problem we were very afraid of, which was all these bipeds are in their

779
00:46:10,309 --> 00:46:14,652
own little predictive futures, and we need to bring them back into the host's present.

780
00:46:14,672 --> 00:46:16,273
That seems like it's going to cause artifacts.

781
00:46:17,333 --> 00:46:18,854
So we did this, and it did work that way.

782
00:46:18,894 --> 00:46:22,196
Like, it definitely prevented lag on the way into assassinations.

783
00:46:23,657 --> 00:46:25,858
And it worked really well in our play tests and take-homes.

784
00:46:28,359 --> 00:46:31,121
Unfortunately, it totally failed in the public beta.

785
00:46:32,304 --> 00:46:37,032
Let's take a look at some of the bug videos from our wonderful bug database that came

786
00:46:37,052 --> 00:46:37,613
back from the beta.

787
00:47:03,410 --> 00:47:30,701
This one's my favorite. This black screen is what you see in a film when there's a host

788
00:47:30,741 --> 00:47:31,141
migration.

789
00:47:40,746 --> 00:47:42,067
Oh my god.

790
00:47:46,270 --> 00:47:49,153
It will surprise very few of the programmers in the audience

791
00:47:49,693 --> 00:47:51,034
to learn that that location

792
00:47:51,915 --> 00:47:53,576
that we got warped to after the host migration

793
00:47:54,417 --> 00:47:54,557
was 0, 0, 0.

794
00:48:03,024 --> 00:48:04,365
All right, so this wasn't very good.

795
00:48:04,385 --> 00:48:05,466
There were clearly a lot of problems.

796
00:48:05,506 --> 00:48:07,668
They fell broadly into two categories.

797
00:48:08,168 --> 00:48:08,388
First,

798
00:48:08,900 --> 00:48:12,522
The animations didn't always fit in the predicted positions on client machines.

799
00:48:13,103 --> 00:48:16,785
Clients would decide, okay, to minimize network lag, I'm going to run the assassination over

800
00:48:16,825 --> 00:48:17,566
here in this corner.

801
00:48:19,287 --> 00:48:22,870
But it turned out there sometimes was no assassination animation that would fit there.

802
00:48:23,430 --> 00:48:27,333
So they would try, and then the system would panic, and havoc would freak out because you

803
00:48:27,353 --> 00:48:30,795
were pushing people through walls, and then we would break apart the assassination, you

804
00:48:30,815 --> 00:48:31,676
get people pushing through walls.

805
00:48:31,696 --> 00:48:33,537
You see all the artifacts you saw in those bug videos.

806
00:48:36,680 --> 00:48:37,720
Any class of bug was.

807
00:48:38,232 --> 00:48:44,335
At the end of the animation, any survivors need to get back in sync on all boxes.

808
00:48:44,575 --> 00:48:50,599
Remember, we allowed every peer to play the assassination in a different spot, which means

809
00:48:50,639 --> 00:48:55,641
all the survivors, or the survivor, or both survivors possibly, are in different spots

810
00:48:55,681 --> 00:48:56,302
on every box.

811
00:48:56,542 --> 00:49:00,264
But when you come out and the guy is still alive, everyone has to get back in sync somehow.

812
00:49:01,725 --> 00:49:03,086
So our system took care of that, of course.

813
00:49:03,246 --> 00:49:04,306
We received position updates.

814
00:49:04,346 --> 00:49:06,167
We said, oh, assassinations aren't happening anymore.

815
00:49:06,447 --> 00:49:06,928
Get in sync.

816
00:49:09,647 --> 00:49:12,748
So there was those artifacts like what you saw in those videos of people like warping

817
00:49:12,788 --> 00:49:14,869
and blending right after the assassination.

818
00:49:15,989 --> 00:49:19,690
But this was totally unacceptable for one very, very specific reason.

819
00:49:22,251 --> 00:49:27,673
We just got through playing a very expensive, very beautiful piece of content to draw the

820
00:49:27,733 --> 00:49:30,014
attention of every player in the game.

821
00:49:30,794 --> 00:49:32,775
They're all staring at this survivor.

822
00:49:33,195 --> 00:49:34,016
They're all wishing they were him.

823
00:49:35,476 --> 00:49:36,096
And then he warps!

824
00:49:37,136 --> 00:49:41,659
And then we get thousands of forum posts saying that our game is laggy and player perception

825
00:49:41,719 --> 00:49:42,300
is everything.

826
00:49:42,500 --> 00:49:44,401
You can't draw their attention and then have an artifact.

827
00:49:46,203 --> 00:49:49,145
So there were a couple of fixes to produce the shipping version.

828
00:49:50,186 --> 00:49:54,409
First, all peers, including the participants, obey the host strictly.

829
00:49:55,029 --> 00:49:58,011
This means that we get rid of the problem of discrepancies on exit.

830
00:49:58,772 --> 00:50:02,355
Survivors are always in the exact correct position at the end of the animation because

831
00:50:02,395 --> 00:50:04,056
we paid to get them in sync at the beginning.

832
00:50:06,073 --> 00:50:10,517
Now we still had the original problem that we were worried about to start with of, hey,

833
00:50:10,597 --> 00:50:13,660
on the entry into the assassination, we have to get rid of all these discrepancies.

834
00:50:13,700 --> 00:50:14,540
How are we going to do that?

835
00:50:15,701 --> 00:50:20,886
And so we very carefully implemented a, you know, visual only object state interpolator

836
00:50:21,966 --> 00:50:25,790
so that at the beginning of the assassination, all of the havoc state, all of the sort of

837
00:50:25,890 --> 00:50:29,733
true logical object state would be warped so that the assassination could begin and

838
00:50:29,773 --> 00:50:31,975
be in perfect sync with the host.

839
00:50:32,435 --> 00:50:35,598
But we delayed bringing the physical.

840
00:50:38,873 --> 00:50:41,794
and the renderable properties of the bipeds into those locations.

841
00:50:42,154 --> 00:50:45,874
We blended them over time using a quick exponential blend for like three quarters of a second.

842
00:50:48,755 --> 00:50:53,596
Even that didn't look great when we looked at it in our debug cameras.

843
00:50:53,616 --> 00:50:56,897
When our animators looked at this under network test conditions, they said that's not going

844
00:50:56,917 --> 00:50:57,217
to work.

845
00:50:57,277 --> 00:50:58,337
That's totally unacceptable.

846
00:50:58,698 --> 00:51:01,538
There's still these big blends on the way into my beautiful animation.

847
00:51:04,179 --> 00:51:05,019
And we played it in game.

848
00:51:06,006 --> 00:51:09,967
We discovered that once again, heaven had smiled upon us.

849
00:51:13,328 --> 00:51:18,550
As you may remember from the first video showing how assassinations work, when you start an

850
00:51:18,590 --> 00:51:24,152
assassination on the frame you start, the camera pulls out into third person to better

851
00:51:24,212 --> 00:51:24,912
show the ballet.

852
00:51:26,573 --> 00:51:30,574
Turns out the camera pull to third person takes about three quarters of a second.

853
00:51:32,692 --> 00:51:36,773
During that time, the camera's traveling at 25 feet per second.

854
00:51:38,453 --> 00:51:41,714
The player's perspective is changing so fast, they can't tell what's happening.

855
00:51:44,335 --> 00:51:46,496
We can blend 20 feet, they don't even notice.

856
00:51:46,736 --> 00:51:47,196
We tried it.

857
00:51:51,737 --> 00:51:56,039
Their brains fill in somehow consistency, because they're confused, and then they see

858
00:51:56,079 --> 00:51:59,400
the animation happen, and then they just backfill like, oh, that must have been what happened.

859
00:52:02,098 --> 00:52:04,599
So no visible latency, no reports of lag.

860
00:52:05,119 --> 00:52:07,360
Out to 300 milliseconds or so, totally fine.

861
00:52:09,821 --> 00:52:11,502
And once again, we could ship beautiful things.

862
00:52:32,727 --> 00:52:33,747
reinforcements.

863
00:52:52,082 --> 00:52:53,724
Alright, so all of our experiences

864
00:52:54,925 --> 00:52:56,206
on Reach and on prior games

865
00:52:56,746 --> 00:52:58,508
have led us to these four rules.

866
00:53:00,357 --> 00:53:06,420
four rules for designing your gameplay networking systems. First, you have to decide for each

867
00:53:06,480 --> 00:53:11,302
gameplay mechanic and sort of some high-level principles as well, which parts of your game

868
00:53:11,622 --> 00:53:15,924
are adjudicated by a single authority versus the parts that are allowed to be predicted

869
00:53:16,624 --> 00:53:22,046
and allowed to be out of sync for brief periods. The more stuff is adjudicated by the authority,

870
00:53:22,246 --> 00:53:27,829
the fairer and more consistent the game is. The more stuff that's predicted, the more

871
00:53:27,869 --> 00:53:28,849
responsive the game is.

872
00:53:30,729 --> 00:53:35,811
Most often you will have to mix these paradigms, even within every individual game mechanic.

873
00:53:36,471 --> 00:53:40,712
As we saw, you have to split the mechanic up and make predicted the pretty pieces and

874
00:53:40,732 --> 00:53:49,555
make adjudicated the important pieces. Second, always, always ask where you're hiding

875
00:53:49,596 --> 00:53:53,777
the lag. You can save yourself from shipping ugly public beta networking like we did.

876
00:53:56,358 --> 00:53:59,939
If you have host adjudication occurring, you will have lag somewhere.

877
00:54:00,348 --> 00:54:04,049
If you don't have lag somewhere, you don't have host adjudication.

878
00:54:04,129 --> 00:54:05,089
You have incurred lag debt.

879
00:54:07,509 --> 00:54:11,150
Third, don't be afraid to change game mechanics to improve networking.

880
00:54:13,171 --> 00:54:14,811
This is incredibly important.

881
00:54:14,871 --> 00:54:19,392
We have in the past several times had gameplay mechanics that we liked internally, that the

882
00:54:19,412 --> 00:54:22,653
designer was very happy with and that played very well on LAN games.

883
00:54:23,533 --> 00:54:26,053
Halo 3's shipping melee is a classic example.

884
00:54:26,613 --> 00:54:29,314
It was this fairly complex, well, somewhat complex thing where...

885
00:54:29,630 --> 00:54:33,232
When two players meleeed each other at the same time, the player with more health would

886
00:54:33,272 --> 00:54:33,472
win.

887
00:54:34,753 --> 00:54:35,433
The other one would die.

888
00:54:35,973 --> 00:54:38,254
They felt this added tactical depth to the game.

889
00:54:40,375 --> 00:54:45,078
In practice, on the Internet, with a few hundred milliseconds of latency, you couldn't tell

890
00:54:45,258 --> 00:54:48,099
with great precision what the health of your opponent was versus your own health.

891
00:54:49,320 --> 00:54:51,781
Which meant that when you went in and meleeed, it felt arbitrary.

892
00:54:52,861 --> 00:54:54,862
It felt like sometimes you died, sometimes he died.

893
00:54:55,182 --> 00:54:55,903
You had no control.

894
00:54:57,003 --> 00:54:58,764
We patched three months after ship.

895
00:54:59,198 --> 00:55:04,240
to simplify melee, to tear it down and make it this much simpler thing where if both players'

896
00:55:04,780 --> 00:55:06,720
shields are relatively low, they simply both die.

897
00:55:08,621 --> 00:55:12,541
Designers weren't as happy with this. It wasn't as tactically deep, but it worked on the Internet.

898
00:55:13,382 --> 00:55:19,703
It was fun and fair to players. Fourth, this almost goes without saying because

899
00:55:19,723 --> 00:55:26,025
it's so common across all of game dev, pardon me, and really all of engineering. Reserve

900
00:55:26,045 --> 00:55:26,605
time to iterate.

901
00:55:28,274 --> 00:55:32,375
Networking is incredibly hard to get full test coverage for, as all of you who have

902
00:55:32,395 --> 00:55:32,975
worked on it know.

903
00:55:34,136 --> 00:55:35,516
You will test it at your desk.

904
00:55:36,216 --> 00:55:38,277
You will test it with your coworkers.

905
00:55:38,717 --> 00:55:40,898
You will have an army of testers bang on it.

906
00:55:40,978 --> 00:55:42,258
You will take it home and play it.

907
00:55:44,219 --> 00:55:50,160
Then you'll hand it off to a publisher alpha with 10,000 participants.

908
00:55:51,321 --> 00:55:56,602
And an executive at your publisher will load up your game onto a kit, onto a retail Xbox.

909
00:55:58,241 --> 00:56:02,902
and he'll put it in his car and he will take it to his cabin at Whistler.

910
00:56:05,963 --> 00:56:09,824
And he will plug it in and he will boot up your game in his cabin at Whistler up in the

911
00:56:09,864 --> 00:56:10,144
trees.

912
00:56:13,565 --> 00:56:16,786
And then he will play and he will proceed to tell you at great length on your feedback

913
00:56:16,826 --> 00:56:19,467
forums how bad your networking is.

914
00:56:21,707 --> 00:56:25,208
Seriously, the Whistler forum thread as it came to be known inside Bungie.

915
00:56:27,009 --> 00:56:27,729
I'm not making this up.

916
00:56:29,015 --> 00:56:33,258
It actually was the source of several significant fixes between our alpha and delta because

917
00:56:33,338 --> 00:56:36,140
his connection had attributes we had never seen before.

918
00:56:37,821 --> 00:56:38,902
He had latency variance.

919
00:56:38,922 --> 00:56:42,564
We modeled the latency variance on a connection as like a sort of a normal distribution.

920
00:56:43,545 --> 00:56:50,470
His latency variance, the square of a standard deviation, was over 700 milliseconds.

921
00:56:51,930 --> 00:56:53,752
His packets were bouncing around all over the place.

922
00:56:53,772 --> 00:56:56,453
I don't know what the hell layers of buffering he had with his ISP up there.

923
00:56:57,506 --> 00:57:01,367
But he had unbelievably interesting bugs and he got the game into all kinds of crazy states

924
00:57:01,707 --> 00:57:04,008
because of this bad network and we were able to go in and fix them.

925
00:57:04,808 --> 00:57:07,309
It took a lot of time, so reserve that time.

926
00:57:10,310 --> 00:57:10,610
All right.

927
00:57:12,030 --> 00:57:18,372
After you've got your architecture and after you've networked your gameplay, you have to

928
00:57:18,412 --> 00:57:22,013
go in and measure and optimize your networking to make sure that it's actually as efficient

929
00:57:22,053 --> 00:57:23,413
as it needs to be.

930
00:57:24,834 --> 00:57:26,394
This is really, really hard for networking.

931
00:57:27,930 --> 00:57:33,535
Unfortunately, both because of the test coverage problem, which we just talked about, and because

932
00:57:33,595 --> 00:57:37,799
networking is a magnet for entropy, it's a very, very complex system.

933
00:57:37,879 --> 00:57:41,622
It gets more complex all the time because there's always tons of impetus to optimize

934
00:57:41,662 --> 00:57:41,722
it.

935
00:57:43,423 --> 00:57:44,104
It's invisible.

936
00:57:44,184 --> 00:57:46,246
It's only really noticed when it goes wrong.

937
00:57:47,287 --> 00:57:53,432
And perhaps most insidiously, networking has to work on an unreliable underlying layer

938
00:57:53,612 --> 00:57:56,995
on the Internet, which means it has tons and tons

939
00:57:57,357 --> 00:58:03,701
of internal safeguards and failovers, which means that if you have some system that is

940
00:58:03,741 --> 00:58:07,963
horribly broken somewhere in your networking tree, you probably won't notice it for a very

941
00:58:08,023 --> 00:58:13,086
long time because one of the safeguards will save you while consuming a ton of extra bandwidth

942
00:58:13,166 --> 00:58:19,130
or being inefficient in some other way. At the end of Halo 3, and when Halo 3 shipped,

943
00:58:19,650 --> 00:58:22,412
we had built up a couple games worth of this sort of entropy.

944
00:58:23,662 --> 00:58:26,983
As a result, 16-player games in Halo 3 did not work very consistently.

945
00:58:27,084 --> 00:58:29,544
There were a great percentage of lag artifacts.

946
00:58:29,905 --> 00:58:35,447
And so this richest, most complex, most chaotic version of Halo, which we all loved so much,

947
00:58:35,747 --> 00:58:37,988
didn't really work very well on the Internet, and we were sad.

948
00:58:40,048 --> 00:58:42,509
So we said, hey, let's go in, let's attack it, let's optimize it.

949
00:58:44,950 --> 00:58:46,771
Optimization is super dangerous.

950
00:58:50,642 --> 00:58:54,864
It's really easy, using your expert knowledge of the system and your belief that you yourself

951
00:58:54,924 --> 00:59:00,906
are a smart person, which we all share, I'm sure, to think about the architecture of your

952
00:59:00,926 --> 00:59:06,168
networking, decide something that seems like it could be better, implement an optimization,

953
00:59:06,328 --> 00:59:10,630
gain some small amount of efficiency, and introduce a ton of bugs.

954
00:59:12,090 --> 00:59:13,831
Again, this all comes back to test coverage.

955
00:59:14,231 --> 00:59:18,673
You can't really fully test your networking, or it's incredibly, incredibly hard and requires

956
00:59:18,733 --> 00:59:20,033
just vast, vast resources.

957
00:59:20,612 --> 00:59:25,236
So changing architecture is something that has to be done very, very deliberately.

958
00:59:25,256 --> 00:59:31,740
What this means is the kinds of optimizations you will think of from thinking about how

959
00:59:31,760 --> 00:59:35,323
your architecture currently works will usually not be the best bang for the buck.

960
00:59:37,304 --> 00:59:39,586
Really we don't want to be optimizing without good data.

961
00:59:39,646 --> 00:59:44,009
We don't want to just be going in and thinking about functions that are slow on a CPU optimizing

962
00:59:44,029 --> 00:59:48,312
or events we think are big on network optimizing and go in and change them.

963
00:59:48,713 --> 00:59:49,653
What we want is data.

964
00:59:52,713 --> 00:59:55,474
This is one of my favorite quotes from the other Michael Jackson.

965
00:59:58,936 --> 01:00:01,117
First rule of program optimization, don't do it.

966
01:00:01,917 --> 01:00:04,738
Second rule, for experts only, don't do it yet.

967
01:00:07,780 --> 01:00:09,701
Well we knew we needed to do it, unfortunately.

968
01:00:09,721 --> 01:00:11,101
We couldn't follow Mr. Jackson's advice.

969
01:00:11,161 --> 01:00:15,983
So, inspection tools are what you need to get past this problem, to get to where it's

970
01:00:16,043 --> 01:00:16,904
okay to optimize.

971
01:00:18,064 --> 01:00:21,326
Deep inspection tools will help you identify the things that are the best bang for the

972
01:00:21,366 --> 01:00:21,506
buck.

973
01:00:22,695 --> 01:00:23,636
So we thought about this.

974
01:00:23,836 --> 01:00:24,677
We sort of figured this out.

975
01:00:24,697 --> 01:00:25,838
We said, okay, we need some tools.

976
01:00:26,158 --> 01:00:26,759
What do we need?

977
01:00:26,859 --> 01:00:29,201
Well, let's think about how we do CPU optimization.

978
01:00:29,281 --> 01:00:34,585
Like we boot up the game and we run some representative test case and then we gather data, which gives

979
01:00:34,626 --> 01:00:38,088
us a nice hierarchical view of where all of our time is going.

980
01:00:38,189 --> 01:00:40,911
And then we figure out the best bang for the buck pieces and optimize them.

981
01:00:43,353 --> 01:00:44,394
So we built some profilers.

982
01:00:44,654 --> 01:00:45,415
That seemed natural.

983
01:00:47,156 --> 01:00:50,839
They would track bandwidth use for us and priority calculation results and show them

984
01:00:50,899 --> 01:00:51,260
on screen.

985
01:00:54,664 --> 01:00:57,145
Let's take a look at some of the capabilities of our profilers that we built.

986
01:00:58,705 --> 01:01:01,466
So this is from a live game of Reach, just video recording.

987
01:01:03,187 --> 01:01:08,269
And we bring up this graph view, a bunch of configuration stuff at the top, data series

988
01:01:08,329 --> 01:01:10,810
in the center, and then graphing of the data series at the bottom.

989
01:01:10,850 --> 01:01:12,850
You can't read these numbers or even see a lot of these lines.

990
01:01:12,890 --> 01:01:13,491
Don't worry about it.

991
01:01:13,551 --> 01:01:14,051
Not important.

992
01:01:14,771 --> 01:01:17,272
What's important is the kind of content being presented here.

993
01:01:17,732 --> 01:01:22,954
The first line here is showing the entirety of replication used bandwidth.

994
01:01:23,729 --> 01:01:25,030
The total amount of data being sent.

995
01:01:25,750 --> 01:01:27,011
Now it's split into five lines.

996
01:01:27,131 --> 01:01:30,954
This is showing all of our replication bandwidth use by protocol type.

997
01:01:31,214 --> 01:01:35,337
So state data as one, events as another, control data, and then voice.

998
01:01:38,719 --> 01:01:42,581
In particular, you can see here, well, if you take a look at the GDC vault and look

999
01:01:42,601 --> 01:01:46,044
at the good version of the video, you can see that state data takes up about 80% of

1000
01:01:46,064 --> 01:01:46,484
our bandwidth.

1001
01:01:47,364 --> 01:01:48,405
Hey, there's a lot more lines now.

1002
01:01:48,445 --> 01:01:50,246
We've just gone another level deeper.

1003
01:01:51,287 --> 01:01:53,488
We can go inside state data and events.

1004
01:01:53,972 --> 01:01:58,013
and look at individual types of events and individual classes of objects.

1005
01:01:58,653 --> 01:02:04,274
So we can look at bipeds versus weapons versus items and look at all their bandwidth use.

1006
01:02:06,395 --> 01:02:08,455
We can go even one level deeper, which is shown here.

1007
01:02:08,935 --> 01:02:14,736
We can look at every individual property of every subtype of every type of replication.

1008
01:02:14,776 --> 01:02:18,397
So we can look at biped positions and compare them to weapon inventories.

1009
01:02:23,787 --> 01:02:26,689
All of this data is shown, of course, with a nice graphing view so you can see which

1010
01:02:26,749 --> 01:02:27,490
types are spiky.

1011
01:02:27,790 --> 01:02:29,491
Very, very important in any kind of optimization.

1012
01:02:33,373 --> 01:02:34,414
Now this is all very useful.

1013
01:02:34,454 --> 01:02:38,797
This gives us a nice, like, sort of a high-level classification-based view of bandwidth use.

1014
01:02:39,137 --> 01:02:42,799
But one other really interesting thing, especially in combination with priority information,

1015
01:02:43,160 --> 01:02:45,921
is per-object bandwidth use, which I've just turned on in the background.

1016
01:02:45,941 --> 01:02:47,022
There's a sea of numbers there.

1017
01:02:48,900 --> 01:02:54,063
Our profiler tracks for every individual object all of the bandwidth use associated with that

1018
01:02:54,163 --> 01:03:00,066
object as well as all of the bandwidth that the object would like to use in an ideal world.

1019
01:03:00,266 --> 01:03:03,227
And it tracks all those and shows them here and they're color-coded by who's using the

1020
01:03:03,267 --> 01:03:04,548
most bandwidth versus the least.

1021
01:03:05,768 --> 01:03:10,490
And this can let us identify things like individual objects that are sitting off in a corner and

1022
01:03:10,530 --> 01:03:13,912
chewing up bandwidth for no apparent reason, which happens all the time.

1023
01:03:16,533 --> 01:03:17,474
So that's our profiling tool.

1024
01:03:17,514 --> 01:03:18,174
We built this in...

1025
01:03:18,908 --> 01:03:20,709
I don't know, about a month, maybe three weeks.

1026
01:03:22,530 --> 01:03:26,532
And we decided to go and attack, well, I'm getting ahead of myself.

1027
01:03:27,152 --> 01:03:30,393
We had one other tool besides profilers to work with.

1028
01:03:32,194 --> 01:03:33,115
This tool is called Films.

1029
01:03:33,595 --> 01:03:35,355
Films are something we've had since Halo 3.

1030
01:03:36,636 --> 01:03:39,277
They provide us with deterministic playback of gameplay sessions.

1031
01:03:39,317 --> 01:03:42,539
They're called Films instead of deterministic playback of gameplay sessions because they're

1032
01:03:42,559 --> 01:03:43,479
a user-facing feature.

1033
01:03:43,559 --> 01:03:46,500
Players can actually record their gameplay sessions and play them back.

1034
01:03:47,298 --> 01:03:50,800
These are very, very useful for debugging gameplay, but they've never been really very

1035
01:03:50,880 --> 01:03:55,722
useful for network debugging because network systems are, of course, idle during film playback.

1036
01:03:55,762 --> 01:03:57,763
Networking is all about live decisions.

1037
01:03:57,803 --> 01:04:00,344
It's all about looking at the current state of the Internet and making decisions.

1038
01:04:02,505 --> 01:04:03,225
So that was sort of neat.

1039
01:04:03,305 --> 01:04:06,066
So we looked at these and we said, hey, we've got this profiler on the one hand.

1040
01:04:06,086 --> 01:04:06,786
It seems pretty sweet.

1041
01:04:06,806 --> 01:04:10,168
We've got these films on the other hand that everyone loves, all the gameplay guys sort

1042
01:04:10,188 --> 01:04:13,649
of thumb their noses at us with their incredibly easy-to-repro bugs.

1043
01:04:16,675 --> 01:04:18,715
And we said, hey, these things sure would taste good together.

1044
01:04:18,735 --> 01:04:22,056
Can we make that happen?

1045
01:04:23,577 --> 01:04:24,417
And, of course, we're engineers.

1046
01:04:24,457 --> 01:04:24,917
We can.

1047
01:04:26,237 --> 01:04:32,079
So we spliced the network profiler data into the film at the times when gameplay was occurring.

1048
01:04:32,419 --> 01:04:36,300
So after every frame of gameplay, we would inject a little debug blob into our films

1049
01:04:36,580 --> 01:04:41,502
that are being streamed out to the console hard drive containing all of the new network

1050
01:04:41,542 --> 01:04:43,322
state that was sampled during that frame.

1051
01:04:43,962 --> 01:04:46,203
So all the information about every packet we sent and received.

1052
01:04:46,580 --> 01:04:52,262
and all the prioritization decisions. For the first time in Halo history, we could

1053
01:04:52,382 --> 01:04:58,645
analyze network performance after the fact. Which just enabled all kinds of wonderful

1054
01:04:59,085 --> 01:05:01,386
deep investigations we'd never been able to do before.

1055
01:05:05,027 --> 01:05:09,228
All right. Profilers and films are all very well, but we still need some way to actually

1056
01:05:09,268 --> 01:05:14,070
gather data to actually figure out whether the game is working well. So we need play

1057
01:05:14,090 --> 01:05:16,191
tests. We need to play the game. That's the ultimate test.

1058
01:05:17,110 --> 01:05:19,551
So we ran network per focus play tests about once a month.

1059
01:05:20,772 --> 01:05:25,014
We ran network filters on all the boxes in the lab so that we could simulate all kinds

1060
01:05:25,054 --> 01:05:29,956
of different network conditions, packet loss, limited bandwidth, latency spikes, brief connection

1061
01:05:29,996 --> 01:05:31,996
drops, all sorts of things like that.

1062
01:05:33,057 --> 01:05:34,077
And then we had players play.

1063
01:05:36,718 --> 01:05:38,559
And then we ran up into a problem very quickly.

1064
01:05:40,860 --> 01:05:44,241
Players can play and they can sort of tell us whether they had a good time or not.

1065
01:05:45,538 --> 01:05:50,561
whether they thought the networking was laggy or not, which incidentally correlates almost

1066
01:05:50,661 --> 01:05:52,101
perfectly with whether they won or not.

1067
01:05:55,603 --> 01:05:58,464
But really this wasn't very scientific and it wasn't very granular.

1068
01:05:58,504 --> 01:06:01,705
It wasn't helping us figure out whether we were actually making our networking better.

1069
01:06:02,225 --> 01:06:05,067
We needed a more scientific way to measure success.

1070
01:06:09,208 --> 01:06:09,729
So what did we do?

1071
01:06:10,169 --> 01:06:13,630
We allowed players to report every time they see lag.

1072
01:06:14,128 --> 01:06:18,011
by pushing a controller button, especially assigned for that purpose, in these play tests.

1073
01:06:19,432 --> 01:06:25,137
This injects an additional debug blob into the wonderful film, allowing us to jump to

1074
01:06:25,197 --> 01:06:29,120
it later and look at what they saw and investigate why they saw lag.

1075
01:06:32,162 --> 01:06:37,767
This is how we turned this from an art, a guessing-based game and an incredibly labor-intensive game,

1076
01:06:38,107 --> 01:06:38,868
into a science.

1077
01:06:40,289 --> 01:06:43,512
When we could run the game at our bandwidth goals and get...

1078
01:06:43,945 --> 01:06:47,805
no perceived lag events coming out of the players, we knew we had succeeded.

1079
01:06:51,466 --> 01:06:57,327
There were a few bumps along the way. Most notably, as we went through our network optimizations,

1080
01:06:57,607 --> 01:07:01,648
we started discovering that perceived lag events were still getting put in by players.

1081
01:07:01,668 --> 01:07:06,289
They were still pushing the button. We didn't really understand it. We would go in and we

1082
01:07:06,309 --> 01:07:10,629
would look at the films and look at what they saw, and they didn't see any lag. There was

1083
01:07:10,669 --> 01:07:12,230
no network lag. There was plenty of bandwidth available.

1084
01:07:13,352 --> 01:07:17,893
Instead, they would push this button whenever some game mechanic confused them.

1085
01:07:21,174 --> 01:07:24,755
If they got shot from behind by two guys at once and the death camera didn't show them

1086
01:07:24,815 --> 01:07:28,155
how they got killed clearly enough, they would hit the button and be like, that looked laggy.

1087
01:07:30,816 --> 01:07:35,577
It got incredibly subtle things like the, at one point we had, we were tuning grenade

1088
01:07:35,597 --> 01:07:36,938
damage in the alpha.

1089
01:07:37,871 --> 01:07:41,653
grenades were tuned up somewhat from their Halo 3 level, so a grenade could kill you

1090
01:07:41,993 --> 01:07:44,514
in one shot much more often and at a larger distance.

1091
01:07:46,015 --> 01:07:51,478
And in pre-alpha network perf tests, we got a significant number of perceived lag events

1092
01:07:51,578 --> 01:07:54,959
inserted when players would get killed by these grenades, because getting killed in

1093
01:07:55,059 --> 01:07:58,841
one shot from nearly full health is very confusing and feels very disorienting.

1094
01:07:59,561 --> 01:08:02,743
So we would bring these things to our designers and send them these little sub-snippets of

1095
01:08:02,783 --> 01:08:03,543
films and say, hey.

1096
01:08:04,291 --> 01:08:05,632
These game mechanics are confusing players.

1097
01:08:05,672 --> 01:08:06,512
They think they're laggy.

1098
01:08:06,732 --> 01:08:08,013
And we had science to back it up.

1099
01:08:12,055 --> 01:08:12,256
All right.

1100
01:08:12,496 --> 01:08:18,319
The culmination of all of this, I'm going to show you the same section of gameplay that

1101
01:08:18,339 --> 01:08:21,621
we looked at before, but I'm going to talk about everything working together.

1102
01:08:23,582 --> 01:08:24,723
So this is not a live game.

1103
01:08:24,743 --> 01:08:26,004
This is not a video of a live game.

1104
01:08:26,024 --> 01:08:28,285
This is a video of one of our films playing back.

1105
01:08:30,206 --> 01:08:33,268
So we can go into third person and view the game from different perspectives.

1106
01:08:34,295 --> 01:08:38,397
We can fly the camera around and view what's happening in the game to our heart's content.

1107
01:08:39,578 --> 01:08:42,620
Even more powerfully, we can rewind.

1108
01:08:45,081 --> 01:08:50,324
We can go back and we can view a questionable section of the game over and over with these

1109
01:08:50,364 --> 01:08:52,506
powerful profiling tools available to us.

1110
01:08:54,387 --> 01:09:00,730
There is no excuse to us for not tracking down lag problems given this tool set.

1111
01:09:00,750 --> 01:09:03,712
Of course, it gets even more interesting.

1112
01:09:04,437 --> 01:09:08,840
All of this I've shown you up until now is all of the network data of the host box in

1113
01:09:09,040 --> 01:09:09,721
one big bucket.

1114
01:09:09,781 --> 01:09:12,843
Like the graph is showing all the bandwidth use of the host to all clients.

1115
01:09:13,183 --> 01:09:14,684
That's not really the most interesting thing.

1116
01:09:14,704 --> 01:09:17,707
The most interesting thing is this, which looks sort of the same to you, but you'll

1117
01:09:17,727 --> 01:09:18,527
have to take my word for it.

1118
01:09:19,888 --> 01:09:25,392
This is showing bandwidth as sent to the particular client there with the sword only.

1119
01:09:25,873 --> 01:09:30,136
This is the contents of the packets that we sent to him in this game at this time.

1120
01:09:31,377 --> 01:09:34,159
We can also go in and look at a particular object like this shotgun.

1121
01:09:35,534 --> 01:09:40,037
and press a button and filter all of our data being sent to that one guy with the sword

1122
01:09:40,518 --> 01:09:45,221
to show only data sent about that shotgun. Similarly, this biped. We can say, oh, this

1123
01:09:45,281 --> 01:09:48,924
is all the stuff we transmitted about that biped. This is the total output of our prioritization

1124
01:09:48,964 --> 01:09:54,768
systems, the movement of that guy recently, every attribute we care about. But these are

1125
01:09:54,788 --> 01:09:58,330
still one second averages. Oh, we can get way more detail than that. We have all the

1126
01:09:58,370 --> 01:10:02,693
data. We can show every single packet that we sent to this client.

1127
01:10:03,266 --> 01:10:09,591
and look inside them in this very visual way to see exactly which packets included updates

1128
01:10:09,731 --> 01:10:14,856
about this guy, what properties they included. We can scroll through time. We can scrub back

1129
01:10:14,896 --> 01:10:28,327
and forth exactly like we could before. This whole picture is what allowed us to reduce

1130
01:10:28,867 --> 01:10:32,650
the overall bandwidth use of Halo 3, pardon me, Halo Reach from Halo 3.

1131
01:10:33,773 --> 01:10:46,917
by over 80%. The total time for development of these tools, the film integration and the

1132
01:10:47,317 --> 01:10:52,298
various visualizers, somewhere on the order of six weeks, plus a significant amount of

1133
01:10:52,338 --> 01:10:55,059
time ongoing reviewing perceived lag events after play tests.

1134
01:10:58,140 --> 01:11:02,081
All right. So we took this wonderful process, taking you back in time again.

1135
01:11:02,623 --> 01:11:03,683
We're at the end of Halo 3.

1136
01:11:03,723 --> 01:11:04,463
We're starting up a reach.

1137
01:11:04,483 --> 01:11:05,684
We built this beautiful tool set.

1138
01:11:05,704 --> 01:11:06,784
We integrated it into our films.

1139
01:11:07,104 --> 01:11:09,665
We unleashed it on Halo 3 on internal builds.

1140
01:11:10,405 --> 01:11:11,546
We said, let's see what we find.

1141
01:11:11,586 --> 01:11:12,946
I wonder what the problem is.

1142
01:11:14,267 --> 01:11:16,207
And we got this wonderful high-level breakdown of data.

1143
01:11:16,427 --> 01:11:17,868
And this is the first thing we harvested.

1144
01:11:18,048 --> 01:11:19,928
This was even before we had network perf play tests.

1145
01:11:21,629 --> 01:11:26,450
And we got, okay, 50% of our data is positions, velocities, and orientations, 20% player control,

1146
01:11:26,870 --> 01:11:27,231
so forth.

1147
01:11:29,451 --> 01:11:32,192
We said, hey, let's go optimize the heavy hitters just like we would in CPU perf.

1148
01:11:33,690 --> 01:11:35,350
This was a false start, unfortunately.

1149
01:11:38,071 --> 01:11:43,553
Turns out it's very, very difficult to further optimize positions, velocities, and orientations.

1150
01:11:43,573 --> 01:11:46,234
This is very much like seeing your math functions in your CPU profiles.

1151
01:11:46,774 --> 01:11:48,295
They are things that have to be done a lot.

1152
01:11:48,435 --> 01:11:50,195
They're in a lot of algorithms.

1153
01:11:51,156 --> 01:11:54,097
They tend to be already fairly optimal because everyone working on them knows they're going

1154
01:11:54,117 --> 01:11:54,757
to be used a lot.

1155
01:11:56,177 --> 01:11:58,038
And so we didn't get much out of it.

1156
01:11:58,318 --> 01:12:00,539
They were already pretty optimal from even their original implementations.

1157
01:12:00,579 --> 01:12:01,639
So we need to go up to a higher level.

1158
01:12:02,559 --> 01:12:03,540
Here are some good optimizations.

1159
01:12:04,456 --> 01:12:09,420
First, reducing always on bandwidth use, this was sort of a traditional networking optimization

1160
01:12:09,480 --> 01:12:09,960
we would call it.

1161
01:12:10,781 --> 01:12:15,964
We removed data that was duplicated, sorry, so the control replication from hosts to clients

1162
01:12:16,785 --> 01:12:18,106
accounted for a significant amount of upstream.

1163
01:12:18,126 --> 01:12:21,208
And we looked into it and we found that it didn't contain positions and orientations

1164
01:12:21,228 --> 01:12:21,749
and velocities.

1165
01:12:21,789 --> 01:12:23,450
It contained things we could compress pretty well.

1166
01:12:24,991 --> 01:12:27,293
So we went in and we removed a bunch of data that was duplicated.

1167
01:12:27,313 --> 01:12:29,234
We removed data we could infer in other ways.

1168
01:12:29,694 --> 01:12:31,916
And we optimized some encoding by hand very carefully.

1169
01:12:32,536 --> 01:12:37,399
And we got this down about 60% by doing this, just because we knew we had data, we knew

1170
01:12:37,439 --> 01:12:40,100
it was a significant amount of bandwidth, we knew it was worth spending this time.

1171
01:12:40,660 --> 01:12:44,522
So we spent like two weeks on this tiny section of code trying to just hand tweak the hell

1172
01:12:44,583 --> 01:12:44,823
out of it.

1173
01:12:45,863 --> 01:12:46,484
And this worked out.

1174
01:12:48,064 --> 01:12:51,967
This is the only optimization we implemented that I would consider a success that was actually

1175
01:12:51,987 --> 01:12:53,267
a networking optimization.

1176
01:12:54,308 --> 01:12:55,649
But yet I have many more slides.

1177
01:12:57,189 --> 01:12:57,750
Let's take a look.

1178
01:12:58,070 --> 01:12:59,351
Fixing a prioritization bug.

1179
01:12:59,411 --> 01:13:02,352
So, when guys die in Halo, they drop all this crap.

1180
01:13:03,458 --> 01:13:06,699
a couple of guns, a couple of grenades, that sort of thing. These fall to the ground and

1181
01:13:06,719 --> 01:13:11,481
are simulated by Havok. We discovered a problem with the profiler.

1182
01:13:12,462 --> 01:13:17,944
Idle grenades rolling around on the ground had incredibly high network priority. It just

1183
01:13:17,964 --> 01:13:21,285
showed up to us, like they're using all this bandwidth, so they're right on the object

1184
01:13:21,325 --> 01:13:26,348
bandwidth display. Bring up the priority profiler. There's a ton of data there, a ton of very,

1185
01:13:26,368 --> 01:13:29,869
very high priority numbers showing up. And we said, what on earth is going on?

1186
01:13:30,400 --> 01:13:33,662
So we traced it back and we walked through the prioritization algorithms and we discovered

1187
01:13:33,722 --> 01:13:38,885
that a bug fix was implemented at the end of Halo 3, which was causing this to happen.

1188
01:13:40,006 --> 01:13:41,447
So we traced back, why was this done?

1189
01:13:41,507 --> 01:13:42,167
Like this is crazy.

1190
01:13:42,187 --> 01:13:45,329
Why do idle grenades have such high priority?

1191
01:13:46,470 --> 01:13:49,672
Turned out that at the end of Halo 3, about two weeks before RC.

1192
01:13:53,245 --> 01:13:55,445
Equipment was given a huge priority boost.

1193
01:13:55,685 --> 01:13:59,806
Equipment in Halo 3 was like these throwable things that could spawn bubble shields or

1194
01:14:00,026 --> 01:14:00,786
drain people's shields.

1195
01:14:03,007 --> 01:14:05,747
And they were, and equipment was laggy, and so they gave it a big priority boost, and

1196
01:14:05,787 --> 01:14:07,847
they said, all right, we're, you know, that's all that.

1197
01:14:07,867 --> 01:14:08,648
They tested it, it worked.

1198
01:14:10,288 --> 01:14:16,369
Turned out, through an accident of design on the gameplay coder's side, grenades and

1199
01:14:16,409 --> 01:14:19,930
equipment had the same parent class, which was called equipment.

1200
01:14:22,902 --> 01:14:26,104
So all the idle grenades on the ground without their pins pulled, totally unthreatening to

1201
01:14:26,164 --> 01:14:33,731
anyone, received this same priority boost. Consuming tremendous amounts of bandwidth

1202
01:14:33,771 --> 01:14:36,433
as they rolled around gently on the ground and waited for someone to pick them up.

1203
01:14:38,535 --> 01:14:44,660
Simple fix. One line. Apply priority boost only to active equipment. This by itself freed

1204
01:14:44,740 --> 01:14:50,805
up probably 20% of our bandwidth. The whole battle was identifying the issue.

1205
01:14:55,504 --> 01:14:56,085
All right.

1206
01:14:56,105 --> 01:14:57,125
Another example, a little different.

1207
01:14:57,506 --> 01:14:58,306
Changing game mechanics.

1208
01:14:58,366 --> 01:15:02,550
Halo 3 used a constant artificial friction on items, these idle grenades and weapons

1209
01:15:02,590 --> 01:15:03,030
on the ground.

1210
01:15:05,572 --> 01:15:09,335
As they rolled around on the ground, we applied this artificial friction to them to keep them

1211
01:15:09,375 --> 01:15:12,077
from all rolling indefinitely until they reached the lowest point in the level.

1212
01:15:14,399 --> 01:15:18,823
The problem with this was if you had an object on a hill, a relatively steep hill, the artificial

1213
01:15:18,863 --> 01:15:22,646
friction would combat gravity and keep the object rolling slowly for a long period of

1214
01:15:22,706 --> 01:15:24,567
time, consuming network bandwidth.

1215
01:15:25,640 --> 01:15:28,662
Still not that relevant to the game, so we didn't really want this behavior.

1216
01:15:29,682 --> 01:15:34,025
So we went into the item code and the physics code and we implemented this fake friction

1217
01:15:34,065 --> 01:15:34,405
system.

1218
01:15:35,446 --> 01:15:40,089
Totally arbitrary gameplay code, no one really understood why it was there except the networking

1219
01:15:40,129 --> 01:15:40,489
coders.

1220
01:15:40,969 --> 01:15:44,992
But it's this crazy thing where designers can say, oh yeah, please apply this friction

1221
01:15:45,032 --> 01:15:50,915
curve over time so that we allow objects to travel down steep hills at full speed without

1222
01:15:50,935 --> 01:15:53,937
applying any friction to them whatsoever, so they're just subject to Newtonian physics.

1223
01:15:55,315 --> 01:15:58,937
Once they reach a relatively gentle slope, we apply this friction curve that designers

1224
01:15:58,977 --> 01:16:03,320
specify, which starts with low friction and ramps up over the course of three to four

1225
01:16:03,340 --> 01:16:07,522
seconds to infinite friction and brings them to a screeching halt.

1226
01:16:09,443 --> 01:16:13,845
So grenades dropped on hills would fly down them in a couple seconds, looking better in

1227
01:16:13,865 --> 01:16:17,447
the process, if I do say so myself, and then come to rest.

1228
01:16:18,107 --> 01:16:18,848
Nobody noticed this.

1229
01:16:19,088 --> 01:16:19,988
Nobody on the design team cared.

1230
01:16:20,029 --> 01:16:21,369
Nobody on the sandbox team cared.

1231
01:16:21,529 --> 01:16:22,590
But this probably saved another 10%.

1232
01:16:24,598 --> 01:16:27,861
just because there's so many items. Players drop so much stuff and it gets disturbed so

1233
01:16:27,941 --> 01:16:37,548
often. Next example, ragdoll networking. Ragdolls are kind of a pain. They're deeply, deep physical

1234
01:16:37,588 --> 01:16:40,931
simulations. They have a lot of nodes that move around. There's a lot of, it's very hard

1235
01:16:40,951 --> 01:16:45,475
to capture all of their state in a small package. Like, if you have a guy who's alive and he's

1236
01:16:45,515 --> 01:16:49,418
running around playing an animation, you can pretty much capture his state as current position,

1237
01:16:49,458 --> 01:16:52,781
direction he's traveling, maybe the animation he's playing, and you're done. Like, eh, a

1238
01:16:52,861 --> 01:16:54,282
hundred bits, not that big of a deal.

1239
01:16:55,002 --> 01:16:58,523
Ragdolls, on the other hand, is like, oh, God, we've got to transmit all these bones.

1240
01:16:58,563 --> 01:16:59,764
They're all physically separate.

1241
01:16:59,784 --> 01:17:01,244
They can bounce off things independently.

1242
01:17:01,284 --> 01:17:01,725
What a mess.

1243
01:17:03,065 --> 01:17:06,506
So we always sort of come across, we always come up with different compromises, trying

1244
01:17:06,526 --> 01:17:08,587
to network less of, like, some subsections of the ragdoll.

1245
01:17:08,607 --> 01:17:09,427
It never looked that great.

1246
01:17:09,467 --> 01:17:10,288
It burned a lot of bandwidth.

1247
01:17:10,568 --> 01:17:15,209
So we said, hey, do we have to network ragdolls?

1248
01:17:15,569 --> 01:17:16,310
Like, really?

1249
01:17:17,850 --> 01:17:20,531
So we're trying, we tried to turn the problem on its head and say, hey, can we just get

1250
01:17:20,571 --> 01:17:21,772
rid of this whole problem?

1251
01:17:22,961 --> 01:17:28,665
We brought this over to our sandbox design lead, Sage Merrill, and said, hey, can we

1252
01:17:28,705 --> 01:17:29,466
not network ragdolls?

1253
01:17:29,906 --> 01:17:36,731
And we went through three stages of gameplay design response to this sort of thing, which

1254
01:17:36,751 --> 01:17:37,572
you will probably see yourselves.

1255
01:17:38,853 --> 01:17:41,555
First shock, what are you doing?

1256
01:17:41,595 --> 01:17:42,576
Not network ragdolls?

1257
01:17:43,216 --> 01:17:44,557
We might want to do something with them someday.

1258
01:17:45,798 --> 01:17:46,518
Then skepticism.

1259
01:17:46,538 --> 01:17:48,800
Are you sure this will work?

1260
01:17:48,860 --> 01:17:50,181
Like that seems sort of crazy.

1261
01:17:50,381 --> 01:17:51,582
Doesn't everybody else network ragdolls?

1262
01:17:52,955 --> 01:17:58,039
And then consideration, where they dig in and tell us, what really are the problems

1263
01:17:58,059 --> 01:17:59,920
with not networking ragdolls, for real?

1264
01:18:01,141 --> 01:18:02,041
And they came up with two things.

1265
01:18:03,202 --> 01:18:05,123
First, ragdolls block bullets.

1266
01:18:05,984 --> 01:18:10,526
Like every other object in our game, ragdolls are physically real and they can block bullet

1267
01:18:10,587 --> 01:18:11,087
trajectories.

1268
01:18:11,987 --> 01:18:16,450
So we needed to deal with this somehow if we were going to let ragdolls desync, because

1269
01:18:16,470 --> 01:18:18,932
otherwise you'd have invisible objects blocking bullets on different peers.

1270
01:18:21,393 --> 01:18:22,454
The second problem was humping.

1271
01:18:24,886 --> 01:18:32,969
quite serious. Since Halo 1, there's been this tradition in the Halo community, this

1272
01:18:32,989 --> 01:18:36,951
tradition that we didn't want to mess with. When you kill someone and you have some time

1273
01:18:36,991 --> 01:18:41,673
to spare because you're not under attack right now, you walk over to their corpse and then

1274
01:18:41,733 --> 01:18:46,875
you press your crouch button, drop it down like this, and you release your crouch button,

1275
01:18:47,736 --> 01:18:51,037
and you push it again, and so forth, until you get bored.

1276
01:18:53,378 --> 01:18:56,140
It's very important for the ragdoll to be in the right spot so that that humiliates

1277
01:18:56,160 --> 01:18:58,381
him properly, so that he can see that you're doing this to him.

1278
01:19:00,182 --> 01:19:01,182
Totally serious.

1279
01:19:01,742 --> 01:19:02,803
This is a real thing.

1280
01:19:06,285 --> 01:19:08,426
So we made two fixes to deal with these two problems.

1281
01:19:08,486 --> 01:19:12,588
First, we went into our collision system and our projectile system and we allowed bullets

1282
01:19:12,628 --> 01:19:14,429
and grenades to penetrate ragdolls freely.

1283
01:19:14,469 --> 01:19:17,350
We allowed them to overpenetrate without any side effects.

1284
01:19:17,950 --> 01:19:20,271
We used a debug harness to verify that there were no side effects.

1285
01:19:20,531 --> 01:19:22,012
It was added fairly late in the game.

1286
01:19:23,867 --> 01:19:27,628
Second, we added a system to synchronize the initial state of ragdolls.

1287
01:19:27,748 --> 01:19:31,170
So we wouldn't network them over time as they were flying through the air or bouncing around

1288
01:19:31,190 --> 01:19:36,391
on the ground, but we would network them very exactly with a debug harness to verify.

1289
01:19:36,651 --> 01:19:42,133
We would network their initial state at the moment of death on all boxes, and all boxes

1290
01:19:42,153 --> 01:19:43,313
would be guaranteed to start with that.

1291
01:19:43,974 --> 01:19:46,915
Which meant as long as you didn't interfere with the ragdoll too much, it would be in

1292
01:19:46,975 --> 01:19:48,055
perfect sync in most cases.

1293
01:19:50,116 --> 01:19:50,956
And this worked well enough.

1294
01:19:51,349 --> 01:19:54,471
Once in a while, if there's enough grenades going off, you can have ragdolls just completely

1295
01:19:54,511 --> 01:19:55,732
desync and it becomes obvious.

1296
01:19:55,792 --> 01:19:57,813
But by and large, it worked quite well.

1297
01:19:59,154 --> 01:20:02,756
And we saved up another 10, 12% of bandwidth maybe.

1298
01:20:06,198 --> 01:20:09,920
Lastly, I have sort of a bucket of interesting cases of smoothing out bursts of bandwidth,

1299
01:20:09,960 --> 01:20:14,422
smoothing out worst cases, very much like smoothing out worst case frames of CPU performance.

1300
01:20:15,022 --> 01:20:17,504
First, we had problems with high rate of fire weapons, machine guns.

1301
01:20:18,745 --> 01:20:20,005
Bullets were networked optimally.

1302
01:20:20,395 --> 01:20:24,318
but not the damage that they were causing. People who designed the original machine gun

1303
01:20:24,358 --> 01:20:27,121
networking knew that they would fire very rapidly and so they needed an efficient bit

1304
01:20:27,141 --> 01:20:31,004
of networking for them. So they did that. But when the bullets hit targets and dealt

1305
01:20:31,044 --> 01:20:34,326
damage, it would trigger individual events for every bit of damage and that could take

1306
01:20:34,507 --> 01:20:37,589
all your bandwidth very, very quickly if people with, if multiple people with machine guns

1307
01:20:37,629 --> 01:20:43,333
were shooting targets at a lot of hit points. So we went in and we said, okay, for bullets

1308
01:20:43,354 --> 01:20:44,715
that do a small amount of damage.

1309
01:20:45,185 --> 01:20:48,367
We're going to just let clients predict some of those damage effects so that the host doesn't

1310
01:20:48,387 --> 01:20:51,629
have to tell them, oh, yeah, this kind of spark occurred and this sound played and,

1311
01:20:51,749 --> 01:20:53,009
yeah, yada, yada, yada.

1312
01:20:53,029 --> 01:20:53,650
It's a machine gun.

1313
01:20:53,670 --> 01:20:55,831
It's firing 15 times a second.

1314
01:20:55,891 --> 01:20:56,752
Just play your own sparks.

1315
01:21:00,534 --> 01:21:03,476
Another example, we had periodic update of game statistics data.

1316
01:21:03,496 --> 01:21:06,778
So we had this blob of data we sent that shows up on the end game stats.

1317
01:21:08,058 --> 01:21:12,061
It took priority over gameplay traffic because it was on a protocol below our application

1318
01:21:12,101 --> 01:21:12,321
layers.

1319
01:21:12,840 --> 01:21:17,781
This would come in every 10 to 30 seconds and just take all the bandwidth in every packet

1320
01:21:18,241 --> 01:21:19,102
until it was updated.

1321
01:21:19,822 --> 01:21:20,922
Two, three, four packets.

1322
01:21:22,363 --> 01:21:25,324
And we discovered this with the bandwidth profiler because we get lag events during

1323
01:21:25,364 --> 01:21:29,205
that time because at the end of the three or four frame period, the networking would

1324
01:21:29,245 --> 01:21:31,666
turn back on for the game and everything would warp.

1325
01:21:32,486 --> 01:21:35,967
And we dug into it with the per packet information in the profiler and discovered, lo and behold,

1326
01:21:36,027 --> 01:21:38,288
all the gameplay data is just missing from four or five packets.

1327
01:21:39,208 --> 01:21:41,309
And so we found this guy and we beat him in his submission.

1328
01:21:42,340 --> 01:21:44,621
You can only send 10% of each packet maximum.

1329
01:21:44,821 --> 01:21:46,201
Statistics data can be late.

1330
01:21:46,321 --> 01:21:46,921
It's fine.

1331
01:21:49,762 --> 01:21:51,702
Lastly, low priority objects were getting

1332
01:21:51,782 --> 01:21:52,862
updates in perfect sync.

1333
01:21:54,303 --> 01:21:55,163
This is an interesting problem.

1334
01:21:55,183 --> 01:21:57,443
So our priority system ramps up the priority of objects

1335
01:21:57,503 --> 01:21:59,904
over time to make sure that eventually the state data

1336
01:21:59,924 --> 01:22:00,864
guarantee will be met.

1337
01:22:01,504 --> 01:22:03,304
Eventually the most updated state will arrive.

1338
01:22:05,084 --> 01:22:07,305
Problem was, if you had a lot of objects that were out far,

1339
01:22:07,405 --> 01:22:09,585
far away and they all tied for lowest priority,

1340
01:22:09,995 --> 01:22:12,817
and they all got disturbed at the same time, like a pile of crates across the level that

1341
01:22:12,837 --> 01:22:13,478
gets bumped into.

1342
01:22:14,138 --> 01:22:18,081
They would all get lowest priority, they wouldn't get sent, and they'd ramp up in priority slowly,

1343
01:22:18,101 --> 01:22:22,244
slowly, slowly, slowly, and then they'd all get really old, and then they'd all panic

1344
01:22:22,784 --> 01:22:25,906
on the same frame and say, oh, crap, we haven't been sent in five seconds, we need to get

1345
01:22:25,926 --> 01:22:26,246
in sync.

1346
01:22:27,047 --> 01:22:28,388
And they would eat two packets.

1347
01:22:29,449 --> 01:22:32,431
To say, oh, my God, this whole stack of crates over here just got updated.

1348
01:22:32,891 --> 01:22:36,233
And all the guy you're standing in front of, the guy you're fighting, didn't get any bandwidth

1349
01:22:36,253 --> 01:22:36,774
during those two.

1350
01:22:37,474 --> 01:22:39,095
Because he wasn't panicked, he got an update recently.

1351
01:22:39,898 --> 01:22:41,099
And so we get lag artifacts from this.

1352
01:22:42,579 --> 01:22:43,260
Simple fix again.

1353
01:22:44,060 --> 01:22:47,542
Limit objects that can take this panic priority to a fixed number per packet.

1354
01:22:47,562 --> 01:22:52,365
So we always reserve space in the packet for the current live gameplay that matters.

1355
01:22:55,087 --> 01:22:55,407
All right.

1356
01:22:56,068 --> 01:22:58,509
Three rules of network optimization gleaned from all this.

1357
01:22:59,069 --> 01:23:00,630
First, measure twice, cut once.

1358
01:23:00,910 --> 01:23:03,892
Just like CPU optimization, use tools.

1359
01:23:04,953 --> 01:23:07,855
It will be worth the implementation time for the tools, I promise.

1360
01:23:09,745 --> 01:23:13,967
Second, in general, as long as you have some very basic encoding and compression, like

1361
01:23:14,007 --> 01:23:18,129
you're not mem copying vector threes into your packets, you're at least doing a little

1362
01:23:18,169 --> 01:23:24,132
bit of encoding and compression, you won't get much benefit out of looking at that further.

1363
01:23:24,332 --> 01:23:27,754
That mind goes, you know, empties out pretty quickly.

1364
01:23:28,994 --> 01:23:30,875
You need to look at the big picture, much like CPU perf.

1365
01:23:32,936 --> 01:23:37,078
Lastly, make friends with your game mechanics designers and coders because

1366
01:23:37,451 --> 01:23:41,933
As you probably saw, four of those five network optimizations were pretty much game mechanics

1367
01:23:41,973 --> 01:23:42,293
changes.

1368
01:23:42,493 --> 01:23:43,854
They were identifying and changing the game.

1369
01:23:45,074 --> 01:23:48,816
So you make friends with these guys, take them out to lunch and so on, and then abuse

1370
01:23:48,856 --> 01:23:49,516
those friendships.

1371
01:23:51,937 --> 01:23:52,498
Very important.

1372
01:23:53,938 --> 01:23:54,178
All right.

1373
01:23:54,459 --> 01:23:55,099
I'm almost done.

1374
01:23:55,119 --> 01:23:56,059
Less than five minutes to go.

1375
01:23:57,060 --> 01:23:57,180
It's 424.

1376
01:23:57,320 --> 01:23:59,761
Some of you may have to rush.

1377
01:24:00,441 --> 01:24:01,162
Tidbits in the future.

1378
01:24:01,182 --> 01:24:02,162
I want to leave you with a couple things.

1379
01:24:03,503 --> 01:24:05,003
First some numbers from Reach.

1380
01:24:05,063 --> 01:24:06,704
Some actual quantitative stuff.

1381
01:24:09,220 --> 01:24:11,802
Most important, I'm not going to read through all these, most important is the top number.

1382
01:24:12,723 --> 01:24:20,108
Our goal for Reach was to have 16-player games function on a 384-kilobit upstream consumer

1383
01:24:20,128 --> 01:24:22,590
connection, which we considered to be sort of the baseline DSL.

1384
01:24:24,791 --> 01:24:30,335
At the end, our Nerf tests showed us that we could have a solid game with no lag artifacts

1385
01:24:30,655 --> 01:24:35,478
with 250 kilobits per second of total bandwidth in a 16-player game.

1386
01:24:37,260 --> 01:24:38,160
We were very happy with this.

1387
01:24:41,688 --> 01:24:44,590
Related best practices. These are not strictly related to gameplay networking, but they're

1388
01:24:44,610 --> 01:24:51,537
really important. First, flow and congestion control. Just dumping stuff into sockets until

1389
01:24:51,557 --> 01:24:55,881
the connection gives up the ghost or floods or starts dropping packets, not optimal for

1390
01:24:55,901 --> 01:24:58,803
the quality of your game. If you implement your own flow and congestion control, you

1391
01:24:58,823 --> 01:25:03,547
can guarantee the ability to send responsive data at all times or send low latency data

1392
01:25:03,567 --> 01:25:03,988
at all times.

1393
01:25:06,450 --> 01:25:09,953
Once you have that flow control layer, you can record the quality of each individual

1394
01:25:09,973 --> 01:25:12,915
player's connection, record how good their upstream is and how stable their connection

1395
01:25:12,975 --> 01:25:13,055
is.

1396
01:25:13,836 --> 01:25:16,618
You can save those records and then you can use that to drive your host selection.

1397
01:25:18,980 --> 01:25:23,304
The benefit we got from smarter host selection in Reach was on the same order as the benefit

1398
01:25:23,324 --> 01:25:28,888
we got from bandwidth optimizations, because finally we were actually able to select the

1399
01:25:28,928 --> 01:25:33,072
good hosts, select the guys with the university connections, the guys with the megabit up

1400
01:25:33,832 --> 01:25:35,213
and completely rock-solid connections.

1401
01:25:37,625 --> 01:25:42,788
Third, host migration. This is hard to add. Players love it. Really nice for gameplay

1402
01:25:42,808 --> 01:25:45,930
networking quality because if you have a bad host, if a host is having a bad day because

1403
01:25:45,970 --> 01:25:51,033
his wife is downloading Netflix or whatever, you can host migrate in the middle of the

1404
01:25:51,053 --> 01:25:54,755
game to a better host and get rid of all the lag artifacts in five or ten seconds instead

1405
01:25:54,775 --> 01:26:00,719
of forcing players to live with them. Consider having a multiplayer beta or demo.

1406
01:26:02,653 --> 01:26:07,954
All the top multiplayer games, Gears is doing this, COD does this. It's become almost common

1407
01:26:07,974 --> 01:26:11,314
practice, but definitely do it. You can get a tremendous amount of test coverage from

1408
01:26:11,354 --> 01:26:13,815
this. We would not have shipped anywhere near our quality if we did not.

1409
01:26:16,055 --> 01:26:19,656
Use regular internal play tests with traffic shaping to measure your game mechanics under

1410
01:26:19,836 --> 01:26:27,557
some levels of latency. If you play everything in a system link game, it's not going to be

1411
01:26:27,577 --> 01:26:31,378
or pardon me, a LAN game, you're not going to get an accurate picture of how your game

1412
01:26:31,418 --> 01:26:32,018
plays on the Internet.

1413
01:26:33,755 --> 01:26:37,478
Consider having full-time network testers. This is something that Bungie has, which I

1414
01:26:37,518 --> 01:26:41,842
had never seen before in networking on past games, and it was something of a revelation.

1415
01:26:42,642 --> 01:26:46,886
We have guys, a guy in pre-production and then more guys later on in the project, whose

1416
01:26:47,106 --> 01:26:55,673
only job is to stress and attack the networking of the game. These guys will keep your game

1417
01:26:55,693 --> 01:26:59,296
mechanics designers and your network programmers honest, and they will give you an accurate

1418
01:26:59,316 --> 01:27:02,058
picture of the quality of your game, of your networking over time.

1419
01:27:04,748 --> 01:27:08,231
A few more resources, a couple of papers you can read, this deck will be online.

1420
01:27:09,051 --> 01:27:12,094
These give you some sort of more high-level information and more detail on the replication

1421
01:27:12,114 --> 01:27:12,514
protocols.

1422
01:27:15,277 --> 01:27:18,860
Many many people worked to make Halo Reach play as well as it does online, especially

1423
01:27:19,600 --> 01:27:20,341
these guys.

1424
01:27:22,323 --> 01:27:28,228
Nick Giron, Paul Llewellyn, John Cable, and our fearless leader, Luke Timmons, the lead

1425
01:27:28,248 --> 01:27:29,649
of our networking and UI group.

1426
01:27:33,003 --> 01:27:39,748
Lastly, just sort of a quick look at the future. Our system is not completely perfect. We have

1427
01:27:40,829 --> 01:27:43,791
usability improvements to our replication systems we want to implement. Currently it

1428
01:27:43,811 --> 01:27:49,696
takes a lot of boilerplate code to implement new mechanics. So we want to fix that.

1429
01:27:50,336 --> 01:27:55,340
We also want to extend our protocols to support more low-bandwidth, complex use cases. Like,

1430
01:27:55,400 --> 01:27:58,042
I have a state machine off here in the corner. I just want it to be networked. I don't want

1431
01:27:58,062 --> 01:28:00,685
to get a Ph.D. in replication. I don't want to think about it. I just want this to work.

1432
01:28:01,218 --> 01:28:03,779
state machine to stay in sync on multiple boxes. We want to make that sort of thing

1433
01:28:03,859 --> 01:28:04,059
easy.

1434
01:28:07,080 --> 01:28:13,382
But, of course, the real question here is what's really next for Bungie? What are we

1435
01:28:13,442 --> 01:28:20,304
doing? If you've been paying attention to the news recently, you may have heard the

1436
01:28:20,344 --> 01:28:27,346
rumor as propounded by Kotaku and others that we're making World of Warcraft in space. As

1437
01:28:27,386 --> 01:28:29,947
cool as that sounds, that's not true. That's not what we're doing.

1438
01:28:32,670 --> 01:28:40,358
The only thing I can tell you today is that if you love working on or playing massively

1439
01:28:41,780 --> 01:28:46,906
awesome multiplayer online action games, you should come talk to us.

1440
01:28:47,266 --> 01:28:49,909
We are hiring across all disciplines for many positions.

1441
01:28:53,173 --> 01:28:53,953
I will now take questions.

1442
01:29:06,310 --> 01:29:07,691
It is 429.

1443
01:29:08,711 --> 01:29:11,793
If your talk is also, if your talk you're going to at 430 is in South Hall, you can

1444
01:29:11,813 --> 01:29:12,394
totally do it.

1445
01:29:14,195 --> 01:29:15,736
But I'm sure the Q&A will be interesting too.

1446
01:29:21,479 --> 01:29:23,981
Yes.

1447
01:29:27,483 --> 01:29:28,383
On the grenade throw, yes.

1448
01:29:28,944 --> 01:29:29,404
There is.

1449
01:29:29,904 --> 01:29:31,325
Firstly, because we didn't need to.

1450
01:29:32,326 --> 01:29:39,070
because we had happened upon this other design which players were okay with, and so we never

1451
01:29:39,090 --> 01:29:43,814
really revisited it. Secondly, because it actually would not have worked for the grenade

1452
01:29:43,834 --> 01:29:47,976
throw because there's a very specific expectation that clients have, or that players have, in

1453
01:29:48,016 --> 01:29:54,321
Halo, which is that their grenade aiming is sampled at the release frame. It is not sampled

1454
01:29:54,341 --> 01:29:58,083
when they push the button, or at any time earlier. And players are very attuned to this.

1455
01:29:59,802 --> 01:30:02,522
hit the button when they know they're thinking about throwing a grenade, and then they'll

1456
01:30:02,602 --> 01:30:04,062
aim it during the little telegraph.

1457
01:30:04,583 --> 01:30:08,463
So doing anything where we lock in the aiming before that release frame wouldn't work.

1458
01:30:09,944 --> 01:30:13,404
Please also, there will be many more questions, but please fill out your sheets.

1459
01:30:14,484 --> 01:30:16,125
The correct way to do that is to circle the excellent.

1460
01:30:16,705 --> 01:30:18,485
But please fill them out.

1461
01:30:21,286 --> 01:30:21,426
Yes?

1462
01:30:28,643 --> 01:30:32,487
There are two phases to the question was how do we handle host migration in particular

1463
01:30:32,507 --> 01:30:34,528
when the server just vanishes off the face of the planet.

1464
01:30:34,889 --> 01:30:35,810
There are two phases to this.

1465
01:30:37,231 --> 01:30:40,174
If the server just drops ungracefully, the first thing we have to do is what we call

1466
01:30:40,194 --> 01:30:46,560
a host election, which is a distributed algorithm to determine for all the individual sort of

1467
01:30:46,620 --> 01:30:50,283
leaderless peers that remain to determine to elect a new host among themselves.

1468
01:30:51,865 --> 01:30:53,106
Once they have elected a new host...

1469
01:30:53,768 --> 01:30:57,689
The actual process of doing a, doing gameplay host migration is very, very complicated.

1470
01:30:57,709 --> 01:30:58,710
It could be a talk in itself.

1471
01:30:59,450 --> 01:31:07,312
The core of it is that in most cases, the new host takes his current game state, reinitializes

1472
01:31:07,392 --> 01:31:12,074
his networking state, his replication state from that, does a consistency pass to look

1473
01:31:12,114 --> 01:31:15,995
for anything that might be, might have been out of sync because at the time that the host

1474
01:31:16,015 --> 01:31:19,216
migration occurred, he was in the middle of receiving network data, things like that.

1475
01:31:20,217 --> 01:31:23,078
And then he becomes the new host and everybody joins in progress to him.

1476
01:31:24,162 --> 01:31:27,663
Joining Progress is fairly simple because we have this split between state data and

1477
01:31:27,703 --> 01:31:28,043
events.

1478
01:31:28,763 --> 01:31:32,485
To join a game, all you need is all the current state data, and you're guaranteed to be in

1479
01:31:32,505 --> 01:31:34,185
sync with all of the current network state of the game.

1480
01:31:45,489 --> 01:31:46,350
I'm sorry, can you speak louder?

1481
01:31:57,331 --> 01:32:02,775
Yes, and that is sort of what the state data panicking that I mentioned gives us, the priority

1482
01:32:02,815 --> 01:32:04,856
panicking where we ratchet up priorities over time.

1483
01:32:05,697 --> 01:32:08,699
Nothing in the game is more than a couple seconds out of date on any peer.

1484
01:32:09,219 --> 01:32:12,241
So if something is truly irrelevant to you, you'll get updates, and it's moving, you'll

1485
01:32:12,261 --> 01:32:14,683
get updates about it every couple seconds instead of every frame.

1486
01:32:16,758 --> 01:32:21,682
If you do not have, there's one special case which is interesting, if you do not have the

1487
01:32:22,222 --> 01:32:26,185
current game state, because for example the host dropped off the face of the earth while

1488
01:32:26,205 --> 01:32:29,427
the game was starting up before the original host could tell everyone what was happening

1489
01:32:29,448 --> 01:32:35,132
in the game, we call this a double host migration and we have to initialize the world from a

1490
01:32:35,172 --> 01:32:39,135
clean slate and just, we inherit only the statistics data like the current score and

1491
01:32:39,155 --> 01:32:40,756
things like that and we'll reset all the game state.

1492
01:32:41,236 --> 01:32:44,959
That happens fairly rarely because in normal gameplay it requires two hosts to fail in

1493
01:32:44,999 --> 01:32:45,620
rapid succession.

1494
01:32:55,855 --> 01:32:56,055
Yes.

1495
01:32:59,517 --> 01:33:01,658
Priority and relevance is a very interesting thing.

1496
01:33:01,738 --> 01:33:03,779
It's possible that it's overengineered.

1497
01:33:03,799 --> 01:33:07,001
It's not something that's unknown at Bungie.

1498
01:33:07,741 --> 01:33:13,644
The idea, the way we think about it is, relevance is a pure metric of how noticeable something

1499
01:33:13,724 --> 01:33:13,844
is.

1500
01:33:14,024 --> 01:33:16,866
So relevance is calculated purely by, is it on screen?

1501
01:33:17,166 --> 01:33:17,986
How far away is it?

1502
01:33:18,046 --> 01:33:18,866
What is its radius?

1503
01:33:19,387 --> 01:33:21,508
What is its perceptual, like, slice of the screen?

1504
01:33:22,579 --> 01:33:25,980
Sort of very pure things like that that don't take into account game mechanics or what type

1505
01:33:26,000 --> 01:33:26,620
of object it is.

1506
01:33:27,341 --> 01:33:29,661
And that's sort of an algorithm we can write in isolation.

1507
01:33:30,201 --> 01:33:33,542
Then we take out all those relevances for all the different objects and we mix in special

1508
01:33:33,582 --> 01:33:37,123
rules like what type of object are you, have you damaged the player recently, things like

1509
01:33:37,143 --> 01:33:37,283
this.

1510
01:33:38,084 --> 01:33:41,565
And the output of that set of rules is what gives you priority.

1511
01:33:41,745 --> 01:33:46,586
And that just gives us a nice sort of split for being able to evaluate each algorithm

1512
01:33:46,606 --> 01:33:47,226
in isolation.

1513
01:33:47,926 --> 01:33:48,927
We could mix it together.

1514
01:33:48,947 --> 01:33:49,867
It's a detail.

1515
01:33:49,887 --> 01:33:49,967
Next.

1516
01:33:50,807 --> 01:33:51,007
Thank you.

1517
01:34:04,632 --> 01:34:04,892
Sure.

1518
01:34:06,152 --> 01:34:09,293
The question is who is authoritative over hits when you're dealing with bipeds that

1519
01:34:09,333 --> 01:34:11,313
are all in slightly different positions on all the boxes.

1520
01:34:12,373 --> 01:34:17,614
How we do networked aim assist with networked bullets and networked damage could be a talk

1521
01:34:17,674 --> 01:34:18,234
all on its own.

1522
01:34:19,594 --> 01:34:21,275
And in fact, one version of this talk was that.

1523
01:34:22,102 --> 01:34:25,005
Let me see if I can give a quick summary.

1524
01:34:25,905 --> 01:34:31,530
The core idea of that is at the moment bullets are fired, we do not transmit the world space

1525
01:34:31,610 --> 01:34:32,891
vector of what you are shooting.

1526
01:34:33,411 --> 01:34:38,496
We transmit a target relative vector, which says you're shooting relative to this target

1527
01:34:38,536 --> 01:34:42,399
who is likely the guy you're trying to hurt with a particular lead vector.

1528
01:34:42,959 --> 01:34:47,163
On remote boxes, including the host, your bullet is reconstructed to have the same lead.

1529
01:34:48,604 --> 01:34:50,445
The bullet is then simulated on all peers.

1530
01:34:50,794 --> 01:34:53,456
and on the host peer, when it hits someone, it will deal damage.

1531
01:34:54,557 --> 01:34:57,500
That's the broad stroke of it. There's a lot more interesting stuff like

1532
01:34:57,820 --> 01:35:00,142
how we deal with rockets versus machine guns, and

1533
01:35:00,983 --> 01:35:03,004
how we deal with the really interesting case of

1534
01:35:04,405 --> 01:35:09,289
you pull the trigger and fire your gun, and then before your bullet, your fire

1535
01:35:09,330 --> 01:35:13,093
request reaches the host, you die on the host. So when he gets it,

1536
01:35:13,133 --> 01:35:15,855
he's like, oh, you think you fired your gun, like you saw a muzzle flash on your

1537
01:35:15,875 --> 01:35:16,936
screen, but you're dead.

1538
01:35:18,682 --> 01:35:19,363
How do you deal with that?

1539
01:35:19,643 --> 01:35:25,005
And the answer is that in most cases we have sanity checks and whatnot, but we will construct

1540
01:35:25,105 --> 01:35:30,948
a fake new gun out of whole cloth, fire the bullet, and then delete it.

1541
01:35:32,249 --> 01:35:35,730
Specifically so that whenever you see a muzzle flash, like, you will generally get your bullet

1542
01:35:35,750 --> 01:35:37,471
shot with correct aim assist and all that sort of thing.

1543
01:35:52,016 --> 01:36:07,499
Yes. So your question is about the splicing of the profiler data into the films and how

1544
01:36:07,539 --> 01:36:13,380
we get the data about every client into one film. The answer is that the host film...

1545
01:36:13,893 --> 01:36:19,417
includes all of the upstream and downstream that he experienced. So it includes everything

1546
01:36:19,437 --> 01:36:24,060
he sent to every client, everything every client sent to him. Um, and every individual

1547
01:36:24,100 --> 01:36:28,583
client film only includes their traffic, only includes their upstream and downstream. Um,

1548
01:36:29,363 --> 01:36:32,565
so the way, the way that we investigate these things is we always work from the host film.

1549
01:36:43,053 --> 01:36:49,218
If you are watching a film in Halo Reach, a user-facing retail film that was recorded

1550
01:36:49,258 --> 01:36:54,102
by a client box and the game had any sort of bandwidth limitation, if you then detach

1551
01:36:54,122 --> 01:36:56,945
the camera from that guy's view and go fly and look at the other side of the map, you

1552
01:36:56,985 --> 01:37:00,168
will see certain artifacts. You will see objects updating once a second, things like that.

1553
01:37:05,733 --> 01:37:05,853
Yes.

1554
01:37:13,736 --> 01:37:22,260
I'm sure that's exactly how the post-dent job basically looks like before we move time

1555
01:37:22,280 --> 01:37:25,101
forward and applying for the moment that it's done.

1556
01:37:25,121 --> 01:37:28,002
This is short-term, I think, for the current time.

1557
01:37:28,042 --> 01:37:28,322
Correct.

1558
01:37:28,422 --> 01:37:33,724
I'm sure they're also under all of the other products, because I assume that that

1559
01:37:33,884 --> 01:37:35,625
animation is on the same length.

1560
01:37:35,645 --> 01:37:36,525
Do you think that is not a risk?

1561
01:37:36,545 --> 01:37:36,625
Yes.

1562
01:37:36,725 --> 01:37:36,905
Okay.

1563
01:37:37,666 --> 01:37:41,407
Thank you.

1564
01:37:42,272 --> 01:37:46,154
I'm not going to repeat that question because it was very long. I hope everyone heard it.

1565
01:37:46,974 --> 01:37:51,937
The way that works is the appearance of the shield on a guy who is armor locking is always

1566
01:37:51,997 --> 01:37:55,619
host authoritative. It is always transmitted from the host to everyone, including both

1567
01:37:55,659 --> 01:38:02,063
the user and viewers. So the fact that the host shortens the timer automatically causes

1568
01:38:02,103 --> 01:38:05,645
the shield to appear early on every other box. So we don't have to worry about that.

1569
01:38:08,575 --> 01:38:10,877
Yes, we don't short circuit the animation in any way.

1570
01:38:10,917 --> 01:38:13,398
Just the blue shield will appear at frame one or whatever.

1571
01:38:15,339 --> 01:38:15,699
Sure, sure.

1572
01:38:18,240 --> 01:38:18,400
Hi.

1573
01:38:21,002 --> 01:38:21,202
Yes.

1574
01:38:24,303 --> 01:38:24,903
Good question.

1575
01:38:28,705 --> 01:38:29,566
Good question.

1576
01:38:29,706 --> 01:38:30,666
Fantastic question.

1577
01:38:30,686 --> 01:38:31,267
I love that question.

1578
01:38:32,747 --> 01:38:34,388
It does not work at the field level.

1579
01:38:34,568 --> 01:38:37,390
The priority is per object for state data.

1580
01:38:38,401 --> 01:38:43,963
However, we do look at which fields are dirty, which fields currently need to be sent, and

1581
01:38:43,983 --> 01:38:46,664
we use that to bias priorities in some ways.

1582
01:38:46,784 --> 01:38:51,366
So for example, if the state of whether you are alive or dead has changed, your priority

1583
01:38:51,406 --> 01:38:53,587
is quite high, because almost everyone needs to know that.

1584
01:38:54,908 --> 01:38:56,348
So we do a little bit of work with that.

1585
01:38:56,769 --> 01:39:00,930
There's a lot of fancier stuff we could do, like, oh, how dirty is your position?

1586
01:39:01,211 --> 01:39:04,912
Like, your position could be dirty by a centimeter, and we'll send it, and it doesn't, we don't

1587
01:39:04,952 --> 01:39:05,112
really...

1588
01:39:05,502 --> 01:39:08,443
feed that into our prioritization versus something that's, you know, rolling down a hill rapidly

1589
01:39:08,483 --> 01:39:13,824
and has a ten foot dirty position. We are considering adding stuff like that. Currently

1590
01:39:13,904 --> 01:39:19,606
we are constrained primarily by CPU perf in the complexity of our prioritization algorithm.

1591
01:39:20,066 --> 01:39:25,167
Uh, the total prioritization cost for a host at maximum bandwidth, 600 kilobits-ish, um,

1592
01:39:26,147 --> 01:39:35,090
is around 1.8 milliseconds on the, on the, on a single 360 hardware thread, so, yeah.

1593
01:39:35,110 --> 01:39:35,190
Sure.

1594
01:39:46,853 --> 01:39:47,574
Very good question.

1595
01:39:48,875 --> 01:39:54,900
The state data updates are not ordered with respect to each other.

1596
01:39:56,181 --> 01:40:00,525
You can absolutely get, you will, out of order is an interesting question.

1597
01:40:00,785 --> 01:40:02,326
So you can absolutely have this scenario.

1598
01:40:02,687 --> 01:40:05,869
You can have an object change in two linked ways.

1599
01:40:09,354 --> 01:40:10,995
His position changes and his health changes.

1600
01:40:11,276 --> 01:40:15,739
Those updates can be sent in separate packets, which means that the client can absolutely

1601
01:40:15,779 --> 01:40:17,160
get one of them without the other.

1602
01:40:17,200 --> 01:40:21,463
So if there's any sort of interplay between those two properties, there are vulnerabilities

1603
01:40:21,523 --> 01:40:24,025
there where clients can have sort of inconsistent state briefly.

1604
01:40:25,646 --> 01:40:32,892
The only guarantee we provide is that we will never apply old state data updates about an

1605
01:40:32,972 --> 01:40:33,312
object.

1606
01:40:35,373 --> 01:40:36,894
So if you have a

1607
01:40:37,727 --> 01:40:40,428
you have a state that update about the position of an object and then another one following

1608
01:40:40,448 --> 01:40:43,829
it on the wire and they get crossed, packet reordering on the internet happens all the

1609
01:40:44,369 --> 01:40:47,670
time. We will apply the first one that arrives and then we will notice that the other one

1610
01:40:47,730 --> 01:40:51,011
is older for that entity and we will discard it. And that's important because otherwise

1611
01:40:51,031 --> 01:40:54,232
you lose the guarantee that you will eventually converge to the final state.

1612
01:40:57,113 --> 01:40:57,293
Sure.

1613
01:41:18,864 --> 01:41:20,645
for actually figuring out how functions work

1614
01:41:20,665 --> 01:41:21,786
in that simulated game of puzzle pieces

1615
01:41:21,806 --> 01:41:23,146
where it makes you wonder if you're doing that

1616
01:41:23,206 --> 01:41:24,347
because of occluders and things like that?

1617
01:41:24,367 --> 01:41:25,147
Good question, good question.

1618
01:41:25,167 --> 01:41:26,128
We are not considering occluders.

1619
01:41:26,148 --> 01:41:27,709
You're quite right that evaluating that sort of thing

1620
01:41:27,729 --> 01:41:28,949
for every potential player camera

1621
01:41:28,969 --> 01:41:30,590
would be prohibitively costly on the CPU.

1622
01:41:30,630 --> 01:41:33,651
So it's purely based on metrics that we can derive

1623
01:41:33,691 --> 01:41:35,232
without doing massive work like that.

1624
01:41:35,884 --> 01:41:40,446
Um, we do have fairly accurate information about every player's, uh, camera position

1625
01:41:40,466 --> 01:41:41,206
and orientation.

1626
01:41:41,847 --> 01:41:44,228
We, we do a lot of work to, to make that happen.

1627
01:41:44,588 --> 01:41:47,289
Um, fortunately for us, client to host bandwidth is very cheap.

1628
01:41:48,110 --> 01:41:53,193
So we can shove extra data into the control data for the client to host about like, here's

1629
01:41:53,233 --> 01:41:56,354
my current camera position because I know you can't predict it because I'm using a third

1630
01:41:56,394 --> 01:41:57,935
person camera on my vehicle right now.

1631
01:41:57,975 --> 01:41:58,415
Things like that.

1632
01:41:59,417 --> 01:42:02,818
Or I'm on, I'm dead and I'm currently like flying around the world in this flying camera

1633
01:42:03,038 --> 01:42:07,379
or orbiting camera on various teammates. We'll transmit that data explicitly to the host

1634
01:42:07,399 --> 01:42:09,459
so he can use it, but yeah, no occluders, nothing like that.

1635
01:42:22,463 --> 01:42:27,064
Okay, fair enough. I guess, I guess accurate may be the wrong word. Like yeah, we can't,

1636
01:42:27,264 --> 01:42:28,344
we can't guarantee that like

1637
01:42:28,818 --> 01:42:32,720
at the time this data gets to that client, the camera position and orientation we use

1638
01:42:32,840 --> 01:42:36,121
to fill that packet will be the same as his camera. That's complete nonsense, of course.

1639
01:42:36,842 --> 01:42:40,983
Yeah, to some extent, like, by at least round-trip time, he can turn his camera, do whatever

1640
01:42:41,003 --> 01:42:48,826
he wants to. To that extent, he can see artifacts that the prioritization system would have

1641
01:42:48,866 --> 01:42:52,588
blocked. Like, we could have some off-screen thing that we deprioritize. He looks towards

1642
01:42:52,668 --> 01:42:54,828
it and he sees under the underbelly, right?

1643
01:42:55,795 --> 01:42:59,959
The way we handle that is we limit the amount of deprioritization we do for things that

1644
01:42:59,999 --> 01:43:02,041
are off camera because that can change very quickly.

1645
01:43:02,061 --> 01:43:04,744
We are primarily based on distance because that's harder to change quickly.

1646
01:43:05,244 --> 01:43:07,386
And we use a frustum with a wider FOV than the basic one for on-screen tests.

1647
01:43:07,406 --> 01:43:07,486
Sure.

1648
01:43:07,506 --> 01:43:07,686
All right.

1649
01:43:07,706 --> 01:43:07,887
All right.

1650
01:43:07,947 --> 01:43:08,167
All right.

1651
01:43:08,187 --> 01:43:08,427
All right.

1652
01:43:08,447 --> 01:43:08,627
All right.

1653
01:43:08,647 --> 01:43:08,848
All right.

1654
01:43:08,868 --> 01:43:09,088
All right.

1655
01:43:09,108 --> 01:43:10,549
All right.

1656
01:43:10,589 --> 01:43:11,250
All right.

1657
01:43:11,270 --> 01:43:11,450
All right.

1658
01:43:11,470 --> 01:43:12,231
All right.

1659
01:43:13,592 --> 01:43:14,253
All right.

1660
01:43:14,273 --> 01:43:14,453
All right.

1661
01:43:14,473 --> 01:43:14,653
All right.

1662
01:43:14,673 --> 01:43:15,334
All right.

1663
01:43:17,666 --> 01:43:30,652
So, big what, sorry?

1664
01:43:32,033 --> 01:43:32,733
Yes, absolutely.

1665
01:43:42,438 --> 01:43:46,520
As far as vehicle populations and using that to sort of limit network problems.

1666
01:43:47,108 --> 01:43:52,491
On Reach we are entirely bound by CPU costs for pretty much everything we do.

1667
01:43:53,291 --> 01:43:57,134
So we do not limit object counts for networking reasons at all.

1668
01:43:58,234 --> 01:44:05,459
We can support something on the order of 30 vehicles maybe, like 30 full suspension vehicles

1669
01:44:05,919 --> 01:44:10,221
in addition to the 16 players before networking will start to run into problems or, you know,

1670
01:44:10,361 --> 01:44:11,582
gradually degrading priority.

1671
01:44:12,847 --> 01:44:16,610
To answer your question specifically, yes, vehicle updates are a huge amount of bandwidth

1672
01:44:16,630 --> 01:44:17,410
because they are huge.

1673
01:44:17,430 --> 01:44:18,291
They are highly noticeable.

1674
01:44:18,331 --> 01:44:19,252
Players care about them a lot.

1675
01:44:19,272 --> 01:44:19,912
They catch the eye.

1676
01:44:20,613 --> 01:44:22,635
In Halo 3, we spent a lot of perf on them.

1677
01:44:24,296 --> 01:44:27,358
In Reach, we actually had a major development initiative to fix that.

1678
01:44:27,959 --> 01:44:29,760
I can talk about that because we have a few more minutes.

1679
01:44:29,940 --> 01:44:30,541
It's pretty interesting.

1680
01:44:31,241 --> 01:44:34,584
So in Halo 3, we had a blending system which we used on bipeds.

1681
01:44:34,804 --> 01:44:39,288
So when you got a network update about a biped and it was out of sync by some amount, some

1682
01:44:39,308 --> 01:44:42,190
number of feet, and you had to sort of fix up, get in sync with the host.

1683
01:44:42,864 --> 01:44:47,488
We did this visual-only interpolation that I mentioned with assassinations where your

1684
01:44:48,028 --> 01:44:51,632
logical state warps and your physics state warps to that location, but your body gets

1685
01:44:51,652 --> 01:44:54,794
this little blend, this little exponential blend that consumes the error as you continue

1686
01:44:54,814 --> 01:44:55,515
to predict forward.

1687
01:44:55,555 --> 01:44:56,195
So it looks pretty good.

1688
01:44:57,116 --> 01:45:04,522
For vehicles, we couldn't do this in Halo 3 because of their interaction with Havok.

1689
01:45:05,163 --> 01:45:08,766
Blending vehicles turned out to be very complicated because of the level of complexity of their

1690
01:45:08,866 --> 01:45:11,528
rigid body hierarchy as it was represented in Havok.

1691
01:45:11,949 --> 01:45:17,751
and because of annoying issues like the dirt kicked up by the warthog's tires is based

1692
01:45:17,811 --> 01:45:22,212
on an impact system that is driven from havoc contact points of the wheels on the ground.

1693
01:45:22,252 --> 01:45:25,613
So when you warp the physics, all the dirt starts coming up from the new locations and

1694
01:45:25,633 --> 01:45:29,175
the fact that you're blending this object to it looks like garbage, like you're clearly

1695
01:45:29,215 --> 01:45:29,555
cheating.

1696
01:45:31,295 --> 01:45:36,317
So we, for Reach, we rewrote that system, that visual interpolation system to work with

1697
01:45:36,337 --> 01:45:36,997
all object types.

1698
01:45:37,057 --> 01:45:40,698
We fixed all the issues with vehicles, so we would calculate, you know, the transform

1699
01:45:40,758 --> 01:45:41,178
from the... .

1700
01:45:42,338 --> 01:45:46,682
the visual object to the real physics object and the inverse of that and we would use that

1701
01:45:46,702 --> 01:45:50,425
to move things around as needed. So any visual represent, any visual element like a dirt

1702
01:45:50,445 --> 01:45:55,389
from my wheel would get blended back to the visual position to correspond with the visual

1703
01:45:55,409 --> 01:46:00,133
mesh being blended. The result of that is that we could cut down our vehicle update

1704
01:46:00,173 --> 01:46:05,497
rates a lot. On Halo 3, we tried very, very hard to keep vehicles at 20 updates a second,

1705
01:46:05,778 --> 01:46:08,880
rarely below 15 because they were very high priorities, how we did that.

1706
01:46:09,847 --> 01:46:13,049
because they look really bad when they warped because we didn't have any blending. With

1707
01:46:13,069 --> 01:46:18,312
this blending, we found we could drop vehicles to anywhere down to like five updates a second

1708
01:46:18,532 --> 01:46:32,782
and they would look good. It is graphed very specifically, very precisely. The logical

1709
01:46:32,822 --> 01:46:37,325
position of the object is warped immediately. The Havok representation, all the rigid bodies

1710
01:46:37,365 --> 01:46:38,445
and things are warped immediately.

1711
01:46:39,220 --> 01:46:43,824
which allows you to do, you guarantee that the guy will be able to run, um, he won't run into

1712
01:46:43,844 --> 01:46:48,907
invisible walls, for example. Um, that's a bad example. Let me finish and I'll go back to that.

1713
01:46:49,548 --> 01:46:53,511
The visual representation and the, what we call the collision representation, which is

1714
01:46:53,571 --> 01:46:57,674
distinct from physics, are blended. And the collision representation is all the things

1715
01:46:57,694 --> 01:47:03,638
that can be shot. So if you shoot a guy who's blending and you see it hit his, his body, it

1716
01:47:03,658 --> 01:47:05,800
will actually do damage, it will be, it will work correctly.

1717
01:47:06,958 --> 01:47:18,849
So the thing I was saying about physics, the reason we have to warp physics is because you can have this case with like a thin wall and you're predicting that you're running on the right side of the wall and then you get an update that says, oh no, you're on the left side of the wall and this is a solid wall but, you know, fairly thin.

1718
01:47:19,649 --> 01:47:29,998
If you try to blend physics and not warp it, it's very hard to get that to sort of consistently, well, it won't look right, Patek will predict all sorts of terrible things as you push the rigid body through the wall, right, it'll start exploding.

1719
01:47:30,507 --> 01:47:37,131
So we warp Havoc and the logical position to the other side of the wall so prediction can be happy and you know, think I'm on the right spot, everything's cool.

1720
01:47:37,511 --> 01:47:40,233
And then you get this visual only blend. Visual and collision blend.

1721
01:47:43,495 --> 01:47:45,076
That's great. Nobody's behind you.

1722
01:48:05,682 --> 01:48:14,944
Yeah. That's a very good question. When you are driving a vehicle in Halo, you have the

1723
01:48:14,964 --> 01:48:19,785
same level of control over it that you would normally have over your own biped. So the

1724
01:48:19,805 --> 01:48:20,885
way that works for the biped is...

1725
01:48:21,435 --> 01:48:24,617
you, as you're running around, you transmit your world space position and orientation

1726
01:48:24,637 --> 01:48:27,618
and other things to the host and he sort of copes with it. He applies the same blending

1727
01:48:27,658 --> 01:48:32,180
logic that clients use, unless it's insane and then of course he'll correct you. Vehicles

1728
01:48:32,200 --> 01:48:36,221
work the same way. As soon as you get into the driver's seat of a vehicle, your control

1729
01:48:36,241 --> 01:48:39,502
stream switches. Instead of sending your biped data, it sends your vehicle data, the host

1730
01:48:39,563 --> 01:48:43,344
copes with it, everyone blends all the way around and everything, you know, looks beautiful.

1731
01:48:43,384 --> 01:48:48,626
And yeah, there's no latency whatsoever. The client isn't actually authoritative technically

1732
01:48:48,646 --> 01:48:49,646
because he can be corrected.

1733
01:48:50,137 --> 01:48:51,461
but he's authoritative within his bubble.

1734
01:48:53,567 --> 01:48:57,719
Alright, thank you very much everybody.

