1
00:00:06,226 --> 00:00:07,246
Hi, I'm Josh Menke.

2
00:00:07,607 --> 00:00:09,608
Welcome to my talk on machine learning

3
00:00:09,668 --> 00:00:11,309
for optimal matchmaking.

4
00:00:11,890 --> 00:00:13,551
Now, I've been working in matchmaking

5
00:00:13,591 --> 00:00:15,333
for over 16 years at this point,

6
00:00:15,833 --> 00:00:18,095
and I actually do have a background in machine learning,

7
00:00:18,695 --> 00:00:20,817
but I've never actually seen the two combined.

8
00:00:21,757 --> 00:00:24,920
I've used machine learning to figure out player skills,

9
00:00:25,300 --> 00:00:27,962
but that's just a number that goes into matchmaking.

10
00:00:28,383 --> 00:00:29,984
I've never actually used machine learning

11
00:00:30,344 --> 00:00:31,765
to do the matchmaking itself.

12
00:00:32,326 --> 00:00:35,388
And in this case, I'm not actually the creator

13
00:00:35,648 --> 00:00:37,049
of what I'll be talking about today.

14
00:00:37,410 --> 00:00:38,931
I'm a consumer of it, a client.

15
00:00:39,231 --> 00:00:41,452
The person who actually did all the work and the research

16
00:00:41,493 --> 00:00:42,994
and came up with this really nice method,

17
00:00:43,034 --> 00:00:44,134
his name is Tom Minka,

18
00:00:44,675 --> 00:00:46,996
and he is a researcher at Microsoft Research.

19
00:00:47,537 --> 00:00:50,079
I work for 343 Industries on Halo,

20
00:00:50,599 --> 00:00:53,661
and I'm one of the clients of this work,

21
00:00:54,061 --> 00:00:55,683
along with Ryan Clevin, who is...

22
00:00:56,603 --> 00:00:59,744
worked on Gears of War at the Coalition.

23
00:00:59,904 --> 00:01:03,925
We both had interest in improving matchmaking

24
00:01:03,965 --> 00:01:04,705
through machine learning.

25
00:01:05,345 --> 00:01:08,166
And I will say in my over 16 years of matchmaking,

26
00:01:08,206 --> 00:01:10,666
this is probably the biggest leap forward I've seen

27
00:01:11,107 --> 00:01:13,027
in terms of how you do matchmaking.

28
00:01:13,087 --> 00:01:14,007
So I hope you enjoy it.

29
00:01:14,327 --> 00:01:14,967
I think it's great.

30
00:01:15,308 --> 00:01:16,248
And let's get on with the talk.

31
00:01:17,708 --> 00:01:19,949
So let's first explain what type of matchmaking

32
00:01:19,969 --> 00:01:21,229
we're actually talking about.

33
00:01:21,877 --> 00:01:25,338
Matchmaking is the way that players in competitive multiplayer games

34
00:01:25,718 --> 00:01:28,198
find other players to compete against and play with.

35
00:01:28,919 --> 00:01:32,239
And so the way this works is you have a group of players who wants to play a

36
00:01:32,279 --> 00:01:35,060
match, and these players could be submitting

37
00:01:35,360 --> 00:01:38,200
a request to matchmake from all over the world, not necessarily together,

38
00:01:38,860 --> 00:01:41,781
but they want to match. And so they send some information to a matchmaker,

39
00:01:42,121 --> 00:01:44,602
something about their skill, their location,

40
00:01:45,162 --> 00:01:47,902
other information that could be useful. Don't worry too much about that yet.

41
00:01:48,615 --> 00:01:51,235
And then that information is then used by the matchmaker

42
00:01:51,415 --> 00:01:53,676
to place these players into matches and into teams

43
00:01:53,736 --> 00:01:54,636
to play against each other.

44
00:01:55,256 --> 00:01:57,917
That's the type of matchmaking that we'll be working with today

45
00:01:57,937 --> 00:01:59,197
and talking about how to improve.

46
00:02:00,357 --> 00:02:02,478
And since we're talking about using machine learning,

47
00:02:02,518 --> 00:02:04,098
we should probably define that as well.

48
00:02:04,738 --> 00:02:07,319
So for this talk, a simple definition we can use

49
00:02:07,359 --> 00:02:10,540
of machine learning is an algorithm that tunes itself

50
00:02:10,940 --> 00:02:13,980
using data rather than being tuned by hand.

51
00:02:14,879 --> 00:02:17,461
Now, we may be asking, how do we put these together?

52
00:02:17,641 --> 00:02:21,665
Well, matchmaking algorithms are traditionally tuned by hand.

53
00:02:22,305 --> 00:02:23,726
And what we're going to suggest is

54
00:02:24,107 --> 00:02:27,370
we can use machine learning to tune our matchmaking algorithms

55
00:02:27,550 --> 00:02:29,952
automatically instead from the data.

56
00:02:31,253 --> 00:02:34,156
So let's talk first about how matchmaking is done today.

57
00:02:35,057 --> 00:02:36,938
So the state of the art matchmaking today

58
00:02:37,158 --> 00:02:38,359
is pretty much like this.

59
00:02:39,344 --> 00:02:42,265
You put the players go in, the matchmaker kind of hopes

60
00:02:42,285 --> 00:02:44,686
that it can make the best possible match out of the players

61
00:02:45,607 --> 00:02:47,468
and then it waits and eventually it settles

62
00:02:47,548 --> 00:02:48,188
for something worse.

63
00:02:48,448 --> 00:02:50,409
And that goes across whatever you're matchmaking on.

64
00:02:50,809 --> 00:02:54,271
But for example, for skill, the matchmaker sees a player

65
00:02:54,291 --> 00:02:56,872
and it hopes to find the same skilled player

66
00:02:56,912 --> 00:02:58,573
for that player to match with.

67
00:02:59,513 --> 00:03:01,854
And if it can't, it'll wait and eventually it settles

68
00:03:01,914 --> 00:03:02,815
for an imbalanced match.

69
00:03:03,675 --> 00:03:06,315
And that's basically how matchmaking has worked

70
00:03:06,355 --> 00:03:07,676
for a pretty long time,

71
00:03:08,156 --> 00:03:10,136
when we're talking about automated matchmaking.

72
00:03:11,357 --> 00:03:13,097
And this is kind of how it goes, again,

73
00:03:13,117 --> 00:03:15,658
just in review, how it works over time.

74
00:03:15,878 --> 00:03:16,758
You have our matchmaker,

75
00:03:17,839 --> 00:03:19,619
and a player comes and says, hey, I'd like to play.

76
00:03:20,599 --> 00:03:21,100
And then he waits,

77
00:03:21,120 --> 00:03:23,180
because there's no one else to matchmake with him yet.

78
00:03:24,440 --> 00:03:25,781
Then another player comes along,

79
00:03:25,841 --> 00:03:26,741
and the matchmaker says,

80
00:03:26,841 --> 00:03:29,362
well, these two aren't quite a good match.

81
00:03:29,602 --> 00:03:30,662
I'll wait a little bit longer,

82
00:03:30,722 --> 00:03:33,023
because there could be something better come along.

83
00:03:33,985 --> 00:03:35,186
Player three comes along and it says,

84
00:03:35,226 --> 00:03:36,667
well, player three's still not great,

85
00:03:36,707 --> 00:03:38,688
but player one's been waiting for a while

86
00:03:38,908 --> 00:03:41,269
and it's better than matching against player two.

87
00:03:41,309 --> 00:03:43,190
So I guess we'll create that match.

88
00:03:43,851 --> 00:03:45,452
Player one and three, they'll play together.

89
00:03:46,472 --> 00:03:48,293
And then player four comes along and it's like,

90
00:03:48,653 --> 00:03:50,574
oh, player four would have been the perfect match

91
00:03:50,614 --> 00:03:51,255
with player one.

92
00:03:51,595 --> 00:03:52,375
Oh, well, too late now.

93
00:03:52,816 --> 00:03:54,717
I guess four will get to go play with player two

94
00:03:55,157 --> 00:03:56,017
and we'll just settle for it.

95
00:03:56,838 --> 00:03:58,159
Now you notice what I mentioned,

96
00:03:58,539 --> 00:04:00,760
that it could say to itself,

97
00:04:00,920 --> 00:04:02,261
oh, player four would have been perfect.

98
00:04:03,030 --> 00:04:06,333
And that's because if the matchmaker knew what was coming,

99
00:04:07,174 --> 00:04:08,815
it could create optimal matches.

100
00:04:09,256 --> 00:04:11,037
It could have waited for player four.

101
00:04:11,057 --> 00:04:12,919
It would have known, oh wait, player four is gonna come.

102
00:04:12,959 --> 00:04:14,700
I know it's gonna, I know player four is coming.

103
00:04:15,341 --> 00:04:16,982
And so I'll wait, and then when player four comes,

104
00:04:17,002 --> 00:04:18,423
I'll give player one a better match

105
00:04:18,804 --> 00:04:19,824
than I have been giving him.

106
00:04:20,925 --> 00:04:23,688
And so if matchmakers knew the whole future,

107
00:04:24,108 --> 00:04:25,429
then you could solve matchmaking

108
00:04:25,449 --> 00:04:29,112
just with combinatorial optimization over the known future.

109
00:04:30,034 --> 00:04:34,838
So the idea here, the key point for this presentation for how this method works is

110
00:04:35,198 --> 00:04:40,942
we'll use machine learning to predict what's coming. And then because we know what's coming,

111
00:04:41,283 --> 00:04:47,288
we can just use optimization methods to create these matches. But before we get to anything

112
00:04:47,348 --> 00:04:52,532
too fancy, let's start with how conventional matchmakers work today, and then use that as

113
00:04:52,572 --> 00:04:56,055
a jumping off point to see how we can improve them and where the machine learning comes in.

114
00:04:56,795 --> 00:04:59,498
So when we first create a matchmaker today,

115
00:05:00,340 --> 00:05:05,381
we generally start by setting up a set of rules for the matchmaker to use to create matches.

116
00:05:05,881 --> 00:05:08,702
And here I've given the example of the types of rules that we need.

117
00:05:09,342 --> 00:05:14,263
First, we definitely need to define what a match looks like. So in this case, we need to let the

118
00:05:14,303 --> 00:05:20,805
matchmaker know that, hey, we need eight players and we need them as two teams of four. Then often

119
00:05:20,845 --> 00:05:21,685
you have some kind of

120
00:05:22,741 --> 00:05:24,923
Expansion over latency, where you say,

121
00:05:24,963 --> 00:05:28,547
hey, we really want the latency between the players

122
00:05:28,587 --> 00:05:29,909
and the servers are playing on to be

123
00:05:29,969 --> 00:05:31,210
no more than 50 milliseconds,

124
00:05:31,651 --> 00:05:35,135
but as the players wait, we'll increase that tolerance

125
00:05:35,275 --> 00:05:37,177
to allow up to 200 milliseconds.

126
00:05:37,918 --> 00:05:40,941
You also tend to do a similar thing with the skill gap.

127
00:05:41,342 --> 00:05:42,943
It starts small and grows over time.

128
00:05:43,565 --> 00:05:47,426
You also have some bookkeeping type of variables to match on,

129
00:05:47,627 --> 00:05:49,167
like the build versions need to match.

130
00:05:49,327 --> 00:05:51,048
The players need to be playing the same game.

131
00:05:51,068 --> 00:05:53,068
The game needs to be able to talk to the server.

132
00:05:53,548 --> 00:05:56,429
And playlists must match, which in Halo,

133
00:05:56,469 --> 00:05:59,130
we use playlists to identify what players are asking to play.

134
00:06:00,110 --> 00:06:03,351
Players can only play with each other on game modes

135
00:06:03,411 --> 00:06:04,772
that they both want to play together.

136
00:06:04,792 --> 00:06:06,652
So you have some simple values like that.

137
00:06:06,672 --> 00:06:09,253
So you have this set of rules that tells the matchmaker,

138
00:06:09,633 --> 00:06:11,193
these things need to match up for our players.

139
00:06:11,878 --> 00:06:14,500
For fun, here's sort of an example of what that looks like

140
00:06:15,081 --> 00:06:16,281
in like JSON.

141
00:06:17,322 --> 00:06:19,664
The highlighted areas show kind of how we would set up

142
00:06:19,724 --> 00:06:21,525
an expansion rule where we're saying,

143
00:06:21,545 --> 00:06:23,606
hey, you know, we want them to have,

144
00:06:23,946 --> 00:06:27,349
start off at a difference of 0.2 in skill in this case,

145
00:06:27,709 --> 00:06:30,351
but you can increase that over time by a certain amount

146
00:06:30,411 --> 00:06:31,211
up to a certain point.

147
00:06:31,671 --> 00:06:32,832
And don't get too hung up on that,

148
00:06:32,872 --> 00:06:34,053
but that's kind of how that works.

149
00:06:34,073 --> 00:06:35,234
This is how we're setting up rules.

150
00:06:35,654 --> 00:06:37,635
The key thing to notice here is that a rule

151
00:06:37,715 --> 00:06:39,036
is generally a set of numbers.

152
00:06:39,657 --> 00:06:42,019
And that's where later on, to give a little bit of a hint,

153
00:06:42,439 --> 00:06:44,100
we're optimizing over a set of numbers,

154
00:06:44,161 --> 00:06:46,082
which there's a lot of pretty straightforward ways

155
00:06:46,102 --> 00:06:48,484
to optimize over numbers if you know what to look for.

156
00:06:50,186 --> 00:06:54,009
So again, the matchmaker has this set of rules

157
00:06:54,409 --> 00:06:55,970
and over time players are coming in

158
00:06:56,051 --> 00:06:57,252
and it's looking at those rules

159
00:06:57,632 --> 00:06:59,233
and using them to set up those matches.

160
00:07:01,149 --> 00:07:04,934
And an actual request from a player will look something like this.

161
00:07:05,555 --> 00:07:08,659
The player is sending over a creation time because the matchmaker needs to

162
00:07:08,799 --> 00:07:10,521
keep track of how long has the player waited.

163
00:07:11,162 --> 00:07:13,666
It's sending over an ID of the player so it knows who is who.

164
00:07:14,482 --> 00:07:16,182
It tells us how good the player is,

165
00:07:16,662 --> 00:07:17,942
something about their location,

166
00:07:17,962 --> 00:07:20,283
and maybe in the form of a latency table.

167
00:07:20,883 --> 00:07:23,363
I give the example here that if a player's favorite

168
00:07:23,923 --> 00:07:27,824
data center is East US, then you could also just say

169
00:07:27,884 --> 00:07:29,645
that they are an East US player

170
00:07:29,685 --> 00:07:32,225
rather than keeping all of the ping information.

171
00:07:32,265 --> 00:07:33,785
It just depends on what your goals are.

172
00:07:33,965 --> 00:07:36,246
And like I said, again, the player's gonna indicate

173
00:07:36,586 --> 00:07:38,986
their playlist ID, what they actually want to play,

174
00:07:39,406 --> 00:07:40,547
and they're gonna have some information

175
00:07:40,587 --> 00:07:41,647
about their build version,

176
00:07:41,687 --> 00:07:43,067
other more bookkeeping type items.

177
00:07:44,700 --> 00:07:48,523
And so the matchmaker compares requests of this nature

178
00:07:48,683 --> 00:07:49,904
between different players.

179
00:07:50,424 --> 00:07:52,026
It checks each rule that it has

180
00:07:52,426 --> 00:07:54,607
and decides whether or not Bob can match Alice.

181
00:07:55,068 --> 00:07:56,149
So for example, it checks,

182
00:07:56,189 --> 00:07:59,031
hey, is the skill gap between these two less than 10?

183
00:07:59,131 --> 00:08:02,073
In this case, it's five, Alice is 32, Bob is 27.

184
00:08:02,493 --> 00:08:04,434
So they can match, that's okay.

185
00:08:04,935 --> 00:08:07,937
And if all the rules pass, then two players, two teams,

186
00:08:07,977 --> 00:08:10,058
whatever have you, are able to match and play together.

187
00:08:11,883 --> 00:08:14,345
Now, there's some issues with this approach, though, as you'll notice.

188
00:08:14,946 --> 00:08:20,010
First, these rules apply globally to all players in the world that are matchmaking,

189
00:08:20,491 --> 00:08:25,015
which means the same thresholds, the same gaps that are allowed are the same everywhere.

190
00:08:25,575 --> 00:08:29,379
And this can be an issue because it may be that if I'm in the UK

191
00:08:29,899 --> 00:08:31,641
and I have to play against a US player,

192
00:08:32,311 --> 00:08:36,554
I may want a tighter skill gap in that situation than I would be willing to accept if I were

193
00:08:36,574 --> 00:08:37,395
to play locally.

194
00:08:37,455 --> 00:08:42,679
I might be okay sacrificing a bit of fairness if my latency, if my connection to the server

195
00:08:42,719 --> 00:08:43,059
is better.

196
00:08:43,480 --> 00:08:45,281
So that creates a bit of an issue already.

197
00:08:46,392 --> 00:08:48,675
And also, these rules tend to be static.

198
00:08:49,216 --> 00:08:51,639
They tend to be the same whether you are in a time

199
00:08:51,719 --> 00:08:54,743
of high population traffic or low population traffic.

200
00:08:55,144 --> 00:08:57,627
And what that means is during off-peak hours,

201
00:08:58,028 --> 00:09:00,871
the players will always wait for your rules to expand

202
00:09:01,332 --> 00:09:03,355
if you're using rules of that type that expand.

203
00:09:03,375 --> 00:09:04,256
If your rules are saying.

204
00:09:05,076 --> 00:09:08,317
look for a good match, but then wait for a while and accept a bad match,

205
00:09:08,957 --> 00:09:13,698
then you are building in wait time that is unnecessary in your off-peak hours because

206
00:09:13,738 --> 00:09:17,679
those better matches, they're just not ever going to happen. So why are you making your

207
00:09:17,699 --> 00:09:22,140
players wait for them? And that's a general point of this talk, is if your matchmaker was a bit

208
00:09:22,200 --> 00:09:26,201
smarter, it would never make your players wait for matches that it knew were not going to happen.

209
00:09:26,621 --> 00:09:29,402
So if your only takeaway that you take back to your game is

210
00:09:30,740 --> 00:09:34,983
hey let's measure some real-time statistics on our population and on our ticket rates

211
00:09:35,664 --> 00:09:42,690
and then don't expand and so just change our rules real time so that when the pop goes down they are

212
00:09:43,091 --> 00:09:47,635
immediately start off pre-expanded you will already have a nice improvement for your players

213
00:09:47,795 --> 00:09:51,998
in terms of wait time at least. So static rules are inflexible causes some problems.

214
00:09:53,389 --> 00:09:55,110
And there's some consequences that all of these

215
00:09:55,130 --> 00:09:56,511
kind of come together to cause,

216
00:09:57,031 --> 00:10:00,032
in terms of both you're making players wait,

217
00:10:00,292 --> 00:10:02,173
yet you're not dealing with the regional

218
00:10:02,213 --> 00:10:05,014
versus global differences between them.

219
00:10:05,595 --> 00:10:08,036
And here's kind of what happens when you do that.

220
00:10:09,336 --> 00:10:13,358
So, before I get into that, let me define a term

221
00:10:13,398 --> 00:10:15,979
I'm gonna show to show you what happens because of this.

222
00:10:16,079 --> 00:10:17,400
And that term is predictability.

223
00:10:18,080 --> 00:10:20,461
Predictability is a measure we use to tell us

224
00:10:20,521 --> 00:10:22,442
how often the better team wins.

225
00:10:23,244 --> 00:10:25,526
And so it's sort of a measure of unfairness.

226
00:10:25,986 --> 00:10:27,827
So if it was 50%, that would mean that

227
00:10:28,107 --> 00:10:30,309
this match is unpredictable between the two teams

228
00:10:30,689 --> 00:10:32,450
and so because it's a perfectly fair match,

229
00:10:32,530 --> 00:10:33,631
it's close to a draw.

230
00:10:34,091 --> 00:10:36,753
But if it's like 90%, that means the better team

231
00:10:36,853 --> 00:10:38,394
is winning nine out of 10 times,

232
00:10:38,814 --> 00:10:39,775
and it's just not as fair.

233
00:10:39,995 --> 00:10:41,876
So I will be referencing predictability

234
00:10:41,936 --> 00:10:44,818
as a measure of fairness throughout the talk.

235
00:10:45,118 --> 00:10:46,059
And that's what that means.

236
00:10:47,580 --> 00:10:49,802
Can the worst team have a shot at winning that match?

237
00:10:51,139 --> 00:10:57,101
So let's look at some graphs again to show the consequences of using this conventional matchmaking.

238
00:10:57,622 --> 00:11:02,184
So on the left, what I'm showing here in the first graph is how many players are looking for a match.

239
00:11:02,644 --> 00:11:06,326
And you'll notice there's a pretty wide swing between the bottom and the top here.

240
00:11:06,646 --> 00:11:09,748
And that wide swing is what leads to some of these problems that we've talked about.

241
00:11:10,619 --> 00:11:12,980
And that first one is here is the wait time.

242
00:11:13,401 --> 00:11:15,162
That during high population times,

243
00:11:15,222 --> 00:11:18,084
players are waiting for about 20 seconds for a match.

244
00:11:18,405 --> 00:11:21,987
But that goes up to close to 60, 70, 80 seconds

245
00:11:22,668 --> 00:11:23,208
of wait time.

246
00:11:23,589 --> 00:11:25,550
So their wait time is increasing a lot

247
00:11:25,850 --> 00:11:27,231
because of that shift in population.

248
00:11:29,296 --> 00:11:33,680
In addition, you see the same type of effect on other metrics that may be important to you.

249
00:11:33,840 --> 00:11:37,523
Like on the left here, there's that predictability metric I mentioned.

250
00:11:37,984 --> 00:11:43,629
Player fairness is going from being somewhat fair at about 70% chance for the best team to win,

251
00:11:43,689 --> 00:11:46,952
all the way up to like near 100% chance they will win every time.

252
00:11:47,332 --> 00:11:49,854
But this is a pretty big change.

253
00:11:50,362 --> 00:11:53,084
over time in consistency of the match fairness.

254
00:11:53,144 --> 00:11:55,405
And you see a similar issue with latency,

255
00:11:55,545 --> 00:11:58,366
that players during the good population times of the day,

256
00:11:58,627 --> 00:12:02,348
high traffic, they're having very, very good latency.

257
00:12:02,368 --> 00:12:03,549
This is excess latency,

258
00:12:03,589 --> 00:12:05,830
meaning over what you would get on,

259
00:12:06,470 --> 00:12:07,951
compared to what your best you could have,

260
00:12:08,411 --> 00:12:10,112
in which case players are on average

261
00:12:10,232 --> 00:12:11,613
going from around 10, 12 latency,

262
00:12:11,813 --> 00:12:15,335
all the way up to close to 100 milliseconds of latency

263
00:12:16,095 --> 00:12:16,976
as the day changes.

264
00:12:19,017 --> 00:12:24,381
Now with this graph, I'm trying to illustrate an even worse aspect of having these static rules for matchmaking.

265
00:12:24,822 --> 00:12:29,065
What this graph shows is the tradeoff between wait time, which is on the x-axis,

266
00:12:29,685 --> 00:12:31,527
and predictability on the y-axis.

267
00:12:31,867 --> 00:12:34,289
You want that predictability to be close to 50%.

268
00:12:34,589 --> 00:12:36,411
You want it to be as low as you can go.

269
00:12:36,831 --> 00:12:39,473
The optimal point of this graph would be the bottom left corner.

270
00:12:40,133 --> 00:12:44,537
And along this curve, you will see what your options are for that tradeoff.

271
00:12:44,897 --> 00:12:48,160
How long do you want to make your players wait to get what predictability you want?

272
00:12:48,737 --> 00:12:50,458
Now in static rule matchmaking though,

273
00:12:50,478 --> 00:12:52,139
you usually pick a predictability

274
00:12:52,519 --> 00:12:54,600
and you just deal with whatever the wait time is.

275
00:12:55,040 --> 00:12:56,521
But this graph shows us that there's sort of

276
00:12:56,541 --> 00:12:58,422
an optimal point at that knee of the curve,

277
00:12:58,722 --> 00:13:00,503
depending on what's important to you as a designer.

278
00:13:00,943 --> 00:13:03,104
But ideally, you're not gonna wanna make a player wait,

279
00:13:03,284 --> 00:13:04,385
as if you look at this graph,

280
00:13:05,085 --> 00:13:07,786
you're making them wait 134 seconds for a match

281
00:13:07,866 --> 00:13:10,928
that is 52% predictability, and that's pretty good.

282
00:13:11,028 --> 00:13:13,049
That means your worst players

283
00:13:13,089 --> 00:13:13,889
are having a 48% chance to win.

284
00:13:15,350 --> 00:13:16,891
You could, but if you were going for 51%,

285
00:13:17,312 --> 00:13:20,495
you'd have to more than double their wait time,

286
00:13:20,535 --> 00:13:21,215
it looks like here.

287
00:13:21,676 --> 00:13:23,397
So at that point, is it really reasonable

288
00:13:23,437 --> 00:13:25,039
to keep increasing the fairness,

289
00:13:25,459 --> 00:13:27,701
where the amount of fairness you're gonna get

290
00:13:27,761 --> 00:13:30,163
out of a long wait time isn't worth it anymore.

291
00:13:30,484 --> 00:13:31,484
It's just going up too high.

292
00:13:31,885 --> 00:13:34,607
Now, that tends to be a problem with the static rule.

293
00:13:34,647 --> 00:13:36,549
It's never gonna capture what this graph looks like

294
00:13:36,649 --> 00:13:37,810
because this graph changes.

295
00:13:38,495 --> 00:13:42,579
throughout the day. There's going to be a different good point to pick depending

296
00:13:42,599 --> 00:13:46,161
on what time of day it is. If it's a low traffic part of the day,

297
00:13:46,582 --> 00:13:50,004
you're going to want to wait much less. Waiting a long time is

298
00:13:50,104 --> 00:13:53,007
not going to buy you very much in terms of how good your match is.

299
00:13:53,527 --> 00:13:57,030
So this just shows another kind of trade-off between just fairness and

300
00:13:57,050 --> 00:13:58,611
wait time that's important to matchmaking.

301
00:13:59,051 --> 00:14:02,134
So again, let's review the consequences of choosing the

302
00:14:02,434 --> 00:14:06,037
current conventional way that we matchmake. So conventional matchmaking,

303
00:14:06,717 --> 00:14:07,878
what we have there is a

304
00:14:08,691 --> 00:14:11,973
we ignore the real-timing incoming request rate at a given time of day.

305
00:14:12,013 --> 00:14:14,976
We don't take into account that there's a lot more people looking for matches

306
00:14:14,996 --> 00:14:18,598
right now than usual or vice versa. We also would ignore the skilled

307
00:14:18,638 --> 00:14:22,161
distribution at that time of day. Like we don't look at are there good

308
00:14:22,201 --> 00:14:25,683
players around right now and we don't look at regional distribution

309
00:14:25,723 --> 00:14:28,505
infos. Maybe the population traffic is low globally

310
00:14:28,845 --> 00:14:32,288
but it's high in say the EU at which point we would want

311
00:14:32,628 --> 00:14:35,570
EU players to be able to have a different matchmaking preference.

312
00:14:36,335 --> 00:14:38,796
And so this results in either long wait times

313
00:14:39,196 --> 00:14:42,037
as players wait for rules to expand

314
00:14:42,077 --> 00:14:45,618
and for it to learn that as the system tries to account

315
00:14:45,638 --> 00:14:48,239
for the fact that population traffic has changed,

316
00:14:48,599 --> 00:14:51,140
or we have to deal with it and accept matches

317
00:14:51,160 --> 00:14:53,480
that we know are bad in order to have faster wait times,

318
00:14:53,880 --> 00:14:55,601
neither of which are really that great.

319
00:14:56,181 --> 00:14:59,182
So, and why would we give players an extra long match,

320
00:14:59,622 --> 00:15:01,903
an extra long wait time followed by?

321
00:15:02,869 --> 00:15:05,650
just as bad a match. It's like the worst of both worlds. They're getting both

322
00:15:06,010 --> 00:15:12,693
long waits and bad matches. So we need a more optimal approach to do this. And this is where

323
00:15:12,753 --> 00:15:17,275
we come into the approach that we decided to look at. And before we talk about optimal,

324
00:15:17,295 --> 00:15:23,177
we have to define what is optimal. And for us, in order to define that, we came up with a utility

325
00:15:23,217 --> 00:15:27,679
function. So we can actually put a number on optimal so our matchmaker could optimize over

326
00:15:27,739 --> 00:15:28,219
that value.

327
00:15:29,036 --> 00:15:32,837
In addition, this approach uses real-time statistics.

328
00:15:33,237 --> 00:15:36,818
We look at both the arrival rate of players and their skill distribution,

329
00:15:37,158 --> 00:15:38,979
and we take into account that by region.

330
00:15:39,419 --> 00:15:42,620
So we know how many players in each region are coming in for matches,

331
00:15:42,980 --> 00:15:46,020
and we know what their skill distribution is at any time of the day.

332
00:15:47,241 --> 00:15:51,782
Then we use machine learning in order to predict what's going to happen in the future,

333
00:15:52,222 --> 00:15:56,143
so that we can then use an optimizer to optimize over those future matches

334
00:15:56,403 --> 00:15:57,423
that we predict will happen.

335
00:15:59,879 --> 00:16:02,541
And so let's define again what optimal is,

336
00:16:02,561 --> 00:16:04,703
because we have a utility function

337
00:16:04,723 --> 00:16:07,145
that gives us a number that we put on optimal.

338
00:16:07,986 --> 00:16:08,686
And then to do this,

339
00:16:08,726 --> 00:16:11,709
we just weight a number of metrics we feel are important,

340
00:16:12,089 --> 00:16:13,570
or we let our designers weight them.

341
00:16:14,431 --> 00:16:17,633
And the metrics we chose for our approach were wait time.

342
00:16:18,094 --> 00:16:20,255
We assume that players don't want to wait forever.

343
00:16:20,976 --> 00:16:22,477
We assume skill gap is important,

344
00:16:23,037 --> 00:16:24,859
and we represent that as predictability,

345
00:16:24,899 --> 00:16:25,720
as I explained earlier.

346
00:16:26,691 --> 00:16:32,619
We also have something called equal win rate, which is basically do bad players win just as much as good players?

347
00:16:32,639 --> 00:16:35,222
And is that important to you or can you have?

348
00:16:35,923 --> 00:16:39,948
Decent skill gaps, but it's always in the favor of the of the good players

349
00:16:39,988 --> 00:16:45,735
Is that important or not and of course latency how important is it that players have good ping on the service that they play on?

350
00:16:47,552 --> 00:16:50,214
And so what this method does, which we call true match,

351
00:16:50,855 --> 00:16:53,597
is it adapts in real time to optimize

352
00:16:53,797 --> 00:16:55,098
those metrics and matches.

353
00:16:55,739 --> 00:16:59,142
So again, it is using real-time statistics,

354
00:16:59,602 --> 00:17:02,104
predicting what's coming, and then just optimizing

355
00:17:02,184 --> 00:17:04,926
over our utility function to give the type of matches

356
00:17:04,946 --> 00:17:06,868
that our designers have told us are important.

357
00:17:07,808 --> 00:17:09,510
So before going into any more details,

358
00:17:09,910 --> 00:17:11,411
let's look at a high-level comparison

359
00:17:11,491 --> 00:17:14,754
between our proposed changes and conventional matchmaking.

360
00:17:15,312 --> 00:17:18,014
So here's some of the important aspects we want to call out.

361
00:17:18,454 --> 00:17:19,015
First, tuning.

362
00:17:19,595 --> 00:17:22,317
Rather than tuning the values of your matchmaker by hand,

363
00:17:22,678 --> 00:17:24,759
TrueMatch will do for you real time throughout the day

364
00:17:25,420 --> 00:17:28,062
and automatically, you don't have to do those hand tuning.

365
00:17:28,663 --> 00:17:30,564
And this means that instead of being able

366
00:17:30,584 --> 00:17:33,747
to only tune once a month or whenever players complain,

367
00:17:34,147 --> 00:17:36,469
you just let TrueMatch do the tuning for you all the time.

368
00:17:37,806 --> 00:17:41,269
And in addition, an important aspect of what you can do with TrueMatch

369
00:17:41,770 --> 00:17:45,793
is that instead of your rules applying only globally to everybody,

370
00:17:46,313 --> 00:17:51,878
TrueMatch can customize those rules to apply to players and regions specifically.

371
00:17:52,339 --> 00:17:59,105
So every region and every skill bucket has its own set of rules to help it optimize its own matchmaking.

372
00:18:00,026 --> 00:18:04,633
And in addition, this allows us to do predictions at a region and a skill level.

373
00:18:05,013 --> 00:18:11,122
So we can tell a player how long they will wait, and that wait time is customized by that player's

374
00:18:11,683 --> 00:18:15,348
region, where they're at, and what their skill level is, which is great for players.

375
00:18:16,890 --> 00:18:19,271
It also means that because we have these predictions,

376
00:18:19,931 --> 00:18:22,472
if a prediction doesn't look like what actually happens,

377
00:18:22,913 --> 00:18:24,213
and this happens consistently,

378
00:18:24,633 --> 00:18:27,174
that we can do some form of automatic alerting.

379
00:18:27,555 --> 00:18:28,835
We can have the system let us know,

380
00:18:28,895 --> 00:18:30,236
hey, there's something wrong going on.

381
00:18:30,656 --> 00:18:32,377
TrueMatch isn't able to predict correctly

382
00:18:32,437 --> 00:18:34,398
that something's going on that's unexpected.

383
00:18:34,838 --> 00:18:37,019
Right now, those types of things are a lot more difficult

384
00:18:37,039 --> 00:18:39,280
to catch in standard conventional matchmaking.

385
00:18:39,580 --> 00:18:40,740
When matchmaking is not working out

386
00:18:40,780 --> 00:18:41,841
the way you think it should,

387
00:18:42,221 --> 00:18:43,362
you often don't find out about it

388
00:18:43,382 --> 00:18:44,462
until players start complaining.

389
00:18:45,282 --> 00:18:46,203
So it gives us some nice.

390
00:18:46,744 --> 00:18:48,344
automated monitoring and alerting.

391
00:18:49,205 --> 00:18:52,706
So in addition, right now, this system, which we call TrueMatch,

392
00:18:53,027 --> 00:18:54,227
has launched with Gears of War 5,

393
00:18:55,088 --> 00:18:56,908
and in Halo 5, we've switched over to it.

394
00:18:57,409 --> 00:18:59,610
And there's some potential here to make it a standard service

395
00:18:59,630 --> 00:19:01,691
that third-party folks can use as well.

396
00:19:04,832 --> 00:19:07,674
So, let's get back to talking about our utility function

397
00:19:07,794 --> 00:19:08,754
and re-review that.

398
00:19:09,935 --> 00:19:12,396
So we have this, what we call, unified objective function.

399
00:19:12,930 --> 00:19:16,494
Every match is going to have a wait time, it's going to have a skill gap,

400
00:19:16,654 --> 00:19:19,537
it's going to have all the players' latencies from within the match,

401
00:19:20,057 --> 00:19:23,020
and we can measure win rates over sections of our population.

402
00:19:23,440 --> 00:19:29,046
That can all go into a single value that represents the utility of our system of a match,

403
00:19:29,566 --> 00:19:33,730
of a certain amount of time of day, of a region, whatever we would like that utility to be.

404
00:19:35,008 --> 00:19:38,969
And for those that like equations versus looking at graphs,

405
00:19:39,309 --> 00:19:41,149
this is kind of what our utility equation looks like.

406
00:19:41,229 --> 00:19:43,870
It's a weighted sum over these items

407
00:19:43,890 --> 00:19:45,150
that we think are important.

408
00:19:45,691 --> 00:19:46,971
Now, something that we tend to do

409
00:19:47,051 --> 00:19:48,971
to make it easy for designers to use,

410
00:19:49,591 --> 00:19:53,392
we set the wait, wait, on wait time to be just one.

411
00:19:53,412 --> 00:19:58,294
And what that means is that all of the other weights

412
00:19:58,934 --> 00:20:02,295
represent how long you would wait to have,

413
00:20:04,692 --> 00:20:05,993
one more better of each of those.

414
00:20:06,254 --> 00:20:09,396
So for example, if you set W3 for latency,

415
00:20:09,416 --> 00:20:10,377
if you set that to 10,

416
00:20:10,917 --> 00:20:12,878
you're willing to wait 10 more seconds

417
00:20:13,279 --> 00:20:15,540
for one millisecond better of latency.

418
00:20:16,081 --> 00:20:18,803
And that makes it easier for our designers to trade off

419
00:20:19,223 --> 00:20:20,864
how important each of these items are.

420
00:20:21,225 --> 00:20:23,486
They can trade them off directly on time.

421
00:20:24,567 --> 00:20:27,329
1% more predictability is one second more of wait time.

422
00:20:27,529 --> 00:20:28,230
That's what we tell,

423
00:20:28,510 --> 00:20:29,791
that's what we can put into our utility,

424
00:20:29,811 --> 00:20:30,471
which is very nice.

425
00:20:31,059 --> 00:20:33,821
And there's some nice ways we can use these utility functions.

426
00:20:34,322 --> 00:20:36,964
We don't have to use them at the global level.

427
00:20:37,064 --> 00:20:40,408
We could actually put a utility function on every game title

428
00:20:40,928 --> 00:20:42,610
and even drill down to every player.

429
00:20:42,770 --> 00:20:44,812
They can each have their own utility function

430
00:20:45,172 --> 00:20:46,934
to tell the matchmaker what's important to them.

431
00:20:48,187 --> 00:20:52,168
They also are really nice to use to evaluate any change you make to matchmaking,

432
00:20:52,549 --> 00:20:58,151
because if you already know what is important to you, then changing other aspects outside of that

433
00:20:58,591 --> 00:21:03,834
will change the utility, and you can then see if that utility is still what you wanted it to be,

434
00:21:03,954 --> 00:21:07,695
if you're still meeting the goals. Now, if you have some already existing

435
00:21:07,835 --> 00:21:10,256
thresholds and gaps that you're using in your matchmaker,

436
00:21:10,977 --> 00:21:15,640
we have a few ways we've used that I won't go too much into detail on right now for time,

437
00:21:15,980 --> 00:21:20,163
but it's not difficult to reverse engineer those values to what weights they would want to be

438
00:21:20,523 --> 00:21:27,788
in your utility function. And so now let's step back at a high level again and look at how the

439
00:21:27,828 --> 00:21:34,772
TrueMatch algorithm actually works, what its sort of path is that it takes, what the actual steps

440
00:21:34,832 --> 00:21:39,995
it goes through. So first it's going to count the requests it's seeing by type.

441
00:21:40,682 --> 00:21:44,144
So on regular intervals, TrueMatch measures

442
00:21:44,284 --> 00:21:46,365
how many players are we seeing in each region

443
00:21:47,125 --> 00:21:49,127
in every different skill bucket that's important to us.

444
00:21:49,627 --> 00:21:51,548
And that lets TrueMatch have a good idea

445
00:21:51,728 --> 00:21:53,849
of what type of players are coming in,

446
00:21:53,890 --> 00:21:55,711
what does the population look like right now.

447
00:21:56,571 --> 00:21:59,613
That lets us predict what is going to come soon.

448
00:22:00,373 --> 00:22:03,055
And so then we have an optimizer,

449
00:22:03,095 --> 00:22:05,136
which then chooses the best rules,

450
00:22:05,456 --> 00:22:07,698
given what we expect from that population count.

451
00:22:08,461 --> 00:22:11,544
to create the best matches, to create the best utility,

452
00:22:12,004 --> 00:22:16,548
because it now knows what's coming. And after we've chosen those rules,

453
00:22:17,008 --> 00:22:20,551
it then matchmakes, and players play matches, and they see what happens, and

454
00:22:20,571 --> 00:22:25,155
then after that, we measure the results. TrueMatch will look at, okay, I made

455
00:22:25,175 --> 00:22:28,338
these types of matches. Did they match what I'd hoped would

456
00:22:28,378 --> 00:22:31,661
happen with these players? Did they get the matches I wanted them to have?

457
00:22:32,342 --> 00:22:34,263
And did the population behave how I expected?

458
00:22:35,110 --> 00:22:36,231
And using those measurements,

459
00:22:36,651 --> 00:22:38,192
TrueMatch then updates itself.

460
00:22:38,693 --> 00:22:41,194
It updates the way that it understands

461
00:22:41,274 --> 00:22:43,476
how to connect those counts it's getting

462
00:22:43,836 --> 00:22:46,338
with what actually is going to happen when we match make.

463
00:22:46,956 --> 00:22:49,037
And after it's updated itself to be more accurate

464
00:22:49,497 --> 00:22:53,278
for that time of day, it then goes back and recounts again

465
00:22:53,338 --> 00:22:54,799
to see what population looks like.

466
00:22:55,279 --> 00:22:56,660
And we keep going on this cycle.

467
00:22:57,320 --> 00:22:59,381
A typical cycle time could be about 15 minutes

468
00:22:59,801 --> 00:23:02,502
where it is constantly remeasuring the population,

469
00:23:02,862 --> 00:23:04,803
changing the matchmaking rules themselves,

470
00:23:05,283 --> 00:23:09,705
and also improving its own ability to do the matchmaking,

471
00:23:09,785 --> 00:23:11,545
to do those estimates, to create those rules.

472
00:23:12,046 --> 00:23:14,947
So we'll take some time and go into these sections

473
00:23:15,327 --> 00:23:16,187
a little more in detail.

474
00:23:17,756 --> 00:23:20,359
So let's talk about the components of TrueMatch.

475
00:23:20,839 --> 00:23:21,880
I talked about counting.

476
00:23:22,361 --> 00:23:25,604
So the first component we have here is the population tracker.

477
00:23:25,965 --> 00:23:27,566
That's kind of where this counting happens.

478
00:23:28,187 --> 00:23:31,490
The player requests for matchmaking go into the population tracker

479
00:23:31,911 --> 00:23:34,573
and it tracks how many players are coming in of each different type.

480
00:23:35,370 --> 00:23:37,733
It then creates a population model,

481
00:23:38,213 --> 00:23:41,316
which is just a simpler version of all the requests

482
00:23:41,336 --> 00:23:45,139
that are coming in to explain to the TrueMatch system

483
00:23:45,580 --> 00:23:46,721
what it expects to happen,

484
00:23:46,821 --> 00:23:50,624
what the population currently looks like, sorry,

485
00:23:50,685 --> 00:23:51,826
not as much what's gonna happen,

486
00:23:51,866 --> 00:23:53,487
but what the population looks like right now.

487
00:23:54,284 --> 00:23:56,527
Then we have a little system called the metric predictor.

488
00:23:57,067 --> 00:24:00,091
Its job is to take the current model of the population

489
00:24:00,471 --> 00:24:04,536
and use that to predict what would happen given the matchmaking rules.

490
00:24:04,996 --> 00:24:08,780
So there's already some rules set up, there's some default rules that are made

491
00:24:08,840 --> 00:24:12,444
at initialization that exist. The metric predictor will take the

492
00:24:12,505 --> 00:24:14,146
rules state as it is right now.

493
00:24:14,895 --> 00:24:17,856
and take the population model, and then it will predict,

494
00:24:18,076 --> 00:24:19,777
this is where some of that machine learning comes in,

495
00:24:20,138 --> 00:24:22,639
it'll predict, okay, if this is the population,

496
00:24:22,799 --> 00:24:24,500
and if these are your current matchmaking rules,

497
00:24:25,080 --> 00:24:26,801
then this is what I expect to happen

498
00:24:26,981 --> 00:24:28,102
if you matchmake that way.

499
00:24:28,782 --> 00:24:30,243
So it then tells the optimizer,

500
00:24:30,263 --> 00:24:32,804
this is the expected utility of the matches

501
00:24:32,824 --> 00:24:35,506
that will be made because of the rules that you gave me.

502
00:24:36,377 --> 00:24:40,261
This lets the optimizer decide whether it likes that expected utility,

503
00:24:40,622 --> 00:24:44,206
and if not, it can change itself before any matches actually have been made.

504
00:24:44,666 --> 00:24:51,474
It can change itself based on the predicted utility and create better rules for matchmaking

505
00:24:51,814 --> 00:24:54,918
before the players use them. And it could go through a few cycles of this,

506
00:24:55,058 --> 00:24:57,801
improving the rules before they're actually applied.

507
00:24:58,395 --> 00:25:00,576
So again, we model the population,

508
00:25:00,676 --> 00:25:03,417
we predict based on the rules and that model,

509
00:25:03,797 --> 00:25:05,217
what's going to happen with those rules,

510
00:25:05,677 --> 00:25:07,337
and then we tell the optimizer to do

511
00:25:07,417 --> 00:25:09,438
a better job so we can do that.

512
00:25:10,018 --> 00:25:11,978
So let's dig in a little bit onto how

513
00:25:12,019 --> 00:25:14,139
that population tracking actually works.

514
00:25:14,739 --> 00:25:17,760
Just a little bit. The population tracker needs to take

515
00:25:17,880 --> 00:25:20,701
a stream of requests coming in from

516
00:25:20,721 --> 00:25:22,141
the players and create

517
00:25:22,181 --> 00:25:25,042
a population model to inform our metric predictor.

518
00:25:25,679 --> 00:25:28,762
And the way we do that is we assume that the population

519
00:25:28,862 --> 00:25:31,965
isn't changing too fast, that the population rate

520
00:25:32,405 --> 00:25:33,806
isn't gonna change too much right now.

521
00:25:34,227 --> 00:25:35,888
And that actually tends to be reasonable.

522
00:25:36,729 --> 00:25:38,531
And then we need to be able to return

523
00:25:38,611 --> 00:25:41,433
to the metric predictor what we can about

524
00:25:41,674 --> 00:25:43,435
what the population looks like right now.

525
00:25:44,008 --> 00:25:45,349
And there's a few ways to do that.

526
00:25:45,769 --> 00:25:48,570
A simple way would just be to use a circular buffer

527
00:25:49,010 --> 00:25:52,132
where you just hold on to the last, say, 1,000 requests.

528
00:25:52,752 --> 00:25:54,553
And then you use those 1,000 requests

529
00:25:54,593 --> 00:25:57,954
to calculate on the fly the statistics of the players

530
00:25:57,994 --> 00:25:59,135
that have come in and hand off,

531
00:25:59,555 --> 00:26:01,936
just basically to say, okay, in the last 1,000 matches,

532
00:26:02,416 --> 00:26:04,237
this percent came from EU

533
00:26:04,717 --> 00:26:06,698
and this is what the skill distribution

534
00:26:06,718 --> 00:26:07,578
of those players were.

535
00:26:07,958 --> 00:26:10,259
That's kind of what the metric predictor needs to know about.

536
00:26:10,924 --> 00:26:14,547
maybe a more compact way would it be to be something more like a histogram,

537
00:26:14,788 --> 00:26:17,630
where you're tracking the counts of the number of players you've seen

538
00:26:17,970 --> 00:26:21,413
within a certain bucket of skill and within the different buckets

539
00:26:21,714 --> 00:26:24,776
of regions. And that's more in practice what we do,

540
00:26:25,157 --> 00:26:28,740
so that we can in theory have millions of players being represented

541
00:26:29,160 --> 00:26:33,444
in just a compact histogram. And to go into a little more detail onto what this

542
00:26:33,584 --> 00:26:34,925
ends up giving us is

543
00:26:36,642 --> 00:26:40,243
we stored those request rates and given a request type,

544
00:26:40,743 --> 00:26:43,544
we can then return the rate of that type at any given time.

545
00:26:44,245 --> 00:26:47,806
And by type, I mean I'm combining what skill bucket

546
00:26:47,826 --> 00:26:50,167
were you in and what region bucket were you in.

547
00:26:50,567 --> 00:26:52,408
And so the example here at the bottom

548
00:26:52,448 --> 00:26:53,348
is what it might look like.

549
00:26:53,688 --> 00:26:55,989
I'm a Brazilian player, in Brazil,

550
00:26:56,710 --> 00:26:59,931
we are seeing 0.01 requests per second, for example,

551
00:27:00,511 --> 00:27:02,672
for players between skills 0.3 and 0.4.

552
00:27:02,952 --> 00:27:04,253
So we've got a skill bucket.

553
00:27:04,887 --> 00:27:07,209
and we have a region, and for all the regions

554
00:27:07,449 --> 00:27:08,430
and all the skill buckets,

555
00:27:08,790 --> 00:27:11,332
a population model can tell the metric predictor

556
00:27:11,872 --> 00:27:12,993
what those rates look like.

557
00:27:13,133 --> 00:27:15,495
So it knows what the population looks like real time.

558
00:27:16,556 --> 00:27:19,238
And again, customized by skill and region.

559
00:27:21,199 --> 00:27:23,201
And so what the metric predictor can do with that

560
00:27:23,721 --> 00:27:25,523
is if it knows the population model,

561
00:27:26,123 --> 00:27:27,824
and it also knows the rules

562
00:27:27,864 --> 00:27:29,546
that the matchmaker is currently using,

563
00:27:30,526 --> 00:27:30,706
it can

564
00:27:31,465 --> 00:27:35,366
predict using those rules, what kind of matchmaking is going to happen.

565
00:27:36,286 --> 00:27:41,827
It'll predict for every region and for every skill bucket, the wait time for those players,

566
00:27:42,547 --> 00:27:47,728
what their pings are going to be, how fair the matches are going to be. And it makes those

567
00:27:47,748 --> 00:27:54,769
predictions for every single match. And then eventually it gets back what actually happened.

568
00:27:55,210 --> 00:27:59,630
It finds out per ticket, how long did this player actually wait? What was his real latency?

569
00:28:00,193 --> 00:28:01,613
What was the fairness of that match?

570
00:28:02,054 --> 00:28:04,354
And because it gets those actual metrics back,

571
00:28:04,835 --> 00:28:07,035
the metric predictor can then use machine learning

572
00:28:07,436 --> 00:28:11,217
to update its own internal model of how the population

573
00:28:11,257 --> 00:28:14,518
and the rules connects to those predicted metrics.

574
00:28:15,266 --> 00:28:16,848
And because it becomes more accurate,

575
00:28:17,389 --> 00:28:18,750
it's feeding that information later

576
00:28:18,770 --> 00:28:21,655
into the optimizers, which can then optimize more accurately.

577
00:28:22,095 --> 00:28:24,599
And we'll go a little bit more into more details about that,

578
00:28:24,979 --> 00:28:26,581
because that metric predictor has

579
00:28:26,622 --> 00:28:29,125
what are called free parameters inside of it that

580
00:28:29,165 --> 00:28:30,547
are tuned with that feedback.

581
00:28:31,119 --> 00:28:32,019
So let's go a little bit more in.

582
00:28:32,800 --> 00:28:35,381
So yeah, let's go more into that, how that metric predictor works.

583
00:28:35,842 --> 00:28:39,144
So for each of those metrics, for latency, for fairness,

584
00:28:39,504 --> 00:28:43,347
for wait time, each of those has its own formula.

585
00:28:43,907 --> 00:28:47,129
You can think of that formula as a mini little machine learning model.

586
00:28:48,425 --> 00:28:52,546
Each of those formulas, because it's like a little machine learning model, has some parameters inside

587
00:28:52,586 --> 00:28:59,548
it that are updated and adapted over time, given the reality of what happened, so they can be more

588
00:28:59,608 --> 00:29:05,909
and more accurate about its predictions. And that's important. And so maybe we'll step into

589
00:29:05,929 --> 00:29:10,410
a little bit of a quick example of how one of our formulas work.

590
00:29:11,008 --> 00:29:13,010
And that is the wait time formula.

591
00:29:13,391 --> 00:29:15,333
This is pretty important because this is how

592
00:29:15,813 --> 00:29:18,216
the model knows what the wait time is going to be.

593
00:29:18,236 --> 00:29:20,258
It's going to predict on average

594
00:29:20,298 --> 00:29:21,599
how long players are going to wait.

595
00:29:22,300 --> 00:29:24,641
And that prediction is important to the optimizer

596
00:29:24,981 --> 00:29:26,822
because it's going to update the rules

597
00:29:27,242 --> 00:29:29,583
based on the predictions about the wait time.

598
00:29:30,043 --> 00:29:32,284
And so the optimizer can look at this prediction and say,

599
00:29:32,424 --> 00:29:34,745
oh, if I make the rules this way,

600
00:29:34,825 --> 00:29:36,105
players are going to wait too long.

601
00:29:36,425 --> 00:29:37,526
So let me adjust the rules.

602
00:29:37,786 --> 00:29:39,707
And then I will ask the metric predictor again,

603
00:29:39,787 --> 00:29:42,288
okay, what about this set of rules?

604
00:29:42,688 --> 00:29:43,848
How long will they wait with this set?

605
00:29:43,908 --> 00:29:46,389
And the metric predictor can then give back a prediction

606
00:29:46,449 --> 00:29:48,090
and the optimizer can then say,

607
00:29:48,210 --> 00:29:49,870
okay, that's fine, I don't need to change anymore.

608
00:29:50,331 --> 00:29:56,175
So let's talk about what just one of those formulas look like that I call sort of a mini machine learning model.

609
00:29:56,616 --> 00:30:02,961
So this version on this slide is not the adaptable adaptive sort of machine learning version.

610
00:30:02,981 --> 00:30:08,485
This is just a static approximation to what the wait time will be given.

611
00:30:09,773 --> 00:30:15,054
what it knows about how many requests are likely to be able to match with Player T.

612
00:30:15,234 --> 00:30:20,116
So I got this for every player who's Player T, there's some set of matches that he can match

613
00:30:20,156 --> 00:30:24,137
with. Given that, this formula, don't worry too much about the details of this formula,

614
00:30:24,157 --> 00:30:29,179
it's not as important just to know that there is one. You could reverse engineer this if you want,

615
00:30:29,299 --> 00:30:33,540
don't do it in your head right now, but this will return a wait time for 1v1 matches.

616
00:30:35,053 --> 00:30:36,314
So that's the first problem, right?

617
00:30:36,374 --> 00:30:38,154
Our matches are often 4v4.

618
00:30:38,714 --> 00:30:40,455
So in order to make this better

619
00:30:40,535 --> 00:30:42,255
without having to manually figure out

620
00:30:42,435 --> 00:30:45,256
all the different aspects of matchmaking

621
00:30:45,276 --> 00:30:48,717
and population dynamics that will modify this equation,

622
00:30:49,057 --> 00:30:50,357
we just add some parameters.

623
00:30:51,157 --> 00:30:53,218
We add a scale, which is the C,

624
00:30:53,738 --> 00:30:55,698
and we add a shift, which is B.

625
00:30:56,238 --> 00:30:58,899
And both of these values are just learned from the data.

626
00:30:59,439 --> 00:31:02,120
So it just learns based on the type of data it's getting back

627
00:31:02,875 --> 00:31:08,899
what it should actually, how it should modify slightly this formula to be more accurate in its predictions.

628
00:31:09,519 --> 00:31:16,143
And so for a little bit of intuition here, that C value goes up depending on how many players are in each match.

629
00:31:16,683 --> 00:31:19,745
So if it was just 1v1, then the value is 1.

630
00:31:20,245 --> 00:31:25,708
But as we add more players, we are now calculating how long do I need to wait for one more player and then another player.

631
00:31:25,988 --> 00:31:27,469
So that just scales up correctly.

632
00:31:28,464 --> 00:31:33,526
In addition, the buffering time, that gets more to the point that most conventional matchmakers,

633
00:31:33,907 --> 00:31:38,569
and we did build this on top of a conventional matchmaker, will allow some amount of time to

634
00:31:38,669 --> 00:31:44,151
gather the tickets together. And that is a sort of a buffer, fluff time that needs to be worked in

635
00:31:44,511 --> 00:31:49,674
to the formula to account for. And so that it will learn how long that amount of time is

636
00:31:51,054 --> 00:31:53,295
for your particular matchmaking.

637
00:31:54,209 --> 00:32:00,056
population and matchmaker. So this is just an example of the fact that it will improve and

638
00:32:00,176 --> 00:32:07,004
adapt the way it even just predicts wait time all throughout the day appropriately and without

639
00:32:07,144 --> 00:32:13,451
having to be manually tuned. And again, there's a formula just like this for every other aspect of

640
00:32:14,012 --> 00:32:14,972
the metric predictor.

641
00:32:15,372 --> 00:32:17,073
And we don't have time to go into each of them,

642
00:32:17,173 --> 00:32:19,353
but there's a similar one so that it is even,

643
00:32:19,993 --> 00:32:22,394
it's able to refine and become more and more accurate

644
00:32:22,474 --> 00:32:26,375
on how it predicts what's gonna happen to fairness

645
00:32:26,535 --> 00:32:28,876
when we tweak a rule, what's gonna happen to latency

646
00:32:28,936 --> 00:32:29,836
when the rule's changed.

647
00:32:30,336 --> 00:32:34,278
So that is an extremely valuable input for our optimizer,

648
00:32:34,358 --> 00:32:35,098
which we will get to.

649
00:32:36,698 --> 00:32:37,639
So the optimizer.

650
00:32:38,059 --> 00:32:39,719
So I keep talking about this optimizer

651
00:32:39,759 --> 00:32:40,900
that makes rules somehow.

652
00:32:42,053 --> 00:32:43,513
Now, if you remember, if you think back,

653
00:32:44,053 --> 00:32:45,393
I showed you sort of an example

654
00:32:45,413 --> 00:32:47,114
of what our rules look like at the very beginning.

655
00:32:47,694 --> 00:32:49,434
And there are a bunch of numbers, right?

656
00:32:49,494 --> 00:32:52,275
It's usually some variable, like skill gap,

657
00:32:52,295 --> 00:32:53,775
some attribute, like the skill gap,

658
00:32:54,535 --> 00:32:56,255
and a value that says the skill gap

659
00:32:56,315 --> 00:32:57,496
can't be more than some number.

660
00:32:58,216 --> 00:32:59,876
So the rules in our matchmaker,

661
00:33:00,176 --> 00:33:01,516
we don't actually have the matchmaker

662
00:33:01,536 --> 00:33:03,097
write out a whole bunch of random rules

663
00:33:03,137 --> 00:33:03,777
that it comes up with.

664
00:33:04,217 --> 00:33:06,217
We actually pick the form of the rules.

665
00:33:06,357 --> 00:33:08,397
We still have some attribute and a number

666
00:33:08,517 --> 00:33:10,298
that it's worked on by that attribute.

667
00:33:10,872 --> 00:33:14,915
The difference here is that instead of us manually choosing what that number should be,

668
00:33:15,436 --> 00:33:19,759
we let the optimizer figure out what that number should be. It picks that number value.

669
00:33:20,419 --> 00:33:25,443
So in other words, the optimizer is just searching over this vector of numbers,

670
00:33:25,863 --> 00:33:30,526
or each number is just a number that goes into one of our rules. And there's a lot of very

671
00:33:30,566 --> 00:33:34,649
straightforward off-the-shelf ways to do that. You could use gradient ascent, you can use branch

672
00:33:34,689 --> 00:33:36,951
and bound. But at the end of the day, at this point,

673
00:33:37,521 --> 00:33:39,724
You just have a vector of numbers that you can tweak,

674
00:33:40,465 --> 00:33:42,388
your algorithm can tweak and move them up and down.

675
00:33:43,149 --> 00:33:46,593
And you have a utility function, which is coming now from your metric predictor.

676
00:33:46,894 --> 00:33:49,938
You're trusting that your metric predictor is telling you

677
00:33:50,439 --> 00:33:52,902
how those rules are going to affect the matches.

678
00:33:53,613 --> 00:33:57,695
You're trusting that it is accurate about simulating in a matter of sense,

679
00:33:58,015 --> 00:34:00,115
what type of matchmaking happens given your rules.

680
00:34:00,515 --> 00:34:01,876
So now you just use optimization.

681
00:34:02,276 --> 00:34:05,176
You give it a set of numbers and you tweak those numbers,

682
00:34:05,256 --> 00:34:07,957
and then you ask your metric predictor what the utility was,

683
00:34:08,077 --> 00:34:11,878
and then you can keep going and refining those different numbers in

684
00:34:11,898 --> 00:34:15,879
your rules until you have what you hope is an optimal set of rules.

685
00:34:16,699 --> 00:34:17,580
So again, our rules,

686
00:34:17,940 --> 00:34:20,180
let's talk again about what these rules look like.

687
00:34:21,194 --> 00:34:23,635
So here's a fairly classic rule, it's a starting point.

688
00:34:24,236 --> 00:34:27,318
So skill gap, this is a rule that says, hey, you know what?

689
00:34:27,918 --> 00:34:32,341
The skill gap between any two players has to be less than some parameter.

690
00:34:32,401 --> 00:34:34,723
That's our number, that's what that red parameter,

691
00:34:34,783 --> 00:34:36,724
that's what's going to be optimized.

692
00:34:37,265 --> 00:34:39,406
Now the question is, is this a good rule to use?

693
00:34:40,007 --> 00:34:41,648
Is this the type of rule we should be using?

694
00:34:41,688 --> 00:34:44,410
This is a very conventional, classical way to do this

695
00:34:44,590 --> 00:34:47,012
that most of you out there are probably using.

696
00:34:48,008 --> 00:34:51,090
And when you do this, you end up with that graph that we talked about again.

697
00:34:51,671 --> 00:34:54,573
This graph is what is going to be optimized over.

698
00:34:55,174 --> 00:34:59,838
This is the predictability represents the skill gap, and then you have the wait time on the bottom.

699
00:35:00,438 --> 00:35:00,618
So

700
00:35:01,387 --> 00:35:05,668
you want to pick what the optimizer is going to do is pick the point on this blue line

701
00:35:06,208 --> 00:35:11,830
that gives the best utility. Now if you decide that both predictability and wait time are equally

702
00:35:11,850 --> 00:35:16,791
important that will result in you picking something on the knee of this curve and that's the line

703
00:35:16,811 --> 00:35:22,233
you're optimizing over. So an important thing to think about is that the form of rule you choose

704
00:35:22,773 --> 00:35:24,613
decides what this line looks like.

705
00:35:25,268 --> 00:35:26,308
And so you can ask ourselves,

706
00:35:26,428 --> 00:35:28,889
are we picking the best form of the rule?

707
00:35:29,429 --> 00:35:31,329
Is there a better line we could actually get?

708
00:35:31,710 --> 00:35:32,910
And this line's different, again,

709
00:35:33,190 --> 00:35:34,610
every time of day this line changes.

710
00:35:34,630 --> 00:35:36,831
So at different times of day you're going to re-optimize,

711
00:35:36,871 --> 00:35:39,312
but even still, at a given time of day,

712
00:35:39,752 --> 00:35:41,512
is this rule creating a good line

713
00:35:41,572 --> 00:35:43,253
or could I create an even better line

714
00:35:43,773 --> 00:35:45,573
if I changed what the rule looked like?

715
00:35:46,153 --> 00:35:48,134
And that's the question Microsoft Research asked,

716
00:35:48,174 --> 00:35:49,294
of course, because they're brilliant.

717
00:35:49,774 --> 00:35:51,615
They wanted to ask and make sure

718
00:35:51,935 --> 00:35:53,155
they're picking the right line.

719
00:35:53,891 --> 00:35:58,175
And to do that, they had to change the form of the curve,

720
00:35:58,315 --> 00:36:01,698
of the form of that formula first to an equivalent form.

721
00:36:02,158 --> 00:36:04,260
It's the same, it's just as equivalent,

722
00:36:04,280 --> 00:36:06,742
you can still do a raw skill gap like you were before,

723
00:36:06,782 --> 00:36:08,984
but they're putting in a form that allows them

724
00:36:09,084 --> 00:36:12,848
to search conveniently over all possible curves

725
00:36:12,928 --> 00:36:13,668
to optimize on.

726
00:36:13,969 --> 00:36:16,070
So we're not just optimizing on a curve.

727
00:36:16,571 --> 00:36:19,453
First, we're gonna optimize over what's the best curve

728
00:36:19,473 --> 00:36:20,955
to pick to optimize on.

729
00:36:21,684 --> 00:36:23,565
So what they did was they did a bunch of math,

730
00:36:23,605 --> 00:36:25,867
they wrote a proof, I'll spare you for now on,

731
00:36:26,227 --> 00:36:27,828
but they proved you can rewrite

732
00:36:28,268 --> 00:36:31,050
this type of rule differently.

733
00:36:31,730 --> 00:36:33,592
Instead of being just give me,

734
00:36:34,452 --> 00:36:36,213
the skill gap needs to be less than some number,

735
00:36:36,694 --> 00:36:40,016
you can instead say, no, some function of the skills,

736
00:36:40,596 --> 00:36:42,197
the difference in a function of each skill

737
00:36:42,697 --> 00:36:44,238
can just always be less than the number one.

738
00:36:44,949 --> 00:36:46,770
So you don't need to change it, it can always just be one.

739
00:36:47,491 --> 00:36:49,854
Your rule doesn't need to actually change

740
00:36:50,314 --> 00:36:51,195
what the skill gap is.

741
00:36:51,635 --> 00:36:52,857
You just change that function.

742
00:36:52,897 --> 00:36:54,158
And I give a little example here.

743
00:36:54,498 --> 00:36:55,960
Don't get too caught up in it if you don't want to,

744
00:36:56,020 --> 00:36:59,824
but basically if you wanted the rule to be

745
00:37:00,424 --> 00:37:04,108
the skill gap can't be more than 0.5 between two players,

746
00:37:05,129 --> 00:37:07,191
then you basically make that F function

747
00:37:07,351 --> 00:37:08,573
just be two times the skill.

748
00:37:09,195 --> 00:37:12,236
and that'll get you right back by using that form

749
00:37:12,516 --> 00:37:14,557
to the skill gap can't be more than 0.5.

750
00:37:15,477 --> 00:37:17,658
Now this is already I wanna point out as a nice improvement

751
00:37:18,278 --> 00:37:20,879
because now what this is telling you is

752
00:37:21,540 --> 00:37:23,560
you don't actually have to change the rule

753
00:37:23,680 --> 00:37:24,661
in your matchmaker.

754
00:37:25,221 --> 00:37:27,302
The matchmaker itself could have the exact same rule

755
00:37:27,322 --> 00:37:27,902
which is just.

756
00:37:28,552 --> 00:37:30,473
A minus B has to be always less than one.

757
00:37:30,833 --> 00:37:33,233
What you're changing is what you're putting in for A and B.

758
00:37:33,573 --> 00:37:36,514
You're changing the player skill that you put in

759
00:37:36,974 --> 00:37:38,694
rather than actually changing the matchmaker.

760
00:37:39,174 --> 00:37:40,875
And so if you can't, again,

761
00:37:40,915 --> 00:37:42,755
if you don't have time to fully implement TrueMatch,

762
00:37:43,615 --> 00:37:45,576
implementing this aspect is very convenient

763
00:37:45,596 --> 00:37:48,236
because it makes it easier for you to real-time tune,

764
00:37:48,316 --> 00:37:51,017
potentially, what the gap is.

765
00:37:51,377 --> 00:37:54,417
So instead of actually changing the skill gap

766
00:37:54,597 --> 00:37:56,998
that you allow, you just change the skills as they go in.

767
00:37:57,848 --> 00:37:59,509
And I think that's a pretty cool way to do it.

768
00:38:01,050 --> 00:38:04,591
So, they used this form that I spoke about.

769
00:38:04,631 --> 00:38:07,112
They used that form of rule

770
00:38:07,532 --> 00:38:09,513
to search over all possible rules

771
00:38:09,973 --> 00:38:11,834
to find the best rule they should be using

772
00:38:12,054 --> 00:38:13,614
so that you can search along the best curve.

773
00:38:13,674 --> 00:38:15,195
And they did it, they found the best curve.

774
00:38:15,635 --> 00:38:17,976
But we don't actually use the one they found in practice

775
00:38:18,056 --> 00:38:19,716
because they found one that's almost as good

776
00:38:20,037 --> 00:38:21,297
but really simple to use.

777
00:38:21,697 --> 00:38:22,898
Well, relatively simple.

778
00:38:22,938 --> 00:38:25,358
Let's go over what they found that is easy to use.

779
00:38:25,378 --> 00:38:26,499
And again, what I mean here is...

780
00:38:27,150 --> 00:38:29,892
Well, I'll show in a second, we'll review the curves again.

781
00:38:30,332 --> 00:38:31,573
But first, let me tell you what we found.

782
00:38:32,053 --> 00:38:33,254
We found that instead of saying,

783
00:38:33,354 --> 00:38:37,297
hey, the skill gap can't be any more than some number,

784
00:38:37,958 --> 00:38:39,298
we've mapped the skills first.

785
00:38:40,299 --> 00:38:41,780
And in this case, the mapping we use

786
00:38:42,381 --> 00:38:43,762
is we take the player's skill

787
00:38:44,202 --> 00:38:46,904
and we find what percentile is that skill in?

788
00:38:47,444 --> 00:38:49,406
Is this player a 97 percentile player

789
00:38:49,446 --> 00:38:50,546
or is he an 80 percentile?

790
00:38:50,847 --> 00:38:51,887
What is the percentile?

791
00:38:52,308 --> 00:38:53,849
So we're no longer using the raw skill,

792
00:38:54,129 --> 00:38:55,810
but we're using a percentile of the skill.

793
00:38:56,411 --> 00:39:00,294
And then we scale that percentile, that scaling value,

794
00:39:00,314 --> 00:39:02,515
that is the parameter that actually gets changed,

795
00:39:02,896 --> 00:39:05,217
that actually gets optimized over by true match.

796
00:39:05,778 --> 00:39:08,459
And what that does is whatever scale you put in there,

797
00:39:08,920 --> 00:39:11,662
it represents how wide of a percentile

798
00:39:11,722 --> 00:39:13,083
you're willing to match make over.

799
00:39:13,643 --> 00:39:15,784
Instead of matchmaking on the raw gap,

800
00:39:16,345 --> 00:39:18,706
you're saying, instead of saying this player

801
00:39:18,747 --> 00:39:19,467
could match between.

802
00:39:21,294 --> 00:39:27,601
1.5 and 2.5, you're saying no, this player can match between the 80th percentile and the 82nd

803
00:39:27,641 --> 00:39:33,887
percentile. So the gap is always a percent of the population, which means that the gap

804
00:39:34,327 --> 00:39:39,292
is the same for everybody. All players get access to all the same amount of other players.

805
00:39:40,289 --> 00:39:43,191
And because every player sees the same number of players

806
00:39:43,231 --> 00:39:46,333
they can match with, wait time is constant across everyone.

807
00:39:46,714 --> 00:39:48,755
And that's why in the slide I say map the skills

808
00:39:48,795 --> 00:39:50,016
so the wait time is constant.

809
00:39:50,096 --> 00:39:51,197
Everyone has the same wait time.

810
00:39:54,299 --> 00:39:56,380
And so let me go through an example to illustrate it

811
00:39:56,400 --> 00:39:58,001
because it's a little tricky of a concept.

812
00:39:58,382 --> 00:40:00,683
So let's go through this example.

813
00:40:01,043 --> 00:40:03,705
And remember, a gap of one is okay

814
00:40:03,745 --> 00:40:06,587
because we don't actually change the gap that's required.

815
00:40:06,967 --> 00:40:09,169
So our rule will always allow if the gap is one.

816
00:40:09,814 --> 00:40:11,235
and we're gonna pick a scale of 10,

817
00:40:11,976 --> 00:40:14,078
which should mean that players can match

818
00:40:14,118 --> 00:40:18,762
between 10% of the population, give or plus or minus.

819
00:40:19,983 --> 00:40:21,304
So let's kind of look at this.

820
00:40:21,324 --> 00:40:23,786
So we have some players, A, B, and C.

821
00:40:24,126 --> 00:40:27,729
Now their skills are as written, .5, 1.0, and 1.5.

822
00:40:28,530 --> 00:40:30,912
So these are above average players.

823
00:40:30,952 --> 00:40:32,793
Let's assume that the middle is about zero.

824
00:40:33,674 --> 00:40:37,197
Now, if we just stopped here and used our rule,

825
00:40:37,257 --> 00:40:38,438
did no other transformation,

826
00:40:39,241 --> 00:40:41,142
Well, remember a skill gap of one is okay.

827
00:40:41,422 --> 00:40:43,983
So player A and C, okay, maybe they're right on the border,

828
00:40:44,003 --> 00:40:46,204
they can match, but A can match, B and B can match C.

829
00:40:46,965 --> 00:40:49,546
That's the kind of skill gap approach.

830
00:40:50,026 --> 00:40:51,947
But now let's map them onto percentiles.

831
00:40:53,348 --> 00:40:55,209
These are the percentiles that would be associated

832
00:40:55,249 --> 00:40:57,250
with these players if those skill values

833
00:40:57,270 --> 00:40:59,211
were from a normal distribution, a standard normal.

834
00:40:59,911 --> 00:41:01,091
So here's those percentiles.

835
00:41:01,232 --> 00:41:02,792
A would be in the 69th percentile.

836
00:41:03,132 --> 00:41:04,893
C is a good player in the top 93rd.

837
00:41:05,394 --> 00:41:07,094
He's a 93rd percentile, so top 7% player.

838
00:41:08,354 --> 00:41:13,496
Now again, if we're allowing a gap of 1, and we do nothing else but just map them to percentiles,

839
00:41:13,896 --> 00:41:18,239
these players could all match each other because they're all within 1. But remember, the scale is

840
00:41:19,139 --> 00:41:24,262
10. So we would multiply each of these by 10 to get what is actually the final scaled skill used

841
00:41:24,302 --> 00:41:32,246
for comparison. And again, we've said that a distance of 1 is okay. So in this case, A cannot

842
00:41:32,326 --> 00:41:37,188
match B because they are not within 1 of each other. However, B can match C.

843
00:41:38,054 --> 00:41:40,415
So unlike our raw skill approach, this is changed thing

844
00:41:40,495 --> 00:41:43,337
where changed things that A who is closer to the middle

845
00:41:43,737 --> 00:41:46,839
of the distribution, A is gonna be a little more finicky

846
00:41:46,939 --> 00:41:48,120
in who they will match skill wise

847
00:41:48,160 --> 00:41:49,761
because the population is denser there.

848
00:41:50,281 --> 00:41:53,103
Whereas B, and especially C as they move out farther

849
00:41:53,143 --> 00:41:55,264
along the population density,

850
00:41:55,564 --> 00:41:57,806
they have a wider skill, raw skill gap,

851
00:41:58,106 --> 00:41:59,847
but they still see the same amount of population

852
00:41:59,887 --> 00:42:00,828
just over a wider gap.

853
00:42:01,577 --> 00:42:04,038
And again, this allows us to ensure that the wait time

854
00:42:04,098 --> 00:42:05,499
is the same for all of our players.

855
00:42:06,099 --> 00:42:08,420
Now you may ask, okay, so you've told me,

856
00:42:09,141 --> 00:42:10,401
what, like, why are we doing all this?

857
00:42:10,982 --> 00:42:12,102
So let's get back to that.

858
00:42:12,863 --> 00:42:15,244
We did this because we're trying to ask ourselves

859
00:42:15,824 --> 00:42:19,266
what type of rules should TrueMatch be optimizing over?

860
00:42:20,106 --> 00:42:22,967
And we wanted to search the space of all possible rules,

861
00:42:23,308 --> 00:42:24,768
which Microsoft Research did for us

862
00:42:24,788 --> 00:42:25,669
because they're very smart,

863
00:42:26,109 --> 00:42:27,610
and find what rules should we use.

864
00:42:28,449 --> 00:42:33,874
and I submitted that we use a rule that does this type of transformation. And the question is, is it

865
00:42:33,914 --> 00:42:41,921
really that good? And here is a simulation we did to show how good it is. So given the same type of

866
00:42:41,981 --> 00:42:51,430
data, the yellow line is our original classic standard skill gap type curve. So if we were to

867
00:42:51,570 --> 00:42:54,133
use the original curve we picked, the original rule of just

868
00:42:54,787 --> 00:42:58,790
has to be smaller than some skill gap, we're stuck with that yellow curve. That's the best we can do

869
00:42:59,251 --> 00:43:05,416
is to search along that curve and find the optimal point for our utility. But like I said earlier,

870
00:43:05,736 --> 00:43:10,500
you want to be in the bottom left corner, that's the best you can be. That blue curve, that's what

871
00:43:10,520 --> 00:43:16,124
you get if you choose that other form of rule, that constant wait time, that scaled percentile

872
00:43:16,244 --> 00:43:19,807
type of rule. So we have found a more optimal

873
00:43:20,586 --> 00:43:28,013
rule space to search this way as well. So not only do we optimize over the best set of rules to pick,

874
00:43:28,413 --> 00:43:30,975
we're not only optimizing each rule's

875
00:43:31,894 --> 00:43:34,855
setting, we are optimizing the form of the rule itself.

876
00:43:35,395 --> 00:43:37,756
And so this is a great type of rule to use.

877
00:43:38,116 --> 00:43:40,156
So another takeaway you could pull from this,

878
00:43:40,236 --> 00:43:42,857
even if you can't implement full TrueMatch,

879
00:43:43,337 --> 00:43:45,638
is instead of matchmaking on the skill gap,

880
00:43:46,118 --> 00:43:47,978
matchmake on the percentile gap.

881
00:43:48,498 --> 00:43:50,499
Matchmake so that players can matchmake,

882
00:43:50,539 --> 00:43:52,980
say, within one or two percentile

883
00:43:53,000 --> 00:43:55,820
of where they are at on the skill curve.

884
00:43:59,280 --> 00:44:00,962
So again, at the end of the day,

885
00:44:01,002 --> 00:44:02,723
this is what we ended up with for our rules.

886
00:44:03,184 --> 00:44:05,526
They compare skill percentiles instead of skills,

887
00:44:06,286 --> 00:44:08,608
and everyone sees the same size pool of players

888
00:44:08,648 --> 00:44:11,691
to match with, and we can scale those percentiles

889
00:44:11,851 --> 00:44:13,132
as the population changes.

890
00:44:13,792 --> 00:44:15,434
During our high traffic times,

891
00:44:15,474 --> 00:44:18,196
we can say you match within 1% of the population.

892
00:44:18,396 --> 00:44:21,118
During low traffic, that can be dialed down to within 10%.

893
00:44:22,199 --> 00:44:24,161
And again, it's like doubly optimal, right?

894
00:44:24,201 --> 00:44:25,402
We've got the optimal curve,

895
00:44:25,862 --> 00:44:28,004
and we find the optimal point on the optimal curve.

896
00:44:30,729 --> 00:44:32,650
Now, what about regions? How does this work?

897
00:44:32,670 --> 00:44:34,351
Because we've talked a little bit about regions.

898
00:44:34,992 --> 00:44:37,954
Well, basically the way we implement this

899
00:44:38,194 --> 00:44:40,615
is that every pair of regions

900
00:44:41,816 --> 00:44:44,198
has their own optimized rule.

901
00:44:44,778 --> 00:44:48,400
So when I am comparing a US player to an EU player,

902
00:44:48,781 --> 00:44:50,822
there's a rule just for that comparison,

903
00:44:51,482 --> 00:44:55,165
which makes it so that we can optimize over what...

904
00:44:56,114 --> 00:44:57,995
that gap should be between those players.

905
00:44:58,295 --> 00:45:00,257
And let me do a little example to walk through

906
00:45:00,597 --> 00:45:01,717
what that effectively does.

907
00:45:02,818 --> 00:45:05,139
So here we go, we have an EU player.

908
00:45:05,740 --> 00:45:07,581
She is waiting for matchmaking, right?

909
00:45:08,061 --> 00:45:09,962
Now, if this was conventional matchmaking,

910
00:45:10,642 --> 00:45:13,464
she would say timeout after waiting for five minutes

911
00:45:13,524 --> 00:45:15,105
because there's just not enough fish in the pool.

912
00:45:15,645 --> 00:45:17,326
She's fishing, she's waited five minutes,

913
00:45:17,726 --> 00:45:19,707
she was not able to find a full match that way,

914
00:45:20,248 --> 00:45:21,028
and so she's done.

915
00:45:21,688 --> 00:45:22,929
And so in the conventional approach,

916
00:45:22,969 --> 00:45:23,710
when this would happen,

917
00:45:24,452 --> 00:45:28,273
she would say, well, I cannot find a match in the EU,

918
00:45:28,293 --> 00:45:32,275
so I will manually choose to allow matching in the US,

919
00:45:32,636 --> 00:45:34,236
which she's not as happy about

920
00:45:34,677 --> 00:45:37,458
because US matches have worse latency,

921
00:45:37,798 --> 00:45:40,379
but she'll deal with it just so she can find a match.

922
00:45:41,500 --> 00:45:43,661
Now, this is somewhat suboptimal

923
00:45:43,741 --> 00:45:46,162
because she just wasted five minutes finding this out.

924
00:45:48,503 --> 00:45:49,924
Now, here's the true match approach.

925
00:45:50,861 --> 00:45:55,862
Instead of first trying in one pool and then trying in another pool, she will search both

926
00:45:55,942 --> 00:46:02,624
pools at the same time, but with slightly different sized nets. Her net for the EU pool

927
00:46:02,664 --> 00:46:07,905
will be larger, meaning that she is willing to accept a larger skill gap than she would

928
00:46:07,945 --> 00:46:13,447
accept in the US, just so she can get more players from the EU to play with.

929
00:46:14,213 --> 00:46:20,082
So she's fishing with a larger net in the EU, and in the US, she will cast a net at the same time

930
00:46:20,583 --> 00:46:26,853
that will be smaller, so it's less likely to catch fish from the US pool.

931
00:46:28,175 --> 00:46:34,039
So basically what she's able to do is represent her personal preferences for where she wants to

932
00:46:34,099 --> 00:46:40,904
search by the size of the nets. Now the match will be made as soon as there are a total of say seven

933
00:46:40,964 --> 00:46:46,728
fish in both nets. So she could catch some from the U.S. and some from the EU, but in theory she'll

934
00:46:46,748 --> 00:46:51,211
still see the same slice of the population as everybody else and be able to match make

935
00:46:51,571 --> 00:46:55,554
in a reasonable amount of time with a good trade-off in her preferences.

936
00:46:57,818 --> 00:47:01,902
So let's look at what happens when you apply TrueMatch to a real-life situation.

937
00:47:02,703 --> 00:47:08,648
The example we are taking here came from Halo 5 in six-player free-for-all, which is six players

938
00:47:08,688 --> 00:47:14,414
who are all playing against each other to see who can win. This is a good choice for us for TrueMatch.

939
00:47:15,020 --> 00:47:21,085
because this is a playlist that has a very wide request rate over the course of a day.

940
00:47:21,545 --> 00:47:26,529
The amount of tickets that are coming in at a trough time can be a tenth of what we'll see

941
00:47:26,629 --> 00:47:31,653
at our peak times. It is not a crazy popular playlist for us, one of our not as popular ones,

942
00:47:31,993 --> 00:47:35,095
so it actually makes it a good example for what happens when you apply TrueMatch.

943
00:47:35,916 --> 00:47:38,918
So let's see what happens when we use it.

944
00:47:40,599 --> 00:47:44,542
So what I want to show here, I need to be able to compare it to something so you have some sort of

945
00:47:45,023 --> 00:47:49,687
idea of whether it's working right or not. But here we're looking at the actual utility

946
00:47:50,187 --> 00:47:55,852
over the course of time that we ran this. The utility from using TrueMatch is that yellow line

947
00:47:56,032 --> 00:48:00,996
and you'll notice that over the course of a day it is relatively flat, meaning that yes,

948
00:48:01,056 --> 00:48:03,698
it was impacted by the lower population but it did okay.

949
00:48:04,417 --> 00:48:07,079
Now what the blue line is, is something we call an oracle,

950
00:48:07,559 --> 00:48:09,180
because this is what would happen

951
00:48:09,440 --> 00:48:12,341
if I did have to choose conventional static rules,

952
00:48:12,702 --> 00:48:14,282
but I knew the future.

953
00:48:14,963 --> 00:48:17,984
So I could pick the very best static rule for the whole day,

954
00:48:18,244 --> 00:48:19,685
for just that one day.

955
00:48:20,505 --> 00:48:25,331
And that's what you see here. You'll see that it was not able to maintain as high of a utility

956
00:48:25,411 --> 00:48:30,757
despite perfect knowledge during the lower pop times of day. And that's going to translate to

957
00:48:30,797 --> 00:48:35,522
some interesting artifacts in our other metrics that we care about. So let's go look and see

958
00:48:35,642 --> 00:48:41,709
where these true match made these trade-offs. So here's the skill gap as represented by

959
00:48:41,769 --> 00:48:42,470
predictability.

960
00:48:43,422 --> 00:48:47,965
You can see here that what happened was that TrueMatch decided to raise the predictability,

961
00:48:48,305 --> 00:48:53,088
which is equivalent to raising the allowed skill gap, making matches that are not as fair.

962
00:48:53,669 --> 00:48:57,231
And so it decided to maintain the utility that it was asked for.

963
00:48:57,751 --> 00:49:01,454
It would create matches that are less fair so they could still be somewhat timely.

964
00:49:02,105 --> 00:49:07,310
whereas the static rule decided, or basically doesn't really have as much of a choice because

965
00:49:07,370 --> 00:49:12,255
it's more static, but the best static rule we could pick did not do that and for the most part

966
00:49:12,455 --> 00:49:18,501
kept that predictability the same. So the matches were more fair on the oracle during those off

967
00:49:18,541 --> 00:49:23,385
hours. But we'll see that the trade-off may not have been worth it as we switch to look at what

968
00:49:23,445 --> 00:49:24,286
the wait times did.

969
00:49:25,407 --> 00:49:31,071
So what you see here with the wait time, TrueMatch kept the wait times down to still under five minutes,

970
00:49:31,652 --> 00:49:36,235
whereas the Oracle, if we just pick the best static possible rule known ahead of time,

971
00:49:36,675 --> 00:49:41,499
is taking players up well past the 10-minute mark into even 15-minute wait times,

972
00:49:42,000 --> 00:49:45,883
just to keep a difference of about, what, 10% or so in fairness,

973
00:49:46,343 --> 00:49:49,305
which perhaps does not seem to line up with our utility.

974
00:49:49,766 --> 00:49:57,511
So again, we see the nice benefit of using TrueMatch is that despite wide variances in the amount of players who are available to play,

975
00:49:57,871 --> 00:50:00,453
we can keep those metrics more flat.

976
00:50:02,935 --> 00:50:09,480
So the takeaway from this experiment is we're able to get the same utility as the oracle during our normal population hours,

977
00:50:10,140 --> 00:50:13,903
but cut in half relative to the oracle during the off hours.

978
00:50:15,412 --> 00:50:17,013
This allows us to drop the wait time by 72%

979
00:50:17,974 --> 00:50:20,275
compared to using static rules,

980
00:50:21,016 --> 00:50:22,717
even if we knew the perfect static rule.

981
00:50:23,297 --> 00:50:26,860
And yes, we are trading 13% predictability, fairness,

982
00:50:27,380 --> 00:50:29,241
for those, we're trading that off

983
00:50:29,721 --> 00:50:31,703
instead of waiting an extra 600 seconds

984
00:50:31,743 --> 00:50:33,084
or an extra 10 minutes of wait time,

985
00:50:33,524 --> 00:50:35,485
which seems fine from the design intent.

986
00:50:35,525 --> 00:50:36,866
We generally don't ask our players

987
00:50:36,906 --> 00:50:38,667
to wait three times as long

988
00:50:39,068 --> 00:50:40,048
in order for just 13% more fairness.

989
00:50:42,084 --> 00:50:48,514
So the takeaway there is TrueMatch is doing what we expected as we asked it for from the design intent.

990
00:50:49,515 --> 00:50:53,000
So let's go into what some nice takeaways overall from TrueMatch are.

991
00:50:53,882 --> 00:50:57,247
First of all, because we have a utility function that trades off wait time,

992
00:50:58,107 --> 00:51:02,669
This allows our designers to weight the importance of different characteristics of matchmaking

993
00:51:02,990 --> 00:51:07,031
directly against how long players will wait to improve each of those different metrics.

994
00:51:07,412 --> 00:51:14,755
You want a better latency? Well, how long are you willing to wait for one millisecond better ping?

995
00:51:15,115 --> 00:51:20,378
You want it to be more fair? Okay, how long are you willing to wait for 1%, 3%, or 5%

996
00:51:20,458 --> 00:51:24,720
improvement in fairness? We can do all of those directly through the utility function.

997
00:51:25,850 --> 00:51:28,170
Another really cool aspect of TrueMatch

998
00:51:28,570 --> 00:51:30,491
is that because we have that metric predictor,

999
00:51:30,911 --> 00:51:33,391
predicting all your metrics,

1000
00:51:34,452 --> 00:51:36,172
we can tell players individually,

1001
00:51:36,372 --> 00:51:37,692
customized to that player,

1002
00:51:38,072 --> 00:51:40,013
how long they are likely to wait for a match.

1003
00:51:40,393 --> 00:51:42,073
We can give nice, customized,

1004
00:51:42,413 --> 00:51:44,034
personalized, predicted wait times.

1005
00:51:44,394 --> 00:51:46,494
This is something that's sort of been a holy grail

1006
00:51:46,514 --> 00:51:47,855
for me in my career in matchmaking,

1007
00:51:48,175 --> 00:51:50,555
to set player expectations on how long they're going to wait

1008
00:51:50,595 --> 00:51:51,635
and have those be accurate

1009
00:51:52,095 --> 00:51:54,096
by not only taking into account

1010
00:51:54,976 --> 00:51:56,597
how much traffic we're seeing right now,

1011
00:51:56,677 --> 00:51:59,538
but how many people are coming through from your region

1012
00:51:59,818 --> 00:52:02,500
and how many players are coming through at your skill level

1013
00:52:02,780 --> 00:52:04,220
so we can set those expectations.

1014
00:52:05,421 --> 00:52:07,902
And we're using real-time statistics in TrueMatch

1015
00:52:08,402 --> 00:52:09,563
and real-time feedback

1016
00:52:09,863 --> 00:52:11,624
so that we can create optimal rules

1017
00:52:11,784 --> 00:52:13,465
and optimize how well we're predicting

1018
00:52:13,885 --> 00:52:15,766
the effects of those rules all throughout the day

1019
00:52:16,126 --> 00:52:19,027
in ways that you just can't practically do manually.

1020
00:52:19,327 --> 00:52:21,588
So the machine learning is helping us tune real-time.

1021
00:52:22,496 --> 00:52:25,498
And this results in some nice real-time optimized matches

1022
00:52:25,538 --> 00:52:26,098
for our players.

1023
00:52:26,578 --> 00:52:29,960
We're trading off the wait time, the skill gaps, the latency,

1024
00:52:30,080 --> 00:52:31,841
all the things that are important to us real-time

1025
00:52:31,961 --> 00:52:32,901
based on the time of day.

1026
00:52:35,683 --> 00:52:37,984
Now, I wanted to go through some simple improvements

1027
00:52:38,584 --> 00:52:40,205
that I've covered somewhat of in this talk

1028
00:52:40,245 --> 00:52:42,646
just to remind you of things you can do even if you can't

1029
00:52:43,227 --> 00:52:44,527
implement all of TrueMatch today.

1030
00:52:45,008 --> 00:52:47,549
And one of them is what I talked about with using percentiles

1031
00:52:47,589 --> 00:52:50,550
for matchmaking instead of matchmaking directly

1032
00:52:50,670 --> 00:52:51,511
on the raw skill gap.

1033
00:52:52,139 --> 00:52:54,520
And to do this, one way to do it is to just,

1034
00:52:54,900 --> 00:52:56,100
as often as you can per hour,

1035
00:52:56,140 --> 00:52:57,321
say three or four times an hour,

1036
00:52:57,821 --> 00:53:00,102
update your own model of the population.

1037
00:53:00,182 --> 00:53:02,102
Have some way, maybe you're just tracking

1038
00:53:02,142 --> 00:53:06,184
simply the quantiles across your skill distribution

1039
00:53:06,204 --> 00:53:07,144
during every time of day.

1040
00:53:07,804 --> 00:53:09,325
Just have an idea what those are.

1041
00:53:09,885 --> 00:53:12,706
And then, and how, what the amount of population you have.

1042
00:53:13,529 --> 00:53:19,078
And then you have to have some kind of mapping that maps player skills to their percentiles.

1043
00:53:19,419 --> 00:53:24,968
If a player skill is 5.2, what percentile is that? That's the 87th percentile or whatever it may be.

1044
00:53:25,639 --> 00:53:28,020
And then, once you have a way of mapping players

1045
00:53:28,100 --> 00:53:31,140
onto their percentiles, you matchmake on percentile

1046
00:53:31,220 --> 00:53:33,021
instead of matchmaking on the raw gap.

1047
00:53:33,541 --> 00:53:36,822
And you use your real-time statistics to change the scale

1048
00:53:36,922 --> 00:53:38,542
based on how much population you have

1049
00:53:38,922 --> 00:53:39,943
at every given time of day.

1050
00:53:40,483 --> 00:53:44,204
That alone is definitely not as good as full true match,

1051
00:53:44,504 --> 00:53:46,244
but it will let your players feel like

1052
00:53:46,264 --> 00:53:48,325
they don't have to wait an extra long time

1053
00:53:48,665 --> 00:53:50,685
during low traffic times of the day

1054
00:53:51,025 --> 00:53:53,146
to get what's going to be a bad match anyways.

1055
00:53:53,566 --> 00:53:56,869
So just something to think about if you can't take away everything from TrueMatch today,

1056
00:53:57,269 --> 00:54:02,072
take away some of these points to use. And that's all I have. Thanks for coming. If you have some

1057
00:54:02,112 --> 00:54:05,975
questions, you can tweet them at me. You can try to contact me in my Discord. You can use the

1058
00:54:06,015 --> 00:54:12,620
comments section. I really am enjoying using TrueMatch myself in Halo 5. It has solved a lot

1059
00:54:12,660 --> 00:54:15,822
of the sort of issues I've had over time in matchmaking, and I hope this has been useful

1060
00:54:15,842 --> 00:54:17,383
to you as well. Thank you for coming.

