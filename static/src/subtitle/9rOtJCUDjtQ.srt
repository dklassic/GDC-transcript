1
00:00:05,662 --> 00:00:08,383
Good afternoon, ladies and gentlemen.

2
00:00:08,383 --> 00:00:10,785
First things first, I would like to remind you

3
00:00:10,785 --> 00:00:12,466
to turn off your cell phones

4
00:00:12,466 --> 00:00:15,968
and to fill out the session evaluation email.

5
00:00:15,968 --> 00:00:18,030
And let's start.

6
00:00:18,030 --> 00:00:20,371
My name is Aleksander Kauch.

7
00:00:20,371 --> 00:00:24,054
I am lead gameplay programmer at 11-Bit Studios.

8
00:00:24,054 --> 00:00:26,215
And today I would like to present you

9
00:00:26,215 --> 00:00:29,257
the architecture that we used in Frostpunk.

10
00:00:31,396 --> 00:00:36,838
A few words about me. I've been a gameplay programmer for about 9 years now.

11
00:00:36,838 --> 00:00:44,942
Most of this time I spent at 11bit Studios and I programmed titles like Anomaly, Anomaly 2, The Sword of Mine

12
00:00:44,942 --> 00:00:53,226
and most recently I was the lead gameplay programmer of Frostpunk that came out last year.

13
00:00:55,225 --> 00:01:01,430
For those of you who haven't played Frostpunk, it's a society survival game.

14
00:01:01,430 --> 00:01:10,558
So at its core, it's a city builder, but with strong emphasis on the survival aspect and harsh conditions.

15
00:01:10,558 --> 00:01:18,644
In case of Frostpunk, the world is frozen and we are the leader of the last city on Earth.

16
00:01:18,644 --> 00:01:24,369
And the game is focused on society and how the harsh conditions can change the...

17
00:01:24,970 --> 00:01:32,874
society itself, what impact does it have on the society and on our decision-making considering

18
00:01:32,874 --> 00:01:33,095
the society.

19
00:01:33,095 --> 00:01:43,100
So it was made based on liquid engine, our own homebrew technology that has been developed

20
00:01:43,100 --> 00:01:44,982
since nine years or so.

21
00:01:46,027 --> 00:01:50,895
and it was programmed by 5 gameplay programmers and 5 engine programmers

22
00:01:50,895 --> 00:01:56,504
and everything that I will present you was made by those wonderful people, me included.

23
00:01:59,570 --> 00:02:04,992
So the idea of the game had introduced us to many challenges.

24
00:02:04,992 --> 00:02:10,674
First of all, there was no solid reference for what we were trying to pull off,

25
00:02:10,674 --> 00:02:16,377
because there was no city builder game that focused on the survival aspect,

26
00:02:16,377 --> 00:02:24,860
aside from Banished maybe, but the thing that could stand out for our game was the focus on society.

27
00:02:25,585 --> 00:02:29,586
That was never seen in a city builder game as far as we know.

28
00:02:29,586 --> 00:02:33,087
So that meant for the programming team

29
00:02:33,087 --> 00:02:35,908
that we had to do a lot of research and R&D

30
00:02:35,908 --> 00:02:38,749
and support our designers who did the same.

31
00:02:38,749 --> 00:02:43,110
So fast prototyping, fast iterations,

32
00:02:43,110 --> 00:02:47,172
that was the main thing during the development.

33
00:02:47,172 --> 00:02:50,953
And aside from that, it was the biggest project

34
00:02:50,953 --> 00:02:52,733
for A11bit Studios.

35
00:02:52,733 --> 00:02:55,154
This War of Mine was made by 20 people.

36
00:02:56,239 --> 00:03:02,602
Frostpunk was made by 70 people, so the scale went up pretty high.

37
00:03:02,602 --> 00:03:10,245
The solution we came up with was data-driven architecture that was based on entity component

38
00:03:10,245 --> 00:03:10,725
systems.

39
00:03:10,725 --> 00:03:17,749
It proved to be a flexible, easily expandable architecture that allowed the design and art

40
00:03:17,749 --> 00:03:19,730
teams to create content.

41
00:03:20,395 --> 00:03:26,758
and with programmers only providing tools or new pieces of the puzzle.

42
00:03:26,758 --> 00:03:34,623
And the architecture proved to be very good for iterations and experiments.

43
00:03:34,623 --> 00:03:39,946
And I would say that without this approach, without data-driven programming, we wouldn't

44
00:03:39,946 --> 00:03:47,590
be able to create such a unique game as Frostpunk, I believe, is. And I will try to tell you why.

45
00:03:50,945 --> 00:03:58,050
So when we started programming, creating Frostpunk, we had to start from somewhere.

46
00:03:58,050 --> 00:04:04,854
The idea was that we start with something that we all well know, so the economy system,

47
00:04:04,854 --> 00:04:07,336
the building systems, and so on.

48
00:04:07,336 --> 00:04:10,438
So the requests from our design teams...

49
00:04:11,010 --> 00:04:17,758
war was where that they needed a system where they could define new entity types, they could

50
00:04:17,758 --> 00:04:20,701
introduce for example new buildings, new behaviours.

51
00:04:21,301 --> 00:04:28,184
they should be able to quickly reconfigure them and they should be able to swap features

52
00:04:28,184 --> 00:04:30,385
between entity types.

53
00:04:30,385 --> 00:04:39,750
So if we create a coal mine, the fact of gathering coal should be, we should be able to transfer

54
00:04:39,750 --> 00:04:41,511
it to another building as a feature.

55
00:04:42,742 --> 00:04:47,346
And we all knew that it won't end on 20 entity types.

56
00:04:47,346 --> 00:04:53,372
There will be more entity types, so the system should be able to scale well enough.

57
00:04:53,372 --> 00:04:54,192
So we started with data structure.

58
00:04:54,192 --> 00:05:02,480
Main piece of our data structure is something we called RTTI class.

59
00:05:03,647 --> 00:05:11,929
It is a C++ class that can be serialized to XML and to binary,

60
00:05:11,929 --> 00:05:19,071
and our RTTI system recognizes the type and loads the class from the definition.

61
00:05:19,071 --> 00:05:23,573
We use the XML in our editor, in our workplace,

62
00:05:23,573 --> 00:05:27,093
and the binary format is used in the final content.

63
00:05:29,070 --> 00:05:32,751
We also introduced globally unique identifier

64
00:05:32,751 --> 00:05:35,471
to identify RTTI classes.

65
00:05:35,471 --> 00:05:40,392
It, of course, has fixed size text form.

66
00:05:40,392 --> 00:05:42,933
I think you will understand what it is.

67
00:05:42,933 --> 00:05:49,434
And the last piece of a data structure puzzle is template.

68
00:05:49,434 --> 00:05:54,956
Template is a RTTI class that define an in-game object type.

69
00:05:54,956 --> 00:05:58,777
It is, of course, identified by unique ID.

70
00:06:00,093 --> 00:06:03,696
and it's widely supported by our editor, our tool.

71
00:06:03,696 --> 00:06:10,059
So from the template, the instances of an object are created.

72
00:06:10,059 --> 00:06:12,021
It's like a prefab in Unity.

73
00:06:12,021 --> 00:06:19,765
So the pipeline during the game load, during the work, goes like that.

74
00:06:19,765 --> 00:06:25,569
We start with XML file, then our RTTI system creates template object in memory,

75
00:06:25,569 --> 00:06:28,971
and then ClassFactory creates.

76
00:06:29,439 --> 00:06:31,960
instances of in-game objects.

77
00:06:31,960 --> 00:06:33,381
Pretty straightforward.

78
00:06:33,381 --> 00:06:34,902
Template examples, entity templates like buildings,

79
00:06:34,902 --> 00:06:39,104
like citizen template and so on.

80
00:06:39,104 --> 00:06:43,847
Components in entity component systems

81
00:06:43,847 --> 00:06:46,849
were also implemented as templates,

82
00:06:46,849 --> 00:06:49,530
mesh templates, UI recipes.

83
00:06:49,530 --> 00:06:53,572
Basically, every single thing was defined,

84
00:06:53,572 --> 00:06:56,394
is defined in our architecture by a template class.

85
00:06:59,044 --> 00:07:09,212
ETS, I think you all know what an entity component system is, so to briefly remind, it is a system

86
00:07:09,212 --> 00:07:16,598
where entity is just a container for components, the components themselves carry data only

87
00:07:16,598 --> 00:07:23,724
and systems work only on components that are attached to them. And the main advantage for

88
00:07:23,724 --> 00:07:25,546
us, especially considering the

89
00:07:26,099 --> 00:07:34,522
a number of entities in the city was that the update didn't go through entity by entity

90
00:07:34,522 --> 00:07:37,243
way, but functionality by functionality.

91
00:07:37,243 --> 00:07:44,885
So everybody in the city moved, everybody in the city starved, everybody in the city

92
00:07:44,885 --> 00:07:46,386
did their work and so on and so on.

93
00:07:46,386 --> 00:07:50,727
So state and data is kept in component.

94
00:07:50,727 --> 00:07:54,528
All logic is implemented in systems.

95
00:07:55,494 --> 00:07:59,598
But in our case, systems can also keep global state.

96
00:07:59,598 --> 00:08:03,721
It proved to be very useful for a game like Frostpunk,

97
00:08:03,721 --> 00:08:06,563
because, for example, the economy system

98
00:08:06,563 --> 00:08:11,948
keeps track of the resources the player has.

99
00:08:11,948 --> 00:08:18,293
And it is global value that can be taken from the system.

100
00:08:18,293 --> 00:08:19,934
It proved useful for us.

101
00:08:20,675 --> 00:08:25,741
So we decided to let the system keep their state.

102
00:08:25,741 --> 00:08:34,470
And we also needed to face the fact that our engine is older than entity component systems

103
00:08:34,470 --> 00:08:40,818
and not all parts of it were transferred to the new architecture.

104
00:08:41,526 --> 00:08:46,149
So some features were outside of VCS that had an impact on our code.

105
00:08:46,149 --> 00:08:51,873
And for example, that would be UI system, input system, rendering system, and so on.

106
00:08:51,873 --> 00:08:57,077
Components and component templates, as I mentioned earlier, are RTTI classes.

107
00:08:57,077 --> 00:09:06,164
Entity template has a list of component templates that are inside this entity.

108
00:09:06,164 --> 00:09:11,127
And component keeps reference to its template object.

109
00:09:11,593 --> 00:09:23,280
So constant data is kept in the template object and the mutable data is kept within components.

110
00:09:23,280 --> 00:09:26,563
Of course, via the serialization it can be saved as a safe game state.

111
00:09:26,563 --> 00:09:31,506
We introduced two restrictions to the system.

112
00:09:32,482 --> 00:09:41,504
We've decided that only one component of a type can occur inside one entity which helped us to

113
00:09:41,504 --> 00:09:51,266
keep the configuration clean and was less error prone than the approach where you can put many

114
00:09:51,266 --> 00:09:54,207
components of the same type on an entity.

115
00:09:55,094 --> 00:10:03,604
So the designer would be warned or even would be forbidden to put one, to put more than one

116
00:10:03,604 --> 00:10:10,192
component of the same type on entity. And another rule is one system per component type.

117
00:10:10,940 --> 00:10:18,866
In our architecture, one system is only taking care of and processes one component type.

118
00:10:18,866 --> 00:10:29,253
This is a single responsibility principle and it proved to be very clean for us to navigate

119
00:10:29,253 --> 00:10:29,973
through the code.

120
00:10:29,973 --> 00:10:36,458
So we had a lot of new people on board during the development of Frostpunk and the clarity

121
00:10:36,458 --> 00:10:39,140
of the code was very important for us.

122
00:10:39,651 --> 00:10:47,238
So it simplified the architecture and was easier to understand

123
00:10:47,238 --> 00:10:48,959
when one component was handled by one system.

124
00:10:48,959 --> 00:10:53,483
But that implied that there was no system

125
00:10:53,483 --> 00:10:55,545
or component classes inheritance.

126
00:10:56,997 --> 00:11:04,081
So, we technically couldn't allow the inheritance

127
00:11:04,081 --> 00:11:10,525
and through that, the only way the functionality

128
00:11:10,525 --> 00:11:15,128
of a component could be expanded

129
00:11:15,128 --> 00:11:17,129
was by adding a new component type.

130
00:11:17,129 --> 00:11:20,591
So, if there was a movement component type, for example,

131
00:11:20,591 --> 00:11:23,353
the running component type would be another component

132
00:11:23,353 --> 00:11:24,933
handled by another system.

133
00:11:26,277 --> 00:11:31,061
we add the functionality to already existing component.

134
00:11:31,061 --> 00:11:32,562
This allowed us to,

135
00:11:32,562 --> 00:11:36,906
had for the component to have a unique ID.

136
00:11:36,906 --> 00:11:41,450
So checking if the entity has a component of a type

137
00:11:41,450 --> 00:11:43,772
is just comparing bit masks.

138
00:11:43,772 --> 00:11:46,035
So it worked.

139
00:11:46,035 --> 00:11:46,695
But it introduced a new problem.

140
00:11:53,220 --> 00:11:59,041
Because of lack of inheritance, some components were dependent on each other.

141
00:11:59,041 --> 00:12:07,042
And for example, generator is a special building in Frostpunk, the main building in the center

142
00:12:07,042 --> 00:12:12,643
that provides heat for the city.

143
00:12:12,643 --> 00:12:17,964
And it has, of course, generator component, but it is also a building, so it requires

144
00:12:17,964 --> 00:12:19,484
building component.

145
00:12:19,484 --> 00:12:22,105
We solved that dependency by...

146
00:12:22,636 --> 00:12:29,838
introducing attributes and attribute require component marks component type as prerequisite

147
00:12:29,838 --> 00:12:31,838
for another component type.

148
00:12:31,838 --> 00:12:38,060
So when the generator component is added by the design team, the default building component

149
00:12:38,060 --> 00:12:44,821
is also added to an entity or the designer is prompt to define the building component

150
00:12:44,821 --> 00:12:48,362
if it's not able to be created by default.

151
00:12:50,615 --> 00:12:56,096
And on the other hand, there started to occur a problem

152
00:12:56,096 --> 00:12:57,716
with initialization order.

153
00:12:57,716 --> 00:13:01,497
So we initialized components as they were added

154
00:13:01,497 --> 00:13:05,437
by the designers, but some component needed

155
00:13:05,437 --> 00:13:10,338
to be initialized after another component.

156
00:13:10,338 --> 00:13:13,559
So we introduced attribute adapter component

157
00:13:13,559 --> 00:13:19,020
to mark that certain component type should be initialized.

158
00:13:19,597 --> 00:13:21,618
before another component type.

159
00:13:21,618 --> 00:13:24,639
And for example, workplace component is a component

160
00:13:24,639 --> 00:13:29,142
that manages the efficiency of the workers inside the building

161
00:13:29,142 --> 00:13:33,184
and to properly be initialized, it needs information

162
00:13:33,184 --> 00:13:38,907
about what is the amount of people allowed in this building.

163
00:13:38,907 --> 00:13:42,449
So it needs to be added after place for agent component

164
00:13:42,449 --> 00:13:44,050
as you can see in the example.

165
00:13:47,643 --> 00:13:55,166
Through the development of the game, the design team pinpointed that a lot of entities are

166
00:13:55,166 --> 00:14:01,629
basically the same in some way, so they have similar components attached to them.

167
00:14:01,629 --> 00:14:09,012
And they had to, when creating a new building for example, they had to copy the component

168
00:14:09,012 --> 00:14:12,473
definitions that were basically the same for every single building.

169
00:14:14,035 --> 00:14:18,897
To solve that problem and to make the designer's life easier,

170
00:14:18,897 --> 00:14:20,458
we introduced component sets.

171
00:14:20,458 --> 00:14:23,640
Component sets are batches of components

172
00:14:23,640 --> 00:14:26,941
that the designer can define.

173
00:14:26,941 --> 00:14:31,183
It can be nested inside each other,

174
00:14:31,183 --> 00:14:33,144
and it can be attached to entity.

175
00:14:33,144 --> 00:14:35,885
So aside from the component list,

176
00:14:35,885 --> 00:14:37,866
the entity also has a

177
00:14:39,162 --> 00:14:46,488
pointers to component sets that are added when the entity is initialised.

178
00:14:46,488 --> 00:14:55,335
So when the entity, the building, is a common building like any other, the basic component

179
00:14:55,335 --> 00:14:56,836
set is sufficient for them.

180
00:14:56,836 --> 00:15:02,820
But when something special should happen inside the building, the designer always can add

181
00:15:02,820 --> 00:15:05,903
the component set and add the component definition.

182
00:15:06,631 --> 00:15:14,835
of, with special configuration and the definition from an entity overloads the definition from

183
00:15:14,835 --> 00:15:16,616
a component set. And here is an example of generator component

184
00:15:22,928 --> 00:15:26,050
It inherits from some base component type,

185
00:15:26,050 --> 00:15:29,772
the component input class is an abstract class

186
00:15:29,772 --> 00:15:34,994
that basically combines the component template

187
00:15:34,994 --> 00:15:39,216
with components itself and allows the class factory

188
00:15:39,216 --> 00:15:41,977
to properly initialize the component.

189
00:15:41,977 --> 00:15:47,119
Then the capital lettered purple,

190
00:15:47,775 --> 00:15:54,636
Instructions are macros that allow the RTTI system to work properly.

191
00:15:54,636 --> 00:15:56,177
So it introduces attributes.

192
00:15:56,177 --> 00:16:03,378
As you can see, two attributes require component and add after component, which I spoke earlier.

193
00:16:03,378 --> 00:16:05,659
And then we've got property declarations.

194
00:16:05,659 --> 00:16:12,820
These are also macro definitions that add the class fields to an RTTI system.

195
00:16:12,820 --> 00:16:16,521
And then, of course, our ordinary class members.

196
00:16:16,521 --> 00:16:17,281
And...

197
00:16:17,977 --> 00:16:29,937
For the convenience of usage, we also befriend generator systems so that the system can access protected members of the component.

198
00:16:33,263 --> 00:16:35,924
An overview of our architecture looks like that.

199
00:16:35,924 --> 00:16:38,825
So the green part is what is defined

200
00:16:38,825 --> 00:16:41,186
by the design and art teams.

201
00:16:41,186 --> 00:16:45,627
So we've got behavior trees for AI system

202
00:16:45,627 --> 00:16:49,028
that is used by AI components and AI systems,

203
00:16:49,028 --> 00:16:51,489
but that's the topic for another talk.

204
00:16:51,489 --> 00:16:55,370
Then we've got templates, configuration files,

205
00:16:55,370 --> 00:16:57,251
which I'll cover in a moment.

206
00:16:58,191 --> 00:17:03,393
and other things like user interface, like engine render, and so on.

207
00:17:03,393 --> 00:17:12,937
So the game state is held by entity component systems with some helper classes that manage

208
00:17:12,937 --> 00:17:20,660
configuration files and the rendering and user interface input is like a black box in this talk.

209
00:17:23,813 --> 00:17:28,555
So we created a basic city builder with some basic economics,

210
00:17:28,555 --> 00:17:34,377
but we didn't even start to create a society survival game.

211
00:17:34,377 --> 00:17:38,158
So the design team wanted to start iterating on that.

212
00:17:38,158 --> 00:17:40,059
And they wanted a system that would allow them

213
00:17:40,059 --> 00:17:45,020
to control the flow of the game, control the narration,

214
00:17:45,020 --> 00:17:46,881
control the special events that occur,

215
00:17:46,881 --> 00:17:52,223
either from the story or from the game state itself.

216
00:17:53,871 --> 00:18:01,955
So they needed a system that could allow them to write the story via in-game events,

217
00:18:01,955 --> 00:18:08,518
some of them scripted, some of them emerging from the game state. They also needed a way to easily

218
00:18:08,518 --> 00:18:14,461
check how the player is doing, what is the state of the city and the state of the citizens.

219
00:18:16,192 --> 00:18:20,595
And another requirement, they wanted to define things once.

220
00:18:20,595 --> 00:18:22,957
So if they define a building in some place

221
00:18:22,957 --> 00:18:27,501
in the configuration, then they shouldn't be,

222
00:18:27,501 --> 00:18:31,984
shouldn't need to duplicate that definition.

223
00:18:31,984 --> 00:18:35,087
So we needed a system that would allow us

224
00:18:35,087 --> 00:18:38,309
to point certain parts of configuration

225
00:18:38,309 --> 00:18:39,690
from another parts of configuration.

226
00:18:39,690 --> 00:18:43,633
We introduced a concept of an entry

227
00:18:43,633 --> 00:18:45,255
to solve that last problem.

228
00:18:46,188 --> 00:18:52,190
Entry is an abstraction for configuration part.

229
00:18:52,190 --> 00:18:56,972
It is of course an RTTI class with its own unique ID,

230
00:18:56,972 --> 00:18:58,792
but it has also a readable name

231
00:18:58,792 --> 00:19:01,173
and of course the data it consists.

232
00:19:01,173 --> 00:19:09,096
The idea is that a configuration file,

233
00:19:09,096 --> 00:19:13,818
for example, building lists, provides entries

234
00:19:14,596 --> 00:19:22,158
then global entry manager reads these entries and the,

235
00:19:22,158 --> 00:19:25,639
once more, from another parts of configuration,

236
00:19:25,639 --> 00:19:29,481
we are able to point on that entries inside entry manager

237
00:19:29,481 --> 00:19:30,381
via entry links.

238
00:19:30,381 --> 00:19:34,102
So for example, we've got config file A,

239
00:19:34,102 --> 00:19:39,784
which consists a list of entries of type foo entry.

240
00:19:40,981 --> 00:19:47,125
Then we've got entry manager, so after the game is loaded, the file is read, the entry

241
00:19:47,125 --> 00:19:53,449
manager reads the entries and can provide a list of them.

242
00:19:53,449 --> 00:20:00,693
And from another file, we can put an entry link that points at a certain part of configuration.

243
00:20:00,693 --> 00:20:08,758
It was very useful because when entry link is a type of its own, when a class...

244
00:20:08,895 --> 00:20:17,125
an entity I class has a field of an entry type, entry link type, the designer when he's

245
00:20:17,125 --> 00:20:21,550
configuring that part of that object, that entity or whatever, he's configuring that

246
00:20:22,311 --> 00:20:25,992
is able to pick from the list of available entries.

247
00:20:25,992 --> 00:20:31,255
It's all connected via general user IDs, unique IDs.

248
00:20:31,255 --> 00:20:35,456
So the configuration is always consistent

249
00:20:35,456 --> 00:20:39,198
because when an entry that is used somewhere else

250
00:20:39,198 --> 00:20:42,319
is deleted, we can always check

251
00:20:42,319 --> 00:20:45,320
if the entry link pinpoints on something.

252
00:20:45,320 --> 00:20:48,001
And therefore we can inform the design team

253
00:20:48,001 --> 00:20:52,003
that the configuration is wrong, is error.

254
00:20:56,116 --> 00:21:03,220
And as of the narration goes, we introduced Game Events system.

255
00:21:03,220 --> 00:21:07,582
It is basically a script system that is put in XML,

256
00:21:07,582 --> 00:21:13,686
then it is loaded by the RTTI system into C++ classes

257
00:21:13,686 --> 00:21:16,347
and held in memory that way.

258
00:21:16,347 --> 00:21:21,590
So there is no scripts interpreted during runtime.

259
00:21:21,590 --> 00:21:24,912
And the idea was to...

260
00:21:26,686 --> 00:21:31,928
created for quick prototyping, but with the cleanness

261
00:21:31,928 --> 00:21:38,050
and polish of final content, so they could be valid

262
00:21:38,050 --> 00:21:38,910
in final content as well.

263
00:21:38,910 --> 00:21:44,812
The main building part of game event systems

264
00:21:44,812 --> 00:21:46,592
is of course game event.

265
00:21:46,592 --> 00:21:50,594
Game event is a configuration entry that is built

266
00:21:50,594 --> 00:21:53,935
from three lists of elements,

267
00:21:53,935 --> 00:21:56,235
triggers, conditions, and effects.

268
00:21:57,655 --> 00:22:00,997
All of these elements are configurable by the design team.

269
00:22:00,997 --> 00:22:09,102
The programming team only provided different types of triggers or conditions or effects.

270
00:22:09,102 --> 00:22:18,548
And with some additional features like local and global variables, it became almost a programming

271
00:22:18,548 --> 00:22:19,289
language.

272
00:22:19,289 --> 00:22:22,471
It has its pros and cons that we'll cover in a moment.

273
00:22:22,471 --> 00:22:22,711
So triggers.

274
00:22:28,125 --> 00:22:33,189
Triggers are objects that register themselves

275
00:22:33,189 --> 00:22:36,011
for a specific incident in game.

276
00:22:36,011 --> 00:22:37,432
So for example, a specific time of day,

277
00:22:37,432 --> 00:22:41,655
death of a citizen, new child born,

278
00:22:41,655 --> 00:22:44,157
whatever else you can imagine.

279
00:22:44,157 --> 00:22:46,939
And when that specific incident happens,

280
00:22:46,939 --> 00:22:48,480
the trigger is fired.

281
00:22:48,480 --> 00:22:52,243
So here we've got an example from our editor.

282
00:22:52,243 --> 00:22:54,925
A trigger that is named

283
00:22:54,925 --> 00:22:57,967
construction of building beacon finished.

284
00:22:58,679 --> 00:23:06,521
its classes building work, the specific building is beacon and the event occurs when the construction

285
00:23:06,521 --> 00:23:07,121
is finished.

286
00:23:07,121 --> 00:23:16,244
So the designer is able to configure the trigger a bit so to be specific when the trigger fires

287
00:23:16,244 --> 00:23:23,465
but main part of the configuration for conditions is done via conditions system.

288
00:23:23,465 --> 00:23:27,506
So conditions are basically Boolean expressions.

289
00:23:27,957 --> 00:23:35,900
that evaluate of course to true or false and they utilize some helper classes that provide

290
00:23:35,900 --> 00:23:38,181
information about the current game state.

291
00:23:38,181 --> 00:23:46,684
All in all they take form of Polish notation expression and in our editor it looks like a

292
00:23:46,684 --> 00:23:56,468
tree that is expanded and for example here we've got a comparison of integer comparison of one and

293
00:23:57,016 --> 00:24:03,318
amount of bodies, the comparison is lesser than and the left side is configured as constant

294
00:24:03,318 --> 00:24:10,800
integer with a value of 1 and the right side is that helper class that I mentioned, it

295
00:24:10,800 --> 00:24:14,221
is checking for a resource, in this case bodies. Grim.

296
00:24:14,221 --> 00:24:23,844
And last but not least we've got effects. Effects are simply put functors, so C++ objects

297
00:24:24,734 --> 00:24:29,257
are basically functions that can change game state

298
00:24:29,257 --> 00:24:32,900
when they fire, when they are executed.

299
00:24:32,900 --> 00:24:33,661
So the flow, the design I could create,

300
00:24:33,661 --> 00:24:41,707
I could work on, goes like this.

301
00:24:41,707 --> 00:24:46,030
We've got ECS systems that provide game state.

302
00:24:46,030 --> 00:24:49,212
When certain event in game occurs,

303
00:24:49,212 --> 00:24:50,773
then the trigger is fired.

304
00:24:51,691 --> 00:24:52,972
The conditions are checked.

305
00:24:52,972 --> 00:24:55,733
If the conditions are evaluated to true,

306
00:24:55,733 --> 00:24:58,174
the effects are executed.

307
00:24:58,174 --> 00:25:02,536
And if the conditions are evaluated to false,

308
00:25:02,536 --> 00:25:02,916
nothing happens.

309
00:25:02,916 --> 00:25:08,019
For example, trigger, citizen died from starvation.

310
00:25:08,019 --> 00:25:12,581
Condition, more than 30 deaths from starvation.

311
00:25:12,581 --> 00:25:16,663
Effect, the society should be manifesting or protesting

312
00:25:16,663 --> 00:25:18,583
that we need to solve the starvation problem.

313
00:25:19,980 --> 00:25:21,981
Another example, new sick citizen.

314
00:25:21,981 --> 00:25:25,022
If there are more than 10 sick citizens without medical care,

315
00:25:25,022 --> 00:25:28,484
start a quest to solve health care problem.

316
00:25:28,484 --> 00:25:32,687
Another example, day three, 12 o'clock, a bit late.

317
00:25:32,687 --> 00:25:34,328
No hunters' huts, no food.

318
00:25:34,328 --> 00:25:37,930
Create a hint for the player to build hunters' huts.

319
00:25:41,050 --> 00:25:44,873
The last missing part of the event system was the context.

320
00:25:44,873 --> 00:25:51,736
So when the event fires, for example, a new child is born,

321
00:25:51,736 --> 00:25:55,759
we want that child to be the context of the event.

322
00:25:55,759 --> 00:25:58,040
So for example, we want to give him a name

323
00:25:58,040 --> 00:25:59,581
or whatever inside effects.

324
00:25:59,581 --> 00:26:03,683
And that is provided via context.

325
00:26:03,683 --> 00:26:07,526
So every event, when the trigger fires,

326
00:26:07,526 --> 00:26:10,187
it assigns a context, an entity.

327
00:26:10,800 --> 00:26:18,204
to that event. And it is valid through the conditions part, the effects part and so on.

328
00:26:18,204 --> 00:26:27,188
So we've got an entity that fired the trigger, but sometimes we need to affect other entities

329
00:26:27,188 --> 00:26:35,232
connected somehow by the event. So for example, when a new child is born, we want to name

330
00:26:35,232 --> 00:26:39,855
that child, but we also want to raise happiness or hope for the family.

331
00:26:40,840 --> 00:26:48,826
So inside the effects, the designers can put selectors that filter entities through the city,

332
00:26:48,826 --> 00:26:57,593
through the game state basically, and execute effects with these selected entities as contexts,

333
00:26:57,593 --> 00:27:02,076
so they are able to switch context during the event execution.

334
00:27:03,089 --> 00:27:12,217
And by the way, default context for every event is generator, so when the event can't

335
00:27:12,217 --> 00:27:15,279
be really hung on anything, it is hung on generator.

336
00:27:15,279 --> 00:27:22,065
Here is an example from our tool, our editor, of a game event.

337
00:27:22,065 --> 00:27:23,907
It is a first death.

338
00:27:23,907 --> 00:27:25,888
It triggers when a citizen dies.

339
00:27:26,073 --> 00:27:35,261
and it basically creates a tough decision to build cemeteries or to just dispose the body in the snow.

340
00:27:35,261 --> 00:27:45,031
We reused parts of the system, so the conditions were used in requirements for research,

341
00:27:45,031 --> 00:27:49,795
the effects were used in technologies and in...

342
00:27:51,692 --> 00:27:54,075
policies that the player could introduce to the city,

343
00:27:54,075 --> 00:28:00,382
and the effects of course were used in hard decision choices, so the

344
00:28:00,382 --> 00:28:02,445
parts of this system

345
00:28:02,445 --> 00:28:04,968
were spread through the whole game.

346
00:28:08,274 --> 00:28:12,597
It proved to be a very useful tool for debugging.

347
00:28:12,597 --> 00:28:19,783
For example, an event could have a trigger that fires when a certain console command

348
00:28:19,783 --> 00:28:21,684
is put into.

349
00:28:21,684 --> 00:28:26,968
So it was easy for the design team to test certain story parts just by typing a command

350
00:28:26,968 --> 00:28:30,791
and the effects would be executed just like in the game.

351
00:28:34,302 --> 00:28:38,322
It controls all of our flow in game.

352
00:28:38,322 --> 00:28:43,963
The entry system and the fact that we could connect

353
00:28:43,963 --> 00:28:47,884
certain parts of configuration with certain events,

354
00:28:47,884 --> 00:28:51,965
certain entries, provided a tool to create libraries.

355
00:28:51,965 --> 00:28:56,786
So in one scenario, we've got certain event set,

356
00:28:56,786 --> 00:28:59,427
and in another scenario, we could use another event set.

357
00:29:01,622 --> 00:29:09,168
It was very complicated to configure and god, glad that we had designers that could cope

358
00:29:09,168 --> 00:29:15,854
with that because it required certain programming skill just to get into the system and without

359
00:29:15,854 --> 00:29:19,677
that we wouldn't be able to use that at all.

360
00:29:19,677 --> 00:29:25,342
And of course we are aware that we need a better tool to simplify the configuration

361
00:29:25,342 --> 00:29:27,463
because right now it looks like this.

362
00:29:27,463 --> 00:29:30,946
This is a list of directories of events.

363
00:29:31,377 --> 00:29:37,723
when we open one directory there is a list of events and when we get into an event this

364
00:29:37,723 --> 00:29:47,092
is a configuration for a single event. The XML that defines that is huge and we need

365
00:29:47,092 --> 00:29:50,675
to find a way right now to deal with that somehow. Okay, so...

366
00:29:54,938 --> 00:29:58,340
The designers were happy, but the art team wasn't.

367
00:29:58,340 --> 00:30:04,025
Of course, they created art,

368
00:30:04,025 --> 00:30:06,127
but they also needed a gameplay system.

369
00:30:06,127 --> 00:30:09,909
They needed a system that would allow them

370
00:30:09,909 --> 00:30:12,411
to check the game state,

371
00:30:12,411 --> 00:30:17,115
the conditions that are currently in the city,

372
00:30:17,115 --> 00:30:20,758
and change the appearance of buildings based on that.

373
00:30:20,758 --> 00:30:21,078
So, they needed...

374
00:30:25,792 --> 00:30:29,294
to define what visual parts would change,

375
00:30:29,294 --> 00:30:34,356
and to define the conditions when they will be changing.

376
00:30:34,356 --> 00:30:37,938
And they wanted to apply them

377
00:30:37,938 --> 00:30:40,140
on every single building in the city.

378
00:30:40,140 --> 00:30:45,583
So for example, when the temperature is low,

379
00:30:45,583 --> 00:30:48,945
is below zero degrees Celsius,

380
00:30:48,945 --> 00:30:52,327
the buildings should be covered in snow.

381
00:30:52,327 --> 00:30:53,747
But when the temperature is higher,

382
00:30:53,747 --> 00:30:54,968
the snow should disappear.

383
00:30:55,583 --> 00:30:58,445
When the building is active, there should be an animation

384
00:30:58,445 --> 00:31:01,087
that indicates the activity in that building.

385
00:31:01,087 --> 00:31:03,709
When it's not active, maybe a prompt for a player

386
00:31:03,709 --> 00:31:06,231
to that the building is not working

387
00:31:06,231 --> 00:31:09,413
and he should do something about that.

388
00:31:09,413 --> 00:31:12,896
And so on, so on.

389
00:31:12,896 --> 00:31:17,239
Night, the lights in the buildings should be on,

390
00:31:17,239 --> 00:31:17,919
day, they should be off.

391
00:31:17,919 --> 00:31:21,241
So here's an example of a generator

392
00:31:21,241 --> 00:31:23,143
in different appearance states.

393
00:31:23,143 --> 00:31:25,024
The first one is the basic state.

394
00:31:25,705 --> 00:31:33,249
The second is when we introduce laws that basically change our city into a dictatorship

395
00:31:33,249 --> 00:31:33,829
state.

396
00:31:33,829 --> 00:31:39,352
The third one is when we go too far with our religion to the point of fanaticism.

397
00:31:39,352 --> 00:31:46,315
And the other three are different upgrade states for the generator.

398
00:31:46,315 --> 00:31:54,538
And the tricky part is that we needed a system that would allow us to combine the totalitarian

399
00:31:55,370 --> 00:32:01,892
generator with the third or second upgrade. To do that we introduced appearance state.

400
00:32:01,892 --> 00:32:09,554
Appearance state is basically a string label or a config entry that is defined by designers

401
00:32:09,554 --> 00:32:17,295
or artists and can be added or removed by game state mechanisms or by effects. A building

402
00:32:17,295 --> 00:32:24,217
can have an infinite amount of active appearance states. For example, if you have a building

403
00:32:24,952 --> 00:32:29,714
For example, active totalitarian building during night and so on.

404
00:32:29,714 --> 00:32:36,877
And for the visuals, some of these states should be able to be excluded.

405
00:32:36,877 --> 00:32:41,239
So, for example, building during night and not under construction.

406
00:32:41,239 --> 00:32:46,902
And the final visuals of the building depends on the combinations of these appearance states.

407
00:32:50,384 --> 00:32:55,008
The appearance state can affect many, many different things.

408
00:32:55,008 --> 00:32:58,050
Of course, mesh elements, props like flags,

409
00:32:58,050 --> 00:33:00,292
like the religious symbols and so on,

410
00:33:00,292 --> 00:33:05,856
lights, textures, outlines, shaders, animations,

411
00:33:05,856 --> 00:33:09,058
UI icons, sounds, basically everything

412
00:33:09,058 --> 00:33:11,200
that surrounds the building,

413
00:33:11,200 --> 00:33:15,183
and it has any impact visually

414
00:33:15,183 --> 00:33:17,125
or sound-wise on the player.

415
00:33:20,150 --> 00:33:25,373
To aggregate the things that are changed by the appearance,

416
00:33:25,373 --> 00:33:29,595
we created appearance overlay.

417
00:33:29,595 --> 00:33:32,736
Appearance overlay is a definition

418
00:33:32,736 --> 00:33:37,419
of what changes when this overlay is applied.

419
00:33:37,419 --> 00:33:41,761
So for example, visibility of certain props, animation

420
00:33:41,761 --> 00:33:42,941
start, stop, and so on.

421
00:33:42,941 --> 00:33:47,344
When the building is active, the animation should start.

422
00:33:47,344 --> 00:33:49,565
When the building is not active, the animation should stop.

423
00:33:50,786 --> 00:33:54,309
So this combined with appearance conditions

424
00:33:54,309 --> 00:34:01,535
creates a system that applies certain overlay on appearance

425
00:34:01,535 --> 00:34:03,756
when the conditions are met.

426
00:34:03,756 --> 00:34:08,480
So when the conditions are that the building

427
00:34:08,480 --> 00:34:09,221
should be active during night,

428
00:34:09,221 --> 00:34:14,325
we should apply appearance overlay that puts on the lights.

429
00:34:14,325 --> 00:34:17,267
And this is how we did it.

430
00:34:19,788 --> 00:34:24,511
This is a simple sample configuration of appearance state.

431
00:34:24,511 --> 00:34:28,273
This is an appearance for a building that is outside required heat zone.

432
00:34:28,273 --> 00:34:32,055
So the building needs to be heated and it isn't.

433
00:34:32,055 --> 00:34:37,038
The conditions are the building is constructed, the building requires heat zone,

434
00:34:37,038 --> 00:34:39,280
the place is outside heat zone.

435
00:34:40,021 --> 00:34:47,667
And the weather is different than storm, because during the storm we provide the player with different prompts,

436
00:34:47,667 --> 00:34:53,893
not that meaningful, meaningless prompt that the building requires heat zone.

437
00:34:53,893 --> 00:35:01,879
And the overlay is only changing status indicator, in this case it is an icon above the building.

438
00:35:01,879 --> 00:35:08,365
So when these conditions are met, the building has these appearance states.

439
00:35:09,042 --> 00:35:14,225
The icon appears and the players are informed that the building requires heat zone and it

440
00:35:14,225 --> 00:35:15,146
isn't inside the heat zone.

441
00:35:15,146 --> 00:35:17,308
So to sum up, the data-driven architecture, as I have shown you in examples, provided

442
00:35:17,308 --> 00:35:30,637
us with the ability to quickly iterate with minimum involvement of the programming team.

443
00:35:30,637 --> 00:35:38,143
It allowed us to create rapid prototypes.

444
00:35:38,702 --> 00:35:47,085
and the programmers were only introducing new toys for designers to play with.

445
00:35:47,085 --> 00:35:48,365
And artists, of course.

446
00:35:48,365 --> 00:35:57,189
And the ECS system that lies underneath it glued everything together and was an efficient

447
00:35:57,189 --> 00:36:01,151
system that allowed, once again, rapid prototyping and lots of R&D that the game required.

448
00:36:01,151 --> 00:36:01,411
That is all.

449
00:36:01,411 --> 00:36:02,131
Thank you very much.

450
00:36:02,131 --> 00:36:03,471
And thank you.

451
00:36:03,471 --> 00:36:03,772
Thank you.

452
00:36:03,772 --> 00:36:04,712
Thank you very much.

453
00:36:08,827 --> 00:36:31,703
If you have some questions I will gladly answer them.

454
00:36:34,012 --> 00:36:35,512
What can be a template for what?

455
00:36:35,512 --> 00:36:36,152
Component.

456
00:36:36,152 --> 00:36:39,553
If you have some component, you specify template

457
00:36:39,553 --> 00:36:40,574
for this component.

458
00:36:40,574 --> 00:36:41,214
What is template?

459
00:36:41,214 --> 00:36:45,095
Template is just the definition of an object.

460
00:36:45,095 --> 00:36:49,057
So for example, the template defines

461
00:36:49,057 --> 00:36:52,218
what fields are in the object and what

462
00:36:52,218 --> 00:36:54,659
is configurable by the designer.

463
00:36:54,659 --> 00:36:59,520
So the designer only sees the fields that are in the template.

464
00:37:00,417 --> 00:37:07,859
Okay, so component itself does not have fields, configurable fields, or...

465
00:37:07,859 --> 00:37:13,001
No, it does have, but, okay, there is a configuration and there is runtime.

466
00:37:13,001 --> 00:37:22,864
So, in the configuration part we've got templates only that define, that can be configured and create the component.

467
00:37:22,864 --> 00:37:24,965
And when the component lives inside the runtime...

468
00:37:25,540 --> 00:37:34,890
it can change the state and it only has states but the definition remains the same. It's

469
00:37:34,890 --> 00:37:39,014
the same concept as with the class definition and class instances.

470
00:37:40,438 --> 00:37:42,359
Thank you.

471
00:37:42,359 --> 00:37:46,721
So with the appearance system that you can have

472
00:37:46,721 --> 00:37:51,264
authoritarian, not knight and everything, that can define a

473
00:37:51,264 --> 00:37:54,245
huge matrix of different visual configurations for a

474
00:37:54,245 --> 00:37:56,426
building, for example.

475
00:37:56,426 --> 00:38:00,528
Did you do like one special mesh for each case, which

476
00:38:00,528 --> 00:38:02,770
sounds like that's a lot of meshes, or some kind of

477
00:38:02,770 --> 00:38:06,672
combination system so that you overlay the flags over the

478
00:38:06,672 --> 00:38:07,652
building, or something like that?

479
00:38:09,478 --> 00:38:16,482
So we used the simplest way the art team could cope with.

480
00:38:16,482 --> 00:38:21,344
So our artists aren't really into configuration.

481
00:38:21,344 --> 00:38:26,886
So we gave them a tool that basically uses the name

482
00:38:26,886 --> 00:38:28,947
of the mesh used in the entity

483
00:38:28,947 --> 00:38:35,030
so that they can show every single mesh that has that name.

484
00:38:36,091 --> 00:38:43,555
And therefore they do not need to look into the configuration, they only need to look into the elements named in the editor.

485
00:38:47,110 --> 00:38:53,853
So, so say, um, they have to decide for each case, like, uh, I don't know how many

486
00:38:53,853 --> 00:38:58,556
case, but if it's fanatic and it's not night, could be a different like visual

487
00:38:58,556 --> 00:38:59,736
configuration that if it's, uh, okay.

488
00:38:59,736 --> 00:38:59,876
Right.

489
00:38:59,876 --> 00:39:00,176
Yeah.

490
00:39:00,176 --> 00:39:07,580
They gave the designers and, uh, programmers requirements and we created

491
00:39:07,580 --> 00:39:08,861
the configuration for them.

492
00:39:09,513 --> 00:39:17,338
only a few of them could make that configuration. There was a lot of cases, but with the naming

493
00:39:17,338 --> 00:39:27,004
convention, we could allow them just to, you know, they put an effect that has night inside

494
00:39:27,004 --> 00:39:36,069
it, and it was already configured before, so it would be applied in every building.

495
00:39:36,069 --> 00:39:37,390
The effect with night is there.

496
00:39:37,390 --> 00:39:37,870
Okay, thank you.

497
00:39:41,516 --> 00:39:47,163
Hi. I was just wondering on how you actually managed to create a bridge between your visual

498
00:39:47,163 --> 00:39:54,371
and your system because, well, the classic MVC, you want to separate your view from your

499
00:39:54,371 --> 00:39:59,357
system, but did you create specific system to create that bridge between your entity,

500
00:39:59,357 --> 00:40:00,859
your building, and the visuals?

501
00:40:02,536 --> 00:40:06,778
Well, it is one way communication.

502
00:40:06,778 --> 00:40:10,979
So the flow is always like this.

503
00:40:10,979 --> 00:40:13,600
It always starts with the game state

504
00:40:13,600 --> 00:40:16,261
and the visuals depend on the game state.

505
00:40:16,261 --> 00:40:18,822
Just like the view always reads the data.

506
00:40:18,822 --> 00:40:19,862
It's the same concept.

507
00:40:19,862 --> 00:40:20,263
Okay.

508
00:40:20,263 --> 00:40:22,783
And also I just wanted to,

509
00:40:22,783 --> 00:40:26,625
did you inspire yourself by existing ECS system

510
00:40:26,625 --> 00:40:27,705
or was it 100% custom made?

511
00:40:27,705 --> 00:40:28,726
Once more, I'm sorry?

512
00:40:31,408 --> 00:40:35,436
Sorry, did you inspire yourself by existing ECS system

513
00:40:35,436 --> 00:40:37,380
or did you build this from the ground up?

514
00:40:38,125 --> 00:40:43,990
When we started developing Frostpunk it was like four years ago or so.

515
00:40:43,990 --> 00:40:49,515
I don't recall any existing ETS system that was production ready.

516
00:40:49,515 --> 00:40:59,664
But yeah, Unity and Unreal I think they already started developing and there were some papers that we based our system on.

517
00:40:59,664 --> 00:41:05,129
So yeah, it wasn't from the ground our idea, by no means.

518
00:41:05,129 --> 00:41:05,729
But I can't...

519
00:41:06,390 --> 00:41:09,831
a long time ago. I can't really remember what references did we use.

520
00:41:09,831 --> 00:41:12,172
Okay. Thanks. I was just curious. Thank you.

521
00:41:12,172 --> 00:41:15,853
I have a question about a system and component.

522
00:41:15,853 --> 00:41:23,376
You mentioned that one system deals with one component, right?

523
00:41:23,376 --> 00:41:32,119
Yes. So what if the designer needs some function that you need to deal with the data from two components?

524
00:41:33,066 --> 00:41:39,932
Well, the components are accessible via systems, so one system can communicate with another

525
00:41:39,932 --> 00:41:43,935
system and get the data from certain components.

526
00:41:43,935 --> 00:41:53,343
It's just the one system can change the components of one type and getting data from another

527
00:41:53,343 --> 00:41:57,547
system, another component is like no issue, it's no problem.

528
00:41:58,837 --> 00:42:04,162
So the, what I mean by one system, one component type is

529
00:42:04,162 --> 00:42:07,324
that one system can change the data of one component type.

530
00:42:07,324 --> 00:42:07,945
Okay, thanks.

531
00:42:10,815 --> 00:42:15,582
I'm a little green with ECS systems in general, but you

532
00:42:15,582 --> 00:42:19,727
mentioned that your old engine didn't support ECS for the

533
00:42:19,727 --> 00:42:21,389
visuals and the input.

534
00:42:21,389 --> 00:42:24,533
Is that an area that you would have liked to extend to ECS?

535
00:42:24,533 --> 00:42:27,977
I've heard things in the past that usually the visuals are

536
00:42:27,977 --> 00:42:29,640
kept out of ECS systems.

537
00:42:30,378 --> 00:42:39,224
Well, I think that as far as I remember that our engine team is already porting certain

538
00:42:39,224 --> 00:42:42,206
parts of the engine to the ECS system.

539
00:42:42,206 --> 00:42:51,032
But as I am stuck with Frostpunk for now, I'm not updated about the newest changes in

540
00:42:51,032 --> 00:42:53,274
the engine because it won't affect Frostpunk.

541
00:42:53,494 --> 00:43:02,802
at all. So, but yeah, they, they try to move to ECS even with the rendering, but if they

542
00:43:02,802 --> 00:43:04,664
pull that off, I don't know.

543
00:43:04,664 --> 00:43:06,505
Yeah, awesome. Well, thank you very much.

544
00:43:06,505 --> 00:43:06,685
Thanks.

545
00:43:06,685 --> 00:43:06,945
Thank you.

546
00:43:06,945 --> 00:43:13,471
Hi, you mentioned that input and UI were two of the things that had to live outside of

547
00:43:13,471 --> 00:43:17,494
the ECS control, but you also mentioned that there were UI recipes. Could you briefly explain

548
00:43:17,494 --> 00:43:18,735
what the UI recipes were?

549
00:43:19,378 --> 00:43:28,165
Well, the ECS system and the templates and the RTTI that I was talking about are separate things.

550
00:43:28,165 --> 00:43:35,010
So the UI system uses UI recipes as templates to create user interface.

551
00:43:35,010 --> 00:43:42,576
So once again, we've got editors that create XML files that are read by RTTI and the final UI is created.

552
00:43:42,576 --> 00:43:47,880
Okay, so it was just the data format that was being shared there, but then completely outside of ECS?

553
00:43:47,880 --> 00:43:48,320
Yes.

554
00:43:48,320 --> 00:43:49,181
Gotcha. Okay, thank you.

555
00:43:53,163 --> 00:43:55,745
All right, no more questions, so thank you very much.

