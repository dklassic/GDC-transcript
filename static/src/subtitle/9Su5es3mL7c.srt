1
00:00:06,488 --> 00:00:09,071
All right, yesterday we learned

2
00:00:09,071 --> 00:00:10,573
that I should have a picture of a cat.

3
00:00:10,573 --> 00:00:13,976
Unfortunately, today I'm only gonna show you dogs.

4
00:00:13,976 --> 00:00:15,638
Anyway, my name is Tobias Carlsen.

5
00:00:15,638 --> 00:00:17,620
I work at Microsoft, and today I'm gonna talk

6
00:00:17,620 --> 00:00:18,961
about Quarter Belt Locomotion.

7
00:00:18,961 --> 00:00:21,043
First, a little bit of background.

8
00:00:21,043 --> 00:00:23,886
For the past year or so, I've been working on Project FAG,

9
00:00:23,886 --> 00:00:25,868
which is about bringing a virtual pet

10
00:00:25,868 --> 00:00:27,610
to the Microsoft HoloLens.

11
00:00:28,510 --> 00:00:31,231
However, this is not a HoloLens specific talk,

12
00:00:31,231 --> 00:00:34,012
but some of our data will perhaps look

13
00:00:34,012 --> 00:00:35,412
a little bit peculiar,

14
00:00:35,412 --> 00:00:38,553
and that is because we're on the HoloLens.

15
00:00:38,553 --> 00:00:40,894
So as I said, we're going to talk about

16
00:00:40,894 --> 00:00:42,295
quarter-petal locomotion today,

17
00:00:42,295 --> 00:00:44,295
but not just any kind of quarter-petal locomotion.

18
00:00:44,295 --> 00:00:47,416
The kind of techniques I'm going to show you here today

19
00:00:47,416 --> 00:00:50,757
are techniques that you're mostly probably

20
00:00:50,757 --> 00:00:52,038
already familiar with.

21
00:00:52,657 --> 00:00:56,518
And these are also techniques that

22
00:00:56,518 --> 00:00:59,539
should work in any sort of real-time constrained

23
00:00:59,539 --> 00:01:02,300
situation, like a game or similar applications.

24
00:01:02,300 --> 00:01:07,801
So first, I'm going to show you a video of what Fang, our dog,

25
00:01:07,801 --> 00:01:10,502
actually looks like in a virtual environment.

26
00:01:10,502 --> 00:01:14,103
And this is essentially the aspiration of our talk.

27
00:01:14,103 --> 00:01:16,223
This is what we want to create in the end.

28
00:01:18,563 --> 00:01:22,005
So here we got Fang walking in his environment,

29
00:01:22,005 --> 00:01:25,927
and I hope you agree that that's realistic-looking

30
00:01:25,927 --> 00:01:27,688
quadruped locomotion.

31
00:01:27,688 --> 00:01:29,509
So how did we do this?

32
00:01:29,509 --> 00:01:32,690
First, we generate a smooth, realistic-looking path

33
00:01:32,690 --> 00:01:33,531
for the dog to follow.

34
00:01:33,531 --> 00:01:37,893
And as it turns out, the quality of the path

35
00:01:37,893 --> 00:01:40,714
is much more important for quadruped locomotion

36
00:01:40,714 --> 00:01:42,635
than it is for normal biped locomotion.

37
00:01:43,647 --> 00:01:46,608
And then we use a mixture of procedural and canned

38
00:01:46,608 --> 00:01:50,289
animations to create a realistic-looking locomotion

39
00:01:50,289 --> 00:01:50,629
pattern.

40
00:01:50,629 --> 00:01:52,470
At the end of this talk, I'm also

41
00:01:52,470 --> 00:01:56,511
going to cover a few tips and tricks that we

42
00:01:56,511 --> 00:01:59,611
found very useful when we implemented OrgQuadruped.

43
00:01:59,611 --> 00:02:02,492
And hopefully, you will find them useful as well.

44
00:02:02,492 --> 00:02:06,613
First, though, a word about pathfinding size.

45
00:02:06,613 --> 00:02:08,754
So we use a pathfinding radius on our dog

46
00:02:08,754 --> 00:02:12,075
that is roughly equal to half the dog's shoulder width.

47
00:02:12,950 --> 00:02:17,971
This allows the dog to path between obstacles that are quite close together.

48
00:02:17,971 --> 00:02:24,532
However, it also means that the dog needs to follow the path

49
00:02:24,532 --> 00:02:27,073
going forward or potentially backward along the path.

50
00:02:27,073 --> 00:02:29,974
It cannot move sideways or strafe along the path.

51
00:02:29,974 --> 00:02:34,735
This is obviously different from what we're used to with biped locomotion.

52
00:02:35,984 --> 00:02:38,688
where we just used the projected bounding radius

53
00:02:38,688 --> 00:02:39,950
on the ground of the character.

54
00:02:39,950 --> 00:02:41,893
And it doesn't really matter which direction

55
00:02:41,893 --> 00:02:43,395
the character is facing.

56
00:02:43,395 --> 00:02:46,720
He will always be able to fit in on the path.

57
00:02:46,720 --> 00:02:50,265
Normally, in situations with this.

58
00:02:50,969 --> 00:02:56,133
we need to take turn radius into account for the path we build.

59
00:02:56,133 --> 00:03:00,917
Fortunately for us though, our dog has a very good turning radius

60
00:03:00,917 --> 00:03:06,942
and because we do the smoothing post-processing step on our path,

61
00:03:06,942 --> 00:03:09,684
that removes all the sharp corners.

62
00:03:09,684 --> 00:03:12,966
And finally, as it turns out, in real-world situations,

63
00:03:12,966 --> 00:03:15,368
there just aren't any really, really nasty corners.

64
00:03:17,590 --> 00:03:20,172
So this is what the world looks like in the HoloLens.

65
00:03:20,172 --> 00:03:24,336
This is the kind of mesh that the HoloLens creates

66
00:03:24,336 --> 00:03:25,517
of the world.

67
00:03:25,517 --> 00:03:26,938
As you can see, it's quite noisy.

68
00:03:26,938 --> 00:03:30,280
If you squint a little bit, you may be able to notice

69
00:03:30,280 --> 00:03:32,362
that this is actually a living room.

70
00:03:32,362 --> 00:03:35,745
There's a TV in here, a sofa, and some other furniture.

71
00:03:35,745 --> 00:03:38,247
What's important to know about this mesh

72
00:03:38,247 --> 00:03:41,930
is that it's constantly being refined by the HoloLens.

73
00:03:43,163 --> 00:03:45,765
That means it's constantly changing on us.

74
00:03:45,765 --> 00:03:48,846
And even worse, there's nothing preventing the user

75
00:03:48,846 --> 00:03:50,287
from just turning around and looking

76
00:03:50,287 --> 00:03:52,088
in a completely different direction

77
00:03:52,088 --> 00:03:54,269
in which you have not looked before,

78
00:03:54,269 --> 00:03:56,130
or just walking into a different room,

79
00:03:56,130 --> 00:03:58,291
which means that all of a sudden,

80
00:03:58,291 --> 00:03:59,971
this mesh can grow very quickly,

81
00:03:59,971 --> 00:04:03,033
and we need to be able to create pathfinding data

82
00:04:03,033 --> 00:04:04,794
on the fly pretty much immediately.

83
00:04:04,794 --> 00:04:08,816
So the way we do that is we have a very simplified

84
00:04:08,816 --> 00:04:10,716
representation of the pathfinding data.

85
00:04:11,662 --> 00:04:14,983
It consists of a bunch of nodes,

86
00:04:14,983 --> 00:04:17,163
each has a position and a radius,

87
00:04:17,163 --> 00:04:19,764
and then they are connected through a minimal tree.

88
00:04:19,764 --> 00:04:23,885
This picture here on the slide shows an example

89
00:04:23,885 --> 00:04:26,326
of some geometry that we have covered

90
00:04:26,326 --> 00:04:27,327
with our pathfinding data.

91
00:04:28,637 --> 00:04:30,818
And you may think that it's a little bit unusual

92
00:04:30,818 --> 00:04:33,299
to use this kind of representation

93
00:04:33,299 --> 00:04:36,199
when we started off with a good mesh

94
00:04:36,199 --> 00:04:39,660
covering and representing the world we wanted to do.

95
00:04:39,660 --> 00:04:41,121
Why don't we use the NAND mesh?

96
00:04:41,121 --> 00:04:44,402
Well, the reason for that is, first of all,

97
00:04:44,402 --> 00:04:46,342
NAND meshes are expensive to compute,

98
00:04:46,342 --> 00:04:48,623
and the raw data that we have

99
00:04:48,623 --> 00:04:50,363
is not suitable for doing pathfinding on.

100
00:04:51,469 --> 00:04:55,473
And so this representation is very quick to compute,

101
00:04:55,473 --> 00:04:58,255
unlike the NAMM mesh, so that's one of the big benefits.

102
00:04:58,255 --> 00:05:00,737
The second benefit is that we can do search

103
00:05:00,737 --> 00:05:03,019
of certain spatial queries very effectively

104
00:05:03,019 --> 00:05:06,602
in this representation that would be much more expensive

105
00:05:06,602 --> 00:05:09,525
in a pathfinding mesh.

106
00:05:09,525 --> 00:05:10,866
So now we've got some pathfinding data,

107
00:05:10,866 --> 00:05:12,487
and we need to generate a path.

108
00:05:13,792 --> 00:05:17,514
So we start out by creating a rough path using A star.

109
00:05:17,514 --> 00:05:19,575
And then we optimize that path using string pulling.

110
00:05:19,575 --> 00:05:21,817
And at this point, this is generally

111
00:05:21,817 --> 00:05:24,559
where people would say, this is enough for my biped.

112
00:05:24,559 --> 00:05:26,560
And we have a good path.

113
00:05:26,560 --> 00:05:28,561
It's a very optimal path.

114
00:05:28,561 --> 00:05:30,963
And it will get us where we want to go.

115
00:05:30,963 --> 00:05:34,885
However, for a quarterped, these paths don't look very good.

116
00:05:34,885 --> 00:05:38,408
And I'm now going to show you a video of Fang following

117
00:05:38,408 --> 00:05:40,429
one of these biped-style paths.

118
00:05:42,830 --> 00:05:46,373
As you can see, the turns become very, very sharp,

119
00:05:46,373 --> 00:05:48,494
and that does not look very, very good.

120
00:05:48,494 --> 00:05:51,296
So, we need to deal with this.

121
00:05:51,296 --> 00:05:53,577
So, we need to create a better path,

122
00:05:53,577 --> 00:05:56,640
and the way we do that is that we smooth the path.

123
00:05:56,640 --> 00:05:58,721
But before we smooth the path,

124
00:05:58,721 --> 00:06:01,102
we need to subdivide the path.

125
00:06:01,804 --> 00:06:05,847
And the reason for that is once we have optimized the path,

126
00:06:05,847 --> 00:06:09,370
the path contains very few waypoints

127
00:06:09,370 --> 00:06:10,631
because it's an optimized path.

128
00:06:10,631 --> 00:06:12,413
We just take direct routes wherever we can.

129
00:06:12,413 --> 00:06:15,215
And the number of waypoints and segments of the path

130
00:06:15,215 --> 00:06:19,618
is essentially the resolution of the path

131
00:06:19,618 --> 00:06:21,560
that we have to work with when we smooth it.

132
00:06:21,560 --> 00:06:25,703
So this is the same motion, but with a smooth path.

133
00:06:25,703 --> 00:06:28,665
And as you can see, this makes a very large difference

134
00:06:28,665 --> 00:06:30,787
to how we perceive thanks motion.

135
00:06:32,628 --> 00:06:38,053
So we started smoothing the PATH using a physics-based model.

136
00:06:38,053 --> 00:06:40,235
What we would have was a collection of springs,

137
00:06:40,235 --> 00:06:42,638
torsion springs to even out the PATH,

138
00:06:42,638 --> 00:06:46,081
and linear springs to make sure that the PATH didn't really

139
00:06:46,081 --> 00:06:47,582
lose its shape.

140
00:06:47,582 --> 00:06:52,307
And then we would iterate over these springs as we simulate

141
00:06:52,307 --> 00:06:52,747
them.

142
00:06:53,759 --> 00:06:55,560
And where the springs came to rest,

143
00:06:55,560 --> 00:06:57,441
that would be our smooth path.

144
00:06:57,441 --> 00:07:02,024
Some of you may be already familiar with this technique.

145
00:07:02,024 --> 00:07:05,265
It's been used for creating racing lines in racing games.

146
00:07:05,265 --> 00:07:09,107
And this worked great for us most of the time.

147
00:07:09,107 --> 00:07:13,029
However, certain paths, usually a little bit longer,

148
00:07:13,029 --> 00:07:14,890
but not that much longer, like 10, 20% longer

149
00:07:14,890 --> 00:07:18,272
than our average path, would produce paths

150
00:07:18,272 --> 00:07:20,093
with kinks and knots in them.

151
00:07:20,935 --> 00:07:24,176
And even if we increased our number of iterations

152
00:07:24,176 --> 00:07:26,977
that we ran a simulation, even tenfold,

153
00:07:26,977 --> 00:07:31,218
these knots and kinks wouldn't necessarily be worked out.

154
00:07:31,218 --> 00:07:33,699
So we needed a better solution.

155
00:07:33,699 --> 00:07:35,679
And one of my colleagues, Mark Langrag,

156
00:07:35,679 --> 00:07:41,100
suggested that we should think of Pov smoothing

157
00:07:41,100 --> 00:07:42,581
as an optimization problem.

158
00:07:42,581 --> 00:07:44,861
And the good news about optimization problems

159
00:07:44,861 --> 00:07:48,722
is that there are plenty of well-known algorithms out there

160
00:07:48,722 --> 00:07:50,343
for solving optimization problems.

161
00:07:51,255 --> 00:07:54,817
Mark further suggested that we'd use Shambhala-Pock,

162
00:07:54,817 --> 00:07:57,599
or Shambhala-Pock's first-order primal dual algorithm.

163
00:07:57,599 --> 00:07:59,380
And this was a great suggestion.

164
00:07:59,380 --> 00:08:02,662
Shambhala-Pock was almost an order of magnitude

165
00:08:02,662 --> 00:08:06,303
more effective than the physics simulation.

166
00:08:06,303 --> 00:08:08,265
Just do two passes over the data per iteration.

167
00:08:08,265 --> 00:08:12,187
These are very simple passes,

168
00:08:12,187 --> 00:08:14,208
well-optimized code, no branching or anything.

169
00:08:15,066 --> 00:08:17,628
And also, a shamble pof worked well with constraints.

170
00:08:17,628 --> 00:08:20,911
And the reason why we're concerned with constraints is

171
00:08:20,911 --> 00:08:25,634
when we did this moving, we took each waypoint in the pof

172
00:08:25,634 --> 00:08:28,096
and assigned it to a pof-hungry node.

173
00:08:28,096 --> 00:08:29,978
And remember, the pof-hungry nodes

174
00:08:29,978 --> 00:08:31,839
had a position and a radius.

175
00:08:31,839 --> 00:08:35,042
So we said the waypoint was not allowed

176
00:08:35,042 --> 00:08:37,904
to be moved outside its corresponding pof-hungry node.

177
00:08:38,745 --> 00:08:41,806
This had two big benefits for us.

178
00:08:41,806 --> 00:08:44,907
First of all, it reduced the amount of movement

179
00:08:44,907 --> 00:08:45,688
for the waypoints.

180
00:08:45,688 --> 00:08:49,269
And that meant that we could find a good solution quicker

181
00:08:49,269 --> 00:08:52,971
because there were less dynamic things happening

182
00:08:52,971 --> 00:08:55,732
in our smoothing operation.

183
00:08:55,732 --> 00:08:58,753
And secondly, it allowed us to guarantee

184
00:08:58,753 --> 00:09:00,734
that the path that we created from smoothing

185
00:09:00,734 --> 00:09:03,295
was still a valid path because all the waypoints

186
00:09:03,295 --> 00:09:05,376
were on valid pathfinding nodes.

187
00:09:06,811 --> 00:09:10,233
So, getting back to optimization,

188
00:09:10,233 --> 00:09:12,574
so many optimization algorithms,

189
00:09:12,574 --> 00:09:14,515
they use deltas between their iterations,

190
00:09:14,515 --> 00:09:16,256
and sometimes even deltas of deltas.

191
00:09:16,256 --> 00:09:18,537
And if we were to move a waypoint

192
00:09:18,537 --> 00:09:20,038
back into a pathfinding node

193
00:09:20,038 --> 00:09:23,019
that had been moved outside during an iteration,

194
00:09:23,019 --> 00:09:25,020
that could create an infinite delta.

195
00:09:25,020 --> 00:09:29,983
So that would obviously spell troubles for your calculations.

196
00:09:31,078 --> 00:09:37,063
Shambhala Park does not have that problem, because it just works on the data it has with

197
00:09:37,063 --> 00:09:38,644
its current iteration.

198
00:09:38,644 --> 00:09:39,845
It doesn't keep any history.

199
00:09:39,845 --> 00:09:44,109
Now, as I said, Shambhala Park is an optimization algorithm.

200
00:09:44,109 --> 00:09:52,416
And what precisely it optimizes is the output of two functions simultaneously on a set of

201
00:09:52,416 --> 00:09:52,656
data.

202
00:09:52,656 --> 00:09:55,478
That set of data, in our case, is the path.

203
00:09:56,269 --> 00:09:59,170
Now, these functions are called objective functions,

204
00:09:59,170 --> 00:10:01,832
and in order for Shambhala Park to deliver

205
00:10:01,832 --> 00:10:04,434
on the promises that they make

206
00:10:04,434 --> 00:10:09,738
when it comes to effectiveness and time complexity,

207
00:10:09,738 --> 00:10:13,040
these objective functions are required to be convex.

208
00:10:13,040 --> 00:10:17,843
And because of that, we can no longer use the springs,

209
00:10:17,843 --> 00:10:20,025
so we need new objective functions.

210
00:10:21,457 --> 00:10:25,318
So the first objective function, its goal

211
00:10:25,318 --> 00:10:28,019
is to ensure that the smooth path doesn't deviate too

212
00:10:28,019 --> 00:10:31,140
far from the optimal path, because the optimal path is

213
00:10:31,140 --> 00:10:32,601
optimal, so that's good.

214
00:10:32,601 --> 00:10:33,281
But it's still not smooth.

215
00:10:33,281 --> 00:10:38,743
And the way we do that is that the first function

216
00:10:38,743 --> 00:10:42,044
trying to minimize the distance a waypoint has

217
00:10:42,044 --> 00:10:45,325
moved from its original position on the optimized path.

218
00:10:45,325 --> 00:10:47,506
So if we look at this picture, the gray line

219
00:10:47,506 --> 00:10:50,027
would be the original optimized path.

220
00:10:50,718 --> 00:10:55,580
and the black line would be where the path is now in its current iteration.

221
00:10:55,580 --> 00:11:03,805
And the green line then is the distance the waypoint has moved from its original position

222
00:11:03,805 --> 00:11:06,106
and that is what function 1 is trying to minimize.

223
00:11:06,106 --> 00:11:11,829
So if we look at an entire path, what function 1 is trying to minimize is the sum of all these distances

224
00:11:11,829 --> 00:11:15,711
that all the waypoints have moved away from the original optimal path.

225
00:11:17,067 --> 00:11:19,969
The second function is a little bit more complicated.

226
00:11:19,969 --> 00:11:22,431
So what we do is we look at the path segments

227
00:11:22,431 --> 00:11:25,173
that meet in our waypoints.

228
00:11:25,173 --> 00:11:27,776
So we look at the first path segment

229
00:11:27,776 --> 00:11:29,117
and then we copy it out like that.

230
00:11:29,117 --> 00:11:32,099
Take the second path segment and copy it out like that.

231
00:11:32,099 --> 00:11:35,441
Go back to the first one and put another copy out there.

232
00:11:35,441 --> 00:11:37,583
And then finally, the second one,

233
00:11:37,583 --> 00:11:39,064
we put the copy out there.

234
00:11:39,064 --> 00:11:40,205
So we create this rhomboid.

235
00:11:41,225 --> 00:11:43,526
Now what we're trying to do here with function two

236
00:11:43,526 --> 00:11:45,947
is minimize the height of that rhomboid.

237
00:11:45,947 --> 00:11:50,649
And the reason why that works is it minimizes the angle

238
00:11:50,649 --> 00:11:53,830
between the two path segments in this waypoint.

239
00:11:53,830 --> 00:11:56,411
And that is because if the two segments

240
00:11:56,411 --> 00:11:59,092
that meet at this waypoint would have

241
00:11:59,092 --> 00:12:01,513
facing in the same direction,

242
00:12:01,513 --> 00:12:04,774
the height of the rhomboid would be zero.

243
00:12:04,774 --> 00:12:10,457
And that is the optimal non-turning waypoint.

244
00:12:11,161 --> 00:12:16,627
Now, on top of that, because we use a square height

245
00:12:16,627 --> 00:12:18,770
rather than just the height directly,

246
00:12:18,770 --> 00:12:22,314
it is better to distribute any curvature

247
00:12:22,314 --> 00:12:25,397
that we do have to have in our path

248
00:12:25,397 --> 00:12:26,919
over multiple waypoints,

249
00:12:26,919 --> 00:12:28,861
rather than just collect them in one waypoint.

250
00:12:29,784 --> 00:12:33,506
And that is essentially the definition of a smooth path.

251
00:12:33,506 --> 00:12:35,728
So that is why we use the square.

252
00:12:35,728 --> 00:12:39,110
And again, if we look at the entire path,

253
00:12:39,110 --> 00:12:43,293
we build these rhomboids for all of the waypoints in the path.

254
00:12:43,293 --> 00:12:45,154
And then what Function 2 tries to do

255
00:12:45,154 --> 00:12:48,537
is minimize the sum of the square of those heights, which

256
00:12:48,537 --> 00:12:50,758
would be the green lines in this picture.

257
00:12:52,842 --> 00:12:56,144
So this is a screenshot from our pathfinding testing tool.

258
00:12:56,144 --> 00:12:59,305
And what I'm going to do next is show you

259
00:12:59,305 --> 00:13:02,006
12 iterations of ShamblePock running on this path.

260
00:13:02,006 --> 00:13:06,068
This path has already been optimized and subdivided.

261
00:13:06,068 --> 00:13:09,249
So as you can see, the path started out

262
00:13:09,249 --> 00:13:10,890
looking a little bit crazy.

263
00:13:10,890 --> 00:13:13,331
But as the algorithm progresses,

264
00:13:13,331 --> 00:13:15,632
we get a smoother and smoother path.

265
00:13:15,632 --> 00:13:18,653
And eventually we end up with this,

266
00:13:18,653 --> 00:13:20,894
which is a nicely curved path at the end.

267
00:13:22,495 --> 00:13:25,116
So now we have a good path, and we need to follow it.

268
00:13:25,116 --> 00:13:28,618
However, we can't just follow the path

269
00:13:28,618 --> 00:13:30,500
just like we did do with bipeds.

270
00:13:30,500 --> 00:13:33,361
So normally, in biped path following,

271
00:13:33,361 --> 00:13:35,322
what we do is we take the character

272
00:13:35,322 --> 00:13:36,343
and move it along the path,

273
00:13:36,343 --> 00:13:38,765
and put it where it should be on the path

274
00:13:38,765 --> 00:13:40,085
on this particular frame,

275
00:13:40,085 --> 00:13:43,688
and then rotate it to face along the path,

276
00:13:43,688 --> 00:13:44,948
and then we're done.

277
00:13:44,948 --> 00:13:48,190
If we were to do that with a quarterped,

278
00:13:48,190 --> 00:13:50,692
it would look something like this.

279
00:13:50,692 --> 00:13:51,332
Not very good.

280
00:13:52,445 --> 00:13:59,109
So, the problem here is that only the root position of the dog is actually following the path.

281
00:13:59,109 --> 00:14:02,851
While the entire character needs to follow the path.

282
00:14:02,851 --> 00:14:04,752
In order to do that, we need to animate the spine.

283
00:14:04,752 --> 00:14:08,535
We started out by trying to use scanned animations,

284
00:14:08,535 --> 00:14:13,578
so we would have a bunch of animations with the dog's spine being bent more or less,

285
00:14:13,578 --> 00:14:15,279
and then we would blend them together.

286
00:14:15,279 --> 00:14:18,261
This, however, had a couple of problems.

287
00:14:18,261 --> 00:14:18,961
First of all,

288
00:14:19,687 --> 00:14:24,370
It didn't look very good when we were transitioning from a left to a right turn, or from a very

289
00:14:24,370 --> 00:14:26,291
sharp turn that suddenly straightened out.

290
00:14:26,291 --> 00:14:32,494
And secondly, it was very, very hard, if not near impossible, to get the blend parameter

291
00:14:32,494 --> 00:14:37,196
right so that we managed to put the dog on the path and not a little bit too far and

292
00:14:37,196 --> 00:14:38,897
a little bit too little.

293
00:14:38,897 --> 00:14:41,999
So what we ended up doing was procedurally animate the spine instead.

294
00:14:43,010 --> 00:14:45,292
This was something that we internally called SpineFlex.

295
00:14:45,292 --> 00:14:47,575
And because I'm so used to that,

296
00:14:47,575 --> 00:14:49,918
I'm going to call it SpineFlex here as well.

297
00:14:49,918 --> 00:14:53,341
So what SpineFlex is trying to do

298
00:14:53,341 --> 00:14:56,905
is to make the dog look like the entire dog follows the path.

299
00:14:56,905 --> 00:14:58,287
So the root position of the dog

300
00:14:58,287 --> 00:15:00,169
is placed between his rear feet.

301
00:15:00,169 --> 00:15:02,251
So they are oriented on the path and we go there.

302
00:15:02,904 --> 00:15:05,625
But we need to have the rest of the character

303
00:15:05,625 --> 00:15:08,367
sort of lead the root position on the path.

304
00:15:08,367 --> 00:15:10,828
And the way we do that is make sure

305
00:15:10,828 --> 00:15:13,429
that the front feet are also placed on the path.

306
00:15:14,792 --> 00:15:19,294
So to do that, the first thing we do is we figure out where the spine would end if it

307
00:15:19,294 --> 00:15:20,775
was perfectly following that path.

308
00:15:20,775 --> 00:15:26,219
That will give us a position, and then we try to figure out the direction from the root

309
00:15:26,219 --> 00:15:31,462
position to that position and compare that to the root position's direction.

310
00:15:31,462 --> 00:15:33,343
That gives us this angle V.

311
00:15:35,213 --> 00:15:38,135
Next, we look at the spine, and we assume the bones

312
00:15:38,135 --> 00:15:39,995
in the spine are of uniform length,

313
00:15:39,995 --> 00:15:43,017
and that we're gonna rotate them at a uniform angle.

314
00:15:43,017 --> 00:15:44,857
If we look at this illustration here,

315
00:15:44,857 --> 00:15:47,899
the blue lines there are our spine.

316
00:15:47,899 --> 00:15:52,521
We have four bones in our spines,

317
00:15:52,521 --> 00:15:56,142
and if you notice, they form a polygon,

318
00:15:56,142 --> 00:15:58,363
in our case a pentagon, because we got four bones,

319
00:15:58,363 --> 00:16:00,444
with the line from the root position

320
00:16:00,444 --> 00:16:02,345
to the target position on the path.

321
00:16:03,344 --> 00:16:07,047
Now this is interesting because we knew the angle V,

322
00:16:07,047 --> 00:16:11,349
and we also know the internal angles,

323
00:16:11,349 --> 00:16:13,691
or some of the internal angles of any pentagon

324
00:16:13,691 --> 00:16:14,411
that is convex.

325
00:16:14,411 --> 00:16:18,174
So we can set up this easily little equation

326
00:16:18,174 --> 00:16:20,676
and figure out how much we need to rotate each bone.

327
00:16:20,676 --> 00:16:22,317
The reason I'm showing you this

328
00:16:23,145 --> 00:16:29,448
is because this is clearly a very simple function to solve.

329
00:16:29,448 --> 00:16:33,330
So what we need to do in order to get SpineFlex working

330
00:16:33,330 --> 00:16:36,272
is only figure this one out and then rotate the bones.

331
00:16:36,272 --> 00:16:39,633
We don't need IK or any other complicated thing.

332
00:16:39,633 --> 00:16:43,315
How about SpineFlex is not enough.

333
00:16:43,315 --> 00:16:45,716
We need to lead with the head.

334
00:16:45,716 --> 00:16:47,858
Any character that is walking anywhere

335
00:16:47,858 --> 00:16:49,478
will look where it's going.

336
00:16:50,490 --> 00:16:55,892
On bipeds, it's very hard to see where you're looking,

337
00:16:55,892 --> 00:16:58,213
at least on a human, because a human's profile

338
00:16:58,213 --> 00:17:01,034
doesn't change much when it turns its head.

339
00:17:01,034 --> 00:17:03,615
If you don't look directly at the character's eyes,

340
00:17:03,615 --> 00:17:06,316
or you're very close to the character,

341
00:17:06,316 --> 00:17:07,656
you won't know where it's looking.

342
00:17:07,656 --> 00:17:11,378
With our dog, its head is sticking out quite far

343
00:17:11,378 --> 00:17:13,539
in front of its head, its body.

344
00:17:13,539 --> 00:17:17,540
So even at a glance, you can see where it's looking,

345
00:17:17,540 --> 00:17:19,341
so leading with the head becomes very important.

346
00:17:20,082 --> 00:17:25,267
And something that is worth noting is how far you're going to look ahead on the path

347
00:17:25,267 --> 00:17:28,791
with your head is dependent on the character's speed.

348
00:17:28,791 --> 00:17:32,915
The reason for this is that the character doesn't actually look a certain distance ahead,

349
00:17:32,915 --> 00:17:38,340
it looks a certain time ahead, and that's the time it needs in order to react to any

350
00:17:38,340 --> 00:17:40,142
obstacle appearing on the path.

351
00:17:40,142 --> 00:17:43,565
Another curious thing about SpineFlex.

352
00:17:44,783 --> 00:17:47,344
is that if you crank up the spine flicks,

353
00:17:47,344 --> 00:17:51,187
it starts changing how the character is perceived.

354
00:17:51,187 --> 00:17:54,969
When we turn up the spine flicks on our dog far enough,

355
00:17:54,969 --> 00:17:56,850
it starts to look more and more like a cat.

356
00:17:56,850 --> 00:18:01,733
Fortunately for us, dogs are still quite flexible creatures,

357
00:18:01,733 --> 00:18:03,654
so we could use a lot of spine flicks.

358
00:18:03,654 --> 00:18:06,256
But if you are going to work with a less bendy character,

359
00:18:06,256 --> 00:18:08,558
like a horse for instance,

360
00:18:08,558 --> 00:18:12,240
you may want to take this into consideration.

361
00:18:12,240 --> 00:18:12,740
Finally,

362
00:18:14,606 --> 00:18:18,508
If you ever try to play a full body animation,

363
00:18:18,508 --> 00:18:20,689
or even many partial body animations,

364
00:18:20,689 --> 00:18:22,850
on a character with a bent spine,

365
00:18:22,850 --> 00:18:26,032
you will very quickly realize that the results are horrific.

366
00:18:26,032 --> 00:18:29,995
So, it's great to have SpineFlex working

367
00:18:29,995 --> 00:18:30,975
when we're locomoting.

368
00:18:32,076 --> 00:18:34,637
but we really, really do not want to have it

369
00:18:34,637 --> 00:18:35,637
once we're done locomoting.

370
00:18:35,637 --> 00:18:37,378
So we need to be able to get in and out.

371
00:18:37,378 --> 00:18:40,799
So when we get into SpineFlex,

372
00:18:40,799 --> 00:18:44,880
we move the dog's front paws onto the path.

373
00:18:44,880 --> 00:18:47,421
Reason for that is we start our path finding

374
00:18:47,421 --> 00:18:50,242
from the root position, so the root is already on the path.

375
00:18:50,242 --> 00:18:52,862
And also, it's a very natural thing to just turn

376
00:18:52,862 --> 00:18:55,703
to see where you're going before you start moving.

377
00:18:56,718 --> 00:19:00,061
If we're lucky though, we don't need much spine flex in the starting, in which case we just

378
00:19:00,061 --> 00:19:02,243
use this in over the start walking animation.

379
00:19:02,243 --> 00:19:05,847
Getting out of the spine flex server, we need to do the very opposite.

380
00:19:05,847 --> 00:19:11,473
And the reason for that is that generally when we create a path, there's something at

381
00:19:11,473 --> 00:19:15,016
the end of the path that we're interested in, there's a target there.

382
00:19:15,937 --> 00:19:23,344
And when we're done locomoting to the end of the path, the dog's front paws and his head will be facing towards that target.

383
00:19:23,344 --> 00:19:29,490
So if we were to turn the front of the dog in order to straighten it out, we would turn away from the target.

384
00:19:29,490 --> 00:19:32,273
And that's not a good idea. So instead we slide out the dog's rear.

385
00:19:32,273 --> 00:19:37,958
And probably for the very same reasons, this is exactly what real dogs do in those situations.

386
00:19:40,545 --> 00:19:43,366
So now we come to the tips and tricks section.

387
00:19:43,366 --> 00:19:45,487
I'm gonna talk about local motion,

388
00:19:45,487 --> 00:19:46,888
animation footprints,

389
00:19:46,888 --> 00:19:48,748
and finally breadcrumbs and backtracking.

390
00:19:48,748 --> 00:19:53,150
So local motion is a system that was created

391
00:19:53,150 --> 00:19:55,631
by another one of my colleagues.

392
00:19:55,631 --> 00:19:58,393
His name is Todd Heckel.

393
00:19:58,393 --> 00:20:02,594
And it covers an area between standing still and moving

394
00:20:02,594 --> 00:20:04,895
that pathfinding doesn't do very well.

395
00:20:04,895 --> 00:20:07,616
So pathfinding is great for long distance locomotion.

396
00:20:08,512 --> 00:20:12,512
But when we want to do a short move or just a position

397
00:20:12,512 --> 00:20:16,993
adjustment, there's a significant amount

398
00:20:16,993 --> 00:20:19,634
of setup cost involved in the pathfinding.

399
00:20:19,634 --> 00:20:21,854
And it's not helped by us using SpineFlex.

400
00:20:21,854 --> 00:20:24,375
And then we have the start and stop animation,

401
00:20:24,375 --> 00:20:28,555
which has a limited range in which it will look good.

402
00:20:28,555 --> 00:20:31,216
So instead, we use this local motion system.

403
00:20:31,216 --> 00:20:33,936
And the way it's implemented is that we have a very

404
00:20:35,081 --> 00:20:38,784
a complicated blend node in our animation tree.

405
00:20:38,784 --> 00:20:41,706
And this blend node, or rather blend tree,

406
00:20:41,706 --> 00:20:44,408
contains multiple movement animations.

407
00:20:44,408 --> 00:20:47,350
And then we have a lookup table.

408
00:20:47,350 --> 00:20:49,632
So what we say is, I want the dog to have

409
00:20:49,632 --> 00:20:53,235
a particular relative position and facing

410
00:20:53,235 --> 00:20:55,537
to my current position and facing.

411
00:20:55,537 --> 00:20:58,399
What are the correct blend parameters to set?

412
00:20:58,399 --> 00:21:01,521
And we look them up, and we set them on the,

413
00:21:02,722 --> 00:21:06,845
animation graph, and then we just play the animation.

414
00:21:06,845 --> 00:21:09,567
So this is a local motion in action.

415
00:21:09,567 --> 00:21:11,368
As you can see, it's very flexible,

416
00:21:11,368 --> 00:21:14,530
contains a wide range of different movements,

417
00:21:14,530 --> 00:21:17,793
which would have been very difficult to do

418
00:21:17,793 --> 00:21:21,435
in normal pathfinding, if not impossible.

419
00:21:21,435 --> 00:21:21,475
So.

420
00:21:25,764 --> 00:21:28,227
Next, we've got animation footprint checking.

421
00:21:28,227 --> 00:21:30,450
So we don't have any collision with our world.

422
00:21:30,450 --> 00:21:32,593
So before we start playing an animation,

423
00:21:32,593 --> 00:21:35,596
we want to make sure that that animation can be successfully

424
00:21:35,596 --> 00:21:39,321
played and we don't move through any geometry,

425
00:21:39,321 --> 00:21:41,443
like walking through a wall or something like that.

426
00:21:42,211 --> 00:21:47,598
And so the way we do that is we project where the animation's

427
00:21:47,598 --> 00:21:49,601
trajectory will go.

428
00:21:49,601 --> 00:21:54,888
And then we test the position of certain key bones

429
00:21:54,888 --> 00:21:56,030
along that trajectory.

430
00:21:56,030 --> 00:21:58,453
In our case, we test the head, shoulder, and root bones.

431
00:22:00,082 --> 00:22:03,043
Unfortunately, we couldn't ask our animation engine

432
00:22:03,043 --> 00:22:05,764
about this data because it was a third party animation engine

433
00:22:05,764 --> 00:22:08,005
that definitely didn't tell us anything.

434
00:22:08,005 --> 00:22:11,446
So we had to recreate a significant portion

435
00:22:11,446 --> 00:22:14,067
of the animation engine outside the animation engine,

436
00:22:14,067 --> 00:22:16,208
which was a lot of work, but in the end,

437
00:22:16,208 --> 00:22:17,548
it turns out to be worth it.

438
00:22:18,678 --> 00:22:23,182
Apart from being able to just test our animations,

439
00:22:23,182 --> 00:22:25,484
we could use it as a stand-in for pathfinding

440
00:22:25,484 --> 00:22:28,647
for our local motion that I just showed you.

441
00:22:28,647 --> 00:22:32,691
And also, it allowed us to do other things

442
00:22:32,691 --> 00:22:35,413
in the area of examining certain animations.

443
00:22:35,933 --> 00:22:38,955
So, for instance, when we were locomoting

444
00:22:38,955 --> 00:22:42,397
and we needed to play a stop in animation to come to a halt,

445
00:22:42,397 --> 00:22:45,338
that was actually a blend of multiple animations.

446
00:22:45,338 --> 00:22:48,179
And the exact result of those animations

447
00:22:48,179 --> 00:22:51,281
and how they blended depended on the character's speed.

448
00:22:51,727 --> 00:22:55,249
and that meant that the distance we needed in order to stop

449
00:22:55,249 --> 00:22:57,030
was speed dependent.

450
00:22:57,030 --> 00:22:59,391
So we could use this system to figure out

451
00:22:59,391 --> 00:23:01,573
how far we needed in order to stop,

452
00:23:01,573 --> 00:23:05,835
and we could stop very precisely.

453
00:23:05,835 --> 00:23:08,777
So this is a video of Fang playing his rollover animation.

454
00:23:08,777 --> 00:23:09,878
Good boy, Fang.

455
00:23:11,112 --> 00:23:13,493
And this is the animation footprint checking

456
00:23:13,493 --> 00:23:16,275
of that animation from two different views.

457
00:23:16,275 --> 00:23:18,776
The white suers is his root position,

458
00:23:18,776 --> 00:23:21,258
the orange his shoulders, and the teal ones his head.

459
00:23:21,258 --> 00:23:23,779
As you can see, they do not intersect

460
00:23:23,779 --> 00:23:26,861
with any of the geometry here,

461
00:23:26,861 --> 00:23:29,582
so that is an animation that's safe to play

462
00:23:29,582 --> 00:23:32,524
in that particular position.

463
00:23:32,524 --> 00:23:34,825
Finally, we got breadcrumbs and backtracking.

464
00:23:34,825 --> 00:23:34,905
So.

465
00:23:35,939 --> 00:23:42,803
When the dog is out moving, because it can move into areas that are narrower than the dog is wide,

466
00:23:42,803 --> 00:23:45,985
it may find itself in an area where it cannot turn around.

467
00:23:46,890 --> 00:23:49,951
And this gets even worse if it happens to walk into a dead end.

468
00:23:49,951 --> 00:23:57,055
So in order to figure out, get out of this, we keep track of where the dog came from by

469
00:23:57,055 --> 00:23:59,537
dropping virtual breadcrumbs in the environment.

470
00:23:59,537 --> 00:24:06,500
And then if we ever find ourselves in a situation where we cannot get out of, we just reverse

471
00:24:06,500 --> 00:24:09,822
along the path of breadcrumbs until there's enough room to turn around.

472
00:24:10,826 --> 00:24:14,528
So this is a screenshot from our test environment.

473
00:24:14,528 --> 00:24:17,190
The green line here is Fang's current path.

474
00:24:17,190 --> 00:24:19,892
And the yellow dots behind them, if you can see them,

475
00:24:19,892 --> 00:24:24,695
is the breadcrumbs that he's dropped from previous movements.

476
00:24:24,695 --> 00:24:26,656
And this is a video of us telling Fang

477
00:24:26,656 --> 00:24:27,857
to walk into a dead end.

478
00:24:27,857 --> 00:24:30,839
And once he get in there, we ask him to go back out again.

479
00:24:30,839 --> 00:24:34,021
He realized there's not enough room, so he starts backing out.

480
00:24:35,602 --> 00:24:39,506
and eventually finds a spot where there's enough room to turn around,

481
00:24:39,506 --> 00:24:41,008
which he turns around,

482
00:24:41,008 --> 00:24:44,032
and continues on walking like normal towards his target.

483
00:24:44,032 --> 00:24:46,515
So, if you want more information,

484
00:24:46,515 --> 00:24:51,120
Microsoft is going to make the source code available online.

485
00:24:51,120 --> 00:24:52,121
At some point...

486
00:24:56,830 --> 00:24:59,514
This will happen at some point in the future.

487
00:24:59,514 --> 00:25:03,279
The date, I unfortunately do not know that today.

488
00:25:03,279 --> 00:25:06,504
It is most likely gonna be on GitHub, exactly where.

489
00:25:06,504 --> 00:25:09,849
There's also some information I don't have today.

490
00:25:09,849 --> 00:25:11,791
But keep your eyes open, it will turn up.

491
00:25:12,794 --> 00:25:16,575
If you have some questions, I believe we have a few more minutes for questions.

492
00:25:16,575 --> 00:25:19,016
And I will be available outside here.

493
00:25:19,016 --> 00:25:24,697
Or if you're too shy to speak up in this setting, you can email me for general questions.

494
00:25:24,697 --> 00:25:28,898
If you want to talk about shamble pock, you should email Mark Langerak.

495
00:25:28,898 --> 00:25:32,479
And if you want to talk about local motion, then Todd Heckel is your man.

496
00:25:32,479 --> 00:25:33,419
Thank you.

497
00:25:40,223 --> 00:25:43,265
Hi, is there a reason that you decided to put the root

498
00:25:43,265 --> 00:25:48,649
between the dog's rear legs instead of the front legs?

499
00:25:48,649 --> 00:25:51,671
It's partly a legacy reason,

500
00:25:51,671 --> 00:25:57,575
and partly this was because it turned out,

501
00:25:57,575 --> 00:26:01,137
regardless of where we put the root position,

502
00:26:01,137 --> 00:26:04,580
if we put it on the front paws, behind the rear paws,

503
00:26:04,580 --> 00:26:05,841
or in the center of the character.

504
00:26:06,868 --> 00:26:09,109
It gives us various problems.

505
00:26:09,109 --> 00:26:11,870
There's no perfect place to put it.

506
00:26:11,870 --> 00:26:14,031
And essentially, we ended up putting it

507
00:26:14,031 --> 00:26:17,932
between the rear feet because that gave us

508
00:26:17,932 --> 00:26:19,653
the least amount of problems.

509
00:26:19,653 --> 00:26:20,113
Hey, I'm Alex.

510
00:26:20,113 --> 00:26:22,534
Have you guys considered making two different spines,

511
00:26:22,534 --> 00:26:26,455
one for the front and one for the hind legs?

512
00:26:26,455 --> 00:26:27,776
Sorry, two different paws?

513
00:26:27,776 --> 00:26:29,737
Two different paths, yes, spines.

514
00:26:29,737 --> 00:26:35,479
So not the whole dog following it like a train.

515
00:26:36,130 --> 00:26:38,511
but rather having two different sets of paths.

516
00:26:38,511 --> 00:26:42,412
OK, so like if we had a train with two boogies on it,

517
00:26:42,412 --> 00:26:45,133
sort of thing going on.

518
00:26:45,133 --> 00:26:49,074
Well, the short answer is no, we did not consider doing that.

519
00:26:49,074 --> 00:26:53,996
And also, a dog, when it moves, the front of the dog

520
00:26:53,996 --> 00:26:57,577
and the rear of the dog does not move independently of each other.

521
00:26:57,577 --> 00:27:01,298
So I don't think that would necessarily look any good,

522
00:27:01,298 --> 00:27:03,659
though I'm just guessing right now.

523
00:27:04,098 --> 00:27:13,309
I got that. If you actually watch a dog move, or even a cat for that matter, they will often put their back foot right where their front foot left.

524
00:27:13,309 --> 00:27:20,757
And so they are following their own path. It's very, very, if anything it's a variation of just a degree.

525
00:27:20,757 --> 00:27:25,703
I have three dogs and three cats. I watch them walk a lot and this is cool.

526
00:27:26,424 --> 00:27:28,106
That was the moderate length version.

527
00:27:28,106 --> 00:27:28,246
Go ahead.

528
00:27:28,246 --> 00:27:31,170
How well do you think this would work for other animals,

529
00:27:31,170 --> 00:27:33,654
for example, like maybe rodents or elephants or horses

530
00:27:33,654 --> 00:27:35,236
or lizards or things like that

531
00:27:35,236 --> 00:27:37,078
that can squeeze into small areas?

532
00:27:37,078 --> 00:27:41,043
So I think this works in general well

533
00:27:41,043 --> 00:27:44,107
for any kind of quarterped that is.

534
00:27:45,364 --> 00:27:46,846
relatively well-known.

535
00:27:46,846 --> 00:27:48,247
I mean, we can come up with an alien

536
00:27:48,247 --> 00:27:49,428
that moves completely differently,

537
00:27:49,428 --> 00:27:51,511
and obviously everything is void here.

538
00:27:51,511 --> 00:27:54,173
But there are two issues.

539
00:27:54,173 --> 00:27:57,977
First of all, it's turning radius

540
00:27:57,977 --> 00:28:00,079
and the amount of spine flex.

541
00:28:00,510 --> 00:28:05,194
So if we have a limit in turning radius and spine flex,

542
00:28:05,194 --> 00:28:08,477
at some point we need to take that into consideration

543
00:28:08,477 --> 00:28:09,397
when we build a POF.

544
00:28:09,397 --> 00:28:13,380
So all the other stuff will work fine.

545
00:28:13,380 --> 00:28:15,042
I'm pretty confident about that.

546
00:28:15,042 --> 00:28:18,925
But at some point, you need to start doing POF finding

547
00:28:18,925 --> 00:28:20,786
that takes turning radius into account.

548
00:28:20,786 --> 00:28:23,968
And that is much harder than just doing normal A-star,

549
00:28:23,968 --> 00:28:25,089
unfortunately.

550
00:28:25,089 --> 00:28:28,332
And lucky for us, we could just skip that part.

551
00:28:29,256 --> 00:28:32,615
And I apologize to anyone who came here to figure out how to do that.

