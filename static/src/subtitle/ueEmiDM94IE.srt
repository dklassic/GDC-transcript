1
00:00:06,683 --> 00:00:09,686
Welcome to this presentation of It is Rocket Science,

2
00:00:10,006 --> 00:00:11,567
the physics and networking of Rocket League.

3
00:00:12,708 --> 00:00:13,749
You all know the rules by now.

4
00:00:13,849 --> 00:00:15,210
Please silence your cell phones.

5
00:00:16,091 --> 00:00:18,232
Partway through the talk, you will get an evaluation

6
00:00:19,233 --> 00:00:19,833
in your email.

7
00:00:20,194 --> 00:00:22,756
If it's not in your email, then check your spam.

8
00:00:22,916 --> 00:00:23,876
If it's not in your spam,

9
00:00:24,177 --> 00:00:25,978
maybe GDC doesn't care about your opinion.

10
00:00:27,319 --> 00:00:28,740
My name is Jared Cohn.

11
00:00:28,800 --> 00:00:30,541
I am the lead gameplay engineer at Psyonix,

12
00:00:31,362 --> 00:00:33,824
Psyonix being best known as the creators of Rocket League.

13
00:00:34,702 --> 00:00:37,343
I've had the pleasure of working for Sonics for 11 years now.

14
00:00:38,763 --> 00:00:42,204
I was involved with the development and release

15
00:00:42,844 --> 00:00:45,244
of Rocket League's predecessor, the concisely named

16
00:00:45,844 --> 00:00:48,245
Supersonic Acrobatic Rocket-Powered Battle Cars.

17
00:00:49,185 --> 00:00:51,685
Every time I say that name, I make sure to hold my head high

18
00:00:52,245 --> 00:00:54,486
and say the whole thing, all the way to the bitter end.

19
00:00:54,506 --> 00:00:55,306
I'm very proud of it.

20
00:00:56,806 --> 00:00:59,227
I've also was part of the initial startup

21
00:00:59,247 --> 00:01:01,907
for the Rocket League prototype and have been involved.

22
00:01:02,745 --> 00:01:08,930
with the development of it all the way through its release, the fires of release and continue to

23
00:01:08,950 --> 00:01:13,713
support it as a live game today. So I've pretty much made a career out of cars playing soccer.

24
00:01:15,714 --> 00:01:19,017
Today we're going to talk about the tech of Rocket League. If you're interested in the

25
00:01:19,137 --> 00:01:24,080
history or design of Rocket League, then Corey Davis gave a great talk at GDC 2016. That's

26
00:01:24,100 --> 00:01:26,902
available on YouTube and at the vault. I highly suggest you check out.

27
00:01:28,125 --> 00:01:30,546
Specifically, three topics we're going to be covering today.

28
00:01:30,906 --> 00:01:32,506
We're going to take a look at the physics engine.

29
00:01:32,727 --> 00:01:34,407
Even though we're an Unreal Engine 3 game,

30
00:01:34,447 --> 00:01:37,448
we decided to put in an alternative physics engine

31
00:01:38,008 --> 00:01:40,308
and take a look at kind of global physics settings

32
00:01:40,348 --> 00:01:41,329
that we chose for the game.

33
00:01:42,369 --> 00:01:43,729
This is a very quick section,

34
00:01:43,789 --> 00:01:45,250
but it actually contains what I think

35
00:01:46,090 --> 00:01:48,511
is one of the most important takeaways for the whole talk.

36
00:01:48,611 --> 00:01:49,591
So keep an eye out for that.

37
00:01:51,352 --> 00:01:55,556
Then we're going to look into vehicle systems, specifically vehicle tuning and what you can do

38
00:01:55,596 --> 00:02:02,343
to make your lives easier when working with physics based vehicles. And then we're going to

39
00:02:02,384 --> 00:02:06,748
kind of switch context and talk about networking. So once we got this game made that we

40
00:02:06,808 --> 00:02:11,493
really wanted to play online, how the hell do we get to play over the internet?

41
00:02:12,601 --> 00:02:16,525
I'm actually really excited about talking about the networking because for me it was like my

42
00:02:16,585 --> 00:02:22,371
own personal moon landing achieving this type of game to be playable online. So looking

43
00:02:22,391 --> 00:02:23,272
forward to talking about that.

44
00:02:25,207 --> 00:02:27,590
First an overview of Rocket League for the uninitiated.

45
00:02:27,830 --> 00:02:29,793
Elevator pitch is it's cars playing soccer.

46
00:02:30,413 --> 00:02:32,015
We needed our cars to be a little more exciting

47
00:02:32,035 --> 00:02:34,718
than real life cars so they drive fast, they steer fast,

48
00:02:34,839 --> 00:02:37,562
they can jump, they can double jump, they can dodge.

49
00:02:37,942 --> 00:02:39,284
We strapped on some rocket boosters

50
00:02:39,304 --> 00:02:40,445
to make them even faster.

51
00:02:40,946 --> 00:02:42,728
Combine that with jumping and air control

52
00:02:42,888 --> 00:02:44,130
and they can fly through the air too.

53
00:02:50,630 --> 00:02:53,033
So high-level goals that we had for Rocket League

54
00:02:53,073 --> 00:02:54,514
on the tech side of things is we needed

55
00:02:54,634 --> 00:02:55,855
fast, responsive vehicles.

56
00:02:55,875 --> 00:02:58,317
We weren't going for a realistic physics simulation.

57
00:03:01,080 --> 00:03:02,701
Conversely to that, we also wanted

58
00:03:03,001 --> 00:03:04,383
consistent, controllable physics.

59
00:03:04,683 --> 00:03:07,105
We wanted to make sure that players felt like

60
00:03:07,125 --> 00:03:09,747
they had control over the car and kind of a say-so

61
00:03:09,827 --> 00:03:11,409
in how the car was interacting with the ball

62
00:03:11,449 --> 00:03:13,150
and the rest of the physics simulation.

63
00:03:14,727 --> 00:03:18,508
and we wanted the game to not be just playable over the internet but needed to be

64
00:03:18,528 --> 00:03:23,429
competitive. So competitively playable over the internet. Let's dive right into the first

65
00:03:23,449 --> 00:03:28,250
part of the talk. Look at our physics engine. We decided to go with the bullet physics

66
00:03:28,310 --> 00:03:34,951
engine for a number of reasons. First off, it is open source. So you can debug it, you can

67
00:03:34,991 --> 00:03:37,812
modify it, you can make it do what you want it to do.

68
00:03:38,651 --> 00:03:43,152
And I want to say that this bullet point, if I had to pick one thing that was most responsible

69
00:03:43,192 --> 00:03:48,854
for Rocket League's technical success, it was the fact that we went with an open source

70
00:03:48,954 --> 00:03:55,116
physics engine that we could go in and fix edge case problems, literal edge problems,

71
00:03:55,716 --> 00:04:00,457
and make the vehicle system work exactly how we wanted it to do. I highly suggest you do

72
00:04:00,517 --> 00:04:02,658
it if you want to make a physics driven game yourself.

73
00:04:04,382 --> 00:04:06,883
We also needed a really fast single-threaded physics

74
00:04:06,903 --> 00:04:07,343
simulator.

75
00:04:08,103 --> 00:04:10,524
Many physics engines kind of focus on multi-threaded physics

76
00:04:10,584 --> 00:04:13,105
and handling lots of objects over the course of a frame.

77
00:04:13,525 --> 00:04:15,906
We needed something that could run on a single thread

78
00:04:16,666 --> 00:04:19,167
and be able to handle many frames all at once,

79
00:04:19,307 --> 00:04:20,928
as we'll get into when we get in the networking section.

80
00:04:23,223 --> 00:04:28,085
It was pretty quick to integrate because we did not actually replace the physics engine that came with Unreal Engine 3.

81
00:04:28,705 --> 00:04:33,507
We simply added bullet as an additional physics engine and it handles all of the gameplay physics.

82
00:04:34,248 --> 00:04:36,368
It only took a couple of days to get boxes

83
00:04:36,669 --> 00:04:43,411
rolling around in the level and then maybe another week to get the vehicle prototype in. So if you think the idea of switching physics engines

84
00:04:43,511 --> 00:04:43,872
sounds

85
00:04:44,992 --> 00:04:51,435
too daunting, it's not so bad if you're only piecemeal integrating the things that you need from another physics engine.

86
00:04:53,292 --> 00:04:57,656
We use discrete collision detection like most physics

87
00:04:57,716 --> 00:04:58,236
engines do.

88
00:04:59,177 --> 00:05:02,521
The key difference is with discrete collision detection,

89
00:05:02,941 --> 00:05:05,603
the actor will move and then it tries to find things it's

90
00:05:05,623 --> 00:05:06,164
colliding with.

91
00:05:06,624 --> 00:05:09,187
With continuous collision detection, first we look for

92
00:05:09,227 --> 00:05:11,249
things we could collide with and then we move.

93
00:05:12,010 --> 00:05:14,212
We'll get into why that's an important distinction later on,

94
00:05:14,272 --> 00:05:16,474
but of course that was chosen because it's more performant.

95
00:05:18,195 --> 00:05:19,676
And we run at a fixed tick rate, which

96
00:05:19,736 --> 00:05:21,397
is not usual for an Unreal Engine game,

97
00:05:21,417 --> 00:05:24,200
but I'm actually quite surprised it isn't usual.

98
00:05:24,620 --> 00:05:26,922
With a fixed tick rate, you can have deterministic physics.

99
00:05:26,962 --> 00:05:28,043
So your physics frames are always

100
00:05:28,083 --> 00:05:29,504
working with the same delta time,

101
00:05:30,305 --> 00:05:31,726
no matter how fast the game is rendering.

102
00:05:33,227 --> 00:05:36,290
For Rocket League, we chose to go with 120 hertz tick rate.

103
00:05:36,330 --> 00:05:38,511
So each frame is approximately 8 milliseconds.

104
00:05:39,912 --> 00:05:42,435
And I want to get into why we made that decision,

105
00:05:42,535 --> 00:05:44,496
rather than going with something more standard like 60 hertz.

106
00:05:47,362 --> 00:05:50,805
So I want to look at a scenario where a car is actually driving towards the ball,

107
00:05:50,865 --> 00:05:54,368
comes from a stop, hits max speed and hits this ball towards the goal.

108
00:05:57,151 --> 00:05:59,613
Notice how high the ball gets in the frame and

109
00:05:59,653 --> 00:06:00,954
where it lands on the back of the goal.

110
00:06:02,275 --> 00:06:06,539
Now, we're gonna repeat this experiment with a ball going up to speed and

111
00:06:06,559 --> 00:06:09,982
hitting the, or a car getting up to speed and hitting the ball at max speed.

112
00:06:10,542 --> 00:06:13,144
But we're just gonna move the ball back a couple of units.

113
00:06:14,599 --> 00:06:15,880
Notice the difference in the trajectory.

114
00:06:16,260 --> 00:06:17,221
Notice where the ball lands.

115
00:06:17,821 --> 00:06:19,963
So as far as we know, we have a deterministic physics

116
00:06:19,983 --> 00:06:22,666
simulation, but we have these inconsistencies.

117
00:06:22,766 --> 00:06:26,609
So what happens if we up the physics rate to 120 hertz?

118
00:06:28,131 --> 00:06:28,891
Ball lands there.

119
00:06:29,112 --> 00:06:30,012
Repeat the experiment.

120
00:06:33,255 --> 00:06:34,817
We get much more consistent results.

121
00:06:35,818 --> 00:06:36,418
What's going on?

122
00:06:37,545 --> 00:06:43,288
So if we look at it frame by frame, here we see a physics frame run where the car moves and

123
00:06:43,308 --> 00:06:47,770
then we look for intersections and no intersections yet. Car continues moving, nothing's

124
00:06:47,790 --> 00:06:54,573
happening. Finally the car moves and we just are barely intersecting the ball. So at this

125
00:06:54,613 --> 00:06:58,554
point the physics engine needs to calculate the impact normal so it gets a vector from the

126
00:06:58,594 --> 00:07:02,776
impact point on the car to the center of the ball and this is roughly the direction the ball

127
00:07:02,796 --> 00:07:03,456
is going to travel in.

128
00:07:04,245 --> 00:07:08,628
I should clarify that Rocket League doesn't exactly do this. We do augment this vector a

129
00:07:08,648 --> 00:07:13,151
little bit with our custom forces and Cory talks about that in his talk. But it's the same

130
00:07:13,171 --> 00:07:18,114
principle. So with our experiments, instead of starting the car here, we're going to move

131
00:07:18,134 --> 00:07:24,299
him back just a little bit. So step through the physics simulation again. At this point, in

132
00:07:24,319 --> 00:07:28,202
the previous simulation, we were actually intersecting the ball, but because we moved the

133
00:07:28,242 --> 00:07:32,465
car back, it hasn't quite made it there yet. Now when it steps, it's actually got a pretty

134
00:07:32,545 --> 00:07:33,365
deep penetration.

135
00:07:34,647 --> 00:07:40,969
This impact normal is calculated again and now it looks like that instead of that. So

136
00:07:41,149 --> 00:07:46,251
that's the differences we're seeing in these hits and that's why we went with 120 hertz

137
00:07:46,531 --> 00:07:52,853
just for better consistency with the physics simulation. So when you run at a slower physics

138
00:07:52,893 --> 00:07:56,935
rate you have to take larger steps for each physics frame. That results in a larger variance

139
00:07:56,955 --> 00:08:00,076
in penetrations and you get inconsistent physics simulation.

140
00:08:01,225 --> 00:08:04,407
We upped the rate to have more consistency, but of course,

141
00:08:04,487 --> 00:08:05,807
this made everything more expensive.

142
00:08:05,867 --> 00:08:06,888
It was the easy thing to do.

143
00:08:07,348 --> 00:08:09,268
In retrospect, I wish we had found another way

144
00:08:09,388 --> 00:08:10,389
to handle these penetrations.

145
00:08:10,829 --> 00:08:13,110
But the game's released, and so we're kind of stuck with it.

146
00:08:16,791 --> 00:08:18,872
So coming to the end of the physics engine

147
00:08:18,912 --> 00:08:21,313
part of this talk, I strongly suggest

148
00:08:21,373 --> 00:08:22,934
if you're making a physics-driven game,

149
00:08:23,614 --> 00:08:25,275
get a physics engine that you can change.

150
00:08:26,412 --> 00:08:29,334
Use a fixed tick rate for deterministic physics.

151
00:08:29,875 --> 00:08:32,276
That's good not just for replayability,

152
00:08:32,356 --> 00:08:33,637
but also for networking,

153
00:08:33,677 --> 00:08:35,318
as we'll see when we get to the networking section.

154
00:08:36,219 --> 00:08:37,640
And you can play around with your tick rate

155
00:08:38,040 --> 00:08:39,561
for a better physics simulation,

156
00:08:40,262 --> 00:08:41,963
but it will come at a cost

157
00:08:42,023 --> 00:08:43,804
and you might have to optimize that later on.

158
00:08:45,706 --> 00:08:49,548
So switching gears over to vehicle tuning section.

159
00:08:53,171 --> 00:08:54,832
We have some high level goals with Rocket League.

160
00:08:55,505 --> 00:09:01,069
specific to our vehicles. We needed the fast acceleration and braking for a fast game play. We

161
00:09:01,109 --> 00:09:07,374
needed sharp steering. And despite all those things, we also need the cars to be stable. We

162
00:09:07,394 --> 00:09:10,837
don't want them to leave the ground too much by accident. In the event they do leave the

163
00:09:10,877 --> 00:09:14,240
ground, we want to make sure they're able to have a fast recovery so they can get back into

164
00:09:14,280 --> 00:09:18,663
the action. So you would think that making a vehicle drive faster would be something pretty

165
00:09:18,724 --> 00:09:19,204
simple to do.

166
00:09:20,687 --> 00:09:23,108
we just simply say depending on the implementation of your

167
00:09:23,248 --> 00:09:25,389
physics system or your vehicle implementation,

168
00:09:26,090 --> 00:09:27,651
you just simply add more torque to the wheel.

169
00:09:27,711 --> 00:09:28,832
So if the player presses throttle,

170
00:09:28,992 --> 00:09:30,433
we're just gonna up that torque value.

171
00:09:30,913 --> 00:09:33,915
This should cause the wheel to spin, move the car forward.

172
00:09:35,095 --> 00:09:36,736
Problem is that depends on friction,

173
00:09:36,976 --> 00:09:39,458
specifically the tire friction as it's touching the ground.

174
00:09:40,278 --> 00:09:42,040
This could be a complicated friction model.

175
00:09:42,140 --> 00:09:43,741
So if you have too little friction,

176
00:09:43,781 --> 00:09:45,121
the tire is just going to spin.

177
00:09:45,542 --> 00:09:47,183
If you have too much friction,

178
00:09:47,743 --> 00:09:49,184
you might have sticky tires

179
00:09:49,204 --> 00:09:50,405
whenever you come in for a landing.

180
00:09:51,841 --> 00:09:54,261
Friction depends on the spin speed of the wheel.

181
00:09:54,441 --> 00:09:56,462
So if the wheel is spinning faster, you have less friction.

182
00:09:56,822 --> 00:09:58,122
So you have unpredictable driving.

183
00:09:59,182 --> 00:10:00,963
Spin speed of the wheel depends on the wheel radius.

184
00:10:01,023 --> 00:10:04,303
So you might want to grow the rear wheel as we have here,

185
00:10:04,583 --> 00:10:05,783
just because you think it looks cool,

186
00:10:06,104 --> 00:10:07,304
but then you'll have to retweak everything

187
00:10:07,324 --> 00:10:08,264
there is about your vehicle.

188
00:10:09,404 --> 00:10:11,885
Suspension is important for keeping wheels on the ground.

189
00:10:11,925 --> 00:10:12,925
If you have soft suspension,

190
00:10:13,245 --> 00:10:15,585
they will maintain their contact with the ground better.

191
00:10:15,965 --> 00:10:16,925
If you have hard suspension,

192
00:10:16,945 --> 00:10:18,766
then they might ride off the ground a little bit

193
00:10:18,806 --> 00:10:19,646
and affect the driving.

194
00:10:21,068 --> 00:10:23,191
Gravity and mass pretty much affect everything about your

195
00:10:23,231 --> 00:10:27,235
vehicle's driving. If anything about those changes, then you

196
00:10:27,275 --> 00:10:31,759
end up retweaking all of these values anyways. And if you are

197
00:10:31,940 --> 00:10:34,402
really mad at your game designer and just want to ruin his day,

198
00:10:34,842 --> 00:10:37,745
give him a transmission to work with. This means he has to sort

199
00:10:37,806 --> 00:10:40,909
out gear ratios in order to figure out an acceleration

200
00:10:40,949 --> 00:10:41,209
curve.

201
00:10:43,204 --> 00:10:47,485
So these are all things that we have dealt with over the years. You're constantly having to

202
00:10:47,525 --> 00:10:51,606
tweak all these values and it's always a balancing act and you're only, you have to settle on a

203
00:10:51,686 --> 00:10:57,268
compromise for how you want your vehicle to behave in any given scenario. We know this is a

204
00:10:57,408 --> 00:11:01,929
pretty prevalent problem in the industry because Sionics over the years, our primary income was

205
00:11:01,949 --> 00:11:06,691
through contract work and on many of our contracts we're just simply helping other studios

206
00:11:06,791 --> 00:11:07,591
implement vehicles.

207
00:11:09,136 --> 00:11:13,999
because they couldn't sort out all these problems on their own. So we know it's a problem and we

208
00:11:14,019 --> 00:11:18,162
know we need to do something better for Rocket League. So the idea was just simplify the

209
00:11:18,182 --> 00:11:23,926
vehicle system as much as we can while still making it feel like you're driving a vehicle. So

210
00:11:23,986 --> 00:11:29,189
in order to reduce complexity, talking about the transmission, maybe don't start

211
00:11:29,330 --> 00:11:34,153
immediately having transmission just because a car has it in real life doesn't mean you

212
00:11:34,193 --> 00:11:36,154
actually need to simulate one in the physics engine.

213
00:11:36,926 --> 00:11:40,828
If you ever play our game, you'll notice the cars sound like they're changing gears, but

214
00:11:40,848 --> 00:11:41,349
it's all fake.

215
00:11:41,389 --> 00:11:42,369
It's just in the sound system.

216
00:11:44,150 --> 00:11:47,832
Instead, provide your designers an acceleration curve that they can tweak directly.

217
00:11:47,912 --> 00:11:51,714
So if the vehicle's at a stop and the player presses throttle, apply this amount of force

218
00:11:51,734 --> 00:11:52,315
to the vehicle.

219
00:11:52,775 --> 00:11:56,797
If the vehicle's going top speed and the player's pressing throttle, maybe don't apply any force

220
00:11:56,817 --> 00:11:57,077
at all.

221
00:11:57,558 --> 00:12:01,740
So much easier to work with, much better to get the desired acceleration curve that you

222
00:12:01,780 --> 00:12:02,580
want right off the bat.

223
00:12:04,890 --> 00:12:06,871
Mass is a super important property.

224
00:12:06,891 --> 00:12:08,052
It affects pretty much everything

225
00:12:08,072 --> 00:12:09,193
about how your vehicle handles.

226
00:12:09,674 --> 00:12:11,495
So it's very important to make sure

227
00:12:11,515 --> 00:12:13,316
it doesn't change out from underneath you.

228
00:12:14,037 --> 00:12:16,999
Many physics engines offer a feature

229
00:12:17,540 --> 00:12:20,282
where you just simply provide them the density of an actor

230
00:12:21,062 --> 00:12:23,444
and the size of the actor, or its collision size,

231
00:12:23,825 --> 00:12:25,166
and it will calculate the mass for you.

232
00:12:25,266 --> 00:12:26,206
And this is a pain in the butt

233
00:12:26,327 --> 00:12:29,269
because if you play around with the collision shape

234
00:12:29,429 --> 00:12:31,631
for your vehicle, your mass will suddenly change.

235
00:12:31,991 --> 00:12:35,472
And now your driving has changed, and now you've got to tweak all those variables all over again.

236
00:12:35,932 --> 00:12:39,113
So I highly suggest you just turn that off and override the mass manually.

237
00:12:41,534 --> 00:12:44,455
Also, ignore mass when you're applying all these driving forces.

238
00:12:44,495 --> 00:12:48,636
So driving, braking, in case of the rocket league, you have jumping and the dodging.

239
00:12:49,156 --> 00:12:50,717
You want to take mass out of the equation.

240
00:12:50,777 --> 00:12:54,178
So if you apply a force of five to a car...

241
00:12:55,083 --> 00:12:57,945
you want to make sure it has the same amount even if that mass changes.

242
00:12:58,746 --> 00:13:02,087
Many physics engines offer the ability to do this by simply

243
00:13:02,207 --> 00:13:05,609
passing a flag to the add force function to say ignore mass.

244
00:13:09,151 --> 00:13:13,374
Tire friction is another complicated thing. Longitudinal tire friction

245
00:13:14,094 --> 00:13:18,376
is where the wheel spins and it's what causes the car to move forward. It catches on the ground.

246
00:13:19,865 --> 00:13:23,306
All those variables we saw on the blueprint slide

247
00:13:23,326 --> 00:13:27,087
are all directly affecting longitudinal tire friction.

248
00:13:27,567 --> 00:13:30,208
So we can actually just get rid of longitudinal tire

249
00:13:30,248 --> 00:13:30,568
friction.

250
00:13:30,688 --> 00:13:32,669
We don't simulate it at all in Rocket League.

251
00:13:33,049 --> 00:13:34,829
Just simply if the player presses forward

252
00:13:36,050 --> 00:13:37,630
and the wheels have contact with the ground,

253
00:13:37,670 --> 00:13:38,930
we apply a force to the vehicle.

254
00:13:41,658 --> 00:13:44,140
We also simplify the lateral friction instead of depending

255
00:13:44,240 --> 00:13:48,142
on lat slip angles or ratios and whatnot.

256
00:13:48,742 --> 00:13:50,663
We were trying to figure out how can we simulate it

257
00:13:50,723 --> 00:13:52,664
so that you have actual friction,

258
00:13:52,764 --> 00:13:54,665
such as if the vehicle comes in from sliding

259
00:13:54,825 --> 00:13:58,566
or necessary for steering, while being simple to work with.

260
00:13:59,607 --> 00:14:01,188
And we tried a few different scenarios,

261
00:14:01,268 --> 00:14:02,949
and I wanna share with you what we ended up with

262
00:14:02,989 --> 00:14:04,029
and what we're using today.

263
00:14:05,210 --> 00:14:06,890
So for our lateral tire friction,

264
00:14:07,511 --> 00:14:09,111
what we end up doing is we look at the wheel,

265
00:14:09,846 --> 00:14:11,647
and we look at how fast it's moving through world space.

266
00:14:12,347 --> 00:14:14,569
And in this case, we look at how fast it's moving forward,

267
00:14:14,589 --> 00:14:17,150
and we also look at how fast it's moving to the side.

268
00:14:17,170 --> 00:14:18,971
So we look at these speeds.

269
00:14:20,152 --> 00:14:21,472
We use this to calculate the ratio.

270
00:14:21,753 --> 00:14:23,093
We just do side speed divided by

271
00:14:23,293 --> 00:14:24,614
side speed plus forward speed.

272
00:14:25,034 --> 00:14:26,895
This gives us a value between zero and one,

273
00:14:27,055 --> 00:14:29,237
where zero means the wheel is going perfectly forward,

274
00:14:29,297 --> 00:14:31,318
and one means the wheel is going perfectly to the side.

275
00:14:32,639 --> 00:14:33,699
We feed this into a curve.

276
00:14:33,759 --> 00:14:34,820
It's a pretty simple curve.

277
00:14:34,860 --> 00:14:36,681
I think ours only has two points.

278
00:14:37,943 --> 00:14:41,204
But basically, if you feed in a value of one,

279
00:14:41,705 --> 00:14:45,026
where the wheel is going perfectly to the side,

280
00:14:45,046 --> 00:14:47,087
then you're gonna get a value of 0.2 out of it.

281
00:14:47,167 --> 00:14:49,048
So it's nice and slippery when the car comes in

282
00:14:49,428 --> 00:14:50,569
from a sideways landing.

283
00:14:51,609 --> 00:14:52,970
But if you feed in a value of zero,

284
00:14:53,010 --> 00:14:54,831
so that the wheel is going forward,

285
00:14:55,091 --> 00:14:57,032
it's gonna give you a value of one for friction.

286
00:14:57,152 --> 00:14:58,533
So you have very sticky friction.

287
00:14:59,376 --> 00:15:02,759
And this is how we're able to make it so the cars have very tight steering, very sticky

288
00:15:02,779 --> 00:15:06,462
steering, but they stay slippery when they come in for a sideways landing.

289
00:15:06,622 --> 00:15:09,725
And that's pretty hard to do when you have a more realistic tire friction model.

290
00:15:10,906 --> 00:15:14,569
You also have to throw in ground friction because you don't want the vehicle just sticking

291
00:15:14,629 --> 00:15:15,650
on a slope perfectly.

292
00:15:15,770 --> 00:15:19,953
So we just throw the ground normal into another curve that scales friction.

293
00:15:21,781 --> 00:15:32,587
Finally, we use the physics engine to give us what impulse would be necessary to make this wheel come to a stop right now, given the location of the wheel and the mass that the wheel supports.

294
00:15:33,467 --> 00:15:40,050
Once the physics engine gives us that, we just scale that number by this friction value that we calculated and apply it to the wheel.

295
00:15:40,350 --> 00:15:44,673
And that's pretty much all we do. These few lines of code is basically our lateral tire friction model.

296
00:15:45,353 --> 00:15:47,074
It's pretty simple, but it works really well.

297
00:15:48,421 --> 00:15:52,164
and again it allows us to do the tight steering while also having the vehicles be sliding.

298
00:15:55,086 --> 00:15:59,649
While we're talking about friction, another important aspect is where you actually apply the forces on the vehicle.

299
00:16:00,129 --> 00:16:06,113
So in this scenario we have the vehicle on the ground but he's sliding to the right, so we're applying friction force right here.

300
00:16:06,853 --> 00:16:11,837
Normally when you're doing friction forces you want to apply them somewhere around the bottom of the wheel or maybe around the wheel axle.

301
00:16:12,557 --> 00:16:16,940
The point is it's usually offset from the car's center of mass, which is indicated there.

302
00:16:17,887 --> 00:16:20,209
When you apply a force that is offset from the center of mass,

303
00:16:20,569 --> 00:16:23,171
you get a torque, in this case, a rolling torque, which

304
00:16:23,191 --> 00:16:24,471
causes the car to roll.

305
00:16:25,272 --> 00:16:26,913
And that's not good, because we want our players

306
00:16:26,933 --> 00:16:28,294
to be able to drive around without fear

307
00:16:28,334 --> 00:16:29,334
of having their cars roll.

308
00:16:30,555 --> 00:16:33,237
Seeing this in action, the player

309
00:16:33,697 --> 00:16:36,499
is able to steer a little bit, and it's fine.

310
00:16:36,559 --> 00:16:38,460
But once they get up to speed and steer too much,

311
00:16:39,201 --> 00:16:41,062
they just flip over on their side, and they're done for.

312
00:16:41,082 --> 00:16:44,644
This is great if you're making Reliant Robin Simulator.

313
00:16:44,944 --> 00:16:46,425
Not so good for a competitive game.

314
00:16:48,313 --> 00:16:49,634
There are a few workarounds you can do for this.

315
00:16:49,834 --> 00:16:51,435
One, you can just lower tire friction.

316
00:16:51,855 --> 00:16:53,316
Obviously, this is not great if you want

317
00:16:53,336 --> 00:16:54,037
to have good steering.

318
00:16:55,518 --> 00:16:56,698
You can limit your steering angle.

319
00:16:56,758 --> 00:16:58,360
So it just simply prevent the player from

320
00:16:58,420 --> 00:16:59,200
turning that sharply.

321
00:16:59,360 --> 00:17:02,923
Now you're limiting your turn radiuses, and it's a big pain

322
00:17:02,943 --> 00:17:05,084
in the butt to maintain that steering angle curve.

323
00:17:06,625 --> 00:17:09,287
You could apply a physics constraint, usually called a

324
00:17:09,367 --> 00:17:11,408
state upright constraint, which is a constraint that

325
00:17:11,428 --> 00:17:13,570
you actually flip on when all the wheels are on the ground.

326
00:17:14,168 --> 00:17:17,391
that will try to align the vehicle's up axis

327
00:17:17,852 --> 00:17:19,453
with the surface normal that it's touching.

328
00:17:20,014 --> 00:17:21,975
It comes tricky trying to figure out

329
00:17:22,155 --> 00:17:23,777
when you should turn this constraint on or off,

330
00:17:23,797 --> 00:17:26,499
depending on very specific gameplay scenarios.

331
00:17:27,820 --> 00:17:28,741
What we did for Rocket League,

332
00:17:28,761 --> 00:17:29,982
and what I would continue doing

333
00:17:30,243 --> 00:17:31,424
going forward for any vehicle game,

334
00:17:32,304 --> 00:17:34,006
is we apply the friction forces

335
00:17:34,286 --> 00:17:35,507
at the height of the center of mass,

336
00:17:35,787 --> 00:17:37,149
so we don't get that rolling torque.

337
00:17:37,609 --> 00:17:38,970
So instead of applying them down here,

338
00:17:39,751 --> 00:17:40,451
apply them up there.

339
00:17:41,003 --> 00:17:44,504
So now there's no rolling torque and we don't have to worry about flipping the car from

340
00:17:44,544 --> 00:17:51,526
steering. Once we see that in action, the vehicle is able to turn as tight as we want it to

341
00:17:51,546 --> 00:17:56,288
and we don't have to worry about rolling. But you'll notice it has really uninteresting

342
00:17:56,588 --> 00:18:00,969
turning right now. There's no suspension wobble. That got lost because we don't have any of

343
00:18:00,989 --> 00:18:01,810
that torque anymore.

344
00:18:02,545 --> 00:18:08,887
but you can just add it back in visuals. So our cars look like they have suspension, but it's

345
00:18:08,927 --> 00:18:14,129
all fake. It's all just done in the animation system. And so this way you can have suspension

346
00:18:14,210 --> 00:18:18,231
look as wobbly as you want without it actually affecting how you want the vehicle to drive.

347
00:18:20,752 --> 00:18:25,714
Wheel positions. This is an important aspect of how well your vehicle can steer. Looking at

348
00:18:25,754 --> 00:18:27,755
two properties, I call them axle separation.

349
00:18:28,593 --> 00:18:31,695
which is how far the rear wheels are from the front wheels,

350
00:18:32,355 --> 00:18:34,496
and axle width, which is how far the left wheel

351
00:18:34,576 --> 00:18:35,297
is from the right wheel.

352
00:18:36,017 --> 00:18:37,838
These two numbers make a ratio,

353
00:18:37,898 --> 00:18:39,439
and that ratio is a very important number

354
00:18:39,479 --> 00:18:40,879
for how well your vehicle can steer.

355
00:18:41,640 --> 00:18:43,440
Here we have a tool that we use

356
00:18:43,480 --> 00:18:45,001
to measure a vehicle's handling.

357
00:18:46,662 --> 00:18:48,703
So what we'll do is we'll have the vehicle drive forward

358
00:18:48,763 --> 00:18:51,204
and steer various maneuvers at various speeds

359
00:18:51,284 --> 00:18:53,665
and record its position along the track

360
00:18:53,725 --> 00:18:54,886
just to see how well it's handling

361
00:18:55,326 --> 00:18:56,546
and to compare it to other vehicles.

362
00:18:57,254 --> 00:19:01,118
So what happens if we move the front axle forward just 2 centimeters?

363
00:19:02,019 --> 00:19:05,423
Already the vehicle is not turning as well. It's getting a little sluggish,

364
00:19:05,983 --> 00:19:08,886
and it's sometimes very subtle. You won't notice it playing,

365
00:19:09,387 --> 00:19:12,230
but your hardcore players will, and they'll call you out on it.

366
00:19:13,672 --> 00:19:15,173
So what can we do about this?

367
00:19:16,219 --> 00:19:21,101
What I was going to say was a big problem that we had with Rocketly is we allowed the

368
00:19:21,161 --> 00:19:25,222
physics wheels to be defined by the artist. We just simply put the physics wheel wherever

369
00:19:25,262 --> 00:19:30,483
the visual wheel was on the car. As you can guess, this had a dramatic effect on handling.

370
00:19:30,523 --> 00:19:34,645
We would get a new vehicle in and we'd have a long iteration times of trying to figure

371
00:19:34,665 --> 00:19:40,427
out how to get it drivable, either adjusting the visual mesh or more likely adding offsets

372
00:19:40,447 --> 00:19:42,467
to the physics wheels until it became drivable.

373
00:19:44,288 --> 00:19:46,690
So as of summer of last year, after release,

374
00:19:46,910 --> 00:19:49,292
we switched to a vehicle preset system.

375
00:19:50,053 --> 00:19:51,514
The idea of a vehicle preset system

376
00:19:51,554 --> 00:19:54,536
is we simply completely separate the physics settings

377
00:19:55,517 --> 00:19:56,137
from the visuals.

378
00:19:56,177 --> 00:19:58,539
We don't look at the visuals at all

379
00:19:58,579 --> 00:20:00,000
when setting up the physics for the vehicle.

380
00:20:01,141 --> 00:20:03,383
For us, that includes the collision size

381
00:20:03,523 --> 00:20:05,064
and translation for the vehicle collision,

382
00:20:06,045 --> 00:20:10,128
and also the wheel positions and the radius of each wheel.

383
00:20:11,673 --> 00:20:15,516
With this we have many vehicles, I don't even know how many vehicles we have in the game now,

384
00:20:15,896 --> 00:20:20,379
but we only have a handful of actual physics presets. So as soon as we get a new vehicle in,

385
00:20:21,060 --> 00:20:26,844
we just give it an existing preset and it's good to go. Of course this gave us faster

386
00:20:26,884 --> 00:20:28,865
iteration, I wish we had done it a really long time ago.

387
00:20:30,837 --> 00:20:35,938
line up with your visuals anymore, obviously. So I thought there would be a problem where if

388
00:20:35,978 --> 00:20:40,399
the wheel is going up a slope, it might intersect the geometry because the visual is offset

389
00:20:40,419 --> 00:20:44,280
from the physics. Nobody seems to really care. It's not that important in a very fast paced

390
00:20:44,300 --> 00:20:52,042
game. Stability, talking about how we can get vehicles back in the action once they become

391
00:20:52,162 --> 00:20:56,323
unstable. Let's look at a scenario where a vehicle actually leaves the ground and lands

392
00:20:56,403 --> 00:20:57,323
awkwardly on its side.

393
00:20:59,348 --> 00:21:00,629
Notice it takes a while to recover.

394
00:21:00,689 --> 00:21:02,810
It does recover because it's got a low center of mass,

395
00:21:02,930 --> 00:21:05,411
but when it does, it's facing the wrong direction.

396
00:21:07,292 --> 00:21:09,593
So for Rocket League, we work around this

397
00:21:09,633 --> 00:21:11,414
by adding auxiliary forces to help out.

398
00:21:11,774 --> 00:21:12,915
Looking at two scenarios here,

399
00:21:12,975 --> 00:21:14,296
we have a vehicle on the left

400
00:21:14,356 --> 00:21:16,857
who has wheels touching the ground, but not all of them,

401
00:21:17,797 --> 00:21:18,938
and a vehicle on the right

402
00:21:19,158 --> 00:21:21,379
who has a body touching the ground, but no wheels.

403
00:21:21,999 --> 00:21:23,200
For both of these situations,

404
00:21:23,240 --> 00:21:25,461
we're gonna look at the surface normal that it's touching,

405
00:21:26,421 --> 00:21:28,362
and we're gonna apply a rolling torque.

406
00:21:28,883 --> 00:21:32,866
to try to align the vehicle's up axis with that surface normal.

407
00:21:33,407 --> 00:21:37,591
We played around with also doing pitch torques to try to get maybe the front end down faster

408
00:21:37,751 --> 00:21:41,274
or yaw torques if it was maybe yawed up and rolled.

409
00:21:41,875 --> 00:21:47,380
We found that made really unpredictable corrections on the vehicle and decided that roll alone

410
00:21:47,460 --> 00:21:48,741
was perfectly fine.

411
00:21:50,253 --> 00:21:53,794
One difference between these two scenarios is once the vehicle's got a wheel on the ground,

412
00:21:53,834 --> 00:21:58,514
we're also going to give a downward linear force to really clamp it down into that ground much

413
00:21:58,554 --> 00:22:02,235
faster. Obviously, we don't want to do that for this scenario on the right because that would be

414
00:22:02,275 --> 00:22:07,316
counteracting that roll force. But once he's rolled far enough, we will flip it on and that

415
00:22:07,356 --> 00:22:12,257
plants our vehicles to the ground and we'll flip off these extra forces once we've got three or

416
00:22:12,297 --> 00:22:18,158
more wheels touching the ground. Looking at what we had before, just to refresh your memory.

417
00:22:18,728 --> 00:22:20,169
We have the vehicle leave the ground,

418
00:22:20,189 --> 00:22:22,491
takes a while to recover, it's facing the wrong direction.

419
00:22:23,972 --> 00:22:25,493
After we apply stability forces,

420
00:22:27,614 --> 00:22:29,536
the vehicle is able to right itself much quicker

421
00:22:30,136 --> 00:22:31,957
and it's now facing the correct direction still.

422
00:22:34,039 --> 00:22:36,701
So coming to an end, talking about everything

423
00:22:36,721 --> 00:22:37,801
that we did for our vehicles

424
00:22:38,922 --> 00:22:40,203
and some key takeaways from it.

425
00:22:41,264 --> 00:22:42,805
Strongly encourage you to start

426
00:22:42,965 --> 00:22:45,366
with the simplest vehicle system you possibly can

427
00:22:45,446 --> 00:22:47,888
and just simply add complexity whenever the need arises.

428
00:22:47,928 --> 00:22:48,268
Yo, yo.

429
00:22:48,682 --> 00:22:51,283
find that the need doesn't arise that often.

430
00:22:52,243 --> 00:22:54,124
Or if you already have a vehicle system you want to use

431
00:22:54,164 --> 00:22:57,965
or you have to use, find ways to trim out the complexity

432
00:22:58,066 --> 00:22:59,686
by keeping things constant

433
00:22:59,706 --> 00:23:01,107
or removing things from the equation.

434
00:23:03,328 --> 00:23:04,908
Anything that you lose with that,

435
00:23:05,148 --> 00:23:06,369
you can always just make up in the visuals.

436
00:23:06,429 --> 00:23:08,270
We have a surprising amount of our things

437
00:23:08,590 --> 00:23:10,631
that look like physics that are actually all happening

438
00:23:11,191 --> 00:23:13,992
sort of under the hood, so to speak, in the animation layer.

439
00:23:17,086 --> 00:23:19,588
And another thing is when iterating on your vehicles,

440
00:23:19,868 --> 00:23:20,809
don't depend on the visuals.

441
00:23:20,829 --> 00:23:22,130
Those are gonna change all the time.

442
00:23:22,910 --> 00:23:24,552
So just keep your physics settings separate

443
00:23:24,772 --> 00:23:26,233
and you will be able to iterate much faster.

444
00:23:33,358 --> 00:23:35,800
So concluding our vehicle tuning section,

445
00:23:36,521 --> 00:23:38,402
we get to move on to what I would think

446
00:23:38,422 --> 00:23:39,363
would be the meat of the talk,

447
00:23:39,403 --> 00:23:41,705
and my favorite part is talking about networking.

448
00:23:43,026 --> 00:23:44,787
So we had some interesting challenges

449
00:23:44,968 --> 00:23:46,028
with Rocket League's networking.

450
00:23:47,964 --> 00:23:55,479
first off input delay is not an option. So what I mean by this is many physics driven

451
00:23:55,679 --> 00:23:59,267
games that involve vehicles, they can get away with having the client

452
00:24:00,615 --> 00:24:01,936
send their input up to the server,

453
00:24:02,336 --> 00:24:05,238
and have the server simulate the physics simulation,

454
00:24:05,278 --> 00:24:07,059
and send the results back down to the client

455
00:24:07,439 --> 00:24:09,601
before the client even sees the car move at all.

456
00:24:10,081 --> 00:24:12,462
They can do this because the vehicles are more realistic.

457
00:24:12,482 --> 00:24:14,524
They have a slow acceleration, slow braking,

458
00:24:14,584 --> 00:24:15,784
they don't turn too sharply,

459
00:24:16,265 --> 00:24:17,365
and they can totally get away

460
00:24:17,725 --> 00:24:20,447
with having this added network latency.

461
00:24:21,067 --> 00:24:22,328
Obviously, we can't do that for Rocket League

462
00:24:22,348 --> 00:24:24,489
because it's so fast-paced, it would be very noticeable

463
00:24:24,529 --> 00:24:25,830
and makes the game pretty unplayable.

464
00:24:26,985 --> 00:24:28,647
So since we can't have input delay,

465
00:24:29,068 --> 00:24:29,989
we're gonna have to implement

466
00:24:30,029 --> 00:24:31,150
some kind of client prediction.

467
00:24:32,052 --> 00:24:35,336
This has been kind of a solved problem since the mid 90s.

468
00:24:35,356 --> 00:24:37,379
We've had client prediction for shooters for so long.

469
00:24:37,860 --> 00:24:39,762
The tricky part is how are we gonna apply

470
00:24:39,822 --> 00:24:43,267
client prediction to a physics simulation

471
00:24:43,307 --> 00:24:44,649
that involves rigid body vehicles?

472
00:24:47,316 --> 00:24:51,679
Another issue is when the player is sending their inputs up to the server, it suffers from

473
00:24:51,899 --> 00:24:57,203
packet loss, packet jitter, it arrives unpredictably on the server. This isn't a problem

474
00:24:57,344 --> 00:25:01,827
for most games because the server can just simply not run physics for that particular player

475
00:25:02,267 --> 00:25:06,110
until his input comes in. Once it comes in, we run physics immediately and everything is

476
00:25:06,130 --> 00:25:10,894
good. We don't want to do that for Rocket League and we'll get into more detailed reasons why

477
00:25:10,914 --> 00:25:11,815
in the next slides.

478
00:25:14,096 --> 00:25:18,058
Another challenge is collision with moving objects. Normally when you're using client

479
00:25:18,098 --> 00:25:25,101
prediction, if you've played a game, a shooter, where you've been, had high latency and have

480
00:25:25,181 --> 00:25:29,063
either run into other players and been rubber banding around or maybe even something as

481
00:25:29,103 --> 00:25:32,724
simple as going up an elevator and characters jittering on the way up.

482
00:25:33,445 --> 00:25:40,550
that is because client prediction is fighting this server authoritative moving object. So we

483
00:25:40,570 --> 00:25:44,513
need to overcome that in rocket league because the core game involves hitting a moving

484
00:25:44,593 --> 00:25:52,479
object. Last but not least, we wanted to be a PC game so we needed 100% server authority. We

485
00:25:52,499 --> 00:25:59,104
didn't want to trust the clients for anything because cheaters like to cheat. So why can't

486
00:25:59,124 --> 00:26:01,406
we have the server just simply wait for client input?

487
00:26:05,414 --> 00:26:09,098
As players send their inputs to the server, they suffer from loss, they suffer from jitter.

488
00:26:11,662 --> 00:26:16,909
So the server can just simply wait for inputs to come in before running physics for that player.

489
00:26:18,857 --> 00:26:22,078
This isn't very good for rigid body simulation because a core

490
00:26:22,138 --> 00:26:25,200
tenant of rigid body simulations is everyone moves at the same

491
00:26:25,240 --> 00:26:28,442
time a little bit at a time. We can't have one actor sitting

492
00:26:28,482 --> 00:26:31,563
there while all the rest are running their own simulations.

493
00:26:32,324 --> 00:26:35,065
It's also particularly bad for rocket lead because you could

494
00:26:35,085 --> 00:26:38,747
get a pretty bad desync when you're hitting a moving object.

495
00:26:38,787 --> 00:26:42,889
And I want to take a look at that real quick. Here we have a

496
00:26:42,930 --> 00:26:47,052
scenario where a client's car on the left is moving towards the

497
00:26:47,252 --> 00:26:47,792
moving ball.

498
00:26:48,908 --> 00:26:52,190
We're going to step through it frame by frame and see what the client sees as he's approaching

499
00:26:52,210 --> 00:26:58,095
the ball. Finally, he thinks that he has hit the ball here and is able to predict the hit and

500
00:26:58,135 --> 00:27:03,980
maybe sees the ball go into the goal. For a server, he's sitting here waiting for the client

501
00:27:04,020 --> 00:27:08,523
inputs to come in before running physics. One comes in, so he's good to go, runs a physics

502
00:27:08,543 --> 00:27:13,507
frame. But then the next input gets delayed a little bit. This isn't a problem. The server

503
00:27:13,547 --> 00:27:17,890
could just not run physics for that car, but he's got to run everyone else because the show

504
00:27:17,910 --> 00:27:18,371
must go on.

505
00:27:19,225 --> 00:27:24,330
So it continues running physics for the ball. Finally the player input comes in, but at

506
00:27:24,350 --> 00:27:29,455
this point the ball has already moved past him and he has missed the ball. Finally the

507
00:27:29,495 --> 00:27:35,441
server sends this new information back down to the client. Client who thought the ball was

508
00:27:35,501 --> 00:27:40,966
in the goal sees the ball just warp back here. He says, what the hell?

509
00:27:42,785 --> 00:27:48,450
So the reason we don't want servers to pause individual players to wait for their inputs is

510
00:27:48,490 --> 00:27:52,933
because it results in non-deterministic behavior between the client simulation and the

511
00:27:52,953 --> 00:27:58,637
server simulation. What about hitting a moving object? What kind of challenges are we

512
00:27:58,677 --> 00:28:04,902
seeing with that? The idea is the client is predicting his vehicle, so his vehicle is ahead

513
00:28:04,942 --> 00:28:11,126
of the servers, but the server is authoritative over the ball. So the client under these

514
00:28:12,587 --> 00:28:17,589
in this situation normally for most games is just simply drawing the ball where the server

515
00:28:17,629 --> 00:28:23,051
tells him the ball is at. But this is old information. The tricky part with this is we have

516
00:28:23,091 --> 00:28:27,994
two things interacting on the client that are kind of existing in two different timelines with

517
00:28:28,014 --> 00:28:34,316
the car being ahead of the server, the ball being behind the server. Looking at this in

518
00:28:34,437 --> 00:28:39,819
action to see what actually happens. Here we have a car moving down towards a moving ball.

519
00:28:40,306 --> 00:28:44,147
We're going to overlay the client's view so we can see what he sees and what the server sees at

520
00:28:44,187 --> 00:28:49,069
the same time. The client thinks he's driving towards the ball and is able to get a hit off

521
00:28:49,129 --> 00:28:55,952
here. This is what the client sees in his view. This is what the server sees. The client is

522
00:28:56,012 --> 00:29:00,873
nowhere near the ball and he doesn't get a hit. So this timeline discrepancy is something

523
00:29:00,893 --> 00:29:06,655
that we have to overcome for Rocket League. Now, some people ask, what's the difference

524
00:29:07,168 --> 00:29:15,235
for that particular scenario, why don't we just do some form of lag compensation? This is

525
00:29:15,295 --> 00:29:20,099
something we can take from a page from the book of first person shooters is.

526
00:29:21,113 --> 00:29:26,775
the idea that in a shooter you can predict your weapon shooting and then predict that it hit

527
00:29:26,795 --> 00:29:31,236
something and send a packet to the server saying, hey, I shot this guy. When the server

528
00:29:31,276 --> 00:29:36,098
eventually gets that packet, he can look back in time, see that that guy was where you thought

529
00:29:36,138 --> 00:29:41,019
he was, confirm the hit, maybe give you a kill, and this way you're able to fire your weapon as

530
00:29:41,119 --> 00:29:46,101
if we have zero latency and everything is great. How would this apply to Rocket League?

531
00:29:47,812 --> 00:29:52,094
maybe clients could predict hitting the ball and send a packet up to the server saying, hey, I

532
00:29:52,114 --> 00:29:57,697
hit the ball. Server can do the same thing, look back in time, confirm that it's a good hit,

533
00:29:58,017 --> 00:30:02,779
update the ball's position, update the trajectory and continue on like everything's going

534
00:30:02,819 --> 00:30:08,121
great. What does this actually look like in practice? Here we're going to overlay the

535
00:30:08,161 --> 00:30:11,623
server view on top of a laggy client. In this example we'll say the client has a 200

536
00:30:12,063 --> 00:30:16,045
millisecond ping, which is pretty high. Client's driving towards the ball.

537
00:30:16,986 --> 00:30:20,547
thinks that he hits the ball here, so he's going to send a packet up to the server saying,

538
00:30:20,587 --> 00:30:25,828
hey, I hit the ball. Server keeps running the physics simulation until he finally gets the

539
00:30:25,868 --> 00:30:30,869
packet from the client saying when the ball was back here, I think I hit it. Server is going to

540
00:30:30,889 --> 00:30:35,270
look back in time and agree, yep, you're not a cheater, I agree, so I'm going to move the ball

541
00:30:35,350 --> 00:30:41,411
back here and update its position, run a few frames of physics to get back ahead of the

542
00:30:41,451 --> 00:30:44,932
client, and now we're all in sync again, everything's good.

543
00:30:45,787 --> 00:30:50,671
and the client just felt like he hit the ball with zero latency. So everything seems great

544
00:30:51,252 --> 00:30:55,455
until we add another player into the mix. Now we're going to see things from the point

545
00:30:55,475 --> 00:31:01,300
of view of a low ping player. This guy's ping is so low, basically what he sees is what

546
00:31:01,340 --> 00:31:05,763
the server sees. Walking through frame by frame, he's going to try to hit the ball as

547
00:31:05,823 --> 00:31:06,064
well.

548
00:31:07,047 --> 00:31:11,270
At this point, he thinks he's about to hit the ball, or maybe that he did hit the ball, but

549
00:31:11,310 --> 00:31:15,974
remember, this packet is now arriving on the server from the high ping client, indicating

550
00:31:16,014 --> 00:31:21,458
that he hit the ball. So the server is going to move that ball back, rerun physics, send that

551
00:31:21,498 --> 00:31:26,882
update down to the low ping client, and he sees the ball warp past him, maybe rolling into the

552
00:31:26,902 --> 00:31:34,328
goal. He says, what the hell, man? So we can't do lag compensation because laggy clients would

553
00:31:34,368 --> 00:31:35,850
ruin the game for everyone else.

554
00:31:36,754 --> 00:31:41,337
Now, I should specify that this is actually a viable option,

555
00:31:41,457 --> 00:31:44,899
lag compensation, if you're running out of time or

556
00:31:44,979 --> 00:31:48,362
resources, because this is exactly what we did for

557
00:31:48,402 --> 00:31:50,903
supersonic acrobatic rocket-powered battle cars.

558
00:31:52,424 --> 00:31:54,365
People had fun playing the game online.

559
00:31:54,405 --> 00:31:57,427
It developed an online kind of cult following.

560
00:31:58,068 --> 00:31:59,429
But we can do better.

561
00:32:01,290 --> 00:32:03,651
What do we end up doing for Rocket League to get it

562
00:32:03,711 --> 00:32:04,752
playable over the internet?

563
00:32:05,718 --> 00:32:11,962
really came down to two key concepts as far as I'm concerned. First one is to handle the

564
00:32:12,002 --> 00:32:16,405
problem of jittery player inputs coming into the server. We're going to buffer those inputs

565
00:32:16,886 --> 00:32:23,870
just like a video player would buffer a video stream. The second thing that ended up being

566
00:32:23,890 --> 00:32:28,594
kind of wacky is we have the clients predict everything about the simulation. So instead of

567
00:32:28,654 --> 00:32:33,877
running prediction and corrections on their own vehicle, they're actually going to run it on

568
00:32:33,957 --> 00:32:34,678
their own vehicle.

569
00:32:35,255 --> 00:32:42,661
every other vehicle and the ball. So with that said, I'm going to split networking up into two

570
00:32:42,781 --> 00:32:47,425
distinct sections and talk about input buffer. I have to apologize, you're about to get a wall

571
00:32:47,445 --> 00:32:53,150
of text. I don't have pretty slides for this one, so just bear with me. So the idea with the

572
00:32:53,190 --> 00:32:58,114
input buffer is the client, for every physics frame he runs, he's recording input and just

573
00:32:58,234 --> 00:32:59,354
sending that off to the server.

574
00:33:00,755 --> 00:33:05,637
This is arriving on the server at some random rate. Who knows when an input is going to get in

575
00:33:05,677 --> 00:33:11,759
there. So instead of processing input as soon as it comes into the server, the server is going

576
00:33:11,779 --> 00:33:19,342
to put it into a buffer and let that buffer fill up for a little bit. So when it comes time for

577
00:33:19,362 --> 00:33:24,804
the server to run physics, it can just take one item from this buffer and he's good to go. He

578
00:33:24,844 --> 00:33:26,985
doesn't have to ever pause for the player.

579
00:33:28,014 --> 00:33:35,097
because ideally there's always something in this input buffer that he can pull from. The

580
00:33:35,117 --> 00:33:39,119
nice thing about this is it eliminates certain classes of cheats. You don't get speed

581
00:33:39,159 --> 00:33:45,202
cheaters because if a player increases the rate at which their game is running as a

582
00:33:45,242 --> 00:33:48,223
cheater, all they're going to do is fill up that input buffer faster.

583
00:33:49,175 --> 00:33:54,577
Likewise, if they intentionally try to make their network jittery or laggy to try to

584
00:33:54,617 --> 00:33:58,858
appear jittery to other players, it can't happen because the server is just simply pulling

585
00:33:58,898 --> 00:34:05,499
inputs out of a buffer whenever it needs it. Downside is it increases average latency

586
00:34:05,539 --> 00:34:09,480
because the server instead of processing input from a player as soon as it arrives, it's

587
00:34:09,500 --> 00:34:12,861
going to sit on it for a few frames and then process it sometime later.

588
00:34:15,420 --> 00:34:19,202
There are a few key requirements if you're going to implement an input buffer on the server.

589
00:34:19,802 --> 00:34:24,623
First off, you don't want it to run empty because if an input buffer runs empty, that means

590
00:34:24,643 --> 00:34:29,325
the next time the server goes to run physics, he won't have any input to work with. So he's

591
00:34:29,365 --> 00:34:34,507
just going to have to reuse whatever the previous input was. Not terrible, but you might miss

592
00:34:34,527 --> 00:34:39,689
something important. You also don't want the buffer to get too big because now inputs are

593
00:34:39,709 --> 00:34:44,290
just sitting in the buffer for longer and it's adding latency to the player. So the question

594
00:34:45,700 --> 00:34:51,744
what techniques can we use to grow or shrink this input buffer? One technique is upstream

595
00:34:51,764 --> 00:34:56,566
throttle, or at least I'm calling it upstream throttle. The idea is the server can tell the

596
00:34:56,606 --> 00:35:03,450
client to run faster or slower depending on how empty or full the input buffer on the server

597
00:35:03,570 --> 00:35:09,494
is. So if the input buffer is low, he tells the client to speed up, maybe run an extra

598
00:35:09,554 --> 00:35:12,135
physics frame more than he would have normally.

599
00:35:13,868 --> 00:35:17,049
If the buffer's getting full, tells the client,

600
00:35:17,369 --> 00:35:19,829
maybe don't run one more physics frame.

601
00:35:20,289 --> 00:35:24,951
And now, inputs are coming in to the buffer slower

602
00:35:25,131 --> 00:35:27,531
than they're being pulled out, so the buffer can shrink down.

603
00:35:29,272 --> 00:35:31,152
This is the technique used by Overwatch,

604
00:35:31,372 --> 00:35:35,473
as explained in last year's GDC talk given by Tim Ford,

605
00:35:36,273 --> 00:35:38,034
Overwatch Gameplay Architecture and Netcode.

606
00:35:38,454 --> 00:35:40,875
If you haven't seen this, you have to watch it.

607
00:35:41,255 --> 00:35:42,835
If you have seen it, go watch it again.

608
00:35:42,855 --> 00:35:43,495
It's totally worth it.

609
00:35:45,947 --> 00:35:51,711
what Rocket League uses is what I'm calling downstream throttle. The idea here is the server

610
00:35:51,751 --> 00:35:58,034
handles the input buffer himself without talking to the client. It just simply consumes 0, 1 or

611
00:35:58,675 --> 00:36:05,058
2 client inputs for every physics frame depending on what he needs. So the idea is if the

612
00:36:05,098 --> 00:36:11,742
buffer is running low, the server is going to repeat an input for two physics frames so that

613
00:36:11,822 --> 00:36:13,983
he's consuming inputs slower.

614
00:36:16,052 --> 00:36:17,694
and it gives a chance for the buffer to fill up.

615
00:36:18,375 --> 00:36:19,656
If the buffer's running full,

616
00:36:20,077 --> 00:36:23,020
he's gonna consume two inputs for one physics frame.

617
00:36:23,120 --> 00:36:24,201
Not throw out an input,

618
00:36:24,501 --> 00:36:26,944
it'll still process it so he can catch jumps and dodges

619
00:36:27,004 --> 00:36:27,985
and other important things,

620
00:36:28,546 --> 00:36:29,767
but he's just simply gonna consume it

621
00:36:29,927 --> 00:36:32,650
and then consume the next input too for one physics frame.

622
00:36:34,443 --> 00:36:38,824
This is effective, it works, we're still running with this today, but if you think about it,

623
00:36:38,884 --> 00:36:43,406
it can result in minor desyncs because the server is doing exactly what we didn't want

624
00:36:43,446 --> 00:36:48,328
to do, which is repeating player input or reading input without running a physics frame

625
00:36:48,348 --> 00:36:53,529
for it. So the one-to-one ratio of input to physics frame that the client is running may

626
00:36:53,569 --> 00:36:57,611
not be the exact same thing the server is running and you could get desyncs. I should

627
00:36:57,631 --> 00:36:57,891
mention...

628
00:36:58,691 --> 00:37:02,574
If you're going to go with input buffers, I strongly suggest starting off with the upstream

629
00:37:02,614 --> 00:37:06,738
throttle method where you tell the client to run faster or slower. It seems much smarter to me

630
00:37:06,858 --> 00:37:11,281
and we're investigating converting Rocket League to that system pretty much right now.

631
00:37:12,742 --> 00:37:18,827
Sorry, not today. We're investigating it today. The other aspect for Rocket League's

632
00:37:18,887 --> 00:37:21,450
networking is predicting everything.

633
00:37:22,844 --> 00:37:27,248
So the best way I can explain this and to see how exactly it works and how we're able to hit

634
00:37:27,428 --> 00:37:31,573
moving objects is just walking through it with you one frame at a time.

635
00:37:31,593 --> 00:37:35,757
And we're going to see this whole process from beginning to the end.

636
00:37:35,937 --> 00:37:40,942
So the idea, what we have here is the client on the left has a vehicle and he's pressed

637
00:37:40,962 --> 00:37:44,286
throttle, but that input hasn't made it to the server yet, so the server doesn't know.

638
00:37:45,540 --> 00:37:49,242
the ball isn't moving on the client because maybe it doesn't know it's moving yet, but the

639
00:37:49,262 --> 00:37:53,545
server knows it does. Maybe somebody just hit it. So they're out of sync and we need to get

640
00:37:53,565 --> 00:37:58,367
them back in sync. For every physics frame that the client runs, he's going to record the

641
00:37:58,387 --> 00:38:03,190
current input and an incremental frame number. This is just a number to identify this

642
00:38:03,250 --> 00:38:10,774
particular physics frame. He then runs physics and records the results to history. So for

643
00:38:10,814 --> 00:38:13,555
frame number one, the car is there, the ball is there.

644
00:38:15,167 --> 00:38:19,489
He then sends this frame number and his inputs up to the server.

645
00:38:19,809 --> 00:38:21,350
It's going to take some time to get there.

646
00:38:23,271 --> 00:38:25,692
While it's in route, the client and server

647
00:38:25,772 --> 00:38:27,333
are just going to keep on running physics.

648
00:38:29,054 --> 00:38:31,135
Finally, this information makes it to the server.

649
00:38:31,595 --> 00:38:33,496
The server is able to read that player's input,

650
00:38:33,836 --> 00:38:35,777
see that the player is actually pressing throttle now,

651
00:38:36,337 --> 00:38:37,918
and then it's going to run physics just

652
00:38:37,938 --> 00:38:38,678
like it always would.

653
00:38:40,499 --> 00:38:41,700
Car moves forward on server.

654
00:38:41,920 --> 00:38:43,061
Ball moves forward on server.

655
00:38:43,998 --> 00:38:49,482
Now that the server has run physics, he's able to pack the current physics state up into a

656
00:38:49,542 --> 00:38:55,886
packet and send that information plus the frame number back down to the client. It's going to

657
00:38:55,926 --> 00:38:59,087
take some time for this information to get down there, so again, the server and the client

658
00:38:59,127 --> 00:39:06,732
just keep on running physics. Finally, it makes it to the client and the client is able to see

659
00:39:08,625 --> 00:39:13,808
I should say compare the server state to what he had recorded in history. So this is what we

660
00:39:13,848 --> 00:39:18,771
got from the server. This is what we have recorded for frame number one on the client. The

661
00:39:18,811 --> 00:39:22,074
car is good because we were predicting our car and we knew we were holding throttle. So

662
00:39:22,114 --> 00:39:28,157
that's fine. But we didn't know the ball was moving. So that is way off. It's far enough off

663
00:39:28,237 --> 00:39:29,718
that we're going to have to do a correction.

664
00:39:31,184 --> 00:39:36,608
So first thing we do for a correction is we update that point in history to the new data

665
00:39:36,628 --> 00:39:42,453
that we just got from the server. Then we're going to take where all of our physics actors

666
00:39:42,513 --> 00:39:47,497
are now, so our car, all cars, and the ball, and we're going to move them back in time

667
00:39:47,977 --> 00:39:54,542
to that point in history. Then we're going to rerun physics frames a whole bunch of times

668
00:39:55,543 --> 00:39:58,766
to catch back up to the frame we had just left from.

669
00:40:00,125 --> 00:40:05,411
Now the car is back where it was before, because we have deterministic physics simulation.

670
00:40:05,992 --> 00:40:10,897
The ball is where it should be, because we now know that the ball was moving on frame

671
00:40:11,038 --> 00:40:14,682
one, and we can accurately predict that it should be further ahead now.

672
00:40:16,325 --> 00:40:22,010
If you compare what the server sees versus what the client sees at this moment in time, the

673
00:40:22,050 --> 00:40:26,053
client's car is ahead of the server's car, which we kind of expect with client prediction, but

674
00:40:26,093 --> 00:40:31,117
an interesting point is now the client's ball is ahead of the server's ball instead of behind.

675
00:40:31,557 --> 00:40:40,005
So now the car and the ball are on the same timeline, so he's able to hit the ball. Exactly

676
00:40:40,625 --> 00:40:45,229
how does that work out? Here we have the client moving towards a moving ball.

677
00:40:47,368 --> 00:40:51,210
Here we can see we're going to overlay the server's view with his car being behind the

678
00:40:51,250 --> 00:40:56,652
client and the ball being behind the client as well. Here is the data that the server is

679
00:40:56,692 --> 00:41:04,375
sending down to the client. Here, the client thinks he hits the ball. Eventually the input from

680
00:41:04,395 --> 00:41:08,837
that frame number makes its way up to the server. The server runs physics and because we

681
00:41:08,877 --> 00:41:13,018
have deterministic physics between client and server, they calculate the exact same

682
00:41:13,118 --> 00:41:16,259
outcome. There's no coordination, they're just running the same inputs and the same

683
00:41:16,299 --> 00:41:16,620
physics.

684
00:41:18,540 --> 00:41:23,481
That frame makes its way back down to the client where you can look up in history, confirm

685
00:41:23,681 --> 00:41:29,943
that everything is good and we don't need to do a correction and continue on just playing

686
00:41:29,963 --> 00:41:35,064
the game as we were. So now the client can hit the ball, predict hitting it as if it's zero

687
00:41:35,124 --> 00:41:41,266
latency but we don't have to do any lag compensation. What are the results of all this?

688
00:41:42,654 --> 00:41:47,696
If you think about it, if you've ever played a first person shooter back before lag compensation was invented,

689
00:41:48,096 --> 00:41:48,916
you know, back in the day,

690
00:41:49,776 --> 00:41:54,338
you remember that you would actually have to lead your target and shoot ahead of them.

691
00:41:54,458 --> 00:41:56,258
So if they're over here, you're shooting ahead of them

692
00:41:56,658 --> 00:41:58,879
and you kind of just hope that they run into your bullet.

693
00:41:59,759 --> 00:42:01,620
That's basically what we're doing in Rocket League,

694
00:42:01,840 --> 00:42:07,222
but we're able to project the ball where the player needs to be going in order to hit it.

695
00:42:07,462 --> 00:42:09,242
We're just kind of doing it behind the scenes for them.

696
00:42:10,792 --> 00:42:14,375
This works really well with the ball because the ball moves predictably. It's predictable

697
00:42:14,435 --> 00:42:20,660
physics. It's not a whole lot of dynamic input is happening with the ball. As you might guess,

698
00:42:20,720 --> 00:42:24,623
it doesn't work so well with other cars because they can change their inputs at any time and

699
00:42:24,663 --> 00:42:29,667
all of a sudden you've got 150 milliseconds of steering this way changes to 150 milliseconds

700
00:42:29,727 --> 00:42:34,671
of steering that way. It's still better than not running prediction on the cars at all.

701
00:42:34,811 --> 00:42:38,074
Trust me, I've tried turning it off on the other cars. It looks really bad.

702
00:42:40,293 --> 00:42:43,016
Huge upside is we don't have server-side lag compensation,

703
00:42:43,197 --> 00:42:45,259
so high-paying clients aren't ruining

704
00:42:45,299 --> 00:42:46,341
the game for everyone else.

705
00:42:48,363 --> 00:42:50,566
Downside is we have crazy expensive corrections

706
00:42:50,626 --> 00:42:52,949
on the client, because instead of running correction

707
00:42:53,009 --> 00:42:55,572
on just the client's character, like most games do,

708
00:42:56,073 --> 00:42:58,736
we're running corrections on the entire physics scene.

709
00:43:00,256 --> 00:43:04,679
this is where the 120 hertz physics simulation really bites us in the ass. You get a 200

710
00:43:05,060 --> 00:43:10,104
millisecond ping client running 120 hertz physics. That's 24 physics frames we got to run

711
00:43:10,204 --> 00:43:17,069
all at once while continuing to run everything else about the game. It's tough, but it's

712
00:43:17,089 --> 00:43:22,893
doable. After all this work, what we get is you can play the game, you can drive around in

713
00:43:22,913 --> 00:43:26,636
your own car with a high latency, hit the ball around, it feels like you have no latency at

714
00:43:26,716 --> 00:43:26,776
all.

715
00:43:28,590 --> 00:43:33,914
aren't ruining the game for everyone else. We can hit moving objects which is not

716
00:43:33,954 --> 00:43:38,577
something you're supposed to be allowed to do when running client prediction. And we have

717
00:43:38,597 --> 00:43:42,800
what I consider the holy grail of client server networking, a completely authoritative

718
00:43:42,820 --> 00:43:50,625
server. All it does is read inputs, execute physics. So summary for the whole talk for today.

719
00:43:50,645 --> 00:43:52,366
Key takeaways.

720
00:43:54,813 --> 00:43:58,515
Reducing complexity can help you achieve your goals.

721
00:43:58,555 --> 00:44:01,037
This is not just for physics systems and for vehicles,

722
00:44:01,097 --> 00:44:02,678
but really just everything about your game.

723
00:44:03,079 --> 00:44:04,359
If you don't like how it's going,

724
00:44:04,940 --> 00:44:07,161
you can just gut it and start from simple.

725
00:44:07,201 --> 00:44:10,564
We probably redid how the car interacts

726
00:44:10,584 --> 00:44:12,285
with the ball like three times.

727
00:44:14,827 --> 00:44:16,147
You do have a choice of physics engine.

728
00:44:16,808 --> 00:44:18,349
We didn't think we did until we tried it

729
00:44:18,429 --> 00:44:19,710
and found it surprisingly easy

730
00:44:19,750 --> 00:44:21,391
to add an additional physics engine.

731
00:44:21,511 --> 00:44:23,793
So maybe consider that for your game.

732
00:44:25,390 --> 00:44:29,312
Networking is still hard. We've had client prediction since the mid-90s, but we still

733
00:44:29,352 --> 00:44:35,594
find interesting new ways to apply it to new types of games. And I highly recommend any

734
00:44:35,614 --> 00:44:40,235
games you go forward, use a fixed tick rate. It's so much easier to debug, to reproduce

735
00:44:40,335 --> 00:44:43,896
problems. It's great for client server networking because they're running the same

736
00:44:43,936 --> 00:44:49,538
deterministic simulation. And I also recommend client input buffers instead of having the

737
00:44:49,558 --> 00:44:53,699
server wait for clients. Even if I was to make a shooter, I would go this route. It's

738
00:44:53,739 --> 00:44:53,880
just...

739
00:44:55,039 --> 00:45:03,243
more reliable, but extra work. Some resources, if you want to learn a little bit more about what

740
00:45:03,263 --> 00:45:07,446
we talked about today. Gaffron games, it's a fantastic website, you should just read

741
00:45:07,486 --> 00:45:11,108
everything on it, but particularly if you want to know more about fixed time steps, there's

742
00:45:11,128 --> 00:45:15,890
this article. I already mentioned the Overwatch game play architecture and net code that's

743
00:45:15,930 --> 00:45:16,771
available on the vault.

744
00:45:18,412 --> 00:45:23,517
these two articles I found that seem to do a really good job explaining client prediction and

745
00:45:23,557 --> 00:45:29,422
reconciliation in general if you want to know about how that works in other games. And

746
00:45:29,442 --> 00:45:35,288
there's also a YouTube channel called rocket science where they actually really dive very

747
00:45:35,348 --> 00:45:36,329
deep into how 

748
00:45:37,240 --> 00:45:43,327
physics and other things work in Rocket League and I've actually watched all the episodes and

749
00:45:43,447 --> 00:45:47,832
I've actually learned a few things about our game that I didn't know. So I highly recommend it.

750
00:45:47,852 --> 00:45:53,719
It's really great. That's it for this presentation. We've got some pretty good time for Q&A.

751
00:46:06,182 --> 00:46:13,651
Cool. So I kind of understand the system you showed where on the client-side prediction,

752
00:46:13,992 --> 00:46:18,697
it looks like you almost kind of extrapolated the ball forward based on what the server is seeing

753
00:46:18,777 --> 00:46:20,459
when you rewind back and simulate forward.

754
00:46:21,040 --> 00:46:22,982
And I can see how that system would work really well

755
00:46:24,443 --> 00:46:26,545
in the beginning of a match case, for example,

756
00:46:26,585 --> 00:46:28,327
where the two center forwards are charging

757
00:46:28,347 --> 00:46:29,188
the ball in the center.

758
00:46:29,488 --> 00:46:32,030
And if they don't do any kind of crazy turning,

759
00:46:32,070 --> 00:46:34,813
that should work out perfectly because the extrapolated

760
00:46:34,913 --> 00:46:36,294
other car will collide.

761
00:46:36,735 --> 00:46:41,480
with the ball where he would normally collide on his side of the simulation, but do you

762
00:46:41,520 --> 00:46:47,147
know if that causes issues if one of the guys at the last second changes his vector to decide

763
00:46:47,207 --> 00:46:49,730
not to hit the ball because it takes a while for the input to arrive?

764
00:46:49,770 --> 00:46:51,451
Yes, it absolutely does.

765
00:46:52,513 --> 00:46:53,794
I should clarify real quick.

766
00:46:53,814 --> 00:46:55,195
We don't use extrapolation.

767
00:46:55,235 --> 00:46:57,057
What we're doing is rerunning physics frames.

768
00:46:57,597 --> 00:46:59,719
But I get what you're saying, and it absolutely

769
00:46:59,739 --> 00:47:00,480
does cause problems.

770
00:47:00,500 --> 00:47:01,981
That's why kickoffs are basically

771
00:47:02,001 --> 00:47:03,222
the worst thing for our game.

772
00:47:03,663 --> 00:47:06,045
The player can change their input at the last moment,

773
00:47:06,205 --> 00:47:07,687
and you predicted that they hit the ball.

774
00:47:08,888 --> 00:47:10,709
but instead they actually miss the ball.

775
00:47:11,189 --> 00:47:12,871
So you see the ball moving on your screen,

776
00:47:12,891 --> 00:47:13,992
but it's actually not moving.

777
00:47:14,492 --> 00:47:16,654
What we did for that was make sure

778
00:47:16,694 --> 00:47:19,496
that we send the ball information down to the client

779
00:47:19,556 --> 00:47:22,099
at a regular interval, even if nothing has changed.

780
00:47:22,159 --> 00:47:24,040
So you'll see the ball slide away for a second

781
00:47:24,080 --> 00:47:25,121
and then slide back.

782
00:47:26,262 --> 00:47:27,103
Cool, okay, got it.

783
00:47:30,854 --> 00:47:35,458
you said you used 120 hertz fixed physics step to improve

784
00:47:35,498 --> 00:47:39,862
consistency. But you said also multiple times or a few times

785
00:47:39,902 --> 00:47:42,624
throughout the presentation that there are some minor regrets

786
00:47:42,664 --> 00:47:44,866
regarding that. I'm curious if you were to go back and say

787
00:47:45,006 --> 00:47:48,509
remake everything from scratch, if you would go with a different

788
00:47:48,870 --> 00:47:53,173
method. Yes. I would at least investigate something where

789
00:47:53,293 --> 00:47:55,916
possibly taking the penetration depths into account when

790
00:47:55,976 --> 00:47:57,157
calculating those vectors.

791
00:47:59,088 --> 00:48:03,794
I would try that out first before turning on 120 hertz.

792
00:48:03,874 --> 00:48:05,876
We did 120 hertz because we were strapped for time.

793
00:48:06,236 --> 00:48:07,938
Well, you're always strapped for time, aren't you, when

794
00:48:07,958 --> 00:48:08,739
you're working on a game?

795
00:48:09,380 --> 00:48:10,721
But it was the easy thing to do.

796
00:48:10,981 --> 00:48:12,563
But yeah, I would definitely investigate a different

797
00:48:12,583 --> 00:48:13,424
solution to the problem.

798
00:48:13,845 --> 00:48:14,285
Awesome, thanks.

799
00:48:16,837 --> 00:48:21,678
I have two hopefully short questions. One being how do you deal with things like audio or

800
00:48:21,818 --> 00:48:26,239
effects that you can't necessarily roll back? So like the collision of the ball makes an

801
00:48:26,299 --> 00:48:31,980
audio cue happen but then if that collision didn't turn out to happen when you get the

802
00:48:32,040 --> 00:48:35,640
information back from the server, do you actually like stop the audio or do you just say

803
00:48:35,660 --> 00:48:41,222
screw it? You heard that and it's erroneous. Luckily our audio is pretty short so we just

804
00:48:41,362 --> 00:48:43,442
leave it. One thing we make sure not to do

805
00:48:44,482 --> 00:48:51,184
is repeat audio. So if the player thinks they hit the ball and then a correction comes in and they

806
00:48:51,204 --> 00:48:55,845
rerun physics and they just hit the ball again, we make sure we're not going to repeat that audio

807
00:48:55,865 --> 00:49:01,026
and it won't stack up. But otherwise if the player thinks they hit the ball and a correction comes in

808
00:49:01,066 --> 00:49:05,207
and turns out they actually missed it, it's a short-lived audio so we just let it keep playing.

809
00:49:05,947 --> 00:49:12,133
second one is on the input buffers on the server, sometimes things can come in out of order. Do

810
00:49:12,173 --> 00:49:15,896
you respect that and reorder them on the way into the buffer or does order actually end up

811
00:49:15,916 --> 00:49:20,220
mattering because you buffered anyway? We respect, well they can come in out of order but

812
00:49:20,260 --> 00:49:25,064
we'll enter them into the buffer in order. Because they have that sequential frame number we

813
00:49:25,084 --> 00:49:26,125
know what order they belong in.

814
00:49:26,862 --> 00:49:28,624
And like any other sort of out of order things

815
00:49:28,664 --> 00:49:31,026
that end up affecting that system,

816
00:49:31,086 --> 00:49:32,507
like maybe that we've made a decision

817
00:49:32,527 --> 00:49:35,950
when we have frame five, but frame six is still on the way?

818
00:49:36,750 --> 00:49:40,073
We, so we don't send player inputs one at a time.

819
00:49:40,293 --> 00:49:42,595
We'll always send like the last 10 inputs.

820
00:49:42,956 --> 00:49:43,156
Cool.

821
00:49:43,176 --> 00:49:44,677
Which is, you know, it's a standard thing to do.

822
00:49:44,757 --> 00:49:46,118
So that way, if you lose a packet

823
00:49:46,138 --> 00:49:47,039
and when the next one comes in,

824
00:49:47,119 --> 00:49:48,760
it's got a whole lot of inputs ready for you.

825
00:49:49,101 --> 00:49:49,581
Great, thanks.

826
00:49:51,796 --> 00:49:57,199
So obviously if you can predict the inputs of other players more accurately it'll end up in a better

827
00:49:57,880 --> 00:49:59,661
consistent view of the world

828
00:50:00,842 --> 00:50:04,444
Can talk a little bit about the model you use for that prediction?

829
00:50:05,045 --> 00:50:11,229
Obviously discrete button presses might be tough to predict for other players, but what about something like the analog stick?

830
00:50:12,290 --> 00:50:12,470
we

831
00:50:16,532 --> 00:50:22,053
it's a good point. So with the analog stick what we actually do we don't try to predict player

832
00:50:22,113 --> 00:50:26,035
inputs. I mean maybe you can do some like machine learning or something that might be kind

833
00:50:26,075 --> 00:50:30,476
of cool. But beyond that you can't predict what they're going to do. So your client doesn't

834
00:50:30,536 --> 00:50:35,018
predict the other cars? Correct. It'll take so here's what we actually do is it'll take

835
00:50:35,058 --> 00:50:39,079
whatever their input is that the last input that we know of that we got from the server.

836
00:50:39,979 --> 00:50:44,442
and it will, for the first frame of the correction, it's going to use that input for that

837
00:50:44,482 --> 00:50:48,665
frame. And then the next frame, specifically in regards to your comment about analog

838
00:50:48,685 --> 00:50:52,907
inputs, it's going to decay that input a little bit. And then the next frame, decay it

839
00:50:52,927 --> 00:50:57,070
some more. So it's kind of like we're losing certainty over an amount of time. So if the car

840
00:50:57,150 --> 00:51:03,013
is like full steering right on the first correction frame, by like 150 milliseconds in,

841
00:51:03,714 --> 00:51:08,296
we're just, it's got like, it's straight steering and no brakes. And that was actually

842
00:51:08,316 --> 00:51:08,877
something we did.

843
00:51:09,877 --> 00:51:12,299
In response, people were saying the game looked more laggy.

844
00:51:12,720 --> 00:51:15,161
And even though we hadn't changed the networking, we had

845
00:51:15,201 --> 00:51:16,302
made the game faster.

846
00:51:16,883 --> 00:51:18,784
And so they were seeing cars.

847
00:51:18,884 --> 00:51:21,286
If you throttled back and forth between steering, they

848
00:51:21,306 --> 00:51:22,407
would see cars doing this.

849
00:51:22,887 --> 00:51:25,629
And so by decaying the inputs, now the cars just do that.

850
00:51:26,250 --> 00:51:27,230
And it looks less laggy.

851
00:51:30,306 --> 00:51:32,808
So I do have a real question, but first, so you were saying

852
00:51:33,689 --> 00:51:36,272
lag, high lag players don't ruin the experience.

853
00:51:36,472 --> 00:51:38,894
I'd like to counter that by saying they suck as teammates.

854
00:51:39,295 --> 00:51:40,095
Well, they actually do.

855
00:51:41,437 --> 00:51:42,498
It's a real question.

856
00:51:43,238 --> 00:51:46,141
So if on my screen, and it's interesting what he was saying

857
00:51:46,181 --> 00:51:48,664
about my client doesn't predict other players.

858
00:51:49,144 --> 00:51:51,406
If on my screen I see someone else hit the ball.

859
00:51:52,081 --> 00:51:54,643
and they swear they hit the ball, but then it's a goal,

860
00:51:54,903 --> 00:51:57,145
and the replay shows that that was missed.

861
00:51:57,626 --> 00:51:59,327
How is that being handled that I saw it,

862
00:51:59,808 --> 00:52:02,210
and a teammate saw it, and it didn't happen?

863
00:52:02,370 --> 00:52:05,212
Yeah, so you saw a hit.

864
00:52:05,573 --> 00:52:06,714
The teammates saw the hit.

865
00:52:07,194 --> 00:52:09,976
You both could have been working with the compressed inputs

866
00:52:10,016 --> 00:52:11,197
that were sent down from the server.

867
00:52:11,858 --> 00:52:14,881
And so that's the problem is up until this patch

868
00:52:14,901 --> 00:52:15,881
that we're going to be coming out with.

869
00:52:18,361 --> 00:52:25,565
April 3rd? April 3rd. The server would actually send compressed physics state down to the

870
00:52:25,605 --> 00:52:31,709
clients for the networking reasons, so the server is running with full bits of floating

871
00:52:31,729 --> 00:52:35,091
point precision, compresses it, and then the clients have to work with this compressed

872
00:52:35,111 --> 00:52:39,493
state, so there's a slight desync there. So what we added was, again on that Gaffron Games

873
00:52:39,533 --> 00:52:43,115
website, it talks about quantizing physics state.

874
00:52:43,796 --> 00:52:48,141
And the idea is you're going to run the same compression on the server, then run physics,

875
00:52:48,302 --> 00:52:52,467
then run that compressed result back down to the client. And we implemented that for this

876
00:52:52,527 --> 00:52:56,273
upcoming patch, so we're hoping there will be less instances of exactly what you just described.

877
00:52:58,944 --> 00:53:03,407
Hello, sir. I got a question about cheaters. Do you guys

878
00:53:03,508 --> 00:53:10,893
cheaters, physics based cheaters or visual, visual only or nobody

879
00:53:10,953 --> 00:53:11,213
cheats?

880
00:53:11,914 --> 00:53:15,817
So far, we've only seen visual cheaters. The question is what

881
00:53:15,837 --> 00:53:17,058
kind of cheaters are we running with our game?

882
00:53:17,418 --> 00:53:22,221
Well, we were blessed with a game that doesn't quite fit the normal cheating model, since it's not a shooter.

883
00:53:22,362 --> 00:53:25,864
It's actually really quite nice. We haven't had to worry about cheaters too much.

884
00:53:26,345 --> 00:53:30,648
Mostly we've just seen visual, where they'll kind of draw the trajectory of the ball a little bit,

885
00:53:31,088 --> 00:53:33,950
and then we actually try it out, and we're like, oh, that really doesn't help all that much,

886
00:53:33,970 --> 00:53:35,812
so we actually just don't care about that yet.

887
00:53:37,693 --> 00:53:41,637
Really the biggest concern we would have is people start adding things to help them with

888
00:53:41,698 --> 00:53:43,940
like aim assist or flying or something.

889
00:53:44,260 --> 00:53:46,162
So that would be a physical cheat.

890
00:53:46,583 --> 00:53:52,269
But as far as people actually like warping around on the server or futzing with their

891
00:53:52,309 --> 00:53:54,751
inputs or something going to the server, we just don't have that problem.

892
00:53:55,552 --> 00:53:55,872
Thank you.

893
00:53:58,202 --> 00:53:59,963
Hi, thanks for your talk, it was fascinating.

894
00:54:01,644 --> 00:54:06,428
I'm wondering, you hinted a little bit at how you deploy

895
00:54:06,488 --> 00:54:08,029
physics changes post-launch.

896
00:54:08,569 --> 00:54:11,551
And I'm wondering if you could talk a little bit about the

897
00:54:11,591 --> 00:54:15,574
process of how you test and evaluate those physics changes

898
00:54:15,614 --> 00:54:18,677
and net code changes, and how you decide what's too risky

899
00:54:18,797 --> 00:54:20,358
and might affect the competitive landscape.

900
00:54:20,899 --> 00:54:25,044
Yeah, so specifically the vehicle presets,

901
00:54:25,624 --> 00:54:27,587
we consider it a win because we have data

902
00:54:27,607 --> 00:54:29,088
on what cars people are using,

903
00:54:29,148 --> 00:54:30,770
and of course everyone's using Octane.

904
00:54:31,311 --> 00:54:34,074
So it was actually a big win because we were able

905
00:54:34,114 --> 00:54:36,838
to apply these physics presets to these cars

906
00:54:36,858 --> 00:54:39,421
that nobody was using, and now they're more playable.

907
00:54:39,441 --> 00:54:39,481
So.

908
00:54:40,742 --> 00:54:44,323
some people complained that okay my car drives a little differently but then once they try it

909
00:54:44,363 --> 00:54:48,344
out like oh wait it's actually better. So in that particular regard we weren't too concerned

910
00:54:48,364 --> 00:54:52,865
and we just kind of did it. Otherwise pretty much any time we make a physics change and this

911
00:54:52,925 --> 00:54:58,126
includes any kind of bug fix we do in physics, any kind of networking change with all the

912
00:54:58,186 --> 00:55:02,107
networking change we have coming out with this April 3rd patch, we always add an ability to

913
00:55:02,167 --> 00:55:08,469
dynamically turn it off from the back end. So every single feature that goes out, if

914
00:55:08,529 --> 00:55:10,149
something goes wrong after we deploy it.

915
00:55:10,669 --> 00:55:12,351
I mean, of course, we test it before we send it out.

916
00:55:12,632 --> 00:55:14,434
But if something goes wrong, which sometimes it does,

917
00:55:14,734 --> 00:55:17,658
we can just flip it off and then fix it and then deploy

918
00:55:17,678 --> 00:55:17,978
a patch.

919
00:55:19,020 --> 00:55:19,180
Cool.

920
00:55:19,400 --> 00:55:19,640
Thanks.

921
00:55:20,301 --> 00:55:22,544
I actually prefer the hybrid hitbox, but thanks.

922
00:55:23,305 --> 00:55:23,565
Sorry.

923
00:55:24,761 --> 00:55:28,705
Great talk, very clear slides, it's very easy to understand.

924
00:55:31,327 --> 00:55:37,053
At the risk of sounding lazy, since you guys started the development of this, have you

925
00:55:37,193 --> 00:55:40,756
run into any third party solutions that solve all of this for you?

926
00:55:41,577 --> 00:55:47,442
Solve all that for us? I have not seen anything. I haven't seen anybody else doing anything like

927
00:55:47,482 --> 00:55:54,328
this before. The only thing we've seen is third party solutions that claim to help your

928
00:55:54,888 --> 00:55:58,311
latency in general, which is definitely worth looking into, but that's pretty much it.

929
00:56:03,594 --> 00:56:09,820
Um, so you talked about how you can predict ball easily and that allows you to, uh, calculate

930
00:56:09,840 --> 00:56:15,525
the physics for player to ball collisions and that's, that sounded awesome. What do you do

931
00:56:15,565 --> 00:56:19,829
with like player to player collisions when they're not near a ball? Um, so for example if

932
00:56:19,849 --> 00:56:25,174
like I'm swerving really fast and on my client I see that I have avoided hitting player A.

933
00:56:26,493 --> 00:56:29,958
but because of flag or whatever it is on his client,

934
00:56:29,998 --> 00:56:32,461
it might seem that he's still at the first position

935
00:56:32,581 --> 00:56:33,482
and is hitting him.

936
00:56:34,063 --> 00:56:36,206
Do you run into issues surrounding that?

937
00:56:36,286 --> 00:56:37,208
How do you solve those?

938
00:56:37,445 --> 00:56:39,505
Were you asking about other players hitting the ball,

939
00:56:39,545 --> 00:56:40,506
or just simply other players?

940
00:56:40,686 --> 00:56:42,226
Other players interacting with other players.

941
00:56:42,246 --> 00:56:42,806
With other players?

942
00:56:42,987 --> 00:56:43,467
Yeah.

943
00:56:43,507 --> 00:56:45,467
We still run prediction on them, because if you don't,

944
00:56:45,507 --> 00:56:47,808
it's extremely hard to actually run into another player.

945
00:56:48,989 --> 00:56:50,049
There are desyncs issues.

946
00:56:50,249 --> 00:56:52,970
You'll think you hit a player, but then he'll just suck right

947
00:56:53,010 --> 00:56:54,030
back to where he was before.

948
00:56:55,391 --> 00:56:57,411
Luckily, it's not a core issue for our game,

949
00:56:57,451 --> 00:56:58,772
so it hasn't been a huge problem.

950
00:56:59,252 --> 00:57:01,073
But pretty much, we just run prediction,

951
00:57:01,313 --> 00:57:02,253
just like we do for the ball.

952
00:57:02,893 --> 00:57:05,314
And we decay the player inputs, as I mentioned

953
00:57:05,354 --> 00:57:06,254
with the previous question.

954
00:57:06,614 --> 00:57:07,115
That's pretty much it.

955
00:57:09,648 --> 00:57:12,729
me again. I was curious on the slide where you had, you know,

956
00:57:12,829 --> 00:57:15,770
we find that the client, because the client's in control of his

957
00:57:15,810 --> 00:57:18,071
own car, you know, that matches up with the server's

958
00:57:18,091 --> 00:57:24,193
understanding of the future or the past. And like, do you do

959
00:57:24,293 --> 00:57:28,254
any kind of diff when you're rerunning and re-simulating to

960
00:57:28,294 --> 00:57:32,055
know that like, okay, these objects are in sync and they

961
00:57:32,075 --> 00:57:34,196
continue to be in sync so we don't need to simulate that? Or

962
00:57:34,276 --> 00:57:37,016
is it just like a regular old simulation when you're playing

963
00:57:37,036 --> 00:57:37,277
it back?

964
00:57:39,508 --> 00:57:44,153
Do we do a diff between the server information coming in on the client or what the client

965
00:57:44,193 --> 00:57:44,914
had recorded?

966
00:57:45,154 --> 00:57:47,997
Well in other words when that matches up, right, like when the server and the client

967
00:57:48,057 --> 00:57:51,661
agree that they're both in the same position in a historical frame, does that mean you

968
00:57:51,721 --> 00:57:55,105
don't need to re-simulate that object or potentially you could interact with other things?

969
00:57:55,185 --> 00:58:04,754
Yes. So before we added quantization, we basically if a correction came in from the server

970
00:58:04,774 --> 00:58:08,898
and it was kind of close to what we had, we're not going to bother doing a correction. So if

971
00:58:08,918 --> 00:58:11,600
it's like just a few units off, that's close enough.

972
00:58:12,321 --> 00:58:17,263
After quantization, I haven't turned it on yet, but I might make it so that it has to be exact

973
00:58:17,343 --> 00:58:19,784
because we are now working with more exact units.

974
00:58:20,024 --> 00:58:24,947
But like per object, does that matter? In other words, if no correction is needed, then I understand.

975
00:58:25,187 --> 00:58:28,748
But if there is a correction being done, do you do it on all of the objects in the simulation

976
00:58:28,768 --> 00:58:30,049
or only the objects that disagree?

977
00:58:30,149 --> 00:58:34,071
We do it for all objects. So if the ball is miscorrected, we're going to rerun physics.

978
00:58:34,251 --> 00:58:37,072
We're going to warp everyone back and rerun physics for all the cards and the ball.

979
00:58:37,332 --> 00:58:38,253
Cool. Okay, thanks.

980
00:58:39,876 --> 00:58:44,981
Hi, thank you for the talk. So what kind of extra work you had to do on the physics system to

981
00:58:45,041 --> 00:58:53,229
achieve a deterministic simulation? Uh, was it to achieve the, I'm sorry to achieve what

982
00:58:53,249 --> 00:58:56,452
about the simulation? Deterministic simulation. Deterministic. Um,

983
00:58:58,033 --> 00:58:59,535
It was mostly deterministic.

984
00:58:59,595 --> 00:59:02,557
There were a few weird things that you wouldn't expect.

985
00:59:03,478 --> 00:59:10,023
There was an issue where if the ball hit two physics objects

986
00:59:10,243 --> 00:59:14,666
kind of at the same time, versus if it hit one on it first

987
00:59:14,706 --> 00:59:15,667
and then hit the other one.

988
00:59:15,687 --> 00:59:18,149
Let me clarify that.

989
00:59:19,810 --> 00:59:22,652
If the ball hits two different meshes,

990
00:59:22,712 --> 00:59:25,594
such as like a triangle mesh and then a plane,

991
00:59:26,417 --> 00:59:32,526
there is an issue where it gets added to the collision hash and then that the size of the

992
00:59:32,566 --> 00:59:35,009
collision hash is used later on to determine

993
00:59:36,222 --> 00:59:38,023
what order collisions are processed in.

994
00:59:38,343 --> 00:59:40,545
So depending on what order those things get added

995
00:59:40,585 --> 00:59:42,146
to the hash and the size of the hash,

996
00:59:42,466 --> 00:59:44,467
you could have things processed in different orders

997
00:59:44,827 --> 00:59:46,709
so you end up with non-deterministic results,

998
00:59:46,749 --> 00:59:49,471
sometimes surprisingly non-deterministic.

999
00:59:49,671 --> 00:59:51,852
The quick fix would have been to make the hash a fixed size,

1000
00:59:51,872 --> 00:59:52,553
but I didn't want to do that,

1001
00:59:52,593 --> 00:59:55,475
so we actually dived in and fixed the code to say,

1002
00:59:56,035 --> 00:59:58,356
if the ball is hitting these two things at the same time,

1003
00:59:59,177 --> 01:00:01,499
make sure that the order in which they're processed

1004
01:00:01,739 --> 01:00:02,980
produces the same results.

1005
01:00:03,840 --> 01:00:04,461
Other than that,

1006
01:00:06,261 --> 01:00:10,384
you want to make sure you turn off any randomization, some physics users use randomization so turn

1007
01:00:10,404 --> 01:00:17,449
that off. Yeah. Some optimization for the compiler right? For what? For the compiler, some

1008
01:00:17,509 --> 01:00:22,012
optimizations. I remember Glenn writing about it. No, I mean you're not going to get, especially

1009
01:00:22,052 --> 01:00:25,274
with being multi platform, they're all playable with each other. We're not going to get

1010
01:00:25,334 --> 01:00:28,896
perfect floating point simulation so that's why all the corrections and stuff, they're just

1011
01:00:28,916 --> 01:00:30,837
going to fix that up for us. Great, thank you.

1012
01:00:32,165 --> 01:00:35,530
I'm surprised you guys didn't run into bullet physics floating point errors because it's

1013
01:00:35,570 --> 01:00:35,971
full of them.

1014
01:00:36,852 --> 01:00:43,062
But my question is, I guess, so whenever you're running these kind of simulations where your

1015
01:00:43,082 --> 01:00:47,208
requirement is that whatever a player is driving has to be super responsive.

1016
01:00:47,928 --> 01:00:52,470
and there's latency involved and they can crash into each other you usually have some

1017
01:00:52,490 --> 01:00:56,251
form of desync like it's an unsolved problem essentially so do you guys do any kind of

1018
01:00:56,291 --> 01:01:00,592
tracking on seeing like hey how often are corrections happening in clients like do you

1019
01:01:00,632 --> 01:01:06,273
know like approximately what number percentage of interactions end up being some form of

1020
01:01:06,313 --> 01:01:10,815
a desync even if it's not something that human eye is going to catch as like a bad behavior.

1021
01:01:10,975 --> 01:01:13,816
Right, it's a metric that we actually, behind the scenes,

1022
01:01:14,257 --> 01:01:15,858
we report metrics of various things

1023
01:01:15,898 --> 01:01:16,838
from the game to the server.

1024
01:01:17,238 --> 01:01:19,259
We actually just flip it on with this latest patch

1025
01:01:19,279 --> 01:01:20,620
to actually track that sort of thing

1026
01:01:20,680 --> 01:01:23,862
so that we can, if a game is running poorly

1027
01:01:23,942 --> 01:01:26,684
or a server's running poorly, we can actually see like,

1028
01:01:26,704 --> 01:01:29,325
oh, this server's actually having larger corrections

1029
01:01:29,365 --> 01:01:30,786
happening on the client.

1030
01:01:30,806 --> 01:01:32,187
So it's something we just recently turned on,

1031
01:01:32,247 --> 01:01:33,468
probably should've turned on a long time ago.

1032
01:01:34,648 --> 01:01:37,290
Are you willing to share any numbers or?

1033
01:01:37,550 --> 01:01:39,131
Well, we don't have them flooding in yet.

1034
01:01:39,351 --> 01:01:40,391
It's not until the patch goes out.

1035
01:01:41,630 --> 01:01:41,851
Thank you.

1036
01:01:42,912 --> 01:01:43,273
OK.

1037
01:01:43,693 --> 01:01:46,077
Well, we'll be out in the overlook if anyone else has

1038
01:01:46,157 --> 01:01:46,818
any more questions.

1039
01:01:46,858 --> 01:01:48,160
Otherwise, thanks for coming out.

