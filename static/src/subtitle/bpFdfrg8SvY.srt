1
00:00:11,949 --> 00:00:12,930
My name is Nolan Carnahan.

2
00:00:13,130 --> 00:00:15,051
I'm an Engine and Graphics Programmer at Ember Lab,

3
00:00:15,111 --> 00:00:16,651
the studio that made Kane and Bridge of Spirits.

4
00:00:17,712 --> 00:00:20,253
And in this talk, I'm going to cover some of the VFX

5
00:00:20,293 --> 00:00:22,694
and tech art that went into realizing

6
00:00:22,734 --> 00:00:24,194
the dead zone restoration sequences

7
00:00:24,434 --> 00:00:25,915
and the round abilities in game.

8
00:00:28,256 --> 00:00:31,697
So for some context, Ember Lab is a small animation studio

9
00:00:31,757 --> 00:00:32,478
turned game studio.

10
00:00:33,388 --> 00:00:35,729
and Kena Bridge of Spirits was our first big game.

11
00:00:36,809 --> 00:00:38,890
The studio had previously worked on the effects

12
00:00:38,950 --> 00:00:40,230
for commercials and short films,

13
00:00:41,191 --> 00:00:43,392
but I imagine more of you would probably recognize

14
00:00:43,432 --> 00:00:44,992
the team's work on Terrible Fate,

15
00:00:45,392 --> 00:00:47,393
a Majora's Mask fan film that went viral

16
00:00:48,234 --> 00:00:49,334
apparently five years ago

17
00:00:49,414 --> 00:00:50,875
because time has no meaning at this point.

18
00:00:53,556 --> 00:00:55,596
That said, I personally joined the team to work on Kena,

19
00:00:56,016 --> 00:00:57,737
and while I certainly did a lot of work

20
00:00:57,777 --> 00:00:59,078
on the content I'll be presenting,

21
00:00:59,138 --> 00:01:00,838
I do want to stress that it was definitely a team effort

22
00:01:00,898 --> 00:01:01,178
across.

23
00:01:02,132 --> 00:01:04,013
art, programming, and design to arrive at where we did.

24
00:01:06,213 --> 00:01:07,694
So for anyone not familiar with the game,

25
00:01:07,894 --> 00:01:09,474
Cana Bridge of Spirits is a third-person

26
00:01:09,714 --> 00:01:11,755
action-adventure game featuring the spirit guide Cana

27
00:01:12,335 --> 00:01:14,975
and her fluffy round spirit companions called the Rot.

28
00:01:17,276 --> 00:01:19,216
Throughout the game, you come across this corruption

29
00:01:19,276 --> 00:01:20,757
covering the land that we called Dead Zone,

30
00:01:21,317 --> 00:01:22,937
which usually manifests in locations

31
00:01:23,017 --> 00:01:25,958
tied to lingering spirits struggling

32
00:01:25,978 --> 00:01:27,678
with some sort of tragedy from their past.

33
00:01:29,442 --> 00:01:31,543
In-universe, the Rot Spirits are a key component

34
00:01:31,563 --> 00:01:33,044
of the cycle of death and rebirth

35
00:01:33,484 --> 00:01:35,365
and can eat away the dead zone to restore balance.

36
00:01:37,307 --> 00:01:39,088
By using the Rot, Kena is able to destroy

37
00:01:39,108 --> 00:01:40,969
the dead zone hearts, the source of the corruption.

38
00:01:41,489 --> 00:01:43,290
And upon doing so, the player is rewarded

39
00:01:43,410 --> 00:01:44,971
with the restoration of the environment.

40
00:01:45,532 --> 00:01:47,393
We call these sequences dead zone clears.

41
00:01:48,434 --> 00:01:49,894
And in this talk, we'll discuss the goals

42
00:01:49,914 --> 00:01:51,475
that we had established for these dead zone clears,

43
00:01:51,936 --> 00:01:53,557
showcase some of our earlier prototypes,

44
00:01:54,137 --> 00:01:56,459
and break down the different layers of VFX and tech art

45
00:01:56,479 --> 00:01:57,079
that went into.

46
00:01:58,468 --> 00:02:00,229
achieving our visual and storytelling goals,

47
00:02:00,349 --> 00:02:02,390
and then finally share some concluding thoughts

48
00:02:02,650 --> 00:02:03,590
and some lessons learned.

49
00:02:05,871 --> 00:02:06,811
So starting from the goals,

50
00:02:07,452 --> 00:02:08,452
we first wanted the dead zones

51
00:02:08,492 --> 00:02:09,913
to feel threatening to the player,

52
00:02:10,553 --> 00:02:12,434
in harsh contrast to the inviting nature

53
00:02:12,454 --> 00:02:13,274
of the rest of the world.

54
00:02:14,394 --> 00:02:16,655
The spaces should not only be filled with spiky roots

55
00:02:16,715 --> 00:02:18,716
and boldest growths and thick fog,

56
00:02:19,236 --> 00:02:21,257
but the transition back to the healed version of the forest

57
00:02:21,337 --> 00:02:23,018
should be obvious and noticeable.

58
00:02:24,478 --> 00:02:26,120
We also wanted these dead zone clear transitions

59
00:02:26,160 --> 00:02:28,101
to take place in real time as much as possible.

60
00:02:28,701 --> 00:02:30,262
The transitions in some of our prototypes

61
00:02:30,382 --> 00:02:32,944
hit a lot of environmental changes behind cut scenes,

62
00:02:33,565 --> 00:02:35,866
which felt somewhat disconnected from the player's actions.

63
00:02:36,507 --> 00:02:38,808
Bringing it closer to the gameplay makes it more fun to do

64
00:02:38,828 --> 00:02:41,570
and it makes the player want to do it over and over again.

65
00:02:42,891 --> 00:02:44,872
And finally, since the Rot Spirit companions

66
00:02:44,912 --> 00:02:46,794
are such a key component to fighting back the dead zone,

67
00:02:47,254 --> 00:02:50,877
we wanted to make sure that the VFX feedback

68
00:02:50,957 --> 00:02:52,618
reinforced their place in the story.

69
00:02:56,756 --> 00:03:00,720
As Kena has access to a variety of rot-powered special abilities,

70
00:03:01,380 --> 00:03:03,763
we wanted those abilities to have a smaller scale version

71
00:03:04,243 --> 00:03:06,826
of the cleaning feedback scene in the dead zone clear sequences as well.

72
00:03:09,428 --> 00:03:11,750
So these prototypes showcase an early version of Dead Zone,

73
00:03:12,671 --> 00:03:14,753
one with larger spaces packed full of corruption,

74
00:03:15,193 --> 00:03:16,775
tall enough to physically block the player.

75
00:03:18,116 --> 00:03:19,798
However, this vision wound up changing over time

76
00:03:19,818 --> 00:03:21,680
because of both art and design considerations.

77
00:03:22,569 --> 00:03:24,330
In this early version, the player could throw bait

78
00:03:24,371 --> 00:03:26,533
to attract the rot or move them around directly,

79
00:03:26,753 --> 00:03:28,575
like the rot cloud in the shipped version of the game.

80
00:03:29,336 --> 00:03:31,358
This version is obviously quite crude,

81
00:03:32,279 --> 00:03:33,501
lacking any sort of feedback

82
00:03:33,541 --> 00:03:35,563
when the larger dead zone clumps are getting destroyed.

83
00:03:38,086 --> 00:03:39,828
This later prototype used a render target

84
00:03:39,868 --> 00:03:41,690
to mask out areas that were cleaned by the rot,

85
00:03:42,130 --> 00:03:43,792
which is then sampled by other materials.

86
00:03:44,455 --> 00:03:47,057
The cleaning of the landscape material was somewhat successful

87
00:03:47,197 --> 00:03:48,759
and closely resembles what we shipped.

88
00:03:49,459 --> 00:03:51,821
However, these larger dead zone clumps push their vertices

89
00:03:51,901 --> 00:03:52,842
down into the terrain,

90
00:03:53,482 --> 00:03:55,624
which causes a lot of weird visual artifacts

91
00:03:55,644 --> 00:03:57,505
when the player is slicing through the middle of a mesh.

92
00:03:59,547 --> 00:04:01,549
In addition to the visuals, we had a couple other problems

93
00:04:01,569 --> 00:04:02,169
with this version.

94
00:04:02,850 --> 00:04:04,731
The meshes need to be very high poly

95
00:04:04,791 --> 00:04:06,212
in order to support this deformation,

96
00:04:07,573 --> 00:04:09,214
and LOD popping would be exacerbated

97
00:04:09,254 --> 00:04:10,235
when you're cutting into a mesh.

98
00:04:11,944 --> 00:04:17,830
Handling collision was also very challenging as we did not want to dynamically adjust the collision based on which parts of the model were cleaned.

99
00:04:18,871 --> 00:04:25,157
And instead we just wound up disabling collision and we made the player take damage when they walked through it, which didn't look very good either.

100
00:04:26,498 --> 00:04:36,848
As these collision issues also caused problems for navmesh generation and other things of the like, we wound up going away from this approach to ensure that the combat worked well in these spaces.

101
00:04:39,650 --> 00:04:40,851
In this last bit of prototype footage,

102
00:04:40,871 --> 00:04:42,832
you can see how a prototype dead zone clear

103
00:04:43,452 --> 00:04:45,713
was not yet accomplished in real time.

104
00:04:46,054 --> 00:04:47,875
You might notice that these blue and purple flowers

105
00:04:48,235 --> 00:04:50,136
only appear after the camera cuts to black.

106
00:04:51,117 --> 00:04:52,898
This flower growing in during the cut scene

107
00:04:53,018 --> 00:04:55,679
is meant to incept the idea in the player's mind

108
00:04:55,739 --> 00:04:56,720
that the plants grew back in,

109
00:04:57,040 --> 00:04:58,961
but it's not quite the same as seeing it actually happen

110
00:04:58,981 --> 00:04:59,621
during gameplay.

111
00:05:02,543 --> 00:05:04,144
So next I'm going to talk about how we built

112
00:05:04,164 --> 00:05:06,145
the final version of the dead zones in engine.

113
00:05:06,914 --> 00:05:10,057
There are roughly four layers or ingredients involved,

114
00:05:10,197 --> 00:05:11,858
and each of them uses different solutions

115
00:05:11,998 --> 00:05:13,319
to solve their unique problems.

116
00:05:14,400 --> 00:05:17,042
The first is the landscape, the base layer of the terrain.

117
00:05:17,883 --> 00:05:19,444
And then after that, I'll cover the foliage

118
00:05:19,544 --> 00:05:21,346
and how it builds on how the landscape is cleaned.

119
00:05:22,807 --> 00:05:24,348
And next, I'll cover the improvements that we made

120
00:05:24,368 --> 00:05:26,050
to how we handled larger dead zone meshes.

121
00:05:27,371 --> 00:05:29,132
And finally, I'll cover the systems that we built

122
00:05:29,172 --> 00:05:30,634
to drive lighting and ambience

123
00:05:30,654 --> 00:05:31,995
when the player is in the dead zones

124
00:05:32,275 --> 00:05:34,897
and how we turn them off during the clear sequences.

125
00:05:36,556 --> 00:05:38,277
So I'll now go over each of these layers in detail

126
00:05:38,417 --> 00:05:39,738
and show how they all work together.

127
00:05:41,720 --> 00:05:43,961
Our landscape material supports two additive layers

128
00:05:43,981 --> 00:05:46,103
that can be painted on top of the underlying material.

129
00:05:46,983 --> 00:05:49,245
In Unreal, this requires checking the no weight blend

130
00:05:49,365 --> 00:05:51,286
checkbox on the landscape layer info.

131
00:05:52,827 --> 00:05:55,029
The first is a dead mask that just

132
00:05:55,069 --> 00:05:56,950
makes the underlying material appear dead.

133
00:05:58,071 --> 00:05:59,472
And the second is a harmful variant

134
00:05:59,492 --> 00:06:01,093
of the dead zone that slows the player down

135
00:06:01,553 --> 00:06:03,515
and will kill them if they stand in it for too long.

136
00:06:04,516 --> 00:06:05,036
The dead mask.

137
00:06:05,547 --> 00:06:07,108
tints and desaturates the base color

138
00:06:07,688 --> 00:06:10,269
and makes the material appear a little bit glossier

139
00:06:10,309 --> 00:06:11,389
by modifying the roughness.

140
00:06:12,270 --> 00:06:14,411
And on the other hand, that harmful dead zone one

141
00:06:14,671 --> 00:06:16,071
layers a different tiling material

142
00:06:16,171 --> 00:06:17,992
on top of the underlying material,

143
00:06:18,352 --> 00:06:20,773
which makes the border between the two a little bit more clear.

144
00:06:22,514 --> 00:06:24,474
This layer also modifies the physics material

145
00:06:24,975 --> 00:06:27,776
so that we can detect when the player is standing on top of it.

146
00:06:31,057 --> 00:06:32,417
So to implement the cleaning effect,

147
00:06:32,537 --> 00:06:34,918
we have gameplay objects right to a top-down.

148
00:06:35,652 --> 00:06:37,733
render target that is centered on the player's location.

149
00:06:38,694 --> 00:06:41,275
The red channel of this texture encodes the clean state.

150
00:06:41,836 --> 00:06:44,277
So for example, when the player destroys a dead zone heart,

151
00:06:44,737 --> 00:06:46,798
a circular shape extends outward

152
00:06:47,259 --> 00:06:48,960
and marks different areas as being cleaned.

153
00:06:49,620 --> 00:06:52,261
The material uses pixels world space position

154
00:06:52,722 --> 00:06:53,942
to compute the correct location

155
00:06:53,962 --> 00:06:55,283
at which to sample from this texture.

156
00:06:55,984 --> 00:06:58,005
And the value that is sampled is used to fade off

157
00:06:58,445 --> 00:06:59,986
both of the additive dead zone layers

158
00:07:00,046 --> 00:07:01,186
on the landscape material.

159
00:07:02,922 --> 00:07:04,643
Since the landscape can be visible from afar,

160
00:07:05,243 --> 00:07:07,364
we actually have two render targets set up

161
00:07:07,404 --> 00:07:09,225
in a similar manner to cascading shadow maps.

162
00:07:09,945 --> 00:07:11,446
One render target of higher resolution

163
00:07:11,506 --> 00:07:15,868
covers the area immediately surrounding the player,

164
00:07:16,368 --> 00:07:18,249
and a second lower resolution render target

165
00:07:18,269 --> 00:07:19,549
covers a much larger area,

166
00:07:19,789 --> 00:07:22,531
which allows us to have dead zone appear being cleaned,

167
00:07:22,731 --> 00:07:23,711
even from very far away.

168
00:07:25,372 --> 00:07:26,632
Just like in cascaded shadow maps,

169
00:07:26,672 --> 00:07:30,254
we also ensure that the render target

170
00:07:30,294 --> 00:07:31,855
is snapped to the nearest texel.

171
00:07:32,535 --> 00:07:34,296
so we don't have any weird sampling artifacts

172
00:07:34,316 --> 00:07:36,817
from it smoothly interpolating between

173
00:07:36,837 --> 00:07:39,379
when you're moving small distances.

174
00:07:41,420 --> 00:07:43,141
There are a couple of limitations with this approach.

175
00:07:43,722 --> 00:07:46,263
One of the obvious ones is that the render target is top down,

176
00:07:46,363 --> 00:07:49,165
so we can't have dead zones layered on top of each other,

177
00:07:49,645 --> 00:07:51,847
but this didn't really wind up being a problem in practice.

178
00:07:53,328 --> 00:07:55,549
This also only supports cleaning dead zone.

179
00:07:56,189 --> 00:07:59,491
So while we thought that dynamically authoring dead zone

180
00:07:59,992 --> 00:08:01,673
might be interesting from a gameplay perspective,

181
00:08:02,173 --> 00:08:03,975
we didn't wind up actually pursuing that.

182
00:08:05,636 --> 00:08:06,857
So yeah, just above the landscape,

183
00:08:06,877 --> 00:08:09,358
we have ground cover meshes like our grass, clovers,

184
00:08:09,398 --> 00:08:11,079
and flowers, which add depth to the terrain

185
00:08:11,120 --> 00:08:12,580
as well as other larger plants,

186
00:08:14,061 --> 00:08:15,462
like ferns and some other stuff.

187
00:08:17,104 --> 00:08:19,005
We use Unreal's built-in instance foliage system

188
00:08:19,165 --> 00:08:20,646
to place and render these assets.

189
00:08:21,727 --> 00:08:23,488
For assets that need to be used in the dead zones,

190
00:08:23,768 --> 00:08:25,649
we set up two foliage types for each plant,

191
00:08:26,430 --> 00:08:28,591
both a clean version and a dead zone version.

192
00:08:29,032 --> 00:08:30,933
And we use the appropriate version when doing level dressing.

193
00:08:31,547 --> 00:08:34,887
So if the artist is placing Assets on top of somewhere

194
00:08:34,907 --> 00:08:36,728
where they painted Dead Zone on the landscape,

195
00:08:36,868 --> 00:08:38,848
they would make sure that they place the Dead Zone versions

196
00:08:38,888 --> 00:08:40,928
of the Assets instead.

197
00:08:42,389 --> 00:08:44,769
And so obviously, we also need two sets of Materials as well,

198
00:08:45,589 --> 00:08:48,530
and the Dead Zone Foliage Types have different Materials

199
00:08:48,570 --> 00:08:50,090
assigned that support being cleaned.

200
00:08:51,511 --> 00:08:53,571
Having two sets of Foliage Types and Materials

201
00:08:53,771 --> 00:08:55,811
did lead to some minor issues, like keeping both of these

202
00:08:55,952 --> 00:08:57,832
in sync when we were making changes

203
00:08:57,872 --> 00:08:59,092
to things like Material parameters.

204
00:09:00,017 --> 00:09:01,858
But ultimately, I think this wound up being the right call.

205
00:09:03,018 --> 00:09:05,018
We had tried out using a single foliage type

206
00:09:05,038 --> 00:09:06,518
that could detect when it was in dead zone,

207
00:09:06,918 --> 00:09:08,439
but that added additional complexity

208
00:09:08,499 --> 00:09:12,439
around detecting what landscape layers were below the mesh,

209
00:09:13,119 --> 00:09:15,100
which is not super easy to do out of the box.

210
00:09:16,100 --> 00:09:18,160
It also increased the shader complexity for every mesh,

211
00:09:18,280 --> 00:09:20,701
even though most meshes were not going to be transitioning

212
00:09:22,021 --> 00:09:24,361
from cleaned to dead zone.

213
00:09:24,501 --> 00:09:26,342
Given the asset density that we were targeting,

214
00:09:26,762 --> 00:09:28,302
it did not really seem to be a trade-off

215
00:09:28,322 --> 00:09:29,042
that was worth making.

216
00:09:32,238 --> 00:09:33,920
So these foliage types are generally cleaned

217
00:09:33,960 --> 00:09:34,901
the same way as the terrain,

218
00:09:35,421 --> 00:09:36,982
by sampling from the red channel

219
00:09:37,022 --> 00:09:39,525
in that cleaning render target that I mentioned earlier.

220
00:09:40,365 --> 00:09:41,987
And they use that value to lerp colors

221
00:09:42,127 --> 00:09:44,028
and other Material parameters.

222
00:09:45,650 --> 00:09:48,372
You might also notice that some dead zone plants scale down

223
00:09:48,432 --> 00:09:49,513
and disappear when cleaned.

224
00:09:50,234 --> 00:09:52,596
This is handled by scaling the mesh in the vertex shader

225
00:09:53,056 --> 00:09:55,959
based on that same value sampled by the Texture,

226
00:09:55,979 --> 00:09:58,241
or sampled from the Texture, I should say.

227
00:09:59,212 --> 00:10:00,673
This does leave us with a problem, though,

228
00:10:00,793 --> 00:10:03,275
in that if we remove a lot of dead zone versions of plants,

229
00:10:03,856 --> 00:10:06,338
we are left with bare patches of the landscape exposed.

230
00:10:07,959 --> 00:10:10,541
So we solved this problem by having other plants grow back in

231
00:10:10,922 --> 00:10:12,243
and fill in those bare spots.

232
00:10:13,564 --> 00:10:15,785
Certain Materials actually start with a scale of zero,

233
00:10:15,886 --> 00:10:18,768
and they scale up instead, based on the value

234
00:10:18,928 --> 00:10:21,190
sampled from this time, the blue channel,

235
00:10:21,490 --> 00:10:22,411
instead of the red channel.

236
00:10:23,712 --> 00:10:25,453
One big reason that we separated these

237
00:10:25,473 --> 00:10:26,414
into two separate channels,

238
00:10:26,984 --> 00:10:29,925
is we want the flowers and other plants to grow in a little bit

239
00:10:29,985 --> 00:10:32,566
delayed relative to when the dead zone gets cleaned.

240
00:10:33,366 --> 00:10:35,046
So having them separated into two channels

241
00:10:35,487 --> 00:10:37,427
allows the viewer to take them in as two separate events,

242
00:10:37,947 --> 00:10:40,208
and it makes everything feel a little bit less in sync.

243
00:10:42,089 --> 00:10:44,269
Adding this wound up being a big win from an art direction

244
00:10:44,309 --> 00:10:48,130
perspective as well, as it enabled the artist to dress

245
00:10:48,310 --> 00:10:52,111
spaces with vibrant plants and large flowers that would not

246
00:10:52,512 --> 00:10:54,032
look correct in a dead zone space,

247
00:10:54,672 --> 00:10:56,613
even if we did desaturate the colors.

248
00:10:58,045 --> 00:11:00,267
So whenever the dead zone clear occurs,

249
00:11:00,687 --> 00:11:02,088
all of these plants rush back in,

250
00:11:02,308 --> 00:11:03,449
and they fill the space with life.

251
00:11:04,090 --> 00:11:06,071
This also allowed us to stop loading in levels

252
00:11:06,111 --> 00:11:08,754
to bring in Assets and have it all occur in real time.

253
00:11:11,015 --> 00:11:12,957
One obvious drawback of scaling foliage like this

254
00:11:13,758 --> 00:11:16,200
in the vertex shader is that there are locations

255
00:11:16,240 --> 00:11:18,902
where we have two versions of plants in the same area.

256
00:11:19,102 --> 00:11:20,663
We have dead zone plants that scale down,

257
00:11:20,904 --> 00:11:23,566
and we have the plants that grow back in,

258
00:11:24,306 --> 00:11:25,908
and they scale back on top of those ones.

259
00:11:28,436 --> 00:11:31,558
To optimize this, we could have theoretically written some code

260
00:11:31,598 --> 00:11:35,860
to modify the instance foliage system

261
00:11:36,460 --> 00:11:39,542
and have some code that tries to call out zero scale instances

262
00:11:39,582 --> 00:11:40,322
or something like that,

263
00:11:40,943 --> 00:11:43,764
but we did not actually have the time to make any big changes.

264
00:11:44,264 --> 00:11:46,826
So instead, we just made sure that we did not go overboard

265
00:11:47,206 --> 00:11:47,806
with this effect.

266
00:11:49,247 --> 00:11:51,588
At least any of the zero scale instances,

267
00:11:52,268 --> 00:11:54,089
all of the triangles that are generated from them

268
00:11:54,149 --> 00:11:54,970
have zero area,

269
00:11:55,370 --> 00:11:57,251
and so they at least get called during rasterization.

270
00:12:00,253 --> 00:12:02,315
And then one final bit of visual polish on the ground cover

271
00:12:02,415 --> 00:12:04,837
assets is what we call overgrowth.

272
00:12:05,797 --> 00:12:07,518
The green channel in the cleaning render target

273
00:12:07,538 --> 00:12:11,421
encodes an additional value that we use to temporarily saturate

274
00:12:11,461 --> 00:12:13,823
colors and scale up plants beyond their normal size.

275
00:12:14,783 --> 00:12:16,144
You can see this effect take place

276
00:12:16,704 --> 00:12:18,085
when destroying a dead zone heart

277
00:12:18,686 --> 00:12:21,268
or removing the rot in the rot cloud form through the grass.

278
00:12:22,688 --> 00:12:24,490
This effect provides some additional bounce

279
00:12:24,550 --> 00:12:25,390
during dead zone clears.

280
00:12:25,851 --> 00:12:28,172
It makes everything just feel a little bit more animated.

281
00:12:31,060 --> 00:12:33,322
And finally, you can see all of this work on the foliage shaders

282
00:12:33,362 --> 00:12:35,384
come together in the context of a dead zone clear.

283
00:12:36,465 --> 00:12:38,527
It is easier, I think, to see it in the viewport

284
00:12:38,607 --> 00:12:40,168
rather than the debug render target view,

285
00:12:40,769 --> 00:12:43,271
but the blue channel is slightly delayed to the red channel.

286
00:12:43,711 --> 00:12:46,054
So you might notice that the flowers grow in a little bit

287
00:12:46,154 --> 00:12:47,855
after all of the grass turns green.

288
00:12:49,857 --> 00:12:51,559
Also note that the green overgrowth channel

289
00:12:51,699 --> 00:12:54,121
is the only one that does not stick around after the clear.

290
00:12:54,281 --> 00:12:55,342
That effect is temporary.

291
00:12:57,618 --> 00:12:59,580
The next ingredient is the larger dead zone meshes

292
00:12:59,640 --> 00:13:00,120
in the space.

293
00:13:00,421 --> 00:13:03,484
This includes the bulbous, gnarled dead zone pods,

294
00:13:04,085 --> 00:13:08,009
but also trees with some larger dead zone growth sprouting out

295
00:13:08,029 --> 00:13:08,249
of them.

296
00:13:09,810 --> 00:13:11,672
These larger meshes are great at blocking progression

297
00:13:11,692 --> 00:13:14,195
through a space, and they help sell the idea

298
00:13:14,235 --> 00:13:15,536
that the dead zone is taking over.

299
00:13:16,477 --> 00:13:17,819
Whenever a dead zone clear occurs,

300
00:13:18,019 --> 00:13:19,521
these meshes dissolve out, allowing

301
00:13:19,541 --> 00:13:20,461
the player to get past them.

302
00:13:22,775 --> 00:13:25,396
These meshes are actually Blueprints rather than

303
00:13:25,496 --> 00:13:26,217
instance foliage.

304
00:13:26,857 --> 00:13:28,117
A big reason for that is we did not

305
00:13:28,197 --> 00:13:29,638
want to use the cleaning render target,

306
00:13:30,778 --> 00:13:32,199
since we would run into the same issue

307
00:13:32,239 --> 00:13:34,660
that we had with the prototypes, where things would be,

308
00:13:34,980 --> 00:13:36,561
we would just be cutting through the middle of a mesh

309
00:13:37,501 --> 00:13:38,781
whenever those effects were going off.

310
00:13:40,142 --> 00:13:43,443
And another problem is that during the dead zone clear,

311
00:13:43,463 --> 00:13:45,644
the cleaning effect moves out so quickly

312
00:13:46,084 --> 00:13:47,885
that it would wipe over the larger assets

313
00:13:47,985 --> 00:13:50,766
in a fraction of a second, which wouldn't look good either.

314
00:13:52,043 --> 00:13:53,764
So instead, what we do is we dissolve out

315
00:13:53,804 --> 00:13:55,845
all of these assets on their own timeline.

316
00:13:56,365 --> 00:13:58,666
By giving them more time, the player actually has a chance

317
00:13:58,706 --> 00:13:59,566
to take all of this in.

318
00:14:01,807 --> 00:14:03,468
Compared to the prototype version where the meshes

319
00:14:03,508 --> 00:14:05,709
could be either, could be partially cleaned,

320
00:14:06,169 --> 00:14:08,350
these meshes are binary.

321
00:14:08,390 --> 00:14:09,651
They're either cleaned or not.

322
00:14:10,771 --> 00:14:12,692
So that makes it easy to disable collision

323
00:14:12,732 --> 00:14:13,572
on these when they're cleaned.

324
00:14:15,053 --> 00:14:16,454
To make the dissolve still feel connected

325
00:14:16,494 --> 00:14:17,634
to the dead zone hearth's destruction,

326
00:14:18,125 --> 00:14:19,866
We built a tool to adjust the time

327
00:14:20,706 --> 00:14:23,727
that it takes for each one to start dissolving out.

328
00:14:24,527 --> 00:14:28,489
So what happens is when the dead zone cleaning effect goes out,

329
00:14:28,889 --> 00:14:30,489
these meshes are not dissolved by the time

330
00:14:30,629 --> 00:14:32,130
the cleaning effect reaches them,

331
00:14:32,590 --> 00:14:34,091
but rather they start dissolving out

332
00:14:34,131 --> 00:14:36,331
when the dead zone clear hits them.

333
00:14:37,612 --> 00:14:40,033
And that gives them enough time to sort of be spaced out,

334
00:14:40,353 --> 00:14:42,593
and they just dissolve out on their own timeline,

335
00:14:43,134 --> 00:14:45,954
and they can take however long they need in order

336
00:14:45,974 --> 00:14:46,615
for it to look good.

337
00:14:49,027 --> 00:14:51,269
The dissolve in the shader is a pretty typical noise-based

338
00:14:51,369 --> 00:14:52,550
dissolve that brightens the edges

339
00:14:52,590 --> 00:14:53,551
to cover up the transition.

340
00:14:53,571 --> 00:14:56,193
A lot of the assets also spawn particle effects,

341
00:14:56,453 --> 00:14:58,475
like little splashes and snapping roots

342
00:14:58,515 --> 00:15:00,858
and a little bit of distortion to help cover stuff up.

343
00:15:02,559 --> 00:15:04,121
Some assets like trees also lurp

344
00:15:04,241 --> 00:15:05,882
between two separate diffuse textures,

345
00:15:06,042 --> 00:15:08,124
which just gives us a little bit more texture variation.

346
00:15:08,805 --> 00:15:10,927
You might notice that there's a little bit of moss

347
00:15:10,967 --> 00:15:12,428
growing back here on the tree.

348
00:15:13,937 --> 00:15:15,838
And note that for the handful of assets like trees

349
00:15:15,878 --> 00:15:17,078
that stick around after the clear,

350
00:15:17,518 --> 00:15:22,639
we don't actually disable collision on those as well.

351
00:15:22,699 --> 00:15:25,020
So as with most things that are Blueprint adjacent,

352
00:15:25,380 --> 00:15:27,060
we did run into some performance problems

353
00:15:27,480 --> 00:15:28,861
with our initial setup for these assets.

354
00:15:30,261 --> 00:15:31,561
We had originally set up these Blueprints

355
00:15:31,701 --> 00:15:33,422
using dynamic material instances

356
00:15:33,942 --> 00:15:35,982
to allow tweening the dissolve parameters per instance,

357
00:15:36,263 --> 00:15:38,483
but we moved away from that since it breaks instancing.

358
00:15:39,503 --> 00:15:42,304
Since version 4.22, Unreal automatically instances

359
00:15:42,344 --> 00:15:42,764
draw caps.

360
00:15:43,003 --> 00:15:45,405
draw calls that share the same mesh and materials,

361
00:15:45,966 --> 00:15:47,767
which can significantly reduce the amount of draw calls

362
00:15:47,787 --> 00:15:48,948
that get submitted to the GPU.

363
00:15:50,529 --> 00:15:52,731
But since dynamic material instances

364
00:15:52,771 --> 00:15:53,751
can have different values

365
00:15:54,292 --> 00:15:55,593
for their different shader parameters,

366
00:15:56,113 --> 00:15:58,035
they need to be rendered as separate draw calls.

367
00:16:00,657 --> 00:16:03,198
The other problem is that it's expensive on the CPU side

368
00:16:03,659 --> 00:16:05,400
to update a lot of material parameters.

369
00:16:06,581 --> 00:16:08,883
The default interface for updating material parameters

370
00:16:08,943 --> 00:16:10,524
involves looking up the parameters by name,

371
00:16:10,964 --> 00:16:12,505
which involves a lot of string comparisons.

372
00:16:13,227 --> 00:16:15,248
This was especially bad during level streaming,

373
00:16:15,828 --> 00:16:17,809
because we would wind up updating a few parameters

374
00:16:18,030 --> 00:16:19,550
on hundreds of dead zone Blueprints.

375
00:16:20,851 --> 00:16:22,672
And on some of our levels, we were paying something

376
00:16:22,712 --> 00:16:24,033
like 30 milliseconds

377
00:16:24,233 --> 00:16:26,114
just to create the dynamic material instances

378
00:16:26,435 --> 00:16:28,956
and update all of the parameters on these assets

379
00:16:29,537 --> 00:16:30,997
just so they could get into the correct state

380
00:16:31,098 --> 00:16:31,758
on the level load.

381
00:16:33,479 --> 00:16:35,220
So to solve these problems, we switched to using

382
00:16:35,240 --> 00:16:37,121
an Unreal feature called Custom Primitive Data.

383
00:16:37,884 --> 00:16:40,846
Custom primitive data gives you access to 32 floating point

384
00:16:40,886 --> 00:16:43,987
numbers on a per primitive level that can be modified just

385
00:16:44,047 --> 00:16:45,368
like material parameters.

386
00:16:46,048 --> 00:16:49,110
But it does not require you to make dynamic material instances

387
00:16:49,690 --> 00:16:52,232
just to set these values on a per primitive basis,

388
00:16:52,652 --> 00:16:54,133
or a per instance basis.

389
00:16:56,854 --> 00:16:58,595
So as you can see in these images

390
00:16:58,635 --> 00:17:00,796
that I stole from the Unreal documentation page,

391
00:17:02,077 --> 00:17:03,958
in the shader, instead of reading the parameter value

392
00:17:03,998 --> 00:17:06,740
by name, you instead index into that float array.

393
00:17:08,282 --> 00:17:10,264
So you just specify the number of the index

394
00:17:10,284 --> 00:17:11,305
that you want to use instead.

395
00:17:12,907 --> 00:17:14,368
Since a lot of our shader parameters

396
00:17:14,408 --> 00:17:16,490
are actually exposed from material functions

397
00:17:16,730 --> 00:17:20,013
and not the material itself, we set aside,

398
00:17:20,794 --> 00:17:23,596
we set up like a convention to set aside specific indices

399
00:17:23,636 --> 00:17:26,319
to be used for certain effects.

400
00:17:27,039 --> 00:17:29,262
So that would allow us to avoid any conflicts

401
00:17:29,402 --> 00:17:31,444
if you just drop in random material functions

402
00:17:32,124 --> 00:17:32,945
into different materials.

403
00:17:34,026 --> 00:17:34,606
So for example,

404
00:17:35,502 --> 00:17:38,763
Index 0 might be always set aside to store the dissolve amount,

405
00:17:39,083 --> 00:17:43,205
or index 1 might be set aside to always store a desaturation value

406
00:17:43,265 --> 00:17:43,945
or something like that.

407
00:17:45,866 --> 00:17:48,306
So since we don't need dynamic material instances anymore,

408
00:17:48,767 --> 00:17:51,768
the renderer is able to instance all of these dead zone meshes.

409
00:17:53,408 --> 00:17:57,490
And another thing that is also a benefit is that since the parameters

410
00:17:57,550 --> 00:17:59,551
are referenced by index instead of by name,

411
00:18:00,571 --> 00:18:03,252
updating these values on the CPU side is a lot easier

412
00:18:03,272 --> 00:18:04,873
because we avoid all of those string comparisons.

413
00:18:06,589 --> 00:18:08,590
Custom primitive data does have some drawbacks though.

414
00:18:09,450 --> 00:18:14,071
One big one is that it is a per primitive setting.

415
00:18:15,512 --> 00:18:17,833
And that means that if you have multiple materials

416
00:18:17,873 --> 00:18:20,233
on the same mesh and you want them to have different,

417
00:18:21,654 --> 00:18:23,814
different values for their shader parameters,

418
00:18:24,835 --> 00:18:26,255
you won't be able to do that.

419
00:18:26,915 --> 00:18:30,256
So in our cases, whenever we ran into that,

420
00:18:30,616 --> 00:18:32,137
we wound up just falling back to using

421
00:18:32,657 --> 00:18:35,158
dynamic material instances for those meshes.

422
00:18:38,417 --> 00:18:40,158
So the final key component to the dead zone

423
00:18:40,298 --> 00:18:41,479
is the lighting and ambience.

424
00:18:43,039 --> 00:18:44,800
All of the lighting in Kena is real time,

425
00:18:45,140 --> 00:18:47,541
which gave us the ability to finely tune

426
00:18:47,561 --> 00:18:50,883
the look of each area in the game, including the dead zones.

427
00:18:52,443 --> 00:18:54,284
Lighting artists control the lighting in different regions

428
00:18:54,364 --> 00:18:56,125
by using custom post-process volumes.

429
00:18:56,765 --> 00:18:59,106
Similar to the built-in Unreal post-process volumes,

430
00:18:59,506 --> 00:19:01,487
our volumes drive the lighting and fog parameters

431
00:19:02,048 --> 00:19:04,449
based on the camera location, fading in the values

432
00:19:04,529 --> 00:19:05,489
as the camera gets closer.

433
00:19:06,947 --> 00:19:09,468
Artists can modify a variety of properties like sun

434
00:19:09,568 --> 00:19:11,589
or skylight intensity or fog density,

435
00:19:12,410 --> 00:19:14,611
and plenty of the other in-depth parameters

436
00:19:14,631 --> 00:19:16,932
that get exposed on the light and fog components

437
00:19:17,272 --> 00:19:19,053
so that they can finely tune the look of the space.

438
00:19:21,474 --> 00:19:22,875
Similar to post-process volumes,

439
00:19:22,955 --> 00:19:24,755
all of the parameter overrides are optional,

440
00:19:25,176 --> 00:19:27,437
so a volume only needs to specify a value for things

441
00:19:27,457 --> 00:19:28,677
that it actually wants to override.

442
00:19:30,276 --> 00:19:32,196
For dead zones in particular, we generally just

443
00:19:32,216 --> 00:19:34,737
decrease the sun intensity, increase the fog density,

444
00:19:35,337 --> 00:19:37,098
and bring in a little bit of chromatic aberration.

445
00:19:38,958 --> 00:19:40,939
And all of these parameters are not actually stored

446
00:19:41,179 --> 00:19:43,619
on the volumes themselves, but we store them

447
00:19:43,639 --> 00:19:45,580
in data asset configuration files.

448
00:19:47,640 --> 00:19:49,361
Swapping out the configs in the editor

449
00:19:50,401 --> 00:19:52,242
is a very easy thing to do, and it can be a great way

450
00:19:52,282 --> 00:19:54,602
to find a config that is close to what you're

451
00:19:54,622 --> 00:19:56,743
looking for when you're setting up the lighting in a space.

452
00:19:57,947 --> 00:19:59,867
Another benefit of having the lighting configs

453
00:19:59,927 --> 00:20:02,669
as separate files is that it avoids a lot of the source

454
00:20:02,709 --> 00:20:06,570
control conflicts where people would run into issues having

455
00:20:06,590 --> 00:20:07,691
to check out the same levels.

456
00:20:11,912 --> 00:20:13,193
So for each dead zone, we wind up

457
00:20:13,213 --> 00:20:14,613
setting up a post-process volume that

458
00:20:14,653 --> 00:20:16,834
controls the look of that particular space

459
00:20:17,154 --> 00:20:18,135
when it is a dead zone.

460
00:20:19,095 --> 00:20:21,116
And during the dead zone clear, we gradually

461
00:20:21,216 --> 00:20:23,737
fade out the contribution of that dead zone post-process

462
00:20:23,777 --> 00:20:24,998
volume to avoid a lighting pop.

463
00:20:25,835 --> 00:20:27,856
Artists can also preview the contribution of a volume

464
00:20:27,876 --> 00:20:28,976
by toggling it in editor.

465
00:20:29,356 --> 00:20:31,177
So this makes it very easy when you're setting up the length

466
00:20:31,197 --> 00:20:32,658
for a space to see both the before

467
00:20:32,698 --> 00:20:34,659
and after version of the dead zone clear.

468
00:20:37,420 --> 00:20:38,841
So finally, in this breakdown video,

469
00:20:39,301 --> 00:20:40,822
you can see how all of the different layers

470
00:20:40,882 --> 00:20:42,362
come together for the final product,

471
00:20:42,783 --> 00:20:44,263
starting from just the landscape,

472
00:20:44,703 --> 00:20:48,005
having the foliage, having the rest of the scene come in,

473
00:20:48,145 --> 00:20:49,426
having these dead zone meshes,

474
00:20:49,466 --> 00:20:51,507
which you'll see dissolve out slowly

475
00:20:51,607 --> 00:20:52,547
once they get hit by the clear.

476
00:20:53,243 --> 00:20:54,923
and then the lighting and the fog changes

477
00:20:54,963 --> 00:20:56,484
that dissolve out at the beginning.

478
00:21:02,365 --> 00:21:03,946
So now I'm going to talk about how we achieved

479
00:21:04,006 --> 00:21:05,986
the rot-powered special abilities in the game.

480
00:21:06,667 --> 00:21:08,547
There were two big goals that we wanted to accomplish

481
00:21:08,567 --> 00:21:09,347
with these abilities.

482
00:21:10,288 --> 00:21:12,208
First, we wanted to make sure that we captured

483
00:21:12,228 --> 00:21:13,508
the collective nature of the rot

484
00:21:14,449 --> 00:21:16,609
and their role in cleaning Dead Zone.

485
00:21:19,310 --> 00:21:21,291
While the rot are typically animated characters

486
00:21:21,371 --> 00:21:22,651
represented by skeletal meshes.

487
00:21:23,173 --> 00:21:24,934
They transition through different representations

488
00:21:24,974 --> 00:21:25,794
during these abilities,

489
00:21:26,295 --> 00:21:28,176
including Alembic geometry caches

490
00:21:28,256 --> 00:21:29,997
for fast morphing transitions,

491
00:21:30,717 --> 00:21:33,719
and Niagara particles for when the rot are swarming together.

492
00:21:37,542 --> 00:21:39,903
So first, the geometry caches are used in cases

493
00:21:39,943 --> 00:21:43,265
where it would be hard to synchronously animate

494
00:21:43,305 --> 00:21:44,006
multiple rot.

495
00:21:45,086 --> 00:21:46,467
So to create the geometry caches,

496
00:21:46,527 --> 00:21:49,549
we animated low-poly rot meshes to follow animation curves.

497
00:21:50,257 --> 00:21:52,919
There are generally only a few base curves

498
00:21:53,280 --> 00:21:56,242
that are then tweaked slightly to create different path

499
00:21:56,262 --> 00:21:57,943
variations for other rot to follow.

500
00:21:58,684 --> 00:22:01,006
This ensures that there's some level of visual cohesion

501
00:22:01,486 --> 00:22:02,807
as all of the rot are swarming in.

502
00:22:04,349 --> 00:22:06,891
The meshes are also stretched as their velocity increases,

503
00:22:07,391 --> 00:22:09,333
with care taken to preserve their overall volume.

504
00:22:10,554 --> 00:22:13,676
You can see these used at the beginning of the rot bow

505
00:22:13,836 --> 00:22:15,838
and bomb abilities, as well as the rot hammer.

506
00:22:21,996 --> 00:22:24,077
For swarming behaviors, we use a Niagara sim

507
00:22:24,137 --> 00:22:26,118
where each rot is represented by a particle.

508
00:22:27,099 --> 00:22:28,720
The normal skeletal mesh versions of the rot

509
00:22:28,740 --> 00:22:29,600
can be quite expensive,

510
00:22:30,681 --> 00:22:32,742
and so we wind up scaling down the number of rot

511
00:22:32,762 --> 00:22:33,782
that are visible on screen

512
00:22:33,842 --> 00:22:35,783
depending on what platform you're playing on.

513
00:22:37,044 --> 00:22:38,505
However, we wanted to ensure that the user

514
00:22:38,525 --> 00:22:39,905
could see all of their collected rot

515
00:22:40,526 --> 00:22:41,686
when they're in the rot cloud form.

516
00:22:42,807 --> 00:22:44,688
So we chose to represent them with static meshes

517
00:22:44,788 --> 00:22:46,049
in the Niagara particle system

518
00:22:46,109 --> 00:22:47,870
to reduce their animation and rendering cost.

519
00:22:48,982 --> 00:22:50,803
This Niagara simulation runs on the CPU

520
00:22:50,823 --> 00:22:53,305
so that we can easily keep the particle locations in sync

521
00:22:53,325 --> 00:22:54,166
with the rot characters.

522
00:22:54,726 --> 00:22:56,627
This allows us to switch from the particle system

523
00:22:56,647 --> 00:22:59,109
version to the skeletal mesh version relatively seamlessly.

524
00:23:01,631 --> 00:23:04,232
The Niagara simulation distributes rot along a spline.

525
00:23:05,313 --> 00:23:06,734
When binding enemies, the spline is

526
00:23:06,774 --> 00:23:08,555
generated dynamically by adding points

527
00:23:08,595 --> 00:23:10,096
that follow an animated path.

528
00:23:11,757 --> 00:23:12,998
As you can see here, this is the version

529
00:23:13,018 --> 00:23:14,639
that just has the spline.

530
00:23:15,940 --> 00:23:16,500
On the other hand.

531
00:23:17,015 --> 00:23:21,095
When in the rot cloud form, the splines actually follow the bones in the skeletal mesh.

532
00:23:21,836 --> 00:23:24,796
This ensures that the spline has a consistent length and the distribution,

533
00:23:25,276 --> 00:23:28,277
and it has a good distribution even when the cloud is standing still.

534
00:23:29,977 --> 00:23:33,138
The rot particles are attracted to points that rotate around this spline.

535
00:23:33,838 --> 00:23:36,618
The radius and angle of rotation of the attraction points

536
00:23:38,079 --> 00:23:39,499
is somewhat randomized per particle.

537
00:23:40,419 --> 00:23:43,260
These settings are also controlled both by curves

538
00:23:43,760 --> 00:23:46,180
that allow you to define how the values change over.

539
00:23:46,647 --> 00:23:47,487
the length of the spline.

540
00:23:47,987 --> 00:23:51,028
So you might want more thickness at the head

541
00:23:51,048 --> 00:23:52,188
and less at the tail.

542
00:23:53,349 --> 00:23:55,089
And they're also controlled by scalar values

543
00:23:55,509 --> 00:23:56,229
that can be adjusted.

544
00:23:56,649 --> 00:23:59,270
So for example, you can globally scale up the radius

545
00:23:59,550 --> 00:24:01,550
if, for example, the player collects more rot.

546
00:24:04,831 --> 00:24:08,592
These Niagara parameters can also

547
00:24:08,652 --> 00:24:10,572
be driven over time by animation curves.

548
00:24:11,233 --> 00:24:13,753
This allows animators to adjust the simulation's behavior

549
00:24:13,853 --> 00:24:15,133
to better match the animation.

550
00:24:15,973 --> 00:24:17,913
So for example, if the rot cloud is moving fast,

551
00:24:18,473 --> 00:24:20,014
the attraction strength might need to be higher

552
00:24:20,054 --> 00:24:21,794
to prevent the particles from lagging behind.

553
00:24:22,754 --> 00:24:24,655
To accomplish this, we just have some blueprint code

554
00:24:24,675 --> 00:24:26,855
that samples specific animation curves by name,

555
00:24:27,455 --> 00:24:29,856
and it routes those values into the Niagara system.

556
00:24:32,636 --> 00:24:34,137
We animate these values as scalars

557
00:24:34,357 --> 00:24:35,617
rather than absolute values

558
00:24:35,797 --> 00:24:38,337
to avoid stopping any other global changes

559
00:24:38,377 --> 00:24:39,558
that are being passed in.

560
00:24:39,918 --> 00:24:41,978
Like for example, if we're adjusting the radius

561
00:24:42,018 --> 00:24:43,538
based on how many rot you have.

562
00:24:46,874 --> 00:24:48,234
So in this breakdown of the Rot Hammer,

563
00:24:48,274 --> 00:24:49,875
you can actually see all three stages,

564
00:24:50,375 --> 00:24:53,216
starting with these rots swirling in as a geometry cache,

565
00:24:54,496 --> 00:24:56,617
and then turning into a Niagara particle system

566
00:24:56,957 --> 00:24:57,957
as they come bouncing out.

567
00:25:00,778 --> 00:25:02,018
And then finally, they change back

568
00:25:02,058 --> 00:25:03,239
into their skeletal mesh form

569
00:25:03,539 --> 00:25:05,379
when they hit the ground and come tumbling out.

570
00:25:10,921 --> 00:25:11,841
As previously mentioned,

571
00:25:12,441 --> 00:25:13,962
these abilities also are tied

572
00:25:14,002 --> 00:25:15,242
into the Dead Zone cleaning system.

573
00:25:15,919 --> 00:25:18,020
all of the abilities right to the cleaning render target

574
00:25:18,060 --> 00:25:20,282
so that they affect the landscape and the foliage,

575
00:25:20,722 --> 00:25:23,183
but they don't affect the larger dead zone meshes, which

576
00:25:23,243 --> 00:25:23,944
is good in our case.

577
00:25:25,625 --> 00:25:27,626
Not everything cleans in a circular shape, however.

578
00:25:28,166 --> 00:25:30,688
So we needed to add support for drawing trails

579
00:25:30,788 --> 00:25:31,608
to this render target.

580
00:25:32,769 --> 00:25:34,750
While this was originally built to provide the feedback when

581
00:25:34,790 --> 00:25:36,551
moving around the rot cloud, we wound up

582
00:25:36,591 --> 00:25:40,093
using it in a variety of places like the bind feedback,

583
00:25:40,113 --> 00:25:41,874
or the bounce during the rot hammer,

584
00:25:42,635 --> 00:25:44,956
or the cleaning trail left behind from the rot arrow.

585
00:25:47,485 --> 00:25:50,986
One problem we ran into was that the cleaning mask render target

586
00:25:51,167 --> 00:25:51,847
is top down.

587
00:25:52,307 --> 00:25:53,648
So there isn't really an easy way

588
00:25:53,688 --> 00:25:55,249
to encode that cleaning is happening

589
00:25:55,289 --> 00:25:56,549
at a particular height value.

590
00:25:57,330 --> 00:25:59,090
So one of the early problems that we ran into

591
00:26:00,411 --> 00:26:02,012
was, for example, if you take the raw arrow

592
00:26:02,172 --> 00:26:05,473
and you fire it into the air, ideally, the cleaning effect

593
00:26:05,514 --> 00:26:08,255
should decrease as the arrow gets higher off of the ground.

594
00:26:09,115 --> 00:26:11,737
But in our naive approach, it didn't do that.

595
00:26:13,156 --> 00:26:16,278
So we fixed this by just simply performing traces down

596
00:26:16,418 --> 00:26:19,760
to find how high off the ground it was whenever we were adding

597
00:26:19,800 --> 00:26:20,701
a point to the trail.

598
00:26:21,762 --> 00:26:23,443
And then depending on the distance to the ground,

599
00:26:23,863 --> 00:26:25,324
we adjusted the strength for that point.

600
00:26:26,345 --> 00:26:27,926
And the shader takes that into account,

601
00:26:27,986 --> 00:26:28,906
and it fades out the effect.

602
00:26:31,468 --> 00:26:33,710
So put all together, we think the dynamic feedback

603
00:26:33,730 --> 00:26:35,931
for these abilities gives the impression

604
00:26:35,951 --> 00:26:38,153
that the player is fighting back the dead zone every time

605
00:26:38,193 --> 00:26:39,313
they use the Rot in combat.

606
00:26:42,400 --> 00:26:44,101
So hopefully that gives you a brief overview

607
00:26:44,141 --> 00:26:45,781
of how we achieved the dead zone transitions

608
00:26:45,881 --> 00:26:47,561
and rot abilities in Cana Bridge of Spirits.

609
00:26:48,342 --> 00:26:50,122
I think that there were two big takeaways for us

610
00:26:50,162 --> 00:26:51,902
that we've already somewhat alluded to.

611
00:26:53,383 --> 00:26:56,303
First, ideally the VFX is used to reinforce the world building

612
00:26:56,623 --> 00:26:58,584
rather than just using it to make stuff look cool.

613
00:27:00,084 --> 00:27:01,604
Especially in our case, we struggled a lot

614
00:27:02,225 --> 00:27:04,885
to establish how the rot actually cleaned dead zone,

615
00:27:05,505 --> 00:27:07,026
but we found that good VFX feedback

616
00:27:07,066 --> 00:27:08,906
did a lot of heavy lifting when it came to getting players

617
00:27:08,946 --> 00:27:11,407
to understand and accept how the stuff worked.

618
00:27:13,880 --> 00:27:16,742
And second, we derived a lot of value by building stuff in layers.

619
00:27:17,642 --> 00:27:21,204
So while none of the individual parts of the dead zone equation are particularly complicated,

620
00:27:21,845 --> 00:27:24,106
each layer provides different feedback from the last,

621
00:27:24,966 --> 00:27:27,667
and they all work to produce something greater than the sum of its parts.

622
00:27:28,728 --> 00:27:30,929
And by staggering the effects of these layers across time,

623
00:27:31,429 --> 00:27:33,811
we were able to make each part read separately from the others,

624
00:27:34,311 --> 00:27:35,552
instead of getting lost in the noise.

625
00:27:37,925 --> 00:27:41,087
So I guess we're a little short on time for questions.

626
00:27:41,687 --> 00:27:44,268
So I will say, if anybody has questions,

627
00:27:44,348 --> 00:27:47,309
I'll probably be hanging out in the room 204

628
00:27:47,909 --> 00:27:50,610
down the hallway if anybody wants to ask questions afterward.

629
00:27:52,471 --> 00:27:54,271
And you can also shoot me an email if you want to.

630
00:27:54,432 --> 00:27:56,192
My email is on the slide, my work email,

631
00:27:56,772 --> 00:27:57,713
and I'll try to get back to you.

632
00:27:58,273 --> 00:28:00,054
And if you have any other things

633
00:28:00,074 --> 00:28:01,294
that you want to contact the studio about,

634
00:28:01,334 --> 00:28:03,235
you can always hit up our contact email,

635
00:28:03,355 --> 00:28:04,515
contact.emeralab.com.

636
00:28:05,706 --> 00:28:08,388
But I guess I just want to thank you all for your attention.

637
00:28:08,849 --> 00:28:12,412
And yeah, I want to thank everybody else who

638
00:28:13,093 --> 00:28:14,474
worked on this content and helped

639
00:28:14,494 --> 00:28:16,055
me prepare this presentation, because it was certainly

640
00:28:16,075 --> 00:28:16,656
a good bit of work.

641
00:28:17,356 --> 00:28:17,556
So thanks.

642
00:28:17,977 --> 00:28:18,277
Thank you.

643
00:28:19,638 --> 00:28:19,999
Good night.

644
00:28:20,019 --> 00:28:20,279
Good evening.

645
00:28:20,299 --> 00:28:20,519
How are you?

646
00:28:20,539 --> 00:28:20,799
Good evening.

647
00:28:20,819 --> 00:28:21,120
Good evening.

648
00:28:21,140 --> 00:28:21,460
Good evening.

649
00:28:21,480 --> 00:28:21,740
Good evening.

650
00:28:21,760 --> 00:28:22,661
How are you?

651
00:28:23,121 --> 00:28:23,622
Good evening.

652
00:28:23,662 --> 00:28:23,942
Good evening.

653
00:28:23,962 --> 00:28:24,383
Good evening.

654
00:28:24,403 --> 00:28:24,643
Good evening.

655
00:28:24,663 --> 00:28:24,903
Good evening.

656
00:28:24,923 --> 00:28:25,163
Good evening.

657
00:28:25,183 --> 00:28:25,644
How have you all been?

658
00:28:25,664 --> 00:28:25,744
Good.

659
00:28:25,764 --> 00:28:26,004
Good evening.

660
00:28:26,024 --> 00:28:26,264
Good evening.

661
00:28:26,284 --> 00:28:26,524
Good evening.

662
00:28:26,544 --> 00:28:26,785
Good evening.

663
00:28:26,805 --> 00:28:27,065
Good evening.

664
00:28:27,085 --> 00:28:27,345
Good evening.

