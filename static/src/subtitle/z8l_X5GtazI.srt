1
00:00:06,143 --> 00:00:11,165
Thank you for joining us today. My name is Romain and I'm a senior gameplay engineer at ILMxLAB,

2
00:00:11,686 --> 00:00:14,066
which is Lucasfilm's immersive entertainment studio.

3
00:00:15,087 --> 00:00:21,809
Our core mission at xLAB is to pioneer a new era of interactive storytelling via connected stories that cross platforms.

4
00:00:22,850 --> 00:00:32,773
The goal is to move from storytelling to story living where we invite you to step inside living worlds to meet beloved characters and become the hero of your own personal adventure.

5
00:00:36,414 --> 00:00:43,257
We're excited to talk to you today about how we built an expansive Star Wars world in mobile VR with Star Wars Tales from the Galaxy's Edge.

6
00:00:46,079 --> 00:00:55,123
Tales began in the fall of 2019. It was a continuation of our partnership with Oculus Studios, which previously we released a very immortal, the VR series, for.

7
00:00:56,144 --> 00:01:04,368
That experience delivered on the Oculus Rift, which is desktop powered, and the Oculus Quest, which was Oculus' first untethered mobile VR headset.

8
00:01:05,510 --> 00:01:08,431
Similar to Vader, Tales is also a flagship title

9
00:01:08,591 --> 00:01:10,472
for the recently released Oculus Quest 2,

10
00:01:10,552 --> 00:01:14,034
which is a more powerful entry into the mobile VR market.

11
00:01:14,735 --> 00:01:16,456
But even though our experience was to be featured

12
00:01:16,496 --> 00:01:18,437
for the Quest 2, we still had to deliver

13
00:01:18,517 --> 00:01:20,398
a performance experience for Quest 1.

14
00:01:22,099 --> 00:01:23,820
And that's what we're gonna tell you about how we did it.

15
00:01:25,561 --> 00:01:27,982
So now in mobile VR, there are challenges

16
00:01:28,042 --> 00:01:30,423
that we've run into, especially for a platform

17
00:01:30,563 --> 00:01:32,785
that is not as powerful as Quest 2, which is Quest 1.

18
00:01:34,372 --> 00:01:37,494
Some of those challenges include explorable world with long sightlines,

19
00:01:37,794 --> 00:01:40,536
there are more characters, more interactive cinematics,

20
00:01:41,016 --> 00:01:44,258
lots of weapons, inventory, collectibles, and of course lots of combat.

21
00:01:45,318 --> 00:01:47,399
All of this challenges the device.

22
00:01:49,340 --> 00:01:52,762
First, what I want to tell you about is the Game Thread challenges we ran into.

23
00:01:52,922 --> 00:01:56,404
So in this project, I was the lead Game Thread performance engineer.

24
00:01:58,105 --> 00:01:59,906
And we ran into a few issues.

25
00:02:00,346 --> 00:02:01,887
Some of those I'm going to mention here.

26
00:02:02,523 --> 00:02:04,524
and how we went about addressing them.

27
00:02:05,164 --> 00:02:07,445
Some of those issues include moving complex component

28
00:02:07,485 --> 00:02:10,086
hierarchies, spawning and despawning hitches,

29
00:02:11,047 --> 00:02:12,828
ticks during combats that are not needed,

30
00:02:13,188 --> 00:02:14,568
and stalls on the CPU.

31
00:02:16,289 --> 00:02:17,950
So first, component hierarchy.

32
00:02:18,010 --> 00:02:19,811
So it's, as a rule of thumb,

33
00:02:20,491 --> 00:02:22,072
the bigger a component hierarchy is,

34
00:02:22,412 --> 00:02:24,193
the longer it will take to move.

35
00:02:24,893 --> 00:02:26,634
So there are a few tips to know

36
00:02:27,214 --> 00:02:29,075
whenever we run into those kinds of issues.

37
00:02:29,235 --> 00:02:31,096
First is to try as much as you can

38
00:02:31,750 --> 00:02:37,772
to use actor components instead of scene components, especially for things that don't need to have a transform all the time that is up to date.

39
00:02:38,273 --> 00:02:39,573
Things that are not visual, for instance.

40
00:02:41,274 --> 00:02:49,236
Second is to use Unreal's built-in scoped movement, which allows you to do all the transform calculations ahead of time and only do the move once at the end.

41
00:02:49,836 --> 00:02:55,578
Which goes into the next point of making sure you only move heavy hierarchies once a frame at most.

42
00:02:57,457 --> 00:03:06,425
if possible, of course. Lastly, we managed to build a system to detach components that were not needed and to reattach them when needed.

43
00:03:06,525 --> 00:03:14,152
And I'm talking about components like VFX or audio. Things are not present all the time, but that might show up every once in a while.

44
00:03:16,088 --> 00:03:19,010
Now there's a special case I want to address, skeletal meshes.

45
00:03:19,050 --> 00:03:22,633
So on top of the issues that I have detailed before,

46
00:03:23,253 --> 00:03:25,675
skeletal meshes have to update their bones twice,

47
00:03:26,015 --> 00:03:28,477
once when the character moves and the second time

48
00:03:28,537 --> 00:03:30,378
when the animation evaluation ends.

49
00:03:31,639 --> 00:03:34,201
This is especially a problem if you have lots of bones,

50
00:03:34,701 --> 00:03:36,722
if you have lots of things attached to your bones,

51
00:03:37,543 --> 00:03:39,985
things that themselves have lots of subcomponents as well.

52
00:03:40,830 --> 00:03:43,771
What we did for those is what I called the detachment

53
00:03:43,811 --> 00:03:44,471
optimization.

54
00:03:44,811 --> 00:03:47,292
So for this, we detached the skeletal mesh

55
00:03:47,312 --> 00:03:48,292
from its parent component.

56
00:03:49,712 --> 00:03:51,353
And instead of moving the components,

57
00:03:51,453 --> 00:03:53,553
we used the anim graph to move all the bones where

58
00:03:53,593 --> 00:03:54,273
they're supposed to be.

59
00:03:54,913 --> 00:03:56,394
So basically, we saved the transform

60
00:03:56,414 --> 00:03:57,754
that the component was supposed to have

61
00:03:57,794 --> 00:03:58,934
and put it on the root bone.

62
00:04:00,575 --> 00:04:01,595
This was great.

63
00:04:01,635 --> 00:04:03,895
It helped us a lot, especially during combat,

64
00:04:03,915 --> 00:04:05,376
where we have lots of characters on screen.

65
00:04:05,876 --> 00:04:08,236
We used it on the player pawn, all enemies,

66
00:04:08,356 --> 00:04:09,797
and some of the cinematic characters, too.

67
00:04:10,888 --> 00:04:16,555
There obviously are some drawbacks. You can't use the transform of the component anymore, you have to use the root bone transform.

68
00:04:17,576 --> 00:04:22,843
And some anim nodes don't know how to work with this, so you have to go in and fix them.

69
00:04:22,963 --> 00:04:28,149
Thankfully we managed to keep that, although it didn't take us too long to do that.

70
00:04:30,426 --> 00:04:34,708
So another issue that comes about when moving component hierarchies is overlaps.

71
00:04:34,928 --> 00:04:41,852
There are a lot of times where overlaps are turned on, whether it's by default or it's people thinking they're doing the right thing and turning them on.

72
00:04:42,393 --> 00:04:44,474
There's a lot of cases where actually you don't need overlaps.

73
00:04:44,494 --> 00:04:49,497
So, for instance, when you're only going to be doing traces on a specific collision.

74
00:04:50,977 --> 00:04:58,282
So it's great to educate people as to how collision and physics work, what the settings are for and when to turn them on.

75
00:04:59,204 --> 00:05:02,567
and definitely make sure you tell them to leave things off by default unless needed.

76
00:05:03,888 --> 00:05:08,672
And finally, one thing that has helped us a couple times is to switch to a list of targets

77
00:05:08,752 --> 00:05:12,516
as opposed to collisions. For instance, if you have a sphere collision that only detects

78
00:05:12,576 --> 00:05:16,819
enemies, you can maybe instead keep a list of the enemies and just do a distance check

79
00:05:16,839 --> 00:05:19,342
against them. That will take a lot less time.

80
00:05:22,114 --> 00:05:23,695
All right, so moving on from components,

81
00:05:23,775 --> 00:05:24,736
now we have hitches.

82
00:05:25,296 --> 00:05:27,297
There are hitches in Unreal Engine,

83
00:05:27,357 --> 00:05:29,459
and especially when spawning and despawning

84
00:05:29,559 --> 00:05:30,359
actors and components.

85
00:05:30,879 --> 00:05:33,201
So the best weapon we have to fight against those

86
00:05:33,281 --> 00:05:34,342
is to use a pooling system.

87
00:05:35,042 --> 00:05:36,423
There isn't one built into Unreal,

88
00:05:37,163 --> 00:05:38,844
so we had to roll out our own.

89
00:05:40,065 --> 00:05:41,046
And it helped us a lot.

90
00:05:41,866 --> 00:05:44,228
Basically, the concept is you spawn everything ahead of time,

91
00:05:45,168 --> 00:05:47,049
you hide them and use them when needed.

92
00:05:47,069 --> 00:05:49,351
And when they're done, you re-hide them again.

93
00:05:49,591 --> 00:05:51,792
Make sure to turn off all the ticks, collision, everything.

94
00:05:52,884 --> 00:05:56,266
It's great. It helped us get rid of most of the hitches.

95
00:05:56,967 --> 00:06:06,214
It also allowed us to use caps for all our enemies and for also weapons and lots of items that could potentially balloon otherwise.

96
00:06:07,775 --> 00:06:13,360
Another thing it helps is with spawning and despawning of objects when they're far away. So that's my next slide.

97
00:06:14,361 --> 00:06:20,065
During combat, and even when you're just exploring the world, it's very common to see things ticking, rendering.

98
00:06:20,720 --> 00:06:26,063
or even updating their collision when they're really far away and you don't actually care about all this.

99
00:06:26,824 --> 00:06:32,448
So what we did for that is to use a player distance system that we put on almost all of our objects,

100
00:06:32,728 --> 00:06:35,390
interactive objects and enemies, well not enemies.

101
00:06:36,731 --> 00:06:41,194
The idea is to reduce the impact when you're not close to the items.

102
00:06:42,755 --> 00:06:46,718
And we leverage our pulling system to spawn the items when you're close enough

103
00:06:46,778 --> 00:06:47,918
and despawn them when you're far away.

104
00:06:49,138 --> 00:06:50,619
So that was a great help.

105
00:06:50,639 --> 00:06:54,901
All right, finally, and I want to say last but not least,

106
00:06:55,541 --> 00:06:56,221
game thread stalls.

107
00:06:57,482 --> 00:06:59,263
On Quest, especially Quest 1, we only

108
00:06:59,303 --> 00:07:00,823
have three cores that we can use.

109
00:07:00,863 --> 00:07:01,784
The rest are reserved.

110
00:07:02,504 --> 00:07:04,645
And in heavy moments such as combat,

111
00:07:04,705 --> 00:07:08,067
we are using all of those very intensely.

112
00:07:08,587 --> 00:07:10,608
By rendering, by audio, gameplay,

113
00:07:10,748 --> 00:07:12,428
everything is acting up all at once.

114
00:07:13,455 --> 00:07:14,956
So it's really hard to address stalls.

115
00:07:14,996 --> 00:07:16,516
Sometimes they're just there

116
00:07:16,556 --> 00:07:17,977
because there's just too much work to do.

117
00:07:18,697 --> 00:07:21,878
But there are some cases where you can solve some of them.

118
00:07:23,098 --> 00:07:26,439
In order to do that, we've used a tool called Unreal Insights

119
00:07:26,519 --> 00:07:27,699
that you may be familiar with.

120
00:07:28,339 --> 00:07:31,320
This tool is aiming to replace the stats capture

121
00:07:31,380 --> 00:07:32,781
that we've been doing in the past.

122
00:07:34,181 --> 00:07:35,361
I think it's great personally.

123
00:07:35,381 --> 00:07:38,242
I think there's still a little bit of work to do on it,

124
00:07:38,322 --> 00:07:40,843
but we've been using it with great success.

125
00:07:41,525 --> 00:07:43,806
It's great for people who are more visual

126
00:07:43,867 --> 00:07:44,787
in understanding things.

127
00:07:44,907 --> 00:07:48,090
It helps you see what things are happening in which order.

128
00:07:50,111 --> 00:07:51,933
It also has a smaller impact on performance

129
00:07:51,953 --> 00:07:52,813
than the stats capture,

130
00:07:52,873 --> 00:07:54,935
because it doesn't have to save everything to a file.

131
00:07:55,035 --> 00:07:56,336
It just sends it over the network.

132
00:07:56,856 --> 00:07:58,578
Now it's a little bit hard to set up on Quest.

133
00:07:59,318 --> 00:08:00,579
There are some resources online

134
00:08:00,639 --> 00:08:01,680
that are not too hard to find.

135
00:08:02,721 --> 00:08:04,602
And as of our version of Unreal,

136
00:08:04,742 --> 00:08:06,363
we didn't have any of the object names

137
00:08:06,904 --> 00:08:09,146
that were causing the stats.

138
00:08:09,686 --> 00:08:11,287
So it was a little bit tricky to interpret.

139
00:08:11,864 --> 00:08:14,606
Thankfully, we're able to go in the engine and add some of that back.

140
00:08:14,826 --> 00:08:17,329
So hopefully we can see that in the future version of the engine.

141
00:08:19,330 --> 00:08:23,374
So with this tool, we were able to see one thing in particular.

142
00:08:23,394 --> 00:08:28,438
And if you can see on this image, there is a stall that I've circled.

143
00:08:28,518 --> 00:08:32,482
And right after you can see a parallel animation evaluation that's completing.

144
00:08:33,703 --> 00:08:35,925
Thanks to this graph, we were able to determine that

145
00:08:36,874 --> 00:08:41,376
One of our skeletal meshes had a prerequisite on it that was forcing it to complete in an earlier

146
00:08:41,456 --> 00:08:48,300
tick than what we were okay with. By fixing this, we were able to let the animation complete

147
00:08:48,580 --> 00:08:52,963
in parallel and finish way later in the frame, which saves us some of the stall.

148
00:08:54,504 --> 00:09:00,727
So to use Unreal Insights the most effectively, the way we did, it's critical in my mind to

149
00:09:00,787 --> 00:09:03,489
understand the task graph system, so dive a little bit if you have to.

150
00:09:04,549 --> 00:09:10,773
And definitely be careful of tick prerequisites because those get added automatically when you parent components to each other.

151
00:09:12,174 --> 00:09:13,475
So keep an eye out for those things.

152
00:09:15,156 --> 00:09:21,140
I want to close the game thread parts with some miscellaneous tips. Some of those are obvious, but I just thought I'd mention it.

153
00:09:22,341 --> 00:09:29,626
No blueprint ticks. Please keep everything in native because you will have to do it at some point. I guarantee it. You will have to move things to native.

154
00:09:30,467 --> 00:09:33,129
Except of course in some very trivial cases.

155
00:09:34,203 --> 00:09:43,447
In the same vein, no blueprint implementable or blueprint native events on ticks, because those incur the same kind of overhead as the regular blueprint tick.

156
00:09:44,047 --> 00:09:50,249
And even with blueprint native events that are not implemented in blueprints, you will have to maybe remove that.

157
00:09:51,970 --> 00:10:03,135
Favorite non-dynamic delegates. Dynamic delegates actually use similar tech under the hood as blueprint does, so you will also have an overhead with that. So try to keep those two minimum.

158
00:10:04,109 --> 00:10:05,990
Finally, beware of blueprint timers.

159
00:10:06,230 --> 00:10:08,672
So the blueprint timers actually show up

160
00:10:08,712 --> 00:10:10,333
in a different area of the stats capture

161
00:10:11,013 --> 00:10:12,174
than the regular ticks.

162
00:10:12,814 --> 00:10:15,216
So in our case, it took us almost

163
00:10:15,276 --> 00:10:16,797
until the end of development to realize

164
00:10:16,837 --> 00:10:18,498
that we had three millisecond hitches

165
00:10:18,958 --> 00:10:21,280
happening very frequently in the timer

166
00:10:22,000 --> 00:10:23,541
and that were causing some of our issues

167
00:10:23,561 --> 00:10:24,862
that we just couldn't see happening

168
00:10:24,942 --> 00:10:26,183
in the regular tick section.

169
00:10:26,223 --> 00:10:29,445
So definitely remember that and keep an eye out for those.

170
00:10:30,445 --> 00:10:30,605
Now.

171
00:10:31,126 --> 00:10:34,248
Game thread is not the only thing that we've had challenges with.

172
00:10:35,229 --> 00:10:37,170
Of course, we've been trying to push our rendering,

173
00:10:37,491 --> 00:10:39,372
and I'm going to hand it over to Jeff

174
00:10:39,572 --> 00:10:41,874
to talk about our rendering challenges on this project.

175
00:10:45,016 --> 00:10:47,358
Thanks, Romain. Hi, I'm Jeff Gridby,

176
00:10:47,618 --> 00:10:50,100
Technical Art Director on Tales from the Galaxy's Edge.

177
00:10:50,720 --> 00:10:54,743
As TAD, it was my responsibility to oversee the render side,

178
00:10:54,944 --> 00:10:56,665
performance and optimization approach,

179
00:10:57,005 --> 00:10:59,407
as well as investigate techniques for visual enhancements.

180
00:11:00,357 --> 00:11:02,038
This was an exciting opportunity for us

181
00:11:02,078 --> 00:11:04,539
to partner both with Disney theme parks, Lucasfilm

182
00:11:04,619 --> 00:11:07,140
Storytelling, to give our fans an opportunity

183
00:11:07,200 --> 00:11:09,402
to step well beyond Black Spire Outposts

184
00:11:09,602 --> 00:11:11,002
and explore the lands of Batuu.

185
00:11:11,823 --> 00:11:13,204
We knew early on from our experiences

186
00:11:13,244 --> 00:11:15,505
with Vader Immortal, thorough optimization

187
00:11:15,585 --> 00:11:17,746
was going to be essential to bringing about our rich

188
00:11:17,786 --> 00:11:20,568
environments and interactive storytelling content to life.

189
00:11:21,368 --> 00:11:23,329
Unreal Engine has numerous built-in methods

190
00:11:23,369 --> 00:11:24,150
of optimization.

191
00:11:24,690 --> 00:11:27,231
I'm going to share with you some of the methods we chose to use,

192
00:11:27,651 --> 00:11:30,113
enhance, as well as some of the features we implemented.

193
00:11:35,838 --> 00:11:39,640
We want to achieve vast, diverse regions for you to explore.

194
00:11:39,840 --> 00:11:41,601
And to do so, object inclusion is

195
00:11:41,641 --> 00:11:43,941
going to be vital to keeping our performance metrics down.

196
00:11:44,482 --> 00:11:46,703
This was by far our best means of performance gains.

197
00:11:47,243 --> 00:11:49,744
We want systems that were thorough, automated,

198
00:11:50,124 --> 00:11:52,305
and avoided human error, and were also

199
00:11:52,365 --> 00:11:53,585
computationally efficient.

200
00:11:54,085 --> 00:11:56,366
Above all, we want our RSTeams to spend more time

201
00:11:56,426 --> 00:11:59,007
building our worlds and less time focused on optimizing

202
00:11:59,027 --> 00:11:59,107
them.

203
00:12:05,758 --> 00:12:08,720
For mesh occlusion, we opted to use Unreal's precomputed

204
00:12:08,740 --> 00:12:09,621
visibility system.

205
00:12:10,041 --> 00:12:13,263
It's a powerful tool in that its simplicity is set up,

206
00:12:13,484 --> 00:12:16,606
as well as its automation tied with light beak generation.

207
00:12:17,386 --> 00:12:20,449
It works by scattering cells over every single static mesh

208
00:12:20,489 --> 00:12:23,471
within a volume, emitting rays from those cells

209
00:12:23,551 --> 00:12:24,972
to detect mesh boundaries.

210
00:12:25,953 --> 00:12:28,895
Unfortunately, though, most of the default configurations

211
00:12:29,015 --> 00:12:31,937
lead to noticeable bumps and inaccurate occlusion queries.

212
00:12:32,718 --> 00:12:33,398
To remedy this.

213
00:12:33,888 --> 00:12:37,249
the sample settings need to be set extremely high for accurate results,

214
00:12:37,870 --> 00:12:40,270
especially with long sight lines filled with various obstacles.

215
00:12:41,070 --> 00:12:44,291
We also needed many cells to increase the occlusion effectiveness.

216
00:12:44,972 --> 00:12:47,492
Too large of a cell size and we ended up just drawing too much.

217
00:12:48,432 --> 00:12:52,354
That said, higher sample settings can lead to exponential computation times.

218
00:12:52,914 --> 00:12:56,695
So it's critical for the effectiveness of this tool to limit the amount of cells.

219
00:12:57,255 --> 00:13:00,776
And the only option to do that is to hand place individual volumes over

220
00:13:01,222 --> 00:13:03,904
each location where you want these visibility cells placed.

221
00:13:04,444 --> 00:13:07,026
In a large map, this can be extremely difficult to maintain.

222
00:13:10,989 --> 00:13:14,411
So instead, to reduce the computation time and retain accuracy,

223
00:13:14,631 --> 00:13:18,194
we modified the system to only place cells on specified meshes.

224
00:13:21,677 --> 00:13:25,279
We also exposed a method to export the navigation mesh's geometry,

225
00:13:25,779 --> 00:13:27,701
which we could then use for selective cell placement.

226
00:13:28,398 --> 00:13:34,282
This approach dropped us from roughly 40,000 cells using individually hand-placed volumes to only 5,000 cells.

227
00:13:34,782 --> 00:13:40,686
And another nice perk was that we only needed to place a single volume to encompass the entire map, which made maintenance a breeze.

228
00:13:44,885 --> 00:13:48,907
We also had a player jetpack to account for, which tripled the potential player height.

229
00:13:49,567 --> 00:13:53,549
But with our cell count nice and low, we added some logic to support cell stacking.

230
00:13:54,010 --> 00:13:59,333
Here, we were able to add three layers of additional cells to cover each potential player

231
00:13:59,353 --> 00:14:00,253
height from the jetpack.

232
00:14:00,793 --> 00:14:04,035
This way, the cells were made nice and small to maximize occlusion.

233
00:14:07,977 --> 00:14:10,158
We also exposed controls within the world settings to

234
00:14:13,201 --> 00:14:15,702
as well as mesh quantity sampling thresholds

235
00:14:15,822 --> 00:14:18,963
to circumvent fluctuations in the amount of meshes

236
00:14:19,183 --> 00:14:20,243
that we needed to process.

237
00:14:20,924 --> 00:14:21,824
Early on in our development,

238
00:14:21,864 --> 00:14:24,045
those mesh quantities would shift drastically.

239
00:14:24,765 --> 00:14:27,746
This helped to provide us predictable competition times

240
00:14:27,766 --> 00:14:28,926
for pre-computed visibility.

241
00:14:33,508 --> 00:14:34,949
One last bit that was troublesome

242
00:14:35,089 --> 00:14:37,810
was how each run of the pre-computed visibility system

243
00:14:37,910 --> 00:14:39,770
would generate fresh occlusion IDs.

244
00:14:40,447 --> 00:14:44,633
with every static mesh and store those IDs within the levels containing those meshes.

245
00:14:45,133 --> 00:14:47,417
That typically meant dirtying every level within a map.

246
00:14:48,058 --> 00:14:50,101
Unless those levels were available to be saved,

247
00:14:50,121 --> 00:14:54,647
you ran the risk of a potential update and essentially an incorrect ID map.

248
00:14:55,617 --> 00:14:58,638
Even when all maps were saved, the ID structure

249
00:14:58,658 --> 00:15:01,998
deteriorates rapidly with mesh additions and modifications.

250
00:15:02,178 --> 00:15:04,899
And you're stuck with a flickering incorrect occlusion

251
00:15:04,959 --> 00:15:05,319
queries.

252
00:15:06,419 --> 00:15:08,660
With an up-to-date editor session, though,

253
00:15:08,940 --> 00:15:11,180
with a not up-to-date editor session,

254
00:15:11,260 --> 00:15:13,561
it can be very difficult to determine what to optimize.

255
00:15:15,861 --> 00:15:18,181
So we modified the system to store the mapping IDs

256
00:15:18,702 --> 00:15:20,662
in the persistent level, tying the static mesh

257
00:15:20,722 --> 00:15:21,922
IDs to their footpaths.

258
00:15:22,746 --> 00:15:24,766
This provided us a system that would not

259
00:15:24,786 --> 00:15:27,327
deteriorate and remain valid.

260
00:15:28,027 --> 00:15:31,227
With our iCard precomputed visibilities now in Editor,

261
00:15:31,367 --> 00:15:33,548
we set up scene cameras to run through our maps,

262
00:15:33,948 --> 00:15:36,948
not only to optimize and visualize

263
00:15:36,988 --> 00:15:39,529
our precomputed visibility, but also to detect

264
00:15:39,629 --> 00:15:49,731
other objects not included.

265
00:15:49,851 --> 00:15:51,631
Even with optimized special version.

266
00:15:52,237 --> 00:15:53,678
Given our sightline detail, we still

267
00:15:53,738 --> 00:15:56,599
had significant draw calls over draw and memory consumption.

268
00:15:57,120 --> 00:16:00,402
We were averaging roughly 600 draw calls in GPU

269
00:16:00,422 --> 00:16:01,342
well within the 20s.

270
00:16:01,943 --> 00:16:04,064
And we knew we had to perform some form of texture

271
00:16:04,104 --> 00:16:05,325
at the scene and mesh combining.

272
00:16:05,725 --> 00:16:07,946
So once again, we looked into Unreal's built-in performance

273
00:16:07,966 --> 00:16:08,807
solutions for the web.

274
00:16:09,567 --> 00:16:10,968
Two solutions that stood out to us,

275
00:16:11,388 --> 00:16:13,249
the hierarchical LODing system, which

276
00:16:13,309 --> 00:16:16,031
is an automated system of mesh combining,

277
00:16:16,611 --> 00:16:19,933
and the Merge Actors Texture Atlas and Generation system.

278
00:16:23,984 --> 00:16:29,828
optimization tasks. But we ran into some complications. The systems degraded visual

279
00:16:29,868 --> 00:16:34,611
quality either by overriding some of the customizations we built into our source materials

280
00:16:35,311 --> 00:16:40,614
or by packing some of the tileable textures into too small of a unique texture. The systems were

281
00:16:40,634 --> 00:16:44,957
also kind of cumbersome to implement by our artist teams and in some ways were destructive to their

282
00:16:44,977 --> 00:16:45,417
workflows.

283
00:16:46,318 --> 00:16:51,384
Plus, we experienced numerous lighting and geometry LOD transition pops, killing our immersion.

284
00:16:51,884 --> 00:16:55,488
So we wanted to see if there was a way we could leverage some of these systems with some enhancements.

285
00:17:00,093 --> 00:17:03,716
Textures and audio usually accounted for the lion's share of our memory allocation.

286
00:17:04,297 --> 00:17:09,903
We found that we achieved higher detail of 4K tellable textures as opposed to numerous unique textures at lower res.

287
00:17:10,824 --> 00:17:13,606
To increase variation, we blended multiple tiling textures

288
00:17:13,666 --> 00:17:16,629
through mass regions and offset the tiling by object size.

289
00:17:17,229 --> 00:17:18,851
This way, we could kit bash our environments

290
00:17:18,911 --> 00:17:20,792
with very small base set of meshes

291
00:17:21,073 --> 00:17:22,814
and still achieve a diverse look of terrain.

292
00:17:23,975 --> 00:17:25,796
Through the use of custom parameters,

293
00:17:26,117 --> 00:17:28,238
we could drive unique mesh overrides

294
00:17:28,639 --> 00:17:30,600
through a common master material.

295
00:17:31,461 --> 00:17:33,563
But for this to be effective at reducing drop calls,

296
00:17:33,903 --> 00:17:36,425
we would need to utilize hierarchical lighting technique

297
00:17:36,866 --> 00:17:38,687
that would support our customizations.

298
00:17:42,738 --> 00:17:44,519
Unfortunately, that's where we ran into some snags

299
00:17:44,579 --> 00:17:46,600
with Unreal's built-in HLOD system.

300
00:17:47,121 --> 00:17:49,182
So we set about to see if we could make some modifications

301
00:17:49,242 --> 00:17:51,864
to simplify its implementation, make it

302
00:17:51,924 --> 00:17:54,346
non-destructive for artist workflows,

303
00:17:54,406 --> 00:17:57,328
support custom material systems, and see if we could also

304
00:17:57,388 --> 00:17:58,949
utilize it to reduce overdraw.

305
00:17:59,849 --> 00:18:02,411
First off, we modified how HLODs are clustered,

306
00:18:02,691 --> 00:18:04,212
opting for a very simplistic approach,

307
00:18:04,392 --> 00:18:08,115
parenting source meshes under an overridden exposed LOD actor.

308
00:18:08,675 --> 00:18:12,158
LOD actors are the invisible HLOD actors in their level.

309
00:18:12,893 --> 00:18:16,016
This provided us not only a readable, deterministic system

310
00:18:16,096 --> 00:18:19,078
for our artist teams to define how their HLODs are clustered,

311
00:18:19,518 --> 00:18:21,520
but it was also non-disruptive to their workflows.

312
00:18:21,960 --> 00:18:23,481
And by exposing the LOD actor, we

313
00:18:23,501 --> 00:18:26,344
could control key specifics, including the ability

314
00:18:26,404 --> 00:18:28,785
to create our own customized HLOD meshes.

315
00:18:35,931 --> 00:18:37,932
Utilizing Houdini, we built a tool

316
00:18:37,952 --> 00:18:40,815
that could ingest and export a set of HLOD clusters.

317
00:18:41,293 --> 00:18:48,677
not only combining those meshes, preserving our material systems, but also utilizing an exported

318
00:18:48,797 --> 00:18:53,819
navigation mesh to scatter visibility rays to remove triangles not visible to the player region.

319
00:18:54,600 --> 00:18:59,882
Taking that a step further, each H-slot would be re-sampled and LODed at varying view distances

320
00:19:00,263 --> 00:19:04,905
to further decimate non-visible triangles, as well as to incorporate the correct set of source

321
00:19:04,945 --> 00:19:06,646
mesh LODs from that distance.

322
00:19:12,088 --> 00:19:13,649
And the whole process was automated

323
00:19:13,869 --> 00:19:15,290
and batched over our server front.

324
00:19:15,670 --> 00:19:17,811
That meant we couldn't rerun the entire process

325
00:19:17,872 --> 00:19:19,633
in roughly 15 minutes for a full map,

326
00:19:20,053 --> 00:19:22,855
which typically contains somewhere around seven sub-levels

327
00:19:23,035 --> 00:19:25,016
at 50 to 100 page slots each.

328
00:19:25,676 --> 00:19:27,918
Automation meant we were achieving far better results

329
00:19:27,958 --> 00:19:29,239
than what we could manually achieve.

330
00:19:29,619 --> 00:19:31,420
And this drastically reduced overdraft.

331
00:19:32,141 --> 00:19:34,602
And because the system was now exposed within Houdini,

332
00:19:35,002 --> 00:19:37,804
we could further continue to modify its performance

333
00:19:37,824 --> 00:19:38,485
and functionality.

334
00:19:43,478 --> 00:19:48,142
In situations where the sightline was still too expensive, we leveraged tiered H-slides

335
00:19:48,182 --> 00:19:52,106
to cull additional triangles visible from specific vantages.

336
00:19:54,408 --> 00:19:58,071
Here in the mouth of the cavern, the player could see the entire region below, which was

337
00:19:58,111 --> 00:19:59,312
far too expensive to draw.

338
00:19:59,952 --> 00:20:04,897
Using a tier 2 H-slide, we trimmed the triangles from that particular vantage, reducing the

339
00:20:04,937 --> 00:20:05,417
GPU.

340
00:20:06,038 --> 00:20:09,220
Once the player drops down, the sightline is contained, and we restore the view.

341
00:20:12,781 --> 00:20:13,721
transition is not perceivable.

342
00:20:23,443 --> 00:20:26,504
Given the H-slide's effectiveness at reducing overdraw,

343
00:20:26,744 --> 00:20:29,424
we opted to set our H-slides to always be visible

344
00:20:29,744 --> 00:20:32,245
and replace the source meshes entirely.

345
00:20:32,825 --> 00:20:36,046
This had numerous benefits from removing H-slide transition pops,

346
00:20:36,526 --> 00:20:40,847
lighting LOD pops, saving memory by eliminating source mesh lightmaps,

347
00:20:41,365 --> 00:20:45,228
And it improved the PCB computation time

348
00:20:46,009 --> 00:20:47,750
because we had far less static meshes

349
00:20:47,790 --> 00:20:49,331
to compute for pre-computed visibility.

350
00:20:50,292 --> 00:20:52,614
And Unreal's internal HLOD mechanics

351
00:20:52,674 --> 00:20:55,996
allowed for us to leverage the source mesh collisions, which

352
00:20:56,036 --> 00:20:58,819
were instanced, keeping our memory footprint nice and low

353
00:20:58,839 --> 00:20:59,499
for our collisions.

354
00:21:00,100 --> 00:21:01,941
With our memory gains, we could actually

355
00:21:02,001 --> 00:21:04,643
go back through and increase the lightmap resolution

356
00:21:04,683 --> 00:21:05,524
of all of our HLODs.

357
00:21:09,737 --> 00:21:11,478
Despite the effectiveness of our HLADs,

358
00:21:11,618 --> 00:21:14,380
we still encountered occasions of GPU performance drops,

359
00:21:14,580 --> 00:21:16,141
notably during intense combat.

360
00:21:16,642 --> 00:21:18,303
Nothing breaks immersion like a game stall.

361
00:21:19,544 --> 00:21:21,265
One thing that we pursued early on

362
00:21:21,465 --> 00:21:24,767
was to implement dynamic resolution on the Oculus Quest,

363
00:21:25,207 --> 00:21:27,148
which currently functions on Oculus Rift

364
00:21:27,248 --> 00:21:30,230
by dynamically modifying the render target size.

365
00:21:30,891 --> 00:21:33,072
Modifying the render target size, though, on Quest

366
00:21:33,112 --> 00:21:33,933
was out of the question,

367
00:21:34,333 --> 00:21:36,374
as it requires a reallocation of memory

368
00:21:36,414 --> 00:21:37,615
that is far too expensive.

369
00:21:38,336 --> 00:21:38,736
I'm stabbing.

370
00:21:39,801 --> 00:21:42,543
One of our rendering engineers looked into mimicking this behavior

371
00:21:42,624 --> 00:21:44,565
by simply adjusting the viewport size.

372
00:21:45,146 --> 00:21:46,827
And this had no incurred expenses.

373
00:21:47,528 --> 00:21:49,990
Once functioning, we were able to gradually apply and remove

374
00:21:50,531 --> 00:21:52,953
this offset during moments of GPU overage,

375
00:21:53,073 --> 00:21:54,734
which was really helpful in just a pinch.

376
00:21:59,198 --> 00:22:01,740
Those render side optimizations opened the door

377
00:22:01,781 --> 00:22:03,662
to applying a few render side adjustments.

378
00:22:04,403 --> 00:22:06,465
We integrated the use of stereo layers in our game.

379
00:22:07,629 --> 00:22:09,410
game menus and subtitles.

380
00:22:09,850 --> 00:22:13,691
Since stair layers are drawn to an independent render target,

381
00:22:14,091 --> 00:22:16,792
they benefit from crisp text and displays

382
00:22:17,152 --> 00:22:18,333
with aliasing disabled.

383
00:22:18,953 --> 00:22:22,254
One of our challenges though, by our engineers to overcome

384
00:22:22,314 --> 00:22:24,635
though, was to bring the hands over the menu.

385
00:22:25,115 --> 00:22:26,215
We couldn't use a depth test.

386
00:22:28,094 --> 00:22:30,136
then draw behind other objects within the scene.

387
00:22:30,757 --> 00:22:33,199
But instead we found a solution contained

388
00:22:33,219 --> 00:22:35,322
within the Oculus SDK for Android

389
00:22:35,762 --> 00:22:38,765
that allows for the creation of a poke a hole material

390
00:22:39,085 --> 00:22:41,188
which essentially acts as a depth layer

391
00:22:41,648 --> 00:22:43,009
to composite against the stereo layer.

392
00:22:44,211 --> 00:22:45,072
Another feature we added

393
00:22:45,112 --> 00:22:47,234
for increased reflection detail on surfaces.

394
00:22:47,729 --> 00:22:49,730
was mobile parallax reflections.

395
00:22:50,150 --> 00:22:52,671
This allowed for a lighting team to place specific lighting

396
00:22:52,791 --> 00:22:55,832
objects and sources to capture accurately reflected

397
00:22:57,073 --> 00:22:58,573
reflections within our surfaces.

398
00:22:59,513 --> 00:23:02,735
Another solution our engineering team provided us with

399
00:23:02,915 --> 00:23:05,256
was the inclusion of decals in forward rendering.

400
00:23:05,976 --> 00:23:08,577
Unreal only supports decals in deferred.

401
00:23:09,077 --> 00:23:10,798
But we were able to mirror a technique

402
00:23:10,818 --> 00:23:14,199
from a previous GDC talk that allowed for up to two decals

403
00:23:14,219 --> 00:23:14,879
per primitive.

404
00:23:19,242 --> 00:23:23,945
Vertex animation proved to be an efficient means for storing and delivering large amounts of animation data.

405
00:23:24,706 --> 00:23:30,730
Whereas joint-driven animation roughly capped out at about 200 to 250 joints per animatable object,

406
00:23:31,010 --> 00:23:36,794
we found with a mobile GPU we could handily support upwards of 4,000 objects utilizing vertex animation.

407
00:23:37,334 --> 00:23:40,436
This allowed for us to use traditional film tools for destruction elements.

408
00:23:40,976 --> 00:23:44,398
As opposed to storing animation data within individual vertices,

409
00:23:44,759 --> 00:23:48,241
vertex animation rigidbodies can store their animation per component.

410
00:23:48,642 --> 00:23:49,742
allow for greater quantities.

411
00:23:50,482 --> 00:23:52,924
We couple this with positioning by turning an interpolation

412
00:23:52,944 --> 00:23:56,866
to reduce the data to exercises as well as procedural overrides

413
00:23:56,926 --> 00:23:58,746
to further maximize gain performance.

414
00:24:02,748 --> 00:24:04,989
Unreal's hierarchical instancing system

415
00:24:05,029 --> 00:24:08,951
provides an efficient means at clustered draw call reduction,

416
00:24:09,412 --> 00:24:12,173
LOD support, and viewport frustum calling for instances.

417
00:24:12,853 --> 00:24:15,755
We tapped into overriding a per instance random float.

418
00:24:16,392 --> 00:24:18,492
passing individual instance arguments

419
00:24:18,772 --> 00:24:21,293
to drive unique characteristics and control our instances.

420
00:24:22,013 --> 00:24:24,353
One example of this was our customized foliage system.

421
00:24:25,233 --> 00:24:28,554
We combined several offset variations of each foliage type

422
00:24:28,714 --> 00:24:29,614
into a single mesh,

423
00:24:30,114 --> 00:24:32,655
and then use a texture driven vertex deformation

424
00:24:32,815 --> 00:24:35,155
along with unique baked texture atlases

425
00:24:35,195 --> 00:24:38,176
to create variation with minimal draw on GPU effect.

426
00:24:39,276 --> 00:24:42,817
Scene lighting was then passed into the emissive materials

427
00:24:42,897 --> 00:24:45,597
by pre-sampling the nearest light probes to each instance.

428
00:24:45,983 --> 00:24:50,985
and baking those values into a color lookup table, which we could then reference in the

429
00:24:51,025 --> 00:24:55,507
material using baked IDs that were set through the for instance parameter.

430
00:24:56,107 --> 00:24:59,469
This approach scaled our viewable foliage from the 20s up to the 200s.

431
00:25:03,270 --> 00:25:06,712
Another use case for instancing a couple of vertex animation were crowds.

432
00:25:07,152 --> 00:25:13,995
Here we would take our traditional film crowd simulations, extract per-component animations,

433
00:25:14,528 --> 00:25:16,349
Store that within the data texture,

434
00:25:16,449 --> 00:25:18,830
mapping IDs to the source mesh UVs.

435
00:25:19,670 --> 00:25:22,232
For Unreal, on the Unreal side, we

436
00:25:22,252 --> 00:25:26,434
set up a Blueprint system to assign those individual instance

437
00:25:26,574 --> 00:25:29,195
IDs from data files right now from Houdini.

438
00:25:29,935 --> 00:25:31,196
Further variation can be achieved

439
00:25:31,236 --> 00:25:34,978
through packing multiple assets together, as well as

440
00:25:35,378 --> 00:25:37,219
texture atlasing variants.

441
00:25:42,241 --> 00:25:48,602
And here's a wonderful example of that process delivered by one of our FX team members that really helped bring life to Black Spire Outposts.

442
00:25:57,164 --> 00:26:05,826
Combining these processes together was how we were able to achieve the final growth system in the Jedi Legend for the engaging conclusion of Part One of our experience.

443
00:26:06,446 --> 00:26:11,807
Here we needed a system that would spawn and generate corruption growth over various surfaces within our final map.

444
00:26:12,286 --> 00:26:14,347
supporting hundreds of growing instance finds.

445
00:26:14,927 --> 00:26:16,648
We really wanted to engage all the senses

446
00:26:16,768 --> 00:26:19,529
and provide you a means to interact with the environment

447
00:26:19,549 --> 00:26:20,249
with a light saber.

448
00:26:20,849 --> 00:26:22,010
This would not have been possible

449
00:26:22,050 --> 00:26:23,690
without utilizing some of the techniques

450
00:26:23,790 --> 00:26:24,911
we presented here today.

451
00:26:30,053 --> 00:26:31,633
In summary, we learned a great deal

452
00:26:31,673 --> 00:26:34,374
about core performance optimization methods

453
00:26:34,514 --> 00:26:37,376
in designing a VR project on mobile.

454
00:26:38,176 --> 00:26:39,797
Using those practices as a core

455
00:26:42,315 --> 00:26:45,397
and breadth of our work on higher-end processors.

456
00:26:49,440 --> 00:26:53,623
We'd like to give special thanks today for the support teams at Oculus, Unreal Engine,

457
00:26:53,944 --> 00:26:59,568
GDC for hosting this talk, and the entire XLAB team from production, engineering,

458
00:26:59,768 --> 00:27:03,871
QA, and the artist teams. We're really privileged to be here to represent them today.

459
00:27:06,913 --> 00:27:11,137
And thank you for joining our talk today, Star Wars Tales from the Galaxy's Edge Part 2.

460
00:27:16,917 --> 00:27:18,939
next time. Thank you.

