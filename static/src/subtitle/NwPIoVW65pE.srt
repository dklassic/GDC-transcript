1
00:00:05,517 --> 00:00:12,642
Everybody. All right. So I think one of the things that's changed a lot over the last

2
00:00:12,702 --> 00:00:18,367
few years in independent game development is physics engines used to just be this gimmick

3
00:00:18,427 --> 00:00:24,491
that was used for games like Stair Dismount. But they're now used in a lot of indie action

4
00:00:24,531 --> 00:00:28,534
games. And I think maybe even most of them, right? So indie developers used to...

5
00:00:29,714 --> 00:00:33,418
roll their own really simple arcade style physics from scratch.

6
00:00:34,299 --> 00:00:37,443
But I think most people now, probably most of the people in this room, just use an engine

7
00:00:37,503 --> 00:00:44,592
like PhysX or Box2D because that's what comes rolled into Unity or Unreal or whatever it

8
00:00:44,652 --> 00:00:46,133
is that you might be using, Cocos2D.

9
00:00:48,412 --> 00:00:51,654
And the downside of that is it's hard to get a modern physics

10
00:00:51,714 --> 00:00:53,835
engine to behave just how you want it to, right?

11
00:00:53,915 --> 00:00:56,797
So indie teams don't usually have a physics expert.

12
00:00:57,458 --> 00:00:58,418
They probably don't even have a person

13
00:00:58,438 --> 00:01:01,020
who gets the basics of how the physics engine works

14
00:01:01,080 --> 00:01:01,540
under the hood.

15
00:01:01,560 --> 00:01:04,702
We're just a bunch of designers messing around with middleware.

16
00:01:04,742 --> 00:01:07,103
So we're starting to see a lot of games, I think,

17
00:01:07,303 --> 00:01:10,585
with physics that are glitchy or unreliable,

18
00:01:10,766 --> 00:01:14,108
or much more often than that, the kind of dreaded word,

19
00:01:14,188 --> 00:01:15,408
games that are floaty.

20
00:01:17,407 --> 00:01:19,987
And floaty isn't a precise term, right?

21
00:01:20,027 --> 00:01:21,347
Like, that's a vague term.

22
00:01:21,387 --> 00:01:23,328
It's just a vague feeling you get when you're playing a game.

23
00:01:23,348 --> 00:01:24,788
And I think there's a few different things that

24
00:01:24,808 --> 00:01:25,989
can make a game feel floaty.

25
00:01:26,569 --> 00:01:28,309
So for example, a game can feel floaty

26
00:01:28,329 --> 00:01:31,130
because the gravity is too low, which means it takes a long time

27
00:01:31,190 --> 00:01:33,470
after I jump in a platformer for me to land again.

28
00:01:33,490 --> 00:01:36,091
And things really accelerate slowly in the air.

29
00:01:36,411 --> 00:01:38,992
This, of course, is Limbo.

30
00:01:39,012 --> 00:01:41,012
It's one of my favorite indie games of all time,

31
00:01:41,052 --> 00:01:44,993
but I think also representative of a large crop of indie games

32
00:01:45,033 --> 00:01:46,953
with floaty platforming physics.

33
00:01:48,508 --> 00:01:51,108
A game can feel floaty if objects have no mass,

34
00:01:51,168 --> 00:01:54,269
which makes them feel like cheap props made out of styrofoam.

35
00:01:54,309 --> 00:01:57,230
They fly away when you touch them and they don't push back on anything.

36
00:01:59,070 --> 00:02:00,610
And sometimes games feel floaty because it just,

37
00:02:01,090 --> 00:02:03,691
it just seems like objects have no mass even though they do,

38
00:02:03,751 --> 00:02:06,152
because they skate along the ground without slowing down,

39
00:02:06,212 --> 00:02:07,212
like empty boxes,

40
00:02:07,232 --> 00:02:09,452
or because they travel through each other like,

41
00:02:09,772 --> 00:02:11,713
like ghosts instead of colliding with things.

42
00:02:12,719 --> 00:02:15,620
And, you know, I feel okay calling out floatiness in other people's games,

43
00:02:15,700 --> 00:02:17,922
because I made QWOP, which I think is probably

44
00:02:18,682 --> 00:02:21,404
the worst floatiest game of all time.

45
00:02:22,824 --> 00:02:25,826
He's in moon gravity. His feet slide along the ground,

46
00:02:25,986 --> 00:02:27,587
and his body is tremendously weak.

47
00:02:27,607 --> 00:02:30,829
His joints are kind of spongy like foam rubber,

48
00:02:30,889 --> 00:02:34,351
and, you know, so I think I'm the world's premier expert

49
00:02:34,811 --> 00:02:35,772
at making a game floaty.

50
00:02:36,677 --> 00:02:39,138
But I've been getting a little bit better at not doing that too.

51
00:02:39,238 --> 00:02:41,719
So I thought I'd share some tips for other people who, like me,

52
00:02:41,959 --> 00:02:45,320
don't want to roll their own engines and just want to use a pre-built one.

53
00:02:46,861 --> 00:02:50,662
Action games generally feel best when they're fast and heavy.

54
00:02:50,682 --> 00:02:53,164
You want things to react quickly, hit hard.

55
00:02:53,684 --> 00:02:55,625
It makes a game feel more convincing.

56
00:02:55,665 --> 00:02:57,165
It tightens a sense of control.

57
00:02:57,645 --> 00:02:58,806
It makes the action cooler.

58
00:02:58,846 --> 00:02:59,806
It makes it more exciting.

59
00:03:00,911 --> 00:03:05,835
But when you make things move fast and hit hard, you're adding a lot of energy to the scene.

60
00:03:06,296 --> 00:03:08,698
You're basically pushing the engine to its limits.

61
00:03:09,738 --> 00:03:14,242
And when you push a physics engine past its limits, you get glitches and instability, right?

62
00:03:14,382 --> 00:03:17,825
Joints explode, things get stuck inside other things.

63
00:03:19,349 --> 00:03:23,492
objects fly off into space. So we dial our forces down, we slow things down, we

64
00:03:23,532 --> 00:03:25,453
reduce the mass and the energy in the scene,

65
00:03:25,913 --> 00:03:29,035
and we get this kind of floaty result. That's how floatiness occurs. And in fact

66
00:03:29,676 --> 00:03:32,858
it's for that reason that most game engines, including Unity,

67
00:03:33,338 --> 00:03:36,820
are set up with really floaty defaults, right? The default values for physics

68
00:03:37,621 --> 00:03:40,702
are there because it slows things down and protects you from glitchiness.

69
00:03:41,623 --> 00:03:47,068
But it is possible to reduce floatiness in your game and still keep things stable and glitch-free.

70
00:03:47,108 --> 00:03:51,452
And generally, I think that falls into the category of things that are the designer's job.

71
00:03:51,492 --> 00:03:57,698
It's a designer's job because some of the ways we fix physics problems involve changing the game design,

72
00:03:57,978 --> 00:04:02,142
redesigning the levels or the game mechanics so that problems don't arise.

73
00:04:02,823 --> 00:04:07,268
And all of the more technical ways we go about fixing physics problems

74
00:04:07,529 --> 00:04:10,132
are going to have an impact on how the game plays and how it feels.

75
00:04:10,172 --> 00:04:12,155
So I think of it as being a designer's job.

76
00:04:13,160 --> 00:04:19,104
So I'm going to try and give these tips with as little reference to code or to maths as possible.

77
00:04:19,304 --> 00:04:23,628
I'm going to start with the basics and then I'm going to get more surprising and more complex.

78
00:04:24,368 --> 00:04:28,331
So there's one very basic step that you can take to improve floatiness in your game

79
00:04:28,371 --> 00:04:33,515
that most indie designers neglect to do, which is to check your gravity and units.

80
00:04:34,916 --> 00:04:35,877
So for total realism...

81
00:04:36,667 --> 00:04:41,829
You have an average human being character should be about 1.7 meters tall, you know, 5 feet tall.

82
00:04:42,509 --> 00:04:45,670
And gravity should be about 9.8 meters per second squared.

83
00:04:45,690 --> 00:04:48,211
And it would fall down something like that, right?

84
00:04:48,231 --> 00:04:49,792
That's sort of roughly how it would look.

85
00:04:51,352 --> 00:04:55,433
But gravity accelerates everything at the same rate, no matter how big it is and how heavy it is.

86
00:04:55,493 --> 00:04:58,775
So if you set your objects up to be too large, as in this case,

87
00:04:58,815 --> 00:05:00,715
they're going to look like they're falling incredibly slow.

88
00:05:01,669 --> 00:05:04,411
You need to make sure you're at least designing your objects

89
00:05:04,451 --> 00:05:07,392
so that they have a realistic size relative to the gravity you've set.

90
00:05:07,453 --> 00:05:10,634
Right? That's the first, most basic step to avoiding floatiness.

91
00:05:11,915 --> 00:05:13,736
But in fact, when you make an action game,

92
00:05:13,816 --> 00:05:17,539
you usually want to turn your gravity way up higher than a realistic level, right?

93
00:05:17,619 --> 00:05:20,520
Strong gravity is faster and more exciting.

94
00:05:20,540 --> 00:05:21,881
It makes everything feel better.

95
00:05:22,502 --> 00:05:24,543
And you know, in saying that, that shouldn't be news to any of you.

96
00:05:24,763 --> 00:05:28,745
Super Mario Bros. gravity is about nine times Earth's gravity.

97
00:05:30,602 --> 00:05:32,884
I mocked it up, this is how Mario would look

98
00:05:33,665 --> 00:05:36,287
with realistic gravity, assuming Mario is five feet tall.

99
00:05:36,347 --> 00:05:38,469
I think that is pretty floaty.

100
00:05:39,570 --> 00:05:41,051
All right, so what do you do, right?

101
00:05:41,172 --> 00:05:43,974
You're gonna turn up the gravity, turn it way up,

102
00:05:45,035 --> 00:05:47,097
make it more fun, suddenly you get problems.

103
00:05:47,117 --> 00:05:48,618
So this is one of the most common problems

104
00:05:48,638 --> 00:05:50,560
that you see with physics engines, it's called jitter.

105
00:05:51,541 --> 00:05:53,602
So an object that should fall down

106
00:05:53,722 --> 00:05:55,264
and come to rest on the ground sits there

107
00:05:55,284 --> 00:05:56,825
doing these little mini bounces forever.

108
00:05:59,202 --> 00:06:02,545
So to understand why that kind of thing happens and to avoid it,

109
00:06:03,086 --> 00:06:06,969
you kind of have to have a basic understanding of how collisions work in a physics engine.

110
00:06:07,550 --> 00:06:11,514
Now objects in a physics engine don't collide like things in real life do.

111
00:06:11,534 --> 00:06:14,456
So I'm just going to give you, like, the basics of this so you can understand it.

112
00:06:16,617 --> 00:06:20,761
The most important thing to know about a physics engine is that it works in two separate phases.

113
00:06:21,421 --> 00:06:24,323
So the first thing that happens is the engine tries to work out

114
00:06:24,564 --> 00:06:27,606
where everything would go if nothing could interact, if nothing could collide,

115
00:06:28,106 --> 00:06:29,568
using Newton's equations of motion.

116
00:06:29,668 --> 00:06:34,071
So it's a video game. We need to know what's going to happen every time we update the physics engine.

117
00:06:35,032 --> 00:06:38,475
So we update the position of every object based on how fast it's going

118
00:06:39,616 --> 00:06:43,639
and its speed or its velocity.

119
00:06:44,602 --> 00:06:46,464
And we update the velocity of every object

120
00:06:46,544 --> 00:06:48,525
according to its acceleration, including gravity.

121
00:06:49,046 --> 00:06:50,327
That's the kind of basic thing.

122
00:06:50,347 --> 00:06:51,268
That's the first step.

123
00:06:52,989 --> 00:06:55,531
At the end of that first step, you

124
00:06:55,571 --> 00:06:57,593
might have solid objects overlapping,

125
00:06:57,613 --> 00:06:58,553
because they couldn't interact.

126
00:06:58,794 --> 00:07:00,575
And all the joints will have come out of their sockets.

127
00:07:00,635 --> 00:07:04,038
So the second phase is what's called constraint resolution.

128
00:07:04,778 --> 00:07:06,440
Constraints is just this umbrella term

129
00:07:06,860 --> 00:07:08,781
that refers to collisions and joints.

130
00:07:09,682 --> 00:07:11,243
For collisions, this is how it works.

131
00:07:11,283 --> 00:07:13,145
The engine takes the overlapping object.

132
00:07:14,069 --> 00:07:17,194
and it moves it back out until it's no longer overlapping.

133
00:07:17,775 --> 00:07:19,217
And if it's an object that ought to bounce

134
00:07:19,257 --> 00:07:20,278
when this kind of thing happens,

135
00:07:20,299 --> 00:07:22,221
we looked at how far we had to move it back

136
00:07:22,642 --> 00:07:23,864
to stop it from overlapping,

137
00:07:24,565 --> 00:07:26,087
and then we calculate how much it should bounce

138
00:07:26,127 --> 00:07:26,708
according to that.

139
00:07:26,748 --> 00:07:29,532
So that's the basics of how collisions work in an engine.

140
00:07:31,059 --> 00:07:32,020
Same thing goes for joints.

141
00:07:32,760 --> 00:07:35,942
So everything gets, every object in your scene

142
00:07:35,962 --> 00:07:38,384
that's connected with joints, gets moved first

143
00:07:38,444 --> 00:07:39,885
as though they're not connected at all.

144
00:07:40,325 --> 00:07:42,207
They just generally get sucked down by gravity.

145
00:07:42,987 --> 00:07:45,429
And after that, the engine moves them back

146
00:07:46,069 --> 00:07:49,011
until they're in a place that's allowed by that joint.

147
00:07:49,071 --> 00:07:51,253
Right, so I'm exaggerating the effects a little bit here

148
00:07:51,293 --> 00:07:53,294
so you can see it, but this is basically what happens.

149
00:07:56,996 --> 00:07:57,096
Now.

150
00:07:58,144 --> 00:08:01,106
Since the movement phase and the collision phase are handled separately,

151
00:08:01,307 --> 00:08:04,390
you get a bunch of unexpected behaviors that you wouldn't see in the real world.

152
00:08:04,410 --> 00:08:05,651
So this is the most basic one.

153
00:08:06,371 --> 00:08:09,955
After every physics update, we move the objects according to their speed.

154
00:08:10,556 --> 00:08:15,220
If they're going fast, they may never overlap an object that you would expect them to collide with,

155
00:08:15,260 --> 00:08:16,701
and you'll never see a collision.

156
00:08:16,761 --> 00:08:17,742
So this is called tunneling.

157
00:08:18,743 --> 00:08:19,344
By the way, I should say...

158
00:08:20,206 --> 00:08:22,788
I captured all these animations from an actual Unity project,

159
00:08:22,808 --> 00:08:26,451
but I could have set them up just as easily in C++ Box2D,

160
00:08:27,052 --> 00:08:28,153
or in Unreal, or whatever.

161
00:08:28,173 --> 00:08:28,894
It would have been the same.

162
00:08:28,914 --> 00:08:31,936
And the most simple way to solve that

163
00:08:31,976 --> 00:08:34,458
is to make it so that less time passes between each update.

164
00:08:34,999 --> 00:08:37,120
So you set a smaller fixed time step.

165
00:08:38,001 --> 00:08:41,344
So in Unity, you can see here that the default value

166
00:08:41,364 --> 00:08:43,846
of your fixed time step is 0.02 seconds.

167
00:08:43,866 --> 00:08:46,788
So what that means is it's updating the physics engine

168
00:08:47,189 --> 00:08:47,909
50 times a second.

169
00:08:48,692 --> 00:08:51,914
which is good if you're running it on a Danish TV set, I guess,

170
00:08:52,634 --> 00:08:55,496
but totally insane on a computer or a console,

171
00:08:55,576 --> 00:08:59,218
especially in America, because your main update loop is probably running 60 times a second.

172
00:08:59,979 --> 00:09:04,041
So here I've set a much faster update rate, 120 physics updates per second,

173
00:09:04,321 --> 00:09:06,943
which costs me some physics, which costs me some CPU,

174
00:09:07,383 --> 00:09:08,284
but it solves the problem.

175
00:09:08,584 --> 00:09:10,265
So that's called the brute force solution.

176
00:09:10,950 --> 00:09:15,231
The other thing you can do is you can set fast-moving objects to use continuous collision detection,

177
00:09:16,151 --> 00:09:20,393
which prevents tunneling by looking for collisions all along the path of an object's motion.

178
00:09:20,753 --> 00:09:22,673
That costs quite a lot of CPU cycles.

179
00:09:22,953 --> 00:09:28,835
I should say, Unity actually has this long-standing bug where you can't switch that off in the 2D physics mode,

180
00:09:29,235 --> 00:09:32,376
but they're fixing it for the next update, so you'll start to see these problems.

181
00:09:33,217 --> 00:09:35,137
Yeah, so, continuous collision detection.

182
00:09:37,042 --> 00:09:39,343
Okay, so now we can understand why jitter happens, right?

183
00:09:39,363 --> 00:09:41,865
So every frame the ball is accelerating down with gravity,

184
00:09:42,405 --> 00:09:44,186
it's entering and overlapping the ground,

185
00:09:44,666 --> 00:09:46,147
and then the engine is pushing it back up

186
00:09:46,388 --> 00:09:47,588
until it's not overlapping the ground,

187
00:09:47,608 --> 00:09:49,369
and the engine has to interpret that as a bounce.

188
00:09:50,210 --> 00:09:51,912
So most designers get frustrated with that,

189
00:09:51,952 --> 00:09:53,493
and they wind up turning the gravity down,

190
00:09:53,913 --> 00:09:55,194
and you get a floaty result.

191
00:09:55,554 --> 00:09:56,455
So what should you do about that?

192
00:09:56,575 --> 00:09:58,657
Well, there's a special setting for jitter.

193
00:09:59,297 --> 00:10:01,319
Both Box2D and PhysX have this thing

194
00:10:01,359 --> 00:10:04,521
where you can specify a minimum speed for bouncing.

195
00:10:04,621 --> 00:10:05,762
It's a threshold value.

196
00:10:05,862 --> 00:10:09,465
So if the object lands slowly, it just sticks to the ground.

197
00:10:09,485 --> 00:10:10,325
It gets glued to the ground.

198
00:10:10,345 --> 00:10:12,667
It's not realistic, but it does solve the problem.

199
00:10:13,167 --> 00:10:15,089
So you can turn that value up, or again, you

200
00:10:15,109 --> 00:10:17,831
can mitigate the problem by just reducing the fixed time step.

201
00:10:20,380 --> 00:10:21,660
OK, slightly weirder stuff.

202
00:10:22,300 --> 00:10:24,521
The next thing you need to know about the constraint

203
00:10:24,781 --> 00:10:26,601
resolution phase is it doesn't know anything

204
00:10:26,641 --> 00:10:28,202
about the free movement phase, right?

205
00:10:28,222 --> 00:10:31,743
So if an object winds up overlapping another object

206
00:10:31,783 --> 00:10:33,043
at the end of the movement phase,

207
00:10:33,583 --> 00:10:34,883
the engine doesn't know which direction

208
00:10:34,923 --> 00:10:36,104
the object came from, right?

209
00:10:36,344 --> 00:10:37,644
It just moves it back to whatever

210
00:10:37,704 --> 00:10:40,105
is the closest edge of the overlapping object.

211
00:10:40,465 --> 00:10:42,465
So you get situations like this where the ball bounces out

212
00:10:42,505 --> 00:10:45,406
the wrong way because the closest edge is the wrong edge.

213
00:10:47,630 --> 00:10:49,651
If you reduce your time step, you make it more likely

214
00:10:49,691 --> 00:10:51,111
the engine will find the correct edge.

215
00:10:51,191 --> 00:10:53,232
Or again, you can enable continuous collisions

216
00:10:53,272 --> 00:10:54,693
so the ball doesn't go past the edge.

217
00:10:58,755 --> 00:11:00,116
The other main thing that you need to know

218
00:11:00,176 --> 00:11:01,656
about collisions in these engines

219
00:11:01,736 --> 00:11:04,538
is that they get resolved one pair of bodies at a time.

220
00:11:05,318 --> 00:11:07,479
Each pair of bodies is only considered once

221
00:11:07,539 --> 00:11:09,040
every time the physics engine is updated.

222
00:11:09,120 --> 00:11:11,741
So the engine pushes apart the first pair

223
00:11:11,781 --> 00:11:14,622
of overlapping bodies that it finds, and then the second.

224
00:11:16,049 --> 00:11:17,209
and then so on, right?

225
00:11:17,429 --> 00:11:19,390
So we don't come back to that first pair of objects

226
00:11:19,430 --> 00:11:21,311
until the next iteration of the engine.

227
00:11:21,971 --> 00:11:23,091
If you walk that through in your head,

228
00:11:23,111 --> 00:11:24,352
if you think about how that's going to work,

229
00:11:24,392 --> 00:11:25,893
you'll realize that you'll definitely have

230
00:11:26,053 --> 00:11:27,773
a bunch of bodies that are still overlapping

231
00:11:27,813 --> 00:11:28,774
at the end of the process.

232
00:11:29,614 --> 00:11:32,275
So because of that, when you have long chains of bodies,

233
00:11:33,616 --> 00:11:35,336
big stacks of bodies that are colliding,

234
00:11:35,416 --> 00:11:36,717
or chains of joints,

235
00:11:37,769 --> 00:11:40,130
They take time to finish colliding with each other, right?

236
00:11:40,150 --> 00:11:42,111
So that's why you see this kind of sponginess,

237
00:11:42,171 --> 00:11:45,492
which is why the joints in QWOP, for example, are really spongy.

238
00:11:46,552 --> 00:11:48,313
And you can use that to your advantage, right?

239
00:11:48,353 --> 00:11:52,234
So the pole in Super Pole Riders uses the same principle.

240
00:11:52,274 --> 00:11:56,496
The pole is made up of a whole bunch of pole segments

241
00:11:56,576 --> 00:11:58,596
that are connected by rigid weld joints.

242
00:11:58,636 --> 00:12:01,077
So in theory, really what I'm telling the engineers,

243
00:12:01,537 --> 00:12:02,578
the pole shouldn't bend at all.

244
00:12:02,618 --> 00:12:05,139
It's made up of a bunch of bricks that are welded together.

245
00:12:06,059 --> 00:12:06,279
But...

246
00:12:07,117 --> 00:12:09,298
Because it can only correct the positions of these segments

247
00:12:09,698 --> 00:12:10,578
one pair at a time,

248
00:12:11,198 --> 00:12:14,659
you can never get the pole back to perfectly straight in one pass.

249
00:12:15,320 --> 00:12:17,200
So it takes time for the pole to get back to straight

250
00:12:17,640 --> 00:12:19,321
and you get this kind of bendy appearance.

251
00:12:19,641 --> 00:12:21,441
So, you know, I wanted that for this game,

252
00:12:21,461 --> 00:12:23,402
but if you want to minimize that kind of rubberiness

253
00:12:23,482 --> 00:12:24,562
rather than maximizing it,

254
00:12:24,982 --> 00:12:26,223
you should try to design the objects

255
00:12:26,243 --> 00:12:29,204
so they aren't made out of long chains of connected objects

256
00:12:29,264 --> 00:12:30,264
or stacks of bodies.

257
00:12:31,087 --> 00:12:33,289
And I keep coming back to this point about design,

258
00:12:33,349 --> 00:12:35,270
because this really is a job for a designer, right?

259
00:12:35,290 --> 00:12:37,471
The mechanics of the game depend deeply

260
00:12:38,071 --> 00:12:39,632
on how you construct your physics scene.

261
00:12:39,993 --> 00:12:42,074
You can't depend on programmers for you,

262
00:12:42,254 --> 00:12:44,335
artists to do that for you, assuming you even

263
00:12:44,375 --> 00:12:47,377
have a separate programmer or an artist on your indie team.

264
00:12:49,231 --> 00:12:50,873
So that kind of bendiness and sponginess,

265
00:12:50,913 --> 00:12:52,675
you can reduce the effect by turning up

266
00:12:52,695 --> 00:12:54,618
the number of iterations in the physics solver, which

267
00:12:54,658 --> 00:12:56,941
allows these pairs to be analyzed multiple times

268
00:12:56,981 --> 00:13:00,605
in each fixed update, or by reducing the fixed time step

269
00:13:00,645 --> 00:13:00,866
again.

270
00:13:00,906 --> 00:13:02,928
But the effect is always going to be there no matter what.

271
00:13:02,968 --> 00:13:04,350
So you need to design with it in mind.

272
00:13:06,319 --> 00:13:11,763
There's one other weird side effect of this pairwise approach to collision resolution,

273
00:13:11,803 --> 00:13:14,966
which is that things get stuck when you don't expect them to get stuck.

274
00:13:15,046 --> 00:13:17,708
So, I remember a few slides ago, I showed you this case

275
00:13:17,728 --> 00:13:20,009
where the ball bounces out the wrong side of this object.

276
00:13:21,110 --> 00:13:22,031
What if we add another block?

277
00:13:23,112 --> 00:13:25,654
So in a case like this, the ball is pushed away from the top block

278
00:13:26,254 --> 00:13:27,935
before it gets pushed away from the bottom one.

279
00:13:28,236 --> 00:13:30,137
And neither block knows about the other one.

280
00:13:30,417 --> 00:13:33,019
It's just pushing the ball out to the nearest edge and forgetting about it.

281
00:13:33,440 --> 00:13:34,240
So the ball gets stuck.

282
00:13:35,310 --> 00:13:36,831
And that's the culprit, I think, a lot of the time

283
00:13:36,851 --> 00:13:38,793
when you see stuck bodies in physics games.

284
00:13:38,973 --> 00:13:40,554
People really have a lot of trouble solving that.

285
00:13:41,495 --> 00:13:43,516
So adding more iterations here won't help.

286
00:13:43,556 --> 00:13:46,078
You need to make sure that the initial collision works

287
00:13:46,118 --> 00:13:47,379
and goes out to the correct side,

288
00:13:47,779 --> 00:13:49,120
either by reducing the time step

289
00:13:49,260 --> 00:13:50,541
or using continuous collisions.

290
00:13:51,221 --> 00:13:53,703
Or sometimes you can also, it can help to add

291
00:13:53,743 --> 00:13:56,505
like a redundant collider there to fill in the gaps,

292
00:13:56,545 --> 00:13:58,566
to give the object a hint which way it should go

293
00:13:58,606 --> 00:13:59,607
to get out of being stuck.

294
00:14:00,087 --> 00:14:02,649
So again, it's the job of the designer, not the programmer.

295
00:14:04,416 --> 00:14:05,182
One other note on this.

296
00:14:06,201 --> 00:14:08,943
When you're creating a polygon or mesh collider that's concave,

297
00:14:09,183 --> 00:14:11,264
the engine will break it up into convex shapes for you.

298
00:14:11,304 --> 00:14:13,606
So here I'm building a collider for this cricket bat in Unity,

299
00:14:13,626 --> 00:14:17,388
and you can see it's breaking it up into triangular sub-colliders as I go.

300
00:14:17,948 --> 00:14:19,809
But each sub-collider is a separate shape.

301
00:14:20,410 --> 00:14:23,091
Makes it a... gets considered separately by the engine.

302
00:14:23,392 --> 00:14:25,193
So objects can get stuck in between them.

303
00:14:25,453 --> 00:14:26,494
And it can be a bit bewildering.

304
00:14:26,954 --> 00:14:28,815
So you just need to be aware that when you're using

305
00:14:28,895 --> 00:14:30,456
concave shapes for your colliders,

306
00:14:30,476 --> 00:14:31,877
you're going to see that kind of thing.

307
00:14:31,917 --> 00:14:35,159
You should probably try to avoid using concave shapes if you're able to.

308
00:14:37,292 --> 00:14:38,633
All right, so as I said at the beginning,

309
00:14:39,674 --> 00:14:42,196
one of the major reasons why we say a game is floaty

310
00:14:42,236 --> 00:14:43,937
is that the objects appear too light.

311
00:14:44,057 --> 00:14:45,058
We want objects to look like

312
00:14:45,078 --> 00:14:46,539
they've got a realistic amount of mass.

313
00:14:47,820 --> 00:14:49,161
But it's not just a matter of turning up

314
00:14:49,181 --> 00:14:50,001
the mass on everything.

315
00:14:50,702 --> 00:14:52,103
When you've got two objects colliding,

316
00:14:52,143 --> 00:14:54,285
you expect the lighter object to be bounced away fast

317
00:14:54,325 --> 00:14:55,946
and the heavy object to keep on moving.

318
00:14:56,846 --> 00:14:58,668
So here it's the behavior of the light body

319
00:14:58,828 --> 00:15:00,789
which makes the heavy body look heavy, right?

320
00:15:01,150 --> 00:15:03,872
The big block looks heavy because the small ball

321
00:15:03,892 --> 00:15:06,333
looks like it's gonna be knocked away fast.

322
00:15:07,505 --> 00:15:10,088
here the ball seems extremely heavy, right?

323
00:15:10,128 --> 00:15:13,312
So the important thing is the ratio of the ball's mass

324
00:15:13,432 --> 00:15:14,133
to the block's mass.

325
00:15:14,153 --> 00:15:16,275
That's called the mass ratio in physics terms.

326
00:15:16,376 --> 00:15:18,718
So you set your masses so that objects

327
00:15:18,758 --> 00:15:19,820
that should be heavy are heavy,

328
00:15:20,260 --> 00:15:21,822
and objects that should be light are light.

329
00:15:21,882 --> 00:15:24,105
And it's good to have a few of each for contrast

330
00:15:24,165 --> 00:15:25,767
so that the heavy things can really look heavy.

331
00:15:27,336 --> 00:15:30,419
If you use straight box 2D in C++,

332
00:15:30,459 --> 00:15:32,401
it will calculate masses for all the objects

333
00:15:32,441 --> 00:15:33,361
based on their size.

334
00:15:33,982 --> 00:15:36,164
But Unity defaults everything to one kilogram.

335
00:15:36,184 --> 00:15:39,287
So this is using the default one kilogram mass.

336
00:15:40,127 --> 00:15:42,610
So the mass ratio of collisions is always one to one.

337
00:15:42,670 --> 00:15:44,291
So you've got a one kilogram hammer,

338
00:15:44,351 --> 00:15:46,593
sledgehammer colliding with a one kilogram balloon,

339
00:15:46,613 --> 00:15:48,815
and I think that makes it look pretty floaty.

340
00:15:49,636 --> 00:15:51,578
You know, I should set the hammer to be

341
00:15:51,998 --> 00:15:53,920
far heavier than the balloon if I want it to look real.

342
00:15:55,197 --> 00:15:57,097
You might wonder why would Unity do that?

343
00:15:57,157 --> 00:15:58,998
Why would they default everything to one kilogram?

344
00:15:59,018 --> 00:16:00,218
It's not crazy in this case.

345
00:16:00,258 --> 00:16:02,478
The reason is it helps to avoid glitches.

346
00:16:02,498 --> 00:16:05,959
Like so much of the source of floatiness comes down to this.

347
00:16:06,499 --> 00:16:09,840
So remember that the engine resolves constraints in pairs, right?

348
00:16:09,920 --> 00:16:13,301
And remember that light objects are bounced off heavy ones really, really fast.

349
00:16:13,741 --> 00:16:14,961
So what would you expect to happen here?

350
00:16:15,001 --> 00:16:18,282
I mean, what you want to happen is that the ball is going to sit still.

351
00:16:18,302 --> 00:16:19,883
It's going to be wedged between these two blocks.

352
00:16:21,202 --> 00:16:22,663
But because it's much lighter than those blocks,

353
00:16:22,703 --> 00:16:24,484
it's going to bounce away fast from the top one,

354
00:16:25,204 --> 00:16:27,245
and it's going to bounce away fast from the bottom one,

355
00:16:28,025 --> 00:16:30,386
and you get this unstable situation.

356
00:16:30,846 --> 00:16:33,127
So you can fix this if you set the ball

357
00:16:33,187 --> 00:16:35,929
so that the mass is closer to the mass of the blocks,

358
00:16:36,609 --> 00:16:37,969
but then it's going to seem floaty, right?

359
00:16:38,009 --> 00:16:40,731
Because it will make the blocks seem lighter by comparison.

360
00:16:40,751 --> 00:16:43,412
So you need to strike a balance between floatiness and stability.

361
00:16:44,712 --> 00:16:45,613
Same thing goes for joints.

362
00:16:46,530 --> 00:16:48,312
So remember, joints are resolved in the same way

363
00:16:48,352 --> 00:16:51,494
as collisions are in pairs after the free movement phase.

364
00:16:51,634 --> 00:16:52,975
So they've got these two springs here,

365
00:16:52,995 --> 00:16:55,437
and they're taking turns to pull really hard

366
00:16:55,497 --> 00:16:56,818
on this small, lightweight ball.

367
00:16:57,939 --> 00:16:59,540
So it gets moved a lot by each spring,

368
00:16:59,780 --> 00:17:01,842
and that's very unstable as well.

369
00:17:01,882 --> 00:17:03,403
So that's probably the number one reason

370
00:17:03,463 --> 00:17:05,264
why people have trouble with joints in games,

371
00:17:05,304 --> 00:17:06,325
especially with ragdolls.

372
00:17:08,047 --> 00:17:09,868
So if you try to set it so that the ball and the block

373
00:17:09,908 --> 00:17:12,850
have similar masses, then nothing's

374
00:17:12,870 --> 00:17:15,472
being pulled up too fast, and you get a more stable simulation.

375
00:17:17,071 --> 00:17:20,341
albeit much floatier and much less realistic.

376
00:17:20,923 --> 00:17:21,906
The same thing goes for the stack.

377
00:17:21,926 --> 00:17:23,831
So, you know, you're always balancing

378
00:17:23,891 --> 00:17:25,115
floatiness against stability.

379
00:17:27,612 --> 00:17:30,932
All right, so I've shown you some ways to keep things moving fast

380
00:17:31,032 --> 00:17:32,993
and looking heavy while avoiding glitches.

381
00:17:33,573 --> 00:17:37,194
But sometimes you have to give things an unrealistically heavy

382
00:17:37,294 --> 00:17:39,335
or a light mass for creative reasons.

383
00:17:39,475 --> 00:17:42,895
In fact, sometimes you just have to slow the whole thing down,

384
00:17:43,096 --> 00:17:46,076
either just to reduce glitches or because you want a slower game,

385
00:17:46,096 --> 00:17:48,077
it's getting too hard, it's going too fast,

386
00:17:48,137 --> 00:17:49,297
or just for aesthetic reasons.

387
00:17:49,337 --> 00:17:52,598
You know, maybe you just want your game to look slower.

388
00:17:53,318 --> 00:17:55,279
And it matters a lot in terms of floatiness,

389
00:17:55,559 --> 00:17:56,479
how you go about doing that.

390
00:17:57,516 --> 00:17:59,978
So physics engines, including Unity,

391
00:18:01,439 --> 00:18:03,681
include this drag feature that slows things down

392
00:18:03,721 --> 00:18:06,243
in direct proportion to how fast they're going.

393
00:18:06,343 --> 00:18:08,625
But to me, anyway, it looks super floaty.

394
00:18:09,185 --> 00:18:10,306
And it turns out the reason for that

395
00:18:10,346 --> 00:18:12,948
is that real objects hardly ever get slowed down

396
00:18:12,989 --> 00:18:15,631
by a force that's in linear proportion to how fast they're

397
00:18:15,651 --> 00:18:15,891
going.

398
00:18:16,471 --> 00:18:19,374
Only balloons and feathers should be slowed down that way.

399
00:18:21,075 --> 00:18:23,517
You can apply your own custom drag force

400
00:18:23,597 --> 00:18:26,159
that's proportional to the square of the velocity.

401
00:18:26,953 --> 00:18:29,155
then you'll get a more realistic way of slowing things down

402
00:18:29,175 --> 00:18:30,256
that doesn't look so floaty.

403
00:18:30,296 --> 00:18:33,639
It looks more like real air resistance, real water resistance.

404
00:18:33,699 --> 00:18:35,480
So that's called quadratic drag.

405
00:18:35,680 --> 00:18:38,202
Now, I know that probably looks subtle in that example.

406
00:18:38,963 --> 00:18:42,245
Trust me, it feels a lot better in the context of a real game.

407
00:18:45,347 --> 00:18:47,529
Sometimes when you set your mass values right,

408
00:18:48,070 --> 00:18:49,491
your objects look lightweight.

409
00:18:50,227 --> 00:18:51,948
like in the big rigs game,

410
00:18:52,428 --> 00:18:53,989
because they don't slow down fast enough

411
00:18:54,029 --> 00:18:55,469
when they're sliding around, right?

412
00:18:55,489 --> 00:18:57,650
So the first thing that you do is you turn up

413
00:18:57,670 --> 00:18:59,630
the friction value on all your materials, right?

414
00:18:59,650 --> 00:19:02,852
So Unity defaults to a reasonably low value for friction.

415
00:19:02,872 --> 00:19:04,192
A lot of people don't change their defaults.

416
00:19:05,240 --> 00:19:07,300
But even then you may still see them sliding around.

417
00:19:07,400 --> 00:19:10,041
And the reason for that is that your physics engine only

418
00:19:10,081 --> 00:19:13,101
applies friction force at points of contact.

419
00:19:13,221 --> 00:19:15,742
And in a situation like this, it's a ball.

420
00:19:15,822 --> 00:19:18,002
So there's only one single point of contact on the ground.

421
00:19:18,022 --> 00:19:19,363
And where the circle touches the ground,

422
00:19:19,703 --> 00:19:20,863
that's where the friction is applied.

423
00:19:20,883 --> 00:19:21,803
It's a low force.

424
00:19:22,303 --> 00:19:24,884
So the object slides a lot more than you expect it to,

425
00:19:25,424 --> 00:19:26,824
which makes it look as though it's light

426
00:19:26,884 --> 00:19:28,965
and doesn't have any mass pulling it towards the ground.

427
00:19:30,065 --> 00:19:33,086
So if you can't get enough of a sense of weight,

428
00:19:33,970 --> 00:19:38,552
with friction alone, you can use a custom quadratic drag force there as well.

429
00:19:38,972 --> 00:19:42,033
Which does a pretty good job, I think, of looking like strong friction even though it isn't.

430
00:19:42,213 --> 00:19:44,994
Makes the object look heavier and makes the whole thing less floaty.

431
00:19:45,514 --> 00:19:49,695
Don't use the inbuilt linear drag to solve the sliding problem.

432
00:19:51,676 --> 00:19:52,796
Okay, so one final point.

433
00:19:54,252 --> 00:19:55,533
This is a situation you see a lot.

434
00:19:55,573 --> 00:19:58,535
There's like this moving platform that's a kinematic body,

435
00:19:58,595 --> 00:20:00,157
which means I'm just telling it where it should be.

436
00:20:00,177 --> 00:20:01,598
And since it's kinematic,

437
00:20:01,638 --> 00:20:03,039
it can't be pushed back by the ball.

438
00:20:03,099 --> 00:20:05,000
So the ball has to bounce off the platform

439
00:20:05,821 --> 00:20:07,702
as well as off the ground and the block,

440
00:20:08,283 --> 00:20:09,844
all of which are static and can't move.

441
00:20:10,464 --> 00:20:11,405
So the ball glitches out

442
00:20:11,425 --> 00:20:13,627
because it's overlapping all these three objects

443
00:20:13,667 --> 00:20:14,948
and none of those objects can move

444
00:20:15,008 --> 00:20:15,988
and the engine just doesn't know

445
00:20:16,028 --> 00:20:17,329
which way it should be pushing the ball.

446
00:20:18,388 --> 00:20:20,589
Even if you didn't get a glitch in this kind of situation,

447
00:20:20,970 --> 00:20:22,410
you'd get a really floaty result,

448
00:20:22,550 --> 00:20:25,411
because the ball would be pushed away from the platform without pushing back,

449
00:20:25,671 --> 00:20:28,673
which would make it look like the platform had infinite mass

450
00:20:28,713 --> 00:20:30,774
and the ball had zero mass, like it was made out of air.

451
00:20:31,174 --> 00:20:32,374
So like everything else I've mentioned,

452
00:20:32,434 --> 00:20:35,595
like that's more of a design problem than a technical problem.

453
00:20:37,097 --> 00:20:41,238
I've created a level design here which is just asking the engine to do something it doesn't know how to do.

454
00:20:41,798 --> 00:20:44,839
So you try to avoid moving bodies just by setting their position.

455
00:20:44,859 --> 00:20:48,360
You try to avoid making objects that have to move kinematic

456
00:20:48,640 --> 00:20:52,301
unless you are sure that they're never going to wind up pushing on a dynamic object

457
00:20:52,341 --> 00:20:53,462
and making it look really light.

458
00:20:54,602 --> 00:20:58,123
Now you know that the, how the engine is solving collisions,

459
00:20:58,283 --> 00:21:00,324
you know, in two steps and pair by pair.

460
00:21:00,584 --> 00:21:03,625
You can do your best to design your game environments and your levels and so on

461
00:21:03,705 --> 00:21:06,426
so that these non-resolvable scenarios never occur.

462
00:21:09,558 --> 00:21:11,739
So I've given you a lot of stuff to tune

463
00:21:11,779 --> 00:21:13,340
to get the physics working just right, right?

464
00:21:13,360 --> 00:21:14,960
You have a complex scene like this one

465
00:21:15,000 --> 00:21:17,221
with a lot of joints and a lot of different bodies.

466
00:21:17,902 --> 00:21:20,723
You need to tweak masses, joint strength, gravity,

467
00:21:21,623 --> 00:21:23,944
all these engine parameters for every single object.

468
00:21:24,384 --> 00:21:25,945
And the default values are almost never

469
00:21:26,025 --> 00:21:26,886
exactly what you want.

470
00:21:27,386 --> 00:21:30,187
And you probably don't know beforehand what you want.

471
00:21:30,267 --> 00:21:32,728
So it's almost an impossible tuning problem.

472
00:21:33,589 --> 00:21:35,790
You might have to change dozens of different parameters

473
00:21:35,830 --> 00:21:37,731
just to get it to work something like how you want it.

474
00:21:37,791 --> 00:21:39,892
So I was stuck for about a year with this game,

475
00:21:40,712 --> 00:21:43,213
trying to tune it to the point where the horse could just make it

476
00:21:43,253 --> 00:21:44,614
from the right of the screen to the left.

477
00:21:46,160 --> 00:21:48,801
And I only managed to get it working when I hooked up a MIDI,

478
00:21:49,121 --> 00:21:52,203
a USB MIDI mixer controller with eight sliders and eight knobs

479
00:21:52,443 --> 00:21:54,484
to 16 of the physics variables at once,

480
00:21:54,964 --> 00:21:56,145
so I could tweak them all at once.

481
00:21:56,585 --> 00:21:59,046
And even now, I think it sort of remains a little bit floaty.

482
00:21:59,066 --> 00:22:01,328
So, you know, I'm trying hard to work this stuff out myself,

483
00:22:01,448 --> 00:22:03,589
but, you know, what I'm finding is, gradually,

484
00:22:03,909 --> 00:22:05,750
you can almost always get the effect you want

485
00:22:05,830 --> 00:22:08,872
if you work hard enough on redesign and on tuning.

486
00:22:09,917 --> 00:22:11,757
I made a little demo of how I would do that.

487
00:22:12,477 --> 00:22:14,398
This MIDI controller setup is really easy to do.

488
00:22:15,078 --> 00:22:17,698
I made this example from scratch, like with nothing,

489
00:22:18,398 --> 00:22:21,099
in about half an hour using the free program MIDI Bridge

490
00:22:21,919 --> 00:22:25,240
and a Korg NanoControl MIDI controller,

491
00:22:25,260 --> 00:22:27,160
which costs about $40 now on Amazon.

492
00:22:28,421 --> 00:22:30,561
If you don't have a MIDI controller, you could use a flight stick,

493
00:22:30,621 --> 00:22:33,482
or a touchpad, or anything that's giving you this kind of fine,

494
00:22:33,542 --> 00:22:34,602
multi-dimensional control.

495
00:22:35,718 --> 00:22:38,380
You can also just put mouse slider objects on the screen

496
00:22:38,400 --> 00:22:39,460
that you can move with the mouse.

497
00:22:39,480 --> 00:22:41,541
It's not quite as good, but it's better than nothing.

498
00:22:41,941 --> 00:22:43,642
I think if you try to tune your physics game

499
00:22:43,782 --> 00:22:45,423
one variable at a time, you're making life

500
00:22:45,543 --> 00:22:46,623
incredibly difficult for yourself.

501
00:22:46,643 --> 00:22:47,584
It's almost impossible.

502
00:22:49,064 --> 00:22:53,786
Okay, so I know that was a lot to digest in 25 minutes,

503
00:22:54,547 --> 00:22:57,048
but I came up with a couple of goofy mnemonics

504
00:22:57,528 --> 00:22:58,508
to help you out with this.

505
00:22:59,969 --> 00:23:01,349
Check your gravity.

506
00:23:01,650 --> 00:23:03,030
Is it high or higher than Earth?

507
00:23:04,207 --> 00:23:05,207
Check your units are correct.

508
00:23:05,267 --> 00:23:07,928
Make sure the objects are not too large relative

509
00:23:07,968 --> 00:23:09,148
to the scale of your gravity.

510
00:23:10,228 --> 00:23:12,849
And reduce the fixed time step as much as you can

511
00:23:12,869 --> 00:23:14,050
without maxing out the CPU.

512
00:23:14,170 --> 00:23:15,250
So you need to check your gut.

513
00:23:15,890 --> 00:23:16,610
I know this is stupid.

514
00:23:16,670 --> 00:23:19,691
I just, I felt bad about how complex this was.

515
00:23:21,432 --> 00:23:22,712
You want to check that your objects have

516
00:23:23,112 --> 00:23:27,133
realistic contrasts in mass, but that stacks of chains

517
00:23:27,554 --> 00:23:29,654
or chains of objects have similar mass values,

518
00:23:30,034 --> 00:23:31,095
similar mass ratios.

519
00:23:32,305 --> 00:23:35,446
If you have stacks or chains of colliding objects,

520
00:23:36,387 --> 00:23:37,947
you want to increase the number of iterations.

521
00:23:38,788 --> 00:23:42,249
You want to avoid creating scenarios that the engine can't figure out how to resolve.

522
00:23:43,549 --> 00:23:47,691
And you want to replace the linear built-in drag with quadratic drag.

523
00:23:47,711 --> 00:23:48,571
So change your mind.

524
00:23:49,051 --> 00:23:50,812
Check your gut, change your minds.

525
00:23:52,732 --> 00:23:54,193
I hope that was useful for some of you.

526
00:23:54,633 --> 00:23:57,374
Next week or two I'll try to put these slides on my website

527
00:23:57,474 --> 00:23:58,875
so you can go through more slowly. Thanks.

