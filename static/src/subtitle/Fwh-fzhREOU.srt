1
00:00:12,247 --> 00:00:13,448
Welcome to this presentation.

2
00:00:14,328 --> 00:00:18,271
My name is Timo HÃ¤nepurula, and I'm going to be talking about modernizing rendering

3
00:00:18,371 --> 00:00:19,051
at Supercell.

4
00:00:19,932 --> 00:00:24,054
So, first of all, I want to remind everyone to please turn off their phones if they're

5
00:00:24,255 --> 00:00:29,498
potentially making any sounds, and remember to fill in the review forms after the presentation.

6
00:00:33,477 --> 00:00:41,078
So I'm going to start off the presentation with a short history tour on technology development at the company.

7
00:00:42,338 --> 00:00:47,179
After that, I'm going to be talking about the actual process of rewriting our core renderer

8
00:00:47,759 --> 00:00:50,140
and porting all of our games on top of the new system.

9
00:00:52,400 --> 00:00:55,481
Then, I'm going to be talking about the new system itself,

10
00:00:55,781 --> 00:00:59,582
going to give an overview of its architecture and talk a bit about the feature set.

11
00:01:01,429 --> 00:01:04,530
And finally, I'm going to go through some of the learnings from along the way.

12
00:01:06,531 --> 00:01:08,311
But first off, a little bit of introductions.

13
00:01:09,011 --> 00:01:11,312
So the name was already mentioned, Timo Hennepurla.

14
00:01:11,752 --> 00:01:15,093
I've been a Supercellian since March 2020,

15
00:01:15,993 --> 00:01:20,154
and ever since I've been focusing on building our shared rendering capabilities.

16
00:01:22,035 --> 00:01:24,536
So my career actually started in the IT industry.

17
00:01:24,916 --> 00:01:27,216
I did that for about five or so years,

18
00:01:27,677 --> 00:01:29,617
but I always wanted to be in the game development industry.

19
00:01:30,673 --> 00:01:32,595
So I decided to join Bugbear Entertainment

20
00:01:33,596 --> 00:01:35,457
and work primarily on the game Wreckfest.

21
00:01:36,958 --> 00:01:38,699
After Bugbear, I joined Next Games

22
00:01:38,919 --> 00:01:41,081
as the lead programmer on The Walking Dead No Man's Land.

23
00:01:42,482 --> 00:01:44,663
Before Supercell, I was at a small startup

24
00:01:44,723 --> 00:01:46,185
called Reforge Studios.

25
00:01:48,206 --> 00:01:50,047
So Supercell was founded in 2010.

26
00:01:50,127 --> 00:01:52,229
We have about 420 or 430 people, give or take, globally.

27
00:01:57,444 --> 00:02:00,346
And we're best known for games such as Hay Day, Clash of Clans,

28
00:02:00,546 --> 00:02:03,067
Boom Beach, Clash Royale, and Brawl Stars.

29
00:02:05,429 --> 00:02:08,151
So now let's talk a bit about the history of technology development here.

30
00:02:09,392 --> 00:02:12,414
So we actually started developing our games in Flash.

31
00:02:13,415 --> 00:02:17,538
Our first game, Gunshine.net, was made on Flash for the Facebook platform.

32
00:02:19,459 --> 00:02:24,062
And Facebook was the first component in our multi-platform strategy back then.

33
00:02:26,385 --> 00:02:30,547
But we soon realized that Gunshine.net was not going to be the huge success that we had

34
00:02:30,727 --> 00:02:36,109
hoped it to be, so we decided to kill the game and pivoted to tablet-oriented mobile,

35
00:02:36,429 --> 00:02:37,850
which was really on the rise back then.

36
00:02:39,870 --> 00:02:45,072
So we needed something native to run on iOS and Android, because Flash just wouldn't cut

37
00:02:45,112 --> 00:02:49,634
it and the options back then were quite a lot more limited than they are nowadays.

38
00:02:52,348 --> 00:02:57,292
We also wanted to continue authoring in Flash because we had a lot of experience in the pipeline,

39
00:02:57,952 --> 00:03:02,336
and we also had a lot of content coming up in the pipeline as well, so it made sense.

40
00:03:03,737 --> 00:03:06,519
So this was the birth of what we call Titan.

41
00:03:08,520 --> 00:03:13,804
So we developed this pipeline for converting Flash content into our in-house format,

42
00:03:15,025 --> 00:03:18,747
and a rendering system for rendering this content, and we call this Stage.

43
00:03:19,766 --> 00:03:22,948
Stage is closely modeled off of the Flash API.

44
00:03:24,389 --> 00:03:27,872
Stage is also part of Titan, but Titan is quite a lot more

45
00:03:28,232 --> 00:03:31,014
than just rendering, or stage in this case.

46
00:03:32,155 --> 00:03:36,638
Titan has a lot of components that are utilized by the game

47
00:03:36,678 --> 00:03:41,581
teams to implement the game functionality, components that

48
00:03:41,621 --> 00:03:44,443
they might not necessarily want to, or it doesn't make sense

49
00:03:44,503 --> 00:03:46,265
for them, to develop on their own.

50
00:03:47,901 --> 00:03:52,462
Historically, Titan has been something of a toolbox of components from which game teams

51
00:03:52,522 --> 00:03:57,203
can pick and choose these components, but it's becoming more and more of an actual engine.

52
00:03:59,784 --> 00:04:02,684
Titan is also maintained by the tools and technology team.

53
00:04:03,304 --> 00:04:08,506
So even though every game team does have the capacity and can commit directly into Titan,

54
00:04:09,026 --> 00:04:13,127
the primary responsibility for maintaining the engine still falls on the tools and technology

55
00:04:13,167 --> 00:04:13,387
team.

56
00:04:14,207 --> 00:04:15,747
And I'm also personally part of that team.

57
00:04:18,529 --> 00:04:20,951
So we've been seeing this growing need for 3D.

58
00:04:21,851 --> 00:04:25,653
Historically, our early games have been isometric,

59
00:04:25,954 --> 00:04:28,015
pre-rendered, or hand-painted 3D.

60
00:04:29,255 --> 00:04:31,377
So if you look at Hay Day or Clash of Clans,

61
00:04:32,077 --> 00:04:35,959
it looks 3D-ish, but it's actually not real-time rendered 3D.

62
00:04:38,672 --> 00:04:42,073
But games such as Everdale, which is one of our beta games,

63
00:04:42,353 --> 00:04:45,073
and Brawl Stars really highlighted the potential

64
00:04:45,294 --> 00:04:48,495
of 3D in our games and how it could make

65
00:04:48,595 --> 00:04:49,835
for more vivid environments.

66
00:04:51,375 --> 00:04:54,456
It's worth mentioning here that even though Everdale was killed,

67
00:04:54,556 --> 00:04:56,137
it's found a new home under MetaCore.

68
00:04:56,237 --> 00:04:57,917
So we're definitely looking forward

69
00:04:57,997 --> 00:05:01,558
to what they can come up with the idea with the concept.

70
00:05:03,771 --> 00:05:06,553
So then some new wind started blowing for 3D.

71
00:05:06,953 --> 00:05:08,975
And one of the big things that happened

72
00:05:09,035 --> 00:05:10,816
was that Apple decided to drop a bomb

73
00:05:11,497 --> 00:05:13,138
when they deprecated OpenGL ES.

74
00:05:14,098 --> 00:05:15,560
This was a huge problem for us

75
00:05:16,020 --> 00:05:18,542
because we heavily relied on OpenGL ES.

76
00:05:19,002 --> 00:05:20,163
Pretty much all of our rendering

77
00:05:20,343 --> 00:05:21,764
was built directly on top of it.

78
00:05:22,324 --> 00:05:26,007
We had some lightweight layers on top of OpenGL ES,

79
00:05:27,108 --> 00:05:29,830
but a lot of the games were also directly calling

80
00:05:29,970 --> 00:05:31,951
into the underlying API.

81
00:05:34,126 --> 00:05:38,148
So if we look at a bird's eye view of our legacy rendering architecture,

82
00:05:38,829 --> 00:05:44,212
then at the bottom we have the OpenGL and OpenGL ES layer directly, no abstractions.

83
00:05:45,853 --> 00:05:52,297
On top of this, we have this lightweight helper layer with shader loading on a render class

84
00:05:52,337 --> 00:05:55,419
that help with some vertex buffer binding things and stuff like that.

85
00:05:56,600 --> 00:06:01,022
GL image for OpenGL texture creation and texture content loading.

86
00:06:02,232 --> 00:06:04,094
A very kind of simple and lightweight stuff.

87
00:06:06,215 --> 00:06:09,798
On top of this, we had 3D rendering functionality

88
00:06:09,898 --> 00:06:12,860
for meshes, materials, models, scenes, et cetera.

89
00:06:13,140 --> 00:06:15,602
And this layer also kind of contains stage.

90
00:06:16,603 --> 00:06:18,725
And this was using the underlying layer

91
00:06:19,305 --> 00:06:23,028
in addition to directly calling into OpenGL ES as well.

92
00:06:24,751 --> 00:06:27,173
And then finally, we have a game-specific rendering layer

93
00:06:27,513 --> 00:06:29,874
which used all the layers underneath,

94
00:06:30,134 --> 00:06:32,356
including directly calling into OpenGL.

95
00:06:33,617 --> 00:06:36,919
So we were heavily reliant on OpenGL.

96
00:06:38,740 --> 00:06:40,581
So we wanted to future-proof our rendering.

97
00:06:42,362 --> 00:06:44,083
We really saw this as an opportunity.

98
00:06:44,563 --> 00:06:47,285
So we didn't want to just work around the issue

99
00:06:47,465 --> 00:06:49,567
of not having metal by just implementing

100
00:06:49,687 --> 00:06:51,668
a side-by-side metal path for rendering.

101
00:06:52,048 --> 00:06:53,269
We wanted to do this properly.

102
00:06:55,284 --> 00:06:57,766
Our legacy rendering path was really holding us back.

103
00:06:58,046 --> 00:07:00,087
So it's becoming more and more complicated

104
00:07:00,327 --> 00:07:04,069
to create anything more complex, 3D effects.

105
00:07:06,030 --> 00:07:07,911
So it was really holding us back.

106
00:07:08,191 --> 00:07:10,092
And we had these situations where we had

107
00:07:10,753 --> 00:07:14,115
2D rendering states leaking into 3D rendering states

108
00:07:14,375 --> 00:07:17,517
and it was really hard to maintain a separation

109
00:07:17,577 --> 00:07:18,517
between these systems.

110
00:07:20,033 --> 00:07:24,256
So we needed a proper abstraction layer that would allow our game rendering

111
00:07:24,296 --> 00:07:29,840
engineers to focus on the actual game visuals and not think too much about the

112
00:07:30,080 --> 00:07:31,161
underlying API.

113
00:07:34,583 --> 00:07:39,906
So this could be considered a risky move to rewrite the render of billion dollar

114
00:07:39,926 --> 00:07:45,730
games, but we believe that changes like these are often necessary to keep us

115
00:07:45,790 --> 00:07:46,330
competitive.

116
00:07:47,945 --> 00:07:51,829
So we keep moving our games to new Titan features because it

117
00:07:51,929 --> 00:07:52,931
helps us in many ways.

118
00:07:53,852 --> 00:07:57,536
It helps us improve our existing games with every update.

119
00:07:57,776 --> 00:08:01,381
So if we, for instance, develop a new content delivery system,

120
00:08:01,821 --> 00:08:04,965
then these games are able to deliver better and more content

121
00:08:04,985 --> 00:08:05,646
to our players.

122
00:08:07,391 --> 00:08:11,253
It also allows us to keep the tools and technology team smaller

123
00:08:11,733 --> 00:08:15,115
because we can focus on this single stack

124
00:08:15,255 --> 00:08:18,517
and we don't have multiple branches of our technology stack to maintain.

125
00:08:20,618 --> 00:08:25,900
Also, it makes it a lot easier to share learnings and technology between games

126
00:08:25,980 --> 00:08:28,241
because we have this common language that we're speaking,

127
00:08:28,361 --> 00:08:29,762
common platform that we're using.

128
00:08:31,837 --> 00:08:34,119
So now it's time to introduce Thor,

129
00:08:34,640 --> 00:08:37,523
or Titan Hardware Oriented Slash Optimized Renderer.

130
00:08:38,704 --> 00:08:41,527
In fact, this is actually just a name that I came up

131
00:08:41,628 --> 00:08:43,269
after watching a Marvel Thor movie,

132
00:08:43,309 --> 00:08:46,773
but the term was nice and it had a nice abbreviation,

133
00:08:46,833 --> 00:08:47,975
so that stuck.

134
00:08:50,487 --> 00:08:52,267
So Thor is this abstraction layer.

135
00:08:52,647 --> 00:08:56,548
Currently it abstracts Metal, OpenGL, OpenGL ES, and Vulkan.

136
00:08:57,089 --> 00:08:59,109
Vulkan is still an experimental support,

137
00:08:59,209 --> 00:09:01,270
but we're pushing hard to get that into live

138
00:09:01,710 --> 00:09:02,610
as soon as possible.

139
00:09:04,791 --> 00:09:05,791
When I joined the company,

140
00:09:05,911 --> 00:09:08,512
we had like a skeleton of what was to become Thor.

141
00:09:08,532 --> 00:09:10,632
So it was very simple,

142
00:09:10,652 --> 00:09:13,373
but we had the basic architecture in place already,

143
00:09:14,174 --> 00:09:17,775
and we had basic support for OpenGL, OpenGL ES, and Metal.

144
00:09:18,115 --> 00:09:19,615
Vulkan was still missing at this point.

145
00:09:20,554 --> 00:09:24,057
And actually quite a lot of like core features, you know,

146
00:09:24,077 --> 00:09:26,579
were still missing and a lot of this has been rewritten

147
00:09:27,040 --> 00:09:30,583
partially because of multi-threaded support added to OpenGL.

148
00:09:32,565 --> 00:09:33,626
But it was a good start.

149
00:09:35,708 --> 00:09:36,870
So during the spring of 2020,

150
00:09:37,911 --> 00:09:40,113
I worked on Thor pretty much in isolation.

151
00:09:40,293 --> 00:09:40,994
So I didn't have any...

152
00:09:42,282 --> 00:09:47,471
game project to actually work on. I just had this separate test project for different rendering

153
00:09:47,532 --> 00:09:52,059
tests for creating textures, creating compiling shaders, and rendering primitives.

154
00:09:54,622 --> 00:09:57,163
But right before summer holidays, which in Finland,

155
00:09:57,583 --> 00:10:01,943
the game industry typically has in roughly around July,

156
00:10:02,344 --> 00:10:05,244
so this was by the end of June or so,

157
00:10:05,744 --> 00:10:07,784
I got Hay Day running in a very limited manner.

158
00:10:07,944 --> 00:10:11,525
So as you can see, the screenshot is quite buggy,

159
00:10:12,345 --> 00:10:14,046
but it is the first screenshot

160
00:10:14,326 --> 00:10:16,386
of the game actually running on Thor.

161
00:10:16,446 --> 00:10:18,646
So it was a huge milestone because after this,

162
00:10:19,326 --> 00:10:22,067
we could just start improving Thor, making it better,

163
00:10:22,307 --> 00:10:23,547
and making it production ready.

164
00:10:26,455 --> 00:10:30,238
Hay Day was chosen due to its limited rendering feature set.

165
00:10:30,959 --> 00:10:33,101
It basically only relied on stage.

166
00:10:33,241 --> 00:10:36,825
We didn't have to implement any of the 3D rendering functionality.

167
00:10:39,547 --> 00:10:41,309
Of course, we had to prepare for the worst.

168
00:10:42,430 --> 00:10:45,172
So we set up automated testing from the get-go,

169
00:10:45,553 --> 00:10:48,215
even before we were considering merging anything in.

170
00:10:50,650 --> 00:10:53,593
So we had these predefined scenarios for smoke testing.

171
00:10:54,193 --> 00:10:56,115
Tests that would scour through the game,

172
00:10:56,195 --> 00:10:58,757
go through different menus, press different buttons,

173
00:10:59,058 --> 00:11:01,880
and basically kind of automatically play the game.

174
00:11:03,361 --> 00:11:06,804
We also have video recording for recording the play session

175
00:11:06,924 --> 00:11:09,506
and storing that on disk for later analysis.

176
00:11:10,863 --> 00:11:16,287
We had log capturing so that if we saw some issues in the videos, we could go into the

177
00:11:16,327 --> 00:11:20,951
logs and see if there's any potential reasons for why that might be happening.

178
00:11:22,592 --> 00:11:25,494
And we could execute these tests in Google Firebase.

179
00:11:25,834 --> 00:11:31,618
So we could take hundreds of devices and combinations with different OS versions and try out the

180
00:11:31,658 --> 00:11:32,399
tests on there.

181
00:11:32,519 --> 00:11:33,540
Get really good coverage.

182
00:11:35,926 --> 00:11:39,088
This helped us find multiple issues in rendering before launch.

183
00:11:39,388 --> 00:11:41,049
And towards the end of the presentation,

184
00:11:41,149 --> 00:11:43,891
I have a couple of interesting examples of these.

185
00:11:45,112 --> 00:11:48,094
And it allowed QA to focus on the more tricky issues.

186
00:11:52,077 --> 00:11:52,917
So, during the fall of 2020,

187
00:11:53,538 --> 00:11:56,700
I focused on improving and stabilizing Thor,

188
00:11:56,920 --> 00:11:58,581
so basically making it production-ready,

189
00:11:59,361 --> 00:12:02,423
fixing small issues, doing performance optimization,

190
00:12:02,643 --> 00:12:03,444
and stuff like that.

191
00:12:05,545 --> 00:12:07,786
Working with the game team was super easy.

192
00:12:08,146 --> 00:12:10,867
So whenever I had any questions about where certain things

193
00:12:10,907 --> 00:12:13,908
were implemented, how the rendering was done,

194
00:12:14,048 --> 00:12:15,649
or how to make certain kinds of builds,

195
00:12:16,249 --> 00:12:17,970
I could just directly go to the team

196
00:12:18,030 --> 00:12:19,371
and get answers really quickly.

197
00:12:20,231 --> 00:12:23,873
And no one really questioned my ability to work on this.

198
00:12:24,053 --> 00:12:27,394
And I was able to do really big decisions autonomously.

199
00:12:29,195 --> 00:12:31,916
So in the end, the update of Hay Day using Thor

200
00:12:32,056 --> 00:12:34,097
was released on the 23rd of November in 2020.

201
00:12:35,707 --> 00:12:38,868
And this was the second huge milestone for Thor,

202
00:12:39,168 --> 00:12:41,989
because after this point, we had a game in the wild

203
00:12:42,089 --> 00:12:44,830
and we could start collecting performance metrics,

204
00:12:45,731 --> 00:12:48,312
crash reports, and overall player feedback.

205
00:12:50,453 --> 00:12:53,954
Luckily, we didn't run into a lot of issues in the live,

206
00:12:54,294 --> 00:12:56,415
so I was able to move to the next project,

207
00:12:57,075 --> 00:13:00,117
which was that I was jumping from one game team to another,

208
00:13:00,617 --> 00:13:02,778
porting the game rendering over to Thor

209
00:13:03,058 --> 00:13:04,758
and improving Thor while doing so.

210
00:13:06,278 --> 00:13:08,818
So the next game in the line was Clash of Clans.

211
00:13:09,779 --> 00:13:13,940
And this was actually the first game to be ported

212
00:13:13,980 --> 00:13:15,540
that had 3D elements in it.

213
00:13:16,140 --> 00:13:18,381
So at this point, I needed to port meshes,

214
00:13:18,601 --> 00:13:20,962
render queues, materials, all that stuff.

215
00:13:23,102 --> 00:13:26,083
But it was a relatively straightforward process,

216
00:13:26,123 --> 00:13:29,124
partially because stage was already ported

217
00:13:29,344 --> 00:13:32,065
and most of the rendering in Clash relied on stage

218
00:13:32,505 --> 00:13:34,725
with just a couple of 3D elements there.

219
00:13:36,360 --> 00:13:41,390
This update went out pretty quickly after heyday on the 12th of April in 2021.

220
00:13:44,506 --> 00:13:49,249
Next up was Clash Royale, and Clash Royale was actually started in parallel with Clash of Clans.

221
00:13:50,190 --> 00:13:56,854
And there weren't a lot of huge surprises again here, mainly some shader variant filtering systems

222
00:13:56,894 --> 00:14:02,458
that needed to be implemented. But the biggest issue really was matching the timelines of the

223
00:14:02,518 --> 00:14:09,743
project, so their release schedule. And it took quite a lot of time to bring this update out,

224
00:14:10,063 --> 00:14:12,385
which came out on the 25th of October in 2021.

225
00:14:15,395 --> 00:14:17,135
The fourth game out was Brawl Stars.

226
00:14:17,895 --> 00:14:20,536
And Brawl Stars was probably the most complicated.

227
00:14:21,616 --> 00:14:24,337
Most of the functionality itself was already there,

228
00:14:24,657 --> 00:14:27,177
but because of the sheer amount of content that we had

229
00:14:27,257 --> 00:14:30,698
and the variations of the different shaders that we had,

230
00:14:31,818 --> 00:14:33,979
we ran into a number of smaller issues

231
00:14:34,019 --> 00:14:34,979
that needed to be fixed.

232
00:14:35,619 --> 00:14:37,539
Also, QA had their hands full

233
00:14:37,759 --> 00:14:39,540
on multiple releases of the game,

234
00:14:39,900 --> 00:14:41,740
so it just took a while to go through QA.

235
00:14:44,105 --> 00:14:46,886
Eventually this update went out on 16th of December in 2021.

236
00:14:48,407 --> 00:14:50,547
The last game to be ported was Boom Beach.

237
00:14:52,068 --> 00:14:57,829
And this took the longest, because, again, the release schedules of the game.

238
00:14:58,310 --> 00:15:02,671
And Boom has its own, a bit different way of doing 3D rendering.

239
00:15:02,791 --> 00:15:06,252
So there was somewhat more work to be done there.

240
00:15:07,892 --> 00:15:10,433
But the update eventually went out on the 2nd of November in 2022.

241
00:15:13,029 --> 00:15:18,135
So at this point, all the live games had been ported, and we could do a surgical operation

242
00:15:18,295 --> 00:15:19,757
to remove the old render path.

243
00:15:20,157 --> 00:15:23,080
So this was the third major milestone for Thor development.

244
00:15:23,501 --> 00:15:25,603
And we could consider the project done at this point.

245
00:15:26,931 --> 00:15:33,396
You've probably noticed a pattern here with me mentioning that the biggest problem was really the timeline of the projects.

246
00:15:33,936 --> 00:15:41,802
And that is true, because it was complicated to match the work being done on Thor to the timelines of these individual projects,

247
00:15:41,922 --> 00:15:47,887
because they still wanted to develop the games forward, develop all the new cool features that they wanted for their players,

248
00:15:48,787 --> 00:15:51,249
while I was still working on the core rendering.

249
00:15:51,789 --> 00:15:54,712
So that was probably the most challenging part on here.

250
00:15:56,945 --> 00:15:57,946
But that was just the beginning.

251
00:15:58,466 --> 00:16:01,488
So the development of Thor has continued nonstop.

252
00:16:02,749 --> 00:16:06,051
We've now shifted focus to building on top of Thor.

253
00:16:06,071 --> 00:16:09,453
So now we're able to build new rendering techniques,

254
00:16:09,653 --> 00:16:10,614
which we couldn't before.

255
00:16:11,734 --> 00:16:13,836
It also has made sharing a lot easier.

256
00:16:13,956 --> 00:16:16,517
It's easier to talk if you have a common code base

257
00:16:16,557 --> 00:16:18,038
and common language to speak with.

258
00:16:19,379 --> 00:16:21,640
And it has allowed us to build better tooling

259
00:16:21,800 --> 00:16:23,321
and use a lot of better tooling

260
00:16:23,461 --> 00:16:25,823
because of the pipeline, the new pipeline underneath.

261
00:16:28,086 --> 00:16:30,187
So now let's talk a bit about Thor itself.

262
00:16:32,489 --> 00:16:35,631
So we had three major design goals for Thor.

263
00:16:36,831 --> 00:16:39,993
First of all, it needed to support multiple rendering

264
00:16:40,013 --> 00:16:40,593
APIs.

265
00:16:41,534 --> 00:16:43,375
We wanted to add metal support, but we

266
00:16:43,435 --> 00:16:47,217
had to also keep the OpenGL and OpenGL ES support.

267
00:16:47,338 --> 00:16:49,079
So naturally, we had at least two APIs.

268
00:16:49,839 --> 00:16:51,740
But we also wanted to add support for Vulkan,

269
00:16:51,800 --> 00:16:54,062
because that's the direction that Android

270
00:16:54,102 --> 00:16:55,943
has been pushing really hard.

271
00:16:59,298 --> 00:17:04,202
We also wanted it to be powerful and efficient, but easy to use.

272
00:17:04,502 --> 00:17:08,485
So we wanted to be able to create these modern, impressive visuals

273
00:17:08,525 --> 00:17:10,047
with the system efficiently.

274
00:17:10,687 --> 00:17:15,050
But we also wanted the game engineers and the game rendering engineers

275
00:17:15,150 --> 00:17:17,832
to be able to do this without a lot of hassle.

276
00:17:20,534 --> 00:17:22,616
And we wanted to make this future proof.

277
00:17:23,076 --> 00:17:25,918
So we didn't want to be rewriting the system anytime soon.

278
00:17:26,099 --> 00:17:29,121
It was going to be our rendering platform for the future.

279
00:17:32,279 --> 00:17:33,259
So Thor in a nutshell.

280
00:17:34,160 --> 00:17:36,322
Currently Thor supports these APIs,

281
00:17:36,482 --> 00:17:37,724
which I already mentioned earlier.

282
00:17:39,265 --> 00:17:41,687
It is architectured around the concepts of Metal,

283
00:17:42,428 --> 00:17:45,991
because we found that Metal is probably the best compromise

284
00:17:46,031 --> 00:17:48,093
between performance and usability.

285
00:17:48,794 --> 00:17:52,698
And also, Metal was kind of our primary target initially,

286
00:17:52,898 --> 00:17:54,940
so it made sense to architecture things around it.

287
00:17:57,230 --> 00:18:01,755
Thor is also multi-threaded, so this was a really important point for us, because modern

288
00:18:02,115 --> 00:18:06,339
mobile devices tend to have a lot of cores, and different types of cores also.

289
00:18:06,900 --> 00:18:10,643
So we wanted to be able to utilize that to create multi-threaded rendering algorithms,

290
00:18:10,743 --> 00:18:11,604
which we couldn't before.

291
00:18:14,847 --> 00:18:16,729
So we had a number of design challenges also.

292
00:18:18,077 --> 00:18:21,600
First of all, it needed to support all the legacy devices

293
00:18:21,940 --> 00:18:23,462
the render path also supported.

294
00:18:24,302 --> 00:18:25,924
This partially comes from our mission,

295
00:18:26,024 --> 00:18:27,965
which is to create great games

296
00:18:28,326 --> 00:18:31,728
that as many people as possible play for years

297
00:18:32,249 --> 00:18:33,570
and that are remembered forever.

298
00:18:34,511 --> 00:18:36,732
So we didn't want to be dropping these players

299
00:18:36,792 --> 00:18:39,575
that have been enjoying our games for years

300
00:18:40,776 --> 00:18:44,058
just because we were rewriting this core rendering,

301
00:18:44,198 --> 00:18:45,259
which was more or less

302
00:18:46,262 --> 00:18:50,082
Future-proofing our rendering, but it wasn't immediately providing any

303
00:18:50,262 --> 00:18:51,843
huge benefits to our players.

304
00:18:52,303 --> 00:18:54,563
It was going to provide those benefits in the future.

305
00:18:59,684 --> 00:19:03,785
So the added abstractions should also be very efficient.

306
00:19:04,425 --> 00:19:09,186
We had a very efficient use of OpenGL ES originally because we had built all of

307
00:19:09,266 --> 00:19:11,807
our rendering directly on top of OpenGL ES.

308
00:19:14,578 --> 00:19:16,940
And abstractions tend to add overhead.

309
00:19:17,361 --> 00:19:19,042
So we wanted to keep this to the minimum.

310
00:19:22,545 --> 00:19:24,487
This was probably our biggest challenge.

311
00:19:26,169 --> 00:19:30,973
We wanted the new render path to coexist with the old render path.

312
00:19:32,347 --> 00:19:35,148
So we didn't want to put all of our eggs in a single basket.

313
00:19:35,588 --> 00:19:39,990
And we wanted to update our games one after another

314
00:19:40,370 --> 00:19:42,831
to make sure that the game before worked

315
00:19:42,971 --> 00:19:44,992
before we moved to the next game.

316
00:19:49,093 --> 00:19:50,354
So let's look at a bird's eye view

317
00:19:50,534 --> 00:19:52,274
of the core architecture of Thor.

318
00:19:53,595 --> 00:19:55,375
So we have the bottom layer,

319
00:19:55,495 --> 00:19:57,156
which is a platform specific layer.

320
00:19:57,236 --> 00:20:01,758
And this is different for Metal, Vulkan, OpenGL and OpenGL ES.

321
00:20:02,733 --> 00:20:06,195
For OpenGL and OpenGL ES, it shares quite a lot of code, actually.

322
00:20:06,235 --> 00:20:09,437
So technically, it's kind of the same platform with some variations.

323
00:20:11,978 --> 00:20:14,339
On top of this, we have the actual abstraction layer,

324
00:20:14,759 --> 00:20:17,561
which contains resources such as buffers, textures,

325
00:20:18,061 --> 00:20:21,163
different render states such as the render pipeline,

326
00:20:21,903 --> 00:20:25,165
depth stencil state, shader function definitions, and all that.

327
00:20:27,657 --> 00:20:29,239
And this is what we call Thor.

328
00:20:29,379 --> 00:20:33,543
So it is the hardware or the underlying API abstraction layer.

329
00:20:35,284 --> 00:20:40,409
On top of this, we have the same layer that we had before for 3D rendering,

330
00:20:40,449 --> 00:20:42,231
mainly also including stage.

331
00:20:43,692 --> 00:20:47,736
And we didn't re-architecture this layer in any significant way.

332
00:20:47,916 --> 00:20:52,820
We ported it over to Thor, but we didn't make any big changes to its structure.

333
00:20:55,498 --> 00:20:57,378
Then we have the game-specific rendering layer,

334
00:20:57,739 --> 00:21:02,260
which now depends only on Thor and the scene layer here.

335
00:21:03,100 --> 00:21:06,041
So as you can see, it's no longer dependent on the platform API,

336
00:21:06,401 --> 00:21:08,302
which was one of our biggest goals here.

337
00:21:10,303 --> 00:21:13,364
So let's quickly look at the composition of a single frame here.

338
00:21:14,564 --> 00:21:16,485
So we start off with command buffer encoding.

339
00:21:17,563 --> 00:21:19,346
This is a concept that we took from Metal.

340
00:21:19,606 --> 00:21:24,915
So you create a command buffer, and then you create a render encoder, which is responsible

341
00:21:24,975 --> 00:21:28,841
for encoding these draw calls and state sets into the command buffer.

342
00:21:31,907 --> 00:21:38,490
This is emulated on OpenGL because OpenGL does not have an explicit concept of

343
00:21:39,011 --> 00:21:39,791
command buffers.

344
00:21:42,433 --> 00:21:46,475
Metal and Vulkan has this, so for them it's basically just a native operation.

345
00:21:46,535 --> 00:21:52,799
But for OpenGL, we have a host memory buffer where we encode these state sets

346
00:21:53,019 --> 00:21:54,359
and draw calls, et cetera.

347
00:21:56,301 --> 00:21:58,882
This command buffer is then pushed into the command queue.

348
00:22:00,370 --> 00:22:03,473
And on Metal and Vulkan, this basically goes through the driver

349
00:22:03,693 --> 00:22:05,854
and to GPU execution, et cetera.

350
00:22:06,355 --> 00:22:09,717
But for OpenGL, we actually have a dedicated working thread

351
00:22:10,177 --> 00:22:14,000
that unwraps the command buffer and executes the OpenGL commands.

352
00:22:16,102 --> 00:22:19,344
So this has allowed us to create these command buffers on any threads,

353
00:22:20,265 --> 00:22:24,768
but the actual OpenGL commands are executed on a single thread.

354
00:22:27,737 --> 00:22:30,857
We can of course have multiple command buffers being encoded

355
00:22:31,477 --> 00:22:33,058
and in execution in parallel.

356
00:22:34,058 --> 00:22:36,259
There is only a limit for how many command buffers

357
00:22:36,299 --> 00:22:38,159
can exist at any given time.

358
00:22:38,459 --> 00:22:40,800
But if you encode these command buffers,

359
00:22:41,260 --> 00:22:44,561
commit them and wait for some of them to be freed again,

360
00:22:44,761 --> 00:22:46,981
you can encode any amount of command buffers

361
00:22:47,021 --> 00:22:47,901
during a single frame.

362
00:22:49,962 --> 00:22:52,483
And this hard limit of command buffers executing

363
00:22:52,523 --> 00:22:53,483
actually comes from Metal.

364
00:22:56,127 --> 00:22:59,109
Then, of course, the second command buffer here gets executed.

365
00:22:59,370 --> 00:23:03,594
And finally, when we're complete with the frame, we schedule a present.

366
00:23:04,915 --> 00:23:05,856
That concludes the frame.

367
00:23:07,878 --> 00:23:09,039
So let's talk a bit about shaders.

368
00:23:09,840 --> 00:23:12,462
So we author our shaders in GLSL.

369
00:23:14,084 --> 00:23:16,946
This is then compiled into Sperby modules.

370
00:23:18,586 --> 00:23:23,227
And we convert the SPIR-V module to the target-specific languages

371
00:23:23,567 --> 00:23:24,867
using SPIR-V cross.

372
00:23:25,427 --> 00:23:28,808
For OpenGL, it's like different variations of GLSL,

373
00:23:28,948 --> 00:23:30,349
and for Metal, that's MSL.

374
00:23:34,489 --> 00:23:38,690
These are then loaded at runtime and converted

375
00:23:38,770 --> 00:23:41,031
into the runtime concepts, shader functions,

376
00:23:41,131 --> 00:23:43,911
or compiled and linked into shader programs.

377
00:23:45,080 --> 00:23:47,902
And on OpenGL, we also have a shader program cache

378
00:23:48,223 --> 00:23:51,225
that we can use to optimize the load times significantly.

379
00:23:54,008 --> 00:23:56,751
And of course, on Vulkan, we directly load the Spurvy module.

380
00:23:57,251 --> 00:23:59,653
But it's important to note that this Spurvy module

381
00:23:59,873 --> 00:24:02,836
might not be the same for every single platform

382
00:24:02,916 --> 00:24:06,359
because we might be doing some optimizations for them,

383
00:24:06,419 --> 00:24:07,320
depending on the platform.

384
00:24:10,039 --> 00:24:13,941
We have both a load time and a build time pipeline here.

385
00:24:14,541 --> 00:24:18,863
So we can do the SPIR-V cross compilation

386
00:24:19,023 --> 00:24:20,804
either at load time or at build time.

387
00:24:21,144 --> 00:24:23,745
The load time approach was something that we originally had

388
00:24:24,045 --> 00:24:25,606
where we shipped the SPIR-V modules

389
00:24:26,046 --> 00:24:28,848
and then at load time, we did the cross compilation

390
00:24:29,068 --> 00:24:32,469
to get the final target language, which was then compiled.

391
00:24:33,370 --> 00:24:42,208
But now we've since moved to a build time pipeline where we actually built the different variations of these shaders offline during the game build.

392
00:24:45,564 --> 00:24:48,426
In addition to this, we also have a variant system.

393
00:24:48,587 --> 00:24:52,329
So every single shader can define a set of variant flags.

394
00:24:52,750 --> 00:24:55,532
And the pipeline then builds different variations of these.

395
00:24:56,092 --> 00:24:59,075
But as we all know from a lot of other engines,

396
00:24:59,375 --> 00:25:01,176
this can cost quite a lot of time

397
00:25:01,357 --> 00:25:02,618
to build all these variations.

398
00:25:03,098 --> 00:25:05,240
So we also support specialization constants.

399
00:25:05,980 --> 00:25:09,303
So if you request a shader function from Thor,

400
00:25:10,124 --> 00:25:15,887
you can specify a set of specialization constants which will further branch out the shader

401
00:25:15,907 --> 00:25:23,270
implementation. On Metal, this uses function constants, and on Vulkan it's specialization

402
00:25:23,310 --> 00:25:30,094
constants, and on OpenGL we actually utilize the way that Spurvy cross kind of emulates

403
00:25:30,414 --> 00:25:36,417
the specialization constants, but we're able to define these values at compilation time.

404
00:25:40,675 --> 00:25:44,640
So naturally, not all features of Thor are available on all platforms.

405
00:25:46,482 --> 00:25:52,270
Games can check for the availability of certain features using feature flag tests.

406
00:25:53,868 --> 00:25:56,410
But some of these features are also emulated.

407
00:25:56,430 --> 00:26:00,594
And this allows for a uniform base implementation.

408
00:26:01,094 --> 00:26:05,478
So the game rendering engineers can expect a certain uniform implementation

409
00:26:05,818 --> 00:26:08,941
or base implementation to be there to build on top of,

410
00:26:09,521 --> 00:26:12,364
and then they can branch out for specific type of features

411
00:26:12,764 --> 00:26:14,045
that they might want to be using.

412
00:26:16,129 --> 00:26:23,465
An example of these emulated features on OpenGL ES 2 backend is uniform buffers.

413
00:26:24,502 --> 00:26:28,324
So in OpenGL ES2, we don't have support for native uniform buffers,

414
00:26:28,764 --> 00:26:33,026
so we just have a host memory buffer where we store the uniform values

415
00:26:33,586 --> 00:26:36,707
based on the shader uniform block layout.

416
00:26:37,568 --> 00:26:40,329
And then when we want to actually render some primitives,

417
00:26:40,849 --> 00:26:43,550
we resolve these by reading from the memory buffer

418
00:26:44,191 --> 00:26:47,812
and using glUniform calls to set the values of the uniforms.

419
00:26:51,398 --> 00:26:56,981
So looking into the future, focus has now shifted to building on top of Thor, as already mentioned.

420
00:26:57,461 --> 00:27:01,503
I have a couple of examples here of things that we're currently working on.

421
00:27:02,523 --> 00:27:09,287
So of course we're adding features to Thor. Whenever we realize that there's some new feature in Metal or Vulcan,

422
00:27:09,727 --> 00:27:14,229
we consider adding that to the core of Thor, if it is something that really benefits the game teams.

423
00:27:15,543 --> 00:27:18,405
In addition to this, we have a couple of new systems

424
00:27:18,425 --> 00:27:20,226
that I wanted to mention here that we're working on.

425
00:27:21,006 --> 00:27:23,128
First of all, a render graph implementation,

426
00:27:23,888 --> 00:27:25,629
and something what we call Odin.

427
00:27:26,329 --> 00:27:28,511
And this is not a coincidence that it's called Odin.

428
00:27:30,552 --> 00:27:32,793
So, now let's quickly talk about the render graph.

429
00:27:34,194 --> 00:27:36,776
The render graph is basically a task,

430
00:27:36,956 --> 00:27:39,758
render task management system.

431
00:27:42,535 --> 00:27:48,478
Each task implements a piece of frame rendering, and we have two types of tasks on here.

432
00:27:49,418 --> 00:27:52,920
First of all, we have generic tasks, which do not output pixels.

433
00:27:54,000 --> 00:27:57,922
And a good example of these is CPU skinning.

434
00:28:00,583 --> 00:28:06,126
And this task is basically responsible for taking the model transforms, the untransformed

435
00:28:06,286 --> 00:28:11,788
vertex data, processing that, and outputting that into a temporary vertex buffer for rendering.

436
00:28:14,308 --> 00:28:18,349
Then we have render passes, and render passes actually output pixels,

437
00:28:18,529 --> 00:28:21,331
either off-screen or on-screen framebuffers.

438
00:28:23,551 --> 00:28:27,413
These tasks are then queued for execution on worker queues,

439
00:28:28,853 --> 00:28:32,295
and we can have basically any number of worker queues,

440
00:28:32,775 --> 00:28:35,936
depending on how many different cores the platform has.

441
00:28:36,316 --> 00:28:38,337
It really makes sense to use different amount of queues.

442
00:28:40,447 --> 00:28:44,688
Synchronization is based on the inputs and outputs of these nodes.

443
00:28:45,209 --> 00:28:50,250
So as you can see, there is a dependency between model skinning and the different render passes here.

444
00:28:51,010 --> 00:28:55,351
So the model skinning needs to complete before the render passes can start.

445
00:28:56,732 --> 00:29:00,273
Also, there is a dependency between the shadow pass and the color pass,

446
00:29:00,733 --> 00:29:04,274
but you can see there's quite a lot of overlap in the execution between these tasks.

447
00:29:05,129 --> 00:29:11,033
This is because the color pass only meets the frame buffer output of the shadow pass,

448
00:29:12,034 --> 00:29:13,675
but only on the GPU.

449
00:29:14,376 --> 00:29:18,399
So we can overlap most of the execution of these tasks,

450
00:29:18,619 --> 00:29:22,402
because that execution is preparation of the command buffers.

451
00:29:23,322 --> 00:29:28,646
So the only important thing is to make sure that the command buffer for the shadow pass

452
00:29:28,826 --> 00:29:31,008
is committed before the color pass.

453
00:29:31,508 --> 00:29:34,250
And this is something that the system also takes into account.

454
00:29:37,941 --> 00:29:42,049
So I'm not going to go too much into Odin at this point, but I wanted to mention that

455
00:29:42,450 --> 00:29:47,440
because this project with Thor did not really touch the middle layer that much.

456
00:29:48,380 --> 00:29:51,900
But the project called Odin is this.

457
00:29:52,500 --> 00:29:55,381
So the purpose is to modernize this middle layer.

458
00:29:55,701 --> 00:29:59,202
So to be able to be better equipped

459
00:29:59,482 --> 00:30:03,202
to fulfill the needs of our new games and our current games,

460
00:30:04,203 --> 00:30:05,663
to have different kinds of materials,

461
00:30:05,783 --> 00:30:09,924
make that more data-driven and easier to use.

462
00:30:12,844 --> 00:30:15,525
So now let's dig into some learnings from along the way.

463
00:30:17,790 --> 00:30:20,952
The first thing that I wanted to talk about here is quality.

464
00:30:22,833 --> 00:30:25,595
So our games are played on a wide range of devices.

465
00:30:25,835 --> 00:30:29,378
We have about 250 million monthly average users

466
00:30:29,738 --> 00:30:33,440
who have quite a large variety of different kinds of devices.

467
00:30:34,661 --> 00:30:37,944
So testing everything manually is just impossible.

468
00:30:39,224 --> 00:30:41,426
And automated testing, smoke testing,

469
00:30:41,486 --> 00:30:43,227
really took the pressure off of QA

470
00:30:43,547 --> 00:30:45,909
and allowed us to have really good coverage here.

471
00:30:48,515 --> 00:30:52,818
Another very important topic, at least for myself, is proper self-review.

472
00:30:53,299 --> 00:30:58,082
So making sure that the commit that you're making or the code that you're merging,

473
00:30:58,162 --> 00:31:03,467
that you understand it and that it is up to your own quality standards.

474
00:31:04,828 --> 00:31:09,612
So this basically helps you feel sure that you've made the best decisions

475
00:31:09,692 --> 00:31:11,733
with the available time and information.

476
00:31:12,916 --> 00:31:18,140
Also, it builds confidence in your coworkers that you are not making decisions at random.

477
00:31:19,141 --> 00:31:24,926
And finally, that you're also better equipped to fix any bugs that are surely going to pop up in

478
00:31:24,966 --> 00:31:33,213
your code in the future. And finally, respect your QA. They really help me sleep my nights

479
00:31:33,353 --> 00:31:41,399
in relative comfort. Something that's very important with mobile development overall is

480
00:31:41,499 --> 00:31:42,420
energy efficiency.

481
00:31:43,858 --> 00:31:47,841
So batteries and heat dissipation tend to be very limiting factors on mobile.

482
00:31:48,342 --> 00:31:52,284
You don't see a lot of devices with active cooling, like fans blowing.

483
00:31:53,305 --> 00:32:00,690
And these devices are targeted towards not sustained performance, but peak performance.

484
00:32:01,050 --> 00:32:07,975
So if you try to sustain the full 100% usage of the device, then you're going to run through

485
00:32:08,035 --> 00:32:12,498
battery and it's going to be overheating and the device will be throttling.

486
00:32:15,539 --> 00:32:19,222
Rendering needs to pay extra attention to this because a lot of the rendering

487
00:32:19,282 --> 00:32:21,024
code tends to be on the hot path.

488
00:32:24,627 --> 00:32:29,111
And this is really important to fulfill our mission because it allows us to, you

489
00:32:29,472 --> 00:32:33,335
know, we need to be efficient even on these lower end devices and we need to

490
00:32:33,655 --> 00:32:37,058
allow our players to play our games as long as possible.

491
00:32:37,359 --> 00:32:42,143
So taking into account the batteries and basically gaming comfort as well.

492
00:32:44,747 --> 00:32:48,530
So a couple of examples of how to take into account energy efficiency.

493
00:32:50,031 --> 00:32:53,414
First of all, I would recommend to use cache efficient data layouts,

494
00:32:53,974 --> 00:32:55,235
especially on hot memory.

495
00:32:55,255 --> 00:33:00,299
I dug up some information in preparation to this presentation,

496
00:33:00,680 --> 00:33:05,423
indicating that the difference between a cache miss and a cache hit

497
00:33:06,144 --> 00:33:06,604
is about 200.

498
00:33:08,898 --> 00:33:16,180
times. So it's 200 times less efficient in terms of energy consumption if you get a cache miss.

499
00:33:16,580 --> 00:33:22,881
So you should definitely aim to design your data layouts in such a way that they are efficient for

500
00:33:22,961 --> 00:33:30,944
the for the cache. Also favor using multiple cores. So if you're able to split your rendering

501
00:33:31,044 --> 00:33:32,844
algorithm into multiple threads.

502
00:33:33,968 --> 00:33:37,990
then you're able to put less pressure on individual cores,

503
00:33:38,331 --> 00:33:40,672
allowing them to run at a lower voltage,

504
00:33:40,972 --> 00:33:42,013
saving a lot of energy.

505
00:33:44,935 --> 00:33:47,617
Also, aim to use low-power cores.

506
00:33:48,357 --> 00:33:51,419
Most modern devices nowadays have low-power cores.

507
00:33:51,579 --> 00:33:53,861
They might have mid-power cores, high-power cores,

508
00:33:54,361 --> 00:33:56,863
different sets of different kind of cores.

509
00:33:58,935 --> 00:34:03,498
And using the low-power cores or the mid-power cores really saves a lot of energy.

510
00:34:03,938 --> 00:34:08,461
If we look at Clash of Clans, for instance, it mostly runs on the low-power cores,

511
00:34:08,841 --> 00:34:11,362
especially on the even slightly higher-end devices.

512
00:34:14,792 --> 00:34:19,095
And finally, I would recommend everyone to write sensible code from the get-go,

513
00:34:19,495 --> 00:34:22,617
because you will probably not have the time to fix your code

514
00:34:22,697 --> 00:34:26,080
if you have not allocated time to do that.

515
00:34:27,100 --> 00:34:31,784
So make sure your code, the code that you commit in, is sensible enough.

516
00:34:32,144 --> 00:34:34,706
It doesn't use a lot of brute forcing,

517
00:34:34,946 --> 00:34:38,308
and it is just something that can go into production

518
00:34:38,428 --> 00:34:41,831
if you do not have the time to optimize it further.

519
00:34:44,772 --> 00:34:47,813
Also I wanted to put this picture here which showed the

520
00:34:48,274 --> 00:34:52,075
difference in energy consumption before and after

521
00:34:52,515 --> 00:34:53,276
moving to Thor.

522
00:34:53,536 --> 00:35:00,418
So this was the comparison between using OpenGL ES on the

523
00:35:00,578 --> 00:35:04,580
old, the legacy render pipeline compared to the new render

524
00:35:04,620 --> 00:35:06,601
pipeline using Metal.

525
00:35:10,222 --> 00:35:13,563
Of course, sometimes devices don't work as expected.

526
00:35:15,373 --> 00:35:20,457
So many Android devices, especially, ship with buggy drivers or hardware.

527
00:35:21,538 --> 00:35:28,285
The situation isn't as bad as we had expected it to be, but it is still significant.

528
00:35:30,547 --> 00:35:36,952
So I have a couple of examples here for the inquisitive mind of certain situations that

529
00:35:36,972 --> 00:35:40,295
we ran into during this project.

530
00:35:42,100 --> 00:35:45,262
So first of all, there's this case of missing code blocks,

531
00:35:45,503 --> 00:35:46,323
nested code blocks.

532
00:35:47,444 --> 00:35:49,466
Then we have using outputs as temporaries.

533
00:35:50,707 --> 00:35:53,309
And finally, broken uniform structures.

534
00:35:56,432 --> 00:35:58,574
So let's talk about the missing code blocks first.

535
00:36:00,415 --> 00:36:04,799
So when we were analyzing the recorded video from our test

536
00:36:04,859 --> 00:36:08,842
cases, we noticed that on some devices, the hero characters

537
00:36:08,982 --> 00:36:11,344
were darker than on other devices.

538
00:36:12,654 --> 00:36:17,598
Digging into this, I pinpointed the issue to a function roughly like this.

539
00:36:18,118 --> 00:36:23,743
So we were doing srdb decoding if a constant was set to true.

540
00:36:25,204 --> 00:36:28,807
And I thought that, well, maybe it's the constant that just has the wrong value, so I'll just

541
00:36:28,827 --> 00:36:33,030
hack it in and just try, you know, checking if true is true.

542
00:36:34,371 --> 00:36:36,573
But this did not fix the issue.

543
00:36:37,982 --> 00:36:40,363
So at this point, I was like, well, maybe it's actually a

544
00:36:40,403 --> 00:36:43,645
driver issue, so I'll just remove the if, and at least

545
00:36:43,705 --> 00:36:45,106
now it should execute that code.

546
00:36:46,306 --> 00:36:47,166
Turns out it didn't.

547
00:36:48,987 --> 00:36:53,489
So the result was that the driver just didn't like

548
00:36:54,648 --> 00:36:59,752
code blocks within functions, which was pretty ugly because we had to move this

549
00:37:00,212 --> 00:37:02,793
type of code to the main function.

550
00:37:03,914 --> 00:37:08,557
Putting any code like this in a nested function or a function that was called from main

551
00:37:09,057 --> 00:37:09,858
just did not work.

552
00:37:10,218 --> 00:37:15,401
And this was a relatively new OpenGL ES3 level device.

553
00:37:19,772 --> 00:37:23,074
Then we have this case of using fragment output as temporaries.

554
00:37:23,494 --> 00:37:25,315
This is actually something where we did wrong,

555
00:37:25,495 --> 00:37:28,616
but the result was quite interesting, I think.

556
00:37:30,397 --> 00:37:35,680
So in the recording, we saw that on some devices,

557
00:37:36,200 --> 00:37:39,021
the characters were drawn in grayscale.

558
00:37:41,542 --> 00:37:44,264
And I pinpointed it to code like this.

559
00:37:44,784 --> 00:37:47,465
So we were writing into the fragment output.

560
00:37:48,469 --> 00:37:52,030
And then we were doing the linear to sRGB encoding here

561
00:37:53,310 --> 00:37:57,471
by reading from the output value and writing it back.

562
00:38:00,151 --> 00:38:03,412
Doing it from the temporary value basically fixed the issue.

563
00:38:03,712 --> 00:38:05,813
So we're not reading from fracColor anymore.

564
00:38:07,473 --> 00:38:12,014
This is something that the OpenTL specification actually states should not be done.

565
00:38:12,294 --> 00:38:15,414
So you should never read from the fragment output.

566
00:38:15,434 --> 00:38:16,535
You should only write into that.

567
00:38:19,527 --> 00:38:24,070
But nevertheless, it was really interesting how it worked on some

568
00:38:24,130 --> 00:38:26,992
devices and the compiler didn't really complain about it.

569
00:38:27,272 --> 00:38:31,235
And the output was a very interesting case.

570
00:38:34,217 --> 00:38:37,340
Finally, there's the case of broken uniform structures.

571
00:38:38,100 --> 00:38:40,582
So on some devices, we just had a black screen.

572
00:38:41,403 --> 00:38:44,485
So this is like the worst nightmare of any rendering engineers,

573
00:38:44,545 --> 00:38:45,586
looking at a black screen.

574
00:38:45,646 --> 00:38:47,687
You have no idea if it's rendering anything.

575
00:38:49,038 --> 00:38:53,241
But look, I opened the build on the machine,

576
00:38:53,261 --> 00:38:54,402
a device where it was broken,

577
00:38:55,023 --> 00:38:57,245
and I was looking at it for quite a long time,

578
00:38:57,365 --> 00:38:58,766
thinking what could be wrong,

579
00:38:59,126 --> 00:39:01,508
and then I noticed some small flickering

580
00:39:01,969 --> 00:39:03,890
at the lower corner of the screen.

581
00:39:04,711 --> 00:39:06,072
So I thought that, well, definitely,

582
00:39:06,112 --> 00:39:08,835
it is rendering something, but what's wrong with this?

583
00:39:10,310 --> 00:39:14,633
So I looked at it using GAPID, which is an Android graphics debugging tool,

584
00:39:15,113 --> 00:39:18,775
and it showed some inconsistencies between two different views.

585
00:39:19,476 --> 00:39:24,199
These views displayed the uniform data of the shader program.

586
00:39:25,340 --> 00:39:27,161
So it was just showing different data there.

587
00:39:29,022 --> 00:39:33,705
So this is how we had defined the uniform block in the source shader.

588
00:39:35,366 --> 00:39:40,289
And this was converted for the OpenGL ES2 backend,

589
00:39:40,710 --> 00:39:42,971
which did not have uniform buffer support,

590
00:39:43,932 --> 00:39:44,832
into code like this.

591
00:39:45,773 --> 00:39:48,995
So it generated a structure with a couple of matrices

592
00:39:49,556 --> 00:39:51,677
and then a uniform based on that structure.

593
00:39:53,554 --> 00:39:57,856
Turns out, the driver didn't like uniforms defined in this way.

594
00:39:58,696 --> 00:40:00,977
And when we were updating the uniform values,

595
00:40:01,437 --> 00:40:06,680
some of the columns in uView got values from uProjectionView.

596
00:40:07,000 --> 00:40:11,242
So it was messing up the locations of the uniforms in some weird way.

597
00:40:13,287 --> 00:40:20,416
The resolution to this issue was to use something in SpervyX that basically flattens out the

598
00:40:20,516 --> 00:40:23,219
uniform block into a vec4 array.

599
00:40:23,780 --> 00:40:28,946
So we could just update this whole uniform using a single uniform, glUniform call.

600
00:40:29,727 --> 00:40:35,174
The only problem was that this does not allow interleaving floating point values with integer

601
00:40:35,194 --> 00:40:41,462
values in the uniform block. But for the games that had this issue and needed to use the OpenGL ES2

602
00:40:41,723 --> 00:40:44,586
backend, this was not really an issue.

603
00:40:49,366 --> 00:40:53,389
So finally, I wanted to talk about something very important

604
00:40:54,230 --> 00:40:56,812
that's kind of been glanced over during this presentation,

605
00:40:57,052 --> 00:40:58,513
but I wanted to highlight at this point,

606
00:40:59,053 --> 00:41:01,115
which is the whole getting it done mentality

607
00:41:01,155 --> 00:41:02,136
that we have at the company.

608
00:41:03,617 --> 00:41:07,039
So our culture is really about empowering people

609
00:41:07,119 --> 00:41:08,300
to do their best work.

610
00:41:09,910 --> 00:41:11,912
We have very little red tape.

611
00:41:12,272 --> 00:41:14,794
So whenever you need to do something

612
00:41:15,074 --> 00:41:17,076
and you need to start off a project

613
00:41:17,116 --> 00:41:18,537
to improve a certain system,

614
00:41:19,037 --> 00:41:21,679
you don't have to go through a lot of different kinds

615
00:41:21,839 --> 00:41:24,421
of organizational hoops.

616
00:41:25,082 --> 00:41:27,644
Don't have to go through different levels of management

617
00:41:27,684 --> 00:41:30,206
to make designs and get approvals for them.

618
00:41:30,846 --> 00:41:33,668
You can just kind of become your own project manager

619
00:41:33,768 --> 00:41:34,969
and start moving it forward.

620
00:41:36,140 --> 00:41:41,363
Of course, there are cases where this doesn't work for big structural changes,

621
00:41:42,543 --> 00:41:45,665
some strategically important things.

622
00:41:46,745 --> 00:41:51,347
But for most of the system development that we're doing, it works really well.

623
00:41:53,465 --> 00:41:57,286
People also tend to take responsibility and ownership of the code that they're

624
00:41:57,326 --> 00:41:59,547
developing and the systems that they're working on.

625
00:42:00,327 --> 00:42:05,009
So I usually say that it's not really a problem if you screw up.

626
00:42:05,329 --> 00:42:06,209
That's totally okay.

627
00:42:06,249 --> 00:42:10,871
That's, that's human, but it's really what happens after that, what matters.

628
00:42:11,651 --> 00:42:17,753
So if you really take, um, take up the responsibility and you help people fix

629
00:42:17,833 --> 00:42:22,675
your, your issues, or you fix them yourselves, that is really the important thing.

630
00:42:25,787 --> 00:42:32,631
And this whole mentality of autonomous development, basically,

631
00:42:32,931 --> 00:42:36,814
being able to do that, allowed me to work efficiently and move

632
00:42:36,854 --> 00:42:40,016
between different game teams and talk directly with the game teams

633
00:42:40,116 --> 00:42:43,618
and get things done really quickly and make big decisions

634
00:42:44,358 --> 00:42:46,420
without going through different levels of management.

635
00:42:49,192 --> 00:42:50,993
Of course, it's not all roses.

636
00:42:51,133 --> 00:42:54,214
Like, you know, some people occasionally make decisions

637
00:42:54,274 --> 00:42:57,615
without making the necessary preparations

638
00:42:57,735 --> 00:43:00,256
and talking to people who actually, like,

639
00:43:00,456 --> 00:43:03,717
know about the system that this person will be working on.

640
00:43:04,197 --> 00:43:07,319
But overall, the benefits really outweigh the downsides,

641
00:43:07,519 --> 00:43:08,979
and it's been working really well.

642
00:43:11,740 --> 00:43:13,821
So this actually brings me to my conclusions.

643
00:43:15,106 --> 00:43:18,067
So first of all, we built technology for a need.

644
00:43:18,427 --> 00:43:21,688
So for Thor, we really needed to add mental support,

645
00:43:21,908 --> 00:43:22,728
so that was a given.

646
00:43:23,208 --> 00:43:25,149
But we also wanted to make it possible

647
00:43:25,269 --> 00:43:26,689
for game rendering engineers

648
00:43:26,750 --> 00:43:29,670
to build better visuals in the future.

649
00:43:30,551 --> 00:43:33,292
So we were not just rebuilding something

650
00:43:33,332 --> 00:43:35,432
just because it was a fun thing to do.

651
00:43:38,225 --> 00:43:42,507
We also had to proceed really carefully because we were rewriting the

652
00:43:42,547 --> 00:43:44,248
render of billion dollar games.

653
00:43:44,788 --> 00:43:49,670
So we wanted to make sure that we're not, um, we're not putting all of our

654
00:43:49,710 --> 00:43:51,711
eggs in a single basket and then dropping it.

655
00:43:55,433 --> 00:43:58,834
And finally, Thor is our platform for the future for rendering.

656
00:43:59,374 --> 00:44:03,857
So we were able to build this common language that now all the different

657
00:44:03,897 --> 00:44:07,778
game teams use, and we can rely on, and now we can build on top of this.

658
00:44:09,888 --> 00:44:13,050
And finally, there is a very important thing that I wanted to mention here,

659
00:44:13,070 --> 00:44:14,550
which is that we are hiring.

660
00:44:15,090 --> 00:44:18,092
So if you want to know more about the company,

661
00:44:18,412 --> 00:44:22,073
you can come talk to me or any one of the supercellians roaming around here,

662
00:44:22,233 --> 00:44:24,294
of which there are quite many this year, actually.

663
00:44:26,255 --> 00:44:29,536
But apart from that, I think it's time for questions now.

664
00:44:30,356 --> 00:44:31,097
I thank you very much.

665
00:44:40,449 --> 00:44:47,856
So earlier you mentioned that you tried to put your game on the slower cores on mobile.

666
00:44:49,958 --> 00:44:55,384
I'd like to know how you do that on iOS, which doesn't provide an API for Thread Affinity.

667
00:44:57,286 --> 00:44:58,086
Basically

668
00:45:00,024 --> 00:45:03,647
really about like how much you actually push the CPUs.

669
00:45:04,127 --> 00:45:07,570
So just try to like be as efficient as possible

670
00:45:07,770 --> 00:45:09,432
and it'll automatically move it there.

671
00:45:09,852 --> 00:45:13,835
So in Clash's case, it is relatively lightweight on the CPUs

672
00:45:13,895 --> 00:45:15,256
so it kind of naturally happens.

673
00:45:16,217 --> 00:45:18,079
But yes, it is true that there's like no way

674
00:45:18,119 --> 00:45:19,020
of defining that.

675
00:45:19,460 --> 00:45:22,342
But then again, if you do have that interface

676
00:45:22,402 --> 00:45:24,804
and then you force it onto the low power course

677
00:45:24,904 --> 00:45:25,845
and it's not enough,

678
00:45:26,045 --> 00:45:27,967
then you're not gonna have the frame rate that you want.

679
00:45:28,707 --> 00:45:33,729
So the best way is to just like make sure that you have as efficient,

680
00:45:33,889 --> 00:45:37,810
use as efficient algorithms as possible to just naturally make it happen.

681
00:45:38,951 --> 00:45:40,951
Yeah, we're running into that problem. Thank you.

682
00:45:41,191 --> 00:45:42,612
Okay, yeah, no problem. Thanks.

683
00:45:48,994 --> 00:45:52,095
Yeah, I have mostly the same question, but don't you run into the issue that

684
00:45:52,115 --> 00:45:56,237
when you run on the low power cores that you're not getting your deadlines, for example?

685
00:45:59,955 --> 00:46:01,636
It's pretty smart at actually scaling.

686
00:46:01,916 --> 00:46:03,957
Like, you know, there are cases where

687
00:46:04,898 --> 00:46:06,699
if you try to do something really smart,

688
00:46:06,739 --> 00:46:08,200
like automatically scale your,

689
00:46:08,280 --> 00:46:09,341
like especially in Metal,

690
00:46:09,741 --> 00:46:14,224
if you try to scale your presentation times

691
00:46:14,605 --> 00:46:16,326
based on like the actual time

692
00:46:16,406 --> 00:46:18,007
that you're executing on the GPU,

693
00:46:18,307 --> 00:46:20,288
then you get this kind of rubber band effect

694
00:46:20,489 --> 00:46:23,090
where it's like spending more time

695
00:46:23,150 --> 00:46:25,272
and then you scale it down,

696
00:46:25,332 --> 00:46:27,153
then spending less and you scale it up.

697
00:46:28,874 --> 00:46:34,859
But yeah, so it can be, you know, it's a difficult problem in some cases to solve.

698
00:46:35,419 --> 00:46:43,105
And it's really about like trial and error and looking at your metrics using the tools that you have and what you can do there.

699
00:46:43,125 --> 00:46:44,506
All right. Thank you.

700
00:46:47,727 --> 00:46:53,356
Hi, how are you finding the driver stability on like Android Vulkan drivers?

701
00:46:53,596 --> 00:46:58,965
Are you finding bugs with all the drivers or are you having to limit your devices to

702
00:46:59,005 --> 00:47:00,989
like a known set of devices?

703
00:47:02,110 --> 00:47:06,672
Yes, so we've been seeing multiple issues,

704
00:47:06,972 --> 00:47:10,394
like some very weird cases,

705
00:47:10,494 --> 00:47:13,796
even on high-end devices,

706
00:47:13,916 --> 00:47:18,858
things like the pipeline cache

707
00:47:18,898 --> 00:47:19,879
is not working at all

708
00:47:19,959 --> 00:47:23,040
for a large amount of specialization constants.

709
00:47:23,781 --> 00:47:26,482
So it is a kind of a challenging world.

710
00:47:26,562 --> 00:47:27,283
It's getting better.

711
00:47:28,561 --> 00:47:33,565
The problem really is that you have the baseline profiles

712
00:47:33,585 --> 00:47:36,208
that you can rely on, but that doesn't really tell anything

713
00:47:36,248 --> 00:47:37,589
about the quality of the driver.

714
00:47:38,350 --> 00:47:42,293
So it is just a thing that's improving over time

715
00:47:42,373 --> 00:47:45,816
and we just need to maybe try it out on those devices

716
00:47:45,876 --> 00:47:48,358
and then blacklist them if it just doesn't work there

717
00:47:48,578 --> 00:47:50,580
and move on there incrementally.

718
00:47:51,301 --> 00:47:54,003
But yeah, definitely we're running into those issues.

719
00:47:54,584 --> 00:47:55,084
Okay, thank you.

720
00:47:55,464 --> 00:47:55,645
Thanks.

721
00:47:56,640 --> 00:47:58,521
Hey, thanks for the talk.

722
00:47:59,382 --> 00:48:07,129
When you selected Spire V, did you analyze other tools like BGFX or other kind of backends like that?

723
00:48:08,410 --> 00:48:09,310
Excuse me, selected what?

724
00:48:09,871 --> 00:48:17,978
When you selected Spire V, did you analyze other tools like BGFX or others?

725
00:48:19,571 --> 00:48:26,619
Spervy basically was like a, it was a pretty good natural selection in the sense that it

726
00:48:26,659 --> 00:48:28,200
worked directly for Vulkan as well.

727
00:48:28,561 --> 00:48:31,904
And there were pretty good tools for that, like Spervy cross, which we could use.

728
00:48:32,525 --> 00:48:34,707
The first Spervy cross is not.

729
00:48:35,228 --> 00:48:37,551
Perfect. And Spurvy itself is not perfect.

730
00:48:37,571 --> 00:48:42,076
So we run into issues with, for instance, floating point 16 support,

731
00:48:42,557 --> 00:48:46,542
which Metal doesn't support the relax position attributes on there.

732
00:48:46,642 --> 00:48:50,246
So it gets a bit tricky to add like floating point 16 support.

733
00:48:51,067 --> 00:48:52,449
So definitely it's not perfect.

734
00:48:54,551 --> 00:48:54,711
But.

735
00:48:56,291 --> 00:49:00,595
We didn't really, really, think we didn't really do

736
00:49:01,175 --> 00:49:03,777
really in-depth analysis on that, to be honest,

737
00:49:05,238 --> 00:49:08,121
but it was just a tool that looked to fit

738
00:49:08,321 --> 00:49:10,302
our requirements really well overall,

739
00:49:10,463 --> 00:49:11,624
and the pipeline was there.

740
00:49:11,684 --> 00:49:14,206
We could cover all of the different use cases

741
00:49:14,266 --> 00:49:17,088
like Metal and OpenGL and Vulkan for us with that.

742
00:49:17,929 --> 00:49:22,630
But we have been thinking about potentially either switching a solution

743
00:49:23,010 --> 00:49:27,432
or potentially even building our own pipeline on there because of some

744
00:49:27,452 --> 00:49:28,772
of the issues that we're having with it.

745
00:49:29,533 --> 00:49:31,674
But I hope that answers your question.

746
00:49:31,834 --> 00:49:32,854
Thanks.

747
00:49:34,254 --> 00:49:34,354
Hi.

748
00:49:34,815 --> 00:49:37,836
What tool were you using to measure wattage on the iPhone 7?

749
00:49:39,276 --> 00:49:41,157
This was like GameBench, I think.

750
00:49:41,337 --> 00:49:41,497
Yeah.

751
00:49:46,315 --> 00:49:52,203
When you find problems with the drivers, are you just doing workarounds and moving on,

752
00:49:52,363 --> 00:49:58,231
or are you contacting the driver manufacturers? And if so, how long does it take till that gets resolved?

753
00:49:58,675 --> 00:50:04,459
Well, both, but the problem really is that it's not a practical route to expect the driver

754
00:50:04,519 --> 00:50:09,283
update, because many of the drivers actually never get updated.

755
00:50:09,643 --> 00:50:15,227
And you might have like even slightly older devices which are updated like maybe for two

756
00:50:15,267 --> 00:50:17,990
years or so, and then after that they never get any updates.

757
00:50:18,610 --> 00:50:21,753
or like the drivers might even never be updated.

758
00:50:22,273 --> 00:50:25,996
So we usually have to just work around the issue in some way

759
00:50:26,597 --> 00:50:30,680
and then, you know, just hope that it's going to be fixed at some point.

760
00:50:31,321 --> 00:50:31,521
Thanks.

761
00:50:32,242 --> 00:50:32,522
Thanks.

762
00:50:37,446 --> 00:50:40,088
So if there are no other questions, then I thank you very much.

763
00:50:45,551 --> 00:50:45,611
I

764
00:50:45,631 --> 00:50:46,838
hope you enjoyed the video.

765
00:50:46,878 --> 00:50:47,501
Thank you for watching.

766
00:50:47,582 --> 00:50:47,823
See you soon.

767
00:50:47,843 --> 00:50:47,904
Bye.

768
00:50:47,924 --> 00:50:48,044
Bye.

769
00:50:48,065 --> 00:50:48,125
Bye.

770
00:50:48,145 --> 00:50:48,205
Bye.

771
00:50:48,306 --> 00:50:48,406
Bye .

