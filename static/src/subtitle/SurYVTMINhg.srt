1
00:00:05,938 --> 00:00:07,439
All right, without further ado.

2
00:00:08,620 --> 00:00:09,200
Hello, everybody.

3
00:00:09,540 --> 00:00:10,201
I'm Robert Meyer.

4
00:00:10,601 --> 00:00:13,483
I'm a game designer focusing on AI at Avalanche Studios.

5
00:00:13,903 --> 00:00:16,244
Welcome to Tree's Company, Systemic AI Design,

6
00:00:16,405 --> 00:00:16,925
and Just Cause 3.

7
00:00:17,005 --> 00:00:20,707
To just quickly introduce myself,

8
00:00:21,108 --> 00:00:23,189
I attended NYU, New York University,

9
00:00:23,349 --> 00:00:25,530
where I studied film, but also dabbled

10
00:00:25,550 --> 00:00:28,052
in what was then the infancy of the NYU Game Center.

11
00:00:28,913 --> 00:00:31,254
After that, I worked at a couple of smaller and indie game

12
00:00:31,294 --> 00:00:33,055
studios around New York for a while.

13
00:00:33,764 --> 00:00:37,449
And for the last three or so years, I've been an AI designer at Avalanche Studios.

14
00:00:37,710 --> 00:00:41,596
And of course, this talk will mostly focus on my time as an AI designer on Just Cause 3.

15
00:00:44,875 --> 00:00:46,376
So what is AI in Just Cause 3?

16
00:00:46,956 --> 00:00:49,538
Well, Just Cause 3 is a chaotic, over-the-top,

17
00:00:49,699 --> 00:00:51,600
open-world action game where the player

18
00:00:51,620 --> 00:00:54,362
has incredibly powerful traversal and combat mechanics.

19
00:00:55,003 --> 00:00:56,344
There are destructible environments,

20
00:00:56,724 --> 00:00:58,766
loads of dynamic objects, and tons of ways

21
00:00:58,806 --> 00:01:00,487
for the player to mess around with the AI.

22
00:01:01,088 --> 00:01:02,869
The player can hijack AI vehicles,

23
00:01:03,370 --> 00:01:04,851
shoot AI out of their parachutes.

24
00:01:05,151 --> 00:01:06,512
The player can use their grappling hook

25
00:01:06,552 --> 00:01:08,193
to tether a character to their jet

26
00:01:08,233 --> 00:01:09,895
and then fly them halfway across the world.

27
00:01:10,788 --> 00:01:14,498
Basically, there are an extremely high amount of unpredictable things that can happen to

28
00:01:14,719 --> 00:01:16,504
or near the AI at any given time.

29
00:01:20,464 --> 00:01:22,504
So how did AI process everything around them,

30
00:01:22,564 --> 00:01:24,605
all this information, and make any sort of decisions?

31
00:01:24,845 --> 00:01:26,225
Well, we use behavior trees,

32
00:01:26,345 --> 00:01:28,526
which of course is not that uncommon in AI design.

33
00:01:29,166 --> 00:01:30,886
This is what our behavior trees looked like

34
00:01:31,006 --> 00:01:32,887
for our combatants in Just Cause 3.

35
00:01:33,527 --> 00:01:35,307
Each agent runs one of these trees,

36
00:01:35,547 --> 00:01:36,487
sort of as their brain.

37
00:01:37,267 --> 00:01:39,208
For now, just think of the leaves at the bottom

38
00:01:39,408 --> 00:01:40,628
as basically sub-trees,

39
00:01:41,008 --> 00:01:42,588
different states that the AI can be in

40
00:01:42,628 --> 00:01:45,449
that sort of exist in a dynamic, prioritized list.

41
00:01:47,319 --> 00:01:50,122
inside each of these subtrees, if you were to expand it,

42
00:01:50,142 --> 00:01:51,643
you know, double click it, go into it,

43
00:01:51,964 --> 00:01:54,727
it would reveal much, much more behavior tree script

44
00:01:54,767 --> 00:01:56,809
that controls all the actual decision making

45
00:01:56,849 --> 00:01:58,751
and processes that this state performs.

46
00:01:59,091 --> 00:02:00,153
But for now, we're just gonna look

47
00:02:00,193 --> 00:02:01,875
at this higher level abstracted view.

48
00:02:03,870 --> 00:02:05,551
Now, in addition to behavior trees,

49
00:02:06,132 --> 00:02:09,555
agents in Just Cause 3 also utilize various utility functions

50
00:02:09,975 --> 00:02:12,737
for the purpose of computing things like ideal positions to move to

51
00:02:13,218 --> 00:02:15,920
or which eligible targets to focus on.

52
00:02:16,500 --> 00:02:19,323
A utility function is a function that ranks a bunch of different options

53
00:02:19,403 --> 00:02:21,344
according to their utility to an individual.

54
00:02:21,965 --> 00:02:25,549
So here, this agent is ranking each position you see a sphere at

55
00:02:25,989 --> 00:02:28,672
based on a variety of things like proximity to the target,

56
00:02:28,852 --> 00:02:32,136
line of sight to the target, distance from other allies, etc.

57
00:02:32,696 --> 00:02:35,699
The greener positions are the ones with a higher utility score

58
00:02:35,820 --> 00:02:38,062
and so those are the positions that the enemy character you see

59
00:02:38,122 --> 00:02:39,283
is going to prefer to stay around.

60
00:02:40,265 --> 00:02:42,226
Note that this utility function evaluation

61
00:02:42,447 --> 00:02:45,089
does not actually take place inside the behavior tree itself,

62
00:02:45,449 --> 00:02:47,191
but rather in code outside of it.

63
00:02:47,531 --> 00:02:49,332
The behavior tree simply requests,

64
00:02:49,713 --> 00:02:51,574
give me a good combat position to move to,

65
00:02:51,594 --> 00:02:53,536
and then utility function does its thing

66
00:02:53,676 --> 00:02:55,217
and returns the position to the AI.

67
00:02:55,938 --> 00:02:58,320
So in a sense, you can think of the AI in Just Cause 3

68
00:02:58,420 --> 00:03:00,502
as being composed primarily of behavior trees

69
00:03:00,702 --> 00:03:01,823
and these utility functions.

70
00:03:03,944 --> 00:03:05,846
Now, the problem I'm mostly gonna talk about today

71
00:03:06,126 --> 00:03:07,127
stems from a few things.

72
00:03:07,407 --> 00:03:07,808
Firstly,

73
00:03:08,757 --> 00:03:10,559
Our behavior trees are very bottom-up.

74
00:03:11,079 --> 00:03:12,821
Each individual is making their own decisions.

75
00:03:13,041 --> 00:03:16,144
We have very few coordinators or managers of any type.

76
00:03:16,204 --> 00:03:17,925
It's a very individualistic system.

77
00:03:18,746 --> 00:03:20,628
Originally, this was built for the robust

78
00:03:20,688 --> 00:03:22,129
and emergent systemic behaviors

79
00:03:22,749 --> 00:03:24,171
that would flourish in the open world,

80
00:03:24,231 --> 00:03:25,992
but not for any sort of scripted content.

81
00:03:26,773 --> 00:03:28,374
And the behavior trees are pretty complex.

82
00:03:28,494 --> 00:03:30,396
They're complex enough that content designers

83
00:03:30,496 --> 00:03:31,717
are not gonna be able to open them

84
00:03:31,837 --> 00:03:33,459
and look inside and modify them

85
00:03:33,499 --> 00:03:34,680
or understand what's going on.

86
00:03:36,409 --> 00:03:38,971
But of course, we're still an open world game

87
00:03:38,991 --> 00:03:40,913
with story, missions, set pieces.

88
00:03:41,153 --> 00:03:43,275
Occasionally we need the AI to do specific,

89
00:03:43,375 --> 00:03:45,617
predetermined things, like waiting for Rico,

90
00:03:45,677 --> 00:03:47,579
the main character, to use their grappling hook

91
00:03:47,659 --> 00:03:49,240
retract ability to open a gate.

92
00:03:49,981 --> 00:03:51,942
In this scene, Rico the player can be seen

93
00:03:52,002 --> 00:03:54,064
in a military station with his ally Mario,

94
00:03:54,244 --> 00:03:55,385
right after a fight is finished.

95
00:03:58,245 --> 00:04:01,489
This being a very early mission, we reinforce the power of the grappling hook

96
00:04:01,630 --> 00:04:05,875
by asking the player to use it to open a gate so a rescue vehicle can come in and pick up Mario.

97
00:04:06,416 --> 00:04:09,519
Of course, Mario's behavior here feels very scripted and instructed.

98
00:04:09,640 --> 00:04:13,224
He's waiting for the gate to open, playing a special animation that points at it,

99
00:04:13,424 --> 00:04:16,068
and once the gate opens, he then scrambles to get into the vehicle.

100
00:04:18,543 --> 00:04:22,344
So the goal of them is, of course, to create a technical design for our AI,

101
00:04:22,585 --> 00:04:25,966
an interface that allows the AI to still be built on these systemic behavior

102
00:04:25,986 --> 00:04:29,628
trees and utility functions, while also still empowering content designers

103
00:04:29,668 --> 00:04:31,468
to create whatever scripted content they desire.

104
00:04:33,113 --> 00:04:34,914
When I talk about empowering content designers,

105
00:04:35,114 --> 00:04:37,035
I'm specifically talking about mission designers

106
00:04:37,095 --> 00:04:39,256
to create whatever objective sequences they can imagine,

107
00:04:39,816 --> 00:04:41,877
world designers to create unique open moments

108
00:04:41,937 --> 00:04:43,118
and open world locations,

109
00:04:43,758 --> 00:04:45,138
and encounter designers to create

110
00:04:45,178 --> 00:04:46,799
these sort of bite-sized narrative bits

111
00:04:46,839 --> 00:04:48,640
that we have procedurally generate in our world.

112
00:04:50,461 --> 00:04:52,462
And I think to understand some of the solutions

113
00:04:52,482 --> 00:04:53,542
that I'm about to talk through,

114
00:04:53,562 --> 00:04:55,843
it helps to understand the division of labor

115
00:04:56,343 --> 00:04:58,444
of designers at Avalanche Studios New York.

116
00:04:59,937 --> 00:05:04,864
The AI designers, like me, we're the ones that do all the scripting of the actual behavior trees themselves.

117
00:05:05,325 --> 00:05:09,170
We work with AI programmers who help us build all the lower level building blocks,

118
00:05:09,210 --> 00:05:11,233
but we're the ones who actually put the behavior trees together.

119
00:05:11,934 --> 00:05:13,735
We also tune all the utility functions.

120
00:05:13,795 --> 00:05:17,778
We say it's really important to stand where you have line of sight to the target.

121
00:05:17,858 --> 00:05:23,562
In fact, it's five times more important to stand there than it is to stand this amount of distance away from an ally, for example.

122
00:05:24,182 --> 00:05:27,584
We create a variety of AI templates and packages for other designers to use.

123
00:05:28,045 --> 00:05:30,946
Really, anything technical design related to the AI, we do.

124
00:05:31,848 --> 00:05:33,609
Whereas the content designers, as we call it,

125
00:05:34,030 --> 00:05:35,591
are people who might be level designers

126
00:05:35,691 --> 00:05:37,413
or mission designers or world designers.

127
00:05:37,813 --> 00:05:39,534
They're the ones actually placing the characters

128
00:05:39,654 --> 00:05:41,216
in the world, and importantly,

129
00:05:41,336 --> 00:05:43,838
they can fill out the exposed arguments and parameters

130
00:05:44,038 --> 00:05:45,459
on any of these character spawners.

131
00:05:46,660 --> 00:05:47,681
Another way to think about this

132
00:05:47,961 --> 00:05:49,463
might be by looking at the tools we use.

133
00:05:49,943 --> 00:05:52,465
This is our proprietary behavior tree scripting tool,

134
00:05:52,926 --> 00:05:54,607
and so this is what me, as an AI designer,

135
00:05:54,787 --> 00:05:56,208
this is what I'm looking at most of my day.

136
00:05:58,213 --> 00:06:00,975
Now, for now, just note that if I select the root view,

137
00:06:00,995 --> 00:06:02,496
the very top of this behavior tree,

138
00:06:02,777 --> 00:06:05,539
that gives me the ability to expose certain parameters,

139
00:06:05,599 --> 00:06:08,381
certain arguments, variables that the content designer

140
00:06:08,461 --> 00:06:11,084
can then fill out when they're placing this AI

141
00:06:11,184 --> 00:06:12,585
using this behavior tree in the world.

142
00:06:14,026 --> 00:06:15,047
Now, the content designer,

143
00:06:15,407 --> 00:06:17,089
they work in our level editor, our engine,

144
00:06:17,529 --> 00:06:19,391
and so here they've placed an enemy character

145
00:06:19,631 --> 00:06:20,992
using a character rule,

146
00:06:21,212 --> 00:06:23,294
which is a thing that just spawns a character.

147
00:06:24,348 --> 00:06:26,068
And when they select that character rule,

148
00:06:26,508 --> 00:06:28,389
they'll be able to see those same arguments,

149
00:06:28,409 --> 00:06:30,610
those same parameters that I as an AI designer

150
00:06:30,930 --> 00:06:32,550
set to be exposed from the behavior tree.

151
00:06:34,491 --> 00:06:36,071
So this is basically what we have to work with

152
00:06:36,111 --> 00:06:37,011
to solve this problem.

153
00:06:38,112 --> 00:06:41,473
The AI designer can write the behavior tree,

154
00:06:41,793 --> 00:06:43,193
set what arguments are exposed.

155
00:06:43,453 --> 00:06:45,634
The content designer has access to those arguments

156
00:06:45,674 --> 00:06:47,734
or parameters whenever they spawn a character.

157
00:06:48,094 --> 00:06:49,615
So the content designer can fill them out,

158
00:06:49,795 --> 00:06:51,015
and then whatever they fill them out with,

159
00:06:51,175 --> 00:06:52,636
that's data that can be read and used

160
00:06:52,736 --> 00:06:53,616
inside the behavior tree.

161
00:06:55,929 --> 00:07:00,192
Now, the last thing I want to cover before I get into the core solutions and methods

162
00:07:00,292 --> 00:07:04,114
is that I'd like to help you form a mental model of how our behavior trees actually work.

163
00:07:04,495 --> 00:07:06,016
A lot of people do it a little bit differently.

164
00:07:07,181 --> 00:07:09,403
So pictured here is how our behavior tree flows

165
00:07:09,543 --> 00:07:11,324
on the first frame of a combatant's life.

166
00:07:11,965 --> 00:07:13,786
Basically, this GIF is a debug view

167
00:07:13,866 --> 00:07:16,288
of me kind of just stepping over all of these subtrees.

168
00:07:16,788 --> 00:07:19,190
You can see that each node can return a success,

169
00:07:19,670 --> 00:07:21,672
working, or fail state every frame.

170
00:07:21,992 --> 00:07:24,194
So that's what that check mark gear icon

171
00:07:24,254 --> 00:07:27,336
or X icon represents as you see me step over each subtree.

172
00:07:28,197 --> 00:07:29,959
So starting at the top, right on spawn,

173
00:07:30,320 --> 00:07:31,461
you see this yellow circle.

174
00:07:31,642 --> 00:07:32,703
That's what we call a sequence.

175
00:07:33,064 --> 00:07:35,387
It will run all the nodes under it from left to right.

176
00:07:35,828 --> 00:07:37,770
So first it runs this init subtree,

177
00:07:37,850 --> 00:07:39,733
which just initializes a bunch of data,

178
00:07:39,813 --> 00:07:41,896
like the AI looks at what weapon they're spawned with,

179
00:07:41,976 --> 00:07:43,719
and so they kind of set up some things based on that.

180
00:07:44,059 --> 00:07:45,420
but that only ever needs to run once.

181
00:07:45,920 --> 00:07:48,821
Then it moves over to this yellow square called a parallel.

182
00:07:49,242 --> 00:07:51,583
The parallel runs all nodes under it every frame.

183
00:07:51,903 --> 00:07:53,764
So first it runs an update subtree,

184
00:07:54,164 --> 00:07:56,365
which looks at a bunch of different data in the world

185
00:07:56,465 --> 00:07:58,006
and sets up a bunch of internal data.

186
00:07:58,466 --> 00:07:59,687
Probably the most important thing

187
00:07:59,727 --> 00:08:01,208
that our update subtree does

188
00:08:01,368 --> 00:08:03,989
is it selects what combat target this AI should focus on.

189
00:08:05,917 --> 00:08:08,077
Then the parallel moves over to this green circle

190
00:08:08,197 --> 00:08:08,937
called the selector.

191
00:08:09,317 --> 00:08:11,558
Now, don't worry about remembering any of this vocabulary.

192
00:08:11,598 --> 00:08:12,418
It's not that important.

193
00:08:12,438 --> 00:08:15,379
Just kind of try to grok the general flow of things.

194
00:08:16,039 --> 00:08:17,159
So the selector first says,

195
00:08:17,259 --> 00:08:19,580
do I have any special behavior to run on spawn,

196
00:08:19,860 --> 00:08:20,580
an intro behavior?

197
00:08:20,680 --> 00:08:21,480
In this case, I don't,

198
00:08:21,801 --> 00:08:24,081
so I'm gonna move along to this green square at the bottom

199
00:08:24,141 --> 00:08:25,301
called the dynamic selector.

200
00:08:25,902 --> 00:08:28,482
The dynamic selector checks every node under it

201
00:08:28,602 --> 00:08:30,423
all the way from left to right every frame.

202
00:08:30,543 --> 00:08:32,823
It's sort of like a prioritized if-else list.

203
00:08:33,323 --> 00:08:34,884
It checks all these different subtrees

204
00:08:34,924 --> 00:08:36,444
to first find the one that's valid,

205
00:08:36,544 --> 00:08:38,304
and once it finds a valid one, it's happy,

206
00:08:38,364 --> 00:08:39,165
and that's where it runs.

207
00:08:40,485 --> 00:08:42,505
If we were to look at the next frame of this combatant's life,

208
00:08:42,545 --> 00:08:43,966
the second frame after they've spawned,

209
00:08:44,446 --> 00:08:47,146
we see that they no longer need to check their init subtree

210
00:08:47,226 --> 00:08:49,067
or if they have a special on-spawn behavior.

211
00:08:49,227 --> 00:08:51,507
At this point, they're just checking their update subtree

212
00:08:51,627 --> 00:08:54,168
and the main dynamic selector of possible behaviors below.

213
00:08:55,627 --> 00:08:56,948
And if we look at a further frame,

214
00:08:56,988 --> 00:08:58,568
where this AI is actually in combat,

215
00:08:59,008 --> 00:09:00,469
we'll see once again, they're only checking

216
00:09:00,509 --> 00:09:02,530
their update subtree and the dynamic selector,

217
00:09:02,710 --> 00:09:04,350
but at this point, the dynamic selector

218
00:09:04,470 --> 00:09:07,031
only needs to advance as far as the combat subtree.

219
00:09:07,592 --> 00:09:10,112
Because the character is actively in combat,

220
00:09:10,233 --> 00:09:11,873
this combat subtree returns working,

221
00:09:12,193 --> 00:09:13,934
and so the search and relax subtrees

222
00:09:14,014 --> 00:09:15,134
don't need to be checked at all.

223
00:09:15,494 --> 00:09:15,995
At this point.

224
00:09:16,295 --> 00:09:17,855
those trees are completely irrelevant

225
00:09:17,935 --> 00:09:20,516
because this AI is occupied in a higher priority behavior.

226
00:09:20,956 --> 00:09:22,956
So you can see in this way, the dynamic selector

227
00:09:23,036 --> 00:09:25,997
kind of controls implicit conditions and transitions

228
00:09:26,037 --> 00:09:27,317
between these substates below.

229
00:09:29,738 --> 00:09:31,798
So, jumping back to our abstracted view,

230
00:09:32,458 --> 00:09:34,339
looking at what we have, how can we use this

231
00:09:34,599 --> 00:09:36,259
as AI designers to solve the problem

232
00:09:36,299 --> 00:09:37,159
we talked about earlier?

233
00:09:37,659 --> 00:09:38,980
How can we keep things systemic

234
00:09:39,220 --> 00:09:40,700
while still allowing content designers

235
00:09:40,760 --> 00:09:42,180
to create their own custom content?

236
00:09:43,697 --> 00:09:45,417
Well, the very first thing we tried

237
00:09:45,498 --> 00:09:47,559
were these built-in on-spawn behaviors.

238
00:09:48,279 --> 00:09:50,800
Basically, maybe you could give a character a point,

239
00:09:50,940 --> 00:09:51,981
and if you gave them this point,

240
00:09:52,041 --> 00:09:53,902
they would know they wanted to move there on-spawn.

241
00:09:53,942 --> 00:09:55,763
So you give them a point, they run there on-spawn.

242
00:09:55,923 --> 00:09:57,403
You give them a path, a spline,

243
00:09:57,724 --> 00:09:59,244
they move along this path on-spawn.

244
00:09:59,805 --> 00:10:02,066
But as soon as we baked in those options,

245
00:10:02,606 --> 00:10:04,747
content designers just started asking for more, right?

246
00:10:04,807 --> 00:10:06,888
We immediately were faced with argument creep.

247
00:10:07,408 --> 00:10:09,690
If it's a helicopter, do we want them to land at the point

248
00:10:09,770 --> 00:10:10,530
or hover above it?

249
00:10:11,330 --> 00:10:13,011
At what speed should they move along the path?

250
00:10:13,231 --> 00:10:15,172
Do I want them to stop at the point or move through it?

251
00:10:15,552 --> 00:10:17,892
It's hard to really build in any of these custom

252
00:10:18,353 --> 00:10:20,813
on-spawn behaviors with only one or two simple arguments.

253
00:10:22,674 --> 00:10:24,995
In fact, this really didn't scale well at all.

254
00:10:25,535 --> 00:10:27,495
Pictured here is just an in-development look

255
00:10:27,655 --> 00:10:30,876
at a portion of a subtree for a drive-to-point style

256
00:10:30,936 --> 00:10:32,877
microbehavior, as well as a screenshot

257
00:10:32,897 --> 00:10:35,078
for all the exposed arguments, different parameters

258
00:10:35,098 --> 00:10:36,998
a content designer might want to set up

259
00:10:37,038 --> 00:10:39,179
for how a character could go about driving to a point.

260
00:10:39,659 --> 00:10:42,421
We've got should drive around traffic in there,

261
00:10:42,461 --> 00:10:45,003
should I reverse to the point, should I wait at the point,

262
00:10:45,243 --> 00:10:46,644
how fast do I drive to the point?

263
00:10:47,285 --> 00:10:48,946
There's like literally 50 parameters

264
00:10:48,986 --> 00:10:50,127
about driving to a point in there.

265
00:10:50,207 --> 00:10:52,109
And so obviously I couldn't bake this

266
00:10:52,169 --> 00:10:55,051
into the main behavior tree because 99% of the time,

267
00:10:55,091 --> 00:10:57,593
of course, our characters are not driving to a point on spawn

268
00:10:58,033 --> 00:11:00,155
and content designers cannot just sort through all this.

269
00:11:02,425 --> 00:11:05,050
So obviously, the natural intuition was that

270
00:11:05,170 --> 00:11:07,355
any sort of these micro on-spawn behaviors,

271
00:11:07,715 --> 00:11:09,739
they need to be split out of the main behavior tree

272
00:11:10,180 --> 00:11:12,064
and made into these modular pieces somehow,

273
00:11:12,164 --> 00:11:14,048
pieces that could be nicely compartmentalized.

274
00:11:16,847 --> 00:11:19,448
This led us to the concept of external behavior trees.

275
00:11:20,228 --> 00:11:21,448
And this concept is twofold.

276
00:11:22,049 --> 00:11:24,430
Firstly, content designers who are working

277
00:11:24,450 --> 00:11:26,691
in the level editor could add a new type of object

278
00:11:26,831 --> 00:11:28,431
called an external tree object.

279
00:11:28,691 --> 00:11:30,872
And this object simply holds another

280
00:11:31,012 --> 00:11:32,513
self-contained behavior tree.

281
00:11:33,033 --> 00:11:35,194
So whereas this character rule object you see here

282
00:11:35,654 --> 00:11:38,355
spawns a character and provides it its default behavior tree,

283
00:11:38,755 --> 00:11:40,996
this external tree object doesn't do anything.

284
00:11:41,076 --> 00:11:42,957
It just holds another external behavior tree.

285
00:11:44,228 --> 00:11:46,791
But the content designer can specify, OK,

286
00:11:46,871 --> 00:11:48,892
which behavior tree is this external tree object

287
00:11:48,912 --> 00:11:49,373
going to hold?

288
00:11:49,893 --> 00:11:52,115
Let's say, for example, the content designer selected

289
00:11:52,335 --> 00:11:55,098
a take cover in area micro behavior to live on this tree.

290
00:11:55,798 --> 00:11:58,461
Well, now as the AI designer, I can set up the main behavior

291
00:11:58,501 --> 00:12:01,303
tree to expect one of these external tree objects

292
00:12:01,423 --> 00:12:03,125
as one of the arguments to be fed into it.

293
00:12:03,725 --> 00:12:06,527
So now the content designer can pass in this external tree

294
00:12:06,828 --> 00:12:09,030
as a parameter to the main character's behavior tree.

295
00:12:10,876 --> 00:12:13,578
And then this external tree could basically be run

296
00:12:13,718 --> 00:12:15,379
inside that main behavior tree

297
00:12:15,519 --> 00:12:17,340
as if it was another subtree within it.

298
00:12:17,800 --> 00:12:19,341
So this enabled content designers

299
00:12:19,701 --> 00:12:23,123
to basically feed in modular, smaller microbehavior trees

300
00:12:23,463 --> 00:12:25,624
as arguments into the main big behavior tree.

301
00:12:26,245 --> 00:12:28,326
So now we could have things like drive to point

302
00:12:28,626 --> 00:12:31,688
or take cover an area as compartmentalized objects

303
00:12:31,728 --> 00:12:32,648
that would live on their own

304
00:12:32,928 --> 00:12:35,229
and then be fed into the main character's behavior tree.

305
00:12:35,730 --> 00:12:37,651
And let me show you exactly what that looked like.

306
00:12:41,202 --> 00:12:43,423
So here, a content designer has added an external

307
00:12:43,824 --> 00:12:45,185
behavior tree object to their scene,

308
00:12:45,945 --> 00:12:47,387
and the first thing they have to do

309
00:12:47,507 --> 00:12:48,888
with an external behavior tree object

310
00:12:48,948 --> 00:12:50,869
is pick what behavior tree it's gonna use.

311
00:12:51,450 --> 00:12:53,612
So down here, they've selected a helicopter

312
00:12:53,672 --> 00:12:55,153
fly-to-point microbehavior.

313
00:12:55,773 --> 00:12:57,435
As soon as they select the helicopter

314
00:12:57,475 --> 00:12:59,757
fly-to-point microbehavior, that's when this

315
00:12:59,857 --> 00:13:03,320
bt args, behavior tree arguments, section fills out.

316
00:13:03,780 --> 00:13:06,042
And so all these parameters are just about

317
00:13:06,202 --> 00:13:07,903
how a helicopter should fly to the point.

318
00:13:08,304 --> 00:13:10,966
So this content designer has fed in the point

319
00:13:11,026 --> 00:13:12,287
they want the helicopter to fly to,

320
00:13:12,687 --> 00:13:13,868
they've checked a box indicating

321
00:13:13,888 --> 00:13:15,529
they want the helicopter to land at the point,

322
00:13:15,710 --> 00:13:16,610
and they filled out the speed

323
00:13:16,630 --> 00:13:18,091
they want the helicopter to fly there at.

324
00:13:19,252 --> 00:13:21,454
Then they take that external behavior tree object

325
00:13:21,534 --> 00:13:22,575
and feed it into the thing

326
00:13:22,595 --> 00:13:24,457
that actually spawns the helicopter pilot,

327
00:13:24,797 --> 00:13:26,198
and the helicopter pilot can now run

328
00:13:26,238 --> 00:13:28,039
that helicopter fly to point behavior

329
00:13:28,340 --> 00:13:29,881
with all those parameters baked into it.

330
00:13:30,742 --> 00:13:31,602
And we didn't have to add

331
00:13:31,642 --> 00:13:33,544
all those helicopter fly to point arguments

332
00:13:33,964 --> 00:13:35,285
to the main behavior tree arguments.

333
00:13:37,645 --> 00:13:40,008
So now we have the concept of these external tree objects,

334
00:13:40,208 --> 00:13:42,310
allowing us to create these modular micro behaviors

335
00:13:42,530 --> 00:13:43,851
and feed them into the main tree.

336
00:13:44,661 --> 00:13:47,742
So while they're provided into the tree view via the main behavior tree arguments,

337
00:13:48,142 --> 00:13:52,263
the main tree itself still has to choose where and how to run these passed in subtrees.

338
00:13:52,843 --> 00:13:55,784
Of course, just doing things on spawn, which is what we've talked about so far,

339
00:13:56,204 --> 00:13:57,484
is the most obvious use case,

340
00:13:57,884 --> 00:14:00,745
but this isn't enough for content designers to do everything they want.

341
00:14:01,245 --> 00:14:03,706
Sometimes you want an agent to be purely systemic on spawn,

342
00:14:04,026 --> 00:14:07,727
but then use an external microbehavior at some future time under uncertain conditions.

343
00:14:08,545 --> 00:14:10,046
If these different places or conditions

344
00:14:10,086 --> 00:14:12,487
for triggering microbehaviors got too numerous though,

345
00:14:12,927 --> 00:14:14,747
we'd once again end up with a mess of arguments

346
00:14:14,867 --> 00:14:16,108
and an unintuitive interface.

347
00:14:17,989 --> 00:14:19,989
Ultimately, we realized we could do well

348
00:14:20,109 --> 00:14:22,190
with just three different points of ejection,

349
00:14:22,290 --> 00:14:22,850
as I called them.

350
00:14:23,590 --> 00:14:25,711
These external behaviors into the main tree

351
00:14:25,731 --> 00:14:27,492
could only be fed in at these three points.

352
00:14:27,692 --> 00:14:30,093
But with just these three insertion points,

353
00:14:30,373 --> 00:14:31,393
we found we could achieve

354
00:14:31,493 --> 00:14:33,654
almost every desired custom behavior in the game,

355
00:14:34,034 --> 00:14:36,055
and we did it by only adding a very small amount

356
00:14:36,155 --> 00:14:38,195
of arguments to the main behavior tree.

357
00:14:39,560 --> 00:14:42,041
Here's a look at kind of where those three different

358
00:14:42,101 --> 00:14:44,622
insertion points actually fed into the main behavior tree.

359
00:14:45,482 --> 00:14:46,803
So you can see we had the intro behavior,

360
00:14:47,123 --> 00:14:48,824
an interrupt behavior, and an idle behavior.

361
00:14:50,604 --> 00:14:52,445
And here is kind of how the content designer

362
00:14:52,465 --> 00:14:53,305
saw those arguments.

363
00:14:53,766 --> 00:14:55,886
They had options for the idle behavior,

364
00:14:55,986 --> 00:14:57,367
interrupt behavior, and intro behavior,

365
00:14:57,407 --> 00:14:59,188
and an object they could pass in for each of those.

366
00:15:01,912 --> 00:15:04,714
Now, I think it's worth taking the time to understand

367
00:15:04,835 --> 00:15:06,556
why these points of injection were chosen

368
00:15:06,656 --> 00:15:07,717
and what they're actually good for,

369
00:15:07,798 --> 00:15:09,920
and then why we didn't add any ones beyond these.

370
00:15:10,160 --> 00:15:10,841
So let's take a look.

371
00:15:12,803 --> 00:15:15,205
Intro behaviors were the first and most classic use case.

372
00:15:15,365 --> 00:15:18,548
Of course, on spawn do X, very simple.

373
00:15:18,989 --> 00:15:21,591
Here I spawn a rebel and I give him an intro behavior

374
00:15:21,631 --> 00:15:23,413
to just run to the right side of the screen.

375
00:15:24,154 --> 00:15:26,016
Doesn't need much further explanation than that.

376
00:15:27,575 --> 00:15:30,556
Now, there is still a few things to note about this implementation.

377
00:15:31,117 --> 00:15:34,398
Note that the runExternalTree node for intro behavior still takes place

378
00:15:34,658 --> 00:15:37,499
after the init and update subtrees have had their chance to run.

379
00:15:38,099 --> 00:15:41,160
This is because the init and update subtrees handle a lot of complex,

380
00:15:41,200 --> 00:15:44,961
important tasks like target selection, and it's good for the microbehaviors

381
00:15:44,981 --> 00:15:48,102
that might be run in the intro behavior to be able to rely on the fact

382
00:15:48,162 --> 00:15:50,663
that the main behavior tree has already taken care of these things.

383
00:15:51,224 --> 00:15:55,366
If it weren't for that, we'd have to reinitialize a bunch of stuff in all the microbehaviors themselves.

384
00:15:55,426 --> 00:15:59,207
And of course, we want to keep these microbehaviors as lean and modular as possible,

385
00:15:59,608 --> 00:16:04,750
so we run them after that main AI has had the chance to update a bunch of internal facts about the world and themselves.

386
00:16:05,991 --> 00:16:09,392
Also note that the intro behavior is under this green circle, which is a selector.

387
00:16:10,153 --> 00:16:15,656
For now, you can just know that all this does is ensure that the intro behavior only gets attempted to run once on spawn,

388
00:16:15,776 --> 00:16:17,656
and then it never needs to get checked again after that.

389
00:16:20,698 --> 00:16:22,638
Now there was one extra parameter that came

390
00:16:22,678 --> 00:16:24,919
with intro behaviors, which is a bool or flag

391
00:16:25,039 --> 00:16:27,279
I simply called always finish intro behavior,

392
00:16:27,619 --> 00:16:29,119
and this turned out to be incredibly useful.

393
00:16:29,659 --> 00:16:31,800
Basically, each agent in their update

394
00:16:32,060 --> 00:16:33,760
has the ability to kick themselves out

395
00:16:33,880 --> 00:16:36,821
of their own intro behavior based on various heuristics

396
00:16:36,861 --> 00:16:38,541
that are running in parallel to determine

397
00:16:38,561 --> 00:16:40,501
if something more important has presented itself.

398
00:16:41,222 --> 00:16:43,762
If you set this always finish intro behavior flag to true,

399
00:16:43,962 --> 00:16:45,742
then it basically turns those heuristics off.

400
00:16:47,683 --> 00:16:48,323
So for example.

401
00:16:49,622 --> 00:16:51,482
A world designer places an enemy helicopter

402
00:16:51,563 --> 00:16:54,004
on the other side of a mountain for some sort of epic entrance.

403
00:16:54,564 --> 00:16:56,925
She gives the helicopter pilot a special intro behavior

404
00:16:57,005 --> 00:16:59,166
to fly a specific path around the mountain that she

405
00:16:59,206 --> 00:17:00,187
thinks will look really cool.

406
00:17:00,727 --> 00:17:02,868
Now, our player has a grappling hook and a wingsuit.

407
00:17:02,948 --> 00:17:04,689
So let's just say they get to the top of the mountain

408
00:17:04,889 --> 00:17:06,550
one second after the helicopter spawns.

409
00:17:07,290 --> 00:17:09,691
And now that epic path that she outlined

410
00:17:09,771 --> 00:17:11,572
doesn't look that smart anymore because it

411
00:17:11,632 --> 00:17:13,973
takes the helicopter right past where the player is already

412
00:17:14,013 --> 00:17:14,373
standing.

413
00:17:15,173 --> 00:17:17,775
Well, with the always finish intro behavior flag unchecked,

414
00:17:18,095 --> 00:17:19,756
the enemy pilot's heuristics will detect,

415
00:17:19,936 --> 00:17:21,736
hey, I know I'm supposed to fly this path,

416
00:17:22,217 --> 00:17:23,857
but my target is right here in front of me,

417
00:17:23,917 --> 00:17:25,458
so forget the path, I'm just gonna fight

418
00:17:25,478 --> 00:17:26,318
the target where I am.

419
00:17:27,039 --> 00:17:29,480
Whereas if you check the box, if you don't check the box,

420
00:17:29,860 --> 00:17:32,321
then the AI will, yeah, if you don't check the box,

421
00:17:32,341 --> 00:17:34,502
they'll automatically exit, or if you do check the box,

422
00:17:34,522 --> 00:17:36,883
they'll be enforced to finish the whole path no matter what.

423
00:17:37,651 --> 00:17:40,133
Now you might think it's always smarter to not check the box,

424
00:17:40,213 --> 00:17:42,976
let the AI systemically exit if they think something more important has

425
00:17:43,016 --> 00:17:43,336
happened.

426
00:17:43,676 --> 00:17:46,459
But if you're creating a mission where this is an escape helicopter that's

427
00:17:46,479 --> 00:17:49,781
trying to escape with stolen data or pick up a critically wounded ally,

428
00:17:50,102 --> 00:17:51,963
then it would make perfect sense to check this box

429
00:17:52,003 --> 00:17:54,866
and make sure that this AI prioritizes completing its path.

430
00:17:56,764 --> 00:17:58,485
The next up injection point I want to talk about

431
00:17:58,665 --> 00:18:00,406
is the interrupt behavior, which also came

432
00:18:00,446 --> 00:18:01,346
with a trigger event.

433
00:18:01,946 --> 00:18:03,907
An interrupt behavior is sort of like an intro behavior,

434
00:18:04,007 --> 00:18:06,528
except the AI doesn't attempt to run it on spawn,

435
00:18:06,908 --> 00:18:08,149
but rather listens for an event

436
00:18:08,189 --> 00:18:09,670
in their update tree every frame.

437
00:18:09,930 --> 00:18:11,210
And if this event is received,

438
00:18:11,611 --> 00:18:13,131
that's when the AI will automatically make

439
00:18:13,211 --> 00:18:15,292
this interrupt behavior their topmost priority.

440
00:18:17,045 --> 00:18:19,345
So here we have a rebel that's fighting an enemy soldier,

441
00:18:19,865 --> 00:18:21,666
and about a second or two into the fighting,

442
00:18:21,806 --> 00:18:23,646
I send an event under the hood to the rebel,

443
00:18:23,926 --> 00:18:25,387
telling them, stop what you're doing,

444
00:18:25,767 --> 00:18:27,587
get up and run to the square on the right side

445
00:18:27,607 --> 00:18:29,348
of the screen for whatever reason.

446
00:18:30,068 --> 00:18:33,249
Obviously, this is a too micro and suboptimal use case

447
00:18:33,269 --> 00:18:35,309
for interrupt behaviors, but it showcases what I mean,

448
00:18:35,369 --> 00:18:37,210
that they can take over the AI at any point.

449
00:18:38,560 --> 00:18:40,061
What's great about interrupt behaviors

450
00:18:40,421 --> 00:18:41,822
is that content designers define

451
00:18:41,842 --> 00:18:42,983
the trigger event themselves,

452
00:18:43,143 --> 00:18:45,424
and so it enables them to do it on a case-by-case basis,

453
00:18:45,524 --> 00:18:47,045
and they can be fully responsible for it.

454
00:18:47,756 --> 00:18:52,097
meaning if a content designer has a timer that they want to wait 30 seconds before triggering an event,

455
00:18:52,157 --> 00:18:54,458
or they have a counter that's counting a certain amount of things,

456
00:18:54,858 --> 00:18:58,999
anything the content designer has that can send events, they can use to trigger and interrupt behavior.

457
00:18:59,719 --> 00:19:04,180
As you'll see later, this slot turns out to be particularly useful for communicating with the mission objective system.

458
00:19:04,660 --> 00:19:08,781
And of course, when the interrupt behavior is done, or if it's invalid, or it can't run,

459
00:19:09,282 --> 00:19:13,643
the AI resumes its main dynamic selector and is as functional as any other character in the game.

460
00:19:15,762 --> 00:19:17,104
Lastly is the idle behavior.

461
00:19:17,564 --> 00:19:20,267
If provided, this simply just runs with a higher priority

462
00:19:20,347 --> 00:19:22,289
than the systemic normal relaxed behavior.

463
00:19:22,850 --> 00:19:24,431
So a normal systemic relaxed behavior

464
00:19:24,491 --> 00:19:26,433
might have a character roaming some sidewalks

465
00:19:26,473 --> 00:19:28,676
or just hanging out, but you can offer them

466
00:19:28,696 --> 00:19:30,157
a specific idle behavior using this.

467
00:19:30,738 --> 00:19:33,199
So here I have a rebel that's fighting an enemy soldier.

468
00:19:33,519 --> 00:19:34,919
When they're done fighting the soldier,

469
00:19:35,179 --> 00:19:36,860
instead of doing their normal relaxed behavior,

470
00:19:36,980 --> 00:19:39,360
I tell them to walk over to this arrow

471
00:19:39,480 --> 00:19:41,481
on the right side of the screen and stand guard there.

472
00:19:41,981 --> 00:19:44,342
So I've just authored a manual idle behavior

473
00:19:44,442 --> 00:19:45,262
for this rebel to do,

474
00:19:45,502 --> 00:19:47,763
instead of their normal default systemic relaxed behavior,

475
00:19:48,083 --> 00:19:50,123
which would probably have them wander off screen somewhere.

476
00:19:52,186 --> 00:19:53,607
As you might expect, idle behaviors

477
00:19:53,647 --> 00:19:55,628
are great for staging patrolling characters

478
00:19:55,688 --> 00:19:57,429
around a military base or around a town.

479
00:19:58,070 --> 00:20:00,031
And you might ask, why is the idle behavior

480
00:20:00,511 --> 00:20:03,293
before the relaxed behavior and not somehow overriding it?

481
00:20:04,093 --> 00:20:05,735
Well, this is kind of an important theme.

482
00:20:06,435 --> 00:20:08,596
Imagine you have an enemy that's patrolling

483
00:20:08,616 --> 00:20:10,257
a military base in a Jeep, and they

484
00:20:10,277 --> 00:20:12,359
have a special idle behavior to drive a patrolling

485
00:20:12,379 --> 00:20:13,780
Jeep around a military base.

486
00:20:13,980 --> 00:20:15,381
That's their external idle behavior.

487
00:20:15,621 --> 00:20:16,501
Now the player comes in.

488
00:20:17,046 --> 00:20:19,307
They hijack the jeep, they throw the character out,

489
00:20:19,947 --> 00:20:22,367
the player drives the jeep away and then destroys the jeep.

490
00:20:22,788 --> 00:20:25,128
Okay, this character is gonna go into combat for a while,

491
00:20:25,168 --> 00:20:26,849
trying to shoot at the player while they drive away,

492
00:20:27,209 --> 00:20:28,349
then they're gonna go into search,

493
00:20:28,649 --> 00:20:30,009
but after a while they're gonna go back

494
00:20:30,029 --> 00:20:32,010
to their external idle behavior and they'll say,

495
00:20:32,150 --> 00:20:34,291
okay, time to drive my jeep around the base again.

496
00:20:34,811 --> 00:20:36,311
Of course, their jeep no longer exists

497
00:20:36,531 --> 00:20:37,452
because the player blew it up.

498
00:20:38,012 --> 00:20:40,512
but because we didn't override the default relax behavior,

499
00:20:40,752 --> 00:20:42,313
this character can now simply fall back

500
00:20:42,373 --> 00:20:43,633
to that normal relax behavior

501
00:20:43,813 --> 00:20:45,634
and be as functional as any other AI,

502
00:20:45,954 --> 00:20:48,234
so they'll probably just find a good systemic spot

503
00:20:48,274 --> 00:20:49,455
to stand guard near the base

504
00:20:49,555 --> 00:20:50,775
and they'll look perfectly fine there.

505
00:20:55,056 --> 00:20:56,617
So why didn't we just provide options

506
00:20:56,657 --> 00:20:58,297
to run these micro behaviors everywhere?

507
00:20:58,377 --> 00:20:59,918
If inserting things is so safe

508
00:20:59,978 --> 00:21:01,378
and the behavior tree is so robust,

509
00:21:01,938 --> 00:21:03,819
why didn't I just provide all the options

510
00:21:03,839 --> 00:21:04,679
to the content designers?

511
00:21:05,393 --> 00:21:08,775
Well, this is in order to preserve the integrity and the consistency of the AI.

512
00:21:09,416 --> 00:21:12,478
The decision of whether to enter combat or search, for example,

513
00:21:12,618 --> 00:21:14,600
is very involved and meticulously crafted.

514
00:21:15,180 --> 00:21:18,102
It's very important to keep transitions between combat and search

515
00:21:18,643 --> 00:21:21,025
consistent and clear so the player can learn them

516
00:21:21,165 --> 00:21:22,726
and begin to anticipate and predict them.

517
00:21:23,513 --> 00:21:25,734
Furthermore, it's important that the content designer

518
00:21:25,834 --> 00:21:28,715
can't accidentally override places where the AI

519
00:21:28,775 --> 00:21:31,656
is about to play a special animation or a key reaction,

520
00:21:31,797 --> 00:21:33,417
because if they could, they would accidentally

521
00:21:33,457 --> 00:21:35,898
compromise the visual integrity of the AI as well.

522
00:21:37,839 --> 00:21:40,700
In many ways, this is the same reason why we don't expose

523
00:21:40,780 --> 00:21:43,661
that much tuning data as behavior tree arguments either.

524
00:21:43,941 --> 00:21:46,282
This is all, all the tuning data is mostly decided

525
00:21:46,382 --> 00:21:47,862
internally by the AI designers.

526
00:21:48,503 --> 00:21:50,223
Instead, we only expose the few things

527
00:21:50,263 --> 00:21:51,364
you see on the right there.

528
00:21:52,264 --> 00:21:57,227
For example, one thing that content designers often requested was an overridden range they could give an enemy.

529
00:21:57,387 --> 00:22:01,930
So let's say they wanted to put a sniper rifle using enemy on the top of this one tower

530
00:22:02,270 --> 00:22:07,794
because the mission takes the player right by this tower and it's going to be awesome if an enemy can use a sniper to shoot at them from the tower.

531
00:22:08,234 --> 00:22:12,917
But a sniper's default range is 120 meters and this tower is 140 meters high.

532
00:22:13,277 --> 00:22:16,720
Can't I just give them an ability to override it just this once?

533
00:22:17,900 --> 00:22:21,422
Sadly, I can't because I want every sniper enemy in the game

534
00:22:21,522 --> 00:22:23,983
to be perfectly consistent and have the same range

535
00:22:24,183 --> 00:22:26,004
so once again the player can learn this range

536
00:22:26,204 --> 00:22:27,885
and learn to anticipate it and play around it.

537
00:22:29,826 --> 00:22:31,647
So yeah, we designed these points of injection

538
00:22:32,007 --> 00:22:34,468
to maximize simplicity, flexible control,

539
00:22:34,768 --> 00:22:38,090
robustness, behavioral consistency, and visual integrity.

540
00:22:40,534 --> 00:22:42,675
Now part of the reason working with this micro behaviors

541
00:22:42,775 --> 00:22:44,636
were so easy and I could keep them so lean

542
00:22:44,816 --> 00:22:46,477
is because we used a header file system

543
00:22:46,537 --> 00:22:47,818
for our behavior trees as well.

544
00:22:48,458 --> 00:22:49,979
Just like you might have a helper function

545
00:22:50,139 --> 00:22:51,320
and header file and code,

546
00:22:51,660 --> 00:22:53,841
we had header files for our behavior trees as well

547
00:22:53,981 --> 00:22:56,363
that could hold very frequently used AI subtrees.

548
00:22:57,003 --> 00:22:59,165
So here we have a run and shoot subtree,

549
00:22:59,265 --> 00:23:00,926
which handles all the inner workings

550
00:23:00,966 --> 00:23:03,008
for how a character fights as they run to a point.

551
00:23:03,669 --> 00:23:04,790
And we put that in a header file.

552
00:23:05,370 --> 00:23:07,732
We include that header file in our main behavior tree

553
00:23:07,812 --> 00:23:10,014
so that during standard systemic combat,

554
00:23:10,695 --> 00:23:12,096
the character can use that function

555
00:23:12,676 --> 00:23:15,258
and run to a position determined by their utility function

556
00:23:15,298 --> 00:23:16,900
for a good place to stand in combat.

557
00:23:17,380 --> 00:23:18,801
We can also include that header file

558
00:23:18,881 --> 00:23:20,803
in our microbehavior for running to an area.

559
00:23:21,283 --> 00:23:23,025
A-O-O stands for area of operations.

560
00:23:23,585 --> 00:23:25,927
The only difference here, the same subtree gets used,

561
00:23:26,027 --> 00:23:29,050
but the destination is an area provided by the content designer

562
00:23:29,130 --> 00:23:30,971
instead of one internally figured out by the AI.

563
00:23:31,812 --> 00:23:34,174
Of course, the benefit of reusing these subtrees everywhere

564
00:23:34,574 --> 00:23:36,315
is that as I improve the subtree once,

565
00:23:36,636 --> 00:23:38,657
all the behavior trees using it get that same improvement.

566
00:23:40,795 --> 00:23:44,478
Now we have this general interface and I could focus on building this library of modular

567
00:23:44,518 --> 00:23:47,581
microbehaviors that felt the most useful or most often requested.

568
00:23:48,141 --> 00:23:51,444
Each of these microbehaviors could of course then have their own particular arguments which

569
00:23:51,464 --> 00:23:55,448
would be nicely compartmentalized and I could focus on making sure that these were dependable

570
00:23:55,508 --> 00:23:56,028
and reliable.

571
00:23:57,910 --> 00:24:01,133
But the system still kind of had a pretty big problem.

572
00:24:01,987 --> 00:24:03,989
What if a designer wanted to create a mission

573
00:24:04,089 --> 00:24:06,051
where Mario, the character in Just Cause 3,

574
00:24:06,091 --> 00:24:07,452
the ally character in the blue shirt,

575
00:24:07,792 --> 00:24:08,913
has to first take cover,

576
00:24:09,314 --> 00:24:11,015
then fight with the player for a while,

577
00:24:11,616 --> 00:24:13,738
then wait for the player to kind of open the gate

578
00:24:13,758 --> 00:24:14,499
so they can escape,

579
00:24:14,519 --> 00:24:17,141
and then get into the systemic vehicle that comes in,

580
00:24:17,482 --> 00:24:19,624
and then fight from within the vehicle once it comes in.

581
00:24:20,164 --> 00:24:22,707
Right, that's a pretty beefy micro-behavior,

582
00:24:23,047 --> 00:24:25,029
and this is, again, is not gonna emerge naturally

583
00:24:25,049 --> 00:24:26,150
from our behavior tree system.

584
00:24:27,031 --> 00:24:30,994
At first I had no choice but to create these giant mission-specific intro behaviors,

585
00:24:31,274 --> 00:24:33,976
and this would of course take a lot of my time to write and debug,

586
00:24:34,377 --> 00:24:36,538
and it turned me into a bottleneck for the mission designers

587
00:24:36,578 --> 00:24:38,560
when they wanted to change how things in their mission worked.

588
00:24:39,100 --> 00:24:41,022
Obviously, this was not a scalable solution.

589
00:24:41,582 --> 00:24:45,005
There needed to be a way for mission designers to craft their own sequences

590
00:24:45,065 --> 00:24:47,186
without ever needing to touch behavior tree script.

591
00:24:49,048 --> 00:24:52,310
Well, let's take a look at what the mission designer really needed to do here.

592
00:24:52,770 --> 00:24:55,673
They roughly want Mario to perform this sequence of behaviors.

593
00:24:57,185 --> 00:25:00,266
Well, if we abstract away all the mission-specific details,

594
00:25:00,646 --> 00:25:02,746
at a glance, we have an intuition that we can maybe

595
00:25:02,966 --> 00:25:04,647
puzzle this out with the micro behaviors

596
00:25:04,707 --> 00:25:05,727
and the system we have now.

597
00:25:07,227 --> 00:25:10,228
Maybe take cover an area can be Mario's intro behavior,

598
00:25:10,648 --> 00:25:12,749
then we kind of release him into systemic combat

599
00:25:12,769 --> 00:25:15,410
for a while, and then we trigger these other three

600
00:25:15,470 --> 00:25:17,970
sequence of micro behaviors as his interrupt behavior

601
00:25:18,010 --> 00:25:20,191
when it's time for Mario to wait for the gate to be opened.

602
00:25:22,480 --> 00:25:24,082
But wait a minute, I know what you're saying.

603
00:25:24,462 --> 00:25:26,964
Sequence of microbehaviors, how do we do that?

604
00:25:27,024 --> 00:25:29,166
We only have one slot for an interrupt behavior

605
00:25:29,366 --> 00:25:30,407
on our behavior tree arguments.

606
00:25:31,027 --> 00:25:34,230
Well, so we enter the meta utility tree.

607
00:25:35,051 --> 00:25:37,993
The meta utility tree is basically just an intermediary tree

608
00:25:38,253 --> 00:25:40,575
that can package a bunch of smaller microbehaviors

609
00:25:40,695 --> 00:25:43,197
into a single behavior tree that can then be fed

610
00:25:43,318 --> 00:25:45,039
into one of the main behavior tree's arguments.

611
00:25:45,439 --> 00:25:47,201
These could be as simple as a sequence

612
00:25:47,221 --> 00:25:48,582
that just runs three other trees,

613
00:25:48,822 --> 00:25:50,363
one after the other, after the other.

614
00:25:52,423 --> 00:25:54,404
So this is what it looked like to the content designer.

615
00:25:54,664 --> 00:25:56,606
They had their character spawner for Mario,

616
00:25:57,026 --> 00:25:58,907
and Mario had two things passed into him,

617
00:25:59,487 --> 00:26:01,108
an interrupt behavior, which was a sequence

618
00:26:01,128 --> 00:26:03,090
of micro behaviors, and an intro behavior,

619
00:26:03,130 --> 00:26:05,171
which is just to take cover in area external tree.

620
00:26:06,172 --> 00:26:07,552
The sequence of behaviors itself

621
00:26:07,853 --> 00:26:09,253
had three external tree arguments,

622
00:26:09,554 --> 00:26:11,375
and those are where the three external tree objects

623
00:26:11,455 --> 00:26:12,075
are fed into that.

624
00:26:13,848 --> 00:26:16,491
Just quickly want to touch on these intermediary trees.

625
00:26:16,612 --> 00:26:17,473
You don't need a lot of them.

626
00:26:17,533 --> 00:26:18,434
We only needed three.

627
00:26:19,075 --> 00:26:21,538
One, which was just a sequence of trees, as we've talked about.

628
00:26:21,618 --> 00:26:23,341
So this was useful when you had a character that

629
00:26:23,361 --> 00:26:26,365
wanted to do something like enter a car, then drive to a point,

630
00:26:26,445 --> 00:26:27,306
then exit the car.

631
00:26:28,252 --> 00:26:30,614
A selector of behaviors is more like or statements.

632
00:26:30,994 --> 00:26:35,058
This is like try tree A, and only if that fails, try tree B.

633
00:26:35,539 --> 00:26:37,401
This is pretty useful in a just cause game

634
00:26:37,421 --> 00:26:39,002
where you might want to have a character say,

635
00:26:39,503 --> 00:26:41,905
try to drive this car to that point over there.

636
00:26:42,086 --> 00:26:44,168
But if for some reason that car gets destroyed

637
00:26:44,208 --> 00:26:45,689
as you're moving to it or you're driving it,

638
00:26:46,190 --> 00:26:47,911
then get out and run to the point instead.

639
00:26:49,252 --> 00:26:51,533
Lastly is an external behavior with autocomplete.

640
00:26:51,873 --> 00:26:53,174
We don't really need to dig into that one,

641
00:26:53,214 --> 00:26:55,455
but it basically, it enabled us to autocomplete

642
00:26:55,515 --> 00:26:57,376
or auto-abort out of a bigger sequence

643
00:26:57,436 --> 00:26:59,317
or selector of behaviors whenever we needed to

644
00:26:59,417 --> 00:27:00,397
with just a single event.

645
00:27:01,357 --> 00:27:05,039
Designers could stitch together or nest these meta-utility trees as much as they want.

646
00:27:05,239 --> 00:27:08,640
You could have a sequence of sequences of behaviors, you could have a selector of sequences

647
00:27:08,680 --> 00:27:09,661
with an autocomplete event.

648
00:27:09,941 --> 00:27:11,962
You can infinitely nest these as much as you want.

649
00:27:12,382 --> 00:27:14,083
Well, probably not infinitely, but pretty close.

650
00:27:15,563 --> 00:27:18,805
And the system was very intuitive and flexible enough for content designers to use.

651
00:27:18,985 --> 00:27:22,566
It scaled really well, and we had basically a working way now where content designers

652
00:27:22,606 --> 00:27:23,847
could sort of script their own AI.

653
00:27:26,191 --> 00:27:29,014
You'll notice that every layer at play here is a behavior tree.

654
00:27:29,355 --> 00:27:31,537
The micro behaviors, what they're organized into,

655
00:27:31,797 --> 00:27:33,379
and the main tree that they're inserted into.

656
00:27:33,900 --> 00:27:36,082
And this is actually beneficial for us for a few reasons.

657
00:27:36,603 --> 00:27:38,765
The first is that the AI designers can do all of this.

658
00:27:39,006 --> 00:27:41,548
We can quickly create different meta trees, micro behaviors,

659
00:27:41,628 --> 00:27:42,830
and work those into the main tree

660
00:27:43,110 --> 00:27:45,152
without requiring any AI programmer time.

661
00:27:46,019 --> 00:27:47,520
Since each layer is a behavior tree,

662
00:27:47,780 --> 00:27:49,742
they all fit together seamlessly in runtime,

663
00:27:49,822 --> 00:27:51,182
and that means that we can debug them

664
00:27:51,243 --> 00:27:53,204
with our behavior tree debugger, which is really good,

665
00:27:53,544 --> 00:27:55,265
meaning that I could sit down with the mission designer

666
00:27:55,325 --> 00:27:57,547
and debug any layer of this whenever I wanted to.

667
00:27:59,208 --> 00:28:02,010
Lastly, because these all use the same AI header files

668
00:28:02,030 --> 00:28:03,651
we talked about earlier, it was very easy

669
00:28:03,691 --> 00:28:05,852
to share subtrees and share behavior tree script

670
00:28:05,912 --> 00:28:06,853
across these different layers.

671
00:28:08,007 --> 00:28:11,149
And finally, to quote Damian Isla from his famous

672
00:28:11,229 --> 00:28:15,112
Halo 2 AI presentation, only by placing the stimulus

673
00:28:15,132 --> 00:28:17,554
behavior into the tree itself can we be assured

674
00:28:17,594 --> 00:28:19,955
that all the higher level and higher priority behaviors

675
00:28:20,295 --> 00:28:22,417
have had their say before the stimulus behavior

676
00:28:22,457 --> 00:28:23,638
can consider taking action.

677
00:28:24,158 --> 00:28:25,659
By having this all be a behavior tree,

678
00:28:25,759 --> 00:28:27,680
we were able to keep it very robust as well.

679
00:28:29,081 --> 00:28:31,503
And yeah, this three tree type interface,

680
00:28:32,063 --> 00:28:34,505
this of course is the titular trees company

681
00:28:34,665 --> 00:28:37,186
that I know you've all been waiting for, so there you go.

682
00:28:39,273 --> 00:28:42,077
But speaking of trees, we're not out of the woods yet.

683
00:28:42,677 --> 00:28:44,159
We still had a pretty big problem

684
00:28:44,860 --> 00:28:46,161
with the mission system interface.

685
00:28:47,262 --> 00:28:49,725
Picture the mission sequence from the Mario example earlier.

686
00:28:50,346 --> 00:28:52,067
Here's a mapping of the player objectives

687
00:28:52,188 --> 00:28:53,289
in the top row of the mission,

688
00:28:53,529 --> 00:28:55,111
and Mario's behaviors in the bottom row.

689
00:28:55,982 --> 00:28:58,183
Imagine that each one of these player objectives on the top

690
00:28:58,303 --> 00:28:59,783
is sort of a checkpoint for that mission.

691
00:28:59,963 --> 00:29:02,264
So if the player dies while opening the gate somehow,

692
00:29:02,645 --> 00:29:04,245
then they'll respawn at opening the gate.

693
00:29:04,285 --> 00:29:06,266
They won't have to do the defeat enemies checkpoint again.

694
00:29:07,027 --> 00:29:09,568
But what happens if the player fails during the escort objective?

695
00:29:09,928 --> 00:29:12,229
Mario's AI has been fed a sequence of behaviors

696
00:29:12,309 --> 00:29:14,290
and will want to restart this sequence from the start.

697
00:29:15,370 --> 00:29:18,092
But the mission will have checkpointed to the point where the gate is already opened,

698
00:29:18,312 --> 00:29:20,793
and so now our AI and our mission system would be out of sync.

699
00:29:21,822 --> 00:29:27,168
Initially, mission designers started to make alternate copies of spawners with different behaviors cut off and

700
00:29:27,489 --> 00:29:33,336
to accommodate every possible mission checkpoint, but this was of course very unwieldy for mission designers to handle,

701
00:29:33,376 --> 00:29:35,419
especially as they iterated on their checkpoint system.

702
00:29:36,952 --> 00:29:39,814
The solution, of course, was to assign trees

703
00:29:40,154 --> 00:29:42,055
to the mission objectives themselves,

704
00:29:42,235 --> 00:29:44,116
not to the AI directly in these cases.

705
00:29:44,636 --> 00:29:46,397
So for example, we would assign,

706
00:29:47,117 --> 00:29:48,738
each mission objective object

707
00:29:48,918 --> 00:29:51,099
had what we called a character controller object

708
00:29:51,139 --> 00:29:52,280
for all of the key characters.

709
00:29:52,680 --> 00:29:54,481
So each mission objective in this mission

710
00:29:54,801 --> 00:29:56,342
has a Mario character controller.

711
00:29:56,822 --> 00:29:59,504
we could feed the behavior tree that we wanted Mario to run

712
00:29:59,544 --> 00:30:01,966
during that objective to that objective's character

713
00:30:02,006 --> 00:30:04,748
controller, and that would automatically be passed to Mario

714
00:30:04,869 --> 00:30:05,769
as the mission progressed.

715
00:30:06,370 --> 00:30:08,231
So if at objective three, we know

716
00:30:08,251 --> 00:30:11,053
we want Mario to run a sequence where he animates at the gate

717
00:30:11,233 --> 00:30:13,835
and then enters the car, we can pass that sequence just

718
00:30:13,875 --> 00:30:14,756
into objective three.

719
00:30:15,237 --> 00:30:17,358
And whether you're respawning, restarting the mission

720
00:30:17,438 --> 00:30:19,660
from objective three, or you're starting it from objective one,

721
00:30:20,140 --> 00:30:22,262
Mario will get this behavior tree right on time,

722
00:30:22,302 --> 00:30:23,203
and it'll work perfectly.

723
00:30:23,763 --> 00:30:28,310
So by assigning the AI on a per character per mission objective level,

724
00:30:28,750 --> 00:30:31,194
rather than on the per character for the whole mission level,

725
00:30:31,454 --> 00:30:34,538
we successfully synced the system with our mission system.

726
00:30:36,314 --> 00:30:40,237
Now, all this functionality also benefited a lot of systems

727
00:30:40,338 --> 00:30:41,719
beyond the mission system as well.

728
00:30:42,379 --> 00:30:44,321
In this random encounter, you can see that the AI

729
00:30:44,341 --> 00:30:46,963
were staged into custom intro behaviors and animations,

730
00:30:47,283 --> 00:30:49,085
setting up a firing squad type scenario.

731
00:30:49,525 --> 00:30:51,247
But once disturbed, they all break out

732
00:30:51,287 --> 00:30:53,068
into their emergent systemic behavior,

733
00:30:53,128 --> 00:30:55,190
and the results are all the sort of emergent chaos

734
00:30:55,510 --> 00:30:56,071
you'd expect.

735
00:30:56,411 --> 00:30:58,493
The rebels start investigating some enemy corpses,

736
00:30:58,613 --> 00:31:01,295
other enemies happen to drive by, and a fight ensues.

737
00:31:02,696 --> 00:31:05,185
And because we were able to have this sort of intro behavior

738
00:31:05,205 --> 00:31:07,172
that can release into normal systemic AI,

739
00:31:07,653 --> 00:31:09,520
there was no stress that any of this was gonna work fine.

740
00:31:11,942 --> 00:31:14,344
The design also allowed world and location designers

741
00:31:14,424 --> 00:31:15,886
to set up custom patrol paths.

742
00:31:16,486 --> 00:31:18,708
Here we see custom idle behaviors at work

743
00:31:18,829 --> 00:31:20,010
with some patrolling enemies.

744
00:31:20,410 --> 00:31:21,692
Rico and a rebel drive up,

745
00:31:21,872 --> 00:31:23,714
they disturb the enemies out of their patrol,

746
00:31:23,854 --> 00:31:25,956
they go into combat, Rico runs away,

747
00:31:26,396 --> 00:31:28,458
eventually those enemies go back to being relaxed

748
00:31:28,659 --> 00:31:31,081
and the enemies who are lucky enough to still be alive,

749
00:31:31,461 --> 00:31:33,223
they resume their patrol as intended.

750
00:31:35,056 --> 00:31:38,802
Now is the time in the presentation where I want to take a step away from talking about

751
00:31:38,842 --> 00:31:39,423
behavior trees.

752
00:31:40,124 --> 00:31:44,091
There were other ways that we went about creating systemic AI in our game and other ways where

753
00:31:44,111 --> 00:31:47,637
we needed to kind of control that AI, but we used methods that had nothing to do with

754
00:31:47,677 --> 00:31:48,178
behavior trees.

755
00:31:50,116 --> 00:31:53,960
The first thing I want to talk about is that often you need to get a character on foot

756
00:31:54,100 --> 00:31:58,625
in combat from point A to point B. But points and splines are fragile stuff that I want

757
00:31:58,645 --> 00:31:59,245
to get away from.

758
00:31:59,806 --> 00:32:03,730
Stuff in a Just Cause game moves around a lot, a lot of things get in the way, paths

759
00:32:03,790 --> 00:32:05,892
that initially seemed smart start to look dumb.

760
00:32:06,493 --> 00:32:09,876
I mean, it's Just Cause, the player can basically debug, spawn, attack, whatever they want.

761
00:32:10,744 --> 00:32:15,852
So the better solution is to utilize our pre-existing concept of areas of operations, or AOOs.

762
00:32:16,353 --> 00:32:20,079
An area essentially crops the positions that a character wants to consider moving to,

763
00:32:20,479 --> 00:32:22,863
and so it confines the space where they'll next reposition.

764
00:32:23,835 --> 00:32:26,138
Here you can kind of see some of that repositioning in action.

765
00:32:26,598 --> 00:32:29,401
This is a mission where the player is fighting along with two friendly AI,

766
00:32:29,622 --> 00:32:33,546
Annika and Tio, and throughout the mission we kind of advance through this warehouse together.

767
00:32:34,026 --> 00:32:37,930
Now, rather than me telling Annika and Tio exactly where to move or how to move,

768
00:32:38,050 --> 00:32:40,954
I simply update their area of operations in the back of their head.

769
00:32:41,760 --> 00:32:47,485
The area of operations guides them to where they want to consider repositioning to the next time they want to reposition.

770
00:32:48,086 --> 00:32:53,511
And Annika and Teo make all the decisions about exactly how to fight, where to stand, where to take cover themselves,

771
00:32:53,872 --> 00:32:56,755
just within this bounded area that the content designer can provide them.

772
00:32:58,416 --> 00:33:01,599
So here, it was Annika's decision to run up to that cover and take cover there.

773
00:33:02,520 --> 00:33:04,422
All they have to do is just stay in this general area.

774
00:33:06,425 --> 00:33:07,786
Here's kind of a debug screenshot

775
00:33:07,826 --> 00:33:09,346
of how an area of operations works.

776
00:33:10,107 --> 00:33:11,768
It basically crops the utility map

777
00:33:11,788 --> 00:33:12,889
that they use for positioning.

778
00:33:13,449 --> 00:33:14,810
We normally wouldn't make one this small.

779
00:33:15,030 --> 00:33:16,911
In general, again, you want to have these areas

780
00:33:16,951 --> 00:33:19,293
be as big as possible because you never know

781
00:33:19,333 --> 00:33:21,034
what could be happening, and the bigger you make it,

782
00:33:21,054 --> 00:33:22,394
the more flexible and robust it is,

783
00:33:22,515 --> 00:33:24,696
but of course, the content needs will dictate the size.

784
00:33:25,877 --> 00:33:27,458
And remember, a normal utility map,

785
00:33:27,518 --> 00:33:28,978
as we saw earlier, is pretty huge.

786
00:33:29,219 --> 00:33:31,860
A character considers about 150 square meter area

787
00:33:31,900 --> 00:33:34,322
of possible positions, and so when you crop the AOO,

788
00:33:34,722 --> 00:33:36,143
you're cutting this down pretty drastically.

789
00:33:38,699 --> 00:33:39,961
One important theme to this, though,

790
00:33:40,241 --> 00:33:42,865
is that we still let the AI make their own systemic decisions,

791
00:33:42,945 --> 00:33:45,007
in this case, about exactly where to stand

792
00:33:45,108 --> 00:33:45,969
or where to take cover.

793
00:33:46,189 --> 00:33:48,031
We're just constraining their decision space,

794
00:33:48,392 --> 00:33:50,274
but within as generous a bounds as possible.

795
00:33:50,434 --> 00:33:51,396
And we'll see that come up again.

796
00:33:53,830 --> 00:33:55,932
Another subtler but really effective improvement

797
00:33:56,032 --> 00:33:59,015
came when we stopped telling AI exactly when to do things.

798
00:33:59,475 --> 00:34:02,098
For example, exactly when to move to the next area.

799
00:34:02,498 --> 00:34:04,180
Just because we assign them a new area

800
00:34:04,240 --> 00:34:06,062
doesn't mean we force them to move there right away.

801
00:34:06,422 --> 00:34:08,424
Instead, we wait for the AI to tell us

802
00:34:08,464 --> 00:34:09,565
that they want a reposition.

803
00:34:10,366 --> 00:34:13,688
Characters in combat in Just Cause 3 want to reposition fairly often,

804
00:34:13,788 --> 00:34:16,130
so it was good enough to update the area they want to be in,

805
00:34:16,410 --> 00:34:19,692
and then let them finish what they were doing before they decide to reposition.

806
00:34:20,333 --> 00:34:24,255
This helps avoid cutting off animations or firing patterns too awkwardly,

807
00:34:24,356 --> 00:34:26,237
and it also gives a nice staggering effect.

808
00:34:26,677 --> 00:34:29,559
You can notice here that Annika decides to get up and start running,

809
00:34:29,619 --> 00:34:32,521
but the other character, Tio, he's kind of already running by at this point,

810
00:34:32,561 --> 00:34:34,562
so you can see that kind of staggering effect in action.

811
00:34:35,223 --> 00:34:37,864
Again, this happens because we just update information

812
00:34:37,884 --> 00:34:39,485
in the back of their head instead of telling them

813
00:34:39,525 --> 00:34:41,486
exactly what to do or exactly when to do it.

814
00:34:44,647 --> 00:34:47,069
A different sort of example of affecting how AI

815
00:34:47,229 --> 00:34:49,210
act in a space while still leaving decisions

816
00:34:49,350 --> 00:34:52,291
up to the individual is this concept of restricted areas.

817
00:34:53,212 --> 00:34:55,653
If a content designer wants an area to be aggressively

818
00:34:55,713 --> 00:34:58,654
guarded by enemy AI, where they will warn the player

819
00:34:58,754 --> 00:35:00,755
and eventually open fire if the player stays there,

820
00:35:01,155 --> 00:35:03,436
they can author one of these invisible restricted areas.

821
00:35:04,604 --> 00:35:09,148
Importantly, the content designer does not need to assign certain characters to be the

822
00:35:09,208 --> 00:35:10,249
guards of this area.

823
00:35:10,449 --> 00:35:12,371
All they have to do is place the restricted area.

824
00:35:13,547 --> 00:35:14,268
Why is this better?

825
00:35:14,768 --> 00:35:17,030
That instead when the player enters a restricted area,

826
00:35:17,491 --> 00:35:19,973
all nearby AI get alerted to it?

827
00:35:20,313 --> 00:35:22,055
Well, this is because we have no way of knowing

828
00:35:22,135 --> 00:35:24,797
exactly which enemies will be where at any given time

829
00:35:24,817 --> 00:35:25,738
in a just cause game.

830
00:35:26,359 --> 00:35:28,741
In the first example in this video here,

831
00:35:29,241 --> 00:35:30,923
of course these AI are expected to be

832
00:35:30,943 --> 00:35:31,863
in this restricted area,

833
00:35:31,963 --> 00:35:34,065
and so they warn the player properly when he enters.

834
00:35:34,546 --> 00:35:35,527
But in the next clip,

835
00:35:36,327 --> 00:35:38,932
AI just kind of happened to be nearby this restricted area.

836
00:35:39,032 --> 00:35:40,935
And it would look really silly if they also

837
00:35:40,976 --> 00:35:42,959
didn't respond to the player entering this area.

838
00:35:43,420 --> 00:35:46,064
Luckily, because we don't need to stage particular guard AI,

839
00:35:46,205 --> 00:35:48,789
we just have the restricted area alert all AI nearby.

840
00:35:49,029 --> 00:35:50,151
This kind of takes care of itself.

841
00:35:52,458 --> 00:35:53,918
So maybe you're starting to sense a theme.

842
00:35:54,719 --> 00:35:56,800
And that theme I want to try and illustrate

843
00:35:56,860 --> 00:36:00,101
through my own attempt at a grandiose GDC quote

844
00:36:00,161 --> 00:36:01,802
on AI design, which is,

845
00:36:02,222 --> 00:36:04,383
the more chaotic and unpredictable your game,

846
00:36:04,743 --> 00:36:07,404
the more of an intelligence edge the runtime AI

847
00:36:07,604 --> 00:36:08,945
will have over the designers.

848
00:36:09,885 --> 00:36:11,626
I'll take a break so you can all take photos of this

849
00:36:11,746 --> 00:36:14,327
and I know you'll want to let it soak in,

850
00:36:14,547 --> 00:36:17,088
post it to Twitter, hashtag GDC, et cetera.

851
00:36:18,349 --> 00:36:18,549
Okay.

852
00:36:19,855 --> 00:36:22,558
Now, seeing as Just Cause 3 ranks very highly

853
00:36:22,718 --> 00:36:24,700
on the chaotic and unpredictability scale,

854
00:36:25,000 --> 00:36:26,341
which is part of what makes it great,

855
00:36:26,721 --> 00:36:29,083
this of course is a very important thing to respect for us.

856
00:36:29,964 --> 00:36:32,246
But, fair warning, your level designers

857
00:36:32,346 --> 00:36:35,188
will not necessarily appreciate you constantly telling them

858
00:36:35,268 --> 00:36:37,150
how much smarter your AI is than they are,

859
00:36:37,771 --> 00:36:39,432
so choose your words carefully.

860
00:36:39,952 --> 00:36:41,394
Maybe just tell them the AI will have

861
00:36:41,474 --> 00:36:43,255
more up-to-date information.

862
00:36:43,656 --> 00:36:45,497
That seems to go over okay.

863
00:36:47,552 --> 00:36:49,552
But anyways, following this principle,

864
00:36:49,752 --> 00:36:52,673
it becomes clear why this kind of annotation for the AI

865
00:36:52,813 --> 00:36:54,834
in a game like Just Cause 3 is so useful.

866
00:36:55,674 --> 00:36:57,455
By annotation, I'm referring to the way

867
00:36:57,495 --> 00:36:59,595
that content designers can mark up a space

868
00:36:59,755 --> 00:37:02,356
in order to influence AI to use it in a certain way.

869
00:37:03,036 --> 00:37:04,577
The restricted area we looked at before

870
00:37:04,677 --> 00:37:06,097
is actually one kind of annotation.

871
00:37:06,517 --> 00:37:08,918
A more traditional kind of annotation is cover points.

872
00:37:09,458 --> 00:37:11,179
All these little green spheres you see here,

873
00:37:11,559 --> 00:37:13,920
these are debug drawings of particular places

874
00:37:13,960 --> 00:37:16,120
where an AI can consider taking cover in battle.

875
00:37:17,427 --> 00:37:19,127
And again, they use a utility function

876
00:37:19,207 --> 00:37:21,028
to rank all the covers based on things

877
00:37:21,088 --> 00:37:23,909
like angle to the target, distance from other allies,

878
00:37:23,969 --> 00:37:25,329
distance to the target, et cetera.

879
00:37:25,749 --> 00:37:27,610
They score each cover, and they pick the cover

880
00:37:27,630 --> 00:37:29,091
with the highest score when they decide

881
00:37:29,151 --> 00:37:30,071
that they do want to cover.

882
00:37:32,032 --> 00:37:34,492
Another annotation example that's not combatant-focused

883
00:37:34,552 --> 00:37:37,093
at all is what we called systemic context actions.

884
00:37:38,011 --> 00:37:40,252
These are essentially animated looping behaviors

885
00:37:40,352 --> 00:37:42,092
that can be reserved, occupied,

886
00:37:42,132 --> 00:37:43,913
and engaged with by an AI for a time.

887
00:37:44,273 --> 00:37:45,934
For example, a wait at the bus stop

888
00:37:45,954 --> 00:37:48,114
systemic context action could be placed on a bus stop.

889
00:37:48,714 --> 00:37:50,775
Any eligible roaming civilian walking by

890
00:37:50,915 --> 00:37:53,596
can reserve that CA, move to it, enter it,

891
00:37:53,756 --> 00:37:54,956
and will now loop the special

892
00:37:55,076 --> 00:37:56,297
waiting for the bus animation.

893
00:37:57,157 --> 00:37:58,778
All sorts of places could be marked up

894
00:37:58,798 --> 00:38:00,918
with a variety of these that would enable AI

895
00:38:00,978 --> 00:38:03,039
to contextually interact with their environment

896
00:38:03,359 --> 00:38:05,160
and express various themes of the world

897
00:38:05,580 --> 00:38:06,720
through their animations.

898
00:38:07,832 --> 00:38:10,078
And this is much more dynamic and lifelike

899
00:38:10,118 --> 00:38:12,905
than simply staging AI who are always static and in place.

900
00:38:12,965 --> 00:38:15,131
It's much nicer to see AI coming and going

901
00:38:15,171 --> 00:38:16,394
from these different types of behaviors.

902
00:38:17,609 --> 00:38:20,530
Also, once again, this emphasizes directing the AI

903
00:38:20,590 --> 00:38:23,371
by authoring a space with optional or suggested behaviors

904
00:38:23,711 --> 00:38:25,712
that the AI can then, in real time,

905
00:38:25,772 --> 00:38:27,412
decide whether to utilize or not.

906
00:38:28,053 --> 00:38:30,533
It's better to give the AI an option to wait at the bus stop

907
00:38:30,673 --> 00:38:31,734
rather than force them to,

908
00:38:32,234 --> 00:38:34,435
because this way the AI can easily opt not to

909
00:38:34,735 --> 00:38:36,335
if, say, there's a tank at the bus stop

910
00:38:36,375 --> 00:38:37,656
or a crazy fight is going on

911
00:38:37,696 --> 00:38:39,416
or there's a bunch of stuff on fire nearby,

912
00:38:39,796 --> 00:38:42,037
all stuff that's more likely than not, to be honest.

913
00:38:44,980 --> 00:38:46,822
Now, when you're working with annotations,

914
00:38:47,462 --> 00:38:49,664
often it makes sense to build some of these annotation

915
00:38:49,764 --> 00:38:52,746
objects into the base templates of things themselves,

916
00:38:52,786 --> 00:38:53,967
the entities or the prefabs.

917
00:38:54,247 --> 00:38:57,409
For example, that wait for bus systemic context action,

918
00:38:57,790 --> 00:38:59,571
maybe we want to build that directly

919
00:38:59,631 --> 00:39:02,493
into the bus stop object so that wherever we place a bus stop,

920
00:39:02,613 --> 00:39:05,015
it comes with one of these wait for bus stop context actions.

921
00:39:05,795 --> 00:39:08,397
Maybe we want to build cover points into a concrete barrier

922
00:39:08,457 --> 00:39:11,139
so wherever world designers place these concrete barriers,

923
00:39:11,279 --> 00:39:12,780
AI can automatically take cover there.

924
00:39:13,740 --> 00:39:15,741
When this is done, these annotation objects

925
00:39:15,781 --> 00:39:17,962
would automatically, of course, accompany all instances

926
00:39:18,002 --> 00:39:19,023
of these entities in the world.

927
00:39:19,423 --> 00:39:20,944
And there's a lot of benefits of doing this.

928
00:39:21,765 --> 00:39:22,865
One of the benefits is, of course,

929
00:39:22,905 --> 00:39:24,506
it just saves a lot of authoring time.

930
00:39:24,606 --> 00:39:26,187
These things don't need to be manually placed.

931
00:39:26,547 --> 00:39:28,248
It usually makes sense, and it's very easy

932
00:39:28,268 --> 00:39:30,530
to perform mass edits on these things out in the world

933
00:39:30,650 --> 00:39:31,971
if they're all on the entity level.

934
00:39:33,512 --> 00:39:35,913
And the best part is sometimes it creates emergent,

935
00:39:35,993 --> 00:39:37,394
unexpected, and awesome moments.

936
00:39:37,894 --> 00:39:40,076
In this screenshot, we had decided earlier

937
00:39:40,176 --> 00:39:42,497
to build in cover points to any car wreck.

938
00:39:43,057 --> 00:39:44,879
Some vehicles get destroyed in the heat of battle,

939
00:39:45,020 --> 00:39:48,324
and now all of a sudden rebels are taking cover behind a vehicle wreck

940
00:39:48,404 --> 00:39:49,886
as they fight this enemy in the distance.

941
00:39:50,147 --> 00:39:52,049
And it's just a completely emergent scene

942
00:39:52,390 --> 00:39:55,814
that happened just because we built cover point entities into car wrecks.

943
00:39:57,894 --> 00:39:59,876
Now, there are some drawbacks to doing this.

944
00:40:00,357 --> 00:40:03,220
The biggest is that if you build these annotations

945
00:40:03,340 --> 00:40:05,562
into entities, things might start to feel too samey.

946
00:40:06,022 --> 00:40:08,125
If every instance of an entity or a prefab

947
00:40:08,165 --> 00:40:09,406
generates the same annotations,

948
00:40:09,466 --> 00:40:11,248
it can start to feel repetitive and gamey.

949
00:40:11,548 --> 00:40:13,971
If you see the same animation of a guy or a girl

950
00:40:14,031 --> 00:40:16,053
waiting for the bus at every bus stop in the game,

951
00:40:16,373 --> 00:40:18,295
it's gonna start to feel a lot less lifelike

952
00:40:18,335 --> 00:40:19,216
and a lot less interesting.

953
00:40:21,178 --> 00:40:23,400
Generally, we kind of just went for a hybrid approach

954
00:40:23,740 --> 00:40:25,842
where we built some stuff into entities,

955
00:40:26,202 --> 00:40:28,243
we tried to build a variety of things into the entities

956
00:40:28,283 --> 00:40:29,464
that it might randomly choose from,

957
00:40:29,764 --> 00:40:32,246
but more importantly, we still did a lot of it by hand,

958
00:40:32,326 --> 00:40:34,628
and we strongly believed that having this hand-touched

959
00:40:34,688 --> 00:40:36,969
flavor, especially to the more important locations

960
00:40:37,009 --> 00:40:38,450
in the game, really helped a lot.

961
00:40:40,686 --> 00:40:44,087
In summary, to wrap up the talk, we created an interface

962
00:40:44,327 --> 00:40:46,968
that empowered content creators to safely yet powerfully

963
00:40:47,028 --> 00:40:50,069
script their own AI without ever having to open a behavior tree

964
00:40:50,489 --> 00:40:52,410
while making sure the core of the systemic brain

965
00:40:52,530 --> 00:40:53,090
was preserved.

966
00:40:54,150 --> 00:40:56,971
We did this using modular micro behaviors on external trees

967
00:40:57,291 --> 00:40:59,232
that could be packaged with meta utility trees

968
00:40:59,472 --> 00:41:01,973
and inserted into intro, interrupt, or idle points.

969
00:41:03,173 --> 00:41:05,314
We successfully synced this with the mission system's check

970
00:41:05,354 --> 00:41:07,595
pointing by having mission objectives provide

971
00:41:07,615 --> 00:41:09,095
the behaviors to be run during them.

972
00:41:11,112 --> 00:41:13,732
And we influenced AI using more bottom-up, systemic,

973
00:41:13,892 --> 00:41:16,253
and annotation-based tools that could guide the AI,

974
00:41:16,533 --> 00:41:19,134
but would still let them decide things on their own terms.

975
00:41:19,554 --> 00:41:21,295
And this, of course, is much more accommodating

976
00:41:21,315 --> 00:41:23,255
to a just cause level of unpredictability.

977
00:41:24,976 --> 00:41:26,416
So thank you all for attending and listening.

978
00:41:26,616 --> 00:41:28,397
You can find some contact info on here,

979
00:41:28,557 --> 00:41:29,917
and I wanna make sure to give special thanks

980
00:41:29,937 --> 00:41:31,858
to the people you see there who help me with feedback

981
00:41:31,958 --> 00:41:33,538
or gathering assets for the presentation.

982
00:41:34,218 --> 00:41:34,438
Thanks.

983
00:41:43,939 --> 00:41:46,599
I'm not sure what time it is, but any questions,

984
00:41:46,660 --> 00:41:47,640
feel free to ask.

985
00:41:51,921 --> 00:41:53,462
And if there's no questions that anybody wanna ask,

986
00:41:53,602 --> 00:41:54,742
oh, there it is, great.

987
00:41:55,183 --> 00:41:56,003
Hi, great talk.

988
00:41:56,803 --> 00:41:59,164
I just wondered if you had thought about

989
00:41:59,224 --> 00:42:02,345
and discarded using a planner for something similar to this

990
00:42:03,105 --> 00:42:04,426
as opposed to behavior trees?

991
00:42:04,966 --> 00:42:07,327
Yeah, the question is if we considered using a planner

992
00:42:07,387 --> 00:42:09,048
more than just individual behavior trees.

993
00:42:09,728 --> 00:42:10,808
We've definitely thought about that,

994
00:42:10,948 --> 00:42:12,869
and on further projects, we're exploring it.

995
00:42:13,940 --> 00:42:17,623
It really depends on the type of game and the type of problem that you want the planner to solve.

996
00:42:18,263 --> 00:42:20,444
In our case, for a just cause game,

997
00:42:21,105 --> 00:42:25,007
you probably don't need that much tactical maneuvering to happen for the AI,

998
00:42:25,047 --> 00:42:26,668
because that's not really what the game is about.

999
00:42:26,848 --> 00:42:30,630
And so it almost is better suited to have a bunch of individuals running around,

1000
00:42:30,650 --> 00:42:32,411
like, trying to manage the chaos the best they can.

1001
00:42:32,852 --> 00:42:34,673
but there are a lot of valid cases

1002
00:42:34,713 --> 00:42:35,994
where it would be nice to have a planner.

1003
00:42:36,034 --> 00:42:37,855
For example, deciding which characters

1004
00:42:37,875 --> 00:42:39,616
should kind of enter combat with the player

1005
00:42:39,656 --> 00:42:41,558
and which should kind of keep their position and hold off.

1006
00:42:41,898 --> 00:42:42,818
That's something that a planner

1007
00:42:42,839 --> 00:42:44,920
could have helped us a lot with in Just Cause 3

1008
00:42:45,240 --> 00:42:46,641
and maybe we'll explore in future games.

1009
00:42:48,022 --> 00:42:48,122
Yeah.

1010
00:42:49,646 --> 00:42:51,989
So you mentioned the utility functions a number of times.

1011
00:42:52,169 --> 00:42:52,890
Where do those live?

1012
00:42:52,910 --> 00:42:56,114
Do those live in each AI, or do they live in the objects

1013
00:42:56,154 --> 00:42:57,415
that the AI runs into?

1014
00:42:58,056 --> 00:43:00,739
Right, so the question is, where did the utility functions live?

1015
00:43:01,080 --> 00:43:04,864
So the utility functions all live in just C++ code, but each.

1016
00:43:05,985 --> 00:43:08,386
AI can run an action in their behavior tree

1017
00:43:08,486 --> 00:43:09,926
that basically requests the outcome

1018
00:43:09,966 --> 00:43:10,907
of that utility function.

1019
00:43:10,967 --> 00:43:13,187
So for example, there's a node in the behavior tree

1020
00:43:13,207 --> 00:43:16,889
called get combat position that talks to C++ code

1021
00:43:17,309 --> 00:43:18,949
and runs the utility function there

1022
00:43:18,969 --> 00:43:20,390
and then returns the best position.

1023
00:43:20,870 --> 00:43:22,490
Or the AI might run an action that says,

1024
00:43:22,550 --> 00:43:24,371
give me a good cover nearby.

1025
00:43:25,131 --> 00:43:27,332
That action communicates with C++ code

1026
00:43:27,372 --> 00:43:28,992
that calculates the best cover nearby

1027
00:43:29,033 --> 00:43:31,593
and then returns them the entity handle of that best cover.

1028
00:43:32,073 --> 00:43:33,874
So the utility functions are calculated in code,

1029
00:43:33,914 --> 00:43:35,334
and the behavior tree can converse with that.

1030
00:43:39,595 --> 00:43:39,695
OK.

1031
00:43:40,015 --> 00:43:40,075
Hi.

1032
00:43:40,115 --> 00:43:40,215
Hi.

1033
00:43:40,656 --> 00:43:43,816
So Just 2.3 is an open-world game.

1034
00:43:43,876 --> 00:43:49,238
So probably something like microbehavior tree

1035
00:43:49,498 --> 00:43:53,079
is tagged into some asset and loaded into this

1036
00:43:53,279 --> 00:43:56,800
so syncutaneously, or that kind of stuff can be available.

1037
00:43:58,543 --> 00:43:59,444
Sorry, can you repeat the question?

1038
00:44:00,265 --> 00:44:04,448
So can you lower some asset with other asset

1039
00:44:04,488 --> 00:44:06,290
like animation or sound with?

1040
00:44:07,949 --> 00:44:09,309
micro behavior tree.

1041
00:44:09,469 --> 00:44:11,410
So yeah, it's the question that can you put behavior trees

1042
00:44:11,450 --> 00:44:14,352
on other assets like animations or sounds or objects

1043
00:44:14,392 --> 00:44:15,072
or smart objects?

1044
00:44:15,812 --> 00:44:15,993
Yeah.

1045
00:44:16,053 --> 00:44:18,754
Yeah, we didn't really do that that much in Just Cause 3,

1046
00:44:18,994 --> 00:44:19,774
but we can do that.

1047
00:44:19,834 --> 00:44:21,795
You could, for example, potentially put a behavior tree

1048
00:44:21,875 --> 00:44:24,937
on a building and have it like kind of listen to the world

1049
00:44:24,977 --> 00:44:26,958
and like play different lighting effects or dialogues

1050
00:44:27,018 --> 00:44:28,919
based on if it detects like explosions or whatever,

1051
00:44:28,939 --> 00:44:30,299
and you could use a behavior tree for that.

1052
00:44:30,700 --> 00:44:32,881
We didn't end up investing in that too much,

1053
00:44:33,321 --> 00:44:35,042
but that is something that you can definitely do

1054
00:44:35,062 --> 00:44:36,603
and that we want to try doing is using

1055
00:44:37,343 --> 00:44:39,205
Whether it's a behavior tree or some other type of script,

1056
00:44:39,406 --> 00:44:41,688
this type of scripting that can live on other animations

1057
00:44:41,728 --> 00:44:43,150
or objects in the world.

1058
00:44:43,971 --> 00:44:44,472
OK, thanks.

1059
00:44:44,672 --> 00:44:44,832
Yeah.

1060
00:44:47,215 --> 00:44:47,456
Cool.

1061
00:44:47,496 --> 00:44:48,977
And I'll be around in the hall afterwards

1062
00:44:48,997 --> 00:44:51,220
if there are any other questions that people want to come chat.

1063
00:44:51,501 --> 00:44:51,681
Thanks.

