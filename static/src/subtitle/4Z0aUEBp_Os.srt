1
00:00:06,357 --> 00:00:07,217
Thanks for being here today.

2
00:00:08,157 --> 00:00:11,118
So just a quick reminder, if you can just mute your phone.

3
00:00:11,458 --> 00:00:13,338
And also, at the end of the session,

4
00:00:14,499 --> 00:00:16,099
there is a survey that you can fill.

5
00:00:17,039 --> 00:00:20,240
If we want to give any feedback, it will be really appreciated.

6
00:00:20,380 --> 00:00:23,981
It's our first talk here at GDC, so anything

7
00:00:24,021 --> 00:00:25,161
can be interesting for us.

8
00:00:25,922 --> 00:00:28,922
So this is Xavier Guibaud, gameplay tech lead on For Honor.

9
00:00:29,042 --> 00:00:31,483
And I am Frédéric Doll, AI programmer on For Honor

10
00:00:31,943 --> 00:00:32,783
at Ubisoft Montreal.

11
00:00:33,744 --> 00:00:35,444
So the game has been released two weeks ago.

12
00:00:36,447 --> 00:00:39,748
And the feedback we get from the community is really incredible.

13
00:00:40,589 --> 00:00:43,630
But a few years ago, when we started working on the project,

14
00:00:43,850 --> 00:00:45,791
we didn't know exactly what would be the game today.

15
00:00:45,971 --> 00:00:47,971
And in fact, most of the time, when

16
00:00:47,991 --> 00:00:49,992
you work on a new IP, on a new game,

17
00:00:50,592 --> 00:00:53,113
you don't know what you will be released at the end.

18
00:00:53,653 --> 00:00:54,474
You need to iterate.

19
00:00:54,674 --> 00:00:55,594
You need to prototype.

20
00:00:55,714 --> 00:00:56,995
You need to test stuff.

21
00:00:57,075 --> 00:00:59,896
You need to find what is fun and try to build around it.

22
00:01:00,756 --> 00:01:02,457
On the tech side, it means that.

23
00:01:02,971 --> 00:01:05,492
You have multiple needs that will emerge.

24
00:01:05,652 --> 00:01:08,413
And as we were able to see during this conference,

25
00:01:09,594 --> 00:01:11,314
sometimes one technology is not enough

26
00:01:11,534 --> 00:01:12,735
to fulfill all these needs.

27
00:01:13,295 --> 00:01:15,616
And you have to test multiple approaches,

28
00:01:15,796 --> 00:01:17,276
and maybe have multiple approaches

29
00:01:17,316 --> 00:01:19,757
that cohabit in your game.

30
00:01:20,838 --> 00:01:23,899
So the vision for For Honor was to create a melee fighting

31
00:01:23,919 --> 00:01:24,059
game.

32
00:01:24,519 --> 00:01:25,860
So basically, you control a character,

33
00:01:25,920 --> 00:01:27,940
but most importantly, you control his weapon.

34
00:01:28,121 --> 00:01:30,802
So you really are inside the battlefield.

35
00:01:31,122 --> 00:01:32,202
You are inside the combat.

36
00:01:33,642 --> 00:01:37,765
One important aspect is that the game needed to have a competitive,

37
00:01:37,785 --> 00:01:38,546
multi-player aspect.

38
00:01:39,207 --> 00:01:43,550
The game needs to be fair because it's player against players.

39
00:01:44,211 --> 00:01:46,933
It needs to be skill-based, responsive, reactive,

40
00:01:47,233 --> 00:01:47,793
and stuff like that.

41
00:01:48,874 --> 00:01:52,657
Also, we wanted to create a game where you

42
00:01:52,738 --> 00:01:53,898
are in a believable battlefield.

43
00:01:54,099 --> 00:01:55,320
It means that it's not.

44
00:01:56,203 --> 00:02:01,284
a kind of arena of gladiators where a few fighters are fighting each other, but really

45
00:02:01,825 --> 00:02:07,266
a huge battlefield with the clash of armies, hundreds of NPCs that fight each other and

46
00:02:07,306 --> 00:02:09,607
you are only one soldier inside this battlefield.

47
00:02:10,827 --> 00:02:14,408
So for the AI, we ended up creating two separated systems.

48
00:02:15,155 --> 00:02:16,935
One deterministic, one replicated.

49
00:02:17,456 --> 00:02:17,656
Why?

50
00:02:18,236 --> 00:02:20,417
What's happened during the process?

51
00:02:21,237 --> 00:02:23,838
What are the needs that we needed to fulfill?

52
00:02:24,318 --> 00:02:27,179
That's what we'll try to show today with this talk.

53
00:02:27,899 --> 00:02:30,660
So in this talk, we'll first show

54
00:02:30,680 --> 00:02:33,081
a few fundamentals of the game, how we control characters,

55
00:02:33,201 --> 00:02:35,942
how we handle the online part, and stuff like that.

56
00:02:36,583 --> 00:02:39,305
Then Xavier will talk about the deterministic AI system.

57
00:02:39,665 --> 00:02:41,666
I will follow with the replicated one.

58
00:02:42,266 --> 00:02:44,988
And we will have a few takeaways at the end of the session.

59
00:02:46,049 --> 00:02:48,110
So let's start with the fundamentals.

60
00:02:49,791 --> 00:02:51,432
In the game, we have multiple characters

61
00:02:52,132 --> 00:02:52,953
that you have to control.

62
00:02:53,333 --> 00:02:56,635
First one is the hero, the one with the more skills,

63
00:02:56,675 --> 00:02:57,375
the more abilities.

64
00:02:58,116 --> 00:03:01,197
It's the one that the player is able to control in the game.

65
00:03:03,334 --> 00:03:05,896
But we have also what we could call the map feeders.

66
00:03:06,657 --> 00:03:09,679
So on the left, captain, soldiers, archers,

67
00:03:09,899 --> 00:03:10,520
this kind of stuff.

68
00:03:11,501 --> 00:03:13,903
These are the characters that create

69
00:03:13,943 --> 00:03:15,144
the feeling of the army.

70
00:03:15,844 --> 00:03:19,467
Also in the campaign, we have a cute elephant and huge wolves.

71
00:03:20,408 --> 00:03:23,811
We have horses and other kind of characters.

72
00:03:25,332 --> 00:03:27,514
So yeah, that's the kind of character we have to control.

73
00:03:30,756 --> 00:03:32,358
To control this character, we decided

74
00:03:32,398 --> 00:03:33,699
to use an input-driven approach.

75
00:03:33,879 --> 00:03:36,762
It means that it's like controlling a gamepad.

76
00:03:37,403 --> 00:03:39,265
So if you have a gamepad, you just press a button,

77
00:03:39,745 --> 00:03:42,929
and it will have an impact on your character.

78
00:03:43,489 --> 00:03:45,431
But it means also that you have indirect control

79
00:03:45,531 --> 00:03:46,072
on your character.

80
00:03:46,232 --> 00:03:48,474
You can't say in the eye, for example,

81
00:03:48,895 --> 00:03:51,097
I want my character to go at 10 meters per second.

82
00:03:51,598 --> 00:03:52,418
There is no way to do that.

83
00:03:52,812 --> 00:03:58,294
The only thing you can do is give the orientation of the left stick of your gamepad and the

84
00:03:58,334 --> 00:04:00,895
strength of the stick and that's all.

85
00:04:01,535 --> 00:04:03,236
So it means that the AI is input driven.

86
00:04:03,856 --> 00:04:08,258
We use exactly the same pipeline for the player and for the AI in this game.

87
00:04:09,383 --> 00:04:13,465
We let you go to one of our tools, we call it Katana.

88
00:04:14,086 --> 00:04:16,747
Basically, it's a tool that the character designer

89
00:04:17,027 --> 00:04:18,448
used to create the characters.

90
00:04:19,109 --> 00:04:22,351
So it's a huge state machine in which all the states,

91
00:04:22,591 --> 00:04:24,112
the blue boxes that you can see here,

92
00:04:25,373 --> 00:04:27,074
define a state of the character.

93
00:04:27,134 --> 00:04:28,174
So it defines a gameplay.

94
00:04:29,690 --> 00:04:31,111
during a certain duration.

95
00:04:31,571 --> 00:04:34,293
The duration is defined by the length of the clip.

96
00:04:35,354 --> 00:04:38,916
And they can define all kind of properties,

97
00:04:38,936 --> 00:04:41,518
the movement available for the character at this moment.

98
00:04:42,259 --> 00:04:43,420
Does he have some defense?

99
00:04:45,141 --> 00:04:46,662
Maybe he has some modifier.

100
00:04:46,682 --> 00:04:48,223
He has some special abilities.

101
00:04:48,703 --> 00:04:52,026
And they also can define all the branchings between the states.

102
00:04:52,646 --> 00:04:53,947
And as you can see on the bottom,

103
00:04:53,967 --> 00:04:55,708
they can specify some kind of conditions

104
00:04:55,989 --> 00:04:58,370
that allow to trigger these kind of branchings.

105
00:05:00,277 --> 00:05:03,218
So yeah, that's it.

106
00:05:03,378 --> 00:05:05,379
Sorry.

107
00:05:06,140 --> 00:05:10,142
So what does an update loop look like in our game?

108
00:05:10,942 --> 00:05:12,023
It's, in fact, pretty simple.

109
00:05:12,203 --> 00:05:14,284
We just generate inputs from a pad.

110
00:05:14,684 --> 00:05:15,945
We send them into Katana.

111
00:05:16,705 --> 00:05:18,546
Katana updates the state of the actor.

112
00:05:18,906 --> 00:05:21,868
We get this into the world, and we're able to render it.

113
00:05:22,622 --> 00:05:25,403
If we have multiple characters, it's exactly the same.

114
00:05:25,783 --> 00:05:27,864
We just generate input for the other character.

115
00:05:28,264 --> 00:05:29,404
We send them into Katana.

116
00:05:29,664 --> 00:05:31,624
It updates the state of the associated actor,

117
00:05:32,065 --> 00:05:33,845
and we're able to put that in the world.

118
00:05:34,325 --> 00:05:36,546
So for the AI, since we use the same pipeline,

119
00:05:36,966 --> 00:05:38,006
it's pretty simple.

120
00:05:39,086 --> 00:05:41,827
The AI has to generate inputs, send them into Katana,

121
00:05:42,027 --> 00:05:43,587
and you know what happens after that.

122
00:05:44,127 --> 00:05:45,628
But how does it work in multiplayer?

123
00:05:45,908 --> 00:05:48,168
I will let Xavier explain this system.

124
00:05:50,171 --> 00:05:50,411
Hello?

125
00:05:51,392 --> 00:05:53,274
So yes, our game is a multiplayer game.

126
00:05:53,474 --> 00:05:54,215
It works online.

127
00:05:54,235 --> 00:05:56,437
The players are fighting against each other.

128
00:05:56,958 --> 00:05:59,900
And the architecture that we chose from the beginning was

129
00:05:59,940 --> 00:06:00,921
to build a peer-to-peer one.

130
00:06:01,342 --> 00:06:04,024
And the main reason was that we wanted as little latency as

131
00:06:04,084 --> 00:06:06,447
possible between two fighters, between when you're fighting

132
00:06:06,487 --> 00:06:08,409
somebody, he's in front of you, he's in your face.

133
00:06:08,929 --> 00:06:10,971
We wanted it to be as fast as possible.

134
00:06:11,882 --> 00:06:15,242
So what we actually send between each of the peers in

135
00:06:15,282 --> 00:06:18,083
a session are actually the inputs of the players.

136
00:06:18,523 --> 00:06:23,004
It's the only thing, with very rare exceptions, that are

137
00:06:23,024 --> 00:06:23,644
actually sent.

138
00:06:24,364 --> 00:06:27,665
And the way that it works is when a peer receives those

139
00:06:27,725 --> 00:06:30,725
inputs from the network, it's the exact same pipeline that

140
00:06:30,765 --> 00:06:32,186
Frédéric mentioned.

141
00:06:32,406 --> 00:06:33,186
We get those inputs.

142
00:06:33,526 --> 00:06:35,626
It starts driving the new actor with Katana.

143
00:06:36,631 --> 00:06:38,072
But obviously, there is lag.

144
00:06:38,412 --> 00:06:40,654
We're not receiving those inputs immediately yet.

145
00:06:41,675 --> 00:06:45,857
So what we do is we have a deterministic simulation

146
00:06:46,038 --> 00:06:48,519
that runs on every single peer of the session.

147
00:06:49,180 --> 00:06:51,982
What that means is that every peer

148
00:06:52,122 --> 00:06:54,624
is responsible to keeping in sync with everybody.

149
00:06:55,444 --> 00:06:57,666
When we receive an input from another peer,

150
00:06:59,547 --> 00:07:03,130
every peer rewinds in time and resimulates every single step

151
00:07:03,270 --> 00:07:03,770
to catch up.

152
00:07:04,330 --> 00:07:05,771
And we end up with the same conclusion.

153
00:07:06,392 --> 00:07:10,315
So this deterministic simulation in the game,

154
00:07:10,755 --> 00:07:12,897
what Frédéric showed you before, the graph,

155
00:07:13,317 --> 00:07:16,520
it's all our gameplay runs into that simulation.

156
00:07:16,980 --> 00:07:20,042
So everything is deterministic and comes to the same conclusion.

157
00:07:21,083 --> 00:07:23,265
To illustrate a bit what that means,

158
00:07:23,785 --> 00:07:27,288
I'm going to give an example that doesn't really happen in our game,

159
00:07:27,508 --> 00:07:29,850
because we don't have three frames attacks in our game,

160
00:07:29,910 --> 00:07:32,332
but I think it illustrates what happens.

161
00:07:33,169 --> 00:07:36,110
Imagine you're fighting somebody over the net.

162
00:07:36,270 --> 00:07:37,151
He's on the other side.

163
00:07:37,171 --> 00:07:39,152
And you launch an attack.

164
00:07:39,833 --> 00:07:41,854
So at time zero, your attack is launched.

165
00:07:42,294 --> 00:07:43,415
And we compute the frame.

166
00:07:43,595 --> 00:07:44,916
You start winding up the attack.

167
00:07:45,376 --> 00:07:47,618
Your weapon is starting to travel.

168
00:07:48,318 --> 00:07:49,219
The frame continues.

169
00:07:49,419 --> 00:07:52,781
We get to the second part of the animation.

170
00:07:53,201 --> 00:07:54,522
And you finally hit your opponent.

171
00:07:55,123 --> 00:07:55,723
You're happy.

172
00:07:56,283 --> 00:07:57,904
You're trying to celebrate.

173
00:07:58,104 --> 00:08:00,226
And then now comes the fourth frame.

174
00:08:01,735 --> 00:08:04,317
Imagine at that moment that you actually receive an input

175
00:08:04,417 --> 00:08:05,738
from your opponent at that moment.

176
00:08:06,499 --> 00:08:08,380
I mentioned that the inputs are time stamped.

177
00:08:08,700 --> 00:08:11,623
So we see at that moment that at time zero, the opponent

178
00:08:12,043 --> 00:08:13,164
decided to change his stance.

179
00:08:13,825 --> 00:08:16,947
So what that means for us in the game is that that input,

180
00:08:17,067 --> 00:08:20,070
it needs to be taken into account at time zero the

181
00:08:20,110 --> 00:08:20,871
moment that it happened.

182
00:08:21,711 --> 00:08:24,514
And what we do is that we completely invalidate the

183
00:08:24,534 --> 00:08:25,414
state in which we were.

184
00:08:25,975 --> 00:08:28,257
So there were never any hits.

185
00:08:28,597 --> 00:08:29,177
It didn't happen.

186
00:08:30,263 --> 00:08:33,689
And always in the same frame that were mentioned,

187
00:08:33,709 --> 00:08:36,053
so the fourth frame, we start resimulating

188
00:08:36,413 --> 00:08:39,118
every single step, but now with that new information.

189
00:08:39,799 --> 00:08:42,664
So the information catches on, we resimulate,

190
00:08:42,904 --> 00:08:44,146
and we end up with the result.

191
00:08:45,275 --> 00:08:47,296
Obviously, in that case, it's pretty intense.

192
00:08:47,716 --> 00:08:49,897
But as I mentioned, we don't have four frames

193
00:08:49,957 --> 00:08:50,717
attacks in our games.

194
00:08:51,377 --> 00:08:54,778
But it's really important, that aspect, because it

195
00:08:54,878 --> 00:08:57,519
introduces a fundamental difference in our game between

196
00:08:57,539 --> 00:08:59,240
a frame and a simulation step.

197
00:08:59,840 --> 00:09:03,021
Because simulation steps happen multiple times per frame.

198
00:09:03,861 --> 00:09:07,082
They're directly dependent about your network conditions.

199
00:09:07,402 --> 00:09:09,163
When you receive those inputs, what's happening?

200
00:09:10,022 --> 00:09:11,303
So imagine you have your big frame,

201
00:09:12,004 --> 00:09:13,245
do a couple of simulations,

202
00:09:13,866 --> 00:09:16,889
but as soon as you start having inputs that bring you really far away in time,

203
00:09:17,690 --> 00:09:20,653
your frame becomes way too big, the player is sad, the framerate drops.

204
00:09:20,993 --> 00:09:23,576
So this was a really big implication for our game.

205
00:09:24,875 --> 00:09:26,755
Those rewinds, they happen all the time.

206
00:09:27,455 --> 00:09:30,976
We have a way of prioritizing the inputs of the actor

207
00:09:31,336 --> 00:09:32,357
that's fighting in front of you,

208
00:09:32,477 --> 00:09:34,137
so you won't see any rewinds with him,

209
00:09:34,597 --> 00:09:35,457
or as least as possible.

210
00:09:36,037 --> 00:09:37,538
But the actors that are around him,

211
00:09:37,698 --> 00:09:39,658
players that are on the other side of the map,

212
00:09:39,918 --> 00:09:41,059
they still generate those inputs

213
00:09:41,099 --> 00:09:42,759
that are processed more slowly.

214
00:09:43,219 --> 00:09:45,580
So we always have up to three to four

215
00:09:46,020 --> 00:09:47,480
resimulation steps per frame.

216
00:09:47,740 --> 00:09:50,201
So it's our normal operation.

217
00:09:50,881 --> 00:09:55,602
And we need to be able to recover and not have a big impact on frame rate

218
00:09:55,722 --> 00:09:57,503
when we have a really big resimulation.

219
00:09:57,623 --> 00:09:59,243
So in that case, for example,

220
00:10:00,704 --> 00:10:04,085
300 milliseconds delay, which would mean 600 milliseconds of ping,

221
00:10:05,145 --> 00:10:09,266
it incurs up to nine steps of resimulation in a single frame.

222
00:10:11,008 --> 00:10:13,930
To be able to do this, every single object in our game

223
00:10:13,950 --> 00:10:15,891
has a history buffer.

224
00:10:16,471 --> 00:10:18,632
So we save the states of those actors.

225
00:10:19,073 --> 00:10:22,575
It's in a simplified structure, optimized and compressed

226
00:10:22,615 --> 00:10:23,435
as much as possible.

227
00:10:24,075 --> 00:10:26,957
And every actor has a definition of that state

228
00:10:27,617 --> 00:10:30,779
that's then copied inside a bigger list.

229
00:10:31,500 --> 00:10:34,161
And that history buffer, we keep around up to five seconds

230
00:10:34,341 --> 00:10:35,362
for every single object.

231
00:10:35,822 --> 00:10:37,703
So of course, that takes a lot of memory.

232
00:10:38,904 --> 00:10:43,749
But that enables us really to, when you go back in time, to resimulate from that moment.

233
00:10:44,910 --> 00:10:48,253
I mentioned every single object has that, and it's really the case.

234
00:10:49,694 --> 00:10:50,375
You get the idea.

235
00:10:51,496 --> 00:10:58,383
Every gameplay element, the explosions in the background, the guys fighting, the heroes, the small soldiers, they all use that system.

236
00:11:00,188 --> 00:11:02,248
It introduces also something really awesome

237
00:11:02,268 --> 00:11:04,689
that we did in the game that helped the production

238
00:11:05,009 --> 00:11:07,770
that you don't really see when you play it.

239
00:11:08,350 --> 00:11:10,191
It's the fact that since we keep all those states

240
00:11:10,471 --> 00:11:12,272
and our game is deterministic,

241
00:11:12,692 --> 00:11:15,433
we're able to have those kind of features in our editor.

242
00:11:15,453 --> 00:11:18,414
Let's say you're fighting, you're testing something,

243
00:11:18,434 --> 00:11:21,715
our designer is working in it and he sees a bug.

244
00:11:24,598 --> 00:11:27,259
And he's like, this didn't work as expected.

245
00:11:27,779 --> 00:11:29,079
Maybe there's something that was wrong.

246
00:11:29,540 --> 00:11:32,320
Well, we have the ability to rewind and go back directly

247
00:11:32,500 --> 00:11:35,041
to where was the interesting moment.

248
00:11:35,721 --> 00:11:36,701
And we can replay.

249
00:11:37,041 --> 00:11:40,642
And all the inputs of the players at that moment were

250
00:11:40,682 --> 00:11:42,062
recorded, and we replayed them.

251
00:11:42,643 --> 00:11:47,704
So we get to the exact same conclusion than

252
00:11:47,744 --> 00:11:48,504
what we saw before.

253
00:11:48,984 --> 00:11:51,765
And all our tools can enable us to inspect what's happening.

254
00:11:51,885 --> 00:11:54,065
We can see what's the states of the objects.

255
00:11:54,966 --> 00:11:56,647
And I mentioned designers because it's

256
00:11:56,687 --> 00:11:57,988
a really powerful tool for them.

257
00:11:58,368 --> 00:12:00,650
But even for us programmers, I mean,

258
00:12:00,750 --> 00:12:02,451
since the code is deterministic, we

259
00:12:02,471 --> 00:12:03,752
can put a breakpoint in the code.

260
00:12:04,232 --> 00:12:08,095
And what we're going to see is the exact same values happening.

261
00:12:09,436 --> 00:12:10,757
Awesome camera work, by the way.

262
00:12:12,138 --> 00:12:15,501
So everything that's happening, it's a really powerful tool.

263
00:12:16,101 --> 00:12:18,763
It was a bit of a side effect of that architecture choice,

264
00:12:18,823 --> 00:12:20,764
but we wanted to share a bit about it.

265
00:12:21,705 --> 00:12:22,627
You probably see me coming.

266
00:12:22,647 --> 00:12:25,612
This talk is about AI, deterministic AI.

267
00:12:25,913 --> 00:12:29,259
So the deterministic simulation is where they live,

268
00:12:29,560 --> 00:12:30,081
what's happening.

269
00:12:31,495 --> 00:12:36,177
And when we started the game, we knew a bit in which

270
00:12:36,197 --> 00:12:37,118
direction we were going.

271
00:12:37,318 --> 00:12:39,639
But we wanted to give a believable medieval

272
00:12:39,679 --> 00:12:41,120
battlefield to the player.

273
00:12:41,600 --> 00:12:45,862
We wanted them to have a sense of scale, being able to fight

274
00:12:46,162 --> 00:12:49,003
other fierce opponents, the other players, but also to be

275
00:12:49,043 --> 00:12:49,924
part of something bigger.

276
00:12:50,524 --> 00:12:52,505
So we knew that we wanted to add a lot of

277
00:12:52,525 --> 00:12:53,365
factors in our world.

278
00:12:53,985 --> 00:12:57,169
We were not aiming to tens of thousands of actors.

279
00:12:58,471 --> 00:13:01,134
I mean, we're not a shooter, so the size of our maps

280
00:13:01,294 --> 00:13:02,235
was not going to be that big.

281
00:13:02,796 --> 00:13:04,718
But around 200 actors was basically

282
00:13:04,738 --> 00:13:05,579
our goal at that moment.

283
00:13:06,500 --> 00:13:08,883
And with the architecture that we showed you in the beginning,

284
00:13:09,143 --> 00:13:10,825
sending all those inputs over the network,

285
00:13:11,166 --> 00:13:12,567
we knew it was not going to cut it.

286
00:13:12,768 --> 00:13:14,269
It was going to take way too much bandwidth.

287
00:13:15,458 --> 00:13:18,120
So our solution for that, as we mentioned in the simulation,

288
00:13:18,160 --> 00:13:21,923
was rather than computing the inputs that we're sending

289
00:13:22,003 --> 00:13:24,885
to actors from outside the simulation and sending them,

290
00:13:25,666 --> 00:13:27,647
compute them from inside the simulation.

291
00:13:27,967 --> 00:13:29,729
Thus, the deterministic AI.

292
00:13:30,509 --> 00:13:32,571
What that means is that when you're playing online,

293
00:13:33,091 --> 00:13:36,133
every single peer is coming to the same conclusion

294
00:13:36,174 --> 00:13:38,055
and controls his AI in the exact same way,

295
00:13:38,195 --> 00:13:39,876
everybody's synchronized,

296
00:13:40,277 --> 00:13:42,238
without sending anything over the network.

297
00:13:43,244 --> 00:13:44,765
That's a really big implication for us.

298
00:13:44,965 --> 00:13:47,467
It met our requirements.

299
00:13:47,687 --> 00:13:48,487
It worked well for that.

300
00:13:48,768 --> 00:13:49,588
No network traffic.

301
00:13:49,628 --> 00:13:50,209
That's awesome.

302
00:13:51,109 --> 00:13:53,231
But it had a really big implication about what did

303
00:13:53,251 --> 00:13:54,972
that mean on the CPU side.

304
00:13:55,593 --> 00:13:58,054
Computing all those actors with those rewinds, it was

305
00:13:58,074 --> 00:13:58,935
going to come to a cost.

306
00:13:59,275 --> 00:14:00,996
So we needed to find a good solution for that.

307
00:14:02,303 --> 00:14:05,066
So we have multiple one of them, but the big ones that

308
00:14:05,126 --> 00:14:08,290
enabled us to do that is the first one is time slicing.

309
00:14:08,951 --> 00:14:12,315
Those actors, we wanted them to fill the map so that the

310
00:14:12,335 --> 00:14:15,219
players had a sense of scale.

311
00:14:15,880 --> 00:14:19,404
They did not have to be as reactive as possible, so we

312
00:14:19,444 --> 00:14:19,925
cheated a bit.

313
00:14:20,466 --> 00:14:26,591
and time slicing them and basically not updating them every single step of the simulation

314
00:14:27,131 --> 00:14:32,236
means that if we get to a frame that we need to resimulate multiple simulation steps

315
00:14:32,756 --> 00:14:34,858
well those actors are only going to be updated once.

316
00:14:36,036 --> 00:14:39,659
So our update time that we came up with was around 3 hertz.

317
00:14:40,200 --> 00:14:45,324
So of course, it's something that we tested through play

318
00:14:45,364 --> 00:14:46,605
tests, through gameplays.

319
00:14:47,146 --> 00:14:49,908
We needed to see what was the limit at which

320
00:14:49,928 --> 00:14:50,529
we could bring that.

321
00:14:51,149 --> 00:14:54,532
But it did allow us to be extremely resilient to rewinds

322
00:14:54,592 --> 00:14:55,433
in that case.

323
00:14:56,554 --> 00:14:58,455
The second steps are simplified physics.

324
00:14:59,416 --> 00:15:02,139
So this is the world that you see when you play the game.

325
00:15:02,539 --> 00:15:03,420
It looks pretty and all.

326
00:15:04,251 --> 00:15:09,372
And this is the world that the players, the collisions

327
00:15:09,412 --> 00:15:10,793
that the players actually interact with.

328
00:15:11,173 --> 00:15:14,294
The collision meshes, everybody's probably aware of

329
00:15:14,334 --> 00:15:14,914
those systems.

330
00:15:15,734 --> 00:15:18,515
But even that, it proved too much, too costly

331
00:15:18,655 --> 00:15:19,715
for simple soldiers.

332
00:15:20,195 --> 00:15:24,777
So what we do is we extract the collision edges of all

333
00:15:24,797 --> 00:15:25,517
those meshes.

334
00:15:26,077 --> 00:15:29,058
And all of that is cached in a localized matter in the map.

335
00:15:29,678 --> 00:15:31,598
So the actors really only test the ground.

336
00:15:31,859 --> 00:15:32,819
And they test those edges.

337
00:15:33,039 --> 00:15:33,499
And that's all.

338
00:15:34,144 --> 00:15:35,084
It's a very dull life.

339
00:15:35,544 --> 00:15:38,345
They're not aware of the risks, but they don't care.

340
00:15:38,385 --> 00:15:40,466
They're there to die for you, so we're

341
00:15:40,506 --> 00:15:41,606
not too attached to them.

342
00:15:42,967 --> 00:15:45,167
Third of all, it's awesome, but we needed a

343
00:15:45,207 --> 00:15:46,288
solution for navigation.

344
00:15:47,128 --> 00:15:50,769
And it came clear at the beginning that NavMesh path

345
00:15:50,789 --> 00:15:52,810
finding, in our case, was going to be problematic.

346
00:15:53,090 --> 00:15:55,990
One of the reasons was that our libraries were not

347
00:15:56,291 --> 00:15:59,852
deterministic from the get go, so it was

348
00:15:59,872 --> 00:16:00,532
going to cause issues.

349
00:16:01,052 --> 00:16:03,713
And we had concerns about the CPU costs of all of that.

350
00:16:04,812 --> 00:16:07,194
So our solution was to use what we call nav flows.

351
00:16:07,795 --> 00:16:10,157
They're basically big roads that level designers

352
00:16:10,197 --> 00:16:11,878
and mission designers drawing the maps.

353
00:16:12,683 --> 00:16:13,864
It looks a bit like something like that.

354
00:16:14,724 --> 00:16:17,065
Obviously, it limits the gameplay space of those actors.

355
00:16:17,265 --> 00:16:18,205
They don't go everywhere.

356
00:16:18,505 --> 00:16:21,306
But they really have a defined role in the game.

357
00:16:21,666 --> 00:16:24,627
They're fighting over a certain piece of territory.

358
00:16:25,047 --> 00:16:28,428
So level designers draw those nav flows.

359
00:16:28,808 --> 00:16:30,969
They define which direction the actors should be going.

360
00:16:31,849 --> 00:16:33,610
But they still have parameters that they can

361
00:16:33,650 --> 00:16:35,450
tweak to tweak the AI on those.

362
00:16:36,740 --> 00:16:38,901
So we started to have something that was interesting.

363
00:16:39,122 --> 00:16:40,743
We wanted to see those actors fight

364
00:16:40,823 --> 00:16:43,965
and have some meaningful gameplay in that section.

365
00:16:44,826 --> 00:16:46,607
And our first solution was to start

366
00:16:46,647 --> 00:16:48,629
with a top-down approach to controlling

367
00:16:49,129 --> 00:16:51,591
where every single of those actors should be going.

368
00:16:52,212 --> 00:16:53,953
So you can imagine the formations,

369
00:16:53,993 --> 00:16:57,616
the soldiers are marching together, and having a clash.

370
00:16:58,691 --> 00:17:01,994
But our problem with that is, so on For Honor, we were

371
00:17:02,054 --> 00:17:03,576
extremely gameplay driven.

372
00:17:03,596 --> 00:17:07,819
It was our mantra was follow the fun, and fell faster and

373
00:17:07,839 --> 00:17:08,981
follow the fun, the four Fs.

374
00:17:09,761 --> 00:17:12,264
And we were playing that, and we were not feeling that it

375
00:17:12,304 --> 00:17:13,004
was interesting.

376
00:17:13,024 --> 00:17:17,348
It started to be evident to the players that there were

377
00:17:17,368 --> 00:17:20,631
some higher rules that were happening that were weird

378
00:17:20,671 --> 00:17:22,853
sometimes with the exact positioning.

379
00:17:23,654 --> 00:17:27,616
And also, we were still having the merge issue.

380
00:17:28,517 --> 00:17:32,959
It's a big battlefield, the players kill those guys extremely, extremely fast,

381
00:17:33,039 --> 00:17:35,961
so we need to fill it up as often as possible.

382
00:17:36,541 --> 00:17:41,404
And having those formations, those platoons, and merging them was proving to be...

383
00:17:42,565 --> 00:17:48,887
a daunting task. I'm not saying it's not solvable, but in our case it was causing, it was starting

384
00:17:48,907 --> 00:17:54,689
to be extremely costly, it was not really fun, and it started to be, it was a bit of

385
00:17:54,749 --> 00:17:59,431
a mess. So we took a step back. And our solution, when we think about it, is really simple,

386
00:18:00,011 --> 00:18:04,953
it's flocking. And I'm not even kidding, our first implementations were pretty much that,

387
00:18:05,253 --> 00:18:06,813
they were wandering aimlessly.

388
00:18:07,574 --> 00:18:10,215
But the idea was to find simple rules that would

389
00:18:10,255 --> 00:18:13,337
govern those actors, that when they're going to the center of

390
00:18:13,357 --> 00:18:15,959
the battlefield, so that it started to make

391
00:18:15,999 --> 00:18:16,779
more sense to the player.

392
00:18:17,020 --> 00:18:17,860
The rules are simple.

393
00:18:18,741 --> 00:18:19,721
It's easy to visualize.

394
00:18:19,941 --> 00:18:22,363
And the player started to see that they had an impact on

395
00:18:22,403 --> 00:18:23,124
each of those actors.

396
00:18:24,044 --> 00:18:26,526
So the complexity of those behaviors, they come from the

397
00:18:26,566 --> 00:18:28,467
number of rules that you start adding to them.

398
00:18:29,227 --> 00:18:31,349
By themselves, those rules are not very complicated.

399
00:18:31,789 --> 00:18:34,131
But the more you add, the more you start adding something

400
00:18:34,151 --> 00:18:35,131
that's interesting.

401
00:18:35,897 --> 00:18:38,958
So one of them, for example, was the distance between actors.

402
00:18:39,819 --> 00:18:41,660
When they're traveling to the battle,

403
00:18:42,100 --> 00:18:44,201
the distance between themselves, we allow them to be closer.

404
00:18:44,281 --> 00:18:46,942
But if they fight, we ask them to spread a bit more.

405
00:18:47,642 --> 00:18:50,023
There is this notion centered around the player

406
00:18:50,083 --> 00:18:52,664
that we have that repulsion bubble that increases

407
00:18:52,704 --> 00:18:54,145
and decreases based on his actions.

408
00:18:54,225 --> 00:18:55,926
So they start being afraid of you.

409
00:18:56,566 --> 00:18:57,926
And all of those starting adding up.

410
00:18:58,587 --> 00:19:00,888
And up to one of my favorite.

411
00:19:01,368 --> 00:19:03,968
When the player fights, that bubble increases and decreases,

412
00:19:04,129 --> 00:19:07,049
and the soldiers can move out of the way.

413
00:19:07,849 --> 00:19:10,270
And those rules starting adding up.

414
00:19:10,290 --> 00:19:13,191
So for example, this one, the Moses effect, you start moving,

415
00:19:13,251 --> 00:19:15,351
they move out of the way.

416
00:19:15,891 --> 00:19:17,172
It's always very satisfying.

417
00:19:18,432 --> 00:19:23,833
So all those rules adding over and over, we were like, yay,

418
00:19:23,873 --> 00:19:24,454
that's perfect.

419
00:19:24,894 --> 00:19:25,714
The system works.

420
00:19:25,874 --> 00:19:27,534
Let's give that to the designers so they can start

421
00:19:27,574 --> 00:19:28,375
tweaking those values.

422
00:19:29,296 --> 00:19:30,557
Well, they were not that happy.

423
00:19:31,258 --> 00:19:34,301
So we gave those systems and what was happening?

424
00:19:35,187 --> 00:19:37,989
Whoops, yes, so it's working.

425
00:19:38,349 --> 00:19:40,231
So what was happening is that the,

426
00:19:41,932 --> 00:19:43,053
I need to find my laptop.

427
00:19:43,493 --> 00:19:46,716
So what we wanted was really the end result,

428
00:19:46,736 --> 00:19:50,559
the battlefield in which the player was actually fighting.

429
00:19:51,119 --> 00:19:53,401
But we were getting to that point with very simple rules.

430
00:19:53,882 --> 00:19:55,243
So every time we were changing one,

431
00:19:55,523 --> 00:19:56,604
it could affect the other,

432
00:19:56,884 --> 00:19:59,466
and it's that weird moment that our,

433
00:20:00,167 --> 00:20:01,627
We were creating emergent gameplay,

434
00:20:01,707 --> 00:20:04,308
but our goal was that emergent state.

435
00:20:04,588 --> 00:20:07,469
So it was finding the rules that bring to

436
00:20:07,509 --> 00:20:10,629
that state proved to be a lot of trial and error,

437
00:20:10,729 --> 00:20:12,090
left and right, trying to see what happened.

438
00:20:13,010 --> 00:20:15,211
To quote one of the designer I had a chance to work with,

439
00:20:17,611 --> 00:20:19,232
that's pretty much what she was saying.

440
00:20:20,552 --> 00:20:22,173
She was scared of touching those values.

441
00:20:22,193 --> 00:20:23,833
It was starting to do something weird.

442
00:20:25,373 --> 00:20:26,914
So our solution for that,

443
00:20:27,762 --> 00:20:28,762
was to create presets.

444
00:20:29,503 --> 00:20:30,644
In the end, when we think about it,

445
00:20:30,964 --> 00:20:32,725
the experience of the player in those lanes

446
00:20:32,785 --> 00:20:35,387
and where he's fighting was very pretty fine.

447
00:20:35,488 --> 00:20:37,929
So we wanted something very compact, claustrophobic,

448
00:20:38,050 --> 00:20:40,571
or something more spread out, or something

449
00:20:40,732 --> 00:20:42,353
that we call the scattered one.

450
00:20:43,374 --> 00:20:47,096
So those systems, if you look a bit at how it works.

451
00:20:49,342 --> 00:20:54,286
So we can see a bit of the debug display, all those forces that are applied to every

452
00:20:54,346 --> 00:20:57,808
actor, the soldiers in the back that joined the battle.

453
00:20:58,449 --> 00:21:03,833
Everything was very systemic, it evolved well, it was giving the result that we wanted.

454
00:21:05,201 --> 00:21:08,243
To go back a bit to the scattered part, we all saw

455
00:21:08,263 --> 00:21:08,864
those movies.

456
00:21:09,444 --> 00:21:11,746
I mean, those two armies are crashing into each other.

457
00:21:12,347 --> 00:21:14,168
Then there's that big camera cut and smoke.

458
00:21:14,588 --> 00:21:16,610
And then everybody is mixed up, left and right.

459
00:21:16,690 --> 00:21:19,392
There's a big bunch of battles on each side.

460
00:21:20,193 --> 00:21:23,155
And every time we were trying to get to that point, well, it

461
00:21:23,195 --> 00:21:23,756
wasn't working.

462
00:21:24,116 --> 00:21:26,378
The reality is that when you think about it, the first

463
00:21:26,438 --> 00:21:27,999
layers just started hitting each other.

464
00:21:30,921 --> 00:21:33,704
So it wasn't creating what we really wanted.

465
00:21:34,264 --> 00:21:37,387
So to show the kind of thinking that brought us to there

466
00:21:37,628 --> 00:21:40,790
is that the simple rule that we ended implementing,

467
00:21:40,851 --> 00:21:42,432
that by itself is very complicated,

468
00:21:42,492 --> 00:21:43,993
but that brings us to the proper result,

469
00:21:44,554 --> 00:21:45,355
is something like that.

470
00:21:45,555 --> 00:21:47,537
That we can call the Gentleman Rule.

471
00:21:48,137 --> 00:21:51,080
Which is, if somebody is fighting an actor,

472
00:21:51,160 --> 00:21:54,064
so let's say we have a blue soldier that comes to the battle,

473
00:21:54,624 --> 00:21:56,106
and then the other blue soldier sees,

474
00:21:56,246 --> 00:21:58,188
oh, I'm sorry, you're doing a duel.

475
00:21:58,468 --> 00:22:00,931
He lets him fight, and he goes to find a new target,

476
00:22:01,131 --> 00:22:03,053
which is more appropriate, and starts fighting.

477
00:22:03,594 --> 00:22:06,657
So only that simple rule, when generalized,

478
00:22:06,777 --> 00:22:08,719
brought us to the state that we wanted.

479
00:22:09,400 --> 00:22:11,560
So to give a small example, it gives something like that.

480
00:22:12,261 --> 00:22:13,921
It's extremely messy.

481
00:22:14,441 --> 00:22:17,322
There's a bunch of guys fighting, guys and girls,

482
00:22:17,382 --> 00:22:19,603
fighting left and right on the battlefield.

483
00:22:20,163 --> 00:22:23,884
But finding those small rules was really

484
00:22:24,244 --> 00:22:29,246
one of the challenging parts because of the intricacies

485
00:22:29,306 --> 00:22:31,467
and the interdependence of all of them.

486
00:22:34,908 --> 00:22:35,048
So.

487
00:22:36,214 --> 00:22:38,535
It's fine, we have those soldiers, they go to the battle,

488
00:22:38,595 --> 00:22:40,656
they start fighting, but we still need it to be able

489
00:22:40,696 --> 00:22:41,696
to generate those inputs.

490
00:22:42,336 --> 00:22:43,877
So Frederic mentioned at the beginning

491
00:22:43,977 --> 00:22:45,957
that we use the same character pipeline

492
00:22:45,997 --> 00:22:47,918
for every single of our actors,

493
00:22:48,358 --> 00:22:50,139
and it's the same thing for the small soldiers.

494
00:22:50,739 --> 00:22:52,520
So this is really great for animators.

495
00:22:52,740 --> 00:22:56,801
They can take the small soldier and start using with them.

496
00:22:58,902 --> 00:23:00,663
But it's not really interesting for the player,

497
00:23:01,163 --> 00:23:02,903
or maybe it's DLC character announced.

498
00:23:05,543 --> 00:23:08,005
And this is really a great tool for animators,

499
00:23:08,065 --> 00:23:12,007
because they don't rely on setups from the AI programmers

500
00:23:12,227 --> 00:23:14,529
or AI designers to test something.

501
00:23:14,849 --> 00:23:16,750
They can build the animation.

502
00:23:16,790 --> 00:23:19,492
They can look and control the movement, see what's happening.

503
00:23:19,572 --> 00:23:22,934
So it made them extremely independent from us.

504
00:23:23,615 --> 00:23:24,956
Not that they don't like to talk to us, but.

505
00:23:26,675 --> 00:23:33,198
So the way that we use to generate those inputs is that we have an implementation of our beaver trees inside the simulation.

506
00:23:34,258 --> 00:23:36,720
It's not extremely complex, but it does a good job.

507
00:23:37,960 --> 00:23:42,562
So you can see actually that the beaver trees that we have right now in the game are extremely simple.

508
00:23:42,582 --> 00:23:46,044
It's different rhythms of attack depending on the distance of the target.

509
00:23:46,887 --> 00:23:52,108
But what's interesting is that we developed the tools that enable designers to actually

510
00:23:52,128 --> 00:23:57,590
debug what was happening and see and control the rhythm and the difficulty.

511
00:23:58,290 --> 00:24:00,431
This can also be applied to any other actor.

512
00:24:00,771 --> 00:24:04,592
This is one of the other actors that we have in the game that uses the deterministic system.

513
00:24:05,093 --> 00:24:05,973
We call them captains.

514
00:24:06,753 --> 00:24:13,155
The trees started to be a bit more complex, but it's still not like our bigger fighters

515
00:24:13,175 --> 00:24:16,536
It's going to come later, but it started to prove interesting.

516
00:24:17,886 --> 00:24:21,048
So our behavior trees by themselves are nodes.

517
00:24:21,569 --> 00:24:23,090
They're the one that are actually generating the

518
00:24:23,130 --> 00:24:24,331
inputs when it runs.

519
00:24:24,771 --> 00:24:27,193
Really, the output of those nodes is it creates a

520
00:24:27,233 --> 00:24:28,794
structure that are the inputs.

521
00:24:30,235 --> 00:24:31,255
Is the character attacking?

522
00:24:31,296 --> 00:24:31,876
Is he moving?

523
00:24:31,936 --> 00:24:32,496
Is he dodging?

524
00:24:33,317 --> 00:24:36,499
And the conditions that the designers can put in place and

525
00:24:36,619 --> 00:24:40,682
hooks that enable the actors to influence the environment.

526
00:24:40,942 --> 00:24:42,483
They're basically events.

527
00:24:43,484 --> 00:24:46,885
So our experience of using the EverTrees inside the simulation

528
00:24:47,445 --> 00:24:50,746
was a mixed one, in the sense that it was extremely powerful

529
00:24:50,846 --> 00:24:51,626
for prototyping.

530
00:24:52,246 --> 00:24:55,246
Designers could come with quick ways of testing gameplay,

531
00:24:55,306 --> 00:24:56,187
see what was working.

532
00:24:56,847 --> 00:25:00,688
But we ended up often to, once that system was validated

533
00:25:00,828 --> 00:25:02,548
on a gameplay level, we needed to extract

534
00:25:02,568 --> 00:25:05,148
those functionalities and then implement them as services.

535
00:25:05,609 --> 00:25:06,509
So we had a lot of

536
00:25:08,169 --> 00:25:10,370
analyzing what we wanted to do, strip them out.

537
00:25:10,410 --> 00:25:13,271
So it was a really good way to iterate quickly.

538
00:25:14,111 --> 00:25:16,852
But CPU-wise, it was costing too much.

539
00:25:17,313 --> 00:25:20,934
So we needed to extract the logic of those

540
00:25:20,994 --> 00:25:22,174
and put them in separated nodes.

541
00:25:23,275 --> 00:25:24,895
So you saw the actors.

542
00:25:24,916 --> 00:25:26,516
We have a living battlefield.

543
00:25:27,016 --> 00:25:28,237
But then on the other part, there's

544
00:25:28,257 --> 00:25:29,537
still heroes that needed to fight.

545
00:25:30,057 --> 00:25:30,898
That's Fred's part.

546
00:25:31,658 --> 00:25:33,319
Thank you, Xavier.

547
00:25:33,959 --> 00:25:35,099
So can you hear me?

548
00:25:35,199 --> 00:25:35,339
Yeah.

549
00:25:35,359 --> 00:25:36,940
Can you hear me?

550
00:25:36,960 --> 00:25:37,040
Yeah.

551
00:25:41,053 --> 00:25:41,613
Yeah, it's OK?

552
00:25:41,754 --> 00:25:43,255
Yeah, good.

553
00:25:43,335 --> 00:25:46,839
So yes, we have, with the Deterministic AI,

554
00:25:46,959 --> 00:25:50,643
we have a battlefield with a lot of character inside it.

555
00:25:51,184 --> 00:25:53,426
You are able to go and play with the system.

556
00:25:53,906 --> 00:25:57,170
But we wanted to also bring challenges to the player.

557
00:25:59,061 --> 00:26:01,943
It was meant to be a PvP game.

558
00:26:02,003 --> 00:26:04,084
It was meant to have a PvP experience inside it.

559
00:26:04,484 --> 00:26:07,547
So we needed ways to control as well the heroes,

560
00:26:07,747 --> 00:26:10,909
the kind of characters the player is able to play.

561
00:26:11,529 --> 00:26:15,212
So we tried to create a system

562
00:26:15,252 --> 00:26:18,074
to handle this kind of challenge.

563
00:26:18,594 --> 00:26:20,676
So why do we need another AI system for it?

564
00:26:21,096 --> 00:26:23,698
First of all, we have NaFlu in the map

565
00:26:23,718 --> 00:26:24,879
for the deterministic AI system,

566
00:26:24,919 --> 00:26:27,020
but if the player go out of it,

567
00:26:28,799 --> 00:26:29,419
we can't do anything.

568
00:26:29,799 --> 00:26:32,781
So we needed to have a way to be able to chase the player

569
00:26:33,081 --> 00:26:33,741
everywhere in the map.

570
00:26:34,482 --> 00:26:36,403
Also, we want to have this cool moment,

571
00:26:36,483 --> 00:26:37,504
like you can see in the picture,

572
00:26:37,544 --> 00:26:39,245
where you grab the player on your shoulder

573
00:26:39,305 --> 00:26:40,405
and you throw him into spikes.

574
00:26:40,886 --> 00:26:42,807
So we needed to have a more,

575
00:26:44,288 --> 00:26:47,069
a better understanding of what is your environment,

576
00:26:47,169 --> 00:26:49,531
what do you have around your hero.

577
00:26:51,661 --> 00:26:59,789
We needed also better reactivity, 300 milliseconds to update your AI, it's a bit slow and if

578
00:26:59,849 --> 00:27:04,133
your player is just in front of you and you have to react to it, it can be problematic.

579
00:27:04,789 --> 00:27:09,994
And one important aspect is that we wanted the AI to control the same kind of character.

580
00:27:10,154 --> 00:27:16,600
We didn't want it to add, because it's a bot, to add 10,000 HP so that the player had to

581
00:27:16,620 --> 00:27:18,982
just attack him all over again to be able to kill him.

582
00:27:19,383 --> 00:27:24,187
So we needed to base the difficulty on the skill and not on the statistic of the character.

583
00:27:25,434 --> 00:27:28,735
So if we look back to how do we control the character,

584
00:27:28,755 --> 00:27:31,616
the player for the player, we get the pad,

585
00:27:31,636 --> 00:27:33,657
we generate input, send them into the simulation.

586
00:27:34,057 --> 00:27:38,239
So for the replicated AI system for the bots,

587
00:27:38,739 --> 00:27:40,000
the AI will generate inputs.

588
00:27:40,200 --> 00:27:42,341
So it will generate the inputs on one machine

589
00:27:42,721 --> 00:27:44,042
and send them over the network.

590
00:27:46,683 --> 00:27:48,484
Here we have an interesting system.

591
00:27:49,325 --> 00:27:53,747
Since we are working with a deterministic simulation,

592
00:27:53,787 --> 00:27:55,307
so what does it give us?

593
00:27:55,888 --> 00:27:57,728
Basically, it gives us that we don't

594
00:27:57,768 --> 00:28:01,950
need to predict the state of the replicated characters

595
00:28:03,051 --> 00:28:04,391
of the other players, for example,

596
00:28:04,871 --> 00:28:06,432
because the simulation does it for us.

597
00:28:06,912 --> 00:28:10,614
In fact, in the simulation, if you look at the current state,

598
00:28:11,034 --> 00:28:12,575
you have, in fact, the latest updated

599
00:28:12,615 --> 00:28:13,715
version of your character.

600
00:28:14,469 --> 00:28:16,990
And if you receive an input and a rewind happens,

601
00:28:17,170 --> 00:28:19,010
it will be updated and you will be fine.

602
00:28:19,810 --> 00:28:23,651
So of course, what happens if you have a rewind?

603
00:28:23,751 --> 00:28:25,791
The state of the world can change.

604
00:28:26,351 --> 00:28:28,292
So we discussed with the designer,

605
00:28:28,392 --> 00:28:31,332
and we decided that we didn't want to consider the rewind.

606
00:28:31,512 --> 00:28:34,193
Because most of the time, a rewind happens,

607
00:28:34,253 --> 00:28:36,893
but it can be on another place on the battlefield.

608
00:28:37,393 --> 00:28:40,454
It doesn't really necessarily affect the fights

609
00:28:40,514 --> 00:28:41,534
that you are currently doing.

610
00:28:42,437 --> 00:28:47,321
And but if it happens that it affects the fights that you are currently doing,

611
00:28:48,721 --> 00:28:54,225
we, the only thing that you have to do is just check your current world state and change the

612
00:28:54,265 --> 00:29:00,409
decision of the AI. So for a certain amount of time, when you fight against someone who is

613
00:29:00,449 --> 00:29:05,913
controlled by another machine, you can take wrong decisions. But we decided that it was okay because

614
00:29:06,413 --> 00:29:10,656
as soon as you will receive the real state where you are, we'll just update.

615
00:29:11,129 --> 00:29:14,012
and take new decisions for the AI.

616
00:29:14,192 --> 00:29:15,974
And also, one really important aspect

617
00:29:16,034 --> 00:29:18,376
is that since we are updated outside of the simulation,

618
00:29:18,796 --> 00:29:20,678
we are updated only once per frame.

619
00:29:21,018 --> 00:29:25,442
If a rewind happens, it doesn't affect the replicated AI

620
00:29:25,482 --> 00:29:25,783
system.

621
00:29:26,223 --> 00:29:28,385
So we have more CPU than the sims.

622
00:29:30,727 --> 00:29:35,431
So for the system, we built a lot of elements.

623
00:29:36,062 --> 00:29:41,384
First one is the team strategies that will analyze the battlefield and try to assign

624
00:29:41,444 --> 00:29:45,906
tasks to the characters to spread them and try to win the game.

625
00:29:46,387 --> 00:29:53,170
Then each actor will have to try to accomplish this task and you have a lot of services to

626
00:29:53,250 --> 00:29:54,951
fight, to navigate and that kind of stuff.

627
00:29:55,351 --> 00:30:00,653
But in the end, what we want is to generate inputs for Katana to control the character.

628
00:30:01,288 --> 00:30:03,449
So in this talk, we will mainly focus on the fight service

629
00:30:03,889 --> 00:30:07,310
and the inputs, because that's really

630
00:30:07,350 --> 00:30:08,550
a specific aspect of Forerunner.

631
00:30:08,970 --> 00:30:11,871
Maybe next year, our colleague will

632
00:30:12,632 --> 00:30:15,032
want to give you more information

633
00:30:15,092 --> 00:30:16,333
about the other systems.

634
00:30:17,693 --> 00:30:21,594
So if we look at Katana, so the way we control the characters,

635
00:30:22,615 --> 00:30:23,775
basically, it's a state machine.

636
00:30:23,875 --> 00:30:26,976
So if we want to control the character, what we want,

637
00:30:27,136 --> 00:30:30,037
really, is to control what happens into the state machine.

638
00:30:30,612 --> 00:30:38,142
what are the state, what are the transitions that we do in this, what is the execution

639
00:30:38,222 --> 00:30:38,943
of your state machine.

640
00:30:39,864 --> 00:30:42,046
But the main issue we have is that we

641
00:30:42,086 --> 00:30:43,807
have 12 different characters.

642
00:30:44,688 --> 00:30:47,290
All 12 characters have a unique state machine

643
00:30:47,871 --> 00:30:49,452
that defines their gameplay.

644
00:30:50,112 --> 00:30:56,577
And also, this data was edited by designers.

645
00:30:56,938 --> 00:31:00,521
So they were able to submit and make changes every day.

646
00:31:01,081 --> 00:31:04,464
So it was really problematic for the AI to be always up to date.

647
00:31:04,664 --> 00:31:07,706
So we decided to automatically extract information

648
00:31:07,866 --> 00:31:08,787
from this data.

649
00:31:09,932 --> 00:31:13,514
So we have two aspects that we extract automatically.

650
00:31:14,354 --> 00:31:16,315
The first one is standard information.

651
00:31:16,475 --> 00:31:19,116
So what kind of attack are you able to do?

652
00:31:19,757 --> 00:31:21,417
Are you able to charge your attacks?

653
00:31:21,758 --> 00:31:23,418
Can you feint your attack?

654
00:31:24,159 --> 00:31:25,799
What are the ranges, the timings,

655
00:31:26,119 --> 00:31:28,340
and do you have special properties?

656
00:31:28,521 --> 00:31:30,662
Like, for example, as you can see on the pictures,

657
00:31:31,142 --> 00:31:32,262
you have on the left an assassin,

658
00:31:32,702 --> 00:31:35,764
which doesn't have some defense when he's idle.

659
00:31:36,224 --> 00:31:37,364
And on the right, you have a tank

660
00:31:37,384 --> 00:31:39,105
that has some defense when he's idle.

661
00:31:40,439 --> 00:31:44,822
So to be able to extract this kind of information,

662
00:31:45,803 --> 00:31:47,824
we discussed with the character designers,

663
00:31:48,024 --> 00:31:49,745
and we were able to define standards.

664
00:31:50,786 --> 00:31:54,648
And so it means that they built all the characters,

665
00:31:54,788 --> 00:31:57,650
all this standard information in the characters

666
00:31:58,391 --> 00:31:59,691
with the same kind of patterns.

667
00:31:59,891 --> 00:32:04,695
So the algorithm was able to extract and locate

668
00:32:04,715 --> 00:32:06,396
these patterns inside the state machine

669
00:32:06,716 --> 00:32:08,357
and extract the information for the AI.

670
00:32:09,538 --> 00:32:09,698
But.

671
00:32:10,332 --> 00:32:13,335
You have always combos and unique abilities,

672
00:32:13,535 --> 00:32:17,279
unique actions that define and give the flavor

673
00:32:17,419 --> 00:32:18,040
to your character.

674
00:32:18,480 --> 00:32:22,144
So you can see that, for example, we have an ability

675
00:32:22,284 --> 00:32:22,925
which looks like this.

676
00:32:23,765 --> 00:32:24,867
The content's not really important,

677
00:32:24,887 --> 00:32:26,168
it's like more of the structure.

678
00:32:26,788 --> 00:32:30,752
And what we want for the bot is to go to this state.

679
00:32:30,912 --> 00:32:33,015
This state represents, for example, the end of the attack.

680
00:32:33,991 --> 00:32:35,131
But how can we do that?

681
00:32:35,612 --> 00:32:39,154
Basically, what we want is to be able to extract

682
00:32:39,695 --> 00:32:41,336
the path into the state machine.

683
00:32:41,756 --> 00:32:43,958
So we go into the branching between the states,

684
00:32:44,438 --> 00:32:47,280
we look at the condition, and we try to extract

685
00:32:47,581 --> 00:32:50,443
what kind of inputs, what are the elements

686
00:32:50,483 --> 00:32:53,985
that will allow the character to fulfill the condition

687
00:32:54,366 --> 00:32:57,168
and thus trigger the branching.

688
00:32:57,588 --> 00:32:59,049
So we do that for all the states

689
00:32:59,489 --> 00:33:02,231
until we go to the root of the ability.

690
00:33:04,014 --> 00:33:08,198
So to be able to do that, it was in fact pretty simple.

691
00:33:08,718 --> 00:33:12,141
We needed to find a way to give information to the algorithm

692
00:33:12,302 --> 00:33:15,024
to say I want to reach this specific state.

693
00:33:15,545 --> 00:33:19,348
So in fact, it's some data that the character designer

694
00:33:20,389 --> 00:33:22,531
have to put directly inside the data.

695
00:33:23,112 --> 00:33:24,213
And that's it.

696
00:33:24,393 --> 00:33:25,975
We are able to locate them.

697
00:33:26,505 --> 00:33:28,225
And in fact, since they know their characters,

698
00:33:28,265 --> 00:33:30,966
they are able to define, OK, this

699
00:33:31,006 --> 00:33:32,606
is a special ability of my character,

700
00:33:33,147 --> 00:33:36,127
and I want to be sure that the AI is able to do it.

701
00:33:38,708 --> 00:33:42,389
So with that, we have all the knowledge of our character.

702
00:33:42,829 --> 00:33:45,930
We know how to control it, but we

703
00:33:45,970 --> 00:33:49,311
have to get this information and bring it to the AI.

704
00:33:49,970 --> 00:33:54,794
So we decided to create simple elements that we call fight actions

705
00:33:55,375 --> 00:33:58,477
that are able to perform one specific action.

706
00:33:59,018 --> 00:34:02,341
So for example, we have a fight action for the block,

707
00:34:02,621 --> 00:34:06,164
one for the attack, the dodge, guard breaks and stuff like that.

708
00:34:06,624 --> 00:34:09,887
And we have also one that is able to play an input pass,

709
00:34:10,027 --> 00:34:12,869
so the pass that we have extracted with the algorithm.

710
00:34:13,867 --> 00:34:17,389
One important aspect of it is that all these blocks,

711
00:34:17,709 --> 00:34:20,050
all these fight actions are character agnostic.

712
00:34:20,430 --> 00:34:23,512
There is no code that say, for the Viking assassin,

713
00:34:24,512 --> 00:34:25,733
in this specific condition,

714
00:34:25,813 --> 00:34:28,234
you have to do this kind of stuff.

715
00:34:29,275 --> 00:34:31,956
So they only use the auto-extracted data.

716
00:34:32,136 --> 00:34:34,137
It's way easier, way easier to debug.

717
00:34:34,957 --> 00:34:36,618
It was really a good thing.

718
00:34:37,298 --> 00:34:38,879
So if we take a look at one example,

719
00:34:40,580 --> 00:34:44,123
We'll just look at a block of the attack.

720
00:34:44,163 --> 00:34:45,865
So on the left, you have a player.

721
00:34:46,005 --> 00:34:48,507
He will attack the bot, and the bot

722
00:34:48,547 --> 00:34:49,848
will try to defend himself.

723
00:34:53,392 --> 00:34:57,495
So it's pretty simple, but how do we do that in the game?

724
00:34:58,817 --> 00:35:03,361
So first of all, we need to be able to detect that the bot is

725
00:35:03,921 --> 00:35:04,802
attacked by the player.

726
00:35:05,547 --> 00:35:10,588
Then at runtime, we go inside the katana graph of the player,

727
00:35:10,988 --> 00:35:13,129
and we're able to detect that, OK, he's attacking,

728
00:35:13,309 --> 00:35:15,409
and we know when will be the hit time.

729
00:35:16,389 --> 00:35:19,390
After that, we go inside the extracted information

730
00:35:19,410 --> 00:35:22,691
for the bot, and we get the defense duration

731
00:35:22,951 --> 00:35:25,871
of this character and the delay to trigger,

732
00:35:25,951 --> 00:35:29,372
to activate this defense when we send the input.

733
00:35:30,093 --> 00:35:34,677
And the only remaining part is just to be sure that we will have some defense when it

734
00:35:34,717 --> 00:35:36,920
occurs so that we can block the attack.

735
00:35:37,920 --> 00:35:40,303
So we do that for all these kind of actions.

736
00:35:40,823 --> 00:35:47,029
Most of them are really pretty simple, but we are able to combine them.

737
00:35:47,710 --> 00:35:52,694
But yeah, we wanted, so now we are able to do all the small elements.

738
00:35:53,908 --> 00:35:56,731
But we have two needs in our game.

739
00:35:57,171 --> 00:35:58,212
First of all is PvP.

740
00:35:59,273 --> 00:36:03,216
In PvP we want to replace players, we want to have unpredictable fighters,

741
00:36:03,556 --> 00:36:07,320
that when a player will face an opponent, he will not...

742
00:36:09,027 --> 00:36:12,289
We will not recognize pattern in it, but in PvE it's different.

743
00:36:12,709 --> 00:36:14,490
We wanted to be able to teach the game.

744
00:36:14,510 --> 00:36:23,275
We wanted to create some elements that will help the player learn the mechanics and try

745
00:36:23,315 --> 00:36:29,419
different things and try to find what is the best option against special abilities and

746
00:36:29,439 --> 00:36:29,840
stuff like that.

747
00:36:30,320 --> 00:36:32,802
So these kind of characters are more pattern-based,

748
00:36:33,222 --> 00:36:35,944
and we also had a few bosses in the game

749
00:36:36,584 --> 00:36:38,526
with multiple stages and stuff like that.

750
00:36:39,166 --> 00:36:42,428
So we decided to, yeah, our solution

751
00:36:42,448 --> 00:36:43,950
to create this kind of factor was

752
00:36:43,990 --> 00:36:48,813
to create a kind of database of all the moves, all the actions

753
00:36:49,313 --> 00:36:51,155
so the bot will be able to perform.

754
00:36:51,998 --> 00:36:54,738
So if we look at the editor, as you can see,

755
00:36:55,178 --> 00:36:57,339
it looks like Katana, but it's another one.

756
00:36:57,639 --> 00:37:00,059
We were able to reuse a lot of elements.

757
00:37:00,159 --> 00:37:02,240
That's why it looks almost the same.

758
00:37:02,880 --> 00:37:04,980
But so we have three main elements.

759
00:37:05,300 --> 00:37:07,601
On the right, it's what we call the action graph.

760
00:37:07,841 --> 00:37:11,742
So we put all the fight action blocks together.

761
00:37:12,082 --> 00:37:13,862
We are able to create branching between them,

762
00:37:14,142 --> 00:37:17,943
set up conditions that allow to activate this branching.

763
00:37:19,536 --> 00:37:21,557
On the left, you have the decision tree parts.

764
00:37:22,337 --> 00:37:25,318
It's where you will create a tree structure

765
00:37:25,358 --> 00:37:27,339
that will contain all the action graph.

766
00:37:27,499 --> 00:37:32,200
So all the leaf of the tree contain an action graph

767
00:37:32,380 --> 00:37:36,082
and in fact is an action that you are able to perform.

768
00:37:36,702 --> 00:37:39,283
And we have conditions, filters, cool down

769
00:37:39,643 --> 00:37:42,944
that allow you to define what branches of your tree

770
00:37:43,084 --> 00:37:45,365
are available at a specific moment.

771
00:37:46,593 --> 00:37:48,775
So how does it look at runtime?

772
00:37:49,756 --> 00:37:51,899
Basically, we do a query inside this database

773
00:37:51,999 --> 00:37:54,982
every frame, which can be problematic.

774
00:37:55,383 --> 00:37:56,884
So we can optimize.

775
00:37:57,024 --> 00:38:00,068
We did some stuff to be able to be sure

776
00:38:00,108 --> 00:38:02,330
that it's not a big deal.

777
00:38:02,410 --> 00:38:05,814
So the first thing is that we pre-compute everything.

778
00:38:06,274 --> 00:38:08,815
We noticed that most of the conditions are duplicated.

779
00:38:09,215 --> 00:38:11,817
So instead of computing your information

780
00:38:11,877 --> 00:38:14,618
into your condition, what we did is

781
00:38:15,158 --> 00:38:16,839
that we compute the information before.

782
00:38:16,959 --> 00:38:20,080
And in the condition, you have only to just check a value.

783
00:38:20,500 --> 00:38:22,101
It's really, really easy.

784
00:38:23,081 --> 00:38:25,282
After that, since we use a tree structure,

785
00:38:26,143 --> 00:38:30,044
if the designer organizes well the condition and the branches,

786
00:38:30,724 --> 00:38:33,326
we are able to have a good early out.

787
00:38:34,866 --> 00:38:35,406
And also

788
00:38:36,192 --> 00:38:37,472
we are able to do partial queries.

789
00:38:37,752 --> 00:38:41,033
Basically, when the bot is fighting,

790
00:38:41,293 --> 00:38:43,154
when it's performing a specific action,

791
00:38:43,174 --> 00:38:47,255
it's performing, it's doing an action graph.

792
00:38:47,455 --> 00:38:49,696
So we have, we define a priority for it,

793
00:38:50,276 --> 00:38:53,137
and we can trim and remove in the query

794
00:38:53,537 --> 00:38:56,738
all the elements that are less important in the tree.

795
00:38:56,818 --> 00:38:58,358
So in fact, most of the time,

796
00:38:58,418 --> 00:39:02,559
you just look at a few parts,

797
00:39:02,860 --> 00:39:05,380
a really small amount of branches in your tree.

798
00:39:06,557 --> 00:39:10,080
So if we take a look at one example, so on the left,

799
00:39:10,300 --> 00:39:14,423
you can see the bot editor at runtime.

800
00:39:14,883 --> 00:39:17,205
And on the right, you have the player in blue

801
00:39:17,385 --> 00:39:19,306
and the bot in orange.

802
00:39:19,927 --> 00:39:23,489
And the bot will try to defend himself and attack.

803
00:39:24,310 --> 00:39:28,053
And you can see on the bottom, the condition,

804
00:39:28,173 --> 00:39:30,935
they are highlighted in green and red

805
00:39:31,175 --> 00:39:32,396
when the condition are met or not.

806
00:39:33,136 --> 00:39:37,258
So it was really powerful to help the designer understand what is happening.

807
00:39:37,278 --> 00:39:47,221
He's doing a pretty good job.

808
00:39:50,142 --> 00:39:50,282
But...

809
00:39:51,323 --> 00:39:52,823
So, right now we have...

810
00:39:53,483 --> 00:39:56,444
The designer was able to create all these fighters, but...

811
00:39:57,005 --> 00:39:58,885
How can we...

812
00:39:59,245 --> 00:40:00,486
But we have to use them in PvP.

813
00:40:01,217 --> 00:40:03,360
So if we take a look at one simple example,

814
00:40:04,141 --> 00:40:05,142
we have six players.

815
00:40:06,063 --> 00:40:09,026
The matchmaking, they want to play a game where

816
00:40:09,066 --> 00:40:11,009
you have two teams, two teams of four players.

817
00:40:11,409 --> 00:40:14,973
The matchmaking will balance all the players.

818
00:40:15,294 --> 00:40:16,615
So you know that your team are balanced,

819
00:40:16,735 --> 00:40:19,579
but you have one missing guy in each team.

820
00:40:20,079 --> 00:40:22,081
So you need to add a bot in each team.

821
00:40:23,584 --> 00:40:26,427
But what kind of bot do you choose?

822
00:40:27,368 --> 00:40:30,392
You don't want to introduce an advantage to one team

823
00:40:30,532 --> 00:40:34,557
by choosing a fighter which is way too hard

824
00:40:35,438 --> 00:40:39,783
and select two bots that don't have the same difficulty.

825
00:40:40,744 --> 00:40:40,844
And

826
00:40:41,910 --> 00:40:45,132
In fact, in the game, we created three difficulty levels

827
00:40:45,992 --> 00:40:49,034
from rank one to rank three.

828
00:40:49,414 --> 00:40:51,835
So how can you be sure that your difficulty looks

829
00:40:51,875 --> 00:40:52,515
something like this?

830
00:40:53,196 --> 00:40:57,418
All the rank one are at the same level, approximately.

831
00:40:57,958 --> 00:41:02,740
And they are less hard than the rank two.

832
00:41:03,261 --> 00:41:05,742
And the rank three are better than everyone else.

833
00:41:07,582 --> 00:41:12,367
How can you guarantee that you have your difficulties almost homogeneous?

834
00:41:14,489 --> 00:41:18,814
In fact, we ended up wanting to validate the EI.

835
00:41:20,112 --> 00:41:24,654
But we have 12 characters, we have three difficulty levels,

836
00:41:25,274 --> 00:41:26,594
it means that we have too many matchups

837
00:41:26,854 --> 00:41:27,675
that we want to test.

838
00:41:28,295 --> 00:41:31,736
And most of the time when we had meetings

839
00:41:31,796 --> 00:41:34,397
with designers, testers, directors,

840
00:41:34,937 --> 00:41:38,158
and we were fighting against a specific bot,

841
00:41:38,378 --> 00:41:39,359
and everyone was saying,

842
00:41:39,459 --> 00:41:42,120
oh yeah, I feel this guy is easy,

843
00:41:42,620 --> 00:41:43,840
I feel he's hard, but...

844
00:41:45,635 --> 00:41:47,035
It was only feeling, not science.

845
00:41:47,515 --> 00:41:52,097
So we decided to implement automatic duels between the bots

846
00:41:52,297 --> 00:41:53,257
and we tracked the results.

847
00:41:53,657 --> 00:41:54,937
So it's very simple.

848
00:41:55,058 --> 00:41:56,058
You set up an arena.

849
00:41:56,378 --> 00:41:59,399
You put two fighters against each other.

850
00:41:59,839 --> 00:42:02,900
And as soon as there is one dead, you have your results.

851
00:42:04,980 --> 00:42:08,741
So the usage was really, really cool.

852
00:42:08,761 --> 00:42:11,002
We were able to play more than 250 duels.

853
00:42:13,066 --> 00:42:15,347
each night on one PC.

854
00:42:15,987 --> 00:42:19,648
And the goal was to reach a pretty fine win ratio

855
00:42:19,708 --> 00:42:22,108
because an assassin, for example,

856
00:42:23,709 --> 00:42:26,389
should win more easily against a tank.

857
00:42:26,829 --> 00:42:31,511
So you don't need to aim to a 50% ratio

858
00:42:31,571 --> 00:42:32,471
for all your characters.

859
00:42:33,731 --> 00:42:35,512
But it's not a silver bullet

860
00:42:35,712 --> 00:42:38,092
because if you have two bots that are broken,

861
00:42:39,040 --> 00:42:40,401
the result doesn't make any sense.

862
00:42:40,761 --> 00:42:43,163
You need to be sure that you have one bot at least

863
00:42:43,283 --> 00:42:46,566
that represents exactly the level of difficulties

864
00:42:46,666 --> 00:42:48,987
that you want for a specific rank.

865
00:42:49,388 --> 00:42:50,909
And after that, you are able to compare it

866
00:42:51,309 --> 00:42:53,351
with others and so on.

867
00:42:53,791 --> 00:42:57,554
So it's mainly to detect high-level anomalies,

868
00:42:57,574 --> 00:43:01,017
but we were able to use it in that way.

869
00:43:02,405 --> 00:43:04,406
So that's it for the replicated AI.

870
00:43:04,767 --> 00:43:06,407
We'll try to share a few takeaways

871
00:43:07,368 --> 00:43:09,109
about all this process.

872
00:43:10,249 --> 00:43:11,810
So we use the input-driven approach.

873
00:43:12,591 --> 00:43:13,311
Was it worth it?

874
00:43:14,391 --> 00:43:14,932
Basically, yes.

875
00:43:16,352 --> 00:43:18,714
In fact, we were able to share all the player

876
00:43:19,214 --> 00:43:20,354
improvements and testing.

877
00:43:22,327 --> 00:43:29,729
We have on For Honor a team of testers that is fully dedicated to test the characters.

878
00:43:30,289 --> 00:43:33,730
And they do that by just playing with the characters.

879
00:43:34,210 --> 00:43:40,492
And on the AI side, we are sure that the characters are well tested and well...

880
00:43:41,623 --> 00:43:46,746
Well, in fact, if we send an input to the character,

881
00:43:46,846 --> 00:43:49,448
it will do exactly what we wanted him to do.

882
00:43:49,828 --> 00:43:53,030
So mostly, when we had the bugs, when

883
00:43:53,070 --> 00:43:54,811
a bot wasn't able to perform something,

884
00:43:54,931 --> 00:43:57,993
it was on the AI side that the input that was sent

885
00:43:58,073 --> 00:43:58,773
was not a good one.

886
00:43:59,534 --> 00:44:05,120
Also, as Xavier mentioned, it allows the user, the animators, the designers, to prototype

887
00:44:05,200 --> 00:44:05,741
really easily.

888
00:44:05,761 --> 00:44:10,266
They were able to spawn an elephant, for example, and just play with him with the pad.

889
00:44:10,607 --> 00:44:15,633
So it was no need of any programmer for that, which is a really good thing because programmers

890
00:44:15,653 --> 00:44:16,774
can be a bottleneck sometimes.

891
00:44:19,560 --> 00:44:22,702
And also it was really lightweight for the networking.

892
00:44:23,362 --> 00:44:26,784
And one interesting thing is that since we

893
00:44:26,844 --> 00:44:29,186
use the same pipeline, the AI can't cheat.

894
00:44:29,386 --> 00:44:30,306
It's not possible.

895
00:44:30,807 --> 00:44:33,248
The AI can only send input, like the player.

896
00:44:33,948 --> 00:44:36,790
And so if the player can do something, the AI can do it.

897
00:44:37,210 --> 00:44:41,073
And if the player can't do something, the AI can't do it.

898
00:44:41,669 --> 00:44:45,554
So for a multiplayer game, it's important

899
00:44:45,634 --> 00:44:51,061
so that you know that when you are in PvP,

900
00:44:52,082 --> 00:44:54,164
your AI can't cheat.

901
00:44:54,224 --> 00:44:54,785
It's important.

902
00:44:56,928 --> 00:44:59,571
So we used also a lot of data driven, as you were.

903
00:45:00,149 --> 00:45:06,494
As we explained, the Bivy trees on the left, on the top right you have Katana, on the bottom

904
00:45:06,554 --> 00:45:09,497
right you have the bot editor.

905
00:45:09,837 --> 00:45:10,738
Was it really worth it?

906
00:45:11,879 --> 00:45:12,079
Yes.

907
00:45:13,000 --> 00:45:17,624
Basically, the designers were really autonomous.

908
00:45:19,159 --> 00:45:22,621
as the owner of the future of the fighters of the characters

909
00:45:22,741 --> 00:45:26,202
of anything it was really really important for us and

910
00:45:27,003 --> 00:45:30,404
but also and we were able to create a lot of characters we

911
00:45:30,444 --> 00:45:35,867
have so 12 characters at lunch. In the game we have I think and

912
00:45:36,087 --> 00:45:39,529
100 of 4 different kind of fighters of a I fight those

913
00:45:39,549 --> 00:45:43,611
that can go to take control of these characters.

914
00:45:44,371 --> 00:45:47,553
It's really important to us to give them great tools you you

915
00:45:47,593 --> 00:45:47,973
can just.

916
00:45:48,644 --> 00:45:51,385
give them, like as Xavier mentioned,

917
00:45:51,745 --> 00:45:55,625
a list of properties to set, and that's it.

918
00:45:55,886 --> 00:45:59,286
You need to be able to give them good visualization,

919
00:45:59,486 --> 00:46:01,627
you need to give them debug tools,

920
00:46:01,827 --> 00:46:03,367
a way to understand what's happening,

921
00:46:03,867 --> 00:46:05,187
so that they are able to isolate

922
00:46:05,247 --> 00:46:07,008
when they have problems and bugs,

923
00:46:07,448 --> 00:46:09,608
and they are able to isolate, understand what is happening,

924
00:46:09,708 --> 00:46:11,089
and after that they come to see you,

925
00:46:11,169 --> 00:46:13,049
and that's because maybe there is a bug inside.

926
00:46:14,740 --> 00:46:17,383
And then the other side, working with a simulation,

927
00:46:17,403 --> 00:46:20,426
I mean it's been five years in total, and for Honor.

928
00:46:20,907 --> 00:46:21,387
What was it?

929
00:46:21,608 --> 00:46:22,368
Was it a good idea?

930
00:46:22,388 --> 00:46:23,129
Did it work?

931
00:46:23,790 --> 00:46:26,032
And it's been a daunting task.

932
00:46:26,072 --> 00:46:26,713
We learned a lot.

933
00:46:26,933 --> 00:46:30,297
But the advantages of having something

934
00:46:30,397 --> 00:46:33,460
that you don't need to think.

935
00:46:33,980 --> 00:46:36,661
Basically, programmers that are working the simulation,

936
00:46:36,681 --> 00:46:39,682
they don't need to care about the fact that they're on a network or not.

937
00:46:40,162 --> 00:46:41,402
The simulation is always right.

938
00:46:41,422 --> 00:46:42,983
It's going to take care of what's happening.

939
00:46:43,483 --> 00:46:47,264
If a programmer was working in the constraints of the simulation in

940
00:46:47,304 --> 00:46:52,225
a deterministic fashion, well, it was already working online.

941
00:46:52,525 --> 00:46:54,445
So that was really a great thing.

942
00:46:54,485 --> 00:46:56,746
We didn't need to be taking into account.

943
00:46:57,786 --> 00:46:59,108
Is it the real position?

944
00:46:59,729 --> 00:47:03,553
Is it an entity that's owned by my system, by my session?

945
00:47:03,633 --> 00:47:05,936
Or is it somebody else handling which replicas?

946
00:47:06,376 --> 00:47:08,439
It's something that we didn't need to look into.

947
00:47:08,579 --> 00:47:09,640
So that was really great.

948
00:47:10,201 --> 00:47:13,505
Of course, you need to take into account that...

949
00:47:14,366 --> 00:47:16,869
you need to work with deterministic code.

950
00:47:17,249 --> 00:47:19,051
So it happened a lot,

951
00:47:19,612 --> 00:47:20,993
storing something outside of

952
00:47:21,033 --> 00:47:23,076
the history buffers that we showed in the beginning,

953
00:47:23,456 --> 00:47:24,978
well, it caused these things.

954
00:47:25,158 --> 00:47:28,141
So obviously, once everybody knew

955
00:47:28,181 --> 00:47:30,284
the framework in which we were working,

956
00:47:30,524 --> 00:47:31,585
it worked pretty well.

957
00:47:32,854 --> 00:47:35,055
And I mean, it's the whole talk, why we're here.

958
00:47:35,435 --> 00:47:36,316
Two AI systems.

959
00:47:36,956 --> 00:47:37,636
Was it a good thing?

960
00:47:37,696 --> 00:47:38,417
Was it a bad thing?

961
00:47:39,137 --> 00:47:43,780
And for us, really, when we think about it, those systems

962
00:47:43,840 --> 00:47:45,001
did what we wanted.

963
00:47:45,880 --> 00:47:49,663
From the beginning, it's really what were the tools that we needed to build those systems,

964
00:47:50,103 --> 00:47:56,347
what's the behavior that we wanted, and by having the approach of always centering our design decisions,

965
00:47:56,428 --> 00:48:00,731
our technical decisions on the player, well, it enabled us to come to that point.

966
00:48:00,811 --> 00:48:06,335
And in the end, yes, we think we made the right calls.

967
00:48:07,055 --> 00:48:08,957
It's doing a great job.

968
00:48:08,977 --> 00:48:10,158
Both systems are different.

969
00:48:12,037 --> 00:48:14,518
However, having those two systems, it's not an LOD.

970
00:48:14,578 --> 00:48:18,498
So soldiers that are going in a NAFLO cannot become a bot

971
00:48:18,558 --> 00:48:19,619
and start going somewhere else.

972
00:48:19,659 --> 00:48:21,319
So there's definitely some limitations.

973
00:48:22,059 --> 00:48:23,759
It's some things that we can think about evolving.

974
00:48:24,259 --> 00:48:28,120
And it's a constraint that was definitely something to look

975
00:48:28,160 --> 00:48:30,221
into throughout all the production.

976
00:48:31,121 --> 00:48:33,421
So that covers it all.

977
00:48:34,141 --> 00:48:35,322
Thank you very much for your time.

978
00:48:35,342 --> 00:48:37,802
I think we have some time for questions.

979
00:48:45,792 --> 00:48:48,895
And also one point, just after this presentation,

980
00:48:48,935 --> 00:48:51,756
there's an awesome presentation about modifiers in Foreigner

981
00:48:51,797 --> 00:48:54,098
that's done by one of our colleagues, Aurelie Lechevalier.

982
00:48:56,520 --> 00:48:56,680
Yes.

983
00:48:57,260 --> 00:48:57,400
Good.

984
00:48:59,522 --> 00:49:00,623
So I don't know if there's any questions.

985
00:49:00,643 --> 00:49:01,143
Do we have time?

986
00:49:01,623 --> 00:49:01,763
Yes.

987
00:49:02,144 --> 00:49:02,344
Yes.

988
00:49:02,904 --> 00:49:03,084
Yes.

989
00:49:03,244 --> 00:49:07,387
It's not directly AI related, but in the replicated AI,

990
00:49:07,868 --> 00:49:10,049
how do you decide, in a peer-to-peer based game,

991
00:49:10,089 --> 00:49:12,971
how do you decide who simulates the replicated AI?

992
00:49:14,310 --> 00:49:17,872
The way that it works is that there's a peer that's owner of

993
00:49:17,972 --> 00:49:18,852
one of that AI.

994
00:49:19,633 --> 00:49:23,815
So it can be one machine or multiple machines that can

995
00:49:23,835 --> 00:49:24,895
send those inputs.

996
00:49:30,098 --> 00:49:33,641
The goal of the bots when they're fighting is really to replace a player.

997
00:49:34,682 --> 00:49:39,445
There's no specific metric about choosing who's going to be the owner of that bot.

998
00:49:40,226 --> 00:49:40,966
I mean, it's going to be...

999
00:49:42,207 --> 00:49:46,931
There's definitely going to be a difference for players that are fighting against that bot.

1000
00:49:46,991 --> 00:49:53,056
I mean, he's going to have the same lag as the host, as the owner of that peer.

1001
00:49:53,596 --> 00:49:57,379
But it's the same thing as the player against who you're fighting.

1002
00:49:57,980 --> 00:50:01,283
A good choice, I would say, would probably

1003
00:50:01,343 --> 00:50:03,745
to choose the teams.

1004
00:50:03,865 --> 00:50:07,309
So basically, if on my machine, I'm

1005
00:50:08,730 --> 00:50:12,093
handling a bot that's on my side, I won't be fighting him.

1006
00:50:12,294 --> 00:50:13,275
I won't get an advantage.

1007
00:50:13,335 --> 00:50:14,996
I won't get zero lag, zero ping.

1008
00:50:16,518 --> 00:50:18,560
So by using that rule, it's a good way

1009
00:50:18,580 --> 00:50:19,401
to mitigate that issue.

1010
00:50:20,121 --> 00:50:20,401
Thank you.

1011
00:50:21,669 --> 00:50:21,869
Hello.

1012
00:50:22,650 --> 00:50:24,413
So you mentioned specifically about AI.

1013
00:50:25,114 --> 00:50:27,797
I wanted to know if for the player versus player,

1014
00:50:28,278 --> 00:50:29,980
you also only send the inputs?

1015
00:50:30,260 --> 00:50:33,945
Or if you also send some state properties on the players

1016
00:50:33,985 --> 00:50:35,147
or else or anything?

1017
00:50:35,327 --> 00:50:36,008
The same thing, yeah.

1018
00:50:36,268 --> 00:50:38,610
It's the same thing, only inputs.

1019
00:50:39,170 --> 00:50:41,712
Only the inputs, and everybody gets the same conclusion.

1020
00:50:41,973 --> 00:50:45,375
And so yeah, as soon as you play on your machine,

1021
00:50:45,435 --> 00:50:48,758
you take your decisions instantaneously.

1022
00:50:48,898 --> 00:50:49,859
So it's deterministic.

1023
00:50:50,380 --> 00:50:53,682
And those inputs, when they're received on the other side,

1024
00:50:54,143 --> 00:50:56,505
the other machine really syncs up and goes to the same point.

1025
00:50:56,585 --> 00:50:58,586
But it's the only information that we send.

1026
00:50:58,746 --> 00:51:02,429
So it's closer to a lockstep system than to a proper

1027
00:51:02,449 --> 00:51:02,590
request.

1028
00:51:02,670 --> 00:51:03,150
Exactly.

1029
00:51:03,771 --> 00:51:03,971
Thanks.

1030
00:51:04,291 --> 00:51:04,551
No problem.

1031
00:51:06,109 --> 00:51:11,032
Two questions, would you re-do the matches between the bots, like if you did balance

1032
00:51:11,072 --> 00:51:12,192
changes for the heroes?

1033
00:51:13,053 --> 00:51:16,835
And then also, did you only do that with one map, or did you do that with multiple kinds

1034
00:51:16,855 --> 00:51:17,175
of maps?

1035
00:51:17,816 --> 00:51:18,616
Can you just repeat?

1036
00:51:18,656 --> 00:51:20,417
I just, I didn't understand.

1037
00:51:20,638 --> 00:51:20,838
Oh, sorry.

1038
00:51:20,858 --> 00:51:25,360
The bot versus bot matches, if you re-balanced the champions to like maybe affect their range

1039
00:51:25,400 --> 00:51:29,643
or something like that, would you re-run the rematches between all the bots to get a new

1040
00:51:29,683 --> 00:51:30,003
ranking?

1041
00:51:30,243 --> 00:51:31,344
Yeah, yeah, of course.

1042
00:51:32,595 --> 00:51:35,336
Currently we are doing iterations and patches

1043
00:51:35,396 --> 00:51:36,296
and stuff like that.

1044
00:51:36,396 --> 00:51:39,377
And yeah, we can use the same system to validate.

1045
00:51:39,517 --> 00:51:44,979
And we can, if we need, if we change something really

1046
00:51:44,999 --> 00:51:48,281
important on one character, we can update the AI accordingly

1047
00:51:48,321 --> 00:51:50,722
to be sure that we maintain the same difficulty, yes.

1048
00:51:51,102 --> 00:51:51,322
Gotcha.

1049
00:51:51,442 --> 00:51:53,503
And then for the bot versus bot matches,

1050
00:51:53,523 --> 00:51:56,044
were you doing that just on one map or all the maps?

1051
00:51:57,164 --> 00:52:00,045
Currently we use it on one map, but we

1052
00:52:00,065 --> 00:52:01,326
could use it in any map here.

1053
00:52:02,246 --> 00:52:04,728
Basically, we have one map, which

1054
00:52:04,788 --> 00:52:07,610
was the first map that was created,

1055
00:52:07,690 --> 00:52:08,831
and we use it all the time.

1056
00:52:08,911 --> 00:52:10,873
So we did the test in this one.

1057
00:52:11,573 --> 00:52:13,495
And I think we have all the kind of situations

1058
00:52:13,515 --> 00:52:15,777
that we want in this map, like drops,

1059
00:52:15,997 --> 00:52:19,520
so you can just throw someone from a bridge.

1060
00:52:20,260 --> 00:52:22,001
We have spikes and stuff like that.

1061
00:52:22,042 --> 00:52:22,442
So yeah.

1062
00:52:22,922 --> 00:52:23,162
Thank you.

1063
00:52:25,785 --> 00:52:33,651
Hi. Um, so are there properties to the melee combat that make the deterministic and uh input

1064
00:52:33,671 --> 00:52:38,055
driven system that you guys went for more useful as compared to like other game types like a

1065
00:52:38,095 --> 00:52:39,776
shooter or RTS or something like that?

1066
00:52:41,206 --> 00:52:42,227
It's a very good question.

1067
00:52:42,907 --> 00:52:45,348
Honestly, on our side, it worked really well.

1068
00:52:45,668 --> 00:52:48,550
What we wanted was really to get feedbacks as quick as

1069
00:52:48,590 --> 00:52:52,312
possible, because your enemy is really in front of your

1070
00:52:52,352 --> 00:52:56,354
face, so we wanted to have the link between those two peers

1071
00:52:56,554 --> 00:52:57,635
as short as possible.

1072
00:52:57,675 --> 00:52:59,796
So that's why we went into that direction.

1073
00:53:01,257 --> 00:53:07,922
If your enemies are further away, I mean, I'm not sure you need such a big system because it has a cost.

1074
00:53:08,002 --> 00:53:11,886
Like, every single of our actors in the world, even somebody that's really far away,

1075
00:53:12,286 --> 00:53:18,151
well, if there's a lag, if we get an input that's further away in time, we resimulate that actor.

1076
00:53:18,591 --> 00:53:20,313
So it has a toll on CPU.

1077
00:53:20,713 --> 00:53:26,238
So I don't think it's necessarily something I would be using on a first-person shooter, for example.

1078
00:53:26,572 --> 00:53:29,396
cool. Uh I also had a second question. Uh did you ever run

1079
00:53:29,416 --> 00:53:33,582
into butterfly effects when like replaying stuff or um were there

1080
00:53:33,622 --> 00:53:36,586
every like really long latency that like you wouldn't be able

1081
00:53:36,626 --> 00:53:37,087
to replay?

1082
00:53:37,772 --> 00:53:43,115
Definitely at the beginning of the game it was certain that something that happened, we call them like the vortex of death.

1083
00:53:43,756 --> 00:53:49,799
Because if it takes too much time, then your next input is going to take more time, then the other resimulates longer, and then over and over.

1084
00:53:50,760 --> 00:53:56,103
So what we do is like we always ensure that we have enough time to catch up.

1085
00:53:56,683 --> 00:54:02,907
Luckily we didn't have that issue, but it's definitely something that can happen if you have something that's applied on, for example,

1086
00:54:03,227 --> 00:54:06,672
all the actors in the world and if you do this and you need to resimulate a lot

1087
00:54:06,812 --> 00:54:07,153
of uh...

1088
00:54:07,653 --> 00:54:08,675
of uh...

1089
00:54:09,175 --> 00:54:11,038
simulation steps it can definitely happen

1090
00:54:11,058 --> 00:54:13,141
uh... what we probably do is that we

1091
00:54:13,822 --> 00:54:17,266
our system is good if somebody's lagging too much he's gonna get kicked out

1092
00:54:17,306 --> 00:54:18,308
before things get too bad

1093
00:54:18,328 --> 00:54:20,511
cool thank you

1094
00:54:22,743 --> 00:54:25,105
Yeah, I'm curious about your bot on bot matches.

1095
00:54:26,286 --> 00:54:28,888
Don't you get like a skewed statistic

1096
00:54:29,148 --> 00:54:32,931
if like a certain type of AI is like just because

1097
00:54:32,951 --> 00:54:35,172
of the balancing is just by design

1098
00:54:35,212 --> 00:54:36,634
more effective against another type?

1099
00:54:37,014 --> 00:54:38,875
Like how do you like compensate for that?

1100
00:54:38,895 --> 00:54:40,577
I'm just curious like about the metrics.

1101
00:54:40,757 --> 00:54:43,799
Like won't that like skew them somehow?

1102
00:54:44,319 --> 00:54:44,980
I think it's weird.

1103
00:54:45,907 --> 00:54:50,213
We guarantee that at least one character is tweaked and tested by a human.

1104
00:54:50,514 --> 00:54:55,400
So that, in fact, the other one will only be tested against this one.

1105
00:54:55,661 --> 00:55:00,647
Of course, we test all the characters with the testers, but we guarantee that some characters

1106
00:55:00,788 --> 00:55:03,591
are really, really heavily tested so that we are sure that...

1107
00:55:03,932 --> 00:55:06,534
it represents exactly the level of difficulty that we want.

1108
00:55:06,594 --> 00:55:09,676
So all characters are supposed to be equally effective

1109
00:55:09,716 --> 00:55:11,358
against all other characters in that case?

1110
00:55:11,718 --> 00:55:15,361
Not equally, but that's why if we have an assassin,

1111
00:55:15,381 --> 00:55:19,624
for example, against a tank, it may have a better win

1112
00:55:19,664 --> 00:55:20,405
ratio against this one.

1113
00:55:20,425 --> 00:55:22,847
But we try to just be sure that it's homogeneous.

1114
00:55:22,927 --> 00:55:25,989
We allow a certain margin.

1115
00:55:26,369 --> 00:55:27,630
OK, thank you.

1116
00:55:30,600 --> 00:55:30,860
Hello.

1117
00:55:31,940 --> 00:55:35,322
My question is about the rules, determining the rules.

1118
00:55:35,362 --> 00:55:38,623
And I was wondering what the process

1119
00:55:38,663 --> 00:55:41,424
was to determine if a rule was a good one or a bad one,

1120
00:55:41,664 --> 00:55:43,525
and if there was some kind of formula

1121
00:55:43,545 --> 00:55:46,026
you were using to judge the fitness of a certain rule,

1122
00:55:46,246 --> 00:55:48,187
and if that could possibly be automated.

1123
00:55:49,888 --> 00:55:51,949
For the rules that govern the fighters?

1124
00:55:52,209 --> 00:55:54,950
Yes, you were talking about how you set a rule,

1125
00:55:55,030 --> 00:55:57,311
and then it wasn't quite right, and then you'd go and change.

1126
00:55:57,371 --> 00:55:58,732
I was wondering about that process.

1127
00:55:58,973 --> 00:56:04,796
Yeah, it was a lot of, so our engine, since it's a simulation-based engine, we can speed up the process a lot.

1128
00:56:05,116 --> 00:56:10,259
So there were a lot of times where we were able to, so let's try those values, let's see what happens, simulate it,

1129
00:56:10,579 --> 00:56:13,761
and some of our designers, people were wondering, what the hell are you doing?

1130
00:56:13,821 --> 00:56:16,143
It's been 10 minutes you're watching the game play on fast forward.

1131
00:56:16,463 --> 00:56:19,865
Well, they were validating the balance and what are the impacts of what they're doing.

1132
00:56:20,225 --> 00:56:23,066
So we have a way of really increasing really, really fast.

1133
00:56:23,447 --> 00:56:24,387
So that's one of the ways.

1134
00:56:25,068 --> 00:56:26,929
Other ways, a lot of debug display tools,

1135
00:56:27,589 --> 00:56:30,231
visualizing what's happening with the different forces,

1136
00:56:30,271 --> 00:56:32,732
the different algorithms that you're putting in place.

1137
00:56:33,312 --> 00:56:35,594
And, yeah, that's most of it.

1138
00:56:35,994 --> 00:56:36,474
All right, thanks.

1139
00:56:38,756 --> 00:56:41,097
I was curious on the bot-on-bot matches.

1140
00:56:41,237 --> 00:56:43,498
If you had completely deterministic AI,

1141
00:56:43,558 --> 00:56:46,260
how the matches just didn't turn out

1142
00:56:46,440 --> 00:56:47,761
exactly the same every single time.

1143
00:56:48,412 --> 00:56:49,633
No, the bots are not deterministic.

1144
00:56:50,273 --> 00:56:53,035
The AI of the bot is not deterministic,

1145
00:56:53,075 --> 00:56:54,556
it's computed only on one machine,

1146
00:56:54,636 --> 00:56:56,777
and that's why we replicate this stuff.

1147
00:56:57,257 --> 00:56:57,577
So...

1148
00:56:58,018 --> 00:56:59,459
But it's a good question.

1149
00:56:59,539 --> 00:57:01,280
I mean, our game, it's deterministic,

1150
00:57:01,420 --> 00:57:02,661
but there's still random, like,

1151
00:57:03,781 --> 00:57:05,722
the way that it works is that every single agent

1152
00:57:05,802 --> 00:57:08,844
has its seed, its own random generator

1153
00:57:09,245 --> 00:57:11,146
that's aligned to...

1154
00:57:11,686 --> 00:57:14,448
the current simulation step, the agent seed,

1155
00:57:14,728 --> 00:57:17,490
and then we're sure that in the simulation step,

1156
00:57:17,570 --> 00:57:21,432
we can use that random generator and have varying results.

1157
00:57:21,812 --> 00:57:25,574
So even if, but definitely if we use the same thing

1158
00:57:25,634 --> 00:57:26,735
and we send the same inputs,

1159
00:57:26,835 --> 00:57:29,477
you're gonna get the exact same result, absolutely.

1160
00:57:30,157 --> 00:57:32,899
So changing the seed of the session, stuff like that,

1161
00:57:33,059 --> 00:57:35,641
is ways that we use to have a variance

1162
00:57:35,661 --> 00:57:37,161
so that you're not doing exactly the same thing.

1163
00:57:37,181 --> 00:57:38,502
Okay, thanks.

1164
00:57:38,522 --> 00:57:39,783
Yeah, and yes, in fact,

1165
00:57:40,779 --> 00:57:44,300
It's if you send the same input, but because for the bots,

1166
00:57:44,320 --> 00:57:46,361
the system that generates input is not deterministic,

1167
00:57:46,621 --> 00:57:49,283
you can just have different matches every time.

1168
00:57:49,543 --> 00:57:49,723
Yeah.

1169
00:57:51,244 --> 00:57:51,484
Thank you.

1170
00:57:52,424 --> 00:57:52,644
Hello.

1171
00:57:53,185 --> 00:57:55,746
My question is about what happens when you receive

1172
00:57:55,766 --> 00:57:56,946
an update and you re-simulate.

1173
00:57:57,006 --> 00:57:59,788
Do you have a way to figure out which entities to re-simulate,

1174
00:57:59,848 --> 00:58:02,189
or you just go to re-simulate everything?

1175
00:58:02,447 --> 00:58:06,728
Right now we resimulate everything, like when the naive approach maybe,

1176
00:58:07,929 --> 00:58:09,589
and so we redo everything.

1177
00:58:09,729 --> 00:58:13,810
What we do is that when we see that there's a change that affected an object,

1178
00:58:14,110 --> 00:58:17,211
so we have that other pattern that we call the observer pattern,

1179
00:58:17,531 --> 00:58:21,492
that's responsible of all the visual effects, for example...

1180
00:58:22,353 --> 00:58:23,854
blood splatters, effects, sounds,

1181
00:58:24,214 --> 00:58:27,096
so that when it sees that an object state has changed,

1182
00:58:27,256 --> 00:58:30,038
well it cancels the effects that were linked

1183
00:58:30,259 --> 00:58:33,221
to that object, so that we come in sync.

1184
00:58:34,582 --> 00:58:36,663
But yeah, so we're not separating.

1185
00:58:37,264 --> 00:58:38,885
It's for foreigners, too.

1186
00:58:42,368 --> 00:58:43,248
Hello, thank you for the talk.

1187
00:58:45,069 --> 00:58:48,132
So the game is available for different platforms, right?

1188
00:58:48,573 --> 00:58:51,176
Xbox, PlayStation, Windows.

1189
00:58:51,617 --> 00:58:53,779
Can you play across those?

1190
00:58:54,320 --> 00:58:57,704
No. No, we can't. Well, the domestic engine is one of the problems.

1191
00:58:58,125 --> 00:58:59,086
So you cannot do that.

1192
00:59:01,102 --> 00:59:05,624
But we have a metagame where you control territories and stuff like that.

1193
00:59:05,704 --> 00:59:12,467
This is the same across all the platforms, but the game, no, you can't play on PS4 against

1194
00:59:12,487 --> 00:59:13,427
someone on Xbox One.

1195
00:59:13,487 --> 00:59:14,608
Because of the determinism.

1196
00:59:15,408 --> 00:59:21,031
But even for Windows versus Windows, I would think determinism would be a problem if you're

1197
00:59:21,091 --> 00:59:21,911
platform dependent.

1198
00:59:22,202 --> 00:59:24,784
Yeah, well, we're not that platform dependent in the sense

1199
00:59:24,804 --> 00:59:27,186
that we did have some issues, for example, at the beginning

1200
00:59:27,246 --> 00:59:28,848
with Intel versus AMD CPUs.

1201
00:59:29,108 --> 00:59:30,709
We're not always getting the exact same results.

1202
00:59:30,909 --> 00:59:34,252
But it's something that I personally didn't do it,

1203
00:59:34,332 --> 00:59:38,456
but our engineers figured a way to fix that.

1204
00:59:39,177 --> 00:59:41,058
So we probably would be able to fix it

1205
00:59:41,238 --> 00:59:44,541
for multi-platform, inter-platform consoles,

1206
00:59:44,581 --> 00:59:46,643
but it's not part of any plan.

1207
00:59:47,412 --> 00:59:50,378
It seems that we don't have enough time for more questions,

1208
00:59:50,618 --> 00:59:53,905
but we can meet in the wrap room if you want after that.

1209
00:59:54,225 --> 00:59:54,887
Thank you very much again.

1210
00:59:55,087 --> 00:59:55,287
Thank you.

