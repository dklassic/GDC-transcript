1
00:00:05,808 --> 00:00:13,654
Hello, everyone, and welcome to our talk.

2
00:00:13,674 --> 00:00:18,598
The topic we will be presenting today is Simulating Tropical Weather in Far Cry 6.

3
00:00:20,999 --> 00:00:22,821
Before we begin, let me introduce myself.

4
00:00:23,421 --> 00:00:27,925
My name is Emily Zhou, and I have been a technical artist at Ubisoft Montreal for the past four

5
00:00:27,945 --> 00:00:28,185
years.

6
00:00:28,885 --> 00:00:32,828
Colin will introduce himself a little later when he covers the second half of our presentation.

7
00:00:35,708 --> 00:00:38,109
The game that our talk is centered around is Far Cry 6,

8
00:00:38,789 --> 00:00:40,769
the latest installment of the Far Cry franchise.

9
00:00:41,809 --> 00:00:43,190
If you're not familiar with Far Cry,

10
00:00:43,290 --> 00:00:45,650
it is an open world first-person shooter series

11
00:00:46,130 --> 00:00:48,251
where each title takes place in a new environment.

12
00:00:49,431 --> 00:00:51,551
In this case, we introduced the players to Yara,

13
00:00:52,131 --> 00:00:53,432
a fictional Caribbean island

14
00:00:53,652 --> 00:00:55,672
that was inspired by Cuba and other countries.

15
00:00:57,412 --> 00:00:59,613
Here, players will take on the role of Danny Rojas,

16
00:01:00,173 --> 00:01:02,133
a local rebel fighting to topple the regime

17
00:01:02,273 --> 00:01:04,533
of dictator Anton Castillo and his son, Diego.

18
00:01:06,317 --> 00:01:09,498
Far Cry's dynamic open worlds are a shining trait of the franchise.

19
00:01:10,039 --> 00:01:11,379
Each world has a life of its own,

20
00:01:11,600 --> 00:01:14,121
with many systems constantly interacting with one another.

21
00:01:15,382 --> 00:01:17,583
Now, to add a tropical island experience to the mix,

22
00:01:17,723 --> 00:01:19,704
we needed something that would be new to Far Cry,

23
00:01:20,324 --> 00:01:22,185
a complete dynamic weather system.

24
00:01:24,867 --> 00:01:27,168
To give you an idea of what dynamic weather entails,

25
00:01:27,748 --> 00:01:30,770
here's a quick sneak peek at what you might see as a player in Far Cry 6.

26
00:01:34,703 --> 00:01:37,045
Today, we will be presenting to you our weather system

27
00:01:37,105 --> 00:01:37,866
in its entirety.

28
00:01:38,646 --> 00:01:40,528
As such, we have condensed many topics

29
00:01:40,668 --> 00:01:42,429
into the following categories.

30
00:01:43,430 --> 00:01:46,352
To start, I will go over our inspiration and core controls.

31
00:01:47,172 --> 00:01:49,314
I'll then explain how we tackled material wetness

32
00:01:49,394 --> 00:01:50,695
by covering each asset type.

33
00:01:51,696 --> 00:01:54,317
Following that, Colin will step through the technical details

34
00:01:54,377 --> 00:01:56,379
for each rendering feature that supports weather.

35
00:01:57,199 --> 00:01:59,001
And lastly, we will conclude with some final thoughts.

36
00:02:02,170 --> 00:02:06,351
For our inspiration, we looked at the weather for various tropical locations, such as Cuba.

37
00:02:08,631 --> 00:02:12,392
Island locations are typically home to very distinct and varied tropical weather.

38
00:02:13,212 --> 00:02:16,893
At the start of the project, research was conducted on tropical scenery and weather

39
00:02:17,314 --> 00:02:20,894
so that we could give our players an authentic experience as they explored our world.

40
00:02:22,335 --> 00:02:26,756
We soon found that we needed to incorporate both the iconic, sunny weather shown here,

41
00:02:28,605 --> 00:02:32,409
as well as the flip side of tropical weather, which includes heavy rain and thunderstorms.

42
00:02:33,671 --> 00:02:37,935
We needed to emulate the way that weather could change back and forth drastically, sometimes

43
00:02:37,975 --> 00:02:38,596
within hours.

44
00:02:40,137 --> 00:02:43,661
We then took these elements that we wanted to highlight and included them in our concept

45
00:02:43,741 --> 00:02:43,901
art.

46
00:02:46,644 --> 00:02:48,866
Yarrow was pitched as an ideal tropical paradise.

47
00:02:49,447 --> 00:02:52,310
It should serve as a convincing escape into our game's fantasy.

48
00:02:54,556 --> 00:02:56,177
However, our art direction wanted

49
00:02:56,197 --> 00:02:57,938
to contrast the picture-perfect weather

50
00:02:58,378 --> 00:02:59,519
with foreboding thunderstorms.

51
00:03:02,320 --> 00:03:03,961
And when the player gets caught in a storm,

52
00:03:04,161 --> 00:03:06,863
the rain and wetness should be felt and should be convincing.

53
00:03:09,724 --> 00:03:11,205
And of course, Yara is an island.

54
00:03:11,385 --> 00:03:14,107
So the ocean is a key part of the equation, even for weather.

55
00:03:16,588 --> 00:03:18,389
With that in mind, let's translate the direction

56
00:03:18,449 --> 00:03:19,870
into goals for implementing weather.

57
00:03:20,670 --> 00:03:22,791
We want to have a collection of different weather states.

58
00:03:23,601 --> 00:03:25,783
We want the weather to be dynamic and varied.

59
00:03:26,663 --> 00:03:28,925
We want a system where the transitions make sense.

60
00:03:29,485 --> 00:03:32,267
For example, a storm should be preceded with darkening clouds

61
00:03:32,467 --> 00:03:34,149
and followed by remaining water puddles.

62
00:03:35,269 --> 00:03:37,591
And of course, everything needs to be efficient and fit

63
00:03:37,651 --> 00:03:38,492
within our budgets.

64
00:03:39,913 --> 00:03:42,154
We must emphasize here that this weather system will

65
00:03:42,174 --> 00:03:43,636
be for an open world game.

66
00:03:44,316 --> 00:03:45,737
Our decisions are often influenced

67
00:03:45,777 --> 00:03:48,239
by data and performance budgets and the need

68
00:03:48,259 --> 00:03:50,981
to support all times of day and all locations in the world.

69
00:03:53,841 --> 00:03:57,422
Let's move on to our implementation, starting with the core weather controls.

70
00:03:59,483 --> 00:04:04,585
The weather manager is the core code for our weather system and is what essentially drives weather behind the scene.

71
00:04:05,485 --> 00:04:11,367
It contains information used to define and control weather, some of which is exposed as settings in our weather database.

72
00:04:12,147 --> 00:04:16,449
Consider the weather manager as the back end of the system and the weather database as the front end.

73
00:04:17,429 --> 00:04:20,590
Let's go over the setup for our system, starting with the weather preset.

74
00:04:22,387 --> 00:04:25,868
The collection of weather types is referred to on the project as weather presets.

75
00:04:26,668 --> 00:04:30,769
These are defined in the weather database using the exposed parameters from the weather manager.

76
00:04:31,950 --> 00:04:34,490
To get an idea of what we can achieve with these parameters,

77
00:04:34,651 --> 00:04:38,331
let's step through some of our final presets and compare a few of their values.

78
00:04:41,192 --> 00:04:45,393
For the few clouds presets, we use low cloud coverage values shown in the bottom right.

79
00:04:48,202 --> 00:04:50,043
In comparison, the Broken Clouds preset

80
00:04:50,103 --> 00:04:53,065
uses higher cloud coverage to give us big, fluffy clouds.

81
00:04:55,207 --> 00:04:58,048
Next, we can see that the Mist preset has added light fog

82
00:04:58,069 --> 00:04:58,689
in the distance.

83
00:05:00,870 --> 00:05:03,192
And in comparison to that, we have our Heavy Fog preset

84
00:05:03,252 --> 00:05:04,933
with fog values cranked much higher.

85
00:05:07,495 --> 00:05:09,156
The next few presets will show the progression

86
00:05:09,196 --> 00:05:13,059
of rain intensity, starting with light rain, then moderate rain.

87
00:05:14,453 --> 00:05:19,035
followed by heavy rain, at which point the rain intensity is maximized and the sky begins to darken,

88
00:05:20,216 --> 00:05:23,938
which leaves us with our most intense preset, the thunderstorm, which adds lightning.

89
00:05:26,880 --> 00:05:31,462
Now that we have our weather preset building blocks, we need to create a cycle or a weather pattern.

90
00:05:32,403 --> 00:05:38,186
In the very beginning, our initial idea was to collect and use real-world meteorological data from cities like Miami.

91
00:05:39,006 --> 00:05:43,409
As shown in the image, we obtained the description of weather at every hour from a period of time in 2013.

92
00:05:45,340 --> 00:05:47,521
Although it would have been nice to use real-world data

93
00:05:47,581 --> 00:05:50,262
to drive our forecast, we wanted more artistic control.

94
00:05:51,383 --> 00:05:52,883
The method that we ended up going with

95
00:05:53,003 --> 00:05:55,984
was a similar text file, but we timed our chosen weather

96
00:05:56,024 --> 00:05:58,745
presets ourselves and designed up to five full day

97
00:05:58,785 --> 00:05:59,726
cycles per region.

98
00:06:00,926 --> 00:06:03,447
This freedom also allowed us to showcase our weather presets

99
00:06:03,567 --> 00:06:04,487
where they look the best.

100
00:06:07,809 --> 00:06:09,889
Now we need to take some time to discuss regions.

101
00:06:10,700 --> 00:06:13,942
The world of Far Cry 6 has been subdivided into three main regions,

102
00:06:14,562 --> 00:06:18,104
West, Central, and East, each with its own visual identity.

103
00:06:18,904 --> 00:06:21,825
The West region was the dry region, Central was the wetlands,

104
00:06:22,306 --> 00:06:26,407
and the East was the jungle region. To enhance these distinctions, we wanted

105
00:06:26,467 --> 00:06:28,448
our weather to differ between each region as well.

106
00:06:31,089 --> 00:06:34,571
Note that our definition of regions also extends to smaller zones, such as

107
00:06:34,671 --> 00:06:37,812
interiors and caves, and anything else that artists might need

108
00:06:37,832 --> 00:06:38,233
to define.

109
00:06:39,190 --> 00:06:41,591
For each region, we exposed min and max curves

110
00:06:41,711 --> 00:06:43,191
to limit certain weather properties.

111
00:06:43,891 --> 00:06:46,072
This was how we altered weather based on where the player

112
00:06:46,132 --> 00:06:47,213
is moving around in the world.

113
00:06:48,273 --> 00:06:51,394
An example usage case would be how we set the max fog curve

114
00:06:51,434 --> 00:06:53,215
to zero for the indoor zones

115
00:06:53,715 --> 00:06:55,336
to prevent fog from appearing inside.

116
00:06:56,276 --> 00:06:57,657
The limitation to this is that

117
00:06:57,777 --> 00:06:59,257
if your indoor area has windows,

118
00:06:59,417 --> 00:07:01,338
you would see the fog disappear outside

119
00:07:01,778 --> 00:07:02,599
as soon as you walked in.

120
00:07:03,179 --> 00:07:05,160
And this is why we assigned our zones very carefully.

121
00:07:06,641 --> 00:07:09,561
Our weather manager then took in all the potentially overlapping

122
00:07:09,601 --> 00:07:13,062
regions around the player and interpolates the curves

123
00:07:13,142 --> 00:07:15,022
accordingly to output the adjusted weather.

124
00:07:17,803 --> 00:07:19,363
The weather manager also needs to allow

125
00:07:19,403 --> 00:07:21,764
for overrides, such as for gameplay missions

126
00:07:21,884 --> 00:07:23,104
and pre-rendered cut scenes.

127
00:07:23,984 --> 00:07:25,844
For example, the opening mission of the game

128
00:07:25,944 --> 00:07:27,805
has the player fleeing through the city streets

129
00:07:27,905 --> 00:07:29,525
in the middle of a nighttime thunderstorm.

130
00:07:30,625 --> 00:07:33,586
Additionally, our game is available in multiplayer co-op,

131
00:07:33,646 --> 00:07:35,986
so weather needs to be replicated for all players.

132
00:07:38,613 --> 00:07:41,275
This flowchart illustrates the final order of operations.

133
00:07:41,915 --> 00:07:44,137
So to summarize, we first consult the forecast

134
00:07:44,177 --> 00:07:46,239
to get the weather preset at the current time of day.

135
00:07:47,019 --> 00:07:48,300
Then based on where the player is,

136
00:07:48,360 --> 00:07:49,661
we apply regional adjustments.

137
00:07:50,422 --> 00:07:52,043
This gives us the current weather state,

138
00:07:52,163 --> 00:07:53,925
which can be overridden for gameplay.

139
00:07:54,946 --> 00:07:56,587
Finally, we use this weather state

140
00:07:56,627 --> 00:07:59,249
to update the wetness, rain, and lightning with time

141
00:07:59,729 --> 00:08:00,950
and output the final parameters.

142
00:08:01,611 --> 00:08:04,453
These are variables like wetness factor, rain factor, et cetera,

143
00:08:04,493 --> 00:08:07,776
which we can now access to drive visuals, audio, gameplay,

144
00:08:07,876 --> 00:08:08,216
and so on.

145
00:08:11,198 --> 00:08:13,380
Now that we've established the inner workings of our weather

146
00:08:13,420 --> 00:08:16,363
manager, we need our materials to respond.

147
00:08:17,083 --> 00:08:19,365
In other words, how do we make our assets wet?

148
00:08:21,907 --> 00:08:23,568
Wetness is a huge component of weather.

149
00:08:23,869 --> 00:08:25,890
When it rains, we need to see the world change.

150
00:08:26,551 --> 00:08:28,152
And this means that every asset now

151
00:08:28,192 --> 00:08:30,174
needs a wet state so that we can properly

152
00:08:30,234 --> 00:08:31,175
blend from dry to wet.

153
00:08:32,255 --> 00:08:35,496
The risks associated with creating a wet version of every asset are,

154
00:08:36,176 --> 00:08:37,577
one, there are too many assets,

155
00:08:37,677 --> 00:08:40,797
so requiring any extra data will add a lot of production time.

156
00:08:41,658 --> 00:08:44,998
And two, our art teams all have their own asset pipelines and shaders.

157
00:08:45,458 --> 00:08:47,199
We could be risking a lack of cohesion,

158
00:08:47,339 --> 00:08:50,099
which would be very hard to control given our project's scale.

159
00:08:51,220 --> 00:08:54,340
So our final solution was to work in parallel with asset creation.

160
00:08:55,321 --> 00:08:58,741
To do this, it needed to be simple and unified as much as possible.

161
00:08:59,579 --> 00:09:02,440
We also decided that it would be primarily tech artist driven

162
00:09:02,760 --> 00:09:04,041
and it should work out of the box.

163
00:09:04,981 --> 00:09:07,502
This means that we should be able to drag and drop assets

164
00:09:07,542 --> 00:09:10,183
in the world and they should get wet properly in the rain.

165
00:09:11,364 --> 00:09:13,865
Of course, some materials receive more detail and polish,

166
00:09:14,085 --> 00:09:16,226
but for the simplest props or legacy assets,

167
00:09:16,746 --> 00:09:18,687
wetness should work without having to revisit them.

168
00:09:20,167 --> 00:09:22,628
So let's dive into our wetness implementation.

169
00:09:24,517 --> 00:09:27,219
First and foremost, we split our solution into two parts

170
00:09:27,659 --> 00:09:30,421
by having two wetness types, static and dynamic.

171
00:09:31,462 --> 00:09:33,143
As their names imply, static wetness

172
00:09:33,163 --> 00:09:34,564
is for objects that will never move,

173
00:09:35,125 --> 00:09:36,826
and dynamic is for objects that will move.

174
00:09:38,287 --> 00:09:41,349
Static wetness applies mostly to our object bank assets,

175
00:09:41,529 --> 00:09:43,531
which includes props and structures.

176
00:09:44,411 --> 00:09:45,772
Their wetness level is determined

177
00:09:45,812 --> 00:09:48,975
by using the wetness factor parameter provided

178
00:09:49,035 --> 00:09:50,075
by the weather manager.

179
00:09:50,896 --> 00:09:53,118
We also use a wetness shadow map to mask out

180
00:09:53,138 --> 00:09:54,138
wetness where appropriate.

181
00:09:55,480 --> 00:09:57,461
Static wetness will be the simplest visually

182
00:09:57,641 --> 00:09:59,862
and will be applied in the deferred lighting pass,

183
00:10:00,302 --> 00:10:02,263
which means it will only be applied in one spot.

184
00:10:03,264 --> 00:10:06,186
The pros to static wetness is clearly its simplicity

185
00:10:06,306 --> 00:10:08,207
and the fact that everything can be tweaked at once.

186
00:10:08,867 --> 00:10:11,148
But the con is that there is no flexibility at all.

187
00:10:12,789 --> 00:10:14,710
Dynamic wetness is reserved primarily

188
00:10:14,810 --> 00:10:16,851
for weapons, vehicles, and characters.

189
00:10:17,412 --> 00:10:19,593
Their wetness level is calculated by raycast

190
00:10:19,953 --> 00:10:21,274
to detect exposure to rain.

191
00:10:22,247 --> 00:10:24,007
Their wetness also includes a bonus feature

192
00:10:24,167 --> 00:10:26,908
called local wetness, which handles submersion in water.

193
00:10:28,368 --> 00:10:30,148
For dynamic wetness, the visual change

194
00:10:30,268 --> 00:10:32,709
will be applied in each individual shader, which

195
00:10:32,749 --> 00:10:34,589
means that we can tailor the look a lot more.

196
00:10:35,269 --> 00:10:36,670
The con to this is that we now have

197
00:10:36,710 --> 00:10:38,050
to manage every shader that could

198
00:10:38,090 --> 00:10:39,490
be used for dynamic assets.

199
00:10:42,151 --> 00:10:43,931
First, let's look at the static wetness type.

200
00:10:44,711 --> 00:10:46,372
The main wetness calculation we need

201
00:10:46,532 --> 00:10:49,252
is the wetness shadow map, which includes objects that are,

202
00:10:49,292 --> 00:10:51,593
for example, under a balcony or indoors.

203
00:10:52,405 --> 00:10:54,786
This is important because we use our props a lot,

204
00:10:55,226 --> 00:10:56,927
so their wetness should be accurate no matter

205
00:10:56,967 --> 00:10:58,247
where level artists place them.

206
00:10:59,688 --> 00:11:02,188
Since our static wetness is applied in the deferred lighting

207
00:11:02,228 --> 00:11:04,349
pass, we store the wetness shadow

208
00:11:04,509 --> 00:11:05,710
in our deferred shadow pass.

209
00:11:06,510 --> 00:11:08,630
We then simply multiply the sample shadow

210
00:11:08,670 --> 00:11:10,511
with the weather manager's wetness factor

211
00:11:10,911 --> 00:11:11,831
to get the final wetness.

212
00:11:14,512 --> 00:11:15,953
Let's look at a wetness shadow example.

213
00:11:16,681 --> 00:11:19,622
In this scene, there are lighter, dry concrete patches

214
00:11:19,662 --> 00:11:22,482
on the floor and on the wooden table as well.

215
00:11:23,763 --> 00:11:26,023
But more importantly, let's look at the wetness shadow.

216
00:11:26,944 --> 00:11:28,664
As you can see, it works quite well,

217
00:11:28,744 --> 00:11:31,265
but there are some precision limitations, particularly

218
00:11:31,445 --> 00:11:32,505
on vertical surfaces.

219
00:11:33,505 --> 00:11:35,366
If you look closely at the highlighted areas,

220
00:11:35,586 --> 00:11:37,246
you will see some speckled details.

221
00:11:37,827 --> 00:11:39,687
This is because the cutoff was originally

222
00:11:39,727 --> 00:11:42,728
a very harsh line, which we softened using dithering.

223
00:11:45,730 --> 00:11:47,271
Now let's move on to how we apply

224
00:11:47,291 --> 00:11:48,492
the visual of static wetness.

225
00:11:49,493 --> 00:11:51,094
We first referred to photo reference

226
00:11:51,234 --> 00:11:53,396
to analyze exactly what inputs we would need

227
00:11:53,496 --> 00:11:54,797
and what changes they should drive.

228
00:11:54,817 --> 00:11:58,399
The two visual changes that we identified as necessary

229
00:11:58,860 --> 00:12:01,602
were darkening the albedo and increasing the smoothness.

230
00:12:02,903 --> 00:12:04,904
Some materials like cardboard would darken,

231
00:12:05,004 --> 00:12:06,145
but wouldn't get too shiny.

232
00:12:06,785 --> 00:12:08,727
And materials like tiles would not darken,

233
00:12:08,787 --> 00:12:09,828
but would get much shinier.

234
00:12:10,448 --> 00:12:12,029
And some materials fall in between.

235
00:12:12,950 --> 00:12:15,351
The key to all this was how absorbent the material was.

236
00:12:17,867 --> 00:12:20,169
As a result, the input we chose was porosity.

237
00:12:20,929 --> 00:12:23,291
Porosity is most directly related to albedo change.

238
00:12:23,472 --> 00:12:25,614
For example, high porosity materials

239
00:12:25,674 --> 00:12:29,037
like dirt, fabric, and raw wood will become saturated

240
00:12:29,097 --> 00:12:29,937
and appear very dark.

241
00:12:30,778 --> 00:12:32,560
On the other hand, low porosity materials

242
00:12:32,620 --> 00:12:34,942
like plastic, marble, and metal will

243
00:12:34,982 --> 00:12:36,423
have water pooling on the surface

244
00:12:36,583 --> 00:12:38,905
rather than getting absorbed, which means that the colors

245
00:12:38,945 --> 00:12:39,566
should be unchanged.

246
00:12:41,057 --> 00:12:44,599
But now that we have our input, we could just use a porosity map and move on.

247
00:12:45,360 --> 00:12:49,242
Except for one problem, not every material can afford an extra texture map.

248
00:12:49,742 --> 00:12:51,704
That would exceed our budgets for not much reward.

249
00:12:52,904 --> 00:12:57,367
So now we need a way to derive porosity whenever a porosity texture is not available.

250
00:12:59,488 --> 00:13:01,449
And this is where we introduce porosity factors.

251
00:13:02,360 --> 00:13:13,752
Since porosity and smoothness are properties that are conceptually connected, our solution was the following formula where the two porosity factor values are just floats that we could specify per material type.

252
00:13:15,333 --> 00:13:23,522
This formula essentially generated a porosity map with all the details of the smoothness map, but with its values lying in the range that we specifically curated.

253
00:13:26,190 --> 00:13:28,251
Luckily for us, our object bank shaders

254
00:13:28,351 --> 00:13:30,472
already had a dropdown of material presets

255
00:13:30,932 --> 00:13:32,392
with hard-coded PBR values.

256
00:13:32,992 --> 00:13:36,553
All we had to do was insert our porosity factors in there.

257
00:13:37,294 --> 00:13:39,554
This kept the artist workflows completely unchanged

258
00:13:39,734 --> 00:13:41,115
and prevented any setup bugs.

259
00:13:44,836 --> 00:13:46,956
So now that we finally have the porosity input ready,

260
00:13:47,076 --> 00:13:49,857
we can look at the central apply wetness function that

261
00:13:49,897 --> 00:13:51,378
is called from the deferred lighting pass.

262
00:13:52,310 --> 00:13:53,610
The code can be referred to later,

263
00:13:53,771 --> 00:13:56,412
but what we essentially did was darken the albedo

264
00:13:56,572 --> 00:13:59,454
according to porosity, except that the material is metallic,

265
00:14:00,334 --> 00:14:03,136
boost the smoothness, and note that we used porosity once more

266
00:14:03,256 --> 00:14:05,537
to get even more control, and finally,

267
00:14:05,597 --> 00:14:07,978
replace the specular reflectance value with that of water.

268
00:14:09,619 --> 00:14:11,881
So for an approximation with very few inputs,

269
00:14:12,021 --> 00:14:14,442
it would be impossible to get every material response

270
00:14:14,602 --> 00:14:14,962
correct.

271
00:14:15,643 --> 00:14:18,064
It was more important to judge the bigger picture rather

272
00:14:18,124 --> 00:14:19,265
than individual assets.

273
00:14:19,968 --> 00:14:22,249
This helped us avoid an endless loop of tweaking values.

274
00:14:24,850 --> 00:14:26,570
Here's a dry versus wet comparison

275
00:14:26,730 --> 00:14:27,791
for some of our materials.

276
00:14:30,352 --> 00:14:32,653
Now let's look at a full scene of assets transitioning

277
00:14:32,773 --> 00:14:35,974
from dry to wet.

278
00:14:39,035 --> 00:14:41,216
Now let's switch gears over to dynamic wetness

279
00:14:41,636 --> 00:14:43,497
used for our characters, weapons, and vehicles.

280
00:14:44,177 --> 00:14:46,118
These assets all have a wetness component

281
00:14:46,138 --> 00:14:47,778
that keeps track of their wetness level.

282
00:14:48,625 --> 00:14:50,226
As mentioned before, characters and weapons

283
00:14:50,266 --> 00:14:52,127
perform a ray cast every few frames

284
00:14:52,207 --> 00:14:53,488
to check their exposure to rain.

285
00:14:54,369 --> 00:14:55,750
Since vehicles are larger in size,

286
00:14:55,810 --> 00:14:57,431
these actually need more than one ray cast.

287
00:14:58,532 --> 00:15:00,393
When exposed to rain, dynamic assets

288
00:15:00,433 --> 00:15:02,335
will increase in wetness level slowly

289
00:15:02,895 --> 00:15:04,036
before they are fully wet.

290
00:15:04,436 --> 00:15:06,818
And when no longer exposed, they will also dry slowly.

291
00:15:08,159 --> 00:15:10,260
The per vertex local wetness calculation

292
00:15:10,380 --> 00:15:11,501
handled submersion.

293
00:15:12,001 --> 00:15:14,763
So if a character wades halfway into a lake, for example,

294
00:15:15,144 --> 00:15:16,545
their lower half will appear wet.

295
00:15:19,756 --> 00:15:21,956
Now, if we recall, the benefits of dynamic wetness

296
00:15:22,016 --> 00:15:24,297
was that we could customize the way we applied wetness.

297
00:15:25,017 --> 00:15:26,998
To gather our ideas, we once again

298
00:15:27,078 --> 00:15:30,459
revisited real-world references, such as staring at parked cars

299
00:15:30,519 --> 00:15:31,259
outside in the rain.

300
00:15:33,659 --> 00:15:35,800
For character clothing, we utilized the same approach

301
00:15:35,860 --> 00:15:36,580
as for our props.

302
00:15:37,080 --> 00:15:39,101
We used an existing dropdown menu in our shaders,

303
00:15:39,341 --> 00:15:41,861
but also added an upper limit to the final smoothness.

304
00:15:42,241 --> 00:15:44,942
This was just to give us even better results for wet fabric

305
00:15:44,962 --> 00:15:45,462
specifically.

306
00:15:46,871 --> 00:15:49,052
Character hair was the simplest change we made.

307
00:15:49,152 --> 00:15:51,314
We only used one set of porosity factors.

308
00:15:52,134 --> 00:15:53,715
At the early stages of brainstorming,

309
00:15:53,755 --> 00:15:56,597
we really wanted a way for hair to actually clump together

310
00:15:56,637 --> 00:15:59,479
when wet, but it was too ambitious for our scope of work.

311
00:16:02,301 --> 00:16:04,182
For skin, we wanted rain to be visible,

312
00:16:04,322 --> 00:16:06,844
but not in a way where scrolling could look unnatural

313
00:16:06,964 --> 00:16:09,886
or distracting, so we went with a subtle approach

314
00:16:09,946 --> 00:16:11,307
by using a static texture,

315
00:16:11,787 --> 00:16:14,349
which contained a droplets normal map and a wetness mask.

316
00:16:15,275 --> 00:16:17,336
With these applied, the skin material wetness

317
00:16:17,376 --> 00:16:18,356
was quickly finalized.

318
00:16:21,778 --> 00:16:24,259
On our project, weapons and vehicles are closely related.

319
00:16:24,800 --> 00:16:27,261
They are both gameplay elements and are seen up close

320
00:16:27,321 --> 00:16:29,082
from the first person's perspective.

321
00:16:29,923 --> 00:16:32,704
For this reason, we gave these assets animated rain effects,

322
00:16:32,864 --> 00:16:35,245
which were applied using animated textures updated

323
00:16:35,345 --> 00:16:35,726
per frame.

324
00:16:36,886 --> 00:16:39,267
These effects were divided into two parts, streaks

325
00:16:39,368 --> 00:16:42,049
and droplets, which were applied on vertical and horizontal

326
00:16:42,089 --> 00:16:43,270
surfaces, respectively.

327
00:16:45,545 --> 00:16:47,966
For the streaks, our input data was only one texture,

328
00:16:48,206 --> 00:16:51,366
which packed in a streak mask, a normal map, and a height map.

329
00:16:52,487 --> 00:16:54,407
The scroll mask was what actually

330
00:16:54,447 --> 00:16:56,747
drove the vertical movement of the streaks, which we applied

331
00:16:56,887 --> 00:16:57,928
in local space UVs.

332
00:16:58,588 --> 00:17:00,448
We made sure to only apply the streaks when

333
00:17:00,468 --> 00:17:02,928
the asset is oriented upright or upside down.

334
00:17:03,509 --> 00:17:05,689
In the latter case, we reversed the scroll direction.

335
00:17:08,509 --> 00:17:10,650
For the droplets, we supplied another texture

336
00:17:10,790 --> 00:17:13,270
containing a normal map, a height map, and an ID map.

337
00:17:14,202 --> 00:17:17,144
To drive the animation here, we sampled the droplets two times

338
00:17:17,344 --> 00:17:19,525
to vary the pattern of droplets fading in and out

339
00:17:19,665 --> 00:17:22,326
with varying timing cycles, which was

340
00:17:22,346 --> 00:17:23,547
made possible with the ID.

341
00:17:24,968 --> 00:17:26,128
One thing we were still missing, though,

342
00:17:26,188 --> 00:17:27,669
was the tiny static droplets that

343
00:17:27,709 --> 00:17:29,810
tend to build up over time on hard surfaces.

344
00:17:30,390 --> 00:17:33,092
So what we did was squeeze them into the height map texture

345
00:17:33,132 --> 00:17:33,532
later on.

346
00:17:34,633 --> 00:17:37,294
We also made sure to use manual MIPS on the droplets texture

347
00:17:37,534 --> 00:17:38,855
to reduce sparkling artifacts.

348
00:17:41,678 --> 00:17:43,299
As we all know, adding a feature often

349
00:17:43,319 --> 00:17:46,042
results in unexpected issues and edge cases popping up.

350
00:17:46,863 --> 00:17:49,065
One issue we faced was that wetness effects were

351
00:17:49,085 --> 00:17:50,406
showing up inside vehicles.

352
00:17:51,447 --> 00:17:53,129
This was because our vehicles sometimes

353
00:17:53,229 --> 00:17:55,811
share materials between the exterior and interior

354
00:17:55,931 --> 00:17:56,912
to save on draw calls.

355
00:17:58,013 --> 00:18:00,856
So the fix for this was simply to use the red vertex paint

356
00:18:01,096 --> 00:18:02,378
channel as an interior mask.

357
00:18:03,250 --> 00:18:04,511
Once this was painted by artists,

358
00:18:04,611 --> 00:18:06,933
we could remove the interior rain effects,

359
00:18:07,233 --> 00:18:09,495
except, of course, in edge cases,

360
00:18:09,575 --> 00:18:11,936
such as when our convertible cars put down their tops.

361
00:18:14,538 --> 00:18:16,900
Another problem came up when moving windshield wipers

362
00:18:16,940 --> 00:18:18,521
were implemented by our gameplay team,

363
00:18:19,081 --> 00:18:21,002
while rain streaks were added by our 3D team,

364
00:18:21,242 --> 00:18:23,264
resulting in no interaction between them.

365
00:18:24,284 --> 00:18:26,506
What we did was pack in a windshield gradient map

366
00:18:26,686 --> 00:18:28,888
and set up the shader to mask the rain according

367
00:18:28,988 --> 00:18:30,188
to the current gradient value.

368
00:18:30,913 --> 00:18:33,474
We then pass this value over to gameplay to hook everything up.

369
00:18:34,595 --> 00:18:37,256
This is a very small feature that we never actually planned,

370
00:18:37,757 --> 00:18:39,798
but inconsistencies like this can really

371
00:18:39,838 --> 00:18:41,799
take a player out of an experience very quickly,

372
00:18:41,819 --> 00:18:43,199
so we were happy to add it.

373
00:18:46,001 --> 00:18:48,702
For vegetation, we originally used the static wetness

374
00:18:48,742 --> 00:18:51,064
approach, but this led to two very big issues.

375
00:18:51,904 --> 00:18:54,346
Firstly, trunks and plants near the jungle floor

376
00:18:54,386 --> 00:18:56,847
were actually getting shadowed from the rain, which

377
00:18:57,007 --> 00:18:58,428
was very strange to see in nature.

378
00:18:59,553 --> 00:19:02,054
And secondly, we were getting bugs explaining that the trees

379
00:19:02,094 --> 00:19:03,115
were looking metallic.

380
00:19:03,936 --> 00:19:06,317
And this was because the flat leaf cards were giving off

381
00:19:06,397 --> 00:19:08,138
a uniform reflection of the gray sky.

382
00:19:08,659 --> 00:19:10,540
And the visual was so strong that it effectively

383
00:19:10,600 --> 00:19:12,921
reduced the realism of our trees by exposing

384
00:19:12,941 --> 00:19:13,722
where the cards were.

385
00:19:15,143 --> 00:19:17,344
To fix this, we converted vegetation over

386
00:19:17,444 --> 00:19:19,605
to the dynamic wetness type, just

387
00:19:19,625 --> 00:19:21,647
so that we could tailor the wetness in the shaders

388
00:19:21,687 --> 00:19:22,227
independently.

389
00:19:23,248 --> 00:19:24,629
Of course, this meant that there would now

390
00:19:24,789 --> 00:19:26,270
no longer be any shadowing.

391
00:19:27,055 --> 00:19:30,335
But 99% of the time, our trees are not hand-placed indoors,

392
00:19:30,456 --> 00:19:31,776
so we went through with the swap.

393
00:19:33,056 --> 00:19:34,616
In the end, we used the droplets texture

394
00:19:34,697 --> 00:19:37,217
on the leaves, which finally matched reality a lot better

395
00:19:37,777 --> 00:19:38,978
and fixed the reflection bugs.

396
00:19:42,298 --> 00:19:44,319
Terrain was the final area to conquer.

397
00:19:44,879 --> 00:19:46,959
Not only is it always in the player's point of view,

398
00:19:47,560 --> 00:19:49,720
but as we can see from these photo references,

399
00:19:49,840 --> 00:19:51,500
it also requires a lot more detail.

400
00:19:53,761 --> 00:19:55,081
Let's first summarize very quickly

401
00:19:55,221 --> 00:19:56,222
what we need for our terrain.

402
00:19:57,161 --> 00:20:00,224
The primary textures used include albedo, normal,

403
00:20:00,424 --> 00:20:03,306
smoothness, and now the new texture, porosity.

404
00:20:04,387 --> 00:20:06,689
These properties are stored in a virtual texture atlas

405
00:20:06,789 --> 00:20:08,271
that we use for the entire world.

406
00:20:09,432 --> 00:20:10,733
To see more about this system, you

407
00:20:10,773 --> 00:20:14,496
can refer to our past talk on terrain.

408
00:20:14,576 --> 00:20:16,238
Note that roads and terrain decals

409
00:20:16,298 --> 00:20:18,340
are all baked into the virtual texture atlas.

410
00:20:18,520 --> 00:20:20,362
So it really is one complete system

411
00:20:20,522 --> 00:20:21,783
that we needed to apply wetness to.

412
00:20:24,957 --> 00:20:26,819
To make terrain wet, we actually just

413
00:20:26,939 --> 00:20:29,080
used the same apply wetness function shown earlier.

414
00:20:29,741 --> 00:20:31,282
The key difference now for terrain

415
00:20:31,462 --> 00:20:33,904
is that the transition was changed.

416
00:20:34,905 --> 00:20:36,967
We didn't want a linear fade, as we thought this

417
00:20:37,007 --> 00:20:38,728
was a bit too artificial for something

418
00:20:38,848 --> 00:20:40,249
with such a large surface area.

419
00:20:41,030 --> 00:20:43,972
So the new transition we created was our raindrop splatter

420
00:20:44,012 --> 00:20:45,333
effect, as shown in the video.

421
00:20:46,514 --> 00:20:48,115
To do this, a height field simulation

422
00:20:48,155 --> 00:20:51,218
was done on the GPU, which took in some simple parameters,

423
00:20:51,278 --> 00:20:53,580
such as drying and spreading speed for the splatters.

424
00:20:54,722 --> 00:20:57,643
The resulting animated mask was used as our custom wetness

425
00:20:57,663 --> 00:20:58,003
factor.

426
00:20:59,524 --> 00:21:00,805
Another thing to note was that we

427
00:21:00,865 --> 00:21:02,906
chose to temporarily increase the terrain

428
00:21:02,946 --> 00:21:05,667
porosity at this point just to accentuate the effect

429
00:21:05,707 --> 00:21:06,548
with darker splatters.

430
00:21:09,769 --> 00:21:11,390
Now that terrain has its wetness applied,

431
00:21:11,610 --> 00:21:14,051
we have to turn our attention to the largest visual feature

432
00:21:14,111 --> 00:21:16,112
needed to present wetness, puddles.

433
00:21:17,133 --> 00:21:18,954
Puddles are also a heavily desired feature

434
00:21:18,994 --> 00:21:21,535
for our direction because they would provide reflections,

435
00:21:21,995 --> 00:21:23,876
which ultimately makes the environment and lighting much

436
00:21:23,916 --> 00:21:24,437
more appealing.

437
00:21:25,640 --> 00:21:27,421
The setup for puddles was very simple.

438
00:21:28,041 --> 00:21:30,402
A puddle itself is a terrain decal,

439
00:21:30,482 --> 00:21:33,064
but all it contained was an alpha gradient and a checkbox

440
00:21:33,164 --> 00:21:34,825
to only write to terrain porosity.

441
00:21:35,765 --> 00:21:38,387
The gradient served as a pseudo-sign distance field,

442
00:21:38,807 --> 00:21:40,708
which allowed puddles to build up from the center.

443
00:21:42,209 --> 00:21:44,550
We only had a few puddle decal variations,

444
00:21:44,710 --> 00:21:47,111
which were scattered by our existing terrain and road

445
00:21:47,151 --> 00:21:50,493
recipe systems, similar to how cracks and potholes would

446
00:21:50,513 --> 00:21:50,933
be scattered.

447
00:21:52,417 --> 00:21:55,420
We calculated the puddle wetness based on the terrain porosity

448
00:21:55,560 --> 00:21:57,741
and the puddle factor provided by the wetness manager.

449
00:21:59,202 --> 00:22:01,704
Once we had the puddle wetness, we once again just

450
00:22:01,784 --> 00:22:03,526
altered the gbuffer values accordingly.

451
00:22:04,467 --> 00:22:06,188
What we did was slightly blend the albedo

452
00:22:06,288 --> 00:22:09,250
to a muddy puddle color and blended this evenness to 1.

453
00:22:10,311 --> 00:22:13,233
For the normals, however, we initially used a flat normal,

454
00:22:13,774 --> 00:22:17,457
but that now brings us to our next implementation, which

455
00:22:17,477 --> 00:22:18,197
was puddle effects.

456
00:22:19,555 --> 00:22:22,538
The two types of puddle effects comprised of rain impact

457
00:22:22,578 --> 00:22:24,600
ripples, which are the circular ripples that

458
00:22:24,720 --> 00:22:27,643
simulate rain hitting water, and wind ripples,

459
00:22:27,823 --> 00:22:30,145
which are the small waves that occur when a gust of wind

460
00:22:30,185 --> 00:22:31,266
pushes the puddle surface.

461
00:22:32,207 --> 00:22:34,048
It would have been perfectly acceptable to have

462
00:22:34,149 --> 00:22:36,291
flat, undisturbed puddles, but we really

463
00:22:36,331 --> 00:22:37,752
wanted to take it one step further

464
00:22:37,992 --> 00:22:39,253
and tie in our weather elements.

465
00:22:40,314 --> 00:22:42,696
So we generated a tiling animated texture,

466
00:22:43,157 --> 00:22:45,679
updated every frame, to be used for all of our puddles.

467
00:22:48,111 --> 00:22:49,792
Our input data was a single texture

468
00:22:50,032 --> 00:22:52,715
with two normal maps packed inside, one for the rain

469
00:22:52,755 --> 00:22:54,216
ripples and one for the wind ripples.

470
00:22:54,816 --> 00:22:57,078
The output was a single animated normal texture.

471
00:22:58,239 --> 00:23:00,601
So for the rain ripples, we sampled the normal texture

472
00:23:00,661 --> 00:23:03,943
twice to have two overlapping layers of flipbook animations.

473
00:23:04,864 --> 00:23:07,546
These are faded in based on the weather manager's rain effects

474
00:23:07,586 --> 00:23:10,789
factor, which will ensure that these ripples only appear

475
00:23:10,829 --> 00:23:11,829
when it is actually raining.

476
00:23:13,110 --> 00:23:15,272
For the wind ripples, we scroll the texture

477
00:23:15,312 --> 00:23:17,534
based on the current wind direction and intensity.

478
00:23:18,320 --> 00:23:19,982
As a result, this effect can be present

479
00:23:20,062 --> 00:23:23,064
whether it is raining or not, such as when puddles are still

480
00:23:23,104 --> 00:23:24,405
on the ground just after a storm.

481
00:23:25,826 --> 00:23:27,387
Finally, we blend these effects together

482
00:23:27,508 --> 00:23:29,829
to get the result that we use for our puddle models.

483
00:23:31,771 --> 00:23:33,672
This concludes the collection of shader changes

484
00:23:33,712 --> 00:23:35,494
we needed to support material wetness.

485
00:23:36,815 --> 00:23:39,217
And now, Colin will take you through the technical features

486
00:23:39,277 --> 00:23:40,678
that allowed us to render the weather.

487
00:23:48,011 --> 00:23:48,831
Thank you, Emily.

488
00:23:48,851 --> 00:23:54,394
Hi, my name is Colin Wyke.

489
00:23:54,734 --> 00:23:56,955
I'm a 3D programmer at Ubisoft Toronto,

490
00:23:56,995 --> 00:23:58,355
where I've been for the past five years,

491
00:23:58,655 --> 00:24:01,136
and I worked on Far Cry 5 and Far Cry 6.

492
00:24:02,437 --> 00:24:04,318
Now that Emily has shown us the intricacies

493
00:24:04,418 --> 00:24:09,240
of the weather manager and the wetness,

494
00:24:11,120 --> 00:24:12,161
the implementation of the wetness,

495
00:24:12,201 --> 00:24:13,681
let's take a look at the rendering features

496
00:24:13,741 --> 00:24:15,762
we needed to realize dynamic weather.

497
00:24:17,765 --> 00:24:20,905
But first, let's take a look at the technical constraints

498
00:24:20,945 --> 00:24:21,445
that we had.

499
00:24:22,166 --> 00:24:23,986
Our game shipped on nine platforms,

500
00:24:24,206 --> 00:24:26,686
spanning multiple console generations, as well as PC.

501
00:24:27,387 --> 00:24:30,367
We were aiming for 4K 60 FPS on next gen

502
00:24:30,427 --> 00:24:32,147
and 30 FPS on the previous gen.

503
00:24:32,868 --> 00:24:35,968
This was also our largest open world to date.

504
00:24:36,628 --> 00:24:39,409
And as Emily mentioned, we have a full day night cycle

505
00:24:39,909 --> 00:24:40,729
in an open world,

506
00:24:41,449 --> 00:24:43,290
which features indoor and outdoor environments.

507
00:24:43,870 --> 00:24:46,850
And now we need to do all of this with dynamic weather.

508
00:24:48,828 --> 00:24:52,651
Let's take a look at a sample scene and see how these rendering features come together

509
00:24:52,991 --> 00:24:55,232
to complete the depiction of our weather states.

510
00:24:56,072 --> 00:24:57,773
First, we have atmospheric scattering.

511
00:24:59,014 --> 00:25:01,315
Then we have the clouds on the horizon and overhead.

512
00:25:02,676 --> 00:25:07,099
Then we have volumetric fog obscuring regions and producing light shafts escaping from the

513
00:25:07,119 --> 00:25:07,419
clouds.

514
00:25:09,100 --> 00:25:10,881
Next, we have cue maps and reflections.

515
00:25:11,281 --> 00:25:13,522
Notice how the power lines are reflected on the road.

516
00:25:14,755 --> 00:25:16,675
And finally, we have rain and lightning,

517
00:25:17,035 --> 00:25:19,096
which complete the scene of an intense thunderstorm.

518
00:25:20,716 --> 00:25:22,536
Before we look at individual techniques,

519
00:25:23,117 --> 00:25:25,397
let's start with a primer on our lighting model.

520
00:25:26,157 --> 00:25:28,198
We use physically based formulas and aim

521
00:25:28,218 --> 00:25:29,878
to be energy conserving as a goal.

522
00:25:31,018 --> 00:25:33,319
New for Far Cry 6, we have a higher quality

523
00:25:33,479 --> 00:25:38,580
multiscattering diffused BRDF and a GGX specular

524
00:25:38,660 --> 00:25:42,301
BRDF with multiscattering lobe and support for area lights.

525
00:25:43,541 --> 00:25:44,442
The chart on the right.

526
00:25:45,429 --> 00:25:51,015
shows how we handle specific materials, but one surface type of note was translucency,

527
00:25:51,375 --> 00:25:56,620
which we use for vegetation. For translucency, we wrapped the diffuse lighting for subsurface

528
00:25:56,640 --> 00:26:01,485
scattering and added a second diffuse lobe to simulate light going through the surface.

529
00:26:02,065 --> 00:26:07,671
You can refer to Steve McCauley's i3d talk from 2019 to learn more about these improvements.

530
00:26:09,315 --> 00:26:12,357
For global illumination, we use a light probe system

531
00:26:13,058 --> 00:26:15,640
where probes are placed by artists throughout the world

532
00:26:15,740 --> 00:26:18,122
and baked daily to incorporate changes in the world.

533
00:26:19,103 --> 00:26:21,265
GI data is stored in voxels.

534
00:26:21,826 --> 00:26:24,848
We pack 13 frames of data, 11 of which

535
00:26:25,329 --> 00:26:27,110
are time of day increments to give coverage

536
00:26:27,130 --> 00:26:27,911
to the sky and moon.

537
00:26:28,571 --> 00:26:30,273
There's one key frame for local lights,

538
00:26:30,413 --> 00:26:32,995
which is mostly used at night, and one key frame

539
00:26:33,035 --> 00:26:33,836
for sky occlusion.

540
00:26:34,436 --> 00:26:35,237
But there's a problem.

541
00:26:35,930 --> 00:26:39,952
These GI probes don't include clouds or any impact from the weather.

542
00:26:40,613 --> 00:26:43,234
The solution that we had was to fade out indirect lighting

543
00:26:43,515 --> 00:26:44,775
when cloud coverage is high.

544
00:26:45,696 --> 00:26:48,958
This could create a problem if local lights were in the key frames

545
00:26:49,238 --> 00:26:50,119
in all the key frames.

546
00:26:50,539 --> 00:26:54,301
But since they're isolated to just one, we can avoid fading

547
00:26:54,341 --> 00:26:56,783
artificial lights during high cloud coverage.

548
00:26:57,663 --> 00:27:00,845
Additionally, urban environments tested the limits of the system.

549
00:27:01,386 --> 00:27:04,368
We leaned heavily into the sparse nature of the data.

550
00:27:05,211 --> 00:27:08,853
and the variable probe size to increase precision near

551
00:27:09,093 --> 00:27:10,374
and within indoor environments.

552
00:27:13,356 --> 00:27:17,198
We use the Brunton Sky model and Pretham Sun model

553
00:27:18,118 --> 00:27:20,139
with improvements made such as Ozone.

554
00:27:21,580 --> 00:27:24,602
This setup involves lookup tables calculated offline.

555
00:27:25,202 --> 00:27:27,383
And previously, this was generated at runtime,

556
00:27:27,403 --> 00:27:28,284
but that was very slow.

557
00:27:29,504 --> 00:27:31,726
Artists create four skies, humidity 0 to 1,

558
00:27:32,633 --> 00:27:39,176
turbidity 0 to 1, and we blend between these at runtime to get variation. You can check out our

559
00:27:39,396 --> 00:27:45,398
GDC talk from 2015 about lighting in Far Cry 4 for early implementation of these concepts.

560
00:27:46,959 --> 00:27:50,961
Here we show the effects of humidity and turbidity parameters on the optical depth

561
00:27:51,021 --> 00:27:55,303
lookup table and the blended in-scattering lookup table. We blend four pairs of data

562
00:27:55,343 --> 00:27:56,723
together to get our final result.

563
00:27:58,030 --> 00:28:00,533
The green arrow points to the blended result for each frame,

564
00:28:00,613 --> 00:28:02,295
and the red arrow points to the lookup tables

565
00:28:02,335 --> 00:28:05,159
with the greatest weight for the frame's humidity and turbidity

566
00:28:05,199 --> 00:28:05,639
parameters.

567
00:28:06,941 --> 00:28:09,504
This is what gave us our stunning sunrises and sunsets,

568
00:28:09,584 --> 00:28:10,966
which you see casting beautifully

569
00:28:11,026 --> 00:28:12,167
on the edges of the clouds.

570
00:28:12,868 --> 00:28:15,331
That leads us to our next subject, volumetric clouds.

571
00:28:16,512 --> 00:28:18,173
So why do we want volumetric clouds?

572
00:28:18,553 --> 00:28:20,795
Simply put, a skybox is not sufficient.

573
00:28:20,975 --> 00:28:22,936
It has poor results in motion and is

574
00:28:22,976 --> 00:28:25,477
difficult to blend between different weather states.

575
00:28:26,298 --> 00:28:28,299
A skybox is also more of a backdrop

576
00:28:28,339 --> 00:28:30,780
where we wanted something more grounded

577
00:28:30,900 --> 00:28:32,481
and interacting with the world.

578
00:28:33,502 --> 00:28:35,083
Additionally, we needed our clouds

579
00:28:35,103 --> 00:28:38,885
to respond to weather and varying cloud coverage.

580
00:28:39,885 --> 00:28:42,847
Our eventual solution was built on prior work as listed here.

581
00:28:44,514 --> 00:28:47,236
The most important part of cloud lighting is extinction.

582
00:28:47,457 --> 00:28:49,578
As light travels through a volume,

583
00:28:50,019 --> 00:28:52,521
it loses energy due to the interaction

584
00:28:52,781 --> 00:28:56,844
with water particles that clouds are composed of.

585
00:28:57,665 --> 00:29:00,867
This extinction is determined by the Beer-Lambert law, which

586
00:29:00,907 --> 00:29:03,309
we will henceforth refer to as transmittance.

587
00:29:04,350 --> 00:29:06,332
Extinction consists of both absorption,

588
00:29:06,392 --> 00:29:08,654
which is actually quite low for clouds, and scattering.

589
00:29:09,374 --> 00:29:12,277
The light that eventually hits the eye after being scattered

590
00:29:12,377 --> 00:29:13,678
is measured in terms of radiance.

591
00:29:15,075 --> 00:29:18,817
Single scattering refers to when light enters a cloud

592
00:29:19,217 --> 00:29:20,738
and encounters one scattering event

593
00:29:20,798 --> 00:29:22,859
before traveling in the direction towards the observer.

594
00:29:23,519 --> 00:29:27,381
Multi-scattering refers to when the light encounters

595
00:29:27,401 --> 00:29:29,382
a near limitless number of scattering events

596
00:29:29,582 --> 00:29:32,323
within the cloud before traveling in the direction

597
00:29:32,403 --> 00:29:33,184
towards the observer.

598
00:29:34,364 --> 00:29:36,786
Here we show the effects of single scattering on the clouds.

599
00:29:37,866 --> 00:29:40,988
Next, we isolate the effects of multi-scattering on the clouds.

600
00:29:41,468 --> 00:29:42,328
And finally, we have

601
00:29:43,158 --> 00:29:46,602
the effect of both. Notice the greater sense of depth in the clouds.

602
00:29:48,584 --> 00:29:52,749
All of these scattering events can be modeled by a phase function, which projects how much

603
00:29:52,829 --> 00:29:55,452
light and in what direction it will travel after it's scattered.

604
00:29:56,734 --> 00:30:01,759
In this diagram, we have the oval shape representing the phase function approximation of light

605
00:30:01,779 --> 00:30:04,082
scattering after the scattering event at the blue dot.

606
00:30:06,165 --> 00:30:09,127
On the right is a plot of the double-lobed Henye-Greenstein

607
00:30:09,327 --> 00:30:11,249
phase function we used in our implementation.

608
00:30:11,509 --> 00:30:12,870
The real phase function for clouds

609
00:30:12,910 --> 00:30:15,412
would be much more complex and far too expensive

610
00:30:15,752 --> 00:30:16,813
to calculate in real time.

611
00:30:17,374 --> 00:30:19,575
You can reference this and other lighting code

612
00:30:19,635 --> 00:30:20,576
in our bonus slides.

613
00:30:22,378 --> 00:30:23,759
All of these scattering events can

614
00:30:23,779 --> 00:30:25,060
be modeled by a phase function.

615
00:30:28,194 --> 00:30:30,855
Let's talk about how we authored cloud data, which

616
00:30:30,895 --> 00:30:33,936
represents the density of particles in the clouds

617
00:30:34,476 --> 00:30:35,936
to be used for scattering techniques.

618
00:30:36,656 --> 00:30:39,457
We created base and detail noise textures

619
00:30:39,957 --> 00:30:42,618
containing mixes of noise types and frequencies, which we

620
00:30:42,638 --> 00:30:43,798
collapsed into a single channel.

621
00:30:44,619 --> 00:30:47,219
These textures are then volumetrically sampled

622
00:30:47,299 --> 00:30:48,960
and blended together to create cloud shapes.

623
00:30:50,020 --> 00:30:53,101
Next, we generated a weather map to be tiled in the world

624
00:30:53,201 --> 00:30:54,621
and scrolled in the wind direction

625
00:30:54,721 --> 00:30:55,582
from a weather manager.

626
00:30:56,345 --> 00:31:02,569
This builds our XY formations of clouds and enables us to smoothly interpolate between levels of cloud coverage.

627
00:31:03,329 --> 00:31:11,615
We also have a curl noise, which contains 3D vector data, which we use as an origin offset when shooting rays into the base in detail noise.

628
00:31:13,075 --> 00:31:18,559
Finally, we have cirrus cloud texture, which we map hemispherically to the sky,

629
00:31:19,359 --> 00:31:23,462
and cirrus horizon texture, which we map in a cylinder around the camera.

630
00:31:24,938 --> 00:31:26,099
Let's put all of these together.

631
00:31:27,279 --> 00:31:29,040
Here we start with a clear sky and just

632
00:31:29,060 --> 00:31:30,000
our atmospheric scattering.

633
00:31:31,241 --> 00:31:34,742
Then we add the cirrus hemisphere and horizon clouds.

634
00:31:35,702 --> 00:31:37,323
Then we add the weather map, and you

635
00:31:37,343 --> 00:31:39,763
start to see the xy shape of the cloud formations.

636
00:31:41,004 --> 00:31:42,824
Then we combine the gradient texture

637
00:31:43,005 --> 00:31:44,665
to define the shape of the clouds.

638
00:31:45,185 --> 00:31:47,686
This cumulus gradient ended up being the only gradient

639
00:31:47,726 --> 00:31:49,907
we needed to ship, although we did experiment

640
00:31:49,947 --> 00:31:50,747
with other cloud types.

641
00:31:52,299 --> 00:31:55,080
Then we use the base detail noise volume texture

642
00:31:55,140 --> 00:31:57,381
to get the distinctive cumulus cloud shapes.

643
00:31:58,261 --> 00:32:01,802
Then we use the detail noise volume texture

644
00:32:01,862 --> 00:32:04,603
to erode more detail from those clouds.

645
00:32:05,263 --> 00:32:07,364
And then finally, we add the curl noise texture

646
00:32:07,424 --> 00:32:09,765
to get the wispy details on the edges of the clouds.

647
00:32:11,485 --> 00:32:14,226
Ray marching is the process we use to draw clouds efficiently.

648
00:32:15,086 --> 00:32:18,807
It involves shooting a ray from the observer

649
00:32:18,887 --> 00:32:20,268
and evaluating at specified steps.

650
00:32:22,346 --> 00:32:25,447
At each step, we integrate the density from that point

651
00:32:25,567 --> 00:32:26,667
back to the sun or moon.

652
00:32:27,568 --> 00:32:29,088
We then convert the optical depth

653
00:32:29,208 --> 00:32:31,249
that is returned to transmittance,

654
00:32:31,489 --> 00:32:33,870
which can then be used to approximate

655
00:32:33,910 --> 00:32:35,470
single and multi-scattering.

656
00:32:36,350 --> 00:32:39,371
We then integrate this transmittance along the segment

657
00:32:39,431 --> 00:32:41,492
and accumulate single and multi-scattering

658
00:32:41,552 --> 00:32:42,452
for the raymarch total.

659
00:32:43,113 --> 00:32:45,413
We also apply the extinction to the transmittance,

660
00:32:45,793 --> 00:32:47,594
so that affects later ray steps.

661
00:32:48,774 --> 00:32:51,635
This general process for each pixel is as follows.

662
00:32:52,644 --> 00:32:57,667
Calculate the origin from the pixel ray march, sorry,

663
00:32:57,867 --> 00:32:59,528
from the pixel and ray march,

664
00:32:59,788 --> 00:33:02,729
the density transmittance, optical depth and scattering,

665
00:33:02,929 --> 00:33:03,810
both single and multi.

666
00:33:04,430 --> 00:33:05,731
Calculate the cirrus clouds

667
00:33:05,871 --> 00:33:08,012
if there is non-zero transmittance.

668
00:33:09,132 --> 00:33:10,913
Use the single and multi scattering values

669
00:33:10,973 --> 00:33:13,034
to calculate the radiance from the phase function.

670
00:33:13,815 --> 00:33:16,056
And then finally calculate atmospheric scattering

671
00:33:16,196 --> 00:33:18,077
and blend the clouds in front

672
00:33:18,257 --> 00:33:19,958
using inverse transmittance as a mask.

673
00:33:21,396 --> 00:33:27,039
It would be far too expensive to ray march at the full screen resolution, so we do so at half of the screen resolution.

674
00:33:27,620 --> 00:33:35,144
We have a radiance and transmittance texture, as well as a history radiance and transmittance textures, which we temporally reproject from the last frame.

675
00:33:36,353 --> 00:33:39,634
We fill these runtime textures using a checkerboard rendering

676
00:33:39,674 --> 00:33:40,154
process.

677
00:33:40,634 --> 00:33:43,015
We do a single ray march for each pixel quad

678
00:33:43,115 --> 00:33:47,236
using a checkerboard offset combined with the curl noise

679
00:33:47,316 --> 00:33:48,656
offset to get the ray origin.

680
00:33:49,216 --> 00:33:52,316
This ray march result is single scattering, multi-scattering,

681
00:33:52,396 --> 00:33:53,097
and transmittance.

682
00:33:53,897 --> 00:33:56,157
We project the history into the current frame

683
00:33:57,777 --> 00:33:59,998
and then gather the neighborhood and reject

684
00:34:00,038 --> 00:34:01,558
based on heuristics listed.

685
00:34:02,518 --> 00:34:05,019
We then use bilinear interpolation of the neighbors

686
00:34:05,159 --> 00:34:05,979
and spread the result.

687
00:34:06,948 --> 00:34:10,529
of the ray march over this area, fading the history over time.

688
00:34:11,149 --> 00:34:14,690
The result is stored as radiance and transmittance history

689
00:34:14,730 --> 00:34:16,130
that will be used for the next frame.

690
00:34:17,151 --> 00:34:18,771
Particularly of note is the process

691
00:34:18,791 --> 00:34:20,312
we use to store the radiance.

692
00:34:20,632 --> 00:34:24,053
We encode with blue noise to help

693
00:34:24,113 --> 00:34:27,294
mask the noisy artifacts inherent to ray

694
00:34:27,314 --> 00:34:28,874
marching at such a lower resolution.

695
00:34:29,594 --> 00:34:32,335
Notice on the right, we do a 2x blur of the blue noise,

696
00:34:32,395 --> 00:34:35,176
and it converges to gray, while the white noise does not.

697
00:34:37,235 --> 00:34:39,357
This looks pretty good, but there's still a problem.

698
00:34:39,897 --> 00:34:41,518
We're missing shadows on the ground.

699
00:34:41,939 --> 00:34:43,460
This makes it really hard to determine

700
00:34:43,640 --> 00:34:45,341
where the clouds actually are.

701
00:34:45,802 --> 00:34:48,383
And in reality, they're directly overhead the island.

702
00:34:49,564 --> 00:34:51,946
We tried to raymarch shadows from the G-buffer,

703
00:34:52,026 --> 00:34:53,167
but that was far too costly.

704
00:34:53,727 --> 00:34:56,730
The solution we landed upon was projected cloud shadows.

705
00:34:57,210 --> 00:34:59,732
It was a simple orthographic projection, nothing fancy.

706
00:35:00,172 --> 00:35:01,893
And the resulting shadow texture will

707
00:35:01,913 --> 00:35:04,135
be used later on for volumetric fog

708
00:35:04,495 --> 00:35:06,176
to get light shafts from the clouds.

709
00:35:07,435 --> 00:35:09,756
And here we have the clouds on the ground

710
00:35:10,576 --> 00:35:11,456
and also on the water.

711
00:35:12,937 --> 00:35:14,357
Next, we have the volumetric fog,

712
00:35:14,397 --> 00:35:17,838
which is used for environmental height fog, as well as local

713
00:35:17,878 --> 00:35:19,078
fog from the weather presets.

714
00:35:20,218 --> 00:35:23,359
Our implementation uses a frustum-aligned voxel grid

715
00:35:23,959 --> 00:35:25,019
presented in prior work.

716
00:35:25,840 --> 00:35:28,760
We have local and global fog based on weather,

717
00:35:28,920 --> 00:35:31,141
as well as local fog used for different biomes.

718
00:35:32,544 --> 00:35:38,566
With the volumetric fog, light shafts are created by shadows evaluated within the cells of the volume.

719
00:35:39,066 --> 00:35:40,767
And here is where we have some problems.

720
00:35:41,807 --> 00:35:44,448
Here's a brief overview of the volumetric fog process.

721
00:35:45,149 --> 00:35:48,930
We prepare our scene depth information in the first three steps shown

722
00:35:49,490 --> 00:35:52,711
and call local fog volumes to screen tiles,

723
00:35:53,131 --> 00:35:55,732
and then we'll cover the remaining steps in the following slides.

724
00:35:56,893 --> 00:35:59,053
We fill the cells with a radiance.

725
00:36:00,159 --> 00:36:08,527
And we do so using the local and global densities of fog and fog particles, as well as lighting from the sun, atmosphere, indirect lighting, point and spotlights.

726
00:36:09,949 --> 00:36:21,300
Note that we use temporal filtering on last gen instead of the upcoming bilateral blur and this would require a history buffer that is reprojected into the current frame and faded out over time.

727
00:36:22,025 --> 00:36:24,626
This requires more memory and is unfortunately,

728
00:36:25,606 --> 00:36:28,327
has some ghosting artifacts, but it was a cheaper solution.

729
00:36:28,867 --> 00:36:30,668
We also use the same phase function

730
00:36:31,248 --> 00:36:32,209
as the volumetric clouds.

731
00:36:32,909 --> 00:36:34,629
Here, you can see us filling the volume.

732
00:36:37,611 --> 00:36:39,511
After we fill the cells with irradiance,

733
00:36:40,272 --> 00:36:43,253
we calculate the continuous sum towards the back of the volume.

734
00:36:44,353 --> 00:36:48,214
Now, we can sample any voxel for full irradiance accumulation

735
00:36:48,395 --> 00:36:50,395
from the eye to the destination.

736
00:36:51,651 --> 00:36:54,613
And finally, on NextGen, we do a two-stage process

737
00:36:54,673 --> 00:36:56,994
of a bilateral blur in the x and y-axis.

738
00:36:57,535 --> 00:37:00,196
Blurring in the x-axis outputs transposed,

739
00:37:00,696 --> 00:37:04,098
and blurring in the x-axis transposes back

740
00:37:04,159 --> 00:37:05,820
to the original orientation.

741
00:37:06,960 --> 00:37:09,001
This optimizes reads and writes of the textures.

742
00:37:09,982 --> 00:37:10,843
But there's still a problem.

743
00:37:11,383 --> 00:37:12,924
On the right, you can see stair-stepping

744
00:37:13,044 --> 00:37:15,645
in the light shafts, which is an artifact of sampling

745
00:37:15,725 --> 00:37:16,226
the shadows.

746
00:37:17,194 --> 00:37:18,795
We want this to be completely smooth,

747
00:37:18,955 --> 00:37:21,397
and the bilateral filtering helps,

748
00:37:21,477 --> 00:37:22,938
but it doesn't completely solve this.

749
00:37:23,699 --> 00:37:26,641
The next approach we had was to blur the actual shadow maps.

750
00:37:27,462 --> 00:37:28,863
And one benefit of this approach is

751
00:37:28,923 --> 00:37:31,045
that it can be reused in multiple places.

752
00:37:32,273 --> 00:37:35,074
Here we see the process for exponential blurred shadows.

753
00:37:35,874 --> 00:37:39,055
First, we convert and downsample three near-shadow slices

754
00:37:39,135 --> 00:37:41,655
from our cascade shadow map from the sun.

755
00:37:42,335 --> 00:37:44,836
Then we blur the slices and downsample again.

756
00:37:45,296 --> 00:37:47,816
As you can see, the result is significantly smaller

757
00:37:47,977 --> 00:37:50,597
than the original, which is more optimal for quality

758
00:37:50,617 --> 00:37:52,497
and performance when volumetrically sampling.

759
00:37:53,518 --> 00:37:55,898
Let's take a look at a sample scene with no fog

760
00:37:56,038 --> 00:37:56,898
from our weather manager.

761
00:37:57,838 --> 00:37:59,879
Here we have the fog on its own with some less

762
00:37:59,899 --> 00:38:00,939
than ideal artifacting.

763
00:38:02,078 --> 00:38:04,279
This is the result of blurring the irradiance volume

764
00:38:04,319 --> 00:38:04,999
and screen space.

765
00:38:05,259 --> 00:38:06,899
It's better, but there's still artifacts

766
00:38:06,919 --> 00:38:08,640
that suggest the shape of the voxels.

767
00:38:09,500 --> 00:38:12,401
And finally, we enable the exponential blurred shadows.

768
00:38:14,021 --> 00:38:15,322
To this point, we have not mentioned

769
00:38:15,342 --> 00:38:16,882
how we actually apply the clouds.

770
00:38:17,322 --> 00:38:20,643
We apply atmospherics, clouds, and fog at the same time

771
00:38:20,964 --> 00:38:23,944
to save on bandwidth when writing to areas of the screen

772
00:38:23,984 --> 00:38:25,045
where both are visible.

773
00:38:25,945 --> 00:38:27,906
You can see here that the cloud shadows

774
00:38:27,946 --> 00:38:30,366
give nice light shafts in the fog.

775
00:38:31,603 --> 00:38:33,844
One final detail of our composite pass

776
00:38:33,924 --> 00:38:36,745
is that we apply the final value with blue noise

777
00:38:36,845 --> 00:38:38,165
at the final screen resolution.

778
00:38:38,765 --> 00:38:41,666
This combined with the temporal AA post-process

779
00:38:42,326 --> 00:38:44,226
further eliminates ray marching artifacts

780
00:38:44,406 --> 00:38:45,287
visible in the clouds.

781
00:38:46,327 --> 00:38:47,527
Now let's talk about reflections.

782
00:38:47,807 --> 00:38:50,268
Reflections are crucial to completing

783
00:38:50,288 --> 00:38:51,548
the visual concept of wetness.

784
00:38:52,128 --> 00:38:54,809
As Emily mentioned before, we used values

785
00:38:54,949 --> 00:38:58,190
from the weather system to determine what surfaces are wet.

786
00:38:59,186 --> 00:39:01,947
Then we perform the process where rays are path traced

787
00:39:02,067 --> 00:39:04,108
using the G-buffer positions and normals

788
00:39:04,468 --> 00:39:06,409
to pixels and screen space to be reflected.

789
00:39:07,469 --> 00:39:09,690
This does most of the work of reflecting objects

790
00:39:09,951 --> 00:39:12,612
in the scene, such as trees, sky, and clouds

791
00:39:12,972 --> 00:39:16,073
on the surface of the road, as well as the mountains shown

792
00:39:16,113 --> 00:39:16,893
on the water surface.

793
00:39:17,294 --> 00:39:19,515
For more information about our SSLR,

794
00:39:20,075 --> 00:39:22,016
as well as our hybrid ray tracing solution,

795
00:39:22,396 --> 00:39:24,257
see my colleagues Stephanie and Ihor

796
00:39:24,537 --> 00:39:27,218
talk about performant reflective beauty in their talk.

797
00:39:29,740 --> 00:39:31,541
But what happens when we don't have enough data

798
00:39:31,661 --> 00:39:35,264
for screen space reflections, such as when we view water

799
00:39:35,344 --> 00:39:36,564
at the angle shown on the right?

800
00:39:37,885 --> 00:39:40,146
We need a fallback where there is no data

801
00:39:40,627 --> 00:39:42,108
to drive the screen space reflections.

802
00:39:42,908 --> 00:39:44,809
Our fallback comes in the form of cubemaps,

803
00:39:45,309 --> 00:39:48,211
which need to show time of day changes, weather, clouds,

804
00:39:49,272 --> 00:39:52,133
as shown in the sunset reflection on the cloud,

805
00:39:52,334 --> 00:39:54,155
or the car on the right.

806
00:39:55,349 --> 00:39:58,812
Our QMaps are generated at build time in positions determined

807
00:39:58,852 --> 00:40:01,535
by artists, and they need to be relit

808
00:40:01,595 --> 00:40:04,097
with our atmospheric scattering, clouds, and fog.

809
00:40:05,679 --> 00:40:10,143
QMap data is baked and stored as albedo, normal, and smoothness,

810
00:40:10,263 --> 00:40:12,325
as well as a lower resolution depth map.

811
00:40:12,950 --> 00:40:21,673
To achieve acceptable performance, we relight just one face of the cubemap each frame, except in special cases such as cinematic camera cuts.

812
00:40:22,433 --> 00:40:28,675
The process starts with generating a sky-only cubemap containing only atmospheric scattering, clouds, and fog.

813
00:40:29,416 --> 00:40:35,778
Then, the sky-only cubemap for our fallback reflection is used on our ocean.

814
00:40:37,108 --> 00:40:39,369
Then we were like the scene using,

815
00:40:39,389 --> 00:40:42,810
sorry, the scene face using the baked cubemap data.

816
00:40:42,990 --> 00:40:45,490
And finally, we composite the sky cubemap

817
00:40:45,610 --> 00:40:47,871
into the relit scene cubemap,

818
00:40:48,251 --> 00:40:50,792
giving the final result shown in the bottom right.

819
00:40:51,452 --> 00:40:53,492
We progressively update a single face,

820
00:40:54,192 --> 00:40:56,653
each frame attempting to process cubemaps

821
00:40:56,693 --> 00:40:57,873
when streaming in new areas.

822
00:40:58,893 --> 00:41:00,194
After the relighting process,

823
00:41:00,274 --> 00:41:03,594
cubemaps need to be filtered for blurrier reflections

824
00:41:04,014 --> 00:41:04,835
on rougher surfaces.

825
00:41:06,490 --> 00:41:09,492
One large problem that we had was overcast lighting and weather.

826
00:41:10,133 --> 00:41:13,795
Sometimes it was just, it just wasn't dark enough and it could appear flat.

827
00:41:14,816 --> 00:41:19,940
We want the clouds to have contrast and we also want to have blue sky breaking through.

828
00:41:20,501 --> 00:41:22,502
There were several reasons why this was happening.

829
00:41:22,642 --> 00:41:26,886
One such example was our authored sky were too turbid and gray.

830
00:41:27,366 --> 00:41:32,870
If you want blue in your scene, in your natural lighting, essentially, it comes from here.

831
00:41:34,352 --> 00:41:35,052
But be careful.

832
00:41:35,212 --> 00:41:38,852
There are otherwise, if you put too much blue,

833
00:41:39,093 --> 00:41:41,793
then your whole scene will get too blue.

834
00:41:42,793 --> 00:41:45,254
We also had issues with the fog washing out the image.

835
00:41:45,554 --> 00:41:48,234
And to fix this, we fade fog based on cloud coverage.

836
00:41:49,015 --> 00:41:52,235
We had skylighting that was too bright because the clouds never

837
00:41:52,275 --> 00:41:53,655
reached the horizon in the cube map.

838
00:41:53,755 --> 00:41:57,036
And there's also a blue band in our cube maps

839
00:41:57,076 --> 00:41:59,036
that contributes to this brightness.

840
00:42:00,117 --> 00:42:01,657
Clouds of uniform thickness.

841
00:42:03,228 --> 00:42:08,415
could also wash out the image, which is why we limit the cumulus coverage to 0.8 even in a storm.

842
00:42:10,158 --> 00:42:13,623
So now let's move our attention to rain. Remember, the weather system

843
00:42:14,063 --> 00:42:18,429
keeps track of a rain factor that we use to drive our particle systems.

844
00:42:19,272 --> 00:42:24,273
it was very apparent early on that our existing CPU particle system would not be able to produce

845
00:42:24,313 --> 00:42:29,595
the number of particles that we wanted for rain. Therefore, we set out to create a GPU particle

846
00:42:29,635 --> 00:42:34,437
system to render rain effects, and in doing so, we ended up with a generalized system

847
00:42:34,797 --> 00:42:36,758
that supported many other types of effects as well.

848
00:42:37,717 --> 00:42:40,098
Here's a brief overview of our particle system

849
00:42:40,239 --> 00:42:41,179
you can refer to later.

850
00:42:41,679 --> 00:42:44,781
In summary, we use compute shaders to emit, simulate,

851
00:42:44,881 --> 00:42:48,123
sort and render all of the particles on the GPU

852
00:42:48,183 --> 00:42:49,984
with minimal interaction with the CPU.

853
00:42:50,824 --> 00:42:53,005
For any particle system, you need billboards

854
00:42:53,145 --> 00:42:55,106
or geometry rendered in the right order.

855
00:42:56,114 --> 00:43:00,276
Our solution was a bitonic sort to order the particles all at once.

856
00:43:00,817 --> 00:43:02,737
This algorithm is massively parallel.

857
00:43:02,898 --> 00:43:06,700
And while it has a higher average cost than something like a radix sort,

858
00:43:07,260 --> 00:43:09,801
it was one of the lowest worst costs,

859
00:43:10,161 --> 00:43:13,583
which is important in game development to avoid frame time spikes.

860
00:43:14,604 --> 00:43:18,526
Once we have a set of visible particles sorted and ready to render,

861
00:43:19,366 --> 00:43:22,768
we need to filter which particles need to be rendered in which paths.

862
00:43:23,915 --> 00:43:27,700
We used a prefix sum algorithm to effectively eliminate

863
00:43:27,740 --> 00:43:31,865
the empty space in a buffer to a sorted list

864
00:43:32,025 --> 00:43:35,470
of visible particles that are just for a single pass.

865
00:43:36,251 --> 00:43:39,075
This is also a highly parallelized algorithm

866
00:43:39,155 --> 00:43:39,976
perfect for the GPU.

867
00:43:41,491 --> 00:43:43,132
Let's go through some of the particle effects

868
00:43:44,133 --> 00:43:45,234
that we had for rain.

869
00:43:45,775 --> 00:43:47,376
The first particle effect we want to look at

870
00:43:47,416 --> 00:43:48,137
is the rain streaks.

871
00:43:48,657 --> 00:43:52,100
We experimented with refraction, blur, and reflections,

872
00:43:52,200 --> 00:43:54,062
but we ultimately used transparent textures

873
00:43:54,622 --> 00:43:57,364
to achieve the look of rain in photography, which was

874
00:43:58,105 --> 00:43:59,046
part of our art direction.

875
00:43:59,846 --> 00:44:02,729
We used two frames of variation and a normal texture

876
00:44:02,769 --> 00:44:03,529
to aid in the lighting.

877
00:44:04,110 --> 00:44:06,692
We recycle rain streaks in a cylinder around the player

878
00:44:06,772 --> 00:44:09,314
to ensure the number of rain particles remains consistent,

879
00:44:10,044 --> 00:44:11,925
regardless of how fast the camera is whooping.

880
00:44:12,465 --> 00:44:14,687
To add continuous variation to the particles

881
00:44:15,407 --> 00:44:18,310
throughout their lifetimes, we used a 3D noise texture

882
00:44:18,710 --> 00:44:20,711
mapped to world space as turbulence.

883
00:44:21,332 --> 00:44:23,834
And finally, the emission rate and direction of the rain

884
00:44:23,974 --> 00:44:27,076
is determined by the wind values provided from the weather

885
00:44:27,096 --> 00:44:27,456
manager.

886
00:44:28,857 --> 00:44:30,959
Since we had many indoor and outdoor environments,

887
00:44:31,039 --> 00:44:33,421
we needed to occlude rain where it was not plausible.

888
00:44:33,721 --> 00:44:35,602
To do this, we created a rain shadow map.

889
00:44:36,197 --> 00:44:40,281
that we can reference to determine if a rain shriek or splash was occluded.

890
00:44:41,041 --> 00:44:44,865
This was a directional shadow set up to cover the playable area near the camera

891
00:44:45,366 --> 00:44:46,607
parallel to the rain direction.

892
00:44:47,428 --> 00:44:52,052
Then we stored this in our regular sunshadow atlas shown on the right.

893
00:44:52,875 --> 00:44:54,837
And the colored image on the left

894
00:44:55,298 --> 00:44:58,941
is used as a lookup table to convert UV space

895
00:44:59,222 --> 00:45:00,463
into the atlas texture.

896
00:45:01,324 --> 00:45:03,766
The rain shadow map only contains static scene elements

897
00:45:03,826 --> 00:45:05,988
and is updated in sections each frame.

898
00:45:07,350 --> 00:45:08,991
The next particle effect we want to talk about

899
00:45:09,291 --> 00:45:11,414
is splashes that appear when rain hits

900
00:45:11,954 --> 00:45:13,075
a surface near the camera.

901
00:45:13,871 --> 00:45:19,914
Initially, this was driven by a GPU particle event system, which emits new particles when

902
00:45:19,934 --> 00:45:23,537
a parent particle hits a surface on the depth buffer, terrain, or water.

903
00:45:24,657 --> 00:45:28,639
And this means we get splash particles on any surface which is opaque, including vehicles,

904
00:45:28,679 --> 00:45:29,600
characters, and weapons.

905
00:45:30,040 --> 00:45:34,343
However, we didn't necessarily want these splashes to be on sides of buildings, so we

906
00:45:34,363 --> 00:45:35,603
incorporated a slope factor.

907
00:45:36,565 --> 00:45:42,332
Another problem that we had was we weren't getting enough splashes because not every particle we checked for collision would generate a splash.

908
00:45:42,792 --> 00:45:48,158
So therefore, we spawned more particles in a volume around the camera and snapped them to the depth buffer.

909
00:45:49,320 --> 00:45:53,024
For both rain streaks and splashes, we wanted pixel lighting, especially at night.

910
00:45:53,405 --> 00:45:56,628
However, this was far too expensive and vertex lighting just wasn't good enough.

911
00:45:57,183 --> 00:46:01,886
What we did was create a system for generating spherical harmonic light probes for each vertex

912
00:46:02,266 --> 00:46:10,131
of the particle. Each of these probes calculates third-order SH coefficients and incorporates sun,

913
00:46:10,672 --> 00:46:14,434
point, and spotlights. This gives us better than vertex lighting,

914
00:46:14,774 --> 00:46:16,235
but is much cheaper than pixel lighting.

915
00:46:16,756 --> 00:46:22,380
In addition, we can sample normal maps of particles for directional lighting and better specular highlights.

916
00:46:22,860 --> 00:46:31,186
Here we see an example of a particle billboard of a sphere on the right, and it only has a diffuse and normal texture.

917
00:46:32,762 --> 00:46:35,882
The next particle effect we needed was lightning bolts for our thunderstorms.

918
00:46:36,483 --> 00:46:42,264
For this effect, we created a ribbon or trail system. We started by creating trails automatically

919
00:46:42,644 --> 00:46:47,166
left by individual particles, but extended this by generating particles and tessellating

920
00:46:47,206 --> 00:46:51,967
geometry between each particle. We call these linked emitters. Using the linked system,

921
00:46:52,107 --> 00:46:56,168
we emitted particles in the cylinder moving from top to bottom, increasing the turbulence

922
00:46:56,568 --> 00:47:01,390
in the center of the volume and fading out at each end. But this alone was not very realistic.

923
00:47:02,098 --> 00:47:04,999
we needed to make the lightning effect the world around it.

924
00:47:05,800 --> 00:47:08,361
First, we generated an omni light and placed it in the scene

925
00:47:08,661 --> 00:47:10,922
so that lightning would light the environment.

926
00:47:11,243 --> 00:47:14,524
Then we had to address the clouds around the lightning bolt.

927
00:47:14,924 --> 00:47:17,806
We applied lightning to the clouds in the upsample pass

928
00:47:18,166 --> 00:47:20,427
so that lightning doesn't end up in the history buffer

929
00:47:20,627 --> 00:47:21,588
and cause ghosting.

930
00:47:22,209 --> 00:47:27,276
And in order to determine where in the clouds to add light,

931
00:47:27,576 --> 00:47:29,959
we use sun scattering factor that we

932
00:47:29,999 --> 00:47:33,103
saved in the green channel of the cloud ray marching pass.

933
00:47:33,384 --> 00:47:36,208
And our implementation functions essentially like a column light.

934
00:47:37,383 --> 00:47:39,144
The next rendering feature is the ocean.

935
00:47:39,664 --> 00:47:41,365
Improvements we made to the ocean rendering

936
00:47:41,405 --> 00:47:43,726
were mostly to support the tropical environment.

937
00:47:44,106 --> 00:47:45,967
However, ocean still needed to be affected

938
00:47:46,007 --> 00:47:49,069
by weather in two ways, Beaufort level and wind direction.

939
00:47:49,569 --> 00:47:51,470
Our previous screen space tessellation

940
00:47:51,750 --> 00:47:54,311
had issues with shoreline waves whenever the ocean was

941
00:47:54,371 --> 00:47:55,631
parallel to the view direction.

942
00:47:56,632 --> 00:47:58,533
It lacked a lot of detail in the distance.

943
00:47:59,053 --> 00:48:02,214
And for more information on our previous implementation,

944
00:48:02,254 --> 00:48:04,295
you can see a previous GDC talk we had.

945
00:48:06,053 --> 00:48:11,515
So we added a new type of tessellation to support sharp waves for weather and improve the distance

946
00:48:11,535 --> 00:48:16,598
visual and support shoreline waves. The tessellation we chose for our ocean was the

947
00:48:16,798 --> 00:48:22,000
i-sub-d tessellation scheme. This basic algorithm subdivides the ocean mesh into

948
00:48:22,281 --> 00:48:27,023
a from the single two triangle quad down to subdivided triangles you see near the camera.

949
00:48:27,664 --> 00:48:31,706
It is a progressive refinement algorithm that will subdivide into smaller triangles,

950
00:48:32,326 --> 00:48:37,209
each frame as they get closer to the camera, and merge into larger ones as they get further away.

951
00:48:38,950 --> 00:48:42,432
There is a performance limit on the number of operations that can be done every frame,

952
00:48:42,772 --> 00:48:46,274
so we fill a buffer with keys to perform these operations.

953
00:48:46,814 --> 00:48:49,376
This led to a list of a lot of empty space.

954
00:48:50,282 --> 00:48:56,286
This was an area of the sub-D algorithm that we found to be unsolved, and we needed a solution to this problem.

955
00:48:56,306 --> 00:49:01,329
So we used the same prefix sum algorithm from the GPU particle filtering on a different type of data.

956
00:49:02,029 --> 00:49:04,711
In our world, we have fresh water that meets the ocean,

957
00:49:04,751 --> 00:49:09,213
therefore we needed to blend the previous screen space tessellation to the sub-D tessellation.

958
00:49:09,694 --> 00:49:18,381
To do this, we use the displacement and normals of the fresh water as input in the intersections of this tessellation type and blended in that range.

959
00:49:18,961 --> 00:49:23,765
And then we use simple stencil testing to avoid redundant pixel shading of the water meshes.

960
00:49:24,646 --> 00:49:29,630
The Beaufort scale is a empirical system that relates wind speed to its effect on bodies of water.

961
00:49:30,230 --> 00:49:35,595
Here we show how Beaufort levels coming from the weather manager can impact the look of the water.

962
00:49:35,855 --> 00:49:37,496
And this is going to be Beaufort level 0 to 4.

963
00:49:39,221 --> 00:49:42,003
The Beaufort levels themselves are tuned with data

964
00:49:42,043 --> 00:49:43,905
such as wind speed, amplitude, and scale,

965
00:49:44,065 --> 00:49:44,905
as well as choppiness.

966
00:49:45,626 --> 00:49:46,667
That was Beaufort level 1.

967
00:49:46,967 --> 00:49:48,228
And here's the value.

968
00:49:48,848 --> 00:49:51,611
Sorry, these values are used to drive the wave simulations,

969
00:49:51,691 --> 00:49:52,531
which we will show later.

970
00:49:53,292 --> 00:49:56,134
The Beaufort level also includes settings for shoreline waves,

971
00:49:56,514 --> 00:49:59,296
such as amplitude, frequency, speed, steepness,

972
00:49:59,336 --> 00:50:00,057
and number of waves.

973
00:50:00,838 --> 00:50:02,459
The Beaufort levels include settings

974
00:50:02,499 --> 00:50:04,240
for foam, which you can see accumulating

975
00:50:04,280 --> 00:50:06,162
alongside the increased wave size.

976
00:50:06,462 --> 00:50:07,283
And this is Beaufort level 4.

977
00:50:08,516 --> 00:50:10,338
Here we have the ocean wave buffers

978
00:50:10,418 --> 00:50:11,579
that we generate every frame

979
00:50:11,619 --> 00:50:13,040
in order to create motion in the waves.

980
00:50:13,620 --> 00:50:16,322
These buffers can be mapped back and read on the CPU

981
00:50:16,423 --> 00:50:18,364
for physics calculations, ocean level,

982
00:50:18,805 --> 00:50:19,705
sorry, and ocean level,

983
00:50:20,126 --> 00:50:22,107
but we disabled this due to performance limits.

984
00:50:22,648 --> 00:50:24,409
The world space FBM was created

985
00:50:24,489 --> 00:50:26,411
to get sharp waves up close near the camera.

986
00:50:27,051 --> 00:50:28,252
Using the world space buffer,

987
00:50:29,333 --> 00:50:30,474
sorry, using a world space buffer

988
00:50:30,514 --> 00:50:33,397
gave us the ability to generate normal directly

989
00:50:33,477 --> 00:50:35,498
instead of from screen space like we did previously.

990
00:50:36,091 --> 00:50:40,633
This gave us better details up close as well as in the distance with mipmapping.

991
00:50:41,214 --> 00:50:44,256
Next, we used the FFT simulation for waves in the distance.

992
00:50:44,496 --> 00:50:48,298
We adjusted our original implementation to respond to Beaufort level and wind parameters.

993
00:50:48,899 --> 00:50:52,941
We also added the accumulation channel to the texture to create persistent white caps

994
00:50:53,041 --> 00:50:53,482
on the waves.

995
00:50:54,062 --> 00:50:58,505
To prevent tiling in the distance, we used the FFT buffer as a cascade at a different

996
00:50:58,525 --> 00:51:01,226
scale as well as a Perlin noise wave texture.

997
00:51:03,917 --> 00:51:05,859
Here we see the FFT buffer we started with.

998
00:51:06,099 --> 00:51:07,401
Notice the tiling in the distance.

999
00:51:07,881 --> 00:51:09,763
Then we have the FFT cascading,

1000
00:51:10,504 --> 00:51:12,867
the FFT cascade eliminating some of the tiling.

1001
00:51:13,388 --> 00:51:15,650
And finally, we have the scrolling Perlin noise texture,

1002
00:51:16,571 --> 00:51:18,113
which is removing the rest of the tiling.

1003
00:51:18,173 --> 00:51:21,076
It does a good job of simulating the effects of wind

1004
00:51:21,176 --> 00:51:23,219
on large patches of water in the distance.

1005
00:51:23,892 --> 00:51:28,476
Related to the new ocean tech was the inclusion of shoreline waves, which we needed for our

1006
00:51:28,496 --> 00:51:35,443
tropical beaches. We had far too many shorelines to cover, so we needed a procedural method,

1007
00:51:35,983 --> 00:51:38,866
which led us to choose the Gershner wave formula.

1008
00:51:40,887 --> 00:51:45,311
We used multiple parameters such as amplitude, speed, and foam to control the visuals.

1009
00:51:46,705 --> 00:51:48,506
The last rendering feature we'd like to talk about

1010
00:51:48,926 --> 00:51:51,527
is the tree bending, which works in conjunction

1011
00:51:51,647 --> 00:51:54,088
with the wind direction and magnitude coming

1012
00:51:54,108 --> 00:51:55,088
from the weather manager.

1013
00:51:55,548 --> 00:51:57,369
We improved the tree bending settings

1014
00:51:57,429 --> 00:51:59,730
by adding noise and bending amplitudes.

1015
00:52:00,250 --> 00:52:02,350
Combined with the wind values, this

1016
00:52:02,410 --> 00:52:05,151
gives us an exaggerated movement in the trees that reflects

1017
00:52:05,471 --> 00:52:06,852
our stormy weather conditions.

1018
00:52:07,692 --> 00:52:09,593
These settings are controlled by artists

1019
00:52:10,013 --> 00:52:11,673
when setting up tree trunk skeletons.

1020
00:52:12,557 --> 00:52:15,718
The movement could sometimes exceed the tree's bounding box,

1021
00:52:16,138 --> 00:52:19,599
which could be problematic because they could suddenly

1022
00:52:19,619 --> 00:52:20,099
be cold.

1023
00:52:20,459 --> 00:52:24,180
And ultimately, the feature was limited

1024
00:52:24,260 --> 00:52:28,802
by being plausible when zooming into the distance.

1025
00:52:29,282 --> 00:52:31,623
To conclude, we'd like to share some of our final thoughts

1026
00:52:32,063 --> 00:52:35,544
from both tech and from tech art and programming perspectives.

1027
00:52:38,758 --> 00:52:43,182
For me, things that really drove our success were limiting the complexity,

1028
00:52:43,783 --> 00:52:48,567
studying references, reducing production dependencies wherever possible, and

1029
00:52:48,607 --> 00:52:52,531
identifying the biggest wins so that we could focus on what sells the weather the most.

1030
00:52:53,477 --> 00:52:56,217
For future work, we could simplify the database further.

1031
00:52:57,178 --> 00:52:58,678
We could also set up an easier way

1032
00:52:58,718 --> 00:53:01,539
to debug and review weather without overrides confusing us.

1033
00:53:02,179 --> 00:53:04,199
We could make more use of wetness effects

1034
00:53:04,359 --> 00:53:06,260
and push our presets to be more extreme.

1035
00:53:06,860 --> 00:53:08,460
And lastly, we could always investigate

1036
00:53:08,520 --> 00:53:10,181
procedural weather patterns as opposed

1037
00:53:10,201 --> 00:53:11,681
to our hard-coded forecasts.

1038
00:53:14,342 --> 00:53:14,862
Thank you, Emily.

1039
00:53:16,467 --> 00:53:19,729
For rendering takeaways, as you saw, there was a lot of tech to maintain.

1040
00:53:20,310 --> 00:53:24,093
There were a lot of interlocking parts which needed to be polished both separately and together.

1041
00:53:24,113 --> 00:53:28,777
The biggest recommendation we have is to finalize these things early.

1042
00:53:29,237 --> 00:53:31,959
That means your data formats, data and processes.

1043
00:53:32,440 --> 00:53:35,042
You don't want any of these things changing too far into production.

1044
00:53:35,637 --> 00:53:38,119
For future work, there were several things listed,

1045
00:53:38,619 --> 00:53:40,240
but one thing I find most interesting

1046
00:53:40,340 --> 00:53:43,703
would be to use the same tessellation for both water

1047
00:53:44,003 --> 00:53:48,027
and terrain and use the same atlas for virtual texturing.

1048
00:53:49,788 --> 00:53:51,790
We would quickly like to thank the 3D teams who

1049
00:53:51,830 --> 00:53:54,112
worked on this feature and everyone who

1050
00:53:54,152 --> 00:53:55,113
helped us along the way.

1051
00:53:55,733 --> 00:53:57,274
As you can see, it was a collective effort.

1052
00:53:58,636 --> 00:54:00,457
Here's a list of references for the talk.

1053
00:54:01,098 --> 00:54:02,539
And with that, we'd like to close out

1054
00:54:02,579 --> 00:54:04,260
with a video of our final results.

1055
00:54:39,303 --> 00:54:40,970
All right, thank you for joining us today.

1056
00:54:40,990 --> 00:54:44,104
Are there any questions?

1057
00:55:01,097 --> 00:55:02,138
Thank you for a nice talk.

1058
00:55:03,319 --> 00:55:06,823
I'd like to ask about the QMAP relighting.

1059
00:55:07,403 --> 00:55:11,427
How did you handle shadow maps for relight QMAP?

1060
00:55:11,667 --> 00:55:18,775
I believe shadow map is outside and then shadow map is

1061
00:55:18,855 --> 00:55:21,758
assigned to main view custom areas.

1062
00:55:23,063 --> 00:55:27,568
Yeah, so one of the things that we noted in our problem section with overcast

1063
00:55:27,628 --> 00:55:30,972
lighting was that we don't have any shadowing in our cube maps.

1064
00:55:31,813 --> 00:55:33,756
So, yeah, we didn't have any shadowing.

1065
00:55:34,036 --> 00:55:36,539
That's something we'd like to add in the future. Thank you.

1066
00:55:41,578 --> 00:55:44,320
Hey, great talk and a lot of awesome information. Thanks for doing it.

1067
00:55:44,340 --> 00:55:49,663
I had a quick question. You mentioned you had some undesirable effects when in interior spaces with some of the weather

1068
00:55:49,763 --> 00:55:55,507
and that that led to constraints on sort of how you were working with like the fog disappearing through windows and stuff.

1069
00:55:55,947 --> 00:56:01,170
What sort of solutions and constrictions did that put on like your concave spaces and interior spaces?

1070
00:56:04,500 --> 00:56:10,786
So for our zones specifically, we did run into a lot of issues, particularly for the indoor zones.

1071
00:56:11,567 --> 00:56:16,912
As we mentioned, the change happened immediately. So you will see these changes if you have windows.

1072
00:56:17,072 --> 00:56:23,599
What we did was if there's ever an open space or an area with windows, we made another zone,

1073
00:56:23,919 --> 00:56:25,741
essentially, where we would solve these issues.

1074
00:56:29,730 --> 00:56:32,173
Hello, great talk by the way, it was very informative.

1075
00:56:33,234 --> 00:56:34,936
My question was related to performance.

1076
00:56:35,517 --> 00:56:37,600
It sounds like there was a lot of features

1077
00:56:37,620 --> 00:56:40,243
that you had to add to the base shaders

1078
00:56:40,303 --> 00:56:41,985
to get all this wetness and stuff.

1079
00:56:42,826 --> 00:56:44,829
Were there any challenges regarding optimization

1080
00:56:44,849 --> 00:56:46,711
and keeping that running at all times

1081
00:56:46,771 --> 00:56:48,153
to dynamically switch between things?

1082
00:56:50,879 --> 00:57:00,686
Yeah, so I would say optimization wise, everything had to be designed so that your cost would not increase when the weather turned on.

1083
00:57:00,786 --> 00:57:11,314
So like Emily talked about with dynamic wetness, we had to assume the cost with the trees to be.

1084
00:57:12,240 --> 00:57:15,521
wet dynamically as part of that cost.

1085
00:57:15,681 --> 00:57:21,064
So I guess the thing is we would have to optimize as much as possible,

1086
00:57:21,424 --> 00:57:25,485
but we essentially have wetness as something that could be turned on at any time.

1087
00:57:25,505 --> 00:57:27,806
Okay, thank you.

1088
00:57:29,325 --> 00:57:31,126
Awesome, thanks for the talk.

1089
00:57:31,146 --> 00:57:34,429
I was very curious about your static wetness specifically

1090
00:57:34,449 --> 00:57:36,450
because it sounded to me like you

1091
00:57:36,470 --> 00:57:39,752
were doing that as a deferred rendering pass instead

1092
00:57:39,773 --> 00:57:41,434
of complicating your materials.

1093
00:57:41,674 --> 00:57:43,795
And I just wanted to make sure that I understood that

1094
00:57:43,836 --> 00:57:44,236
correctly.

1095
00:57:44,276 --> 00:57:44,756
Is that true?

1096
00:57:46,297 --> 00:57:48,119
Yes, so basically in every shader,

1097
00:57:48,219 --> 00:57:50,601
we would be assigning the gbuffer properties.

1098
00:57:51,101 --> 00:57:52,902
And then in our deferred lighting passes

1099
00:57:52,942 --> 00:57:55,024
where we would assemble all these properties

1100
00:57:55,204 --> 00:57:56,145
and perform the lighting.

1101
00:57:56,747 --> 00:57:58,269
So what we did was just basically

1102
00:57:58,410 --> 00:58:00,353
defer our wetness solution.

1103
00:58:00,433 --> 00:58:02,296
So instead of applying it in every shader,

1104
00:58:02,797 --> 00:58:05,061
which would incur some more costs each time,

1105
00:58:05,742 --> 00:58:06,523
we do it all at once.

1106
00:58:07,905 --> 00:58:08,166
Awesome.

1107
00:58:12,184 --> 00:58:13,606
I just had a quick question.

1108
00:58:14,247 --> 00:58:17,171
Thank you for the talk, by the way, really, really informative.

1109
00:58:17,191 --> 00:58:18,933
I had a quick question.

1110
00:58:19,474 --> 00:58:22,818
You render out a rain shadow map.

1111
00:58:23,038 --> 00:58:23,939
I was curious.

1112
00:58:25,642 --> 00:58:28,125
It doesn't seem like you reuse that for wetness.

1113
00:58:29,720 --> 00:58:33,301
No, that was specifically just for particles.

1114
00:58:34,641 --> 00:58:39,583
We tried to use it for other elements in the game like vehicles.

1115
00:58:40,123 --> 00:58:43,303
But as we said, it only included static information

1116
00:58:43,323 --> 00:58:47,104
because it would be far too costly to update that every frame.

1117
00:58:47,985 --> 00:58:50,365
So it's really just to give us directional

1118
00:58:51,365 --> 00:58:54,166
directional occlusion information for particles.

1119
00:58:54,506 --> 00:58:58,087
So essentially, you wouldn't see rain when there was an overhang

1120
00:58:58,127 --> 00:58:59,387
that would block it.

1121
00:58:59,747 --> 00:59:02,849
whether it's indoor, outdoor, or both in and outdoor.

1122
00:59:04,671 --> 00:59:04,991
Thank you.

1123
00:59:11,975 --> 00:59:12,236
Thank you.

1124
00:59:12,256 --> 00:59:12,476
Thank you.

1125
00:59:13,476 --> 00:59:19,521
Thank you.

