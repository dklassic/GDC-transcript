1
00:00:06,067 --> 00:00:07,968
The controls are unresponsive.

2
00:00:07,968 --> 00:00:13,272
These four words can be a death sentence for any video game.

3
00:00:13,272 --> 00:00:21,438
If you have unresponsive controls, it means unfair losses, frustration, players quitting, and of course, lots of bad reviews.

4
00:00:21,438 --> 00:00:24,840
But what are responsive controls?

5
00:00:24,840 --> 00:00:31,825
If it just means the game does what the player tells it to do, how hard could that be to implement?

6
00:00:32,522 --> 00:00:34,804
And how could so many games get it wrong?

7
00:00:34,804 --> 00:00:37,466
I mean, surely it's a simple thing.

8
00:00:37,466 --> 00:00:39,487
All you have to do is tell the game,

9
00:00:39,487 --> 00:00:41,809
hey, when the player presses right,

10
00:00:41,809 --> 00:00:44,891
have the character go right, right?

11
00:00:44,891 --> 00:00:45,371
Wrong.

12
00:00:45,371 --> 00:00:48,373
There's a lot more to it than that.

13
00:00:48,373 --> 00:00:51,596
Making a responsive game requires an additional touch.

14
00:00:51,596 --> 00:00:53,337
It requires you, the designer,

15
00:00:53,337 --> 00:00:54,858
to understand your players better

16
00:00:54,858 --> 00:00:56,579
than they understand themselves.

17
00:00:56,579 --> 00:01:01,042
It requires you to understand their inconsistencies

18
00:01:01,042 --> 00:01:01,883
and then forgive them.

19
00:01:02,968 --> 00:01:05,650
And I don't mean that in a philosophical way.

20
00:01:05,650 --> 00:01:08,531
I mean, literally, building forgiveness

21
00:01:08,531 --> 00:01:10,032
into the design of your game,

22
00:01:10,032 --> 00:01:12,674
so that even if your players aren't perfect,

23
00:01:12,674 --> 00:01:14,735
even if they make mistakes,

24
00:01:14,735 --> 00:01:16,697
they could still have a great time.

25
00:01:16,697 --> 00:01:17,978
My name is Seth Koster,

26
00:01:17,978 --> 00:01:20,719
and I'm a co-founder, designer, and game programmer

27
00:01:20,719 --> 00:01:22,040
at Butterscotch Shenanigans.

28
00:01:22,040 --> 00:01:24,302
Today, I'm gonna talk about our studio's journey

29
00:01:24,302 --> 00:01:27,023
through developing our upcoming platformer, Levelhead.

30
00:01:27,656 --> 00:01:33,859
and the ways that we incorporated forgiveness mechanics into the game's design to make it a truly enjoyable experience.

31
00:01:33,859 --> 00:01:37,021
Now we have a lot to cover, so let's just jump right in.

32
00:01:37,021 --> 00:01:42,644
Now about a month into Levelhead's development, Sam, our artist, was playing the game,

33
00:01:42,644 --> 00:01:47,867
and I noticed that he was having a hard time trying to bounce off of the enemy's heads.

34
00:01:47,867 --> 00:01:53,250
In Levelhead, as in many platformers, you can jump on an enemy to defeat it.

35
00:01:53,734 --> 00:01:58,896
and if you're holding the jump button when you land on its head, then you get a big aerial boost.

36
00:01:58,896 --> 00:02:04,297
But when Sam was playing, I saw that he wasn't always getting the boost.

37
00:02:04,297 --> 00:02:09,239
I asked him what was going on with that, because I'd never seen that before,

38
00:02:09,239 --> 00:02:15,580
and he just said, yeah, there's something inconsistent about bouncing off of enemies' heads,

39
00:02:15,580 --> 00:02:17,041
and it only seems to work half the time.

40
00:02:17,041 --> 00:02:17,521
So as the programmer,

41
00:02:20,047 --> 00:02:26,368
I got defensive because I knew that the underlying code was so simple that there was absolutely

42
00:02:26,368 --> 00:02:28,449
no way that it could be inconsistent.

43
00:02:28,449 --> 00:02:35,270
Either you hold the jump button and you get the boost, or you don't hold the jump button

44
00:02:35,270 --> 00:02:36,330
and you don't get the boost.

45
00:02:36,330 --> 00:02:39,331
I mean, that's textbook consistency.

46
00:02:39,331 --> 00:02:43,332
So I watched Sam play to figure out what was going on.

47
00:02:43,332 --> 00:02:44,052
And sure enough...

48
00:02:45,132 --> 00:02:50,594
he was not holding the jump button. Instead, he was trying to time it so that he was pressing jump

49
00:02:50,594 --> 00:02:56,095
in the exact moment that he hit the enemy. And about half the time, he would hit it too early,

50
00:02:56,095 --> 00:03:00,116
but he'd get the boost anyway because he was holding the button right as he touched the

51
00:03:00,116 --> 00:03:05,398
enemy's head. But the other half of the time, he would press the button after bouncing off

52
00:03:05,398 --> 00:03:11,659
the enemy's head, and then that wouldn't count. So as a designer, this kind of situation puts

53
00:03:11,659 --> 00:03:12,600
you at a crossroads.

54
00:03:13,347 --> 00:03:20,450
you know that your controls are consistent. So, you could just blame the player. You know,

55
00:03:20,450 --> 00:03:26,833
hold jump to bounce. If you don't hold jump, you don't bounce. The end. Or you can recognize the

56
00:03:26,833 --> 00:03:35,257
truth, which is that people are inconsistent. So, if your game demands consistent inputs,

57
00:03:35,257 --> 00:03:37,978
your players will not get consistent results.

58
00:03:39,167 --> 00:03:47,892
The philosophy of forgiveness mechanics tells us that we need to anticipate these inconsistent inputs and build them into the game's mechanics.

59
00:03:47,892 --> 00:03:57,397
People sometimes hit buttons too late, so let's just see if we can accommodate that by using a forgiveness mechanic called the Coyote Jump.

60
00:03:59,245 --> 00:04:03,547
Under the original setup, we just had a true false variable

61
00:04:03,547 --> 00:04:06,209
called canJump inside the player.

62
00:04:06,209 --> 00:04:08,510
And if it was true, you could jump.

63
00:04:08,510 --> 00:04:09,790
And if it was false, you couldn't.

64
00:04:09,790 --> 00:04:12,672
And we would set that variable to true

65
00:04:12,672 --> 00:04:17,174
only if there was a valid jump right in this exact moment,

66
00:04:17,174 --> 00:04:18,655
meaning your feet are touching the ground

67
00:04:18,655 --> 00:04:20,236
or you're bouncing off an enemy.

68
00:04:20,236 --> 00:04:24,778
So the simple change we made was to turn this variable

69
00:04:24,778 --> 00:04:27,539
from a true false variable into a timer.

70
00:04:27,539 --> 00:04:28,540
So now.

71
00:04:29,127 --> 00:04:31,929
Anytime it becomes possible for you to jump,

72
00:04:31,929 --> 00:04:35,032
instead of being true, the variable becomes .1.

73
00:04:35,032 --> 00:04:38,255
And so that means that you're always gonna be given

74
00:04:38,255 --> 00:04:40,157
a tenth of a second to jump,

75
00:04:40,157 --> 00:04:42,779
even after it should no longer be possible to jump.

76
00:04:42,779 --> 00:04:46,443
And suddenly, all those missed inputs

77
00:04:46,443 --> 00:04:49,426
from pressing the button too late go away.

78
00:04:49,426 --> 00:04:52,208
This technique is called the Coyote Jump

79
00:04:52,208 --> 00:04:55,031
after Wile E. Coyote, the Looney Tunes character.

80
00:04:55,476 --> 00:05:00,601
who would run off of cliffs and then only fall when he realized that he no longer had anything to stand on.

81
00:05:00,601 --> 00:05:03,663
If you're really watching somebody play with this mechanic,

82
00:05:03,663 --> 00:05:09,048
then you'll notice those times when they run off a cliff and they seem to jump off of thin air.

83
00:05:09,048 --> 00:05:17,335
So if you're finding that a little tricky to catch, here's this same clip at 25% speed.

84
00:05:17,335 --> 00:05:21,639
As you can clearly see, GR-18, our protagonist delivery robot,

85
00:05:22,820 --> 00:05:24,860
is fully floating in midair here

86
00:05:24,860 --> 00:05:27,061
by the time the jump button is pressed

87
00:05:27,061 --> 00:05:30,702
and that gets caught by our little can jump timer.

88
00:05:30,702 --> 00:05:35,444
So this is what a player would call responsive controls

89
00:05:35,444 --> 00:05:38,805
because the player attempted to jump across a gap

90
00:05:38,805 --> 00:05:41,126
and as far as they could tell,

91
00:05:41,126 --> 00:05:42,287
they pushed the button at the right time.

92
00:05:42,287 --> 00:05:44,267
So they would expect to jump that gap and they did

93
00:05:44,267 --> 00:05:45,068
and that's all there is to it.

94
00:05:45,068 --> 00:05:46,948
So once we opened up our minds to the possibility,

95
00:05:51,807 --> 00:05:54,788
of letting the player hit buttons too late,

96
00:05:54,788 --> 00:05:57,488
we started to see how this could be applied

97
00:05:57,488 --> 00:05:59,769
to other areas as well.

98
00:05:59,769 --> 00:06:02,369
In Levelhead, the player has the ability

99
00:06:02,369 --> 00:06:04,810
to grab objects using a grappler.

100
00:06:04,810 --> 00:06:09,131
And this grappler extends up to three full grid spaces

101
00:06:09,131 --> 00:06:09,871
away from the player,

102
00:06:09,871 --> 00:06:11,991
and it attaches to whatever it hits,

103
00:06:11,991 --> 00:06:14,892
and then it quickly pulls that back

104
00:06:14,892 --> 00:06:16,032
and puts it on the player's back.

105
00:06:17,309 --> 00:06:19,191
So when we first implemented this grappler,

106
00:06:19,191 --> 00:06:20,892
we didn't think too much of it

107
00:06:20,892 --> 00:06:23,995
because it's a common concept in platformers

108
00:06:23,995 --> 00:06:26,057
to be able to grab objects and carry them.

109
00:06:26,057 --> 00:06:32,062
But because our grappler had a range and a directionality,

110
00:06:32,062 --> 00:06:34,424
it suddenly opened up a lot of really interesting mechanics.

111
00:06:34,424 --> 00:06:36,726
And the coolest of these mechanics

112
00:06:36,726 --> 00:06:40,730
was what our players came to call a package jump,

113
00:06:40,730 --> 00:06:43,092
which came to be the signature move of GR-18.

114
00:06:44,777 --> 00:06:52,461
A package jump is when the player jumps off the package while grappling downward to pick it up again mid-jump.

115
00:06:52,461 --> 00:06:58,985
So this move allows you to use a box as a mobile platform to traverse hazardous terrain.

116
00:06:58,985 --> 00:07:05,428
And although the package jump was a really fun and interesting mechanic, we had a little bit of a math problem.

117
00:07:05,428 --> 00:07:12,352
The player can jump more than four spaces high, but the grappler only extends three spaces.

118
00:07:13,135 --> 00:07:15,561
So if the player hit the grappler too late,

119
00:07:15,561 --> 00:07:18,950
then they wouldn't quite be able to reach the package.

120
00:07:20,040 --> 00:07:23,543
So we created a system called cable stretching,

121
00:07:23,543 --> 00:07:26,385
where we would lock in the destination of the cable

122
00:07:26,385 --> 00:07:28,407
the moment you press the button.

123
00:07:28,407 --> 00:07:30,769
And if you happened to move farther away,

124
00:07:30,769 --> 00:07:32,951
the end of the cable would stretch

125
00:07:32,951 --> 00:07:36,014
to reach that original intended spot.

126
00:07:36,014 --> 00:07:39,136
So in this GIF, you can see the cable stretching in action.

127
00:07:39,136 --> 00:07:42,239
And even though GR-18 here, when standing at the top,

128
00:07:42,239 --> 00:07:44,281
normally can't reach down far enough.

129
00:07:44,341 --> 00:07:52,963
to grab the package, we can see that while jumping upward, the cable stretches that entire distance,

130
00:07:52,963 --> 00:07:56,523
giving plenty of wiggle room to perform that package jump. So cable stretching and coyote

131
00:07:56,523 --> 00:08:01,664
jumps are both forgiveness mechanics that work toward the same goal, and they both fall under

132
00:08:01,664 --> 00:08:08,365
the category of late input forgiveness. That is, they allow the player to press inputs too late

133
00:08:08,365 --> 00:08:11,146
while still giving the player the results that they expect.

134
00:08:12,677 --> 00:08:16,100
But even with our delayed input forgiveness mechanics

135
00:08:16,100 --> 00:08:18,602
added to level head, we still felt like the controls

136
00:08:18,602 --> 00:08:21,505
had some problems, because there's a flip side.

137
00:08:21,505 --> 00:08:23,927
People don't just hit buttons too late,

138
00:08:23,927 --> 00:08:25,908
they also hit buttons too early.

139
00:08:25,908 --> 00:08:27,449
So to solve this problem,

140
00:08:27,449 --> 00:08:31,313
we need some kind of early input forgiveness.

141
00:08:31,313 --> 00:08:33,014
We need to let players hit buttons too early

142
00:08:33,014 --> 00:08:34,455
and still make it count.

143
00:08:34,455 --> 00:08:36,177
So for example, if you hit the jump button

144
00:08:36,177 --> 00:08:38,939
before your feet touch the ground, you should still jump.

145
00:08:40,220 --> 00:08:45,844
We can easily solve this problem with a technique called input buffering, which is when you

146
00:08:45,844 --> 00:08:51,547
store an input for a short time after it's pressed and then engage the input when it

147
00:08:51,547 --> 00:08:52,288
becomes valid.

148
00:08:52,288 --> 00:08:59,052
A simple example from Levelhead is the input buffering that we have on jumps, which gives

149
00:08:59,052 --> 00:09:03,654
you a .2 second window after pressing the jump button and it still counts.

150
00:09:04,547 --> 00:09:10,973
So in this GIF, we spawn a red marker at the player's feet the moment the jump button is pressed.

151
00:09:10,973 --> 00:09:18,159
As you can see here, there's no way that the player would ordinarily be able to jump at these locations

152
00:09:18,159 --> 00:09:21,062
because their feet are just way above the ground.

153
00:09:22,141 --> 00:09:23,882
And even more importantly here,

154
00:09:23,882 --> 00:09:26,103
.2 seconds doesn't sound like much,

155
00:09:26,103 --> 00:09:30,266
but this GIF shows that even that short amount of time

156
00:09:30,266 --> 00:09:31,827
gives you a huge amount of leeway,

157
00:09:31,827 --> 00:09:35,028
making it almost impossible to mistime those jumps.

158
00:09:36,471 --> 00:09:37,731
So once we got this system working,

159
00:09:37,731 --> 00:09:40,773
we found it useful to use input buffering

160
00:09:40,773 --> 00:09:42,393
in just about everything.

161
00:09:42,393 --> 00:09:45,134
Yeah, there's input buffering for the jumping,

162
00:09:45,134 --> 00:09:47,835
but also the grappler, the power-ups,

163
00:09:47,835 --> 00:09:50,176
everything that the player does

164
00:09:50,176 --> 00:09:51,596
is just becomes much more responsive

165
00:09:51,596 --> 00:09:53,557
and feels better with input buffering.

166
00:09:54,926 --> 00:09:59,010
At this point, we've now covered all the input timing problems.

167
00:09:59,010 --> 00:10:05,997
In our first design, the player had to exactly press an input when that input was valid or it

168
00:10:05,997 --> 00:10:11,282
wouldn't count. This felt unresponsive and demanded too much perfection of the player.

169
00:10:11,282 --> 00:10:12,363
But when we combine

170
00:10:12,995 --> 00:10:15,776
our early and late input forgiveness mechanics,

171
00:10:15,776 --> 00:10:19,458
we create the input forgiveness sandwich,

172
00:10:19,458 --> 00:10:22,860
where the player has a nice wide window of opportunity,

173
00:10:22,860 --> 00:10:25,181
where when they press a key, they get the result they expect.

174
00:10:25,181 --> 00:10:30,344
This is what a player would call responsive controls.

175
00:10:30,344 --> 00:10:34,026
So we've done all we can to handle mistimed inputs,

176
00:10:34,026 --> 00:10:37,288
where the player presses the right button at the wrong time.

177
00:10:37,288 --> 00:10:39,629
But what about situations where a player

178
00:10:39,629 --> 00:10:42,350
is just pressing the wrong button entirely?

179
00:10:44,272 --> 00:10:48,654
One of the biggest things we struggled with in making Levelhead feel responsive

180
00:10:48,654 --> 00:10:55,019
is that when moments of tension arise, players' minds can become somewhat disconnected from the controls.

181
00:10:55,019 --> 00:11:00,582
So they might think that they're hitting a certain button, but really, they're doing something else.

182
00:11:00,582 --> 00:11:03,844
Maybe they're holding the button instead of repeatedly pressing it,

183
00:11:03,844 --> 00:11:06,446
or maybe they're pushing a different button entirely.

184
00:11:06,446 --> 00:11:12,690
For us, this problem was most pronounced when it came to Levelhead's fall-through mode.

185
00:11:13,988 --> 00:11:18,349
In Levelhead, after holding the down key for 0.2 seconds,

186
00:11:18,349 --> 00:11:20,530
you enter fall-through mode,

187
00:11:20,530 --> 00:11:23,290
which allows you to continue to fall

188
00:11:23,290 --> 00:11:25,411
through certain kinds of platforms

189
00:11:25,411 --> 00:11:27,071
or certain kinds of terrain

190
00:11:27,071 --> 00:11:29,791
as long as you continue to hold down.

191
00:11:29,791 --> 00:11:31,472
So here in this GIF,

192
00:11:31,472 --> 00:11:35,413
you can see a red bar appear at GR-18's feet

193
00:11:35,413 --> 00:11:36,593
when the timer starts.

194
00:11:36,593 --> 00:11:39,733
So that's when down is first pressed.

195
00:11:39,733 --> 00:11:42,214
And when GR-18 enters fall-through mode,

196
00:11:42,214 --> 00:11:43,174
the bar turns green.

197
00:11:43,627 --> 00:11:50,652
and he begins passing down through the thin ledges. So this system worked pretty well,

198
00:11:50,652 --> 00:11:57,037
except when it came to performing package jumps. To do a package jump, you need to grapple

199
00:11:57,037 --> 00:12:04,142
downward, which requires holding down while grappling. But some players would forget that

200
00:12:04,142 --> 00:12:09,306
they were holding down, and they would keep holding down, and they would try to land back

201
00:12:09,306 --> 00:12:11,047
on the package and just fall.

202
00:12:11,522 --> 00:12:14,024
right through it, as you can see here in this GIF.

203
00:12:14,024 --> 00:12:17,987
So we added some hidden rules to make it

204
00:12:17,987 --> 00:12:20,389
so that if the player continued holding down,

205
00:12:20,389 --> 00:12:23,011
they would still get the expected results.

206
00:12:23,011 --> 00:12:25,353
So first, we made it so that every time you jump,

207
00:12:25,353 --> 00:12:27,955
fall-through mode just turns off.

208
00:12:27,955 --> 00:12:31,098
We assume that if you're jumping, you want to go up.

209
00:12:31,098 --> 00:12:33,540
And fall-through mode is about going down.

210
00:12:33,540 --> 00:12:38,024
So in other words, we use one input to completely invalidate

211
00:12:38,024 --> 00:12:38,885
and reset another input.

212
00:12:40,000 --> 00:12:42,902
And second, we add a rule that fall through mode

213
00:12:42,902 --> 00:12:45,484
only begins when your feet are on the ground.

214
00:12:45,484 --> 00:12:48,967
So that means if you're holding down before you land,

215
00:12:48,967 --> 00:12:52,609
then you'll get a brief window of standing on the ground

216
00:12:52,609 --> 00:12:53,650
before you begin falling.

217
00:12:53,650 --> 00:12:55,712
So when we combine these rules,

218
00:12:55,712 --> 00:12:58,714
you can see that the player can now just continue

219
00:12:58,714 --> 00:13:00,555
to hold down forever,

220
00:13:00,555 --> 00:13:02,636
whether they know that they're doing it or not,

221
00:13:02,636 --> 00:13:06,139
and still be able to perform a series of package jumps

222
00:13:06,139 --> 00:13:07,100
without falling through.

223
00:13:08,567 --> 00:13:10,909
So in this GIF, the down button is never released.

224
00:13:10,909 --> 00:13:14,452
You might think that these extra rules

225
00:13:14,452 --> 00:13:16,995
would add some kind of clunkiness to the controls,

226
00:13:16,995 --> 00:13:20,678
but since they line up with players' expected outcomes,

227
00:13:20,678 --> 00:13:24,162
they actually just make the controls feel correct

228
00:13:24,162 --> 00:13:25,303
instead of weird.

229
00:13:25,303 --> 00:13:28,106
So this whole concept that we used

230
00:13:28,106 --> 00:13:30,007
to solve our down button problem

231
00:13:30,007 --> 00:13:31,809
is just called an input reset.

232
00:13:32,555 --> 00:13:34,476
where even though the player is holding a button,

233
00:13:34,476 --> 00:13:36,878
we add rules that reset the input

234
00:13:36,878 --> 00:13:39,719
to make it seem like the player isn't holding the button

235
00:13:39,719 --> 00:13:41,520
and that they've pressed it fresh.

236
00:13:41,520 --> 00:13:44,101
As designers, we just have to acknowledge

237
00:13:44,101 --> 00:13:48,183
that players will sometimes forget to let go of a button,

238
00:13:48,183 --> 00:13:49,284
and it's our job to make sure

239
00:13:49,284 --> 00:13:52,525
that the game handles that gracefully wherever possible.

240
00:13:52,525 --> 00:13:56,707
So when it comes to accidental input forgiveness,

241
00:13:56,707 --> 00:13:59,689
you can go even deeper than input resets.

242
00:14:00,485 --> 00:14:05,027
Because sometimes you'll find that players will press a button

243
00:14:05,027 --> 00:14:07,428
that they really, really don't want to use at all.

244
00:14:07,428 --> 00:14:10,209
In Levelhead, we got hit by this problem in a big way.

245
00:14:10,209 --> 00:14:13,651
We had the controller's left bumper tied to the retry button.

246
00:14:13,651 --> 00:14:17,412
So if you press that bumper, it would start the level over

247
00:14:17,412 --> 00:14:20,213
or set you back to the previous checkpoint.

248
00:14:20,213 --> 00:14:24,836
We wanted to make sure that it was super easy for speed runners

249
00:14:24,836 --> 00:14:27,297
and more serious players to restart levels

250
00:14:27,297 --> 00:14:28,457
to work on their strategies.

251
00:14:29,088 --> 00:14:34,089
or if somebody got soft locked in a puzzle that they could just hit a button and just start over.

252
00:14:34,089 --> 00:14:40,631
So we discovered though that a sizable portion of our players, probably about a third,

253
00:14:40,631 --> 00:14:45,571
kept hitting that left bumper on accident. So they'd be in the middle of doing something and

254
00:14:45,571 --> 00:14:50,572
then all of a sudden they would just accidentally reset the level. This seemed weird to us because

255
00:14:50,572 --> 00:14:56,073
the left bumper is like it's way over there on the controller. So how could you possibly hit it

256
00:14:56,073 --> 00:14:56,693
on accident?

257
00:14:57,869 --> 00:15:00,290
We sat down and we just watched some people play the game.

258
00:15:00,290 --> 00:15:02,010
And we quickly discovered the problem,

259
00:15:02,010 --> 00:15:05,271
which is that some players just naturally hold

260
00:15:05,271 --> 00:15:07,071
the controller with their index fingers

261
00:15:07,071 --> 00:15:08,392
resting on the bumpers.

262
00:15:08,392 --> 00:15:10,932
And when something intense was happening,

263
00:15:10,932 --> 00:15:15,533
these players would clutch the controller super hard

264
00:15:15,533 --> 00:15:16,273
and squeeze it.

265
00:15:16,273 --> 00:15:19,234
And they would press both of the bumpers at the same time.

266
00:15:20,696 --> 00:15:24,598
And because it happened when the player was in the middle of a panic moment,

267
00:15:24,598 --> 00:15:29,200
then the player would actually have no idea that they had squeezed the bumpers.

268
00:15:29,200 --> 00:15:30,941
They didn't know they had pressed any buttons.

269
00:15:30,941 --> 00:15:34,882
And so as far as they were concerned, the level just randomly restarted.

270
00:15:34,882 --> 00:15:38,704
So fortunately, there's a simple fix for this.

271
00:15:38,704 --> 00:15:42,406
We just added a count-up timer to the reset button

272
00:15:42,406 --> 00:15:47,048
so that the button would only be valid if you held it for more than 0.3 seconds.

273
00:15:48,275 --> 00:15:51,296
Now, this is enough time that it allows the panic to pass.

274
00:15:51,296 --> 00:15:53,517
And if a player clutched the controller,

275
00:15:53,517 --> 00:15:55,578
they usually would only do it just for an instant.

276
00:15:55,578 --> 00:15:57,699
And so by the time the panic subsides,

277
00:15:57,699 --> 00:15:59,360
they've released the button

278
00:15:59,360 --> 00:16:02,341
and they've stopped accidentally resetting.

279
00:16:02,341 --> 00:16:05,603
So once, sure enough, once we implemented this,

280
00:16:05,603 --> 00:16:08,544
all those complaints about accidental restarts vanished.

281
00:16:08,544 --> 00:16:10,885
So we call this kind of forgiveness mechanic

282
00:16:10,885 --> 00:16:12,506
an input speed bump.

283
00:16:12,506 --> 00:16:15,287
So rather than just instantly taking the player's input

284
00:16:15,287 --> 00:16:16,808
and engaging the action,

285
00:16:17,660 --> 00:16:21,022
For some inputs, we can say, slow down a second

286
00:16:21,022 --> 00:16:22,103
so you don't hurt yourself.

287
00:16:22,103 --> 00:16:25,604
And when it comes to buttons of higher consequence,

288
00:16:25,604 --> 00:16:28,085
where an accidental input would be really bad,

289
00:16:28,085 --> 00:16:31,427
you might wanna consider putting some speed bumps in there.

290
00:16:31,427 --> 00:16:33,468
All right, so there's many ways

291
00:16:33,468 --> 00:16:36,730
that you can forgive your players

292
00:16:36,730 --> 00:16:41,512
for giving weird, bad, or just plain wrong inputs.

293
00:16:41,512 --> 00:16:44,233
But forgiveness mechanics are not just about inputs.

294
00:16:44,932 --> 00:16:50,414
There are lots of other little things you can do to make your game feel more responsive to the player's intentions.

295
00:16:50,414 --> 00:16:54,296
For example, when we first started working on Levelhead,

296
00:16:54,296 --> 00:16:59,759
we kept running into scenarios where it was unusually difficult to navigate tight spaces.

297
00:16:59,759 --> 00:17:04,061
Like if you ran over a little gap in the floor, you'd just fall right into it.

298
00:17:04,061 --> 00:17:08,363
Or if you wanted to jump through a one grid space hole in the ceiling,

299
00:17:08,363 --> 00:17:11,045
it would take a couple tries and you kept bumping your head.

300
00:17:12,488 --> 00:17:15,671
This was all because of how we were thinking about our hitboxes.

301
00:17:15,671 --> 00:17:20,355
Under the hood, everything in Levelhead has a width and a height,

302
00:17:20,355 --> 00:17:24,358
which determines the hitbox of whatever that thing might be.

303
00:17:24,358 --> 00:17:30,363
So here you can see some of the items in Levelhead shown with their baseline square-shaped hitboxes.

304
00:17:32,033 --> 00:17:33,694
When we first started building the game,

305
00:17:33,694 --> 00:17:37,035
we treated these hitboxes as sacred.

306
00:17:37,035 --> 00:17:40,457
Any collision between hitboxes should be respected,

307
00:17:40,457 --> 00:17:41,037
we thought.

308
00:17:41,037 --> 00:17:43,398
So let's say we had a situation like this

309
00:17:43,398 --> 00:17:44,938
where you have some terrain

310
00:17:44,938 --> 00:17:46,999
and then there's a tiny ledge sticking up.

311
00:17:46,999 --> 00:17:49,400
And if we have a character walking along here

312
00:17:49,400 --> 00:17:52,662
and we take a rigid view of these hitboxes,

313
00:17:52,662 --> 00:17:56,864
then we would say that unless the character jumps,

314
00:17:56,864 --> 00:17:59,005
this tiny ledge is going to stop.

315
00:18:00,012 --> 00:18:03,053
But it turns out that is a terrible gameplay experience

316
00:18:03,053 --> 00:18:07,794
because being stopped by every tiny ledge, lip, and corner

317
00:18:07,794 --> 00:18:10,315
just makes everything frustrating.

318
00:18:10,315 --> 00:18:13,577
So to solve this, we use hitbox pinching,

319
00:18:13,577 --> 00:18:16,258
which is when the character's movement collisions

320
00:18:16,258 --> 00:18:19,899
are based on some smaller pinched version of the hitbox.

321
00:18:19,899 --> 00:18:22,020
And this is gonna allow the character

322
00:18:22,020 --> 00:18:24,241
to squeeze through areas that they otherwise

323
00:18:24,241 --> 00:18:26,161
would have had a harder time squeezing into,

324
00:18:26,161 --> 00:18:28,582
and then they can pop up over obstacles.

325
00:18:29,302 --> 00:18:31,883
So in our previous example, it would look like this.

326
00:18:31,883 --> 00:18:35,524
When you're calculating horizontal movement collisions,

327
00:18:35,524 --> 00:18:38,525
we would pinch the hit box vertically,

328
00:18:38,525 --> 00:18:42,587
which allows us to pretend like the character's feet

329
00:18:42,587 --> 00:18:45,608
are higher up off the ground and its head is lower.

330
00:18:45,608 --> 00:18:48,189
As the character moves forward,

331
00:18:48,189 --> 00:18:51,910
this tiny ledge is no longer a problem.

332
00:18:51,910 --> 00:18:53,410
And in that same movement frame,

333
00:18:53,410 --> 00:18:55,771
we can resolve the fact that the character's

334
00:18:55,771 --> 00:18:58,592
inside the floor by just popping them up out of the ground.

335
00:18:59,705 --> 00:19:05,049
So the player can now move unimpeded over small obstacles.

336
00:19:05,049 --> 00:19:07,650
And this hitbox pinching technique also allows the player

337
00:19:07,650 --> 00:19:10,512
to run over small holes in the ground.

338
00:19:10,512 --> 00:19:12,494
So without hitbox pinching,

339
00:19:12,494 --> 00:19:15,476
you would often find yourself in this kind of a situation

340
00:19:15,476 --> 00:19:17,698
where you'd go to run across this little gap,

341
00:19:17,698 --> 00:19:21,760
but in one frame, you can fall down a single pixel.

342
00:19:21,760 --> 00:19:24,582
And because you fell down one pixel,

343
00:19:24,582 --> 00:19:28,445
the next ledge becomes an impassable wall,

344
00:19:28,445 --> 00:19:29,406
and now you just fall right in.

345
00:19:31,190 --> 00:19:34,352
In Levelhead, when GR18 is moving to the side,

346
00:19:34,352 --> 00:19:38,354
we pinch the hitbox by 20 pixels top and bottom.

347
00:19:38,354 --> 00:19:41,656
So that means that while running to the right,

348
00:19:41,656 --> 00:19:45,818
the player would have to drop more than 20 pixels

349
00:19:45,818 --> 00:19:50,661
before they can no longer pop up over the next ledge.

350
00:19:50,661 --> 00:19:54,063
And when we put this into practice,

351
00:19:54,063 --> 00:19:57,525
we can see that now GR18 can run across one tile wide gaps.

352
00:19:57,525 --> 00:20:00,926
And actually, if you move horizontally fast enough.

353
00:20:01,636 --> 00:20:03,957
you can even clear double-wide gaps.

354
00:20:03,957 --> 00:20:08,200
And this visualization really illustrates that pop-up effect

355
00:20:08,200 --> 00:20:11,922
from the hitbox pinching in a much more pronounced way.

356
00:20:11,922 --> 00:20:14,644
So as you can see here,

357
00:20:14,644 --> 00:20:16,825
JRoutine runs across, falls for a moment,

358
00:20:16,825 --> 00:20:18,326
and pops up over the next tile,

359
00:20:18,326 --> 00:20:20,747
and that little bit of falling is forgiven.

360
00:20:20,747 --> 00:20:23,929
Hitbox pinching can also be used

361
00:20:23,929 --> 00:20:28,232
to let the player easily jump up and out of tight spaces.

362
00:20:29,260 --> 00:20:31,702
So here in this GIF we're representing collision checks

363
00:20:31,702 --> 00:20:34,143
with these little green dots.

364
00:20:34,143 --> 00:20:36,845
And as you can see that when the player's jumping upward,

365
00:20:36,845 --> 00:20:39,387
we pinch the hitbox down to almost nothing.

366
00:20:39,387 --> 00:20:43,009
I think maybe the player's about two pixels wide

367
00:20:43,009 --> 00:20:44,170
while jumping upward.

368
00:20:45,639 --> 00:20:51,604
But that squeeze generally allows the player to sometimes partially go inside of walls,

369
00:20:51,604 --> 00:20:54,767
and so we have to make sure that we adjust for that,

370
00:20:54,767 --> 00:20:59,431
and that adjustment is shown by those little yellow dots in the center of the player's body

371
00:20:59,431 --> 00:21:00,531
when they jump around corners.

372
00:21:00,531 --> 00:21:00,932
Just like that.

373
00:21:00,932 --> 00:21:04,655
And you may also notice that when the player's falling,

374
00:21:04,655 --> 00:21:06,356
we don't pinch the hitbox at all.

375
00:21:06,356 --> 00:21:12,801
So the player has a wide base on which they can much more easily land on narrow ledges.

376
00:21:13,965 --> 00:21:20,390
Hitbox pinching is a super useful tool that allows you to demand a lot less precision of the player

377
00:21:20,390 --> 00:21:24,993
and allows them to very easily squeeze through areas of the game that would otherwise require

378
00:21:24,993 --> 00:21:32,057
a frustrating amount of fine motor skill. So when it comes to hitboxes there are a couple other

379
00:21:32,057 --> 00:21:38,081
much simpler things you can do to get a lot of mileage. For example we can play around with

380
00:21:38,081 --> 00:21:43,205
hitbox sizes and shapes as a simple but effective tool to make the game more forgiving.

381
00:21:44,351 --> 00:21:47,992
For starters, when it comes to things that are bad for the player to touch,

382
00:21:47,992 --> 00:21:51,653
we can tuck the hitbox in at the edges,

383
00:21:51,653 --> 00:21:55,313
making the hitbox smaller than the visual area of the object,

384
00:21:55,313 --> 00:21:57,954
so it's harder for the player to hurt themselves.

385
00:21:57,954 --> 00:22:01,895
And you can see in this GIF how these Spike Trons in Levelhead

386
00:22:01,895 --> 00:22:04,075
have very forgiving hitboxes,

387
00:22:04,075 --> 00:22:07,476
which allows the player to easily squeeze through a gap like this.

388
00:22:07,476 --> 00:22:10,037
So I like to think of this as those times in movies

389
00:22:10,037 --> 00:22:13,958
where someone's flying a spaceship.

390
00:22:14,746 --> 00:22:18,609
And there's always a scene where two big doors are closing,

391
00:22:18,609 --> 00:22:21,251
and they have to squeeze the ship through the gap.

392
00:22:21,251 --> 00:22:25,414
So basically, you want to create that feeling.

393
00:22:25,414 --> 00:22:28,616
And that's easy to do just by tucking in those hitboxes.

394
00:22:28,616 --> 00:22:31,258
So you may also notice that these spikes,

395
00:22:31,258 --> 00:22:35,602
despite obviously being square, have circular hitboxes.

396
00:22:36,377 --> 00:22:40,838
By shaving off the corners, we make it so that the player can kind of pass their toe

397
00:22:40,838 --> 00:22:45,419
through the corner of the spike, and that's still fine.

398
00:22:45,419 --> 00:22:46,880
It's a close call, which feels cool.

399
00:22:46,880 --> 00:22:50,861
It makes the player feel like they're better at the game, and it's just a lot more exciting

400
00:22:50,861 --> 00:22:52,141
that way.

401
00:22:52,141 --> 00:22:59,383
On the flip side, for anything positive, we want the hitbox to be as easy to hit as possible.

402
00:22:59,383 --> 00:23:03,545
So for starters, we make it a square so that it has those corners to catch.

403
00:23:04,210 --> 00:23:05,812
And we also extend the hitbox

404
00:23:05,812 --> 00:23:07,695
beyond the visual size of the item.

405
00:23:07,695 --> 00:23:10,739
So in this GIF, we can see how these hitboxes

406
00:23:10,739 --> 00:23:13,143
of gems and level head extend far beyond

407
00:23:13,143 --> 00:23:14,485
their actual visual size.

408
00:23:15,645 --> 00:23:20,367
And when the game is slowed down at half speed like this and when the hitboxes are visible,

409
00:23:20,367 --> 00:23:23,129
the forgiveness mechanics are pretty obvious.

410
00:23:23,129 --> 00:23:28,652
But at full speed, without the hitboxes visible, it feels totally natural.

411
00:23:28,652 --> 00:23:34,595
And the player is not going to notice or be upset that these good things are being handed

412
00:23:34,595 --> 00:23:36,216
to them with ease.

413
00:23:36,216 --> 00:23:41,078
But sometimes, having a big hitbox isn't enough.

414
00:23:41,078 --> 00:23:44,520
If you want the player to really get that good stuff.

415
00:23:45,078 --> 00:23:48,040
you can add magnetism to positive items.

416
00:23:48,040 --> 00:23:51,683
In Levelhead, we only apply this to the gems,

417
00:23:51,683 --> 00:23:53,944
but in your game, you could technically do this

418
00:23:53,944 --> 00:23:55,445
to whatever you want.

419
00:23:55,445 --> 00:23:58,587
The rule we use is once the player

420
00:23:58,587 --> 00:24:01,249
has gotten pretty close to the gem,

421
00:24:01,249 --> 00:24:04,171
we have the gem enter magnet mode,

422
00:24:04,171 --> 00:24:05,993
and it's then just gonna chase the player

423
00:24:05,993 --> 00:24:06,973
until it gets picked up.

424
00:24:07,664 --> 00:24:13,229
This effect is especially pronounced when the player is moving faster, like this GIF, when they're falling,

425
00:24:13,229 --> 00:24:15,511
or maybe if they're being shot out of a cannon.

426
00:24:15,511 --> 00:24:21,756
So we use this kind of magnetism to make it so that the player doesn't have to backtrack

427
00:24:21,756 --> 00:24:25,359
and physically touch every gem just to collect it.

428
00:24:25,359 --> 00:24:30,043
If they just kind of like graze past one, and got close enough,

429
00:24:30,043 --> 00:24:33,906
then we just call it good enough and we let the player have the win.

430
00:24:34,690 --> 00:24:42,255
And plus, I think it just feels really cool to go really fast and just be chased by a bunch of gems that are trying to catch you.

431
00:24:42,255 --> 00:24:50,340
The last forgiveness mechanic I want to go over is the concept of a benefit-of-the-doubt decision tree.

432
00:24:50,340 --> 00:24:57,345
This is what we use when a player could have multiple possible outcomes when interacting with something,

433
00:24:57,345 --> 00:25:00,907
with varying degrees of goodness or badness.

434
00:25:01,899 --> 00:25:04,820
When one of these events occurs, we

435
00:25:04,820 --> 00:25:08,501
walk through a series of questions

436
00:25:08,501 --> 00:25:10,141
that always leads to the most favorable outcome

437
00:25:10,141 --> 00:25:10,542
to the player.

438
00:25:10,542 --> 00:25:14,323
In Levelhead, enemies are the best example of this.

439
00:25:14,323 --> 00:25:17,523
So when you hit an enemy, there are some scenarios

440
00:25:17,523 --> 00:25:20,084
where you defeat the enemy, and there are some scenarios

441
00:25:20,084 --> 00:25:21,545
where the enemy defeats you.

442
00:25:21,545 --> 00:25:25,886
And the outcome totally depends on how you hit the enemy.

443
00:25:25,886 --> 00:25:30,627
So we can use this scrub enemy from Levelhead as an example.

444
00:25:31,933 --> 00:25:34,375
When you collide with this scrub,

445
00:25:34,375 --> 00:25:37,517
we first check the green rectangular area.

446
00:25:37,517 --> 00:25:41,240
This is the area that is favorable to you

447
00:25:41,240 --> 00:25:45,022
to determine whether you're gonna deal damage to the scrub

448
00:25:45,022 --> 00:25:46,403
by jumping on its head.

449
00:25:46,403 --> 00:25:50,105
So notice that this area is larger

450
00:25:50,105 --> 00:25:52,067
than the visual size of the scrub,

451
00:25:52,067 --> 00:25:55,229
and it also has corners, making it easier to hit.

452
00:25:56,153 --> 00:26:05,721
And as you can see in this GIF, the player doesn't have to directly land on the visual area of the scrub for this to count as a successful hit.

453
00:26:05,721 --> 00:26:10,845
You just need to hit somewhere in that green rectangle.

454
00:26:10,845 --> 00:26:14,768
And just like with the gems, the positive hitbox extends far beyond the visible area.

455
00:26:15,920 --> 00:26:26,505
As before, this effect is more pronounced when the game is slowed down like this, but at full speed, this happens fast enough that you don't really notice it that much.

456
00:26:27,868 --> 00:26:32,911
But when you've collided with the enemy and failed to meet that first decision criteria

457
00:26:32,911 --> 00:26:35,393
for dealing damage to it in the green rectangle,

458
00:26:35,393 --> 00:26:39,675
only then do we evaluate if you're going to be harmed.

459
00:26:39,675 --> 00:26:44,158
And in that case, we use a second, smaller, circular collision mask,

460
00:26:44,158 --> 00:26:47,080
represented by this red circle, to determine whether you're harmed.

461
00:26:47,080 --> 00:26:52,063
So it's possible that you would collide with the green rectangle,

462
00:26:52,063 --> 00:26:54,905
fail to damage the enemy, because maybe, I don't know,

463
00:26:54,905 --> 00:26:56,586
maybe you were traveling up or something.

464
00:26:57,832 --> 00:27:04,034
but maybe you're still not inside the circle so you don't take any, you don't, you're not harmed

465
00:27:04,034 --> 00:27:10,157
and you live to see another day. And by using this tucked in circle we allow you to kind of graze

466
00:27:10,157 --> 00:27:17,520
past and avoid anything bad happening to you. So in all cases our goal here is to give the

467
00:27:17,520 --> 00:27:21,222
player as many opportunities to win and feel like they're really good at the game.

468
00:27:21,853 --> 00:27:28,258
And only when they totally run out of possible ways out, that's when the player loses.

469
00:27:28,258 --> 00:27:31,981
All right, so that's about all the time that I have.

470
00:27:31,981 --> 00:27:36,345
I hope you've all found this useful and interesting.

471
00:27:37,329 --> 00:27:43,693
Some of these concepts are a lot more complicated to implement than others, and not all of them will apply to all games.

472
00:27:43,693 --> 00:27:51,898
So, how you bring these forgiveness mechanics into your game may end up looking a lot different than what I've shown here today.

473
00:27:51,898 --> 00:27:58,603
But that's okay, because the most important thing here is not in the specifics, it's in the broader philosophy.

474
00:27:58,603 --> 00:28:00,844
That your players are people.

475
00:28:00,984 --> 00:28:07,328
And people do all kinds of wacky things. They push the wrong buttons, they squeeze the controller,

476
00:28:07,328 --> 00:28:12,951
they panic, they do a lot of things that they don't even know about or that they can't even explain.

477
00:28:12,951 --> 00:28:18,233
In other words, they're not perfect. But we shouldn't expect them to be perfect.

478
00:28:18,233 --> 00:28:24,837
As designers, it's our job to meet our players where they are and give them the best possible experience.

479
00:28:24,837 --> 00:28:30,840
And to do that, we have to forgive their inconsistencies and build rules into our games that accommodate them.

480
00:28:31,505 --> 00:28:35,107
and only then will you have a truly responsive game.

481
00:28:35,107 --> 00:28:37,489
Thank you for listening.

482
00:28:37,489 --> 00:28:40,431
If you have any questions or comments about this talk,

483
00:28:40,431 --> 00:28:44,855
feel free to shoot me an email at seth at bscodge.net.

484
00:28:44,855 --> 00:28:45,475
Good luck out there.

