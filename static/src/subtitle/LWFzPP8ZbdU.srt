1
00:00:06,295 --> 00:00:10,338
Good morning. Welcome to GDC 2017.

2
00:00:11,959 --> 00:00:13,621
Thank you for getting up on Monday morning

3
00:00:13,641 --> 00:00:15,942
and coming to see us. This is the Math

4
00:00:15,982 --> 00:00:19,845
for Game Programmers tutorial. We're gonna be doing sessions

5
00:00:19,865 --> 00:00:23,548
throughout today on various topics in math in games.

6
00:00:23,788 --> 00:00:26,730
So feel free to join for whichever sessions you like.

7
00:00:28,111 --> 00:00:30,332
I'm supposed to ask you and remind you, please

8
00:00:30,373 --> 00:00:33,094
silence your phones or your pagers, if you're a

9
00:00:33,114 --> 00:00:34,415
drug dealer. And.

10
00:00:36,700 --> 00:00:39,202
At the end of the session, if you haven't been to GDC before,

11
00:00:39,362 --> 00:00:40,783
or if you have, it's good to be reminded,

12
00:00:40,803 --> 00:00:44,026
you'll be getting an email that asks you to review the session.

13
00:00:44,146 --> 00:00:47,049
Please do the review. It just takes a second.

14
00:00:47,789 --> 00:00:50,652
And we really appreciate and read the feedback that you give.

15
00:00:50,912 --> 00:00:51,072
So.

16
00:00:53,234 --> 00:00:55,356
So today's schedule, we're gonna be doing

17
00:00:55,876 --> 00:00:57,497
two one-hour talks this morning.

18
00:00:57,517 --> 00:00:59,579
I'm with myself and then Mike Acton.

19
00:01:00,380 --> 00:01:01,461
And then we're gonna break for lunch.

20
00:01:02,061 --> 00:01:04,744
And then we're gonna have a number of half-hour talks in the afternoon.

21
00:01:05,933 --> 00:01:07,133
We'll have this schedule up as we go.

22
00:01:09,154 --> 00:01:09,394
OK.

23
00:01:09,434 --> 00:01:11,615
So first, I just want to get a sense of who's in the room.

24
00:01:11,815 --> 00:01:13,955
So, um, please raise your hand

25
00:01:14,175 --> 00:01:16,256
if this is your first GDC ever.

26
00:01:17,216 --> 00:01:17,536
Awesome.

27
00:01:17,996 --> 00:01:19,717
That's about half, two-thirds of the room.

28
00:01:20,597 --> 00:01:22,158
And then put those hands back up, please.

29
00:01:22,498 --> 00:01:23,058
And, um,

30
00:01:24,198 --> 00:01:25,459
also if you've been to GDC

31
00:01:25,499 --> 00:01:27,359
but you've never been to this tutorial before.

32
00:01:27,379 --> 00:01:29,240
OK. So that's

33
00:01:29,740 --> 00:01:30,660
mostly first-timers.

34
00:01:31,961 --> 00:01:33,221
Please raise your hand if you're a student.

35
00:01:34,963 --> 00:01:37,164
Only a few. An educator.

36
00:01:37,184 --> 00:01:39,265
A couple as well.

37
00:01:40,505 --> 00:01:41,906
Or if you work in games, full-time.

38
00:01:42,386 --> 00:01:43,546
OK. The vast majority of them.

39
00:01:44,807 --> 00:01:45,147
OK.

40
00:01:46,067 --> 00:01:50,209
So my talk is noise-based random regeneration.

41
00:01:51,850 --> 00:01:54,071
More like why be random when you can be noisy,

42
00:01:54,191 --> 00:01:57,452
or I'm going to make a claim that anything random can do, noise can do better.

43
00:02:00,233 --> 00:02:03,055
So, I'm a game designer programmer.

44
00:02:03,075 --> 00:02:05,017
I've been coding since the Apple II.

45
00:02:05,457 --> 00:02:06,418
My background's in physics.

46
00:02:06,638 --> 00:02:08,780
I've been doing this professionally a long time,

47
00:02:09,521 --> 00:02:11,662
and I present regularly at the GDC,

48
00:02:11,682 --> 00:02:13,844
and I teach now at SMU Gill Hall,

49
00:02:13,864 --> 00:02:15,566
which is a grad school for game development.

50
00:02:16,486 --> 00:02:17,848
I've worked at a bunch of companies.

51
00:02:17,888 --> 00:02:18,668
I was a tech director.

52
00:02:19,317 --> 00:02:20,998
or lead programmer at each of those companies.

53
00:02:21,398 --> 00:02:22,679
And I've worked with a bunch of companies

54
00:02:22,719 --> 00:02:23,840
on a bunch of projects.

55
00:02:24,600 --> 00:02:28,223
So today, we're talking about number generators, right?

56
00:02:28,943 --> 00:02:30,944
From RAND to whatever else.

57
00:02:32,085 --> 00:02:33,626
We're gonna talk about some noise functions,

58
00:02:33,706 --> 00:02:35,908
and I'm gonna get into that a little bit.

59
00:02:36,128 --> 00:02:39,090
Just a couple of versions of smooth or fractal noise,

60
00:02:39,110 --> 00:02:40,771
like Perlin noise, Simplex noise.

61
00:02:41,552 --> 00:02:43,373
I'm gonna make a case that I think noise is

62
00:02:44,213 --> 00:02:46,635
more valuable in some cases than random,

63
00:02:46,755 --> 00:02:47,976
or can even supersede random.

64
00:02:49,131 --> 00:02:52,445
And then we'll, of course, try to give some application and context for all this stuff.

65
00:02:54,070 --> 00:02:56,531
So the talk is for anyone who's interested

66
00:02:56,571 --> 00:02:57,812
in procedural content generation.

67
00:02:57,832 --> 00:02:59,032
That's been a hot topic lately.

68
00:02:59,873 --> 00:03:01,354
Of course, anyone who's just rolling dice

69
00:03:01,374 --> 00:03:02,794
for random outcomes in general.

70
00:03:03,835 --> 00:03:05,876
If you're using RAN, this talk is definitely for you.

71
00:03:06,596 --> 00:03:07,997
Even if you're using the Marcen Twister

72
00:03:08,037 --> 00:03:09,458
or something you think is more sophisticated,

73
00:03:10,058 --> 00:03:10,839
this talk is for you.

74
00:03:12,380 --> 00:03:15,081
Or if you're doing any sort of noise or hash functions

75
00:03:15,121 --> 00:03:17,222
and you're using something like MD5 or SHA

76
00:03:17,282 --> 00:03:19,343
or something you found on Stack Overflow,

77
00:03:19,383 --> 00:03:20,704
this is definitely a talk for you.

78
00:03:22,608 --> 00:03:25,530
Okay, so some example use cases just to frame

79
00:03:26,931 --> 00:03:30,793
what is this, because everything, context is king, right?

80
00:03:31,133 --> 00:03:31,973
Depends on what we're doing.

81
00:03:32,173 --> 00:03:35,515
So one of the most popular things we're gonna use

82
00:03:35,835 --> 00:03:38,537
random numbers for and noise is for generating

83
00:03:38,577 --> 00:03:39,457
procedural worlds, right?

84
00:03:39,497 --> 00:03:40,318
And everyone thinks about.

85
00:03:40,918 --> 00:03:43,058
you know, height maps generating mountains and lakes,

86
00:03:43,178 --> 00:03:44,199
and yes, we can do that.

87
00:03:44,479 --> 00:03:46,859
Or generating random dungeons for roguelikes or something,

88
00:03:46,919 --> 00:03:47,739
yes, we can do that.

89
00:03:48,399 --> 00:03:49,880
There's a lot more we can generate though, right?

90
00:03:49,920 --> 00:03:51,620
We might generate planets or villages,

91
00:03:51,760 --> 00:03:53,040
spaceships, flowers,

92
00:03:53,780 --> 00:03:56,381
random NPCs with random genders and personalities

93
00:03:56,501 --> 00:03:59,582
and backgrounds and professions, random quests, right?

94
00:03:59,602 --> 00:04:01,682
So there's a lot of other things we might wanna do

95
00:04:01,722 --> 00:04:04,303
with generation other than just mountains.

96
00:04:05,603 --> 00:04:07,843
There's some harder problems that are more nuanced too.

97
00:04:09,205 --> 00:04:11,933
and Shay Pearce is going to talk about this a little bit this afternoon,

98
00:04:12,515 --> 00:04:13,297
where we might want to...

99
00:04:15,255 --> 00:04:18,478
create discrete and distinct things

100
00:04:19,119 --> 00:04:20,320
in a near infinite world.

101
00:04:21,201 --> 00:04:24,804
Or we may wanna place objects in a really large world, right?

102
00:04:24,844 --> 00:04:27,106
And so for example, in Minecraft, you can run forever,

103
00:04:27,646 --> 00:04:29,888
but every now and then there are periodic trees

104
00:04:30,589 --> 00:04:32,410
or periodic villages, and how do we decide

105
00:04:32,611 --> 00:04:34,772
where to place those if we can't figure out

106
00:04:34,792 --> 00:04:36,054
where to place them all at the same time

107
00:04:36,094 --> 00:04:37,875
because the world is infinite, right?

108
00:04:37,895 --> 00:04:38,596
So we need to do all this.

109
00:04:39,150 --> 00:04:40,131
kind of on the fly.

110
00:04:40,751 --> 00:04:41,852
We might wanna do particle effects.

111
00:04:41,872 --> 00:04:42,952
We might have a million particles,

112
00:04:43,072 --> 00:04:44,373
each one doing a random thing.

113
00:04:44,593 --> 00:04:46,474
That can get really weird if we're doing it badly.

114
00:04:46,494 --> 00:04:49,416
There are a lot of AI algorithms nowadays

115
00:04:49,476 --> 00:04:51,677
that require randomness,

116
00:04:51,957 --> 00:04:53,578
whether it's Markov chains, genetic algorithms,

117
00:04:54,198 --> 00:04:56,559
Monte Carlo.

118
00:04:57,100 --> 00:04:59,001
And again, going back to the Minecraft example,

119
00:04:59,041 --> 00:04:59,581
we might wanna

120
00:05:01,742 --> 00:05:04,684
have chunks that generate in random order, right?

121
00:05:04,704 --> 00:05:06,124
So if the player runs to the west,

122
00:05:06,164 --> 00:05:07,125
he discovers a mountain.

123
00:05:08,054 --> 00:05:08,995
Great, there's a mountain there.

124
00:05:09,015 --> 00:05:11,456
He then only sees half of the mountain,

125
00:05:11,476 --> 00:05:13,017
so only half of the mountain's been generated.

126
00:05:13,377 --> 00:05:15,678
He then runs away from it, goes south,

127
00:05:15,798 --> 00:05:16,919
comes all the way back around,

128
00:05:17,399 --> 00:05:18,920
and approaches the mountain from the other side.

129
00:05:19,000 --> 00:05:20,361
The mountain better still be there,

130
00:05:20,481 --> 00:05:23,242
and the west side better match with the east side.

131
00:05:24,583 --> 00:05:26,023
We may wanna trade seeds, right?

132
00:05:26,083 --> 00:05:28,785
I may wanna tell my friend, hey, you should try this map.

133
00:05:28,865 --> 00:05:31,086
Try this seed from this word or this number.

134
00:05:31,546 --> 00:05:32,247
It's a really cool map.

135
00:05:32,267 --> 00:05:34,228
It's got a tower in the middle of the jungle,

136
00:05:34,428 --> 00:05:34,968
something like that.

137
00:05:37,835 --> 00:05:42,016
Generation and noise can also be the ultimate form of network compression, right?

138
00:05:42,476 --> 00:05:46,998
If I have 22 gigs of data that I generated, I can send it to you with an almost infinite

139
00:05:47,018 --> 00:05:49,918
to one compression if I just send you the feed, right?

140
00:05:50,018 --> 00:05:51,839
So that's a huge advantage.

141
00:05:51,879 --> 00:05:53,579
That's the same with disk compression, right?

142
00:05:53,619 --> 00:05:57,340
If I generate some mountain, as long as the mountain's unchanged, I don't need to save

143
00:05:57,360 --> 00:05:57,760
it on disk.

144
00:05:57,800 --> 00:06:00,021
I can just throw it away and regenerate it on demand.

145
00:06:01,061 --> 00:06:02,621
So it's the ultimate form of compression as well.

146
00:06:03,444 --> 00:06:07,645
All right, so briefly, I want to talk about, well, what do we actually want out of our random number generators?

147
00:06:08,325 --> 00:06:11,665
Which ones should we actually use or not use if we keep hearing different things?

148
00:06:12,266 --> 00:06:14,706
A couple of the limitations of random number generators.

149
00:06:15,546 --> 00:06:17,987
I'm going to talk about noise functions as an alternative,

150
00:06:19,667 --> 00:06:23,808
and entertain the possibility of can we make a random number generator that's based on noise,

151
00:06:24,488 --> 00:06:26,408
or noise that's based on random number generators,

152
00:06:27,228 --> 00:06:28,148
and then a couple of tidbits.

153
00:06:28,688 --> 00:06:29,689
So that's where we're going to go with this.

154
00:06:29,969 --> 00:06:32,289
So first of all, what do we want to look for in a random number generator?

155
00:06:33,462 --> 00:06:35,004
What makes one good?

156
00:06:36,405 --> 00:06:39,008
Well, I think academics would start answering,

157
00:06:39,108 --> 00:06:41,030
well, it depends on the period of the blah blah blah.

158
00:06:41,050 --> 00:06:43,352
No, no, no. It really depends who's asking, right?

159
00:06:44,413 --> 00:06:46,635
If you're at the NSA, you have very different needs

160
00:06:47,416 --> 00:06:50,679
for your random algorithms than if you're working on Minecraft,

161
00:06:51,300 --> 00:06:53,602
than if you're working at a casino game, right?

162
00:06:54,984 --> 00:06:56,025
So it really depends who's asking.

163
00:06:57,492 --> 00:07:02,193
So what do I want in an RNG as a game developer who's interested in procedural content generation?

164
00:07:02,694 --> 00:07:07,135
Do I want fair statistical distribution, right? It's kind of, it's random enough.

165
00:07:08,216 --> 00:07:15,579
Yes, I very much want that. And 99% fair in statistical is much better and more important than 95% fair.

166
00:07:15,599 --> 00:07:21,181
It doesn't have to be absolutely perfect, but we really start noticing the differences with falloff.

167
00:07:22,522 --> 00:07:23,862
We want it to not repeat, right?

168
00:07:24,407 --> 00:07:28,389
If we're flipping heads, tails, tails, heads, heads, heads, heads, heads, heads, heads,

169
00:07:28,449 --> 00:07:30,731
heads, we don't want that to happen.

170
00:07:31,191 --> 00:07:36,294
Except, actually we do in the sense that it can and will happen, and so we want it to

171
00:07:36,314 --> 00:07:37,995
happen as much as it should, right?

172
00:07:40,396 --> 00:07:44,258
Do we want some really long repeat period where if we run the random number generator

173
00:07:44,318 --> 00:07:48,581
it will only finish its cycle after the sun has long burned out and died?

174
00:07:48,861 --> 00:07:50,042
That's really important, right?

175
00:07:51,137 --> 00:07:53,398
Probably that doesn't matter so much. As long as it can go,

176
00:07:54,118 --> 00:07:57,159
you know, billions or something, really who cares at some point.

177
00:07:58,040 --> 00:07:59,700
I'm gonna make this point in a different way later.

178
00:08:00,841 --> 00:08:02,502
However, we probably do want to make sure that it

179
00:08:02,842 --> 00:08:06,383
doesn't repeat too quickly. So as long as we can

180
00:08:06,403 --> 00:08:08,704
get millions, billions out of the sequence, we're probably

181
00:08:08,724 --> 00:08:11,226
in the ballpark of OK. And most of the

182
00:08:11,266 --> 00:08:14,047
random number generators you'll deal with have a sequence

183
00:08:14,387 --> 00:08:17,288
length, a period of, in the billions. So probably

184
00:08:17,308 --> 00:08:17,768
not a big deal.

185
00:08:19,056 --> 00:08:20,177
We want to be able to seed it, right?

186
00:08:20,197 --> 00:08:20,918
We want to be able to say,

187
00:08:20,938 --> 00:08:22,680
I'm going to give you the seed of 15,

188
00:08:23,360 --> 00:08:25,262
and then go, go, go, go, generate a world.

189
00:08:25,923 --> 00:08:27,645
And that's totally different than if I gave it a 17

190
00:08:27,885 --> 00:08:29,346
and I said generate the world.

191
00:08:30,508 --> 00:08:31,509
So we want to be able to seed it.

192
00:08:32,870 --> 00:08:35,973
I want to be able to use more than just a few seeds.

193
00:08:36,033 --> 00:08:38,256
So maybe 32 bit, that would give me 4 billion seeds.

194
00:08:38,296 --> 00:08:39,497
That's plenty, right?

195
00:08:40,738 --> 00:08:42,180
There's a lot of random number generators that have.

196
00:08:43,126 --> 00:08:45,407
pickiness about its seeds. Like, use any seed you want.

197
00:08:45,908 --> 00:08:48,790
Oh, except don't use even numbers. Please use

198
00:08:48,970 --> 00:08:51,011
large primes. And definitely don't use zero.

199
00:08:52,372 --> 00:08:53,893
So I'd rather not have that if I can

200
00:08:54,053 --> 00:08:55,134
avoid it.

201
00:08:56,355 --> 00:09:01,178
Some RNGs have this sort of warm-up period where

202
00:09:01,218 --> 00:09:03,339
you get some lousy values before you start getting

203
00:09:03,379 --> 00:09:07,222
really good values. And actually some of the most

204
00:09:07,462 --> 00:09:10,344
well-known generators are some of the worst at this.

205
00:09:11,344 --> 00:09:13,145
This is not something that I want,

206
00:09:13,185 --> 00:09:15,067
because oftentimes I'm gonna want to seed something

207
00:09:15,087 --> 00:09:16,227
and then generate five numbers

208
00:09:16,267 --> 00:09:17,909
and seed something else and generate 20.

209
00:09:18,709 --> 00:09:20,390
So it's those numbers at the beginning of the sequence

210
00:09:20,410 --> 00:09:21,251
that I want the most.

211
00:09:21,731 --> 00:09:22,692
So I don't want this warmup.

212
00:09:25,974 --> 00:09:27,655
Statistically, it is important for me that.

213
00:09:28,553 --> 00:09:29,935
The bits are independent, right?

214
00:09:29,995 --> 00:09:32,457
If I look at, if you give me 32 random bits,

215
00:09:32,858 --> 00:09:35,120
then there should be a 50% chance

216
00:09:35,140 --> 00:09:37,462
that any one of them is on or off at any time.

217
00:09:37,723 --> 00:09:39,244
And a 50% chance that any one of them

218
00:09:39,284 --> 00:09:40,726
agrees or disagrees at any time, right?

219
00:09:40,746 --> 00:09:42,187
They shouldn't be correlated with each other.

220
00:09:43,208 --> 00:09:44,089
Spatially and then,

221
00:09:46,051 --> 00:09:47,953
temporally, meaning that the next result

222
00:09:48,013 --> 00:09:49,594
and the next result shouldn't have anything to do

223
00:09:49,634 --> 00:09:50,575
with the previous result.

224
00:09:51,316 --> 00:09:52,477
At least not recognizably.

225
00:09:54,015 --> 00:09:54,715
Platform independence.

226
00:09:54,755 --> 00:09:56,756
I definitely, definitely, definitely want this.

227
00:09:56,816 --> 00:10:00,318
If I have an Android client and an iOS client and a Mac

228
00:10:00,358 --> 00:10:02,900
and a PC client all connect to something and they're trading

229
00:10:02,960 --> 00:10:05,782
seeds over the network, that thing I generate from the seed

230
00:10:05,802 --> 00:10:08,183
you sent me better be the same as this thing you sent, even

231
00:10:08,203 --> 00:10:09,724
though you have a totally different CPU than me.

232
00:10:10,865 --> 00:10:15,567
You might be on a 32-bit ARM or whatever, and I might be

233
00:10:15,607 --> 00:10:16,808
on a 64-bit Intel.

234
00:10:16,868 --> 00:10:17,909
It could be quite different.

235
00:10:19,650 --> 00:10:21,111
I would love to have order independence.

236
00:10:22,050 --> 00:10:23,891
random access, right, where I could just sort of

237
00:10:24,212 --> 00:10:25,953
jump ahead in the sequence and jump behind.

238
00:10:25,973 --> 00:10:28,654
I want to say, give me the 75th random number

239
00:10:28,674 --> 00:10:29,235
in this sequence.

240
00:10:30,876 --> 00:10:33,017
Unfortunately, that's something random number generators

241
00:10:33,417 --> 00:10:34,278
do not do very well.

242
00:10:35,738 --> 00:10:36,519
We'll talk about that more.

243
00:10:37,459 --> 00:10:39,681
And then of course, I need this reproducibility,

244
00:10:40,041 --> 00:10:41,282
this determinism, right?

245
00:10:41,842 --> 00:10:45,204
If I give you the seed 17, I better get the same results

246
00:10:45,544 --> 00:10:46,865
as the next time I give you the seed 17.

247
00:10:48,912 --> 00:10:51,394
And this is crucial to most of the purposes

248
00:10:51,414 --> 00:10:51,975
we're gonna do with this.

249
00:10:52,715 --> 00:10:53,576
How important is speed?

250
00:10:54,917 --> 00:10:57,559
We may end up wanting to generate a lot of random numbers,

251
00:10:57,679 --> 00:10:58,860
like a lot, a lot, a lot,

252
00:10:58,880 --> 00:11:00,382
and we may wanna do it in real time.

253
00:11:01,162 --> 00:11:03,504
Some of the most interesting algorithms we can do

254
00:11:03,964 --> 00:11:06,286
require us to generate millions of random numbers.

255
00:11:06,486 --> 00:11:07,247
So this does matter.

256
00:11:09,982 --> 00:11:13,264
And we also may want to have thousands or tens of thousands

257
00:11:13,524 --> 00:11:15,625
of random number generators that we're going to instantiate.

258
00:11:15,746 --> 00:11:17,447
That each one is feeding us different numbers.

259
00:11:18,087 --> 00:11:22,210
So we may also care about the ability to whip up another generator

260
00:11:22,250 --> 00:11:23,491
and have it start cranking out numbers.

261
00:11:24,632 --> 00:11:25,272
Memory footprint.

262
00:11:25,852 --> 00:11:28,454
How much memory does each RNG have?

263
00:11:28,654 --> 00:11:31,416
If I've got 10,000 of them, am I going to care?

264
00:11:31,436 --> 00:11:32,117
Am I going to notice?

265
00:11:32,177 --> 00:11:34,598
Is that going to be megs and megs of memory or not?

266
00:11:36,756 --> 00:11:38,318
Can I run it in parallel?

267
00:11:38,698 --> 00:11:39,980
Right, if I have multiple threads,

268
00:11:40,300 --> 00:11:42,523
can they all be rolling random numbers at the same time?

269
00:11:43,504 --> 00:11:45,006
Is this thread safe?

270
00:11:46,227 --> 00:11:48,810
Can I use one RNG, one generator,

271
00:11:48,990 --> 00:11:50,252
that multiple threads are saying,

272
00:11:50,392 --> 00:11:51,714
hey, give me numbers, give me numbers?

273
00:11:52,254 --> 00:11:54,617
Or does each thread have to create its own generator?

274
00:11:54,817 --> 00:11:55,698
Which is not the end of the world.

275
00:11:57,225 --> 00:11:59,467
OK, so which RNGs are out there?

276
00:11:59,507 --> 00:12:00,088
What can we use?

277
00:12:00,528 --> 00:12:02,450
I'm going to go really quickly through this, but just a sense

278
00:12:02,490 --> 00:12:03,951
of what kinds of things there are.

279
00:12:04,191 --> 00:12:08,575
So the simplest random number generators, like these, are

280
00:12:08,675 --> 00:12:11,217
literally boiled down to, if you can see the code on the

281
00:12:11,237 --> 00:12:14,600
bottom here, some internal state, say some number.

282
00:12:15,340 --> 00:12:18,002
And we multiply it by some weird number, say a big prime.

283
00:12:19,163 --> 00:12:20,945
And then that's our new state.

284
00:12:21,605 --> 00:12:22,646
Oh, and then we return it to you.

285
00:12:23,438 --> 00:12:25,659
And then the next time you call it, we take that new state

286
00:12:25,719 --> 00:12:27,720
and we mung it some more and then we return it to you.

287
00:12:27,860 --> 00:12:31,282
So we kind of are constantly chewing and mangling our state and returning it.

288
00:12:33,042 --> 00:12:36,984
This sucks because if I put in a seed of zero,

289
00:12:37,044 --> 00:12:38,525
meaning I start the state off as zero,

290
00:12:38,545 --> 00:12:40,785
then it will be zero times I don't care.

291
00:12:40,805 --> 00:12:44,327
Because zero is zero and then it will just be stuck at zero forever.

292
00:12:44,347 --> 00:12:45,067
Right?

293
00:12:47,458 --> 00:12:49,539
In the numerical recipes, they improve this.

294
00:12:49,840 --> 00:12:53,422
And these are called mixed congruential generators,

295
00:12:53,522 --> 00:12:55,984
where they just multiply by something and add a number.

296
00:12:56,084 --> 00:12:56,345
Great.

297
00:12:58,066 --> 00:13:00,247
And supposedly this, I thought, was what rand was,

298
00:13:00,307 --> 00:13:03,089
but my results later in this tell me

299
00:13:03,110 --> 00:13:04,751
that it's doing something even more sinister.

300
00:13:04,771 --> 00:13:07,913
Okay, so that's great.

301
00:13:07,933 --> 00:13:08,734
Why not just use rand?

302
00:13:08,774 --> 00:13:10,175
It's been in the standard forever.

303
00:13:10,295 --> 00:13:11,055
Everyone knows how to use it.

304
00:13:11,716 --> 00:13:13,657
Well, probably you know that rand only gives you

305
00:13:13,897 --> 00:13:14,758
so many numbers, right?

306
00:13:14,798 --> 00:13:15,038
Zero to 32,000.

307
00:13:18,173 --> 00:13:20,454
Okay, well if I wanted a 32-bit RAND,

308
00:13:20,474 --> 00:13:22,694
I'll just mash three RANDs together, right?

309
00:13:22,795 --> 00:13:23,575
Maybe bit shift.

310
00:13:24,435 --> 00:13:26,676
So I could make something called triple RAND, right?

311
00:13:27,396 --> 00:13:31,117
Where I take these, let's see if you can see my mouse cursor,

312
00:13:31,757 --> 00:13:33,498
these 15 bits that it's giving me,

313
00:13:33,598 --> 00:13:34,698
and actually the bottom two bits

314
00:13:34,738 --> 00:13:37,599
are a little bit statistically wonky, no problem.

315
00:13:38,019 --> 00:13:40,980
We'll just generate RAND, shift it over from some bits,

316
00:13:41,320 --> 00:13:42,400
generate RAND, shift it over,

317
00:13:42,780 --> 00:13:43,821
and then mash those together.

318
00:13:43,881 --> 00:13:46,342
Now we get 32 good bits of RAND.

319
00:13:49,191 --> 00:13:50,691
Unfortunately, RAND's not that fast.

320
00:13:50,732 --> 00:13:53,312
When we start doing millions and millions of calls,

321
00:13:53,332 --> 00:13:54,713
and of course it's not going to get any better

322
00:13:54,733 --> 00:13:55,653
if we call it three times,

323
00:13:56,073 --> 00:13:57,814
just to try to get better results.

324
00:13:59,114 --> 00:14:02,035
And RAND does not do well at all, statistically,

325
00:14:02,256 --> 00:14:04,996
in terms of how evenly distributed the random numbers are.

326
00:14:05,577 --> 00:14:07,357
Though this triple RAND can do fine.

327
00:14:09,424 --> 00:14:11,606
Also, random maintains a global state.

328
00:14:12,246 --> 00:14:15,828
So if I have 16 different threads, I can say srand to

329
00:14:15,908 --> 00:14:17,850
seed it to the number 17.

330
00:14:18,330 --> 00:14:19,751
And then I call rand, rand, rand.

331
00:14:19,931 --> 00:14:22,593
If some other thread is doing that as well, it's fighting

332
00:14:22,993 --> 00:14:24,674
with me, and it's disrupting my sequence.

333
00:14:25,314 --> 00:14:28,296
So it's absolutely the worst thing for me to have in terms

334
00:14:28,336 --> 00:14:28,957
of multithreading.

335
00:14:31,398 --> 00:14:32,819
And that's just the beginning of rand's problems.

336
00:14:33,560 --> 00:14:35,861
So let's look at a couple of sort of.

337
00:14:37,045 --> 00:14:40,247
quantitative grades of how well these things do and

338
00:14:40,367 --> 00:14:41,047
how fast they are.

339
00:14:41,547 --> 00:14:44,929
So identity here is a random number generator where

340
00:14:45,189 --> 00:14:46,669
every time you say, give me another number, it

341
00:14:46,729 --> 00:14:49,451
says, OK, one, two, three, four, five.

342
00:14:49,551 --> 00:14:50,031
That's all it is.

343
00:14:51,088 --> 00:14:52,609
So obviously that doesn't do very well.

344
00:14:53,990 --> 00:14:55,591
And I have these different tests, and we could talk about

345
00:14:55,611 --> 00:14:56,491
them later if there's time.

346
00:14:56,571 --> 00:15:00,113
But on average, are the bits 50% on or off?

347
00:15:00,793 --> 00:15:02,634
On average, are bits independent from each other?

348
00:15:03,154 --> 00:15:06,996
Is the next number more likely to be higher?

349
00:15:07,376 --> 00:15:08,897
That should be true 50% of the time.

350
00:15:09,577 --> 00:15:12,218
When I look at each byte, are the bytes distributed over the

351
00:15:12,238 --> 00:15:13,659
different possibilities nicely?

352
00:15:14,059 --> 00:15:16,500
And then if I mod by all the different numbers from one to

353
00:15:16,540 --> 00:15:16,920
a million.

354
00:15:17,660 --> 00:15:18,840
and do that a ton of times,

355
00:15:18,880 --> 00:15:22,082
does it statistically mod, you know, spread nicely.

356
00:15:22,122 --> 00:15:23,883
So if I do this RAND mod 7,

357
00:15:24,643 --> 00:15:26,704
do I tend to get about even results

358
00:15:26,744 --> 00:15:28,225
across those seven buckets?

359
00:15:29,286 --> 00:15:29,926
And you can see here,

360
00:15:30,806 --> 00:15:36,829
these early and common random number generators,

361
00:15:36,969 --> 00:15:38,530
most of them do not do well at all

362
00:15:38,610 --> 00:15:39,611
on these statistical tests.

363
00:15:40,091 --> 00:15:42,752
This triple RAND does much better, thankfully.

364
00:15:43,412 --> 00:15:45,493
If we look at the call time,

365
00:15:45,553 --> 00:15:46,734
this is the top here.

366
00:15:47,868 --> 00:15:51,250
You can see I can make quite a number of calls per millisecond,

367
00:15:51,730 --> 00:15:54,832
but triple RAND is down to 10,000 calls per millisecond,

368
00:15:54,852 --> 00:15:56,673
which seems pretty fast,

369
00:15:57,513 --> 00:15:59,555
unless, again, we're going to be doing millions of them.

370
00:16:00,475 --> 00:16:01,256
So, not bad.

371
00:16:01,276 --> 00:16:04,177
I would say you're fired for all of them

372
00:16:04,217 --> 00:16:05,698
except for this triple RAND so far.

373
00:16:07,377 --> 00:16:08,778
OK. There's some other ones to consider.

374
00:16:08,798 --> 00:16:10,658
I'm not going to go into too much detail, but

375
00:16:12,359 --> 00:16:14,079
if you have to leave in this talk right now,

376
00:16:14,199 --> 00:16:15,740
I would say the one takeaway is at least

377
00:16:15,760 --> 00:16:17,640
do something like this XOR shift one.

378
00:16:18,240 --> 00:16:19,621
It's like RAND, but doesn't suck.

379
00:16:20,761 --> 00:16:23,942
And it's a simple algorithm where you just sort of

380
00:16:25,442 --> 00:16:27,503
bit shift around and XOR with yourself.

381
00:16:27,703 --> 00:16:28,723
And you do that enough times.

382
00:16:29,003 --> 00:16:32,184
Surprisingly, it has very good statistical results.

383
00:16:32,784 --> 00:16:34,365
And there's various other variations of it.

384
00:16:35,927 --> 00:16:38,028
Now by now, probably many of you are thinking,

385
00:16:38,068 --> 00:16:40,450
well, geez, why don't you just get with the program.

386
00:16:40,570 --> 00:16:42,051
We all know there's Mersenne Twister,

387
00:16:42,251 --> 00:16:43,312
and that's the best thing, right?

388
00:16:43,492 --> 00:16:44,873
And it's in the C++ standard now.

389
00:16:47,374 --> 00:16:47,975
Let's take a look.

390
00:16:49,676 --> 00:16:51,797
First of all, it's not simple, right?

391
00:16:52,458 --> 00:16:55,100
If I call rand on the right, it does a bunch of stuff,

392
00:16:55,500 --> 00:16:57,181
and one of those things is, every now and then,

393
00:16:57,241 --> 00:16:59,183
it calls twist, which is a bunch of stuff on the left,

394
00:16:59,663 --> 00:17:00,764
with a for loop, right?

395
00:17:01,744 --> 00:17:04,106
Branches, this just doesn't smell that fast to me.

396
00:17:05,268 --> 00:17:06,169
And sure enough, it's not.

397
00:17:07,209 --> 00:17:08,330
We'll go more into that in a second.

398
00:17:08,811 --> 00:17:10,352
Here's another one that's Intel actually

399
00:17:10,372 --> 00:17:13,354
has some really cool random generators on their website.

400
00:17:13,915 --> 00:17:15,276
This is one I took from their website.

401
00:17:15,936 --> 00:17:18,318
Everyone can obviously understand this code, right?

402
00:17:18,639 --> 00:17:20,420
So you all see what's going on there.

403
00:17:23,483 --> 00:17:24,524
So let's look at how these do.

404
00:17:25,765 --> 00:17:27,927
When I look at these different random number generators,

405
00:17:28,127 --> 00:17:30,849
you can see now everything triple random below

406
00:17:30,929 --> 00:17:31,930
is scoring pretty well.

407
00:17:32,110 --> 00:17:34,031
Mersenne Twister actually only scores a 98.

408
00:17:34,652 --> 00:17:37,253
There's another set of tests you can apply to these,

409
00:17:37,434 --> 00:17:39,235
which I'll talk about at the end if there's time.

410
00:17:39,995 --> 00:17:41,757
But these are more simple and direct to what I wanted.

411
00:17:42,477 --> 00:17:45,159
So actually Mersenne Twister was not the strongest.

412
00:17:45,199 --> 00:17:46,740
These XOR shifts were slightly better.

413
00:17:47,401 --> 00:17:49,683
If you look at the time to run them,

414
00:17:50,622 --> 00:17:54,783
Mersenne twister's pretty fast, but the XOR shifts

415
00:17:54,803 --> 00:17:57,963
are better quality and they're faster.

416
00:17:57,983 --> 00:18:00,684
All right, so that's interesting.

417
00:18:01,664 --> 00:18:03,284
There's another thing that's interesting here to note

418
00:18:03,344 --> 00:18:07,205
is Mersenne twister, notice it takes to seed it,

419
00:18:07,925 --> 00:18:11,446
it's hundreds of times slower than any other thing.

420
00:18:11,826 --> 00:18:13,847
It's so complicated to seed the structure,

421
00:18:15,047 --> 00:18:16,547
and it's also got a lot of memory.

422
00:18:18,348 --> 00:18:18,528
Okay.

423
00:18:19,399 --> 00:18:21,639
All of these functions are based on the central idea

424
00:18:21,759 --> 00:18:23,340
of a recurrence relation function.

425
00:18:24,600 --> 00:18:27,541
And that's basically just to say, any RNG, just pick one,

426
00:18:28,702 --> 00:18:29,902
it basically amounts to this.

427
00:18:30,402 --> 00:18:33,503
Take your state, do something funky to it, and return that.

428
00:18:34,143 --> 00:18:35,544
And then that's your state for next time.

429
00:18:35,884 --> 00:18:37,184
And then you do something funky to that.

430
00:18:37,765 --> 00:18:39,545
And so as long as you pick the right funky,

431
00:18:40,385 --> 00:18:43,827
this thing will create a long chain of interesting things, hopefully.

432
00:18:46,177 --> 00:18:50,081
OK, so lastly I'll just mention there's STD random device.

433
00:18:50,121 --> 00:18:50,662
It's a new thing.

434
00:18:50,682 --> 00:18:52,664
I don't know if it was C++11 or something added.

435
00:18:53,105 --> 00:18:55,527
This is something you should not use for your random

436
00:18:55,547 --> 00:18:56,308
number generation.

437
00:18:56,728 --> 00:19:01,413
This is meant to be physically actually really random, right?

438
00:19:01,774 --> 00:19:04,516
Like, I don't know if it's based on the temperature of

439
00:19:04,556 --> 00:19:05,778
the core or something like that.

440
00:19:05,798 --> 00:19:06,999
I don't know how you do that on a computer.

441
00:19:07,650 --> 00:19:09,952
but it's meant to be an actual random, not a pseudo-random.

442
00:19:11,394 --> 00:19:13,276
For games, that's not really useful at all,

443
00:19:13,316 --> 00:19:16,139
unless perhaps you want something super-random-y

444
00:19:16,159 --> 00:19:18,022
just to kick off your random number generator.

445
00:19:19,824 --> 00:19:22,527
Okay, so I wanna talk about the limitations

446
00:19:22,687 --> 00:19:24,629
of these random number generators,

447
00:19:24,749 --> 00:19:26,031
all of the ones we just discussed.

448
00:19:28,422 --> 00:19:30,563
Many of them have restrictions on the seeds.

449
00:19:30,623 --> 00:19:33,985
Like I said, if you use a seed of an even number

450
00:19:34,745 --> 00:19:36,987
or seed them with zero, half of them break

451
00:19:37,107 --> 00:19:37,787
right out the gate.

452
00:19:38,288 --> 00:19:39,768
And a lot of them have even weirder rules,

453
00:19:39,808 --> 00:19:42,510
like you should use a seed that's a prime

454
00:19:42,570 --> 00:19:44,851
or a seed that's a prime that's one less than a power of two

455
00:19:44,931 --> 00:19:45,572
or something like that.

456
00:19:46,252 --> 00:19:48,353
That's no use for me if I want to have

457
00:19:48,814 --> 00:19:50,554
different planets with ID numbers,

458
00:19:50,614 --> 00:19:52,896
or NPCs with ID numbers,

459
00:19:53,096 --> 00:19:54,617
and this NPC is ID number 12.

460
00:19:55,777 --> 00:19:57,758
Please generate yourself based on that seed.

461
00:19:58,639 --> 00:20:00,480
Right? Well, what if that seed doesn't play well

462
00:20:00,520 --> 00:20:01,500
with the random number generator?

463
00:20:01,600 --> 00:20:03,181
Am I just going to get a really lame NPC,

464
00:20:04,121 --> 00:20:06,443
or am I going to get a lot of clones of the same NPC?

465
00:20:08,363 --> 00:20:10,045
There's a bigger complaint I have, which is that

466
00:20:10,305 --> 00:20:13,048
when we say seeds in these random number generators,

467
00:20:14,570 --> 00:20:16,652
I think it's kind of misleading.

468
00:20:16,672 --> 00:20:18,874
They're not really giving us a whole new set

469
00:20:18,914 --> 00:20:19,655
of random numbers.

470
00:20:19,715 --> 00:20:22,739
They're just jumping us into a different starting point

471
00:20:22,779 --> 00:20:23,940
in that same sequence.

472
00:20:25,156 --> 00:20:26,937
So if the sequence is a billion numbers long,

473
00:20:27,297 --> 00:20:29,538
we might start halfway into it if we use one seed.

474
00:20:29,578 --> 00:20:30,999
We might start a third of the way into it

475
00:20:31,099 --> 00:20:32,119
if we use a different seed.

476
00:20:33,040 --> 00:20:36,301
And this is why the mathematicians get us all excited

477
00:20:36,341 --> 00:20:37,822
about something like Mersenne-Twister

478
00:20:37,862 --> 00:20:41,064
having a ridiculously long sequence,

479
00:20:41,684 --> 00:20:43,025
a period before it repeats,

480
00:20:43,085 --> 00:20:44,905
is because when you sort of jump into it,

481
00:20:45,326 --> 00:20:48,167
you're not likely to sort of find familiar territory

482
00:20:48,207 --> 00:20:49,748
that you were in before, hopefully.

483
00:20:51,600 --> 00:20:54,302
But the seeds are not really a different set of random numbers.

484
00:20:54,322 --> 00:20:55,643
They're just a different starting point.

485
00:20:57,044 --> 00:20:58,545
I mentioned the slow warmup, right?

486
00:20:59,206 --> 00:21:01,628
Mersenne twister included produces weak values

487
00:21:01,688 --> 00:21:03,489
before it starts getting statistically strong.

488
00:21:04,109 --> 00:21:06,291
And that's fine if you're doing scientific programming,

489
00:21:06,311 --> 00:21:09,974
you want to have 250 million random results

490
00:21:10,034 --> 00:21:11,595
and you want them to be statistically sound.

491
00:21:12,356 --> 00:21:14,678
It's not fine if you want to just make an NPC

492
00:21:14,698 --> 00:21:16,439
and you need six die rolls and they're all bad.

493
00:21:18,401 --> 00:21:19,882
Threat safety is important.

494
00:21:21,611 --> 00:21:23,352
Something like Merced and Twister, and most of them,

495
00:21:23,712 --> 00:21:27,114
uses an internal state, so it's not thread-safe.

496
00:21:27,214 --> 00:21:30,916
Every call to it modifies the random number generator.

497
00:21:30,976 --> 00:21:33,738
However, you can instantiate a different generator

498
00:21:33,818 --> 00:21:36,319
on each thread, and then each thread can hammer

499
00:21:36,359 --> 00:21:38,380
on its own generator, no problem.

500
00:21:40,223 --> 00:21:42,164
However, you can still have the case where

501
00:21:43,125 --> 00:21:45,266
this thread seeds with the number five,

502
00:21:45,427 --> 00:21:47,408
this thread seeds with the number seven,

503
00:21:47,488 --> 00:21:49,009
and this thread is pulling numbers

504
00:21:49,850 --> 00:21:51,851
and this one faster than this other one.

505
00:21:52,411 --> 00:21:54,273
And actually, because we're still all pulling out

506
00:21:54,293 --> 00:21:55,293
of the same sequence of numbers,

507
00:21:55,313 --> 00:21:57,015
we can kind of sort of sync up.

508
00:21:57,835 --> 00:22:00,657
And so I can pass you or lap you

509
00:22:00,717 --> 00:22:01,978
or even come in sync with you

510
00:22:02,058 --> 00:22:03,739
in the same part of the number sequence.

511
00:22:04,720 --> 00:22:07,382
And of course, rand, we said, do not use across threads

512
00:22:07,402 --> 00:22:08,683
because it has this global state.

513
00:22:11,344 --> 00:22:14,365
Order to dependency, this is my single biggest objection

514
00:22:14,426 --> 00:22:15,746
to these random number generators.

515
00:22:16,487 --> 00:22:17,928
Every call affects the next one,

516
00:22:18,768 --> 00:22:21,310
so whatever you generate has to be generated

517
00:22:21,370 --> 00:22:22,351
in a strict order.

518
00:22:22,991 --> 00:22:25,293
If I give you the seed 17, that's not enough.

519
00:22:25,873 --> 00:22:29,896
You have to generate the same NPCs, tiles, maps, weapons,

520
00:22:30,096 --> 00:22:32,257
loot, drop, whatever, particles,

521
00:22:32,718 --> 00:22:34,479
in exactly the same order that I did,

522
00:22:34,819 --> 00:22:36,960
or else the sequence gets disrupted, right?

523
00:22:36,980 --> 00:22:38,842
So it's very sequential, it's highly ordered.

524
00:22:40,784 --> 00:22:43,086
This sucks when, say, we want to generate

525
00:22:43,386 --> 00:22:44,948
infinite number of things out of order.

526
00:22:45,969 --> 00:22:48,911
So just to illustrate that point.

527
00:22:50,413 --> 00:22:53,095
So let's say I have some world that's an infinite world,

528
00:22:53,135 --> 00:22:54,997
right, and I can go as far as I want,

529
00:22:55,798 --> 00:22:56,999
and the world just keeps generating

530
00:22:57,079 --> 00:22:57,959
over and over and over and over.

531
00:22:58,900 --> 00:23:01,863
Well, if I see that there's a island over here,

532
00:23:02,383 --> 00:23:04,926
let me get some island, okay.

533
00:23:04,946 --> 00:23:06,467
So I don't know if you can see in the distance.

534
00:23:07,764 --> 00:23:09,525
there's an island that's kind of half-generated.

535
00:23:09,545 --> 00:23:10,726
And I'm gonna back away from it,

536
00:23:11,026 --> 00:23:12,167
and then I'm gonna go around here.

537
00:23:12,868 --> 00:23:14,869
And now I had to go exploring, ta-da-da,

538
00:23:14,949 --> 00:23:17,871
I'm going faster than the thing can catch up at the moment.

539
00:23:18,731 --> 00:23:21,553
But if I then approach from the east

540
00:23:22,134 --> 00:23:23,054
instead of from the south,

541
00:23:23,375 --> 00:23:25,476
I still have to come up with that same island

542
00:23:25,496 --> 00:23:26,637
that I would have before, right?

543
00:23:27,017 --> 00:23:30,139
So I can't roll a bunch of random numbers ahead of time

544
00:23:30,179 --> 00:23:31,740
and just figure out where all the islands are

545
00:23:31,780 --> 00:23:33,061
because there's an infinite number of them.

546
00:23:33,741 --> 00:23:35,643
And I need to be able to encounter them in random order.

547
00:23:39,701 --> 00:23:41,361
So, we have poor random access.

548
00:23:41,902 --> 00:23:44,702
How do you jump 100 numbers ahead in the sequence?

549
00:23:45,722 --> 00:23:48,003
In any normal traditional random number generator,

550
00:23:48,023 --> 00:23:50,324
you just have to roll 100 times, right,

551
00:23:50,344 --> 00:23:52,624
to skip ahead for some reason if you needed to do that.

552
00:23:53,084 --> 00:23:54,525
You wanna jump back three in the sequence?

553
00:23:55,125 --> 00:23:56,325
Sorry, can't do it.

554
00:23:57,405 --> 00:24:00,066
Maybe if you knew, oh, I was generated from seed 2261

555
00:24:00,106 --> 00:24:02,087
and I'm 1400 calls in, you could reseed

556
00:24:02,267 --> 00:24:02,907
and then call three,

557
00:24:07,841 --> 00:24:09,982
1397, right, that's ridiculous.

558
00:24:10,642 --> 00:24:12,042
So we have terrible random access.

559
00:24:14,123 --> 00:24:16,063
We also have non-trivial instantiation.

560
00:24:16,883 --> 00:24:19,824
Like I said, there's a lot of interesting algorithms

561
00:24:19,844 --> 00:24:21,164
that happen in procedural generation

562
00:24:21,364 --> 00:24:24,545
that require us to have thousands or tens of thousands

563
00:24:24,585 --> 00:24:26,006
or even hundreds of thousands

564
00:24:26,526 --> 00:24:28,586
of different random number generators instantiated.

565
00:24:30,160 --> 00:24:32,283
So if we can't make them fast,

566
00:24:32,323 --> 00:24:33,624
and if they're not small in memory,

567
00:24:33,684 --> 00:24:36,286
that actually takes tons of tools away from us.

568
00:24:36,327 --> 00:24:37,428
Takes tons of algorithmic,

569
00:24:38,349 --> 00:24:41,331
interesting procedural content options off the table.

570
00:24:43,434 --> 00:24:47,117
And then there's the lack of temporal and spatial coherence.

571
00:24:47,157 --> 00:24:48,118
And by that I just mean,

572
00:24:48,679 --> 00:24:52,482
if you want to have a slope that's random heights,

573
00:24:52,543 --> 00:24:54,044
and you're kind of smoothing it out between them.

574
00:24:54,600 --> 00:24:56,361
you have to generate the numbers ahead of time

575
00:24:56,401 --> 00:24:58,803
and remember them in order to smooth between them.

576
00:24:58,843 --> 00:25:00,284
You can't go back and say, wait, wait,

577
00:25:00,324 --> 00:25:01,245
what was the number before?

578
00:25:01,645 --> 00:25:01,965
Too late.

579
00:25:03,306 --> 00:25:05,948
So it means you have to end up writing all this extra code

580
00:25:06,549 --> 00:25:07,569
and storing all this extra data.

581
00:25:09,231 --> 00:25:11,272
And if you're still really, really jonesing

582
00:25:11,392 --> 00:25:14,655
on Mersenne Twister, I'll just quote Wikipedia.

583
00:25:15,455 --> 00:25:17,677
Places a load on memory caches, somewhat slow,

584
00:25:17,777 --> 00:25:21,080
fails tests, not appropriate for Monte Carlo simulations,

585
00:25:21,200 --> 00:25:23,461
outputs nearly the same sequence for many iterations.

586
00:25:25,754 --> 00:25:27,395
All right. So I'm not saying Mersenne Twister is bad.

587
00:25:27,415 --> 00:25:29,856
I'm saying, when you talk to anyone on the

588
00:25:29,876 --> 00:25:31,817
street, a game developer, you ask them what do

589
00:25:31,837 --> 00:25:33,619
they know about random numbers, they'll say, oh, rand

590
00:25:33,639 --> 00:25:35,560
is bad. You should use Mersenne Twister. That's the

591
00:25:35,640 --> 00:25:37,621
one thing they know. And I'm saying that's not

592
00:25:37,641 --> 00:25:38,342
necessarily true.

593
00:25:40,623 --> 00:25:44,446
It's heavy weight. Every RNG you instantiate is 2K

594
00:25:44,506 --> 00:25:47,007
of memory, which I still can't.

