1
00:00:06,475 --> 00:00:08,256
Hello, my name is Graham Willetall,

2
00:00:08,477 --> 00:00:10,558
and I'm a rendering engineer for the Frostbite Labs team

3
00:00:10,578 --> 00:00:11,439
at Electronic Arts.

4
00:00:15,203 --> 00:00:17,204
This presentation will cover the various features,

5
00:00:17,485 --> 00:00:19,547
improvements, and optimizations developed

6
00:00:19,607 --> 00:00:21,328
for our 4K checkerboard technology

7
00:00:21,368 --> 00:00:23,430
that shipped in Battlefield 1 on PS4,

8
00:00:24,051 --> 00:00:25,592
as well as in Mass Effect Andromeda,

9
00:00:25,892 --> 00:00:27,654
and the majority of other titles moving forward.

10
00:00:39,255 --> 00:00:41,176
First, I'd like to discuss our motivation.

11
00:00:44,117 --> 00:00:45,938
Frostbite Labs has been focusing on a number of

12
00:00:45,998 --> 00:00:48,699
longer-term projects to advance games, graphics, and

13
00:00:48,739 --> 00:00:49,340
storytelling.

14
00:00:50,280 --> 00:00:53,041
In addition, some shorter-term work has been completed, such

15
00:00:53,081 --> 00:00:54,982
as a strong push to efficiently target higher

16
00:00:55,022 --> 00:00:57,643
perceived resolutions with the Frostbite Engine and games.

17
00:01:01,525 --> 00:01:03,606
Here's a screenshot of Mass Effect Andromeda running at

18
00:01:03,626 --> 00:01:04,426
1080p on a PS4 Pro.

19
00:01:08,710 --> 00:01:10,851
And here's a screenshot of this environment at 1800p,

20
00:01:11,091 --> 00:01:12,992
which offers a substantially higher increase

21
00:01:13,052 --> 00:01:15,613
in visual fidelity compared to the 1080p version.

22
00:01:19,054 --> 00:01:20,275
And here's a screenshot of this environment

23
00:01:20,295 --> 00:01:22,976
running at 2160p, or 4K resolution,

24
00:01:23,376 --> 00:01:24,637
which adds some additional quality.

25
00:01:25,337 --> 00:01:26,778
I do apologize for the camera deltas,

26
00:01:26,858 --> 00:01:28,378
it was tricky to get the exact same view

27
00:01:28,598 --> 00:01:29,819
in the scene due to some gameplay.

28
00:01:33,360 --> 00:01:34,661
Let's look at the difference in detail

29
00:01:34,681 --> 00:01:35,621
for the highlighted region.

30
00:01:39,833 --> 00:01:41,995
Comparing the left version, which is 1080p, to the right

31
00:01:42,035 --> 00:01:44,237
version at 4K, you can see how much more detail and

32
00:01:44,277 --> 00:01:45,898
crispness the high resolution offers.

33
00:01:49,702 --> 00:01:54,185
Looking at another highlighted region, you can clearly see

34
00:01:54,205 --> 00:01:56,567
how much of the original art intention is being lost due to

35
00:01:56,587 --> 00:01:57,308
the undersampling.

36
00:02:01,611 --> 00:02:06,415
Looking at another highlighted region, this is a similar case.

37
00:02:10,500 --> 00:02:11,321
And one last region.

38
00:02:14,501 --> 00:02:16,142
You can see much of the details are blurred out

39
00:02:16,162 --> 00:02:17,582
compared to the high resolution version.

40
00:02:22,483 --> 00:02:25,064
Over the past few years, visual fidelity and complexity

41
00:02:25,104 --> 00:02:26,044
has greatly increased,

42
00:02:26,504 --> 00:02:28,524
accredited to an order of magnitude increase

43
00:02:28,644 --> 00:02:30,625
in both available memory and primitive rate,

44
00:02:31,185 --> 00:02:32,565
as well as algorithmic advances

45
00:02:32,585 --> 00:02:34,126
with huge computational demands,

46
00:02:34,526 --> 00:02:37,547
like PBR, dynamic GI, SSR, and others.

47
00:02:40,395 --> 00:02:42,977
Comparing previous generation consoles to current generation,

48
00:02:43,437 --> 00:02:45,419
the number of display pixels was roughly doubled.

49
00:02:45,979 --> 00:02:47,901
But scene complexity has increased dramatically.

50
00:02:47,921 --> 00:02:50,763
It's about time that perceived resolution got a bump as well.

51
00:02:55,167 --> 00:02:56,748
In this screenshot, you can see the type

52
00:02:56,788 --> 00:02:58,490
of detailed environments that are being rendered

53
00:02:58,530 --> 00:02:59,270
in modern games.

54
00:03:00,251 --> 00:03:02,373
Scenes like this generally require reasonably high

55
00:03:02,413 --> 00:03:04,835
resolution in order to reduce aliasing artifacts

56
00:03:05,415 --> 00:03:07,397
and showcase the details desired by the artists.

57
00:03:11,367 --> 00:03:15,828
Rendering extremely detailed geometry requires a much higher sampling frequency or ugly geometric

58
00:03:15,888 --> 00:03:16,668
aliasing occurs.

59
00:03:17,848 --> 00:03:21,909
Without additional high-resolution geometry information, the bulk of techniques that exist

60
00:03:21,929 --> 00:03:26,450
for removing geometric aliasing sacrifice overall image quality in favor of temporal

61
00:03:26,470 --> 00:03:26,950
stability.

62
00:03:28,930 --> 00:03:33,752
Previously, Frostbite had deferred MSAA support, but as it was an ongoing maintenance nightmare,

63
00:03:34,052 --> 00:03:36,672
it was removed in order to reduce complexity in our rendering.

64
00:03:38,633 --> 00:03:40,655
And while acceptable software solutions exist,

65
00:03:41,135 --> 00:03:43,717
Sony recently added new hardware features to PS4 Pro

66
00:03:44,097 --> 00:03:45,919
that allowed us to more easily and efficiently

67
00:03:46,079 --> 00:03:47,540
implement higher resolution rendering.

68
00:03:52,984 --> 00:03:55,225
The brute force approach of rendering native 4K

69
00:03:55,465 --> 00:03:57,687
is not doable for the majority of engines or games,

70
00:03:58,187 --> 00:04:00,489
since current hardware is largely bottlenecked by bandwidth.

71
00:04:02,360 --> 00:04:06,761
A very practical method to reduce the shading cost of the image is by shading only a subset

72
00:04:06,781 --> 00:04:11,341
of pixels in the majority of the graphics pipeline, while geometry information is computed

73
00:04:11,361 --> 00:04:12,122
for all pixels.

74
00:04:14,042 --> 00:04:18,323
Some of the information is lost, but with the 4K sampling rate, most of the adjacent

75
00:04:18,363 --> 00:04:22,283
pixels will have strongly correlated shading values, as long as they all belong to the

76
00:04:22,303 --> 00:04:22,884
same surface.

77
00:04:24,964 --> 00:04:28,965
A high-quality geometry-aware resolve is performed to reconstruct the missing information.

78
00:04:32,937 --> 00:04:36,239
Here is some history around how this particular checkerboard implementation came to be.

79
00:04:37,760 --> 00:04:41,563
There were some algorithms and prototypes at Sony that utilized object IDs for edge

80
00:04:41,603 --> 00:04:45,305
detection as well as using EQAA for higher resolution depth.

81
00:04:46,386 --> 00:04:50,408
Killzone Shadowfall then shipped with temporal super resolution and a differential blending

82
00:04:50,468 --> 00:04:50,868
operator.

83
00:04:54,858 --> 00:04:56,980
Then the PS4 Pro was architected to include

84
00:04:57,020 --> 00:04:58,802
some hardware features aimed at more easily

85
00:04:58,822 --> 00:05:00,704
and efficiently supporting alternating pack

86
00:05:00,744 --> 00:05:03,107
checkerboard sampling, as well as some initial

87
00:05:03,127 --> 00:05:05,009
implementations in a few first party games.

88
00:05:07,211 --> 00:05:10,695
Last GDC, Jala at Ubisoft had a great presentation

89
00:05:10,815 --> 00:05:13,598
on MSAA checkerboard implementation in Rainbow Six Siege

90
00:05:14,078 --> 00:05:16,201
that helped bring more awareness to the overall idea.

91
00:05:18,280 --> 00:05:20,322
And now we have implemented our own support in Frostbite

92
00:05:20,342 --> 00:05:22,184
for the alternating pack checkerboard approach,

93
00:05:22,705 --> 00:05:25,167
which shipped in Battlefield 1 and Mass Effect Andromeda.

94
00:05:29,131 --> 00:05:30,892
We tried a number of high-resolution techniques

95
00:05:30,912 --> 00:05:31,933
with varying success.

96
00:05:32,534 --> 00:05:34,636
The results were evaluated on a 50-inch TV

97
00:05:34,736 --> 00:05:37,098
at living room distance, not on a computer monitor

98
00:05:37,238 --> 00:05:38,059
two feet from your face.

99
00:05:39,981 --> 00:05:42,583
We started with native 4K, and while it looks excellent,

100
00:05:42,763 --> 00:05:44,024
the performance is unacceptable.

101
00:05:45,452 --> 00:05:49,195
Other resolutions were evaluated like 1440p and 1800p.

102
00:05:49,896 --> 00:05:51,797
And while 1440p was within budget,

103
00:05:52,037 --> 00:05:54,799
we found that 1800p offered a much more dramatic improvement

104
00:05:54,859 --> 00:05:55,700
over 900p.

105
00:05:57,241 --> 00:05:58,742
One way to think about it, as compared

106
00:05:58,762 --> 00:06:00,143
to the previous console generation,

107
00:06:00,684 --> 00:06:05,347
is that 1440p is to 720p as 1800p is to 900p.

108
00:06:06,508 --> 00:06:08,429
While resolution can be a subjective topic,

109
00:06:08,729 --> 00:06:10,411
recall the difference in quality for 720p versus 900p

110
00:06:10,451 --> 00:06:11,131
on a 1080p screen.

111
00:06:15,395 --> 00:06:17,836
Extra resolution has a roughly linear performance cost,

112
00:06:18,156 --> 00:06:19,297
at least for deferred passes,

113
00:06:19,657 --> 00:06:22,479
but will give diminishing returns in perceived quality.

114
00:06:26,581 --> 00:06:29,502
Here's a scene from Battlefield 1 at native 4K resolution.

115
00:06:30,803 --> 00:06:32,444
29 milliseconds for a 60 hertz game

116
00:06:32,484 --> 00:06:33,624
is obviously a showstopper.

117
00:06:37,066 --> 00:06:40,288
Even rendering at 1800p native and scaling up to 4K

118
00:06:40,548 --> 00:06:43,290
has a cost of 21 milliseconds, which is also too high.

119
00:06:47,765 --> 00:06:49,686
There's been a lot of buzz in the last few years

120
00:06:49,726 --> 00:06:51,968
about variable shading rate, and checkerboard rendering

121
00:06:52,008 --> 00:06:53,428
is a practical idea that could be

122
00:06:53,488 --> 00:06:55,089
used to greatly increase the resolution

123
00:06:55,469 --> 00:06:56,630
without much performance cost.

124
00:07:01,553 --> 00:07:03,874
Some experiments have been done to implement checkerboard using

125
00:07:03,914 --> 00:07:04,334
Stencil.

126
00:07:04,954 --> 00:07:06,335
While we didn't bother with implementing this,

127
00:07:06,355 --> 00:07:08,176
it is important to cover for posterity.

128
00:07:10,077 --> 00:07:12,118
Stencil checkerboard can be done in one by one blocks,

129
00:07:12,158 --> 00:07:13,479
but please don't ever, ever do this.

130
00:07:14,667 --> 00:07:16,428
The GPU shades in two by two quads,

131
00:07:16,528 --> 00:07:18,468
so you'll pay the shading cost of native 4K,

132
00:07:18,528 --> 00:07:19,928
but then throw away half of the work.

133
00:07:23,609 --> 00:07:25,029
In order to get a performance gain,

134
00:07:25,289 --> 00:07:27,390
stencil checkerboard can be done in two by two blocks,

135
00:07:27,630 --> 00:07:29,330
but now the sampling distribution is terrible

136
00:07:29,470 --> 00:07:30,411
with less correlation.

137
00:07:32,011 --> 00:07:33,971
You get great coverage in a two by two block,

138
00:07:34,051 --> 00:07:34,872
but then a huge hole.

139
00:07:36,172 --> 00:07:38,052
In many cases, you'll get diluted color bits

140
00:07:38,112 --> 00:07:40,133
every second quad that are quite blurry,

141
00:07:40,213 --> 00:07:42,253
and in order to solve that, you end up blurring even more.

142
00:07:42,873 --> 00:07:43,533
So what's the point?

143
00:07:49,936 --> 00:07:53,259
Initially, we looked into a 2x color and 4x depth checkerboard.

144
00:07:54,059 --> 00:07:57,923
The portability of this technique is compelling, but is very invasive to the rendering pipeline,

145
00:07:58,543 --> 00:08:01,125
as practically all shaders and render passes need to be modified.

146
00:08:02,786 --> 00:08:06,750
Additionally, this form of checkerboard isn't the most optimal configuration.

147
00:08:08,211 --> 00:08:12,855
Some other variants like 2x color and 2x depth have shipped in some games, but have to sacrifice

148
00:08:12,895 --> 00:08:15,697
some performance to remain portable across various IHVs.

149
00:08:20,888 --> 00:08:25,171
Another experiment was to use 1x color to keep most of the rendering pipeline unchanged,

150
00:08:25,411 --> 00:08:27,012
but render with 4x depth samples.

151
00:08:28,093 --> 00:08:32,856
A geometry-aware upsample from 1080p to 4K was performed with the idea of maintaining

152
00:08:32,876 --> 00:08:33,456
the hard edges.

153
00:08:35,517 --> 00:08:40,160
This was a good idea and is similar to SRAA, except this trades the second pass, normal,

154
00:08:40,220 --> 00:08:44,783
and bilateral of SRAA with a single pass IDs and custom reconstruction.

155
00:08:46,909 --> 00:08:48,570
In the end, the quality wasn't high enough,

156
00:08:49,050 --> 00:08:50,772
and while it could have been improved over time,

157
00:08:51,012 --> 00:08:53,193
the implementation cost between 4K geometry

158
00:08:53,253 --> 00:08:54,954
and 4K checkerboard was comparable.

159
00:08:57,436 --> 00:08:59,097
As such, this approach was abandoned early

160
00:08:59,137 --> 00:09:00,638
to focus on a superior technique.

161
00:09:05,181 --> 00:09:06,942
Eventually, we settled on a very efficient

162
00:09:06,962 --> 00:09:08,083
packed checkerboard technique.

163
00:09:08,803 --> 00:09:11,125
We started with the PS4 Pro reference implementation,

164
00:09:11,405 --> 00:09:13,006
customized and optimized it further,

165
00:09:13,326 --> 00:09:15,728
and then incorporated it into our own temporal anti-aliasing.

166
00:09:20,892 --> 00:09:22,814
The Packed Checkerboard approach gave a substantial

167
00:09:22,834 --> 00:09:25,436
boost to image quality and clarity while maintaining a 60

168
00:09:25,816 --> 00:09:28,258
hertz target and shipped with very positive reviews in

169
00:09:28,278 --> 00:09:28,919
Battlefield 1.

170
00:09:32,822 --> 00:09:34,844
Here's an example scene that rendered with the Packed

171
00:09:34,864 --> 00:09:35,665
Checkerboard approach.

172
00:09:40,188 --> 00:09:42,290
Looking at the highlighted area zoomed in prior to

173
00:09:42,310 --> 00:09:44,952
Checkerboard Resolve, you can see which samples were shaded

174
00:09:45,092 --> 00:09:46,153
and which samples were not.

175
00:09:50,967 --> 00:09:54,309
Reconstructing unshaded samples or holes in the current frame

176
00:09:54,349 --> 00:09:55,971
with information from the previous frame,

177
00:09:56,471 --> 00:09:58,833
as well as using high-resolution geometry information,

178
00:09:59,333 --> 00:10:01,976
can produce a result at very high quality.

179
00:10:08,601 --> 00:10:10,002
Using the PAC checkerboard rendering,

180
00:10:10,322 --> 00:10:12,664
we're able to take this scene, reach comparable image

181
00:10:12,704 --> 00:10:14,786
quality to 1800p native, yet stay

182
00:10:14,826 --> 00:10:15,927
within our performance target.

183
00:10:20,258 --> 00:10:22,079
Here's a close-up of the scene showing 1800p native.

184
00:10:22,119 --> 00:10:27,661
And here's a close-up of the scene showing

185
00:10:27,901 --> 00:10:28,601
1800p checkerboard.

186
00:10:34,403 --> 00:10:36,124
Now I'll go over our specific checkerboard

187
00:10:36,164 --> 00:10:37,244
layout and configuration.

188
00:10:41,186 --> 00:10:45,087
AMD EQAA is a superset of MSAA and provides quite a number of

189
00:10:45,107 --> 00:10:46,168
interesting hardware features.

190
00:10:47,147 --> 00:10:48,928
One such feature is the ability to store

191
00:10:48,988 --> 00:10:50,950
fewer color fragments than depth fragments,

192
00:10:51,610 --> 00:10:53,772
which is exploited by the 4K checkerboard technique.

193
00:10:58,295 --> 00:11:00,097
The most common checkerboard configuration

194
00:11:00,197 --> 00:11:03,159
is to use 2x color and 2x, or 4x depth, sorry.

195
00:11:04,580 --> 00:11:06,802
This approach is nice due to its high portability,

196
00:11:07,302 --> 00:11:09,444
and derivatives do not require any sort of adjustment.

197
00:11:10,085 --> 00:11:11,846
But this approach is inefficient due to the way

198
00:11:11,866 --> 00:11:13,047
that the shading quads are packed.

199
00:11:14,087 --> 00:11:16,048
The example shown here will shade eight samples,

200
00:11:16,148 --> 00:11:17,168
but only store two of them.

201
00:11:21,371 --> 00:11:24,112
Our layout is using 1x color with 2x depth.

202
00:11:25,253 --> 00:11:26,554
With the Packed Checkerboard approach,

203
00:11:26,634 --> 00:11:28,315
you only get one shading quad in this case.

204
00:11:29,095 --> 00:11:31,596
Four samples are shaded with two samples being stored.

205
00:11:32,737 --> 00:11:35,018
On average, the samples are 30% closer together,

206
00:11:35,479 --> 00:11:37,340
which results in a very measurable performance win.

207
00:11:41,556 --> 00:11:43,758
For checkerboard rendering, the sample locations are

208
00:11:43,778 --> 00:11:44,739
alternated each frame.

209
00:11:45,839 --> 00:11:49,302
For configuring EQAA, the scan converter must be informed how

210
00:11:49,322 --> 00:11:52,205
many samples to produce per pixel, as well as the absolute

211
00:11:52,245 --> 00:11:54,627
distance from the pixel center of the sample furthest from

212
00:11:54,647 --> 00:11:55,387
the pixel center.

213
00:11:57,409 --> 00:11:59,030
In the case of our checkerboard layout, the

214
00:11:59,050 --> 00:12:01,332
samples are at 1 quarter and negative 1 quarter from the

215
00:12:01,372 --> 00:12:01,913
pixel center.

216
00:12:06,149 --> 00:12:08,210
Now we'll go over the various features that were used to

217
00:12:08,250 --> 00:12:10,850
remove or reduce checkerboard artifacts, providing an

218
00:12:10,890 --> 00:12:12,151
increase in visual fidelity.

219
00:12:16,452 --> 00:12:18,752
Arguably, the most important feature of our checkerboard

220
00:12:18,872 --> 00:12:21,713
is the object and primitive ID buffer used by the resolve.

221
00:12:23,714 --> 00:12:25,654
The IDs are generated at a higher resolution than

222
00:12:25,714 --> 00:12:28,715
shading. For each geometry sample, an identifier is

223
00:12:28,735 --> 00:12:31,796
stored in an image buffer, which uniquely identifies

224
00:12:31,936 --> 00:12:34,017
object and primitive that are visible at that sample.

225
00:12:36,277 --> 00:12:39,139
Instance draws provide a separate object ID per instance

226
00:12:39,739 --> 00:12:42,401
by binding an array of object IDs, one per instance.

227
00:12:44,482 --> 00:12:45,863
And tessellated draws are given

228
00:12:45,883 --> 00:12:47,484
a primitive ID per input patch.

229
00:12:52,287 --> 00:12:53,468
The ID buffer can be written out

230
00:12:53,508 --> 00:12:54,929
during any full geometry pass,

231
00:12:55,109 --> 00:12:56,990
which is either a depth and ID only pass

232
00:12:57,990 --> 00:12:58,931
or the main scene render.

233
00:13:00,226 --> 00:13:02,448
Since the depth pass will typically consume less memory

234
00:13:02,488 --> 00:13:03,849
bandwidth than the shading passes,

235
00:13:03,869 --> 00:13:06,371
it is advantageous to write the IDs at this point.

236
00:13:08,213 --> 00:13:10,535
On PS4 Pro, the ID generation is performed

237
00:13:10,575 --> 00:13:11,876
without any shader involvement.

238
00:13:12,256 --> 00:13:14,598
So the impact on asynchronous compute jobs and parallel

239
00:13:14,658 --> 00:13:15,239
is minimized.

240
00:13:15,259 --> 00:13:19,462
It is not recommended to add an additional depth pass just

241
00:13:19,482 --> 00:13:22,765
for ID generation, as the increased CPU and GPU overhead

242
00:13:22,805 --> 00:13:23,686
is not worth the benefit.

243
00:13:25,765 --> 00:13:28,427
Without an existing depth-only pass, the ID generation is

244
00:13:28,487 --> 00:13:30,348
easy to integrate into the main shading pass.

245
00:13:31,868 --> 00:13:34,190
Doing so will cause the ID generation to compete with

246
00:13:34,230 --> 00:13:37,331
memory bandwidth, but at least the ID-only samples don't pay

247
00:13:37,351 --> 00:13:37,911
for the shading.

248
00:13:43,714 --> 00:13:47,576
The IDs themselves are stored as 32-bit, 16-bit, or 8-bit

249
00:13:47,596 --> 00:13:48,037
values.

250
00:13:48,917 --> 00:13:51,598
We use an ID that is 31 bits wide, with the most

251
00:13:51,638 --> 00:13:53,059
significant bit of the parameter

252
00:13:53,099 --> 00:13:54,000
ignored by the hardware.

253
00:13:55,677 --> 00:13:59,640
Object ID is 14-bit with an optional 17-bit primitive ID

254
00:14:00,080 --> 00:14:02,902
arithmetically added, which is reset to zero at the end of

255
00:14:02,942 --> 00:14:04,123
each instance or draw.

256
00:14:10,027 --> 00:14:13,050
The ID buffer is a color target bound as the eighth MRT.

257
00:14:14,030 --> 00:14:16,412
A shader cannot export to this target when IDs are being

258
00:14:16,472 --> 00:14:19,414
generated, and since the ID buffer is treated like a color

259
00:14:19,434 --> 00:14:22,536
target, it uses both the CB's data paths and the color

260
00:14:22,576 --> 00:14:23,437
target tile modes.

261
00:14:25,537 --> 00:14:27,738
It is also safe to set this with a null pixel shader

262
00:14:27,959 --> 00:14:29,740
because the eighth MRT is not treated

263
00:14:29,780 --> 00:14:32,082
as a pixel shader target when ID propagation

264
00:14:32,102 --> 00:14:32,742
has been enabled.

265
00:14:35,525 --> 00:14:37,626
An alternative way to produce object IDs

266
00:14:37,827 --> 00:14:39,428
is to export them from the vertex shader.

267
00:14:40,429 --> 00:14:42,791
However, this could reduce the number of VS wave fronts

268
00:14:42,811 --> 00:14:44,272
that can be active on the chip at a time.

269
00:14:46,774 --> 00:14:48,235
There are many other interesting use cases

270
00:14:48,255 --> 00:14:50,757
for the object ID buffer, but for this presentation,

271
00:14:50,897 --> 00:14:52,498
it will be used in the checkerboard resolve

272
00:14:52,518 --> 00:14:53,920
to improve the final image quality.

273
00:14:58,730 --> 00:15:01,272
Here is a complex scene from Battlefield 1 with a number of

274
00:15:01,352 --> 00:15:02,093
unique objects.

275
00:15:08,638 --> 00:15:10,600
This is a visualization of just the object

276
00:15:10,660 --> 00:15:11,601
IDs in the scene.

277
00:15:17,326 --> 00:15:19,948
And here's a visualization of the primitive IDs in the scene.

278
00:15:21,663 --> 00:15:23,884
Remember what I said about the object and primitive IDs

279
00:15:24,325 --> 00:15:25,726
being a bit different for the tessellation,

280
00:15:25,746 --> 00:15:27,206
how it's done at the input patch level?

281
00:15:27,226 --> 00:15:29,228
If you look at the bottom left of that screenshot,

282
00:15:29,248 --> 00:15:31,109
you can see that there are a number of adjacent triangles

283
00:15:31,129 --> 00:15:32,990
of the same color, and that's because the ID

284
00:15:33,010 --> 00:15:35,192
was assigned prior to tessellation expansion.

285
00:15:40,996 --> 00:15:42,957
When rendering a checkerboard with any pixel shaders

286
00:15:42,997 --> 00:15:45,238
that use implicit gradients for mipmap selection,

287
00:15:45,719 --> 00:15:47,260
gradient adjust must be configured,

288
00:15:47,380 --> 00:15:49,001
otherwise graphical artifacts will occur.

289
00:15:50,691 --> 00:15:52,712
On the left, you can see the expected gradient,

290
00:15:53,213 --> 00:15:55,875
but on the right, you can see what the real gradient is.

291
00:15:57,316 --> 00:15:59,838
The horizontal gradient is twice the expected value,

292
00:16:00,218 --> 00:16:01,699
and the vertical gradient is stretched

293
00:16:01,799 --> 00:16:03,260
and rotated 45 degrees,

294
00:16:03,921 --> 00:16:05,762
which resembles bad anisotropic filtering.

295
00:16:10,646 --> 00:16:12,607
In order to correct for the rectangular pixels,

296
00:16:12,867 --> 00:16:14,789
we need to apply a non-uniform rescale.

297
00:16:15,710 --> 00:16:17,791
Because of this, we can't use LOD bias

298
00:16:17,971 --> 00:16:19,112
as it scales uniformly.

299
00:16:20,928 --> 00:16:22,510
Instead, we'll use a gradient fetch

300
00:16:22,590 --> 00:16:23,791
with rescaled coordinates.

301
00:16:28,216 --> 00:16:31,039
The adjustment is done by applying a 2 by 2 affine

302
00:16:31,099 --> 00:16:33,642
transform to the derivatives of the texture coordinates.

303
00:16:35,344 --> 00:16:38,288
If checkerboard is disabled, an identity transform is used

304
00:16:38,428 --> 00:16:40,009
with no measurable performance impact.

305
00:16:41,347 --> 00:16:43,468
This approach allows us to avoid having an extra copy

306
00:16:43,488 --> 00:16:44,748
of all our shader permutations

307
00:16:45,028 --> 00:16:46,849
for the adjusted versus unadjusted case.

308
00:16:47,630 --> 00:16:50,211
And in Frostbite, it's about 80,000 to 100,000 shaders

309
00:16:50,251 --> 00:16:51,372
with our generated pipeline,

310
00:16:51,432 --> 00:16:54,013
so that's an important thing for us.

311
00:16:58,395 --> 00:16:59,516
When checkerboard is enabled,

312
00:16:59,816 --> 00:17:01,637
the adjustment alternates between the two forms

313
00:17:01,677 --> 00:17:02,397
that you see here.

314
00:17:03,618 --> 00:17:05,038
The result will be texture coordinates

315
00:17:05,058 --> 00:17:06,299
that have been adjusted to account

316
00:17:06,339 --> 00:17:07,340
for the packed checkerboard.

317
00:17:14,442 --> 00:17:16,022
Manual gradient correction in the shader

318
00:17:16,062 --> 00:17:17,662
does come at a price for calculating

319
00:17:17,702 --> 00:17:21,503
the adjusted derivatives, which is roughly 10% extra cost

320
00:17:21,583 --> 00:17:22,683
in main gbuffer shading.

321
00:17:24,323 --> 00:17:26,904
Sample grad issue is more expensive than normal fetch,

322
00:17:27,404 --> 00:17:29,404
though there is no change in bandwidth or latency,

323
00:17:29,964 --> 00:17:32,105
and the fetch and filter costs are unaffected.

324
00:17:33,365 --> 00:17:35,085
Other than ALU cost, there is also

325
00:17:35,105 --> 00:17:37,545
increased register pressure, as the derivatives

326
00:17:37,565 --> 00:17:38,466
need to be kept around.

327
00:17:38,486 --> 00:17:41,226
You need to be careful that the gradient adjust doesn't

328
00:17:41,246 --> 00:17:43,847
hurt your occupancy, at least on the critical path.

329
00:17:48,104 --> 00:17:51,085
However, we only shade half the pixels, and not all

330
00:17:51,125 --> 00:17:52,685
instructions in the shader are a fetch.

331
00:17:53,345 --> 00:17:54,306
Overall, this is a win.

332
00:18:02,408 --> 00:18:05,508
The PS4 Pro added special hardware and compiler support

333
00:18:05,568 --> 00:18:08,849
to apply the affine transform directly in the texture unit

334
00:18:09,269 --> 00:18:10,389
with no register usage.

335
00:18:11,990 --> 00:18:15,271
On this platform, just turn the feature on at no ALU or

336
00:18:15,311 --> 00:18:16,271
VGPR cost.

337
00:18:21,534 --> 00:18:24,277
Here are two images, courtesy of Sucker Punch, which clearly

338
00:18:24,317 --> 00:18:25,820
show the value of gradient adjustment.

339
00:18:26,901 --> 00:18:29,525
In these images, you can see a curved surface going into the

340
00:18:29,565 --> 00:18:32,589
screen and a scrolling text advertisement, which is

341
00:18:32,629 --> 00:18:35,533
selecting a lower mip earlier than it should, resulting in

342
00:18:35,573 --> 00:18:36,514
very blocky rendering.

343
00:18:43,879 --> 00:18:46,041
Most cases of gradient adjust can be solved with an

344
00:18:46,181 --> 00:18:49,324
automatic adjust performed in the texture unit, but cases

345
00:18:49,364 --> 00:18:51,725
like custom filtering or virtual texturing need to be

346
00:18:51,786 --> 00:18:52,686
manually corrected.

347
00:18:57,550 --> 00:18:59,512
In this magnified test scene showing some horrible

348
00:18:59,552 --> 00:19:01,734
programmer art, thank you very much, you can see two

349
00:19:01,794 --> 00:19:04,656
alternating frames with regions of blurriness due to

350
00:19:04,676 --> 00:19:06,738
lack of gradient adjust in the virtual texture sampling.

351
00:19:08,375 --> 00:19:10,437
It is exacerbated by an isotropic filtering

352
00:19:10,898 --> 00:19:12,740
because the skewed gradients will cause the filtering

353
00:19:12,760 --> 00:19:13,841
to behave more like a blur.

354
00:19:19,566 --> 00:19:20,727
And here is the same test scene

355
00:19:20,747 --> 00:19:22,769
with explicitly adjusted texture gradients

356
00:19:22,889 --> 00:19:24,111
in the virtual texture lookup.

357
00:19:25,372 --> 00:19:26,593
The flickering stabilizes

358
00:19:26,853 --> 00:19:28,655
and the correct MIP levels are being chosen now.

359
00:19:34,335 --> 00:19:38,620
In addition to gradient adjust, the barycentric evaluation also needs to be corrected to use

360
00:19:38,640 --> 00:19:44,387
sample positions instead of pixel positions. Without barycentrics evaluated at sample positions,

361
00:19:44,787 --> 00:19:50,794
texture fidelity and smoothness will be affected. In this example, notice the loss of detail

362
00:19:50,834 --> 00:19:54,598
on the vertical lines of the background and a more rough appearance of the vegetation.

363
00:20:08,817 --> 00:20:11,420
Speaking of vegetation, Battlefield 1 has a lot of it,

364
00:20:11,960 --> 00:20:14,203
and correctly resolving alpha-tested objects with

365
00:20:14,243 --> 00:20:16,004
checkerboard rendering is quite challenging.

366
00:20:22,050 --> 00:20:25,053
Alpha-test shaders compute the depth or coverage of a pixel

367
00:20:25,193 --> 00:20:27,836
inside the shader, instead of relying on the scan converter

368
00:20:27,876 --> 00:20:29,017
to determine these parameters.

369
00:20:30,394 --> 00:20:32,955
If these shaders are run at pixel rate, all samples in the

370
00:20:32,995 --> 00:20:35,496
pixel share the output of a single shader invocation,

371
00:20:36,016 --> 00:20:37,617
resulting in IDs that are at shading

372
00:20:37,677 --> 00:20:38,757
rate instead of full rate.

373
00:20:40,678 --> 00:20:42,698
This presents quite a problem with checkerboard hole

374
00:20:42,738 --> 00:20:43,419
reconstruction.

375
00:20:48,740 --> 00:20:51,341
The solution is to run the pixel shader for each sample

376
00:20:51,381 --> 00:20:54,583
in the image, instead of just once per pixel, to be able to

377
00:20:54,623 --> 00:20:57,043
generate full resolution depth and ID values.

378
00:20:58,839 --> 00:21:01,800
The hardware will unroll each pixel quad, creating a shading

379
00:21:01,820 --> 00:21:02,721
quad per sample.

380
00:21:04,902 --> 00:21:07,423
Because unnecessary unrolling can have a severe performance

381
00:21:07,483 --> 00:21:10,805
impact due to a large increase in pixel shader work, it is

382
00:21:10,845 --> 00:21:12,345
important to switch off the unrolling whenever

383
00:21:12,365 --> 00:21:13,046
it is not needed.

384
00:21:18,288 --> 00:21:21,290
First, all alpha-tested geometry will run a minimal

385
00:21:21,330 --> 00:21:23,351
pass to compute the coverage and or depth.

386
00:21:24,511 --> 00:21:27,172
Since this pass is unrolled, the shader needs to be as fast

387
00:21:27,212 --> 00:21:27,753
as possible.

388
00:21:30,202 --> 00:21:33,747
Next, all alpha-tested geometry runs the expensive shading

389
00:21:33,787 --> 00:21:36,530
pass, which computes the actual color values.

390
00:21:38,653 --> 00:21:41,176
This pass is performed at pixel rate and with depth

391
00:21:41,276 --> 00:21:41,957
equals testing.

392
00:21:43,939 --> 00:21:46,382
With the previous coverage pass, the expensive shading

393
00:21:46,462 --> 00:21:49,086
operations benefit from maximal hidden surface removal.

394
00:21:54,620 --> 00:21:56,761
In order for the depth equals test to work correctly,

395
00:21:57,261 --> 00:21:59,002
the positions written by the coverage pass

396
00:21:59,142 --> 00:22:01,323
and the shading pass need to exactly match,

397
00:22:01,843 --> 00:22:03,444
so make sure that your positions are invariant.

398
00:22:05,464 --> 00:22:07,585
Otherwise, there can be subtle differences

399
00:22:07,685 --> 00:22:09,206
in the computed vertex positions,

400
00:22:09,746 --> 00:22:10,746
which can lead to z-fighting

401
00:22:10,826 --> 00:22:12,367
in the shading pass causing holes.

402
00:22:14,928 --> 00:22:16,768
One approach is to disable fast math

403
00:22:16,868 --> 00:22:18,369
for everything that goes into the position.

404
00:22:19,249 --> 00:22:20,730
We did this on all our vertex shaders

405
00:22:20,770 --> 00:22:22,190
with no measurable performance cost.

406
00:22:27,639 --> 00:22:30,101
Here's another test scene with awesome programmer art, shaded

407
00:22:30,121 --> 00:22:32,764
at low resolution to make the artifacts on the alpha-tested

408
00:22:32,804 --> 00:22:34,045
vegetation more apparent.

409
00:22:38,330 --> 00:22:41,474
Here is the same scene using alpha unroll, avoiding all of

410
00:22:41,514 --> 00:22:42,435
the nasty artifacts.

411
00:22:43,496 --> 00:22:44,577
Let's go back and forth again.

412
00:22:51,182 --> 00:22:54,346
Visualizing the object and primitive IDs without the unroll

413
00:22:54,526 --> 00:22:56,969
shows the lack of high-resolution geometry information

414
00:22:57,069 --> 00:22:57,910
for the vegetation.

415
00:23:01,494 --> 00:23:03,697
This is what the object and primitive IDs look like

416
00:23:03,737 --> 00:23:05,098
with the alpha unrolling enabled.

417
00:23:05,759 --> 00:23:06,700
I'll go back and forth again.

418
00:23:15,907 --> 00:23:18,569
Now, I will cover various optimizations that were done to

419
00:23:18,609 --> 00:23:21,010
our checkerboard solution in order to make it affordable,

420
00:23:21,210 --> 00:23:22,871
especially for our 60 hertz titles.

421
00:23:28,294 --> 00:23:31,316
The first optimization to cover is pixel shader invocation

422
00:23:31,356 --> 00:23:33,697
control, otherwise known as PS invoke.

423
00:23:35,638 --> 00:23:38,480
Every sample position, if covered by a triangle, can

424
00:23:38,500 --> 00:23:39,741
trigger pixel shading work.

425
00:23:41,041 --> 00:23:44,183
Checkerboard uses 1x color and 2x depth and IDs.

426
00:23:45,243 --> 00:23:47,405
Due to the way that EQAA works in this case,

427
00:23:47,645 --> 00:23:49,946
half of the shading does not contribute to the final image.

428
00:23:52,327 --> 00:23:54,948
We can prevent overshading by configuring certain samples

429
00:23:54,988 --> 00:23:57,790
to be non-shading, which brings the amount of pixel shading

430
00:23:57,810 --> 00:24:00,251
work back to what it would be with 1x depth and IDs.

431
00:24:01,191 --> 00:24:03,552
On PS4, there's a very simple API to turn this on,

432
00:24:03,613 --> 00:24:06,034
but it's definitely not simple under the hood.

433
00:24:06,494 --> 00:24:10,396
And I don't want your brains to explode, so that's this slide.

434
00:24:14,680 --> 00:24:18,243
Another optimization was the usage of FP16 GCN instructions

435
00:24:18,324 --> 00:24:19,725
in our checkerboard resolve shader.

436
00:24:20,706 --> 00:24:23,989
PS4 Pro has support for FP16, and we used it throughout the

437
00:24:24,010 --> 00:24:25,151
checkerboard resolve shader.

438
00:24:26,592 --> 00:24:29,635
The largest benefit was the ability to greatly lower our

439
00:24:29,796 --> 00:24:30,877
LDS memory usage.

440
00:24:32,418 --> 00:24:34,520
This resulted in about a 30% improvement in

441
00:24:34,541 --> 00:24:35,321
the resolve shader.

442
00:24:41,430 --> 00:24:43,830
Another important optimization was the implementation

443
00:24:43,870 --> 00:24:45,151
of an efficient depth resolve.

444
00:24:46,391 --> 00:24:48,492
After the ID, depth, and stencil values

445
00:24:48,572 --> 00:24:50,472
are written in the frame, it was important

446
00:24:50,512 --> 00:24:52,933
that passes not requiring higher resolution depth

447
00:24:53,053 --> 00:24:56,554
and ID information be allowed to read from single sample depth

448
00:24:57,314 --> 00:24:59,434
in order to halve the depth block bandwidth.

449
00:25:01,695 --> 00:25:03,916
Transparent objects, as well as post-processing,

450
00:25:04,156 --> 00:25:06,696
read from a single sample resolved depth and stencil

451
00:25:06,736 --> 00:25:09,677
target, as they do not write depth or reasonable IDs.

452
00:25:11,218 --> 00:25:13,801
Higher resolution depth is resolved to single sample

453
00:25:13,941 --> 00:25:15,442
after our main gbuffer lay down,

454
00:25:16,503 --> 00:25:18,304
which is used for the remaining passes in the frame

455
00:25:18,365 --> 00:25:19,886
until the checkerboard resolve occurs.

456
00:25:24,230 --> 00:25:26,592
The simple approach is to copy depth of the compute shader,

457
00:25:27,032 --> 00:25:29,194
but this is slow as it requires full decompression

458
00:25:29,214 --> 00:25:30,775
of depth to be readable in the shader.

459
00:25:32,377 --> 00:25:34,458
During optimization, I developed a technique

460
00:25:34,498 --> 00:25:36,020
that can resolve depth and stencil

461
00:25:36,080 --> 00:25:38,642
to a single sample target without requiring decompression.

462
00:25:39,707 --> 00:25:42,307
This is done with a nifty hidden feature of the AMD GCN

463
00:25:42,347 --> 00:25:43,607
color block, or CB.

464
00:25:45,388 --> 00:25:47,868
The publicly available AMD Evergreen acceleration

465
00:25:47,888 --> 00:25:50,969
document describes a mode where the CB can copy depth

466
00:25:51,029 --> 00:25:51,849
to a color target.

467
00:25:52,869 --> 00:25:55,449
Since the CB can read compressed data natively, a

468
00:25:55,470 --> 00:25:56,710
decompression is not needed.

469
00:25:58,390 --> 00:26:00,871
This all sounds great, but we want a usable depth target in

470
00:26:00,891 --> 00:26:02,471
the end, not a color target.

471
00:26:03,351 --> 00:26:05,671
Here's yet another instance where low-level graphics APIs

472
00:26:05,691 --> 00:26:06,292
can really shine.

473
00:26:10,338 --> 00:26:13,520
First off, because we want 32-bit depth in many cases,

474
00:26:13,720 --> 00:26:15,681
a dummy shader is used that writes out zero,

475
00:26:16,001 --> 00:26:18,222
and the compiler is forced to output 32-bit.

476
00:26:19,423 --> 00:26:21,704
This is important in order to avoid truncation of depth

477
00:26:21,744 --> 00:26:23,565
values when the CB does the blit.

478
00:26:26,167 --> 00:26:27,588
As mentioned, this harder feature

479
00:26:27,668 --> 00:26:29,729
is designed to efficiently resolve depth to a color

480
00:26:29,769 --> 00:26:31,730
target, but we want a depth target in the end.

481
00:26:32,630 --> 00:26:33,631
Through a lot of trial and error,

482
00:26:33,751 --> 00:26:35,512
I found a single tiling mode that matched up

483
00:26:35,552 --> 00:26:37,033
between color and depth layouts.

484
00:26:37,854 --> 00:26:41,077
2D non-displayable thin and 1XAA depth micro-tiling

485
00:26:41,117 --> 00:26:42,057
are essentially the same.

486
00:26:43,479 --> 00:26:45,680
By aliasing the depth target as a color target,

487
00:26:46,061 --> 00:26:48,062
this technique can resolve multi-sample depth

488
00:26:48,182 --> 00:26:49,283
to single-sample color,

489
00:26:49,744 --> 00:26:51,765
which is secretly a single-sample depth target.

490
00:26:54,207 --> 00:26:56,109
Just the setup alone is not enough, though,

491
00:26:56,669 --> 00:26:59,031
as we currently would be invoking pixel shader threads

492
00:26:59,071 --> 00:27:00,853
that would just output zero to the destination.

493
00:27:02,043 --> 00:27:04,825
Depth and stencil need to be disabled, copy centroid set to

494
00:27:05,065 --> 00:27:08,427
on, and copy sample index can be used to specify which depth

495
00:27:08,447 --> 00:27:10,188
fragment we want to write to the destination.

496
00:27:11,709 --> 00:27:13,450
Zero seems like a sensible index to use in

497
00:27:13,470 --> 00:27:14,250
all cases for us.

498
00:27:18,773 --> 00:27:21,575
The main secret here is that the dbRenderControl register

499
00:27:21,615 --> 00:27:24,857
has a depth copy bit, which will read depth and write it

500
00:27:24,877 --> 00:27:26,398
to the red channel in the destination.

501
00:27:28,159 --> 00:27:30,740
It is important to mention that hTile will remain untouched

502
00:27:30,880 --> 00:27:31,761
and not copied either.

503
00:27:36,339 --> 00:27:38,721
Stencil is done in a similar manner, except using the

504
00:27:38,761 --> 00:27:41,324
stencil copy bit of the dbRenderControl register.

505
00:27:42,445 --> 00:27:44,647
Stencil copy will write through to the green channel,

506
00:27:44,867 --> 00:27:46,849
which makes sense for what this hardware was designed for,

507
00:27:47,590 --> 00:27:49,852
but does not work correctly when aliasing the color target

508
00:27:49,912 --> 00:27:52,335
as a stencil target, as only one channel is present.

509
00:27:53,556 --> 00:27:56,559
To solve this, the cbColorInfo register is programmed to

510
00:27:56,579 --> 00:27:59,401
perform a component swap, which effectively swizzles the

511
00:27:59,441 --> 00:28:00,743
green to red channel on write.

512
00:28:05,392 --> 00:28:07,433
Here is the dummy shader used for the depth and stencil

513
00:28:07,453 --> 00:28:09,315
resolve, which as you can see is quite dummy.

514
00:28:10,216 --> 00:28:12,678
The biggest thing is just outputting zero and forcing

515
00:28:12,698 --> 00:28:13,819
the compiler to 32-bit.

516
00:28:14,119 --> 00:28:15,040
It's just a placeholder.

517
00:28:19,444 --> 00:28:21,866
This is what occurs if you only resolve depth and stencil,

518
00:28:22,067 --> 00:28:25,490
but do not copy and fix up the htile metadata or hi-z.

519
00:28:29,573 --> 00:28:31,055
Zooming in on that area in the top left.

520
00:28:33,458 --> 00:28:36,419
You can see the invalid blocks of pixels due to broken hTile.

521
00:28:42,381 --> 00:28:44,722
Just copying the depth will only work if the destination

522
00:28:44,762 --> 00:28:46,463
depth target does not use hTile.

523
00:28:47,263 --> 00:28:50,325
However, hTile is critical for performance, especially at

524
00:28:50,345 --> 00:28:51,785
high resolutions like 4K.

525
00:28:52,525 --> 00:28:54,906
And so we also need to explicitly copy hTile to the

526
00:28:54,946 --> 00:28:56,847
destination and patch up relevant bits.

527
00:28:58,210 --> 00:29:00,633
The copy was accomplished with a very fast compute shader,

528
00:29:01,033 --> 00:29:03,435
which will keep the hTile acceleration working correctly

529
00:29:03,675 --> 00:29:06,858
on the 1xAA depth destination, and any further writes will

530
00:29:06,878 --> 00:29:07,839
compress as expected.

531
00:29:13,344 --> 00:29:16,406
Here is the hTile copy shader, which will load four 32-bit

532
00:29:16,747 --> 00:29:19,889
hTile values per thread, copy them to the destination, mark

533
00:29:19,910 --> 00:29:20,910
the tiles as expanded.

534
00:29:22,051 --> 00:29:24,454
This shader copies four values at a time instead of one to

535
00:29:24,494 --> 00:29:25,655
avoid being SPI bound.

536
00:29:28,127 --> 00:29:30,587
This pass will produce a destination H tile that has

537
00:29:30,627 --> 00:29:33,628
correct Z ranges, and all tiles marked as expanded,

538
00:29:34,248 --> 00:29:35,788
since that is how the CB has copied the

539
00:29:35,808 --> 00:29:36,729
depth values across.

540
00:29:42,070 --> 00:29:44,650
This optimization saved us over one millisecond, and

541
00:29:44,690 --> 00:29:47,151
leaves both the source and depth stencil fully compressed.

542
00:29:48,111 --> 00:29:50,632
Other than preserving compression, this technique is

543
00:29:50,692 --> 00:29:52,392
great, because it's completely bandwidth bound.

544
00:29:58,329 --> 00:30:00,150
Now I will cover the integration of checkerboard

545
00:30:00,190 --> 00:30:01,211
with our post-processing.

546
00:30:10,740 --> 00:30:12,982
After laydown of our checkerboard at gbuffer, it is

547
00:30:13,002 --> 00:30:15,484
important to invoke as many post-processing steps before

548
00:30:15,524 --> 00:30:17,106
the checkerboard resolve is possible.

549
00:30:18,647 --> 00:30:20,509
The reason is strictly due to the performance cost.

550
00:30:22,143 --> 00:30:24,085
While certain passes can produce better results

551
00:30:24,145 --> 00:30:25,707
when computed at higher resolution,

552
00:30:26,207 --> 00:30:28,049
the majority of passes do not benefit enough

553
00:30:28,069 --> 00:30:29,209
from the quality increase

554
00:30:29,290 --> 00:30:31,231
compared to the extremely high performance cost.

555
00:30:32,853 --> 00:30:34,694
It was very time-consuming and painful work

556
00:30:34,714 --> 00:30:36,276
due to the initial refactoring of lighting

557
00:30:36,716 --> 00:30:38,157
and post-process for the checkerboard,

558
00:30:38,898 --> 00:30:40,639
and evolution of the code base over time

559
00:30:40,679 --> 00:30:41,920
breaks various parts often.

560
00:30:43,802 --> 00:30:45,383
Checkerboard is a new concept to many,

561
00:30:46,084 --> 00:30:47,885
so it's important to auto-test

562
00:30:47,905 --> 00:30:49,467
the checkerboard pipeline if possible.

563
00:30:50,345 --> 00:30:52,746
In Frostbite, we have a full auto testing setup

564
00:30:52,786 --> 00:30:54,006
where we were able to just add this

565
00:30:54,046 --> 00:30:56,427
into our existing test suite and test for it now,

566
00:30:56,467 --> 00:30:56,968
which is great.

567
00:31:00,449 --> 00:31:02,970
There are some passes that ignore geometric information,

568
00:31:03,210 --> 00:31:05,331
like SSAO or luminance estimation,

569
00:31:05,751 --> 00:31:07,812
which provide very little visual benefit

570
00:31:07,832 --> 00:31:09,073
to be run after they're resolved.

571
00:31:11,134 --> 00:31:13,615
Some passes that can benefit from geometric information

572
00:31:14,015 --> 00:31:16,376
in order to limit color propagation over an edge

573
00:31:16,436 --> 00:31:17,857
can still run at a very low resolution.

574
00:31:20,062 --> 00:31:21,983
Although the render targets are not structurally different

575
00:31:22,023 --> 00:31:25,124
from non-EQA surfaces, their pixels do not correspond

576
00:31:25,164 --> 00:31:26,025
to a regular grid.

577
00:31:26,965 --> 00:31:29,046
This makes linear sampling of the checkerboard surface

578
00:31:29,086 --> 00:31:29,666
problematic.

579
00:31:30,387 --> 00:31:32,568
It also means that the aspect ratio of the buffer is

580
00:31:32,608 --> 00:31:34,509
different from a normal 16 by 9 render.

581
00:31:36,770 --> 00:31:39,831
As an example, if a blur pass is applied to a checkerboard

582
00:31:39,871 --> 00:31:42,753
surface, the correct thing to do is treat each pixel

583
00:31:42,773 --> 00:31:44,814
according to its exact position on the checkerboard.

584
00:31:45,779 --> 00:31:48,242
In the majority of cases, it is possible to get away with

585
00:31:48,282 --> 00:31:51,185
treating the buffer as a 1920 by 2160 buffer.

586
00:31:52,046 --> 00:31:54,809
However, to maintain the shape of the blur, the horizontal

587
00:31:54,849 --> 00:31:55,690
filter should be halved.

588
00:31:59,994 --> 00:32:02,557
Here's a test scene that shows the tiled lighting before

589
00:32:02,597 --> 00:32:03,478
checkerboard correction.

590
00:32:04,239 --> 00:32:06,101
Notice the blockiness of the lighting results in the

591
00:32:06,141 --> 00:32:06,801
zoomed-in region.

592
00:32:12,675 --> 00:32:15,298
And here is the same test scene in region after accounting for

593
00:32:15,318 --> 00:32:16,519
the checkerboard pixel grid.

594
00:32:17,881 --> 00:32:18,962
Let's go back and forth again.

595
00:32:18,982 --> 00:32:20,504
Hopefully the projector shows it.

596
00:32:27,271 --> 00:32:29,955
This was trivially fixed by applying an offset to the UV

597
00:32:30,055 --> 00:32:32,077
used for reconstructing the clip space position.

598
00:32:39,759 --> 00:32:41,941
This convenience function will return a packed value

599
00:32:41,961 --> 00:32:43,382
for checkerboard UV adjustment.

600
00:32:44,123 --> 00:32:46,545
If checkerboard is disabled, this simply returns zero,

601
00:32:46,745 --> 00:32:48,306
which doesn't apply any sort of adjustment.

602
00:32:49,127 --> 00:32:51,949
Otherwise, the return value contains a frame parity bit

603
00:32:52,029 --> 00:32:55,012
in the LSB and half texel width

604
00:32:55,052 --> 00:32:56,153
when interpreted as a float.

605
00:32:57,754 --> 00:32:59,596
This packed representation allows us to have

606
00:32:59,616 --> 00:33:01,798
a single version of all of our post-processing shaders,

607
00:33:02,178 --> 00:33:04,120
regardless of whether or not checkerboard is active.

608
00:33:05,378 --> 00:33:07,379
And this packing function is what produced the

609
00:33:07,840 --> 00:33:10,381
CB state packed variable being passed in.

610
00:33:18,985 --> 00:33:21,786
This is an overview of a Battlefield 1 frame on PS4 Pro

611
00:33:22,046 --> 00:33:24,487
and the associated resolution changes.

612
00:33:25,848 --> 00:33:27,629
The clear up to the velocity vectors

613
00:33:27,749 --> 00:33:28,589
are done at 1800p checkerboard.

614
00:33:30,188 --> 00:33:32,648
Then the checkerboard resolve, coupled with temporal

615
00:33:32,688 --> 00:33:36,889
anti-aliasing, outputs a native 1800p frame, which is

616
00:33:36,929 --> 00:33:39,630
the resolution used by the remaining passes that do not

617
00:33:39,670 --> 00:33:41,210
currently benefit from the checkerboard.

618
00:33:43,211 --> 00:33:45,771
Finally, the display mapping and resample is performed,

619
00:33:46,292 --> 00:33:49,252
which prepares the frame for scan out at native 4K.

620
00:33:55,614 --> 00:33:57,874
And here is an overview of a Mass Effect Andromeda frame

621
00:33:58,214 --> 00:33:58,694
on PS4 Pro.

622
00:34:00,070 --> 00:34:01,992
The render passes are very similar to Battlefield 1,

623
00:34:02,773 --> 00:34:05,235
except Mass Effect also runs a sprite depth of field pass

624
00:34:05,355 --> 00:34:07,577
after the checkerboard resolve and temporal AA.

625
00:34:12,841 --> 00:34:14,943
The quality of the final image is greatly dependent

626
00:34:15,003 --> 00:34:16,504
on how the color buffers are combined

627
00:34:16,584 --> 00:34:18,646
with the higher resolution geometry information,

628
00:34:19,246 --> 00:34:21,828
making the shaders that move the frame to 4K resolution

629
00:34:21,848 --> 00:34:23,510
a very important part of these techniques.

630
00:34:25,191 --> 00:34:27,493
The checkerboard resolve is broken into two main parts,

631
00:34:27,713 --> 00:34:29,675
the spatial component and the temporal component.

632
00:34:33,500 --> 00:34:36,081
The spatial component exploits the relatively dense sample

633
00:34:36,121 --> 00:34:36,841
rate in two ways.

634
00:34:38,302 --> 00:34:42,064
First, only the unshaded samples are resolved, and the

635
00:34:42,104 --> 00:34:43,645
shaded samples are simply passed through.

636
00:34:45,005 --> 00:34:47,927
Second, the resolve only looks at the four direct neighbors

637
00:34:47,967 --> 00:34:49,748
of the unshaded sample, instead of

638
00:34:49,788 --> 00:34:50,888
performing a wider search.

639
00:34:55,391 --> 00:34:57,492
The checkerboard resolve typically does not use depth

640
00:34:57,572 --> 00:34:58,532
for performance reasons.

641
00:34:59,906 --> 00:35:02,367
Therefore, the color information must be used to

642
00:35:02,407 --> 00:35:03,727
determine if an edge is soft.

643
00:35:05,548 --> 00:35:07,709
This should only be done for colors produced from the same

644
00:35:07,769 --> 00:35:09,909
primitive, as there are no cases where we want

645
00:35:09,969 --> 00:35:12,030
contribution to a pixel from different objects.

646
00:35:14,131 --> 00:35:15,991
In the case where none of the surrounding colors are from

647
00:35:16,031 --> 00:35:18,052
the same objects, an average of all four

648
00:35:18,112 --> 00:35:19,292
color samples is used.

649
00:35:23,354 --> 00:35:25,314
This slide shows a problem with false hard edges.

650
00:35:26,119 --> 00:35:30,342
The pixel labeled a C will be resolved using all four of its neighbors, resulting in an

651
00:35:30,462 --> 00:35:32,203
even blend between red and blue.

652
00:35:33,764 --> 00:35:39,068
Pixels labeled as A and B have an uneven number of red and blue neighbors, leading to different

653
00:35:39,088 --> 00:35:39,908
blending results.

654
00:35:41,509 --> 00:35:44,691
Applied over the whole quad, this would produce a visible diagonal edge.

655
00:35:46,903 --> 00:35:49,125
The color bounding box will add all color samples

656
00:35:49,145 --> 00:35:52,327
from a primitive to a bounding box in Y, C, O, C, G space,

657
00:35:53,028 --> 00:35:54,889
and color samples that are from the right object

658
00:35:54,929 --> 00:35:56,751
but a different primitive will be considered

659
00:35:56,771 --> 00:35:58,652
to be on the right primitive if they are contained

660
00:35:58,672 --> 00:35:59,593
in this bounding box.

661
00:36:01,975 --> 00:36:03,416
It is important to decide what to do

662
00:36:03,436 --> 00:36:05,598
when a single sample is contained in the bounding box.

663
00:36:09,581 --> 00:36:11,422
Here's a test case courtesy of Sucker Punch,

664
00:36:11,603 --> 00:36:12,603
which really shows the problem

665
00:36:12,623 --> 00:36:14,065
of single bounding box samples.

666
00:36:15,340 --> 00:36:17,822
Because it is unlikely that other samples pass the test,

667
00:36:18,222 --> 00:36:19,844
the single sample is copied directly

668
00:36:19,884 --> 00:36:22,906
into the destination pixel, causing an obvious artifact.

669
00:36:24,647 --> 00:36:26,128
The problem can be avoided by using

670
00:36:26,168 --> 00:36:28,110
a heuristic that compares the single color

671
00:36:28,150 --> 00:36:30,451
value to the blended color of all samples

672
00:36:30,571 --> 00:36:31,572
from the correct object.

673
00:36:32,933 --> 00:36:34,794
The heuristic is to help reduce artifacts

674
00:36:34,895 --> 00:36:36,896
in highly tessellated yet smooth areas,

675
00:36:37,116 --> 00:36:38,237
like in this character face.

676
00:36:41,019 --> 00:36:41,880
Let's go back and forth.

677
00:36:50,922 --> 00:36:53,164
Using a distance-weighted blend would perform a simple

678
00:36:53,264 --> 00:36:56,186
averaging, since all four samples are equal distant to

679
00:36:56,226 --> 00:36:56,986
the center sample.

680
00:36:58,467 --> 00:37:00,709
You can see artifacts on the left image where visual

681
00:37:00,769 --> 00:37:03,411
continuity is being interrupted by averaged pixels.

682
00:37:05,432 --> 00:37:07,794
The solution is to use a differential blending operator

683
00:37:08,154 --> 00:37:11,776
that compares two pairs of opposing color samples, and

684
00:37:11,836 --> 00:37:13,958
weighting each pair's contribution to the final

685
00:37:13,998 --> 00:37:17,060
value, higher if the samples in the pair are more similar

686
00:37:17,120 --> 00:37:18,601
than the colors of the opposing pair.

687
00:37:22,382 --> 00:37:24,263
The differential blend operator is much better

688
00:37:24,283 --> 00:37:26,565
than a simple averaging, but it still has limitations

689
00:37:27,686 --> 00:37:29,006
due to its small search radius.

690
00:37:30,207 --> 00:37:31,448
If both pairs are quite similar,

691
00:37:31,648 --> 00:37:32,809
there is not enough information

692
00:37:32,849 --> 00:37:34,210
to select the appropriate blend.

693
00:37:35,511 --> 00:37:37,513
This mainly occurs when a single pixel wide

694
00:37:37,533 --> 00:37:38,814
texture feature is encountered,

695
00:37:39,214 --> 00:37:40,875
like in this example where the light background

696
00:37:40,915 --> 00:37:43,077
is visible through single pixel wide openings

697
00:37:43,217 --> 00:37:44,318
in the foreground geometry.

698
00:37:45,539 --> 00:37:47,180
The solution is to use the ID buffer

699
00:37:47,220 --> 00:37:48,161
to influence the weighting.

700
00:37:51,143 --> 00:37:51,703
Back and forth.

701
00:38:01,130 --> 00:38:03,031
This is the differential weighting function, which

702
00:38:03,091 --> 00:38:04,493
includes ID evaluation.

703
00:38:05,553 --> 00:38:07,915
The exact formulation is dependent on what color space

704
00:38:07,935 --> 00:38:10,337
you operate in, such as log space luminance.

705
00:38:11,398 --> 00:38:13,860
As you can see, the operator is quite simple, but greatly

706
00:38:13,900 --> 00:38:15,001
improves the image quality.

707
00:38:19,825 --> 00:38:22,387
Here are some examples showing how object and our primitive

708
00:38:22,467 --> 00:38:24,669
ID can be used to help in separating out unique

709
00:38:24,709 --> 00:38:25,170
surfaces.

710
00:38:27,168 --> 00:38:29,829
It may seem like the inclusion of object and or primitive ID

711
00:38:29,949 --> 00:38:32,370
results in a more aliased image, but keep in mind

712
00:38:32,390 --> 00:38:34,031
that it is desirable to keep the hard edges

713
00:38:34,071 --> 00:38:36,532
between different objects, rather than just blurring

714
00:38:36,572 --> 00:38:38,473
everything together and reducing image quality.

715
00:38:43,855 --> 00:38:45,736
The temporal component uses reprojection

716
00:38:45,796 --> 00:38:47,716
to combine the results of the spatial resolve

717
00:38:48,076 --> 00:38:49,257
with a color history buffer.

718
00:38:50,297 --> 00:38:52,018
For the majority of details, you can refer

719
00:38:52,058 --> 00:38:53,679
to all the great presentations and research

720
00:38:53,719 --> 00:38:55,700
already out there, especially the work of Brian Karras.

721
00:38:57,057 --> 00:39:00,059
Our temporal AA is very similar to this, and general TA isn't

722
00:39:00,099 --> 00:39:02,240
the talk's focus, so I won't be going into much of the

723
00:39:02,280 --> 00:39:03,000
details for that.

724
00:39:03,861 --> 00:39:06,123
I will briefly touch on velocity-based reprojection,

725
00:39:06,163 --> 00:39:07,463
which was updated for checkerboard.

726
00:39:11,846 --> 00:39:15,268
A static scene over two frames is trivial to reconstruct, but

727
00:39:15,308 --> 00:39:17,550
an actual game is obviously much more dynamic.

728
00:39:18,771 --> 00:39:21,593
There are numerous objects on surfaces in motion, yet the

729
00:39:21,633 --> 00:39:22,753
pixel grid is stationary.

730
00:39:24,104 --> 00:39:29,126
Because of this, we need to correlate 3D surfaces in motion, such that a valid reconstruction

731
00:39:29,226 --> 00:39:31,467
of unshaded checkerboard pixels can be performed.

732
00:39:32,507 --> 00:39:36,909
The correlation is achieved by having surfaces write per-pixel velocity vectors, which can

733
00:39:36,949 --> 00:39:38,269
be used by the reconstruction.

734
00:39:40,970 --> 00:39:44,691
Anti-aliased edges potentially span depth and velocity discontinuities.

735
00:39:45,589 --> 00:39:48,390
In order to make sure that we don't lose anti-aliasing when

736
00:39:48,430 --> 00:39:51,450
reprojecting, we need to reproject anti-alias lines as

737
00:39:51,511 --> 00:39:51,831
a whole.

738
00:39:52,591 --> 00:39:55,091
In order to do that, we must dilate velocities around them.

739
00:39:56,552 --> 00:39:58,992
In practice, using the frontmost velocity works well

740
00:39:59,032 --> 00:40:01,093
in most cases, so that's the technique we

741
00:40:01,133 --> 00:40:01,873
would like to use.

742
00:40:02,733 --> 00:40:05,774
Unfortunately, to find the frontmost velocity, we also

743
00:40:05,794 --> 00:40:08,215
need to fetch the depth buffer, and doing so is quite

744
00:40:08,255 --> 00:40:08,735
expensive.

745
00:40:13,143 --> 00:40:15,683
This is an overview of our optimized velocity dilation,

746
00:40:16,624 --> 00:40:19,104
which determines the pixels that need velocity dilation,

747
00:40:19,604 --> 00:40:21,625
loading depth to compute the frontmost velocity,

748
00:40:22,285 --> 00:40:24,886
and the pixels that can use a basic averaging, which

749
00:40:24,946 --> 00:40:26,266
bypasses the loading of depth.

750
00:40:28,086 --> 00:40:30,127
The pass-through pixel uses a cross-shaped kernel,

751
00:40:30,467 --> 00:40:32,487
while the filtered pixel uses a plus-shaped kernel.

752
00:40:36,088 --> 00:40:37,829
In this debug overlay, the red pixels

753
00:40:37,869 --> 00:40:40,409
are moving edges, which require velocity dilation,

754
00:40:40,869 --> 00:40:42,310
while the unmarked pixels do not.

755
00:40:48,729 --> 00:40:50,711
Here's an overview of the checkerboard resolve shader,

756
00:40:50,911 --> 00:40:52,632
which processes two pixels per thread,

757
00:40:53,053 --> 00:40:54,854
the pass-through, or shaded pixels,

758
00:40:55,134 --> 00:40:56,976
and the filtered, or unshaded pixels.

759
00:40:58,297 --> 00:40:59,898
You'll note that the spatial resolve occurs

760
00:40:59,938 --> 00:41:01,820
within the same shader as the temporal AA,

761
00:41:02,180 --> 00:41:03,761
so that the spatially resolved color

762
00:41:03,841 --> 00:41:05,002
is never written back to memory.

763
00:41:07,304 --> 00:41:09,486
After resolving the spatial and temporal components,

764
00:41:09,866 --> 00:41:11,527
the results undergo a sharpen filter,

765
00:41:11,728 --> 00:41:13,369
and then the final frame is written out to memory.

766
00:41:18,986 --> 00:41:21,707
Despite being quite advanced, the 4K checkerboard resolve

767
00:41:21,847 --> 00:41:24,748
plus temporal AA is essentially a smart blur filter.

768
00:41:26,328 --> 00:41:29,169
As a result, the absence of high frequency components

769
00:41:29,229 --> 00:41:31,369
in an image makes it harder for observers

770
00:41:31,389 --> 00:41:32,250
to discern objects.

771
00:41:33,750 --> 00:41:36,391
Ganglion cells, which link the retina to the optic nerve,

772
00:41:36,571 --> 00:41:39,052
respond acutely to high frequency image components.

773
00:41:39,872 --> 00:41:42,112
With a blurred image, the brain's visual cortex

774
00:41:42,152 --> 00:41:44,453
will lack the necessary information to discern objects

775
00:41:44,473 --> 00:41:45,293
within a blurry frame.

776
00:41:50,518 --> 00:41:52,919
Applying a sharpened filter to the blurred image will help

777
00:41:52,959 --> 00:41:56,281
recover the high frequency components, which will result

778
00:41:56,321 --> 00:41:57,641
in enhanced visual quality.

779
00:41:58,902 --> 00:42:01,923
Be careful to not reintroduce aliasing or false high

780
00:42:01,943 --> 00:42:05,365
frequency and to not introduce ringing or oversharpening.

781
00:42:10,728 --> 00:42:11,988
Here's a screenshot without the

782
00:42:12,028 --> 00:42:13,169
sharpening filter applied.

783
00:42:15,890 --> 00:42:18,371
Here's the same scene with the sharpening filter applied.

784
00:42:20,023 --> 00:42:21,565
before, after.

785
00:42:21,585 --> 00:42:26,811
Another example before and after.

786
00:42:31,717 --> 00:42:34,640
Close up before the filter and after.

787
00:42:34,660 --> 00:42:40,527
I feel like I just gave all of you an eye exam.

788
00:42:46,843 --> 00:42:48,504
Once checkerboard was submitted to mainline,

789
00:42:48,764 --> 00:42:51,325
I started to receive absolutely every artifact-related bug

790
00:42:51,365 --> 00:42:52,866
report, like for the entire game,

791
00:42:53,726 --> 00:42:56,127
claiming that the cause must be the checkerboard,

792
00:42:57,288 --> 00:42:59,629
including bugs that existed well before the checkerboard was

793
00:42:59,669 --> 00:43:01,430
submitted, which is fun.

794
00:43:03,250 --> 00:43:05,091
Adding lots of debug overlays was a great way

795
00:43:05,111 --> 00:43:06,852
to help with debugging and isolate

796
00:43:06,872 --> 00:43:08,973
the root cause in whatever rendering component was to blame.

797
00:43:09,253 --> 00:43:10,073
It was never checkerboard.

798
00:43:12,682 --> 00:43:15,164
Also, take advantage of your technical artists and fellow

799
00:43:15,184 --> 00:43:15,924
rendering engineers.

800
00:43:16,585 --> 00:43:18,586
Teach them how to tell the difference between an actual

801
00:43:18,606 --> 00:43:27,212
checkerboard bug and an unrelated

802
00:43:27,252 --> 00:43:28,293
system like motion blur.

803
00:43:29,554 --> 00:43:30,935
You might think those are the exact same bug.

804
00:43:31,015 --> 00:43:31,395
They're not.

805
00:43:35,037 --> 00:43:38,160
So get ready for an old-fashioned witch hunt.

806
00:43:44,350 --> 00:43:48,731
Now I want to briefly touch on a couple infrastructure pieces that were indirectly related to the

807
00:43:48,771 --> 00:43:49,591
checkerboard rendering.

808
00:43:54,232 --> 00:43:57,953
Perhaps the biggest pain point of the move to 4K rendering was the massive increase of

809
00:43:58,013 --> 00:44:00,194
memory usage by the majority of our render targets.

810
00:44:01,614 --> 00:44:05,075
At the time, we didn't have a fancy system moving and repurposing memory throughout the

811
00:44:05,115 --> 00:44:09,656
frame, so we had to do some pretty creative refactors to do manual aliasing in very complex

812
00:44:11,499 --> 00:44:13,380
This extra effort pulled us away from doing further

813
00:44:13,600 --> 00:44:15,482
4K specific improvements that we wanted to do.

814
00:44:17,203 --> 00:44:19,044
Going forward, we now have very flexible

815
00:44:19,064 --> 00:44:20,425
and efficient approach for managing

816
00:44:20,485 --> 00:44:22,126
render target memory and aliasing.

817
00:44:22,746 --> 00:44:24,587
If you're interested, please go back and watch

818
00:44:24,647 --> 00:44:26,688
Yuri's talk titled Frame Graph Extensible

819
00:44:26,729 --> 00:44:28,129
Rendering Architecture in Frostbite.

820
00:44:28,249 --> 00:44:28,730
It's really good.

821
00:44:33,613 --> 00:44:35,414
Render target aliasing is also super defunded

822
00:44:35,434 --> 00:44:37,455
a bug at times, especially when the corruption

823
00:44:37,495 --> 00:44:39,036
manifests in the object ID buffer

824
00:44:39,076 --> 00:44:40,597
that helps drive our checkerboard resolve.

825
00:44:42,012 --> 00:44:43,554
The corruption wasn't obvious at the time,

826
00:44:43,915 --> 00:44:45,737
as the checkerboard resolve errors were noticeable,

827
00:44:45,797 --> 00:44:46,698
but still quite subtle.

828
00:44:48,280 --> 00:44:50,222
Closer inspection of the memory at this point in time,

829
00:44:51,223 --> 00:44:52,304
at this point in the frame, sorry,

830
00:44:52,405 --> 00:44:53,446
identified the culprit here.

831
00:44:55,208 --> 00:44:57,491
This was especially difficult to debug and track down

832
00:44:57,991 --> 00:45:00,234
because our memory layouts were also constantly changing

833
00:45:00,294 --> 00:45:02,396
frame to frame due to dynamic resolution scaling.

834
00:45:06,292 --> 00:45:10,175
Developed by Dice and Microsoft, another great feature is our dynamic resolution scaling

835
00:45:10,235 --> 00:45:13,557
system, which also plays nicely with our 4K checkerboard implementation.

836
00:45:15,339 --> 00:45:19,541
Checkerboard is always active, but the dynamic resolution scaling will determine what initial

837
00:45:19,561 --> 00:45:23,344
checkerboard frame resolution should be based on a running performance heuristic.

838
00:45:27,287 --> 00:45:30,749
Battlefield 1 contains a number of infrequently running GPU tasks.

839
00:45:31,662 --> 00:45:34,003
These caused the resolution to adjust in small increments

840
00:45:34,143 --> 00:45:36,525
almost every frame, which turned out to be not an issue.

841
00:45:37,165 --> 00:45:38,246
It actually worked with the jitter

842
00:45:38,266 --> 00:45:40,688
to provide different variation in subpixel detail.

843
00:45:42,769 --> 00:45:44,230
We tried preventing any upscaling

844
00:45:44,270 --> 00:45:45,891
if the camera wasn't moving, but this

845
00:45:45,931 --> 00:45:48,633
resulted in a noticeable lower quality image.

846
00:45:49,233 --> 00:45:51,335
And also, nobody complained about it.

847
00:45:56,758 --> 00:45:59,060
Lastly, I will cover performance and future work.

848
00:46:03,650 --> 00:46:10,974
Going back to this battlefield scene, let's look at the performance numbers for it. A

849
00:46:11,034 --> 00:46:15,336
couple things to note here. The ID clear is quite high, as there wasn't enough time to

850
00:46:15,356 --> 00:46:19,758
implement something better, such as using CMask acceleration to mark cleared tiles instead

851
00:46:19,798 --> 00:46:25,281
of clearing the backing memory. And we had to do this because of our Sky not actually

852
00:46:25,301 --> 00:46:29,443
writing down IDs. This should bring the time down quite a lot.

853
00:46:30,454 --> 00:46:33,996
The other note is around the three instances of depth, stencil, and htile copying.

854
00:46:34,816 --> 00:46:38,178
The reason is complicated and specific to how Battlefield and Mass Effect are currently

855
00:46:38,238 --> 00:46:38,938
rendering a frame.

856
00:46:39,999 --> 00:46:43,821
Other Frostbite titles going forward will only require one depth, stencil, and htile

857
00:46:43,841 --> 00:46:47,043
copy on average, making the total cost a third of what you see here.

858
00:46:49,165 --> 00:46:52,729
Comparing 1800p checkerboard versus 1800p native, the

859
00:46:52,749 --> 00:46:55,793
checkerboard implementation saves 5.08 milliseconds in

860
00:46:55,813 --> 00:46:58,856
the scene, making the total frame cost suitable for the

861
00:46:59,357 --> 00:47:00,358
60 hertz performance target.

862
00:47:04,562 --> 00:47:06,745
Here are some interesting GPU timers for this scene,

863
00:47:06,925 --> 00:47:08,627
comparing 1800p native versus 1800p checkerboard.

864
00:47:11,049 --> 00:47:13,210
In a lot of cases, you can see that the timing is pretty much

865
00:47:13,250 --> 00:47:15,291
half of what it was before checkerboard.

866
00:47:15,731 --> 00:47:18,292
The cases where it's not that, like the Gbuffer, is because

867
00:47:18,332 --> 00:47:21,113
it's bound by other things in the pipeline, like bandwidth,

868
00:47:21,133 --> 00:47:21,654
for example.

869
00:47:27,316 --> 00:47:29,217
And here's a scene from Mass Effect Andromeda using

870
00:47:29,257 --> 00:47:32,418
checkerboard, which shows the timings between 1800p native

871
00:47:32,558 --> 00:47:33,879
and 1800p checkerboard.

872
00:47:35,399 --> 00:47:38,080
This is a 30 hertz title, so the checkerboard cost is well

873
00:47:38,100 --> 00:47:39,121
within the allotted budget.

874
00:47:44,060 --> 00:47:48,263
The checkerboard-specific timers are similar to the Battlefield 1 capture, except the Resolve

875
00:47:48,323 --> 00:47:52,527
is much more expensive due to higher quality settings since Mass Effect is a 30-hertz title

876
00:47:52,547 --> 00:47:53,187
and can afford it.

877
00:47:59,292 --> 00:48:02,294
Here are some interesting GPU timers for this scene comparing 1800p native versus 1800p

878
00:48:02,314 --> 00:48:02,855
checkerboard.

879
00:48:13,537 --> 00:48:14,598
We have planned further improvements

880
00:48:14,618 --> 00:48:15,658
to the checkerboard resolve,

881
00:48:16,278 --> 00:48:18,439
as well as optimizations to alpha-tested objects

882
00:48:18,499 --> 00:48:20,299
so that the sample rate coverage is not needed.

883
00:48:20,940 --> 00:48:23,701
And we also want to get our actual resolution higher,

884
00:48:23,721 --> 00:48:26,061
which is just more of general optimization work.

885
00:48:27,802 --> 00:48:29,142
We've also only scratched the surface

886
00:48:29,162 --> 00:48:30,503
for what the IDs can be used for.

887
00:48:31,123 --> 00:48:32,824
The general theme is that a number of heuristics

888
00:48:32,864 --> 00:48:35,024
can be removed in favor of trivial comparisons,

889
00:48:36,105 --> 00:48:38,425
such as the uncharted four or censor-based tagging stuff

890
00:48:38,445 --> 00:48:39,826
that we could replace with object IDs.

891
00:48:45,684 --> 00:48:47,885
We plan to implement Packed Checkerboard on other platforms.

892
00:48:48,345 --> 00:48:50,466
The PS4 Pro has some great hardware features for this,

893
00:48:50,766 --> 00:48:53,088
but reasonable workarounds exist for both Xbox

894
00:48:53,228 --> 00:48:54,268
and for base PS4.

895
00:48:55,709 --> 00:48:59,551
On PC, we need EQAA or something like that for all IHVs,

896
00:48:59,951 --> 00:49:01,812
as well as programmable sample locations

897
00:49:02,192 --> 00:49:03,292
for Vulkan and DirectX 12.

898
00:49:04,693 --> 00:49:06,314
We also need efficient driver support

899
00:49:06,374 --> 00:49:07,735
for the EQAA depth resolve,

900
00:49:08,275 --> 00:49:10,056
such that the source is left uncompressed

901
00:49:10,276 --> 00:49:11,856
and the technique is purely bandwidth bound.

902
00:49:16,690 --> 00:49:19,331
More forward-looking, but also related to high-resolution

903
00:49:19,371 --> 00:49:21,932
rendering, is the notion of using a filtered visibility

904
00:49:21,972 --> 00:49:24,693
buffer and decoupled shading and other variable shading rate

905
00:49:24,733 --> 00:49:25,214
techniques.

906
00:49:27,114 --> 00:49:28,715
G-buffer performance becomes challenging

907
00:49:28,735 --> 00:49:31,136
at high resolutions, so classic deferred shading

908
00:49:31,176 --> 00:49:31,816
isn't the answer.

909
00:49:32,737 --> 00:49:33,977
The goal of the visibility buffer

910
00:49:33,997 --> 00:49:36,699
is to decouple G-buffer from screen resolution, which

911
00:49:36,759 --> 00:49:39,640
improves performance at high resolutions like 2K, 4K,

912
00:49:40,000 --> 00:49:43,562
and even MSA configurations, as well as on some bandwidth

913
00:49:43,602 --> 00:49:44,422
limited platforms.

914
00:49:49,373 --> 00:49:51,414
I'd like to give a special thanks to the people listed here

915
00:49:51,474 --> 00:49:52,955
for their collaboration and feedback.

916
00:49:52,975 --> 00:49:54,116
It was greatly appreciated.

917
00:49:54,136 --> 00:50:01,339
And with that, I'd like to open it up

918
00:50:01,379 --> 00:50:02,519
to actually questions you have,

919
00:50:02,779 --> 00:50:03,720
and thank you very much for coming.

920
00:50:14,322 --> 00:50:16,483
Hello, nice presentation.

921
00:50:16,583 --> 00:50:20,526
Do you try or are you using any kind of stencil anti-alesian?

922
00:50:21,726 --> 00:50:23,407
Sorry, can you repeat the last part?

923
00:50:23,687 --> 00:50:26,269
If you are using or at least trying

924
00:50:27,210 --> 00:50:34,834
any kind of stencil, sorry, specular anti-alesian?

925
00:50:34,854 --> 00:50:37,176
Not this time, as far as I am aware, actually.

926
00:50:37,876 --> 00:50:40,318
We're investigating certain techniques, but no.

927
00:50:40,898 --> 00:50:41,358
Okay, thank you.

928
00:50:44,128 --> 00:50:50,772
Since you were using EQAA, did you find any use for the fmask, for example, for the color

929
00:50:50,792 --> 00:50:52,773
resolve?

930
00:50:53,113 --> 00:50:55,875
With this particular technique, you actually don't need to use fmask for it.

931
00:50:57,176 --> 00:51:01,038
I have some other plans for some of the vbuffer stuff maybe using fmask.

932
00:51:16,388 --> 00:51:17,731
All right, that looks like it.

933
00:51:18,252 --> 00:51:19,074
Thank you very much, everybody.

