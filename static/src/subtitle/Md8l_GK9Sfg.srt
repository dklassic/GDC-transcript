1
00:00:06,522 --> 00:00:06,782
All right.

2
00:00:07,563 --> 00:00:07,923
Hi, everyone.

3
00:00:08,184 --> 00:00:09,725
My name is Alexander, and I'm here

4
00:00:09,745 --> 00:00:11,807
to talk about the rendering of Memories Retold,

5
00:00:12,027 --> 00:00:14,849
or how to beep up ROS with shaders, I guess.

6
00:00:15,710 --> 00:00:17,992
Before we start, I'd like you to cancel,

7
00:00:18,732 --> 00:00:20,874
to silence your cell phones, and to remember

8
00:00:20,934 --> 00:00:23,957
to fill out the evaluation forms after the talk.

9
00:00:26,599 --> 00:00:29,501
So before we start talking about the Memories Retold,

10
00:00:29,982 --> 00:00:32,144
I am going to talk a little bit about myself.

11
00:00:36,342 --> 00:00:39,464
I feel very weird giving a graphics talk,

12
00:00:39,664 --> 00:00:42,225
because I am actually quite sight impaired.

13
00:00:42,305 --> 00:00:44,346
I only have 16% eyesight.

14
00:00:45,407 --> 00:00:47,808
It's specifically because of this gene right here.

15
00:00:49,389 --> 00:00:51,830
And I know that because they actually used a gene sample

16
00:00:51,850 --> 00:00:55,252
for me when I was one as part of the Human Genome Project.

17
00:00:55,632 --> 00:00:58,973
So I guess you're all welcome for that scientific discovery.

18
00:01:02,822 --> 00:01:06,044
And you might be wondering, why do I end up making games,

19
00:01:06,124 --> 00:01:09,185
which is such a visual medium, instead of continuing

20
00:01:09,205 --> 00:01:12,147
on this very promising career in genetics

21
00:01:12,267 --> 00:01:13,287
I had started so early?

22
00:01:14,268 --> 00:01:17,749
And it is kind of ironic, but for me,

23
00:01:17,789 --> 00:01:20,231
I've always been attracted to video games

24
00:01:20,271 --> 00:01:23,492
because they're these constructed environments that

25
00:01:23,732 --> 00:01:27,754
are meant to be traversed and be discovered and read

26
00:01:27,794 --> 00:01:28,235
at a glance.

27
00:01:30,086 --> 00:01:33,268
When a good level designer makes a level,

28
00:01:33,328 --> 00:01:34,868
they will use something called a squint test,

29
00:01:35,069 --> 00:01:36,729
where they will blur their vision

30
00:01:36,929 --> 00:01:39,491
and see if the level is still legible.

31
00:01:40,912 --> 00:01:42,072
I can't stop squint test.

32
00:01:42,572 --> 00:01:43,333
I do it all the time.

33
00:01:43,493 --> 00:01:45,474
And let me tell you, reality doesn't hold up to it.

34
00:01:46,314 --> 00:01:49,836
So having games where the environment

35
00:01:49,856 --> 00:01:51,277
has actually been designed to be legible,

36
00:01:52,838 --> 00:01:54,158
it's not so weird I ended up doing this.

37
00:01:57,160 --> 00:01:59,081
More specifically, with.

38
00:02:03,287 --> 00:02:07,368
painterly aesthetics and something that's not trying to be photorealistic, quite often

39
00:02:07,428 --> 00:02:12,869
it's a lot easier to read, because artists are thinking much more about the base shape

40
00:02:12,909 --> 00:02:21,912
of the objects and you don't have all the noise of the real life coming in the way.

41
00:02:21,932 --> 00:02:26,633
So for example, playing a game like The Return of the Obra Dinn was something I really enjoyed,

42
00:02:26,693 --> 00:02:32,935
because everything had clear outlines and was easy to tell apart.

43
00:02:36,765 --> 00:02:40,447
So when I got the chance to work on 11.11, I jumped at it.

44
00:02:41,908 --> 00:02:45,489
It's a narrative game set in the First World War.

45
00:02:45,889 --> 00:02:49,971
And it tells the story from both the German and the

46
00:02:50,051 --> 00:02:50,591
Allied side.

47
00:02:51,171 --> 00:02:54,753
It's a co-production between Art and Animations, Didixart,

48
00:02:55,053 --> 00:02:56,834
and it's published by Bandai Namco.

49
00:02:57,754 --> 00:03:00,916
Team size was around 30, and the team was distributed all

50
00:03:00,936 --> 00:03:01,476
around the world.

51
00:03:01,496 --> 00:03:03,657
I think that's like a talk in itself, how we

52
00:03:03,897 --> 00:03:04,637
managed to do that.

53
00:03:06,463 --> 00:03:11,127
We used Unity 17.3 with a modified legacy deferred

54
00:03:11,147 --> 00:03:11,427
renderer.

55
00:03:12,328 --> 00:03:17,792
And development time was approximately six months

56
00:03:17,852 --> 00:03:21,655
of pre-production and 10 months of full production.

57
00:03:23,196 --> 00:03:25,738
And the game was released in November

58
00:03:26,779 --> 00:03:28,960
to commemorate the centennial of the armistice,

59
00:03:29,161 --> 00:03:29,681
and hence the name.

60
00:03:31,637 --> 00:03:33,717
As you can see, we kind of have the release date

61
00:03:34,137 --> 00:03:35,138
in the name of the game,

62
00:03:35,418 --> 00:03:38,519
so we could not afford any delays.

63
00:03:38,619 --> 00:03:41,219
So that was a very interesting experience,

64
00:03:41,259 --> 00:03:42,440
but we managed to do it in the end.

65
00:03:45,521 --> 00:03:47,801
Oh, in case you haven't seen the game,

66
00:03:47,821 --> 00:03:48,882
I'm gonna show you the trailer

67
00:03:49,122 --> 00:03:52,163
so you can get a sense of how this painterly art style looks.

68
00:03:53,863 --> 00:03:56,264
So if we can zoom in here.

69
00:04:14,549 --> 00:04:18,672
The first time you see someone die, everything shuts down.

70
00:04:18,692 --> 00:04:22,534
You're left with thoughts that go round and round.

71
00:04:24,976 --> 00:04:26,157
Every man has his demons.

72
00:04:29,919 --> 00:04:31,460
I did what any father would do.

73
00:04:31,480 --> 00:04:35,003
And I would make the same choices again.

74
00:04:58,741 --> 00:04:59,721
I just did what we all did.

75
00:05:03,743 --> 00:05:04,443
I followed orders.

76
00:05:33,957 --> 00:05:35,258
Yeah, that music always gets me.

77
00:05:39,082 --> 00:05:43,386
All right, so here is the outline of the talk.

78
00:05:44,067 --> 00:05:45,448
I'm first gonna give you an overview

79
00:05:45,468 --> 00:05:47,650
of how the painterly render pipeline works,

80
00:05:48,811 --> 00:05:50,633
and I'm then gonna go over some challenges

81
00:05:50,873 --> 00:05:53,655
and snazzy features that is in it.

82
00:05:54,576 --> 00:05:57,159
After that, I'm gonna show you how the artist used the pipeline,

83
00:05:57,879 --> 00:05:59,961
and following that is optimization of it.

84
00:06:00,987 --> 00:06:05,911
And then at the end, I'm going to have a very short section on future improvements.

85
00:06:06,231 --> 00:06:08,733
And at the end, there will also be some time for questions.

86
00:06:13,317 --> 00:06:19,182
So all these interstitials you're going to see throughout the talk are actually the concept

87
00:06:19,202 --> 00:06:20,523
that we were working towards.

88
00:06:20,743 --> 00:06:24,547
So that should give you an idea of where we were at the start and where we ended up.

89
00:06:25,848 --> 00:06:26,008
So...

90
00:06:27,117 --> 00:06:28,818
Whenever I start on a new project,

91
00:06:29,458 --> 00:06:31,480
and I have to develop new tech for it,

92
00:06:31,700 --> 00:06:33,522
I look at existing white papers.

93
00:06:34,282 --> 00:06:35,843
Specifically when you're doing graphics programming,

94
00:06:35,863 --> 00:06:37,365
if you find papers that are kind of old,

95
00:06:37,885 --> 00:06:40,447
it means that they're quite likely to be

96
00:06:43,229 --> 00:06:45,010
something you can actually achieve

97
00:06:45,531 --> 00:06:47,012
like for a commercial project now,

98
00:06:47,072 --> 00:06:48,793
because you're also gonna make sure

99
00:06:48,813 --> 00:06:49,734
that you have enough headroom

100
00:06:49,834 --> 00:06:51,375
for the rest of the rendering taking place.

101
00:06:52,016 --> 00:06:53,637
Thankfully, I found these two papers.

102
00:06:55,241 --> 00:06:59,605
that are both using particles to approximate brush strokes.

103
00:06:59,866 --> 00:07:00,967
So you get this painterly look.

104
00:07:06,513 --> 00:07:07,073
Sorry about that.

105
00:07:08,194 --> 00:07:08,555
There we go.

106
00:07:11,858 --> 00:07:12,098
OK.

107
00:07:12,619 --> 00:07:12,859
There we go.

108
00:07:14,305 --> 00:07:17,807
So what you see here is two papers that are,

109
00:07:19,328 --> 00:07:21,069
one is completely object-based,

110
00:07:21,549 --> 00:07:23,830
and the other one is working full screen.

111
00:07:23,990 --> 00:07:26,292
Especially the one on the right showed us

112
00:07:26,352 --> 00:07:28,513
that this is actually an approach that could work.

113
00:07:29,814 --> 00:07:32,555
And the way that it works in the game

114
00:07:32,655 --> 00:07:37,338
is we have the base frame, the base frame buffer,

115
00:07:38,078 --> 00:07:40,899
and on top of that, we paint all these particles,

116
00:07:41,560 --> 00:07:43,561
and then they are combined together.

117
00:07:44,924 --> 00:07:51,565
The first innovation we did was just painting these particles on top of the frame buffer.

118
00:07:52,205 --> 00:07:56,466
Already it meant that it looked a lot better than what had been done before,

119
00:07:56,646 --> 00:07:59,807
because we could close all the gaps in the particles.

120
00:08:01,227 --> 00:08:08,188
And it kind of resembles how if you're using a camera obscura,

121
00:08:08,308 --> 00:08:12,109
like you're basically taking a picture and then you're painting the strokes on top of it.

122
00:08:16,028 --> 00:08:18,228
On the technical side, all of this is based on

123
00:08:19,448 --> 00:08:22,049
a technique developed by Garrett Thomas from AMD.

124
00:08:23,229 --> 00:08:26,870
It's all based on compute, and it's a tile-based approach.

125
00:08:27,710 --> 00:08:30,670
I will only do a very quick overview of how it works

126
00:08:30,690 --> 00:08:35,531
because he took a whole talk explaining in more detail

127
00:08:36,051 --> 00:08:37,632
how each step is put together.

128
00:08:38,552 --> 00:08:40,592
But his slides are readily available on the Vault

129
00:08:40,692 --> 00:08:41,852
if you need to check them out.

130
00:08:42,393 --> 00:08:43,673
And there's also a Git repository.

131
00:08:46,555 --> 00:08:49,657
Right, so this is how a frame is constructed.

132
00:08:50,478 --> 00:08:52,760
We first have the regular frame buffer rendering.

133
00:08:53,200 --> 00:08:57,543
And together with that, we also render a specific brush buffer

134
00:08:57,743 --> 00:09:01,546
that contains extra information for the effect

135
00:09:01,626 --> 00:09:03,127
to place the brush strokes.

136
00:09:04,488 --> 00:09:07,591
After that, we do bloom and ambient occlusion.

137
00:09:09,252 --> 00:09:12,194
And after that, we start the actual rendering.

138
00:09:14,776 --> 00:09:15,757
Sorry, my notes are.

139
00:09:17,153 --> 00:09:17,494
Can I do this?

140
00:09:17,814 --> 00:09:20,695
Nope.

141
00:09:20,795 --> 00:09:22,095
So we generate new strokes,

142
00:09:23,416 --> 00:09:28,898
and after that we update the strokes

143
00:09:28,938 --> 00:09:29,818
that are currently on the screen.

144
00:09:29,978 --> 00:09:32,819
Some of them are deleted and will die out.

145
00:09:35,480 --> 00:09:36,520
Yes, there we go.

146
00:09:38,661 --> 00:09:43,583
And then we end with calling and course calling.

147
00:09:45,702 --> 00:09:48,283
All of this is basically to make the rendering of the strokes

148
00:09:48,623 --> 00:09:53,265
more efficient at the end.

149
00:09:53,285 --> 00:09:56,807
And we also do blending with the background image as part

150
00:09:56,847 --> 00:09:57,807
of the brush stroke rendering.

151
00:09:58,468 --> 00:10:01,709
And when all of that is done, we have the color grading and

152
00:10:01,909 --> 00:10:02,350
tone mapping.

153
00:10:06,552 --> 00:10:08,873
This is the different aspects that the

154
00:10:08,953 --> 00:10:09,873
artists have control over.

155
00:10:10,193 --> 00:10:11,274
And what you're seeing here is the

156
00:10:12,820 --> 00:10:14,320
different debug views that they have.

157
00:10:14,901 --> 00:10:18,202
So they can control the size of the brush strokes, if the

158
00:10:18,222 --> 00:10:20,543
brush strokes should boil, and if they should flow.

159
00:10:21,223 --> 00:10:23,344
If they boil, they basically die out quicker.

160
00:10:23,384 --> 00:10:25,065
So you get something that kind of shimmers.

161
00:10:25,645 --> 00:10:27,206
It's really good for interactive objects in the

162
00:10:27,246 --> 00:10:29,107
game, something that you need to stand out.

163
00:10:30,660 --> 00:10:35,704
Since this game is about the First World War, a lot of the levels take place in the trenches

164
00:10:35,764 --> 00:10:38,866
and they're like really wet and muddy, so we needed to show something that was like

165
00:10:38,926 --> 00:10:39,627
running with water.

166
00:10:40,407 --> 00:10:44,471
And that means that the artist can actually go in and say, like, I want this, the strokes

167
00:10:44,671 --> 00:10:45,832
to flow along the surface.

168
00:10:46,532 --> 00:10:51,796
And they flow along the direction that the artists have also instructed the effect to

169
00:10:51,896 --> 00:10:51,996
use.

170
00:10:54,153 --> 00:10:56,254
Something that is also quite unique

171
00:10:56,274 --> 00:10:57,575
is that we can actually select

172
00:10:57,795 --> 00:11:00,116
what brush stroke we should render with.

173
00:11:00,517 --> 00:11:02,278
So that way, you can have something

174
00:11:02,318 --> 00:11:04,519
that approximates, like, a very dry brush

175
00:11:04,559 --> 00:11:06,340
being kind of, like, dabbed onto the canvas,

176
00:11:06,360 --> 00:11:08,061
but you can also have something that's much more...

177
00:11:09,582 --> 00:11:11,483
wet and, like, long longer.

178
00:11:12,164 --> 00:11:14,285
So there's a lot of flexibility for the artist to use there.

179
00:11:17,046 --> 00:11:19,008
This is the format of the brush buffer.

180
00:11:20,088 --> 00:11:20,228
So...

181
00:11:21,747 --> 00:11:24,568
Size, flow speed, and angle each get a full eight bits

182
00:11:24,628 --> 00:11:26,488
because we need as much precision there as we can get.

183
00:11:28,909 --> 00:11:31,410
For brush type, I'm only using six bits.

184
00:11:31,771 --> 00:11:37,893
And then I have two bits left for boil speed.

185
00:11:39,133 --> 00:11:41,274
The reason for this layout was predominantly

186
00:11:41,314 --> 00:11:45,076
that we had to integrate this into the deferred buffer.

187
00:11:45,256 --> 00:11:47,717
And gamma correction caused some of these values

188
00:11:47,757 --> 00:11:48,537
to be kind of wonky.

189
00:11:48,557 --> 00:11:50,338
So it had to be laid out this way.

190
00:11:59,186 --> 00:12:01,830
So an early challenge was to make sure that the brushstrokes

191
00:12:01,870 --> 00:12:03,953
would actually be aligned with the objects.

192
00:12:04,314 --> 00:12:07,078
And that's both, they have to respect the object's own

193
00:12:07,098 --> 00:12:09,242
orientation, as you see with the magenta arrows.

194
00:12:09,983 --> 00:12:14,670
And they also had to work with perspective distortion.

195
00:12:15,500 --> 00:12:16,941
And it took me a while to figure this out,

196
00:12:16,981 --> 00:12:19,342
but what I ended up doing was that I would take

197
00:12:20,082 --> 00:12:23,564
both the current fragments' position in world space

198
00:12:23,604 --> 00:12:24,465
into the fragment shader,

199
00:12:24,965 --> 00:12:28,987
along with the world tangent and cotangent.

200
00:12:29,628 --> 00:12:32,129
And that way, I could generate an offset point

201
00:12:32,189 --> 00:12:34,791
and take both of them into screen space

202
00:12:34,891 --> 00:12:36,912
and get a direction vector.

203
00:12:37,793 --> 00:12:39,794
and then take the, get the radiance from that

204
00:12:39,814 --> 00:12:41,796
and then store that as a normalized radian

205
00:12:41,976 --> 00:12:42,717
into the brush map.

206
00:12:43,537 --> 00:12:45,139
This all sounds kind of expensive,

207
00:12:45,199 --> 00:12:49,001
and yeah, I was using an ATAN 2 for that,

208
00:12:49,062 --> 00:12:51,583
but it turned out to not be that big of an issue

209
00:12:51,864 --> 00:12:54,326
as we're gonna cover later in the optimization step.

210
00:13:01,171 --> 00:13:03,753
There we go.

211
00:13:04,714 --> 00:13:04,794
So.

212
00:13:05,987 --> 00:13:08,268
When new strokes are created,

213
00:13:08,368 --> 00:13:11,130
it happens in a kernel that takes the whole screen

214
00:13:11,230 --> 00:13:13,532
and for each pixel generates a random number.

215
00:13:14,112 --> 00:13:17,174
Then for, um, to modify this spawn chance,

216
00:13:17,634 --> 00:13:21,277
we look at the current brush size we want here

217
00:13:21,797 --> 00:13:23,558
and the flow speed along with the boil speed

218
00:13:24,299 --> 00:13:26,360
and also the alpha coverage of the strokes

219
00:13:26,380 --> 00:13:27,020
that are already there.

220
00:13:27,060 --> 00:13:29,482
So if we don't have a good amount of coverage,

221
00:13:29,602 --> 00:13:31,083
we want to create more brush strokes.

222
00:13:32,112 --> 00:13:33,933
And all of those numbers are added together.

223
00:13:34,154 --> 00:13:36,355
And if there are more than one, a brush stroke is created.

224
00:13:36,575 --> 00:13:41,278
And that is by taking an index from a consume buffer and use

225
00:13:41,298 --> 00:13:45,961
that to index into all the data arrays that contains all the

226
00:13:45,981 --> 00:13:46,882
information for the strokes.

227
00:13:51,925 --> 00:13:54,406
So it's important that the RNG is very uniform.

228
00:13:55,187 --> 00:13:56,808
To start with, I was using a noise texture.

229
00:13:56,848 --> 00:13:59,610
And I kept getting strokes planted on top of each other,

230
00:13:59,650 --> 00:13:59,950
which was a.

231
00:14:00,872 --> 00:14:03,656
Both didn't look good, and it was also not very performant.

232
00:14:03,716 --> 00:14:09,344
So at the end, I used WangHash, which Cabbie Games

233
00:14:09,444 --> 00:14:11,647
covers in the render talk on below.

234
00:14:12,348 --> 00:14:15,312
It's very easy to implement, and it is producing some very

235
00:14:15,353 --> 00:14:15,733
nice noise.

236
00:14:15,953 --> 00:14:17,095
So I can recommend using that.

237
00:14:21,122 --> 00:14:22,662
So after the strokes are created,

238
00:14:22,882 --> 00:14:25,523
we move on to updating all the strokes that

239
00:14:25,543 --> 00:14:26,364
are already on the screen.

240
00:14:27,104 --> 00:14:29,165
The first thing is that the precision is updated.

241
00:14:29,765 --> 00:14:32,866
And then we get the depth and color from the gbuffer.

242
00:14:34,106 --> 00:14:37,288
We also get the brush type, flow speed, boil speed, and size

243
00:14:37,328 --> 00:14:38,368
from the brush map buffer.

244
00:14:39,268 --> 00:14:40,889
And if the surface is flowing or boiling,

245
00:14:40,949 --> 00:14:45,791
the stroke will die out faster when we are applying

246
00:14:45,831 --> 00:14:47,331
the lifetime to the stroke.

247
00:14:48,831 --> 00:14:51,972
A stroke is removed, that is, its index is added back to the

248
00:14:52,092 --> 00:14:55,494
consume buffer from before, if its alpha hits zero.

249
00:14:59,436 --> 00:15:04,419
So in order to make the effect not look like you're watching

250
00:15:04,439 --> 00:15:06,200
it through a screen door.

251
00:15:07,430 --> 00:15:09,972
It's quite important that it moves with the scene underneath.

252
00:15:10,432 --> 00:15:13,594
So what you're seeing here is the same scene,

253
00:15:14,014 --> 00:15:17,557
but where, on one hand, they are completely static.

254
00:15:17,577 --> 00:15:18,457
They don't follow the scene.

255
00:15:18,677 --> 00:15:20,959
On the right side, they are using motion vectors

256
00:15:20,999 --> 00:15:22,100
to move along.

257
00:15:22,380 --> 00:15:24,301
And especially if you're looking at the door frame,

258
00:15:24,321 --> 00:15:26,643
you can clearly see that there's a lot of flickering going on

259
00:15:28,684 --> 00:15:29,385
if you don't do this.

260
00:15:29,845 --> 00:15:32,227
Thankfully, in Unity, you can just say,

261
00:15:32,267 --> 00:15:33,868
I want motion vectors, and you get them,

262
00:15:34,048 --> 00:15:36,390
and they turn out to be of a pretty good quality.

263
00:15:41,345 --> 00:15:42,466
Next step is coarse culling.

264
00:15:43,467 --> 00:15:45,968
This happens with the box-box intersection.

265
00:15:46,809 --> 00:15:51,272
And testing revealed that 16 by 8 culling tiles was the most

266
00:15:51,312 --> 00:15:51,973
efficient number.

267
00:15:54,294 --> 00:16:02,059
When a collision is detected, the stroke's index is added to

268
00:16:02,099 --> 00:16:03,440
that tile's index buffer.

269
00:16:04,501 --> 00:16:08,365
And a very similar approach is used for the next step,

270
00:16:08,485 --> 00:16:09,466
the fine-calling.

271
00:16:10,086 --> 00:16:12,369
Uh, here each tile is 32 by 32 pixels.

272
00:16:13,450 --> 00:16:15,291
It's again a box-box intersection testing,

273
00:16:15,772 --> 00:16:17,153
but when we're done with that,

274
00:16:17,253 --> 00:16:19,956
we also do a step of bitonic, uh, sorting

275
00:16:20,016 --> 00:16:21,738
based on the depth of the particles,

276
00:16:22,979 --> 00:16:25,441
um, to get correct alpha blending later on.

277
00:16:26,682 --> 00:16:28,024
And the bitonic sort is the same

278
00:16:28,064 --> 00:16:29,445
that Garrett Thomas used in his talk.

279
00:16:35,770 --> 00:16:39,532
So the render kernel is what really is the most different

280
00:16:39,612 --> 00:16:41,433
from Garrett's approach.

281
00:16:42,354 --> 00:16:49,817
It starts by loading all the stroke data into LDS.

282
00:16:50,378 --> 00:16:51,438
So it's faster to retrieve.

283
00:16:52,099 --> 00:16:55,020
We then set the accumulated color to zero.

284
00:16:55,841 --> 00:17:00,103
And we then, for each thread, take care of one pixel.

285
00:17:01,057 --> 00:17:03,178
We loop through the particles, and it's essentially

286
00:17:03,658 --> 00:17:04,818
a ray cast through them.

287
00:17:05,559 --> 00:17:11,482
So if the ray hits the stroke, we sample its stroke texture

288
00:17:12,322 --> 00:17:14,103
and combine it with the stroke's color

289
00:17:14,283 --> 00:17:15,644
and add it to the accumulated color.

290
00:17:16,524 --> 00:17:18,365
By using a custom alpha blend, we

291
00:17:18,385 --> 00:17:21,246
can actually go front to back instead of back to front.

292
00:17:22,382 --> 00:17:24,023
We didn't see much of an improvement.

293
00:17:24,143 --> 00:17:28,225
In Garrett Thomas's talk, he sees a huge performance boost

294
00:17:28,265 --> 00:17:28,585
from this.

295
00:17:28,605 --> 00:17:30,706
But it's mainly just because he's actually

296
00:17:30,746 --> 00:17:33,247
doing particles in world space.

297
00:17:33,467 --> 00:17:35,228
And he shows that you can go very close to them.

298
00:17:35,648 --> 00:17:38,950
And then I just left it in because it wasn't

299
00:17:39,030 --> 00:17:39,910
hurting performance either.

300
00:17:41,611 --> 00:17:44,712
All of this is rendered into an HDR-ready back buffer.

301
00:17:45,473 --> 00:17:46,373
So we avoid banding.

302
00:17:47,313 --> 00:17:48,874
And the alpha value stored here is

303
00:17:51,297 --> 00:17:53,357
is what is used in the generation kernel

304
00:17:53,437 --> 00:17:55,378
to determine how much coverage we have.

305
00:17:59,760 --> 00:18:05,162
So strokes are stored in an alpha 8 2K texture.

306
00:18:06,663 --> 00:18:08,864
We found out that distinctive strokes are actually

307
00:18:08,924 --> 00:18:12,585
way more important than quite diffuse and soft.

308
00:18:12,745 --> 00:18:14,986
I personally thought that was actually going to work better.

309
00:18:15,326 --> 00:18:17,167
And it turned out I was completely wrong.

310
00:18:18,242 --> 00:18:20,962
And different sprites give impression

311
00:18:20,982 --> 00:18:21,863
of different surfaces.

312
00:18:21,963 --> 00:18:25,044
So for example, for wood, we ended up using quite long and

313
00:18:25,104 --> 00:18:25,644
hard strokes.

314
00:18:25,704 --> 00:18:28,805
And then for the cat in the game, we had some that were

315
00:18:28,845 --> 00:18:30,666
much more like hairy and bristly.

316
00:18:30,686 --> 00:18:34,787
All right.

317
00:18:35,967 --> 00:18:37,648
So let's cover some snazzy features.

318
00:18:40,469 --> 00:18:44,270
Early on, the biggest issue we had with the

319
00:18:44,310 --> 00:18:45,430
effect was readability.

320
00:18:46,343 --> 00:18:48,244
which shouldn't really come as a surprise, I guess.

321
00:18:48,665 --> 00:18:51,447
What you're seeing here is actually a screenshot

322
00:18:51,507 --> 00:18:55,130
from the vertical slice a couple of months into production.

323
00:18:55,150 --> 00:18:57,932
And this was a bit of a crisis moment,

324
00:18:58,172 --> 00:19:00,314
because if we couldn't get this to work,

325
00:19:00,354 --> 00:19:03,636
we would have to abandon the pencil effect

326
00:19:03,696 --> 00:19:04,897
and do something completely different.

327
00:19:05,158 --> 00:19:06,158
You might not be able to see it,

328
00:19:06,218 --> 00:19:08,160
but there's actually a man crouching on the ground.

329
00:19:09,681 --> 00:19:13,784
So this amount of, yeah, blurriness,

330
00:19:15,105 --> 00:19:15,786
that just wouldn't work.

331
00:19:16,657 --> 00:19:21,059
For the vertical slice, what we ended up doing

332
00:19:21,079 --> 00:19:22,701
was just increasing the amount of particles

333
00:19:22,761 --> 00:19:25,823
so they would approximate the shape of the scene more.

334
00:19:26,363 --> 00:19:30,466
But for the full release, this didn't look that great.

335
00:19:30,646 --> 00:19:32,947
And it also wasn't performance, so we

336
00:19:32,987 --> 00:19:34,228
had to find out a different way to do it.

337
00:19:38,551 --> 00:19:40,052
So the reason why this happens is

338
00:19:40,092 --> 00:19:42,273
that we're painting all the strokes on top

339
00:19:42,313 --> 00:19:43,194
of the background image.

340
00:19:44,094 --> 00:19:44,214
And.

341
00:19:45,405 --> 00:19:47,646
That basically means that if you have a stroke that is from

342
00:19:47,686 --> 00:19:51,248
the background, it's still going to cover something that

343
00:19:51,288 --> 00:19:54,149
is in the foreground, such as Kurt's arm here that's being

344
00:19:54,209 --> 00:19:58,991
obscured by the particles from the sea behind him.

345
00:20:02,132 --> 00:20:08,235
So the trick was to sample the depth buffer.

346
00:20:09,455 --> 00:20:11,296
in the render kernel so we know what is the

347
00:20:12,517 --> 00:20:14,458
absolute depth we should traverse through

348
00:20:14,498 --> 00:20:15,839
when we go through all our particles.

349
00:20:16,659 --> 00:20:18,420
So we get like all the particles

350
00:20:18,440 --> 00:20:19,861
that are belonging to Kurt's arm,

351
00:20:20,161 --> 00:20:22,702
but we stop when we know that the particles

352
00:20:22,722 --> 00:20:24,063
that are behind him

353
00:20:27,125 --> 00:20:28,265
would just lead to like

354
00:20:28,786 --> 00:20:29,666
covering up the

355
00:20:32,147 --> 00:20:32,968
what's in the foreground.

356
00:20:34,622 --> 00:20:37,423
So this works, but you see that we get these, like,

357
00:20:37,443 --> 00:20:38,803
quite hard edges on objects,

358
00:20:38,883 --> 00:20:39,924
which is not painted at all.

359
00:20:40,724 --> 00:20:41,684
And in order to fix that,

360
00:20:41,744 --> 00:20:43,425
we end up blurring the background

361
00:20:43,485 --> 00:20:45,825
with a Kawase filter.

362
00:20:46,586 --> 00:20:48,026
And the reason why I ended up using this

363
00:20:48,186 --> 00:20:49,406
is because it's quite performant.

364
00:20:50,027 --> 00:20:52,647
It takes a little bit of, like, manual tweaking.

365
00:20:52,827 --> 00:20:54,408
So what you do is, at each step,

366
00:20:54,968 --> 00:20:58,229
you sample out in a cross of four samples.

367
00:20:58,289 --> 00:21:00,349
And if you use, uh, bilinear sampling,

368
00:21:00,369 --> 00:21:02,490
you end up with double the amount.

369
00:21:03,430 --> 00:21:03,470
Uh...

370
00:21:04,913 --> 00:21:07,955
So it's quite easy to use.

371
00:21:08,195 --> 00:21:10,316
It does require a little bit of manual tweaking, so you

372
00:21:10,356 --> 00:21:13,418
don't get the banding artifacts you might be able to

373
00:21:13,458 --> 00:21:14,158
see in the projector.

374
00:21:15,479 --> 00:21:16,560
But yeah, I recommend using it.

375
00:21:19,422 --> 00:21:23,284
Something that was also important was that objects

376
00:21:23,444 --> 00:21:27,106
would have the correct size of strokes attached to them.

377
00:21:27,995 --> 00:21:29,776
So if something recedes into the background,

378
00:21:29,816 --> 00:21:31,476
and it's important that it's still legible,

379
00:21:31,617 --> 00:21:33,377
we need the strokes on them to be smaller.

380
00:21:34,378 --> 00:21:37,039
And that was quite easy by just taking

381
00:21:37,099 --> 00:21:43,903
the depth of the fragment shader and used that

382
00:21:43,923 --> 00:21:44,883
to increase the brush size.

383
00:21:45,723 --> 00:21:47,584
Interestingly enough, we actually

384
00:21:47,604 --> 00:21:49,525
ended up having this something that the artist could

385
00:21:49,585 --> 00:21:50,626
control with a modifier.

386
00:21:51,761 --> 00:21:53,321
And they would sometimes use it in reverse.

387
00:21:54,101 --> 00:21:58,522
So if you have something where you want to guide the eye of

388
00:21:58,542 --> 00:22:01,643
the player, this is like a technique that's also used in

389
00:22:01,903 --> 00:22:05,744
regular painting, where you will use detail where you want

390
00:22:05,804 --> 00:22:07,244
the viewer to look.

391
00:22:07,924 --> 00:22:11,485
And this meant that we could actually get something kind of

392
00:22:11,505 --> 00:22:13,965
similar in an interactive environment, which I think is

393
00:22:13,985 --> 00:22:14,365
pretty cool.

394
00:22:16,886 --> 00:22:19,266
It also had to take in the camera's field of view.

395
00:22:20,122 --> 00:22:23,464
So in the game, one of the characters has a camera

396
00:22:23,965 --> 00:22:25,266
and can take pictures.

397
00:22:25,946 --> 00:22:29,669
And in order to have zooming, we changed the camera's FOV.

398
00:22:29,769 --> 00:22:32,752
And it's not really because you have a different distance

399
00:22:32,772 --> 00:22:36,715
to the object, but they can still be smaller or bigger on

400
00:22:36,735 --> 00:22:37,115
the screen.

401
00:22:37,395 --> 00:22:42,459
And I fixed that by just having a curve for the artist

402
00:22:42,840 --> 00:22:46,263
to tweak where this would be added in based on the current

403
00:22:46,403 --> 00:22:47,243
FOV of the camera.

404
00:22:52,026 --> 00:22:55,992
Early on, it was all about getting as many strokes on the screen as possible.

405
00:22:56,172 --> 00:22:59,957
We thought that this is how we're going to make it look really good.

406
00:23:00,478 --> 00:23:04,143
So we had around 2 million strokes at the end of the vertical slice.

407
00:23:08,394 --> 00:23:10,015
sort of like halfway through development,

408
00:23:10,215 --> 00:23:11,495
we started to realize, actually,

409
00:23:12,136 --> 00:23:12,956
it's better if there's fewer,

410
00:23:12,996 --> 00:23:15,378
because they look quite artificial

411
00:23:15,478 --> 00:23:17,099
if they're placed right next to each other.

412
00:23:18,299 --> 00:23:20,061
It looks like this manic robot has been like,

413
00:23:20,081 --> 00:23:22,582
ah, I need to paint this as good as possible.

414
00:23:25,891 --> 00:23:29,073
For longer strokes, because they will have the same height

415
00:23:29,273 --> 00:23:31,395
as short strokes, they will cover a large area.

416
00:23:32,175 --> 00:23:33,336
So we need fewer of them.

417
00:23:33,937 --> 00:23:36,578
And I basically just took that into account when generating

418
00:23:37,219 --> 00:23:38,780
the random probability of them spawning.

419
00:23:39,460 --> 00:23:43,303
And this had the added benefit that it looked better, but we

420
00:23:43,323 --> 00:23:44,864
would also get better performance because there was

421
00:23:44,884 --> 00:23:45,985
fewer brush strokes on the screen.

422
00:23:46,005 --> 00:23:48,827
So for example, here, if you look at the image to the

423
00:23:48,887 --> 00:23:54,091
right, the beams look a lot more painterly and human-made.

424
00:23:55,412 --> 00:23:56,793
because there's fewer strokes on them.

425
00:24:02,057 --> 00:24:04,319
The second artist problem to solve was flickering.

426
00:24:04,459 --> 00:24:07,001
So the strokes kind of act as a...

427
00:24:08,162 --> 00:24:10,764
as a downsampling of the base framebuffer.

428
00:24:12,065 --> 00:24:15,787
And this causes the scene to be, uh...

429
00:24:15,988 --> 00:24:17,589
become, like, very noisy.

430
00:24:18,929 --> 00:24:21,333
when you're moving the camera around and when objects are moving.

431
00:24:22,195 --> 00:24:27,603
And the solution to this was to sample the color of the brush stroke and across.

432
00:24:27,644 --> 00:24:32,712
So we wouldn't just use the center of the stroke, but we would also look around it.

433
00:24:33,902 --> 00:24:37,547
Um, here I would actually use the brush type as well

434
00:24:37,767 --> 00:24:39,569
to basically do a bit of rejection sampling.

435
00:24:40,010 --> 00:24:42,833
So you kind of want the stroke to be colored

436
00:24:42,873 --> 00:24:44,895
by only the object that it's supposed to represent,

437
00:24:45,516 --> 00:24:47,699
but we don't have that data available.

438
00:24:48,359 --> 00:24:50,082
But there's a good chance that...

439
00:24:50,846 --> 00:24:54,992
it's only going to be the object itself that has the exact same brush type.

440
00:24:55,793 --> 00:24:59,197
So it's like something in the background is likely going to be using something else.

441
00:24:59,698 --> 00:25:04,384
So this was like a cheap and quick way to kind of fake that.

442
00:25:07,940 --> 00:25:10,443
We also found out that the motion vectors from Unity

443
00:25:10,503 --> 00:25:12,265
are a little bit noisy.

444
00:25:12,585 --> 00:25:14,307
So even when nothing is moving, there

445
00:25:14,327 --> 00:25:15,748
would be a little bit of drift.

446
00:25:16,409 --> 00:25:18,351
So by applying a simple threshold,

447
00:25:18,571 --> 00:25:19,472
that also took care of that.

448
00:25:19,512 --> 00:25:21,715
So the camera would have to actually be in motion,

449
00:25:21,755 --> 00:25:23,076
or an object would have to be in motion

450
00:25:23,096 --> 00:25:28,542
before you would start to have the stroke changing shape.

451
00:25:29,503 --> 00:25:30,544
Oh, sorry, changing color.

452
00:25:36,122 --> 00:25:38,542
So in the real world, when you're looking at a painting,

453
00:25:38,582 --> 00:25:40,943
you can actually pick out the individual brush strokes.

454
00:25:41,923 --> 00:25:46,285
That's because each stroke will catch the light a little bit

455
00:25:46,305 --> 00:25:48,125
differently because of the inherent impasto.

456
00:25:49,246 --> 00:25:51,286
Of course, we can't actually do that.

457
00:25:53,055 --> 00:25:55,016
because we don't know the lighting conditions

458
00:25:55,176 --> 00:25:57,758
of each player's room that they're playing in.

459
00:25:58,399 --> 00:25:59,400
But we can approximate it.

460
00:25:59,840 --> 00:26:02,862
And that's simply by randomizing the color

461
00:26:03,583 --> 00:26:04,984
and also by randomizing the angle.

462
00:26:05,004 --> 00:26:06,745
We actually get something that looks a lot more

463
00:26:07,046 --> 00:26:07,906
like handcrafted.

464
00:26:10,088 --> 00:26:13,450
And it's also kind of like part of the pointillism,

465
00:26:14,131 --> 00:26:15,772
which is part of impressionism

466
00:26:15,812 --> 00:26:18,735
that inspired this whole art style to begin with.

467
00:26:25,599 --> 00:26:30,382
So the way that this randomization is done is, um,

468
00:26:31,242 --> 00:26:32,983
I tried to first use HSV,

469
00:26:33,263 --> 00:26:35,645
but I got a lot of, uh, like, flickery

470
00:26:35,745 --> 00:26:37,926
and edge cases where it wouldn't work.

471
00:26:38,006 --> 00:26:40,587
So in the end, I had to come up with something where,

472
00:26:41,107 --> 00:26:42,988
because all the other colors was in RGB,

473
00:26:43,008 --> 00:26:45,270
like, the randomization of them also had to be in RGB.

474
00:26:46,110 --> 00:26:48,271
And by looking at the color space,

475
00:26:49,152 --> 00:26:50,072
like the RGB color cube,

476
00:26:50,552 --> 00:26:52,053
you can actually see that you, if you...

477
00:26:53,629 --> 00:26:55,070
Look at it from the right direction.

478
00:26:55,130 --> 00:26:56,991
It kind of resembles HSV anyways.

479
00:26:57,732 --> 00:27:01,655
So if you take a vector that goes from pure black to pure

480
00:27:01,675 --> 00:27:05,619
white and use that to form an orthonormal set of basis

481
00:27:05,639 --> 00:27:08,501
vectors, you can actually use those to add color

482
00:27:08,521 --> 00:27:09,102
randomization.

483
00:27:09,542 --> 00:27:12,325
It's by no means perfect, but it's good enough for the small

484
00:27:12,365 --> 00:27:13,506
amount that we needed.

485
00:27:14,086 --> 00:27:16,728
And it turned out to also be much more efficient, because

486
00:27:16,748 --> 00:27:19,251
we didn't have to do the conversion to HSV and back

487
00:27:19,271 --> 00:27:19,431
again.

488
00:27:25,995 --> 00:27:28,236
So we had to keep the randomization

489
00:27:28,296 --> 00:27:29,477
that was happening to each stroke

490
00:27:30,097 --> 00:27:31,298
constant from frame to frame.

491
00:27:31,358 --> 00:27:33,519
Otherwise, the stroke would keep changing color.

492
00:27:34,400 --> 00:27:37,502
And the only constant set of information

493
00:27:37,542 --> 00:27:39,723
I had for the stroke was actually its index.

494
00:27:40,364 --> 00:27:41,845
So I wrote this function you see here

495
00:27:41,905 --> 00:27:45,787
where I get a, like, a sort of randomized, like,

496
00:27:46,808 --> 00:27:50,970
value out that is then used to apply all of these offsets.

497
00:27:55,324 --> 00:27:57,986
So this is some of my favorite features.

498
00:27:58,987 --> 00:28:03,831
We can actually handle particles in two different ways.

499
00:28:04,412 --> 00:28:09,616
So one is just using an alpha cutout standard particle

500
00:28:09,636 --> 00:28:11,338
shader that writes into the brush buffer.

501
00:28:12,158 --> 00:28:14,040
The good thing about this is that it's a workflow

502
00:28:14,060 --> 00:28:15,241
that the artists are familiar with.

503
00:28:15,521 --> 00:28:17,223
And it also allows the strokes to be lit.

504
00:28:17,803 --> 00:28:19,765
So you can see we're using that for fire quite a lot.

505
00:28:21,176 --> 00:28:23,918
We can also inject shuriken particles,

506
00:28:24,518 --> 00:28:26,720
Unity's particle system, directly into the effect.

507
00:28:26,960 --> 00:28:28,561
So they appear as brush strokes.

508
00:28:29,782 --> 00:28:31,323
And I thought, personally, we were

509
00:28:31,343 --> 00:28:34,245
going to use this everywhere because it's damn cool.

510
00:28:34,545 --> 00:28:40,590
But unfortunately, in the Unity's deferred renderer,

511
00:28:40,690 --> 00:28:42,471
you can't actually access the lighting data.

512
00:28:44,660 --> 00:28:47,442
They required a lot of artist tweaking

513
00:28:47,502 --> 00:28:49,344
in order to sit well with the scene.

514
00:28:49,404 --> 00:28:52,987
So then we only used them in very rare circumstances.

515
00:28:53,067 --> 00:28:54,349
And most of the time we ended up using

516
00:28:54,429 --> 00:28:55,850
the alpha color particles instead.

517
00:28:57,772 --> 00:29:00,955
They were also kind of a pain in the butt to implement

518
00:29:01,015 --> 00:29:03,297
because there was a lot of unique rules for them

519
00:29:03,337 --> 00:29:06,159
because they wouldn't get that color from the scene.

520
00:29:06,580 --> 00:29:08,882
So for example, having them work with

521
00:29:10,200 --> 00:29:11,760
meant that I had to take that equation

522
00:29:11,800 --> 00:29:13,721
and actually put it into the injection code

523
00:29:13,961 --> 00:29:15,642
or, like, the injection compute kernel.

524
00:29:16,442 --> 00:29:17,462
And also, um,

525
00:29:18,683 --> 00:29:19,903
it's why we had to split up

526
00:29:20,423 --> 00:29:21,764
our post-processing, so some of it

527
00:29:21,784 --> 00:29:23,204
would happen before the pencil effect

528
00:29:23,244 --> 00:29:24,665
and some of it would happen afterwards,

529
00:29:25,705 --> 00:29:27,066
which incurred a performance cost.

530
00:29:28,586 --> 00:29:28,706
Um...

531
00:29:31,067 --> 00:29:31,247
Yeah.

532
00:29:31,727 --> 00:29:33,168
So, good idea.

533
00:29:34,008 --> 00:29:35,729
Could have, um, been better

534
00:29:35,749 --> 00:29:37,629
if we had, uh, uh,

535
00:29:38,029 --> 00:29:38,790
more data available.

536
00:29:42,217 --> 00:29:42,457
All right.

537
00:29:43,398 --> 00:29:45,341
So how many of you are graphics programmers?

538
00:29:45,361 --> 00:29:48,504
A fair amount.

539
00:29:48,544 --> 00:29:49,665
OK, how many of you are artists?

540
00:29:51,267 --> 00:29:51,988
Also a fair amount.

541
00:29:52,068 --> 00:29:52,288
OK.

542
00:29:53,449 --> 00:29:55,171
If you've ever been part of a production, maybe you can

543
00:29:55,511 --> 00:29:56,072
recognize this.

544
00:30:02,159 --> 00:30:06,821
I will say at times it was kind of stressful.

545
00:30:08,001 --> 00:30:11,703
So we thankfully had some pre-production on the game.

546
00:30:11,743 --> 00:30:15,064
And I think that is what really allowed us to achieve

547
00:30:15,084 --> 00:30:17,545
the look we had in the end.

548
00:30:18,686 --> 00:30:20,927
At the start, it was only me and the art director.

549
00:30:20,947 --> 00:30:23,908
So I had all the, I could focus completely

550
00:30:23,968 --> 00:30:25,769
on just trying out various things

551
00:30:25,789 --> 00:30:27,049
and get something he was happy with.

552
00:30:28,714 --> 00:30:42,226
But I also think it's like a lot of the reason why we ended up with something that worked is that I was constantly in dialogue with the artists about like, well, how should we get this pipeline to do the things that you guys needed to do.

553
00:30:42,246 --> 00:30:56,298
I would also say the artists were like really nimble to adapt to how it worked because it's as you're going to see now it's quite weird workflow and it was definitely something that none of us have tried to do before.

554
00:30:58,633 --> 00:31:00,774
So the artists have three levels of control.

555
00:31:01,355 --> 00:31:06,197
They have globally on the camera, where they can adjust

556
00:31:07,297 --> 00:31:10,539
variables such as the maximum and the minimum brush size,

557
00:31:10,919 --> 00:31:13,440
and how long the brush stroke should live, and so on.

558
00:31:14,412 --> 00:31:21,237
Then they can also go in and adjust it on a per material basis with overrides for brush

559
00:31:21,277 --> 00:31:23,559
type, brush size, and so on.

560
00:31:24,159 --> 00:31:29,323
And finally, there's also on text level a texture that in format resembles very much

561
00:31:29,343 --> 00:31:37,069
what's in the brush buffer where they can go and have the maximum amount of control.

562
00:31:41,292 --> 00:31:42,433
So we used Substance.

563
00:31:43,848 --> 00:31:45,749
for most of our texturing work.

564
00:31:46,229 --> 00:31:48,390
And it has a lot of advantages.

565
00:31:48,450 --> 00:31:49,570
You can reuse graphs.

566
00:31:50,211 --> 00:31:52,452
So if you create a base wood material,

567
00:31:52,492 --> 00:31:55,773
you can reuse that to create a lot of variations very quickly.

568
00:31:55,793 --> 00:31:59,135
It also allows live editing.

569
00:31:59,195 --> 00:32:01,296
And I think this is what was actually

570
00:32:01,316 --> 00:32:02,296
the most beneficial for us.

571
00:32:03,987 --> 00:32:07,189
like I I was the only graphics program on this project so I

572
00:32:07,229 --> 00:32:10,330
didn't have time to do some kind of like custom solutions so

573
00:32:10,790 --> 00:32:13,392
they could actually see how the models would look like in the

574
00:32:13,432 --> 00:32:15,793
treaty modeling tool so they always had to take them into

575
00:32:16,273 --> 00:32:19,935
unity to see the end results and if we hadn't had this

576
00:32:19,975 --> 00:32:23,357
light like like live editing it would have taken so much

577
00:32:23,397 --> 00:32:23,677
longer.

578
00:32:26,358 --> 00:32:27,499
I have an example of that.

579
00:32:33,238 --> 00:32:38,199
So, what you see here is a substance material being edited in real time,

580
00:32:38,259 --> 00:32:43,621
and you can see that getting all these variables of like what directions are the strokes going in,

581
00:32:43,661 --> 00:32:46,982
and how big are they, and like how much boil do we have on them,

582
00:32:47,862 --> 00:32:51,903
like not having these exposed so you could like play around with it,

583
00:32:51,943 --> 00:32:54,924
would have taken a lot longer time to find settings that works.

584
00:32:59,486 --> 00:33:01,768
There was also a lot of problems with them.

585
00:33:02,308 --> 00:33:08,152
This is mainly due to the version of Substance Integration

586
00:33:08,172 --> 00:33:09,053
that we had to work with.

587
00:33:10,054 --> 00:33:14,517
We had very long bake times, and it often broke on console builds.

588
00:33:15,058 --> 00:33:17,199
It would also sometimes crash the Unity editor

589
00:33:17,239 --> 00:33:18,180
when we imported them.

590
00:33:19,040 --> 00:33:22,243
And it actually, and then we had to.

591
00:33:24,314 --> 00:33:31,159
Like our tools program had to spend a lot of time on developing this tool that would allow us to switch between substances and

592
00:33:31,679 --> 00:33:33,000
baked out materials

593
00:33:34,321 --> 00:33:34,642
for this

594
00:33:36,143 --> 00:33:38,825
for to allow us to actually ship the game, so

595
00:33:39,645 --> 00:33:44,269
Thankfully, there's like a new integration on its way, so hopefully that should

596
00:33:45,130 --> 00:33:46,891
Completely remove all of these problems

597
00:33:50,474 --> 00:33:51,274
There was also like some

598
00:33:52,902 --> 00:33:54,342
guidelines for creating good textures.

599
00:33:55,703 --> 00:33:59,024
If we did something that was approaching real life,

600
00:33:59,484 --> 00:34:00,844
you have something that's very noisy.

601
00:34:01,165 --> 00:34:04,706
And that noise causes the brush strokes

602
00:34:04,726 --> 00:34:05,826
to change color very quickly.

603
00:34:05,886 --> 00:34:06,987
So you get something that flickers.

604
00:34:08,007 --> 00:34:10,008
But on the other hand, if you just blur all the textures,

605
00:34:10,028 --> 00:34:11,268
you end up with something that doesn't really

606
00:34:11,348 --> 00:34:12,208
have any definition.

607
00:34:12,308 --> 00:34:14,089
And the image ends up looking really flat.

608
00:34:15,109 --> 00:34:17,830
So having something where you get

609
00:34:17,870 --> 00:34:20,611
this kind of like a posterized look turned out to be the best.

610
00:34:21,737 --> 00:34:24,060
and having a bit of like smooth gradients also helped.

611
00:34:25,422 --> 00:34:27,886
We would also exaggerate the main form slightly

612
00:34:27,946 --> 00:34:30,851
so they would read better underneath the effect.

613
00:34:31,933 --> 00:34:35,017
And this is kind of like the same principles

614
00:34:35,057 --> 00:34:36,740
that would be used for modeling as well.

615
00:34:41,123 --> 00:34:44,145
As it came into flavors, we would have hero assets such as

616
00:34:44,205 --> 00:34:47,488
characters and assets that were used often.

617
00:34:48,008 --> 00:34:51,952
They would be hand painted in Substance Painter, whereas the

618
00:34:51,992 --> 00:34:57,156
rest would use substances from Substance Designer.

619
00:34:57,796 --> 00:34:59,978
And the good thing about those is that the only thing we

620
00:34:59,998 --> 00:35:03,501
needed to do was to do a correct UV unwrap, and the

621
00:35:03,601 --> 00:35:04,201
model would be done.

622
00:35:07,444 --> 00:35:09,005
So four characters.

623
00:35:10,199 --> 00:35:11,680
and other hero assets.

624
00:35:13,001 --> 00:35:14,442
This is the process.

625
00:35:15,222 --> 00:35:22,107
We would do the same texture method that you saw earlier.

626
00:35:22,507 --> 00:35:25,009
But we would also paint in extra highlights and shadows

627
00:35:25,149 --> 00:35:30,213
into the albedo map to kind of make the characters pop even

628
00:35:30,233 --> 00:35:32,435
more underneath, below the effect.

629
00:35:35,517 --> 00:35:35,657
So.

630
00:35:37,588 --> 00:35:41,469
painting the like hero assets, like as you saw earlier,

631
00:35:41,489 --> 00:35:45,190
the format for the brush map buffer

632
00:35:45,250 --> 00:35:46,690
is that's not artist friendly.

633
00:35:47,410 --> 00:35:49,591
So in Substance Painter, the artist

634
00:35:49,611 --> 00:35:53,952
would paint into these custom defined channels that

635
00:35:53,992 --> 00:35:58,733
would control each aspect of the brush stroke.

636
00:35:59,754 --> 00:36:01,854
And when we then imported it into Unity,

637
00:36:02,334 --> 00:36:06,095
a custom editor script would.

638
00:36:06,616 --> 00:36:12,178
then take all of that information and crunch it down into the texture format that the pencil

639
00:36:12,218 --> 00:36:20,021
effect was expecting. Specifically for characters, we found that

640
00:36:20,041 --> 00:36:27,064
we actually needed them to pop a lot more. So we wrote this.

641
00:36:28,944 --> 00:36:33,126
uh... kinda like highlight shader so it is it is uh... it is a a normal rim light

642
00:36:33,166 --> 00:36:36,608
but it actually takes the lighting in the scene into account so it's just uh...

643
00:36:36,648 --> 00:36:36,848
so it

644
00:36:37,188 --> 00:36:38,689
so the character sits more with the scene

645
00:36:39,109 --> 00:36:40,750
but you still get like uh... them

646
00:36:41,191 --> 00:36:42,711
standing out more from uh...

647
00:36:43,192 --> 00:36:43,692
from the

648
00:36:44,072 --> 00:36:45,453
background and objects around them

649
00:36:46,534 --> 00:36:47,394
which worked really well

650
00:36:51,656 --> 00:36:56,159
I think I'm doing well for time, that's good.

651
00:36:57,582 --> 00:37:02,483
Okay, so, um, this was the first project

652
00:37:02,523 --> 00:37:03,743
where I was a graphics programmer,

653
00:37:04,484 --> 00:37:07,785
and I think for more experienced graphics programmers,

654
00:37:07,825 --> 00:37:12,646
a lot of this advice is gonna see kind of, like, basic,

655
00:37:13,746 --> 00:37:15,747
but in my experience, it's actually kind of hard

656
00:37:15,767 --> 00:37:19,668
to find this stuff online and find tutorials on it,

657
00:37:20,449 --> 00:37:23,089
so I hope it's gonna be beneficial for people out there

658
00:37:23,109 --> 00:37:25,950
that there's a place where they can actually learn about this.

659
00:37:28,438 --> 00:37:33,120
So performance target-wise, we looked at GCN as our main

660
00:37:33,540 --> 00:37:35,821
architecture to optimize for, because it's the one used on

661
00:37:35,881 --> 00:37:37,002
PlayStation 4 and Xbox.

662
00:37:37,702 --> 00:37:41,964
We targeted full HP on PlayStation 4 and 90p on Xbox.

663
00:37:42,964 --> 00:37:45,565
And yeah, I would advise you don't give everyone on the

664
00:37:45,585 --> 00:37:49,567
team a 1080 graphics card, because you're sitting there.

665
00:37:49,807 --> 00:37:52,208
I was sitting there as the only graphics programmer being

666
00:37:52,228 --> 00:37:54,709
like, oh, we should probably start optimizing.

667
00:37:54,989 --> 00:37:56,489
And yeah.

668
00:37:57,926 --> 00:38:00,068
It's, we had to, to get, um,

669
00:38:00,589 --> 00:38:01,730
about halfway through development

670
00:38:01,770 --> 00:38:04,093
before we started to really, um,

671
00:38:04,233 --> 00:38:05,595
take this into, into account.

672
00:38:05,995 --> 00:38:06,156
Um...

673
00:38:08,779 --> 00:38:12,103
So for, uh, optimization and for profiling,

674
00:38:12,143 --> 00:38:13,885
I used, uh, GPU eraser quite a lot.

675
00:38:15,183 --> 00:38:17,244
There's other tools out there, but I really like the way

676
00:38:17,284 --> 00:38:18,725
that it's presented.

677
00:38:19,205 --> 00:38:21,626
I think Sony does a really good job with their tools.

678
00:38:21,926 --> 00:38:23,647
They're easy to read.

679
00:38:24,547 --> 00:38:29,129
And not surprisingly, we found out that the main thing that

680
00:38:29,169 --> 00:38:31,570
had to be optimized was to render kernel, because in a

681
00:38:31,610 --> 00:38:38,092
standard HD resolution, you have around 2 million pixels.

682
00:38:38,892 --> 00:38:41,293
And for a given frame, we would have around 30,000

683
00:38:41,333 --> 00:38:41,694
strokes.

684
00:38:41,834 --> 00:38:41,974
There.

685
00:38:44,775 --> 00:38:46,898
kernel creating the strokes and updating the strokes,

686
00:38:47,659 --> 00:38:50,022
they were quite, like really cheap.

687
00:38:50,102 --> 00:38:51,544
Like, that wasn't the worry.

688
00:38:51,584 --> 00:38:53,747
And it also meant that I didn't have to worry

689
00:38:53,767 --> 00:38:54,809
about putting in new features

690
00:38:54,869 --> 00:38:56,992
into that part of the pipeline that much.

691
00:38:57,372 --> 00:38:58,854
But anything that affected the rendering

692
00:38:59,215 --> 00:39:01,338
had to be considered quite carefully.

693
00:39:07,964 --> 00:39:12,386
So something that's quite easy to stumble into

694
00:39:12,546 --> 00:39:14,667
when you're using Unity is that you're gonna, uh,

695
00:39:15,107 --> 00:39:18,008
coupling your render thread to the main thread.

696
00:39:18,609 --> 00:39:21,190
And what this means is that you're not gonna be able

697
00:39:21,230 --> 00:39:25,732
to have your render thread, like, process the last frame

698
00:39:25,792 --> 00:39:28,053
while you are doing the logic for the current one.

699
00:39:28,873 --> 00:39:28,973
And...

700
00:39:30,377 --> 00:39:34,302
It's a lot of it. This is not really that well documented at the moment.

701
00:39:35,543 --> 00:39:41,130
For example, if you use any of the methods in the graphics class,

702
00:39:41,150 --> 00:39:45,074
you're likely going to cause this coupling.

703
00:39:45,775 --> 00:39:48,679
And the solution to that is actually to use command buffers.

704
00:39:49,710 --> 00:39:52,432
which is not really explained in the documentation either.

705
00:39:52,492 --> 00:39:55,173
It's presented as a way to extend the graphics pipeline,

706
00:39:55,213 --> 00:39:55,754
which is true.

707
00:39:56,134 --> 00:39:58,876
But if you use them, you're also making sure that all the

708
00:39:58,896 --> 00:40:01,458
commands are executed on the render thread.

709
00:40:06,841 --> 00:40:07,021
So.

710
00:40:08,343 --> 00:40:10,403
Scriptable Render Pipelines was released,

711
00:40:10,943 --> 00:40:13,124
or like, was starting to get previewed

712
00:40:13,184 --> 00:40:14,784
during the production of 11.11.

713
00:40:16,025 --> 00:40:17,585
And I wish we could have switched over to it,

714
00:40:17,645 --> 00:40:20,166
but, I mean, it was still an experimental feature.

715
00:40:21,466 --> 00:40:24,767
So, originally, we were generating

716
00:40:24,807 --> 00:40:26,987
the BrushMapBuffer with replacement shaders.

717
00:40:27,728 --> 00:40:28,408
And they are...

718
00:40:29,593 --> 00:40:36,342
terrible. They basically causes the camera to call again and you end up with more draw

719
00:40:36,382 --> 00:40:40,407
calls and you also end up causing coupling with the main thread. So...

720
00:40:41,516 --> 00:40:44,999
With scriptable render pipelines, it would likely have been easier to fix this

721
00:40:45,340 --> 00:40:48,442
because I would have all the calling results readily available.

722
00:40:49,063 --> 00:40:51,866
But I was stuck with the deferred renderer,

723
00:40:51,926 --> 00:40:56,690
and I was also stuck with a non-source code version of Unity.

724
00:40:57,210 --> 00:40:58,632
So there was...

725
00:40:59,753 --> 00:41:03,576
Yeah, I had to be quite creative with how I went about solving this.

726
00:41:07,793 --> 00:41:12,816
So what I did is that I stole a buffer in the G-buffer.

727
00:41:13,256 --> 00:41:16,738
So normally, Unity stores the specular value

728
00:41:17,198 --> 00:41:17,958
completely separate.

729
00:41:18,378 --> 00:41:21,020
But that's actually only constructed from a specular

730
00:41:21,060 --> 00:41:25,862
value, or a specularity value, and the albedo color.

731
00:41:26,402 --> 00:41:29,623
So by using an unused channel to store the specularity, I

732
00:41:29,663 --> 00:41:30,424
freed up a whole.

733
00:41:31,858 --> 00:41:34,480
a whole buffer where I could store all the information that I needed.

734
00:41:35,141 --> 00:41:38,243
It did mean that all the lighting equations got more expensive

735
00:41:38,303 --> 00:41:40,084
because that color just wasn't readily available.

736
00:41:40,124 --> 00:41:41,885
You had to recreate it for every light.

737
00:41:42,486 --> 00:41:45,868
But in the end, we didn't have that many lights in the game anyways

738
00:41:45,928 --> 00:41:49,250
because we were concerned about having as much performance

739
00:41:49,831 --> 00:41:52,052
reserved for the painstaking effect anyways.

740
00:41:52,172 --> 00:41:53,553
So this turned out to not be an issue.

741
00:41:54,800 --> 00:41:57,281
But it didn't mean that all the deferred lighting

742
00:41:57,321 --> 00:41:58,282
shields had to be changed.

743
00:41:58,842 --> 00:42:02,543
Thankfully, that's something you can actually access in Unity

744
00:42:03,764 --> 00:42:05,124
quite easily, as you can see here.

745
00:42:05,325 --> 00:42:07,105
So it turned out to be easy.

746
00:42:08,326 --> 00:42:11,007
What was not so easy is that Unity

747
00:42:11,047 --> 00:42:14,828
has a system for generating.

748
00:42:16,275 --> 00:42:21,498
shaders that work with both the deferred and forward render pipeline and all the lighting

749
00:42:21,778 --> 00:42:27,600
that goes on there. But of course, they would be expecting the normal deferred color layout

750
00:42:27,680 --> 00:42:32,242
or like buffer layout. So in order to fix that, I wrote this like

751
00:42:33,250 --> 00:42:35,431
kind of dumb find and replace tool.

752
00:42:35,891 --> 00:42:40,893
So I could go through the generated shader code

753
00:42:41,033 --> 00:42:44,675
and replace it, but it was not a great workflow

754
00:42:44,715 --> 00:42:46,756
because I had to hit a button on.

755
00:42:48,274 --> 00:42:52,096
on the shader, you can actually access the generated code

756
00:42:52,636 --> 00:42:53,637
like through scripting.

757
00:42:53,917 --> 00:42:57,099
So I would always have to go in and hit a button

758
00:42:57,119 --> 00:42:59,761
to show the generated code, copy it over into a separate file,

759
00:42:59,801 --> 00:43:03,523
and then run the patching system on that separate file.

760
00:43:04,444 --> 00:43:06,605
So yeah, it wasn't fun.

761
00:43:11,568 --> 00:43:13,229
Some objects would be forward rendered.

762
00:43:14,471 --> 00:43:17,612
So if we have something like a special effect shader

763
00:43:17,732 --> 00:43:20,012
that we're used in certain sequences,

764
00:43:20,092 --> 00:43:22,433
they have their own, like, lighting going on,

765
00:43:23,093 --> 00:43:26,074
so they can be rendered as part of the regular deferred pass.

766
00:43:27,254 --> 00:43:29,495
And this also meant that they would have to be rendered

767
00:43:29,555 --> 00:43:31,715
into the brush buffer separately.

768
00:43:33,015 --> 00:43:34,796
The way that we would do this is that the artist

769
00:43:34,816 --> 00:43:36,216
would add a script to the object

770
00:43:36,336 --> 00:43:39,937
and instruct what materials should be used.

771
00:43:41,642 --> 00:43:42,922
or should be rendered that way.

772
00:43:43,602 --> 00:43:47,024
And the effect would then generate a separate command

773
00:43:47,044 --> 00:43:52,285
buffer that would run after the deferred pass was done.

774
00:43:52,686 --> 00:43:54,726
And that way, we would get that information

775
00:43:54,766 --> 00:43:56,287
into the brush buffer.

776
00:43:58,848 --> 00:44:02,269
This also meant that I had to inject a special shader pass

777
00:44:02,829 --> 00:44:05,870
into the shaders, which was also taken care of by the

778
00:44:05,950 --> 00:44:06,951
patching system you just saw.

779
00:44:10,389 --> 00:44:11,331
All right, draw calls.

780
00:44:12,393 --> 00:44:16,644
So most games I've been on, draw calls in Unity

781
00:44:17,004 --> 00:44:19,170
is like something you really have to look out for.

782
00:44:20,454 --> 00:44:23,956
And there are more and more tricks you can use to reduce them.

783
00:44:24,116 --> 00:44:28,598
So a fairly new thing is that you can use layer call distances on the camera

784
00:44:28,878 --> 00:44:32,619
to basically say, well, if you know that something is quite small,

785
00:44:33,399 --> 00:44:38,181
you can call it out at a shorter distance

786
00:44:38,201 --> 00:44:41,303
than the far clip plane of the camera.

787
00:44:43,080 --> 00:44:45,401
We would also combine meshes when necessary.

788
00:44:46,162 --> 00:44:50,265
And Unity's static batching is quite temperamental, so it

789
00:44:50,285 --> 00:44:53,787
also took our artists a lot of diligence and experimentation

790
00:44:53,807 --> 00:44:56,109
to make sure that we had everything batching as much as

791
00:44:56,489 --> 00:44:56,829
possible.

792
00:44:58,490 --> 00:45:03,714
So occlusion calling is also something that sometimes led

793
00:45:03,734 --> 00:45:05,535
to better performance, sometimes not.

794
00:45:05,575 --> 00:45:08,417
So we would test it on a level-by-level basis if we

795
00:45:08,637 --> 00:45:09,818
should have that enabled.

796
00:45:14,597 --> 00:45:18,418
So data packing is a pretty cool technique.

797
00:45:19,519 --> 00:45:23,861
What this allows is that you can fit more information

798
00:45:23,921 --> 00:45:25,261
into less space.

799
00:45:25,482 --> 00:45:30,664
In our case, we used it for fitting more strokes into LDS.

800
00:45:30,804 --> 00:45:34,086
And we also reduced the amount of VRAM

801
00:45:34,126 --> 00:45:36,927
that the effect required, which was basically

802
00:45:36,947 --> 00:45:40,408
freed up texture space for the rest of the rendering.

803
00:45:43,787 --> 00:45:46,991
So it can also increase performance

804
00:45:47,052 --> 00:45:51,037
because you have less data that has to be loaded from VRAM.

805
00:45:51,057 --> 00:45:51,657
So there's like less.

806
00:45:53,160 --> 00:45:54,481
data that has to be transferred over.

807
00:45:55,082 --> 00:45:56,703
It does increase ALU pressure.

808
00:45:57,263 --> 00:46:00,686
So it's easy to make sure that you actually test to see if

809
00:46:00,726 --> 00:46:04,609
this is actually going to be more performance than not

810
00:46:04,649 --> 00:46:05,049
having it in.

811
00:46:05,809 --> 00:46:07,771
The good thing is that it's very easy to implement,

812
00:46:07,811 --> 00:46:10,873
because you're only looking at the spots in your code where

813
00:46:10,933 --> 00:46:13,215
you are reading and writing your data out.

814
00:46:13,275 --> 00:46:16,217
So it's something that's not going to have repercussions

815
00:46:16,297 --> 00:46:17,277
for the rest of your logic.

816
00:46:18,191 --> 00:46:23,473
And HLSL supplies F16 to FD2 and reverse.

817
00:46:23,533 --> 00:46:26,434
That allows you to do this packing of two

818
00:46:26,494 --> 00:46:27,594
floats into one float.

819
00:46:30,175 --> 00:46:32,316
But of course, the lack of precision can be an issue.

820
00:46:32,396 --> 00:46:34,977
So there was some of the information, such as the

821
00:46:35,017 --> 00:46:36,338
precision, where we just couldn't use this.

822
00:46:40,762 --> 00:46:44,685
For optimizing ALU and VGPR usage,

823
00:46:45,586 --> 00:46:50,271
I used these two talks from Emil Pearson, aka Humus.

824
00:46:51,392 --> 00:46:52,093
They're really good.

825
00:46:52,433 --> 00:46:55,396
It's like super concrete and easy to use advice.

826
00:46:57,640 --> 00:46:59,940
In our specific case, using ISP,

827
00:47:00,100 --> 00:47:02,701
which is an approximation of division,

828
00:47:03,481 --> 00:47:05,881
turned out to be really beneficial in a lot of cases.

829
00:47:06,902 --> 00:47:12,163
SYNCOS is also a lot more efficient

830
00:47:12,183 --> 00:47:14,903
than doing SYN and COS separately.

831
00:47:15,344 --> 00:47:18,084
All of these are HLSL intrinsic functions

832
00:47:18,124 --> 00:47:19,184
that are readily available.

833
00:47:20,978 --> 00:47:24,260
I also found that pre-computing part of the intersection math,

834
00:47:24,880 --> 00:47:27,061
and then have that available in a constant buffer,

835
00:47:27,921 --> 00:47:28,722
led to a nice speedup.

836
00:47:29,963 --> 00:47:33,004
And we would also pre-compute the aspect

837
00:47:33,264 --> 00:47:34,585
and inverse aspect radio

838
00:47:36,706 --> 00:47:39,107
for use in other parts of the pipeline.

839
00:47:41,288 --> 00:47:44,150
And this is the aspect radio of the brush strokes.

840
00:47:49,373 --> 00:47:49,493
So...

841
00:47:50,225 --> 00:47:55,670
A nice feature in Unity is that you can actually see the generated bytecode by just finding

842
00:47:55,690 --> 00:47:58,472
the shader in the editor and clicking this button.

843
00:47:59,252 --> 00:48:04,076
And what that allows you to do is to compare if changes to your shader is actually going

844
00:48:04,096 --> 00:48:10,121
to change the amount of instructions that you generate, which, when it takes, like,

845
00:48:10,201 --> 00:48:14,024
maybe 20 minutes to do a build, this can very quickly add up to a lot of time gained.

846
00:48:19,892 --> 00:48:23,834
Something you can also do on some platforms is to use

847
00:48:23,914 --> 00:48:30,019
platform-specific defines to basically nudge the compiler

848
00:48:31,159 --> 00:48:33,161
to optimize your shader in different ways.

849
00:48:34,101 --> 00:48:40,226
It's not available on everything, but yeah, for the

850
00:48:40,266 --> 00:48:42,147
consoles, that can be a benefit as well.

851
00:48:47,364 --> 00:48:51,636
So when you're starting out learning compute shaders,

852
00:48:51,796 --> 00:48:53,501
quite often people will use structs.

853
00:48:57,468 --> 00:48:58,729
It's, they're terrible.

854
00:49:00,070 --> 00:49:04,473
Um, it's way better to use, uh, a structure of arrays

855
00:49:04,513 --> 00:49:06,075
instead of an array of structs.

856
00:49:06,395 --> 00:49:07,836
And the reason for that is that, um,

857
00:49:08,296 --> 00:49:09,457
you get better cache coherency,

858
00:49:09,878 --> 00:49:13,901
and each kernel can load in the data it, uh, it needs itself.

859
00:49:14,381 --> 00:49:16,183
Like, for example, for all the calling that we do,

860
00:49:16,683 --> 00:49:18,745
we don't need the color of the brush strokes,

861
00:49:18,765 --> 00:49:21,187
so there's no reason to have that, uh, sticking around.

862
00:49:22,448 --> 00:49:24,009
Um, and...

863
00:49:26,132 --> 00:49:29,474
I, this is a guess, and maybe someone in the audience will know this, but I also think

864
00:49:29,515 --> 00:49:35,759
that the compiler can rearrange the code so ALU instructions can happen while memory fetches

865
00:49:36,059 --> 00:49:42,603
are also being done. And if it's done as, as like one big fetch of, of a struct, I think

866
00:49:42,643 --> 00:49:46,125
that's a lot harder for the compiler to, to schedule.

867
00:49:50,548 --> 00:49:54,811
So what you're seeing here is the debug view that I use the most, and.

868
00:49:56,110 --> 00:50:00,113
This is the content of each calling tile.

869
00:50:00,213 --> 00:50:02,676
So if you see a pixel in there, that

870
00:50:02,716 --> 00:50:06,139
is because a brush stroke has been determined

871
00:50:06,159 --> 00:50:07,941
to be inside that calling tile.

872
00:50:09,702 --> 00:50:14,166
And something that's worked really well

873
00:50:14,226 --> 00:50:17,029
in terms of optimizing the effect without like a.

874
00:50:17,693 --> 00:50:23,696
visual loss of quality was to actually look at how many strokes are inside the culling

875
00:50:23,736 --> 00:50:30,299
tile and then feed that back into the generation kernel. So if the tile was starting to fill

876
00:50:30,379 --> 00:50:34,161
up, the probability of new strokes spawning would be reduced.

877
00:50:37,262 --> 00:50:39,683
So what's going on with all the green and blue colors?

878
00:50:41,112 --> 00:50:44,495
Well, it's quite often that a stroke will not cover

879
00:50:44,916 --> 00:50:48,399
all the pixels in a 32 by 32 tile.

880
00:50:49,560 --> 00:50:55,686
So that basically means that you end up

881
00:50:55,906 --> 00:50:57,948
with a lot of the threads not doing anything.

882
00:50:58,889 --> 00:51:02,332
And on GCN, 8 by 8 pixels is actually

883
00:51:02,352 --> 00:51:06,556
the optimal size for a work group.

884
00:51:08,031 --> 00:51:11,053
But that puts a lot of limitations on how much you can

885
00:51:11,093 --> 00:51:13,575
actually fit into your local data share.

886
00:51:21,540 --> 00:51:21,741
Yeah.

887
00:51:22,401 --> 00:51:26,484
So you might think, OK, can we reduce the size of the

888
00:51:26,564 --> 00:51:27,124
calling tiles?

889
00:51:27,385 --> 00:51:32,228
And unfortunately, testing showed that if they're smaller

890
00:51:32,268 --> 00:51:35,450
than 32 by 32 pixels, they started being slower.

891
00:51:35,510 --> 00:51:36,831
So what I did instead.

892
00:51:38,027 --> 00:51:40,971
is that I would keep the calling, the fine calling,

893
00:51:41,251 --> 00:51:42,532
at 32 pixels,

894
00:51:43,474 --> 00:51:46,317
but I would then actually run

895
00:51:47,778 --> 00:51:50,562
three different render kernels after each other,

896
00:51:51,062 --> 00:51:54,606
each optimized for a different amount of strokes

897
00:51:54,766 --> 00:51:55,567
in that calling tile.

898
00:51:56,394 --> 00:52:01,755
And I did this first as like a quick test to see if the approach would work out.

899
00:52:01,795 --> 00:52:04,556
I thought I would have to do some kind of like quick, clever scheduling.

900
00:52:05,097 --> 00:52:07,157
But it turns out it was actually like really, really fast.

901
00:52:07,618 --> 00:52:08,838
So what happens is that the

902
00:52:11,960 --> 00:52:15,562
The render kernel that's optimized for 8x8 pixels

903
00:52:15,622 --> 00:52:19,684
will look at how many strokes are in the tile.

904
00:52:19,764 --> 00:52:21,145
And if it's not fitting the amount

905
00:52:21,245 --> 00:52:23,926
that it can fit into LDS, it will early out.

906
00:52:24,346 --> 00:52:27,428
And because all the threads in the work group are earlying out,

907
00:52:28,609 --> 00:52:29,769
it's very quick to do this.

908
00:52:30,430 --> 00:52:35,732
So on average, executing a render kernel that

909
00:52:35,752 --> 00:52:37,213
wouldn't actually affect anything in the image

910
00:52:37,233 --> 00:52:39,534
would only take 90 microseconds.

911
00:52:40,471 --> 00:52:43,033
And I thought this was going to be like a golden,

912
00:52:43,153 --> 00:52:45,214
or like, I guess it's a silver bullet.

913
00:52:45,234 --> 00:52:47,776
Yeah, a silver bullet to performance.

914
00:52:47,816 --> 00:52:52,198
But it turns out it was only a 0.7 millisecond gain

915
00:52:52,238 --> 00:52:52,779
we had from it.

916
00:52:52,799 --> 00:52:54,460
But that's still nice.

917
00:53:02,845 --> 00:53:06,267
All right, so now I'm going to talk a bit about future

918
00:53:06,287 --> 00:53:07,988
improvements and a conclusion.

919
00:53:10,297 --> 00:53:19,379
So, one drawback of using substances is that they wouldn't take the topology of an object

920
00:53:19,439 --> 00:53:20,040
into account.

921
00:53:20,060 --> 00:53:26,782
So, for example, these floorboards you see here, you would actually need smaller strokes

922
00:53:27,122 --> 00:53:30,343
on the thinner sides of the boards than on the rest of them.

923
00:53:33,142 --> 00:53:36,665
In order to allow the artist to fix this,

924
00:53:37,686 --> 00:53:42,671
I actually had time to put in vertex painting of brush sizes

925
00:53:43,391 --> 00:53:44,793
into the whole pipeline.

926
00:53:45,233 --> 00:53:47,615
But it came online so late, so we didn't end up

927
00:53:47,755 --> 00:53:48,416
using it in the end.

928
00:53:54,061 --> 00:53:56,623
Unity is doing a lot of amazing things at the moment.

929
00:53:57,404 --> 00:54:00,046
Scripted Render Pipelines is one of them.

930
00:54:01,170 --> 00:54:03,411
And if we had had access to that,

931
00:54:04,032 --> 00:54:05,893
it would have helped with a lot of issues.

932
00:54:08,434 --> 00:54:10,875
We could have had lit injected strokes

933
00:54:11,095 --> 00:54:14,016
because in the high-definition render pipeline,

934
00:54:14,076 --> 00:54:15,957
all of that information is readily available.

935
00:54:16,578 --> 00:54:19,039
I guess it will be available in the lightweight one as well.

936
00:54:20,059 --> 00:54:23,521
And the ability to create and bind buffers more freely

937
00:54:24,261 --> 00:54:26,522
would have meant that I would have a lot more, like,

938
00:54:26,562 --> 00:54:29,023
flexibility in what I would have been able to do.

939
00:54:30,277 --> 00:54:34,539
Um, something that we saw at the end of the project

940
00:54:34,599 --> 00:54:40,982
is because the brush stroke, uh, the brush sizes

941
00:54:41,022 --> 00:54:43,544
are in a single 8-bit channel,

942
00:54:43,584 --> 00:54:45,024
that means that it's a normalized value.

943
00:54:46,165 --> 00:54:49,147
And if we needed to go in and change the, uh...

944
00:54:50,730 --> 00:54:53,251
like make some big strokes, for example, in one scene,

945
00:54:53,271 --> 00:54:55,131
we would have to do that on the global level,

946
00:54:55,171 --> 00:54:58,812
which meant that all the materials had to be tweaked

947
00:54:58,852 --> 00:55:00,573
because it was all coupled together.

948
00:55:01,133 --> 00:55:03,814
So in the future, I would store all of this

949
00:55:03,874 --> 00:55:08,475
in a 16-bit half-precision value instead

950
00:55:08,515 --> 00:55:11,956
so you don't have that coupling between all the brush sizes.

951
00:55:13,176 --> 00:55:16,637
That would have saved our lead artist a lot of time in the end.

952
00:55:22,563 --> 00:55:25,506
So nowadays you have to make sure that you're game is easy

953
00:55:25,547 --> 00:55:25,987
to share.

954
00:55:26,908 --> 00:55:32,675
And we found that YouTube compression was very tough on

955
00:55:32,695 --> 00:55:33,136
the effect.

956
00:55:33,856 --> 00:55:37,541
It took us a couple of tries in recording footage for

957
00:55:37,581 --> 00:55:40,725
trailers before we really got a hang of it.

958
00:55:41,626 --> 00:55:43,007
And it's.

959
00:55:44,028 --> 00:55:45,308
It's such a shame, right?

960
00:55:45,328 --> 00:55:47,689
Because when people actually see the game in real life,

961
00:55:47,709 --> 00:55:51,711
they can see the texture that you get

962
00:55:51,811 --> 00:55:55,352
from having the brush strokes there,

963
00:55:55,372 --> 00:55:57,073
whereas a lot of it is kind of like washed out

964
00:55:57,113 --> 00:55:58,593
if you're watching it on a phone.

965
00:56:01,654 --> 00:56:05,236
That said, I'm really proud of what we achieved.

966
00:56:05,596 --> 00:56:09,237
So what you're seeing here is a piece of concept art

967
00:56:09,717 --> 00:56:10,518
from early in development.

968
00:56:11,637 --> 00:56:14,718
And this is the scene that you see at the start of the game.

969
00:56:15,518 --> 00:56:20,080
Especially the way that the lamp posts are having this

970
00:56:20,140 --> 00:56:25,221
nice halo around them and how dreamy looking the background

971
00:56:25,301 --> 00:56:27,002
is, I think that's really nice.

972
00:56:27,022 --> 00:56:32,003
And you can also see it here with other scenes in the game.

973
00:56:32,023 --> 00:56:33,884
Like having this sense of a

974
00:56:36,711 --> 00:56:40,556
not that defined background like rushing past you, for example, when you're playing with

975
00:56:40,576 --> 00:56:45,623
the pigeon is something that I'm, yeah, I think looks really beautiful.

976
00:56:49,167 --> 00:56:54,574
So here at the end of the talk, I would also like to thank a bunch of different people.

977
00:56:55,388 --> 00:57:00,729
I got a lot of mentoring throughout the project from a bunch of very talented graphics programmers.

978
00:57:02,530 --> 00:57:07,571
We also got a lot of help from the Unity spotlight team with figuring out some of the various

979
00:57:07,591 --> 00:57:12,472
ways to tweak the deferred pipeline to do what we needed it to do.

980
00:57:15,353 --> 00:57:20,174
And I would also like to thank Cody, the lead artist on the game, for helping out with preparing

981
00:57:20,194 --> 00:57:20,314
the...

982
00:57:22,656 --> 00:57:24,116
some of the slides in this talk.

983
00:57:24,936 --> 00:57:27,917
And lastly, I would also like to thank Artman

984
00:57:28,137 --> 00:57:34,358
and Bandai Namco for allowing me to give this talk in the end.

985
00:57:39,519 --> 00:57:42,060
So I would also like to thank the rest of the team

986
00:57:42,080 --> 00:57:43,640
that I worked with at Artman.

987
00:57:44,440 --> 00:57:47,541
I think everyone was doing a really good job.

988
00:57:47,581 --> 00:57:49,881
But maybe even more importantly, it's

989
00:57:49,941 --> 00:57:50,661
also one of the

990
00:57:51,569 --> 00:57:55,051
teams I've been on where we had the best social interactions,

991
00:57:55,111 --> 00:57:57,272
like everyone was gelling really well,

992
00:57:57,312 --> 00:58:01,494
and it meant that it was just a pleasure to work on this game.

993
00:58:02,375 --> 00:58:04,856
Yeah, it's one of the best projects I've been involved in.

994
00:58:09,459 --> 00:58:09,739
All right.

995
00:58:11,119 --> 00:58:14,501
So to conclude on all of this, pre-production

996
00:58:14,601 --> 00:58:15,982
is really a must if you're trying

997
00:58:16,022 --> 00:58:18,904
to do something that is as weird as we try to achieve.

998
00:58:22,208 --> 00:58:25,469
And it's important that the technology has a head start

999
00:58:25,789 --> 00:58:27,689
before the rest of production ramps up.

1000
00:58:29,050 --> 00:58:31,451
Also, talk to your artists and make sure

1001
00:58:31,491 --> 00:58:34,191
that what you're developing is actually what they need.

1002
00:58:35,752 --> 00:58:38,273
All the disciplines have to work together in order

1003
00:58:38,313 --> 00:58:40,533
to achieve the look that you want.

1004
00:58:42,387 --> 00:58:45,868
Computers have a huge potential for photo of like,

1005
00:58:46,508 --> 00:58:47,329
for paints and rendering.

1006
00:58:48,069 --> 00:58:51,450
And I can't wait to see what's going to be done with them

1007
00:58:51,750 --> 00:58:52,290
in the future.

1008
00:58:53,470 --> 00:58:56,491
And thankfully, I would say, be a novice when you start,

1009
00:58:57,071 --> 00:58:59,592
because then there's a lot of easy things

1010
00:58:59,612 --> 00:59:01,213
you can fix at the end of the project

1011
00:59:01,353 --> 00:59:02,853
to increase your performance.

1012
00:59:07,414 --> 00:59:08,715
All right, that's it.

1013
00:59:16,717 --> 00:59:20,200
So there's microphones set up if you want to ask me questions.

1014
00:59:22,602 --> 00:59:24,984
I can't actually see the microphone from here,

1015
00:59:25,084 --> 00:59:28,046
but I guess if you form a line, that'll work.

1016
00:59:28,286 --> 00:59:31,268
And remember to say where you're from when you ask the question.

1017
00:59:35,191 --> 00:59:37,353
Hey, that was a beautiful presentation.

1018
00:59:37,573 --> 00:59:38,334
Really awesome work.

1019
00:59:38,594 --> 00:59:39,595
Thank you.

1020
00:59:40,315 --> 00:59:41,456
I have a quick question.

1021
00:59:41,556 --> 00:59:45,719
How did the artist author the flow directions?

1022
00:59:47,540 --> 00:59:56,804
So that was by painting regular flow maps in Substance Painter

1023
00:59:57,024 --> 00:59:59,605
and also having custom nodes for it

1024
00:59:59,685 --> 01:00:02,806
when it was in Substance Designer, I think.

1025
01:00:03,766 --> 01:00:06,407
If you meet us in the wrap-up room, Cody is actually here.

1026
01:00:06,467 --> 01:00:11,809
And he can answer more specifically how that worked.

1027
01:00:12,370 --> 01:00:12,590
Thanks.

1028
01:00:17,286 --> 01:00:17,929
Do we have any more?

1029
01:00:20,078 --> 01:00:20,881
Yes.

1030
01:00:21,684 --> 01:00:22,407
I asked about the.

1031
01:00:23,849 --> 01:00:26,791
The feature about, because I look,

1032
01:00:26,871 --> 01:00:30,994
is look the static image, I think it's very beautiful.

1033
01:00:31,435 --> 01:00:33,516
But what, when the camera is moving,

1034
01:00:33,756 --> 01:00:37,739
and then we can figure out that the paint,

1035
01:00:37,759 --> 01:00:39,981
the stroke is like a little bit flickering

1036
01:00:40,081 --> 01:00:43,083
because they are keep appearing and disappearing.

1037
01:00:43,443 --> 01:00:47,886
So is that the final effect that the artist expect?

1038
01:00:49,207 --> 01:00:52,329
Or you try to make it more stable?

1039
01:00:52,430 --> 01:00:53,490
Could you try and rephrase that?

1040
01:00:54,741 --> 01:01:02,728
I mean, for a dynamic scene, you will find that the strobe is keep appearing and disappearing

1041
01:01:03,569 --> 01:01:04,910
far away or something like that.

1042
01:01:04,990 --> 01:01:08,993
Is this the final effect that the artist expected?

1043
01:01:11,496 --> 01:01:17,181
So if I'm understanding you correctly, you're asking if artist was expecting the effect

1044
01:01:17,221 --> 01:01:18,101
to behave as it did?

1045
01:01:18,723 --> 01:01:22,104
Yes, because you create a game with some concept art

1046
01:01:22,124 --> 01:01:24,305
that is just static, right?

1047
01:01:24,385 --> 01:01:26,165
It's very beautiful, and the static scene...

1048
01:01:26,465 --> 01:01:27,166
Oh, I see what you mean.

1049
01:01:27,186 --> 01:01:30,086
So in motion, was it, like, what we were trying to go for?

1050
01:01:30,126 --> 01:01:30,407
Yeah.

1051
01:01:32,067 --> 01:01:36,088
So our art director actually made a kind of, like,

1052
01:01:36,108 --> 01:01:39,469
a sizzle reel of things he wanted the effect to do early on,

1053
01:01:39,529 --> 01:01:41,029
and a lot of that was inspired by...

1054
01:01:41,169 --> 01:01:45,671
I think I have a slide for that.

1055
01:01:45,711 --> 01:01:45,871
Yeah.

1056
01:01:46,551 --> 01:01:46,711
So...

1057
01:01:48,066 --> 01:01:50,406
We would look at something like the old man and the sea,

1058
01:01:50,687 --> 01:01:52,927
which is a really beautiful oil painted animation.

1059
01:01:53,707 --> 01:01:55,948
And he had eight different things

1060
01:01:55,988 --> 01:01:57,908
that he wanted to see in the pencil effect.

1061
01:01:58,468 --> 01:02:01,009
Some of them was not really achievable,

1062
01:02:01,069 --> 01:02:05,950
but something like boil and slurring, some of that stuff,

1063
01:02:06,030 --> 01:02:07,170
we kind of got in.

1064
01:02:07,710 --> 01:02:11,391
So I think early on, that dialogue with him

1065
01:02:11,471 --> 01:02:13,651
is really what informed how the effect looked in the end.

1066
01:02:15,052 --> 01:02:18,473
I think there was definitely a learning curve for the artists in order to figure out how

1067
01:02:18,513 --> 01:02:24,015
to create 3D art that would work because they couldn't like just look at it inside 3D Max.

1068
01:02:24,035 --> 01:02:27,136
They would have to export it into the game engine and fiddle around with it.

1069
01:02:27,576 --> 01:02:32,417
But we definitely saw like at the end of the production, they had a lot easier time creating

1070
01:02:32,597 --> 01:02:38,799
assets quickly because they had a huge library of substances to rely on and they just knew

1071
01:02:38,819 --> 01:02:41,600
the whole effect much better.

1072
01:02:42,640 --> 01:02:42,900
Okay.

1073
01:02:43,000 --> 01:02:43,361
Thank you.

1074
01:02:44,581 --> 01:02:44,801
All right.

1075
01:02:50,220 --> 01:02:51,881
Hello, great talk, thank you.

1076
01:02:52,782 --> 01:02:55,564
Did you explore machine learning style transfer

1077
01:02:55,844 --> 01:02:56,965
to perform this effect?

1078
01:02:58,527 --> 01:03:02,410
Sorry, is the question to if I will use machine learning?

1079
01:03:02,710 --> 01:03:05,572
Did you explore the possibility of using style transfer?

1080
01:03:06,613 --> 01:03:08,275
Oh, do you mean the one?

1081
01:03:08,915 --> 01:03:12,338
No, we didn't use any machine learning for this.

1082
01:03:13,939 --> 01:03:14,079
So.

1083
01:03:15,586 --> 01:03:20,009
If we had used machine learning, the problem with that is that you give up a lot of control

1084
01:03:20,169 --> 01:03:22,991
for how easy it is to use.

1085
01:03:23,611 --> 01:03:28,454
And as you can see here, we had a lot of artist control over specific objects and the scene

1086
01:03:28,494 --> 01:03:28,895
as a whole.

1087
01:03:29,435 --> 01:03:34,498
So if we had used, like, machine learning, I think we would have kind of, like, thought

1088
01:03:34,659 --> 01:03:36,680
what that approach would have given us.

1089
01:03:37,665 --> 01:03:43,386
So I'm seeing some quite interesting approaches at GDC this year, where they have used it,

1090
01:03:43,406 --> 01:03:48,227
but they also build it as a way to prototype as a given look.

1091
01:03:48,367 --> 01:03:52,888
And I think that it's going to be interesting to see if we're going to end up with some

1092
01:03:52,928 --> 01:03:58,069
kind of hybrid approach where we will have some parameters that are controlled, but what

1093
01:03:58,089 --> 01:04:02,710
I'm seeing from using machine learning so far is that it is kind of like a take-it-or-leave-it

1094
01:04:02,730 --> 01:04:03,170
situation.

1095
01:04:03,710 --> 01:04:04,590
You either use it or you don't.

1096
01:04:06,326 --> 01:04:06,726
Okay, see.

1097
01:04:07,867 --> 01:04:08,147
Thank you.

1098
01:04:08,608 --> 01:04:08,928
You're welcome.

1099
01:04:15,033 --> 01:04:16,594
Hello, so you mentioned a lot of,

1100
01:04:16,895 --> 01:04:19,317
in the talk about troubles with Unity and all that.

1101
01:04:19,837 --> 01:04:23,220
Could you go into why Unity was chosen for a project

1102
01:04:23,300 --> 01:04:25,281
or for maybe Unreal or a custom engine?

1103
01:04:27,943 --> 01:04:28,964
Yeah, that's a good question.

1104
01:04:29,104 --> 01:04:29,245
So.

1105
01:04:31,740 --> 01:04:32,480
I mean, I'm happy.

1106
01:04:32,520 --> 01:04:33,821
I'm a Unity freelancer.

1107
01:04:33,841 --> 01:04:37,343
So I think it was predominantly because admin

1108
01:04:37,383 --> 01:04:42,586
has used it for other problems, other projects in the past.

1109
01:04:43,586 --> 01:04:47,349
So there was a lot of institutional knowledge

1110
01:04:47,409 --> 01:04:48,569
on how to use the engine.

1111
01:04:48,769 --> 01:04:50,590
And I think for the size of team we were,

1112
01:04:50,650 --> 01:04:52,552
it was also a fairly good fit.

1113
01:04:57,395 --> 01:05:00,156
So I have only worked a little bit with Unreal,

1114
01:05:00,256 --> 01:05:02,037
so this is kind of like hearsay,

1115
01:05:02,097 --> 01:05:06,760
but what I've heard is that if you have to modify their renderer,

1116
01:05:06,800 --> 01:05:09,782
like, you have to delve, like, you basically have to

1117
01:05:10,402 --> 01:05:13,184
write in C++ and, like, tear out things

1118
01:05:13,224 --> 01:05:15,025
and, like, put things back together,

1119
01:05:15,045 --> 01:05:16,586
whereas Unity is much more...

1120
01:05:16,966 --> 01:05:19,387
And I guess this is kind of like an engine design philosophy.

1121
01:05:19,487 --> 01:05:20,288
They use, um...

1122
01:05:23,129 --> 01:05:24,951
they approach it much more like a toolbox.

1123
01:05:26,552 --> 01:05:28,393
And there's like, you have to build more on top,

1124
01:05:28,853 --> 01:05:30,054
but it's kind of designed that way.

1125
01:05:30,815 --> 01:05:34,277
And there are limitations of how far you can go with that

1126
01:05:34,358 --> 01:05:38,120
when you're using the current deferred or forward renderer.

1127
01:05:38,561 --> 01:05:40,662
But what they're doing now with the SRP

1128
01:05:40,782 --> 01:05:42,704
and the whole dot system, you're going to see that

1129
01:05:43,204 --> 01:05:44,785
like it's probably going to be a lot quicker

1130
01:05:44,805 --> 01:05:45,626
to do all of these things.

1131
01:05:47,107 --> 01:05:49,429
So yeah, that's why we ended up with Unity.

1132
01:05:49,449 --> 01:05:50,590
I see, thank you.

1133
01:05:54,817 --> 01:05:55,497
I think we have one more.

1134
01:05:56,838 --> 01:05:57,098
I think.

1135
01:05:59,700 --> 01:06:00,261
That's it, okay.

1136
01:06:00,281 --> 01:06:03,003
All right, well thank you for coming

1137
01:06:03,263 --> 01:06:06,566
and remember to fill out the evaluations afterwards.

1138
01:06:06,586 --> 01:06:08,107
All right, enjoy.

1139
01:06:08,167 --> 01:06:09,048
What's left to be said?

