1
00:00:11,119 --> 00:00:11,439
Hello.

2
00:00:12,194 --> 00:00:16,016
I'm Kevin Dill. I'm a senior solutions engineer at Kythera AI.

3
00:00:16,016 --> 00:00:19,937
And before we get going, just a quick shameless plug. So I've been at Kythera

4
00:00:19,937 --> 00:00:23,419
for about a year and a half now, and it's really been a dream job for me

5
00:00:23,419 --> 00:00:26,860
because a lot of my career has been about trying to find reusable

6
00:00:26,860 --> 00:00:30,662
architectures, build reusable tools, and then carry those with me from project to

7
00:00:30,662 --> 00:00:33,323
project to project. And obviously as a middleware company,

8
00:00:33,323 --> 00:00:34,783
that's what Kythera is all about.

9
00:00:35,904 --> 00:00:39,567
So we have a really solid sort of end-to-end AI solution.

10
00:00:39,567 --> 00:00:41,408
If you're looking for some tools

11
00:00:41,408 --> 00:00:42,809
so you don't have to build them yourself,

12
00:00:42,809 --> 00:00:44,090
if you're looking for some help

13
00:00:44,090 --> 00:00:46,672
building the AI for your game, either way,

14
00:00:46,672 --> 00:00:48,393
I definitely encourage you to reach out

15
00:00:48,393 --> 00:00:49,574
and have a talk with us.

16
00:00:49,574 --> 00:00:51,515
That's the kind of thing we can help with.

17
00:00:51,515 --> 00:00:52,296
My email is here.

18
00:00:52,296 --> 00:00:54,497
There'll be more contact information at the end of the talk.

19
00:00:55,398 --> 00:00:58,941
But enough about that, because this is not a talk about Kythera.

20
00:00:58,941 --> 00:01:00,583
This is a talk about testing.

21
00:01:00,583 --> 00:01:01,744
So this is me.

22
00:01:01,744 --> 00:01:04,566
Here I am in my office away from the office.

23
00:01:04,566 --> 00:01:08,750
I've been an AI developer for over 20 years at this point in games and simulations.

24
00:01:08,750 --> 00:01:13,595
I would say for probably the last 15 years, I've been what I would call really unit test

25
00:01:13,595 --> 00:01:14,115
curious, right?

26
00:01:14,295 --> 00:01:20,121
by the idea of unit testing, excited by the promises that it seems to bring, but

27
00:01:20,121 --> 00:01:24,365
time and time again I would try and get tests going in a project and I would

28
00:01:24,365 --> 00:01:27,628
find I was spending far more time fighting with the tests, rewriting them,

29
00:01:27,628 --> 00:01:31,472
maintaining them, things like that, than on any benefit that I was possibly

30
00:01:31,472 --> 00:01:32,253
getting back from them.

31
00:01:33,074 --> 00:01:37,218
Then about probably six or seven years ago, oh, sorry, but unit testing just didn't seem

32
00:01:37,218 --> 00:01:38,859
to work well for games, right?

33
00:01:38,859 --> 00:01:42,763
And that's something that I've heard a lot of people say in one way or another.

34
00:01:42,763 --> 00:01:45,746
And then about six or seven years ago, it finally clicked, right?

35
00:01:45,746 --> 00:01:47,668
It finally just worked.

36
00:01:47,668 --> 00:01:50,711
So I had built my own test framework for a project I was working on.

37
00:01:50,711 --> 00:01:54,735
And since then, I've been consistently building tests for most of the work that I do.

38
00:01:56,887 --> 00:02:00,147
initially on my own because that was a project where I was working by myself.

39
00:02:00,147 --> 00:02:04,228
And now at Kythera, we already had a test framework before I got here and a bunch of

40
00:02:04,228 --> 00:02:07,309
tests for it. And I've been working with the engineers to get us writing more tests and

41
00:02:07,309 --> 00:02:11,510
using it together more consistently. And especially doing it as a team, we're really

42
00:02:11,510 --> 00:02:16,851
starting to see major benefits that pay off far beyond the cost of writing the tests.

43
00:02:18,463 --> 00:02:21,645
So this talk is going to be about first why you should test.

44
00:02:21,645 --> 00:02:25,006
What I'm doing differently from sort of conventional unit

45
00:02:25,006 --> 00:02:25,426
testing.

46
00:02:25,426 --> 00:02:28,287
I've had a lot of software engineering gurus look and go,

47
00:02:28,287 --> 00:02:29,467
well, those aren't unit tests.

48
00:02:29,467 --> 00:02:31,528
They aren't integration tests.

49
00:02:31,528 --> 00:02:33,069
They aren't feature tests.

50
00:02:33,069 --> 00:02:34,829
I don't know quite what those are.

51
00:02:34,829 --> 00:02:37,470
So I'm going to drill into that a little bit and talk about it

52
00:02:37,470 --> 00:02:41,172
and hopefully figure out how to get it working in games.

53
00:02:41,172 --> 00:02:41,972
Some tips and tricks.

54
00:02:42,572 --> 00:02:44,213
once you've gotten that far that have worked for me

55
00:02:44,213 --> 00:02:46,474
to try and be more effective with my testing.

56
00:02:46,474 --> 00:02:48,855
And finally, a few takeaways that will hopefully

57
00:02:48,855 --> 00:02:51,216
help you get over that initial hurdle

58
00:02:51,216 --> 00:02:52,376
and get started with testing.

59
00:02:52,376 --> 00:02:56,938
So some quick definitions before I get going.

60
00:02:56,938 --> 00:02:59,419
If I say Gaia, that's the game AI architecture.

61
00:02:59,419 --> 00:03:02,020
A lot of you have probably heard me talk about it before.

62
00:03:02,020 --> 00:03:05,141
It's a modular AI architecture I developed at Lockheed Martin.

63
00:03:05,141 --> 00:03:06,782
I've used it on a bunch of different things.

64
00:03:06,782 --> 00:03:09,382
I gave an AI Summit talk about it in 2016.

65
00:03:09,382 --> 00:03:11,623
I wrote a Game AI Pro 3 article about it.

66
00:03:12,064 --> 00:03:13,585
If you want to know more, it's there.

67
00:03:13,585 --> 00:03:15,186
I won't mention it much, but when it comes up,

68
00:03:15,186 --> 00:03:17,487
I just wanted you to know what that is.

69
00:03:17,487 --> 00:03:19,488
CSN is City Scale Navigation.

70
00:03:19,488 --> 00:03:21,550
This is the main feature that I've been

71
00:03:21,550 --> 00:03:22,971
working out at Kythera.

72
00:03:22,971 --> 00:03:24,952
So this is what most of my examples are going to be from

73
00:03:24,952 --> 00:03:27,834
because this is what I'm writing tests for right now.

74
00:03:28,474 --> 00:03:31,777
It's a new feature under development where we're going to fill large open worlds with

75
00:03:31,777 --> 00:03:37,002
ambient vehicles and pedestrians, and it uses a graph-based spatial representation rather

76
00:03:37,002 --> 00:03:38,243
than our underlying NavMesh.

77
00:03:38,243 --> 00:03:46,171
So you can see here is an example of the graph that I use in a lot of the tests, and because

78
00:03:46,171 --> 00:03:51,516
vehicles drive in lanes on roads, and pedestrians walk on crosswalks, those are all pretty linear,

79
00:03:51,516 --> 00:03:53,598
and a graph is a really natural representation for that.

80
00:03:56,392 --> 00:04:00,875
So this is my one sort of by the book software engineering slide.

81
00:04:00,875 --> 00:04:04,797
What is a unit test according to standard lore?

82
00:04:04,797 --> 00:04:07,418
And I'm just want to do this really quickly because hopefully everybody already

83
00:04:07,418 --> 00:04:10,981
knows. But a unit test is an automated piece of code that invokes a unit of work

84
00:04:10,981 --> 00:04:14,823
in the system, right? The smallest thing that you can that you can check and then

85
00:04:14,823 --> 00:04:17,944
checks a single assumption about the behavior of that unit of work.

86
00:04:18,665 --> 00:04:20,546
And a good unit test should be all of these things.

87
00:04:20,546 --> 00:04:23,048
I'm not going to go into them now because we'll come back to them.

88
00:04:23,048 --> 00:04:25,909
And the idea is you're going to have lots of these or hundreds of them, right?

89
00:04:25,909 --> 00:04:28,871
Each testing a single assumption about one thing.

90
00:04:28,871 --> 00:04:31,993
They're going to be in their own library that depends on the game library.

91
00:04:31,993 --> 00:04:36,936
It's going to be written alongside the code in C++ or whatever language you normally develop in.

92
00:04:36,936 --> 00:04:39,017
And it's going to cover as much of the code as possible.

93
00:04:39,017 --> 00:04:42,580
So you're validating that as much of the code as possible works the way that you think it should.

94
00:04:43,080 --> 00:04:44,120
It's run every time you build.

95
00:04:44,120 --> 00:04:46,361
So you hit Control-Shift-B, watch it compile,

96
00:04:46,361 --> 00:04:47,842
and then the tests run and immediately

97
00:04:47,842 --> 00:04:49,702
tell you whether they pass or fail.

98
00:04:49,702 --> 00:04:51,243
It's run on continuous integration.

99
00:04:51,243 --> 00:04:54,584
So if for some reason you didn't run it or you missed something,

100
00:04:54,584 --> 00:04:56,685
it gets caught in continuous integration,

101
00:04:56,685 --> 00:04:57,685
and if the tests fail,

102
00:04:57,685 --> 00:05:00,026
it warns the team so they don't pull the bad code.

103
00:05:00,026 --> 00:05:03,287
It's run in the nightly build so that it can run on

104
00:05:03,287 --> 00:05:05,088
all the targets that we don't have time

105
00:05:05,088 --> 00:05:06,568
to do in continuous integration.

106
00:05:08,327 --> 00:05:12,730
So why do this, right? I mean, this means writing a bunch of extra code, maintaining a bunch of extra code.

107
00:05:12,730 --> 00:05:17,493
That's going to take time. We don't have a lot of extra time on most game projects. So why?

108
00:05:19,732 --> 00:05:23,114
The first really major benefit is that you get instant feedback, right?

109
00:05:23,114 --> 00:05:27,917
As soon as you make a mistake, you know right away that there's a bug.

110
00:05:27,917 --> 00:05:31,719
The best time to fix a bug is just after you wrote it,

111
00:05:31,719 --> 00:05:34,481
because all of the code is fresh in your head, right?

112
00:05:34,481 --> 00:05:37,863
Everything that you're doing, the way it connects up to everything else,

113
00:05:37,863 --> 00:05:40,605
all of that is right there, as opposed to when you come back later

114
00:05:40,605 --> 00:05:43,166
and you have to try and rebuild that, but it's imperfect.

115
00:05:43,166 --> 00:05:45,007
It's also the safest time to fix a bug.

116
00:05:45,007 --> 00:05:48,870
You are least likely to make another bug, because all of that is fresh in your head.

117
00:05:50,731 --> 00:05:52,771
It's like the easy button for bug finding, right?

118
00:05:52,771 --> 00:05:55,272
When a test fails, you know exactly where the bug is.

119
00:05:55,272 --> 00:05:56,872
It's in the code you just wrote

120
00:05:56,872 --> 00:05:59,373
or in the code that the test is testing,

121
00:05:59,373 --> 00:06:00,873
as opposed to getting a bug report from QA

122
00:06:00,873 --> 00:06:03,074
and then you blame it on animation

123
00:06:03,074 --> 00:06:04,674
and they blame it on somebody else

124
00:06:04,674 --> 00:06:05,854
and then it gets thrown back to you

125
00:06:05,854 --> 00:06:07,975
and you mark it no repro and then the testers say,

126
00:06:07,975 --> 00:06:10,475
no, it definitely happens and throw it back, right?

127
00:06:10,475 --> 00:06:13,356
And then you finally start to dig in and try and find it

128
00:06:13,356 --> 00:06:16,177
and you realize it is you and you're really embarrassed.

129
00:06:16,472 --> 00:06:23,975
all of that time is saved because you know exactly where it is. And you have an immediate repro case

130
00:06:23,975 --> 00:06:28,898
because the tests are repeatable because they do the same thing when you run them again.

131
00:06:28,898 --> 00:06:35,101
If you have some difficult to reproduce, hard to catch bug, like you've got one vehicle is

132
00:06:35,101 --> 00:06:39,923
speeding up only a little bit, another vehicle is slowing down but not enough to stop, and there's

133
00:06:39,923 --> 00:06:41,324
a traffic light that's about to turn red.

134
00:06:41,844 --> 00:06:43,185
And on the far side of the traffic light,

135
00:06:43,185 --> 00:06:44,707
there's a crosswalk with a pedestrian

136
00:06:44,707 --> 00:06:45,968
that's gonna go across it.

137
00:06:45,968 --> 00:06:48,971
And in this combination of things, something goes wrong.

138
00:06:48,971 --> 00:06:51,893
And in CSN, we have definitely found cases

139
00:06:51,893 --> 00:06:55,897
where it's weird combinations like that, right?

140
00:06:55,897 --> 00:06:57,659
When we get a test that catches that,

141
00:06:57,659 --> 00:06:59,500
or we set up the situation in game

142
00:06:59,500 --> 00:07:00,842
so that the test catches it,

143
00:07:00,842 --> 00:07:02,964
then we could just rerun the test

144
00:07:02,964 --> 00:07:04,985
and hit the problem again and again and again,

145
00:07:04,985 --> 00:07:08,108
and iterate really, really quickly trying to find it.

146
00:07:10,263 --> 00:07:12,944
This may seem a little strange, but stick with me on this one.

147
00:07:12,944 --> 00:07:16,545
The tests document the code in a really powerful way.

148
00:07:16,545 --> 00:07:18,865
They let you step in and see what's

149
00:07:18,865 --> 00:07:21,046
happening with fully instantiated objects.

150
00:07:21,046 --> 00:07:24,767
It's much better to go in the debugger and see

151
00:07:24,767 --> 00:07:27,687
the object with all the data filled out and everything

152
00:07:27,687 --> 00:07:29,828
hooked up than it is to try and look at

153
00:07:29,828 --> 00:07:32,328
the header files and figure out how everything hooks up.

154
00:07:32,868 --> 00:07:36,891
especially when you're getting back up to speed on some feature that you worked on a while ago,

155
00:07:36,891 --> 00:07:40,755
or when you're trying to look at somebody else's code and you want to get up to speed with

156
00:07:40,755 --> 00:07:45,899
what what they did, going and looking at the tests really helps. And I'll give you a concrete

157
00:07:45,899 --> 00:07:51,204
example of this. The first thing that I worked on when I came to Kaithera was the CSN path planner.

158
00:07:51,204 --> 00:07:56,628
Right, so as you recall CSN works on a graph rather than an avmesh, so it needed its own path planner.

159
00:07:56,969 --> 00:08:00,531
And most of the time we don't use it. Most of the time we have a scheduler that just

160
00:08:00,531 --> 00:08:05,854
picks it random when it comes to an intersection. But we expect that the designers will want to

161
00:08:05,854 --> 00:08:10,818
build missions where a vehicle goes a certain place and they're going to want to take advantage

162
00:08:10,818 --> 00:08:13,039
of all the code in CSN to make it...

163
00:08:13,287 --> 00:08:18,051
follow the rules of the road and look good and all of that. So they need a path planner that works

164
00:08:18,051 --> 00:08:24,116
with CSN. As I said, this was the first thing that I built when I came to Kythera. So we did it pretty

165
00:08:24,116 --> 00:08:29,360
early and they just weren't ready for it yet. So it wasn't hooked up in-game for almost a year.

166
00:08:29,360 --> 00:08:33,483
And by the time they got ready to hook it up, I was off on another project. So Michael's a

167
00:08:33,483 --> 00:08:37,827
co-worker of mine. He came to me and he said, tell me how this works. And I started talking about how

168
00:08:38,307 --> 00:08:40,789
gives you all of the lanes that the vehicle could use,

169
00:08:40,789 --> 00:08:43,591
so it's not always cutting to the inside,

170
00:08:43,591 --> 00:08:44,752
and going on and on.

171
00:08:44,752 --> 00:08:45,933
And I had vehicles on the brain,

172
00:08:45,933 --> 00:08:47,334
because that's usually what we think about first.

173
00:08:47,334 --> 00:08:48,815
And he said, well, yeah, but hang on,

174
00:08:48,815 --> 00:08:50,737
because I'm working on pedestrians.

175
00:08:50,737 --> 00:08:52,178
Does it handle crosswalks?

176
00:08:53,032 --> 00:08:55,492
Well, shit, I don't know.

177
00:08:55,492 --> 00:08:57,193
Crosswalks are kind of tricky, and I remember

178
00:08:57,193 --> 00:08:58,393
we had some trouble with them.

179
00:08:58,393 --> 00:08:59,673
Because if you notice here, for instance,

180
00:08:59,673 --> 00:09:01,254
we have this crosswalk that's going across

181
00:09:01,254 --> 00:09:02,394
these vehicle lanes.

182
00:09:02,394 --> 00:09:05,075
And it breaks off in the middle of this sidewalk here.

183
00:09:05,075 --> 00:09:09,016
Whereas everywhere else, our lanes connect up end to end.

184
00:09:09,016 --> 00:09:10,476
And that caused us a lot of trouble.

185
00:09:10,476 --> 00:09:11,836
I remember that they weren't working

186
00:09:11,836 --> 00:09:13,457
when I first worked on path planning,

187
00:09:13,457 --> 00:09:15,217
and I don't know if I ever got them working

188
00:09:15,217 --> 00:09:15,797
with the path planner.

189
00:09:16,298 --> 00:09:21,482
So let's find out. We go to the test file, start down at the bottom because it would be one of the last things that I did.

190
00:09:21,482 --> 00:09:25,686
And sure enough, here's pedestrian crosswalk 3, right? It's the third of three tests.

191
00:09:25,686 --> 00:09:30,130
So it creates a start position. It creates a destination position.

192
00:09:30,130 --> 00:09:35,975
It tells the tests that those both have to be valid, calling into the is valid code that's built into CSN.

193
00:09:35,975 --> 00:09:40,519
So this is one of the things I like to do, and we'll come back to this, is â€¦

194
00:09:41,060 --> 00:09:43,903
have a lot of checking that I'm doing

195
00:09:43,903 --> 00:09:46,546
so that I can catch a lot of different bugs.

196
00:09:46,546 --> 00:09:48,428
It then calls the path planner,

197
00:09:48,428 --> 00:09:51,712
plans a path, it prints that out so that if the test fails,

198
00:09:51,712 --> 00:09:53,895
we can see what it actually found easily

199
00:09:53,895 --> 00:09:56,357
instead of having to try and inspect the objects in the debugger.

200
00:09:57,038 --> 00:09:58,699
Here's the path that it expects to follow.

201
00:09:58,699 --> 00:10:01,242
And that looks like this, by the way.

202
00:10:01,242 --> 00:10:03,023
So it's coming down across this crosswalk.

203
00:10:03,023 --> 00:10:04,484
There's a crosswalk here.

204
00:10:04,484 --> 00:10:06,646
And there's a third crosswalk here.

205
00:10:06,646 --> 00:10:09,028
And yes, this test does paths.

206
00:10:09,028 --> 00:10:11,590
So it is definitely going across crosswalks.

207
00:10:11,590 --> 00:10:13,231
And finally, it checks that.

208
00:10:13,231 --> 00:10:15,513
So this is where it checks that those two paths are the same.

209
00:10:15,513 --> 00:10:17,855
And it also does a bunch of other checking

210
00:10:17,855 --> 00:10:20,197
that this path object from CSN is well-formed

211
00:10:20,197 --> 00:10:21,738
and that everything is kosher.

212
00:10:23,957 --> 00:10:29,805
So not only does this let us confirm that yes, we did get as far as implementing this feature,

213
00:10:29,805 --> 00:10:34,250
but also it made it a lot easier for Michael to get in and understand things like,

214
00:10:34,250 --> 00:10:38,576
how does it handle this special case where it breaks off in the middle of a lane?

215
00:10:38,576 --> 00:10:42,281
Because I still don't know how it does that. I don't remember what I did.

216
00:10:43,142 --> 00:10:46,887
But instead of me having to go back and help him try and figure it out, or him

217
00:10:46,887 --> 00:10:49,830
spending a lot of time sort of fighting through and digging in, he just sets a

218
00:10:49,830 --> 00:10:54,697
breakpoint and sees what it does. There it is. So it's just a lot quicker to get

219
00:10:54,697 --> 00:10:55,318
up to speed.

220
00:10:56,817 --> 00:10:58,598
The last thing that I'll give for benefits

221
00:10:58,598 --> 00:11:01,239
is that the tests give you a safety net

222
00:11:01,239 --> 00:11:02,780
anytime the code changes.

223
00:11:02,780 --> 00:11:03,920
And this is game development.

224
00:11:03,920 --> 00:11:05,721
Our code changes all the time.

225
00:11:05,721 --> 00:11:08,302
We have to tune, we have to balance,

226
00:11:08,302 --> 00:11:11,003
we have to find the fun, we have features that change,

227
00:11:11,003 --> 00:11:12,303
we have to fix bugs.

228
00:11:12,303 --> 00:11:14,544
Hopefully we have some time to do some refactoring

229
00:11:14,544 --> 00:11:15,645
now and then.

230
00:11:17,071 --> 00:11:21,116
Game code probably changes more than code in most other industries.

231
00:11:21,116 --> 00:11:24,420
And I think that's one of the reasons why testing at the code level,

232
00:11:24,420 --> 00:11:26,923
like unit tests do, can be really challenging.

233
00:11:26,923 --> 00:11:33,170
But it's also really powerful because when I go and make a change,

234
00:11:33,853 --> 00:11:37,636
I'm going to test the thing that I changed that it fixed what I thought it was going to fix,

235
00:11:37,636 --> 00:11:42,620
but it's really difficult to test everything else that might have broken in that process.

236
00:11:42,620 --> 00:11:46,943
And I can throw it to QA for regression testing, but they're coming down from the top,

237
00:11:46,943 --> 00:11:50,166
they're not coming up from the bottom. So they're testing in different ways,

238
00:11:50,166 --> 00:11:53,688
and they're going to find different bugs. There are a lot of bugs that unit testing

239
00:11:53,688 --> 00:11:56,150
will find much more naturally than QA will.

240
00:11:58,379 --> 00:12:00,900
So again, I'll give you an example just as quickly as I can.

241
00:12:00,900 --> 00:12:05,342
So one of the features I've been working on is at very high level of detail,

242
00:12:05,342 --> 00:12:08,103
pedestrians are going to avoid each other using ORCA,

243
00:12:08,103 --> 00:12:11,664
which we already have, so we're just really hooking it up. At lower level of

244
00:12:11,664 --> 00:12:14,445
detail, they just walk right through each other.

245
00:12:15,125 --> 00:12:19,007
So this requires that we add a component onto the entity when the LOD is raised,

246
00:12:19,007 --> 00:12:21,368
and then remove that component when the LOD drops back down.

247
00:12:21,368 --> 00:12:25,590
The problem is when we spawn a player in, we go from the lowest LOD,

248
00:12:25,590 --> 00:12:28,211
because there was nobody there, to the highest LOD,

249
00:12:28,211 --> 00:12:30,112
because the player is standing right there.

250
00:12:30,112 --> 00:12:33,073
So the first thing we do is spawn some actors,

251
00:12:33,073 --> 00:12:36,575
because we don't have any pedestrians at the lowest LOD

252
00:12:36,575 --> 00:12:39,756
that's far enough away that we just don't model them.

253
00:12:39,756 --> 00:12:42,777
And when we spawn them in, we create that avoidance component for them,

254
00:12:42,777 --> 00:12:44,378
because we're spawning them in at a high LOD.

255
00:12:45,139 --> 00:12:49,922
And then we go through all of the actors that are in the area where the LOD is changing,

256
00:12:49,922 --> 00:12:53,764
and we change them from low to high. And in the process of doing that, among other things,

257
00:12:53,764 --> 00:12:57,787
we create an avoidance component for them so that they will avoid each other.

258
00:12:57,787 --> 00:13:01,509
And then we crash because we just created two avoidance components

259
00:13:01,509 --> 00:13:02,650
and they conflict with each other.

260
00:13:03,460 --> 00:13:06,583
So it seems really natural to just reverse the order of operations, right?

261
00:13:06,583 --> 00:13:10,428
First change the LOD on any existing actors and then spawn in any new actors

262
00:13:10,428 --> 00:13:12,931
so that they only get one avoidance component.

263
00:13:12,931 --> 00:13:15,934
But does that create another bug? Is it safe?

264
00:13:15,934 --> 00:13:16,715
Probably.

265
00:13:16,715 --> 00:13:20,119
But it's a pretty complex system and there could easily be some dependency

266
00:13:20,119 --> 00:13:22,962
either that we know about or that we didn't realize that it would break.

267
00:13:23,543 --> 00:13:26,984
So now, unfortunately, we have no tests for this.

268
00:13:26,984 --> 00:13:30,465
So I have to go a lot slower. I have to be a lot more careful in my testing.

269
00:13:30,465 --> 00:13:35,127
I have to go interrupt Sandy, who's the guy who wrote the spawning system in the first place,

270
00:13:35,127 --> 00:13:38,649
and check with him, like, does this seem like it's safe?

271
00:13:38,649 --> 00:13:43,870
And in the end, I just feel a lot more nervous about it. So it slows me down.

272
00:13:43,870 --> 00:13:46,491
And it misses the opportunity to catch bugs early.

273
00:13:48,938 --> 00:13:51,760
So hopefully by now I've got you at least unit test curious, right?

274
00:13:51,760 --> 00:13:54,442
Hopefully by now you're going, wow, that sounds pretty good.

275
00:13:54,442 --> 00:13:56,404
I wish I had some of that.

276
00:13:56,404 --> 00:13:59,046
But I'm not sure how am I going to get it to work for games?

277
00:13:59,046 --> 00:14:00,447
Cause that problem is still out there.

278
00:14:00,447 --> 00:14:03,750
So, so the first thing I think we need to do, of course, we all recognize this

279
00:14:03,750 --> 00:14:08,134
slide from earlier is change this, this definition because it's too restrictive.

280
00:14:08,614 --> 00:14:11,779
So instead, let's say that a unit test, in quotes,

281
00:14:11,779 --> 00:14:15,605
is an automated piece of code that invokes the system and tests it.

282
00:14:15,605 --> 00:14:19,992
And yes, I still call them unit tests, even though software engineer gurus will tell me

283
00:14:19,992 --> 00:14:22,296
those aren't unit tests, they're something else, I don't know what they are.

284
00:14:24,493 --> 00:14:27,275
And so here's our list of things that a good unit test should be.

285
00:14:27,275 --> 00:14:32,458
And these ones are critical. It needs to be fully automated.

286
00:14:32,458 --> 00:14:36,321
We need to run it every time we build. The whole point is to catch bugs early.

287
00:14:36,321 --> 00:14:40,503
So it needs to be readable so that when we get a bug,

288
00:14:40,503 --> 00:14:43,285
we can easily understand what actually happened,

289
00:14:43,285 --> 00:14:46,387
what we expected to happen, and why that thing is wrong.

290
00:14:47,217 --> 00:14:51,742
it needs to be maintainable. The code is going to change and as it does, the tests will often

291
00:14:51,742 --> 00:14:56,107
need to change as well. So we can't just hack them in. We have to treat them as first class code.

292
00:14:56,107 --> 00:14:59,390
It needs to be consistent, meaning that it always returns the same result.

293
00:14:59,390 --> 00:15:03,055
It always does the same thing. It always exercises the same code paths.

294
00:15:04,076 --> 00:15:09,141
For the reasons that I already said, because that's how we get those really powerful repro cases,

295
00:15:09,141 --> 00:15:14,888
where when we catch some hard-to-reproduce bug, now we have an easy way to reproduce it,

296
00:15:14,888 --> 00:15:19,192
and where we can use the test to intentionally create things like that.

297
00:15:19,192 --> 00:15:22,516
And it needs to be order agnostic, meaning that I can run them in any order,

298
00:15:22,516 --> 00:15:25,880
they don't depend on one another. And I'll get to the reason for that in just a moment.

299
00:15:27,528 --> 00:15:33,431
Yes, they need to be fast, but let's not get crazy here. They don't need to run in 30 seconds,

300
00:15:33,431 --> 00:15:40,495
right? A single CPP compile for me takes about 30 seconds. So, sorry, they don't need to run in

301
00:15:40,495 --> 00:15:45,157
three seconds, which is the standard sort of, if you Google that's how fast they say they should be.

302
00:15:46,925 --> 00:15:50,406
Archithera tests take a couple of minutes, two, three minutes

303
00:15:50,406 --> 00:15:51,567
to run the whole way.

304
00:15:51,567 --> 00:15:53,048
And that's slower than I would like.

305
00:15:53,048 --> 00:15:54,728
I have some ideas about how to fix it.

306
00:15:54,728 --> 00:15:55,509
Someday I'll do it.

307
00:15:55,509 --> 00:15:57,490
But is it the most important thing?

308
00:15:57,490 --> 00:15:57,930
Hell no.

309
00:15:57,930 --> 00:15:59,471
I've got a milestone next week.

310
00:15:59,471 --> 00:16:01,892
That's the most important thing.

311
00:16:01,892 --> 00:16:03,692
When I get some free time, I'll speed them up.

312
00:16:03,692 --> 00:16:05,974
I can work with them even though they run slowly.

313
00:16:05,974 --> 00:16:07,954
The biggest thing that I do is I take the tests

314
00:16:07,954 --> 00:16:09,615
that I'm working on and I put them up at the top.

315
00:16:09,615 --> 00:16:11,896
And that's as easy as going into the CMake file

316
00:16:11,896 --> 00:16:14,417
and putting that test file at the top of the list.

317
00:16:16,094 --> 00:16:17,555
So those ones run first, right?

318
00:16:17,555 --> 00:16:19,998
If I've got a fast compile that I hit control shift B,

319
00:16:19,998 --> 00:16:22,299
it compiles, I watched until my tests,

320
00:16:22,299 --> 00:16:25,482
my new tests have passed, and then I can go back to work.

321
00:16:25,482 --> 00:16:27,244
And I should circle back later

322
00:16:27,244 --> 00:16:29,145
and check if something else broke,

323
00:16:29,145 --> 00:16:30,787
in case I broke something in some other system

324
00:16:30,787 --> 00:16:31,908
and didn't realize it.

325
00:16:31,908 --> 00:16:33,990
If I forget, then when I check the code in,

326
00:16:33,990 --> 00:16:36,492
it'll run on the continuous integration server.

327
00:16:36,492 --> 00:16:37,813
And if I broke something,

328
00:16:37,813 --> 00:16:39,554
that'll get sent out to the whole team

329
00:16:39,554 --> 00:16:40,435
and I'll be embarrassed,

330
00:16:40,435 --> 00:16:41,856
and next time I'll remember to do it.

331
00:16:44,269 --> 00:16:48,370
I don't care if they run in memory. The real point of this was to get them to run fast,

332
00:16:48,370 --> 00:16:56,031
but the Gaia tests, for instance, take about 10 to 20 seconds to run, and every one of them

333
00:16:56,031 --> 00:17:00,792
is an XML file that gets loaded in when the tests run. Disk is fast these days. Keep it in memory if

334
00:17:00,792 --> 00:17:04,513
you can, but if there's a reason to hit the disk or the network or the database or whatever else,

335
00:17:04,513 --> 00:17:09,694
if that's going to let you test something more effectively, then by all means do it.

336
00:17:09,694 --> 00:17:11,994
And being atomic...

337
00:17:12,774 --> 00:17:15,458
I feel like this is actually what was screwing me up, right?

338
00:17:15,458 --> 00:17:19,923
So trying to test the smallest possible piece and totally isolate it by building

339
00:17:19,923 --> 00:17:24,409
mocks for all of the other systems and then those have to be maintained.

340
00:17:24,409 --> 00:17:26,472
This was a nightmare, right?

341
00:17:28,327 --> 00:17:32,810
Instead, when I step up the level of granularity and I test, for instance, at the behavior tree

342
00:17:32,810 --> 00:17:38,413
level or in Gaia at the reasoner level, then I'm testing, say, I'm testing my selector node or my

343
00:17:38,413 --> 00:17:44,037
sequence node, right? And I'm building some custom test nodes for some of the pieces underneath that,

344
00:17:44,037 --> 00:17:47,579
but I'm exercising a lot of decision-making logic throughout the architecture. And I've

345
00:17:47,579 --> 00:17:51,702
got these roots that are growing down into the architecture and sort of touching different

346
00:17:51,702 --> 00:17:57,286
things, having more opportunities to find bugs and broadening out my coverage.

347
00:17:57,786 --> 00:18:03,609
almost for free. So you want them to be focused enough that when a test fails, you can get in

348
00:18:03,609 --> 00:18:09,052
and find where the problem is as easily as possible. But it's also nice if they actually

349
00:18:09,052 --> 00:18:14,395
branch out and test more than just the thing you're intentionally testing, because you'll catch bugs

350
00:18:14,395 --> 00:18:18,498
in other places. I found a bug, for instance, where my distance squared function was taking

351
00:18:18,498 --> 00:18:24,601
the square root. And that had been in there for probably five years. And top-down testing

352
00:18:24,601 --> 00:18:25,562
never caught it.

353
00:18:25,802 --> 00:18:30,723
But when I wrote a test and just threw in there, oh, and by the way, the distance should be this,

354
00:18:30,723 --> 00:18:40,645
and it wasn't, then we found it. And boy, was that embarrassing. So that's really the core of it,

355
00:18:40,645 --> 00:18:46,407
to me, is get that granularity right. Test the bigger pieces. And don't be afraid to have your

356
00:18:46,407 --> 00:18:50,768
tests that call into things that have dependencies that are testing more code.

357
00:18:52,039 --> 00:18:56,821
So on to sort of nuts and bolts, tips and tricks to, you know, now you're building tests, you're

358
00:18:56,821 --> 00:19:03,223
testing at a good level of granularity, how do you get it to work? One of the big things I think that

359
00:19:03,223 --> 00:19:08,846
messes people up, especially early on, is that you need to come in through the class interface,

360
00:19:08,846 --> 00:19:14,348
right? And oftentimes your test library is dynamically linking, so you need to come in

361
00:19:14,348 --> 00:19:17,569
through the API, which may not even be all of your public interfaces.

362
00:19:18,372 --> 00:19:21,293
If you're exposing things just for the tests,

363
00:19:21,293 --> 00:19:24,075
it's either moving them into the public interface

364
00:19:24,075 --> 00:19:26,137
or maybe making the test a friend class

365
00:19:26,137 --> 00:19:27,778
of the thing it's testing or something like that,

366
00:19:27,778 --> 00:19:29,439
that's a really bad idea.

367
00:19:29,439 --> 00:19:33,441
That's a really bad code smell.

368
00:19:33,441 --> 00:19:35,743
Not only because you've got stuff in the public interface

369
00:19:35,743 --> 00:19:37,884
that shouldn't be there, but more importantly,

370
00:19:37,884 --> 00:19:40,006
that's a sign that you're trying to test too small.

371
00:19:40,006 --> 00:19:42,027
You're testing implementation details.

372
00:19:42,027 --> 00:19:45,029
And those are the things that are gonna change the fastest.

373
00:19:45,029 --> 00:19:46,450
You wanna test.

374
00:19:46,715 --> 00:19:51,018
through the interface because that's going to change less often. Refactors, for instance,

375
00:19:51,018 --> 00:19:55,860
aren't going to break it. But you can't test everything through the API, right? You can

376
00:19:55,860 --> 00:20:00,042
call a function and see that what you got back is what you expect, but you can't test a lot of the

377
00:20:00,042 --> 00:20:04,664
details that went on in that. And so, you can't really get in and test everything at the code

378
00:20:04,664 --> 00:20:09,647
level. So, how do we solve that? The solution that has worked for me is to inject my tests

379
00:20:09,647 --> 00:20:13,569
into the code. What do I mean by that? Use asserts.

380
00:20:13,869 --> 00:20:18,732
Use errors. Use warnings. Make your errors and warnings cause test failures. Among other things,

381
00:20:18,732 --> 00:20:23,754
then you'll clean up all your damn warnings and they'll become useful again. If they're

382
00:20:23,754 --> 00:20:27,717
unexpected. If errors and warnings are expected, you should have a way to tell the test, hey,

383
00:20:27,717 --> 00:20:32,019
I'm expecting to get three warnings or three errors, right? And then do things like load a

384
00:20:32,019 --> 00:20:36,141
bad data file and confirm that you actually get them so you can test that your data load

385
00:20:36,141 --> 00:20:37,462
catches errors properly.

386
00:20:40,827 --> 00:20:43,008
This means that the code checks

387
00:20:43,008 --> 00:20:44,709
that the edge cases work correctly.

388
00:20:44,709 --> 00:20:46,149
And it's much more natural

389
00:20:46,149 --> 00:20:48,590
than having a separate set of tests to check that.

390
00:20:48,590 --> 00:20:50,171
As the code changes,

391
00:20:50,171 --> 00:20:53,372
the asserts and errors and warnings in the code

392
00:20:53,372 --> 00:20:56,093
will naturally change as part of rewriting the code.

393
00:20:56,093 --> 00:20:57,293
You put those in your code anyway.

394
00:20:58,247 --> 00:21:02,150
And then you have tests that just call the code

395
00:21:02,150 --> 00:21:04,331
to give those asserts a chance to happen.

396
00:21:04,331 --> 00:21:07,733
And the tests can deliberately try and set up

397
00:21:07,733 --> 00:21:09,654
edge cases to confirm that, yes, it

398
00:21:09,654 --> 00:21:12,076
does the right thing when the input is 0 or whatever

399
00:21:12,076 --> 00:21:15,578
the case may be.

400
00:21:15,578 --> 00:21:17,959
Sorry, so this actually was meant to be much earlier.

401
00:21:17,959 --> 00:21:19,601
So we have.

402
00:21:20,516 --> 00:21:27,501
hundreds and hundreds of lines, for example, that validate that the CSN network is correctly

403
00:21:27,501 --> 00:21:31,804
formed. Probably over a thousand lines at this point. That nothing is duplicated. That everything

404
00:21:31,804 --> 00:21:35,666
hooks up correctly. That if I've got a connection from here to here, that I also have a reverse

405
00:21:35,666 --> 00:21:40,509
connection from there to there. All of that kind of stuff. Every time we ran into a bug,

406
00:21:40,509 --> 00:21:42,411
we added something to these validate functions.

407
00:21:43,163 --> 00:21:47,265
They are if-deafed out if you're not in a debug build.

408
00:21:47,265 --> 00:21:50,586
They're hit every time you load a level if you are in a debug build.

409
00:21:50,586 --> 00:21:54,607
But we also have a bunch of tests that load different levels,

410
00:21:54,607 --> 00:21:56,808
including that map that I showed you.

411
00:21:56,808 --> 00:21:59,629
And we found a bunch of bugs because the validate gets found,

412
00:21:59,629 --> 00:22:03,250
and we find, oh, there's a bug in the way the graph is getting formed in this case.

413
00:22:05,980 --> 00:22:09,843
Once you've got tests injected into your code,

414
00:22:09,843 --> 00:22:12,965
then you can do things like write stress tests.

415
00:22:12,965 --> 00:22:14,686
And this is a great place to start, right?

416
00:22:14,686 --> 00:22:17,107
Just load a large map, create lots of entities

417
00:22:17,107 --> 00:22:18,948
and let it run for a while.

418
00:22:18,948 --> 00:22:21,630
When you're trying to exercise something like our scheduler,

419
00:22:21,630 --> 00:22:23,451
which is what controls what all the vehicles

420
00:22:23,451 --> 00:22:25,192
and pedestrians do normally.

421
00:22:25,192 --> 00:22:28,694
So we load in, in this case, this map, which is pretty big.

422
00:22:28,694 --> 00:22:30,736
We create a ton of vehicles and pedestrians.

423
00:22:31,544 --> 00:22:33,305
Then we start with a very small time step,

424
00:22:33,305 --> 00:22:34,605
and we go through a thousand iterations,

425
00:22:34,605 --> 00:22:37,426
incrementing the time step each time,

426
00:22:37,426 --> 00:22:38,386
and then calling update.

427
00:22:38,386 --> 00:22:39,526
So this, among other things,

428
00:22:39,526 --> 00:22:41,687
tests that as your frame rate gets really bad,

429
00:22:41,687 --> 00:22:42,747
does that cause problems?

430
00:22:42,747 --> 00:22:44,308
And the answer was, yeah, it does.

431
00:22:44,308 --> 00:22:45,728
We find bugs that way.

432
00:22:45,728 --> 00:22:48,149
And then we also have, again,

433
00:22:48,149 --> 00:22:50,129
just testing everything that we can think of.

434
00:22:50,129 --> 00:22:51,770
So here I'm testing serialization

435
00:22:51,770 --> 00:22:54,230
that we use for networking every 200 frames.

436
00:22:54,230 --> 00:22:56,511
So the schedules have time to change a bunch,

437
00:22:56,511 --> 00:22:57,731
and then I try serializing them.

438
00:22:59,765 --> 00:23:02,346
This test takes about 30 seconds to run.

439
00:23:02,346 --> 00:23:05,548
So that's too slow to do it every time I compile.

440
00:23:05,548 --> 00:23:06,988
So we have this slow test filter.

441
00:23:06,988 --> 00:23:08,549
We're using the Google test framework.

442
00:23:08,549 --> 00:23:10,890
So this itself isn't built into Google test,

443
00:23:10,890 --> 00:23:14,392
but there are really easy ways to disable tests

444
00:23:14,392 --> 00:23:16,653
that is what this is leveraging.

445
00:23:16,653 --> 00:23:18,714
And I have a compiler directive that if it's enabled,

446
00:23:18,714 --> 00:23:19,754
then I'll run this test.

447
00:23:19,754 --> 00:23:20,955
If it's disabled, I don't.

448
00:23:20,955 --> 00:23:22,695
It's enabled in the nightly build

449
00:23:22,695 --> 00:23:24,776
and on continuous integration.

450
00:23:24,776 --> 00:23:26,817
I don't usually have it enabled when I'm working.

451
00:23:27,702 --> 00:23:33,304
But I build my code, I write my own tests, my faster tests, I make sure that they all pass.

452
00:23:33,304 --> 00:23:38,546
Then if I'm being good, I go into CMake, I click the box, I recompile, which only takes a minute

453
00:23:38,546 --> 00:23:42,627
because it's only a couple of files that change. I run the tests again and I make sure that the

454
00:23:42,627 --> 00:23:48,089
slow tests pass. If I'm being lazy or I forget to do that and I broke something, you know,

455
00:23:48,089 --> 00:23:52,510
or these catch something, which they often do because they can catch those weird edge cases.

456
00:23:53,185 --> 00:23:55,927
Then it'll break in continuous integration

457
00:23:55,927 --> 00:23:57,388
and send out the email to the whole team

458
00:23:57,388 --> 00:23:58,729
and I'll be embarrassed and next time

459
00:23:58,729 --> 00:24:01,110
I'll run the slow tests before I commit.

460
00:24:01,110 --> 00:24:05,272
So that's, I think, probably all I have time for

461
00:24:05,272 --> 00:24:08,654
as far as takeaway, or sorry, as far as tips and tricks.

462
00:24:08,654 --> 00:24:10,715
There's so much else that I wanted to talk about

463
00:24:10,715 --> 00:24:12,196
and had to cut out.

464
00:24:12,196 --> 00:24:13,377
So hopefully a future talk,

465
00:24:13,377 --> 00:24:14,958
and I would love to see talks from others.

466
00:24:14,958 --> 00:24:16,719
There've been really few talks,

467
00:24:16,719 --> 00:24:17,900
especially about unit testing,

468
00:24:17,900 --> 00:24:19,641
like really getting into the code and testing.

469
00:24:20,161 --> 00:24:24,745
And I would love ideas from all the rest of you as well.

470
00:24:24,745 --> 00:24:27,027
But I wanted to give just a few,

471
00:24:27,027 --> 00:24:30,771
what are the reasons that we fail in the games industry?

472
00:24:30,771 --> 00:24:34,034
And the takeaways that I hope will let you get over the hump

473
00:24:34,034 --> 00:24:35,035
and get started with this.

474
00:24:35,035 --> 00:24:37,937
So the first reason that we often fail

475
00:24:37,937 --> 00:24:39,479
is that it's just overwhelming, right?

476
00:24:39,479 --> 00:24:42,121
You've got all of this code, none of it's under test.

477
00:24:42,121 --> 00:24:43,362
Where do you even begin?

478
00:24:44,200 --> 00:24:49,666
don't angst about having perfect coverage. If you have anything under test, that's better than not

479
00:24:49,666 --> 00:24:55,452
having anything under test. Michael Feathers, who's one of the real unit testing gurus,

480
00:24:55,452 --> 00:25:04,061
said that bad tests run often are better than good tests that aren't run at all.

481
00:25:04,061 --> 00:25:04,101
So,

482
00:25:04,315 --> 00:25:08,238
you know, as long as the tests aren't so bad, I would add, that they're slowing you down more

483
00:25:08,238 --> 00:25:13,262
than they're helping you. But you'll know if that's happening. So get anything tested, right?

484
00:25:13,262 --> 00:25:18,045
Start with your next line of code. Or start with the next bug you fix. Put in a test to make sure

485
00:25:18,045 --> 00:25:21,867
that bug doesn't come back. And now you're doing regression testing at the code level

486
00:25:21,867 --> 00:25:24,930
that's complementing the regression testing the QA does.

487
00:25:26,983 --> 00:25:29,185
The next problem, and this was the one that killed me

488
00:25:29,185 --> 00:25:31,326
so many times when I tried to get started,

489
00:25:31,326 --> 00:25:32,748
is that especially early on,

490
00:25:32,748 --> 00:25:34,209
while I was figuring out what to do,

491
00:25:34,209 --> 00:25:35,410
I just didn't have enough time.

492
00:25:35,410 --> 00:25:38,692
The test maintenance was way bigger than the test payoff.

493
00:25:38,692 --> 00:25:40,754
If you find that this is happening,

494
00:25:40,754 --> 00:25:43,096
think about your level of granularity.

495
00:25:43,096 --> 00:25:47,260
Try writing coarser tests that test bigger systems

496
00:25:47,260 --> 00:25:49,682
and then implicitly test the smaller systems

497
00:25:49,682 --> 00:25:51,203
because they call down into it.

498
00:25:52,562 --> 00:25:54,043
build the validation into your code,

499
00:25:54,043 --> 00:25:56,385
make it so that your errors and your warnings are test

500
00:25:56,385 --> 00:25:58,346
failures so that you don't have to assert everything,

501
00:25:58,346 --> 00:25:59,747
get asserts in there.

502
00:25:59,747 --> 00:26:00,868
If you have more expensive things

503
00:26:00,868 --> 00:26:04,470
that you want to put in errors and warnings, if def,

504
00:26:04,470 --> 00:26:08,452
debug them or something like that.

505
00:26:08,452 --> 00:26:12,355
And try and get that coverage broad in the easy, cheap ways.

506
00:26:12,355 --> 00:26:13,876
And as soon as you start finding bugs

507
00:26:13,876 --> 00:26:17,718
and seeing how easy it is to dig in and fix those bugs when

508
00:26:17,718 --> 00:26:19,920
you've got a test pointing right at them,

509
00:26:19,920 --> 00:26:21,421
you'll start to really appreciate

510
00:26:21,421 --> 00:26:22,281
having the tests there.

511
00:26:24,287 --> 00:26:27,670
The last thing that kills us is a lack of buy-in or a lack of discipline.

512
00:26:27,670 --> 00:26:27,951
Right?

513
00:26:27,951 --> 00:26:30,513
And in the games industry, we often tend to be cowboys.

514
00:26:30,513 --> 00:26:31,334
We're pretty arrogant.

515
00:26:31,334 --> 00:26:34,417
We know that we work in a really hard industry and we're all pretty

516
00:26:34,417 --> 00:26:35,277
smart to be here.

517
00:26:36,795 --> 00:26:42,678
But that doesn't change the fact that tests will let us be more effective, work faster.

518
00:26:42,678 --> 00:26:47,741
So there are times when it's not the right time to do it.

519
00:26:47,741 --> 00:26:52,203
As I said right now, we've got a big milestone. And I just came back onto CSN recently.

520
00:26:52,203 --> 00:26:55,345
And as I did, I started, especially because I've been working on this talk,

521
00:26:55,345 --> 00:26:56,585
so I've been thinking about it a lot.

522
00:26:56,926 --> 00:27:01,913
like, you know, let's try this out. Let's, you know, when we move a task into the review column,

523
00:27:01,913 --> 00:27:04,697
just write on there where the tests are, and then the reviewer can go and run the

524
00:27:04,697 --> 00:27:08,042
tests and look at it that way, maybe instead of having an online code review.

525
00:27:08,785 --> 00:27:11,127
And I immediately got back from the project manager,

526
00:27:11,127 --> 00:27:12,909
how long is that gonna take?

527
00:27:12,909 --> 00:27:15,591
Because we've got this really tight milestone.

528
00:27:15,591 --> 00:27:16,211
Do we have time for it?

529
00:27:16,211 --> 00:27:19,174
And my answer was, well, it's not gonna cost me any time

530
00:27:19,174 --> 00:27:20,955
because I'm gonna build the test anyway.

531
00:27:20,955 --> 00:27:24,698
I can't not test my code, that's ridiculous.

532
00:27:24,698 --> 00:27:27,020
But, well, we do have some guys on the team

533
00:27:27,020 --> 00:27:28,501
who've been doing testing with me and,

534
00:27:29,762 --> 00:27:32,524
who are definitely up to speed and bought into it,

535
00:27:32,524 --> 00:27:33,345
we have a couple of guys

536
00:27:33,345 --> 00:27:34,766
who haven't really drunk the Kool-Aid yet.

537
00:27:34,766 --> 00:27:37,529
And I will concede that maybe this week

538
00:27:37,529 --> 00:27:39,630
isn't the week for them to try and figure out

539
00:27:39,630 --> 00:27:40,591
how to start testing.

540
00:27:40,591 --> 00:27:43,694
You know, fair enough, but we have to circle back.

541
00:27:43,694 --> 00:27:46,336
And the project manager is totally on board with,

542
00:27:46,336 --> 00:27:48,558
yes, we want this, maybe just not right now.

543
00:27:48,558 --> 00:27:49,939
So you have to circle back.

544
00:27:49,939 --> 00:27:51,700
You have to have that discipline to,

545
00:27:51,700 --> 00:27:54,342
even when you set it aside for a little while,

546
00:27:54,342 --> 00:27:55,743
to come back to it.

547
00:27:57,933 --> 00:27:59,974
And so at the end of the day, my answer to that,

548
00:27:59,974 --> 00:28:01,614
like how long is this gonna take,

549
00:28:01,614 --> 00:28:03,415
is we don't have time to not write tests.

550
00:28:03,415 --> 00:28:08,457
Because there's some overhead and startup costs to be sure.

551
00:28:08,457 --> 00:28:11,999
But once you get going, they will improve your velocity.

552
00:28:11,999 --> 00:28:13,379
You will notice it.

553
00:28:13,379 --> 00:28:16,641
And especially they will help you

554
00:28:16,641 --> 00:28:19,982
when you get to that crazy end stage

555
00:28:19,982 --> 00:28:23,104
where any mistake could sink the game, right?

556
00:28:23,104 --> 00:28:24,104
Just before you ship.

557
00:28:25,045 --> 00:28:31,267
having that safety net in place, having the ability to better test the code yourself before

558
00:28:31,267 --> 00:28:37,169
you throw it to QA, all of that is really going to help in that end stage get it out the door part.

559
00:28:37,169 --> 00:28:41,610
But if you've given up on it before then, then you won't have that to help you.

560
00:28:41,610 --> 00:28:48,793
So that's all I've got. Thank you for listening. I hope this has helped. I've been wanting to

561
00:28:48,793 --> 00:28:52,994
give this talk for a while now, and it's, you know, really been trying to figure out what is it

562
00:28:53,545 --> 00:29:01,751
that's made it different for me, that caused it to just flip on and start working. So hopefully

563
00:29:01,751 --> 00:29:06,334
this is helpful. As promised, here's the contact information. If you want to talk about AI,

564
00:29:06,334 --> 00:29:10,457
talk about testing, definitely reach out. I love talking about that kind of stuff.

565
00:29:10,457 --> 00:29:15,820
If you're looking for some help with some tools or looking for some help building your AI,

566
00:29:15,820 --> 00:29:21,784
reach out about that too. I love building AI and that is something that we can help you out with.

567
00:29:23,627 --> 00:29:29,871
So that's it. Again, thank you for listening, and I will see you on the other side.

