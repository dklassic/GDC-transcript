1
00:00:04,095 --> 00:00:08,139
all right. We have achieved a quorum up here for this. For

2
00:00:08,159 --> 00:00:11,101
those of you who have not ‑‑ are not familiar with our short

3
00:00:11,161 --> 00:00:14,724
form sessions, we have three of them this year. One of them, of

4
00:00:14,784 --> 00:00:17,367
course, being the rant session which is a perennial favorite.

5
00:00:18,154 --> 00:00:21,415
tomorrow we have a new one that we're introducing AI disaster

6
00:00:21,435 --> 00:00:24,776
stories. That should be entertaining. But this is one

7
00:00:24,796 --> 00:00:27,817
that we started a few years ago that has gotten a lot of good

8
00:00:27,837 --> 00:00:31,058
feedback over the years. Basically what we're saying is

9
00:00:31,458 --> 00:00:35,419
what is the simplest AI trick in the book that you have used and

10
00:00:35,479 --> 00:00:39,381
gotten a lot of mileage out of? So let me change slide decks.

11
00:00:40,241 --> 00:00:42,442
And I'm going to turn it over to our five guys. They have about

12
00:00:42,602 --> 00:00:45,903
five minutes each. Don't blink. Don't bother taking notes

13
00:00:45,923 --> 00:00:47,503
because these things go quickly.

14
00:00:49,739 --> 00:00:49,899
Let's go.

15
00:00:49,919 --> 00:00:49,959
OK?

16
00:00:49,979 --> 00:00:50,019
OK.

17
00:00:50,039 --> 00:00:50,760
Thank you.

18
00:00:50,820 --> 00:00:51,000
Thank you.

19
00:00:51,020 --> 00:00:51,840
Thank you.

20
00:00:52,081 --> 00:00:56,583
Thank you.

21
00:00:56,603 --> 00:00:56,784
Thank you.

22
00:00:56,804 --> 00:00:57,684
OK, my name is Steve Rabin.

23
00:00:57,744 --> 00:00:59,705
And for my simplest AI trick in the book,

24
00:00:59,725 --> 00:01:01,547
I actually have two tricks I'm going to cheat here.

25
00:01:02,287 --> 00:01:04,108
My first trick is agent reaction time.

26
00:01:04,148 --> 00:01:06,790
And I kind of just wanted to ask the question,

27
00:01:07,130 --> 00:01:09,792
if an AI sees the player, how long

28
00:01:09,832 --> 00:01:11,933
should it be before the AI reacts?

29
00:01:12,433 --> 00:01:13,914
I mean, intuitively, we know this

30
00:01:13,934 --> 00:01:16,796
should be like more than 0 seconds and less than 1.

31
00:01:16,896 --> 00:01:18,317
But should it be a quarter of a second?

32
00:01:18,357 --> 00:01:19,318
Should it be a half a second?

33
00:01:19,921 --> 00:01:22,365
What should we really choose as our reaction time?

34
00:01:22,926 --> 00:01:25,149
Well, psychologists and neuroscientists

35
00:01:25,189 --> 00:01:26,992
have been studying this for over 100 years,

36
00:01:27,693 --> 00:01:28,914
and we do have some answers.

37
00:01:29,796 --> 00:01:32,098
So, there's several different types of reaction time.

38
00:01:32,158 --> 00:01:33,300
So there's two I'm gonna talk about.

39
00:01:33,360 --> 00:01:34,821
One is simple reaction time.

40
00:01:35,402 --> 00:01:37,424
And this one, to start with,

41
00:01:37,564 --> 00:01:39,366
is just you're looking at a stimulus

42
00:01:39,446 --> 00:01:41,268
and the moment you see the stimulus,

43
00:01:41,288 --> 00:01:42,309
you say hit a button.

44
00:01:42,589 --> 00:01:45,452
So in an AI context, imagine that we have the AI

45
00:01:45,492 --> 00:01:47,274
and they're aiming at a doorway

46
00:01:47,414 --> 00:01:49,356
and the moment anything comes to that doorway,

47
00:01:49,637 --> 00:01:50,438
they're gonna pull the trigger.

48
00:01:51,218 --> 00:01:51,839
How long does that take?

49
00:01:52,206 --> 00:01:53,447
How long does it take in a human?

50
00:01:54,167 --> 00:01:57,168
So we're told by psychologists it takes about 0.2 seconds

51
00:01:57,308 --> 00:01:58,469
for that simple reaction time.

52
00:01:58,949 --> 00:01:59,849
If you want to try this yourself,

53
00:01:59,909 --> 00:02:01,730
you can go to humanbenchmark.com

54
00:02:01,750 --> 00:02:03,851
and they've had millions of people try this

55
00:02:04,592 --> 00:02:07,973
and we see that the median time for them is 0.25 seconds.

56
00:02:08,593 --> 00:02:10,674
Interestingly enough, this is for vision.

57
00:02:11,535 --> 00:02:14,016
Audio, humans have a faster reaction time

58
00:02:14,056 --> 00:02:17,858
of about 0.15 seconds and fastest of all is touch.

59
00:02:18,773 --> 00:02:20,834
and it's probably just due to the amount of cognitive

60
00:02:21,235 --> 00:02:23,776
processing that has to occur for each of those.

61
00:02:24,416 --> 00:02:26,177
So the other type of reaction time we want to look at

62
00:02:26,237 --> 00:02:27,958
is go no go reaction time.

63
00:02:28,438 --> 00:02:30,759
So this, let's go back to the scenario with the AI,

64
00:02:30,799 --> 00:02:32,079
he's aiming at the doorway.

65
00:02:32,520 --> 00:02:35,641
Now, through the doorway, a human's gonna appear,

66
00:02:35,781 --> 00:02:38,182
now they could be a fellow teammate or an enemy.

67
00:02:38,702 --> 00:02:41,163
So the AI's gonna make the go no go decision,

68
00:02:41,284 --> 00:02:42,724
do I pull the trigger, right?

69
00:02:43,184 --> 00:02:45,165
Anyone who plays first person shooters games

70
00:02:45,525 --> 00:02:46,686
make this decision all the time.

71
00:02:47,486 --> 00:02:48,067
How long does it take?

72
00:02:48,548 --> 00:02:50,510
Takes more time than .2 seconds, doesn't it?

73
00:02:50,790 --> 00:02:52,692
You don't want to make a mistake and shoot your teammate.

74
00:02:53,312 --> 00:02:57,155
So psychologists tell us .4 seconds for the go no go.

75
00:02:58,236 --> 00:02:59,898
So now of course, these are baseline numbers

76
00:02:59,938 --> 00:03:00,918
and it's always worse than that.

77
00:03:01,038 --> 00:03:03,400
So if you want to model being distracted,

78
00:03:03,480 --> 00:03:04,421
you're going to add time.

79
00:03:05,062 --> 00:03:07,123
Sometimes the stimulus is hard to identify

80
00:03:07,343 --> 00:03:09,765
and maybe you want to model that, you need to add some time.

81
00:03:10,206 --> 00:03:14,609
Maybe you're also kind of, the AI agent also needs to aim

82
00:03:14,709 --> 00:03:15,850
and that takes time too.

83
00:03:16,311 --> 00:03:18,272
So we just talked about kind of the simplest cases.

84
00:03:18,312 --> 00:03:20,532
So you probably want to add time in addition to that.

85
00:03:21,372 --> 00:03:21,533
OK.

86
00:03:21,553 --> 00:03:24,433
For my second trick, it's just a simple C++ trick

87
00:03:24,754 --> 00:03:26,274
to correlate enums and strings.

88
00:03:26,314 --> 00:03:28,175
So sometimes we have these enumerations,

89
00:03:28,215 --> 00:03:30,195
say these messages that the AI is going to deal with.

90
00:03:30,595 --> 00:03:33,956
And we want to be able to not have numbers in our debug logs

91
00:03:34,016 --> 00:03:36,117
or on the screen for debugging information.

92
00:03:36,137 --> 00:03:36,677
We want strings.

93
00:03:37,057 --> 00:03:39,198
But we don't have to maintain these two tables.

94
00:03:39,738 --> 00:03:41,118
This is problematic and stuff.

95
00:03:42,301 --> 00:03:45,582
And yet, and then we don't want to just use strings because,

96
00:03:46,823 --> 00:03:49,304
you know, if you have a string compare in your game,

97
00:03:49,444 --> 00:03:51,665
I'm going to find you and I'm going to shoot you.

98
00:03:53,146 --> 00:03:54,627
And it's going to be a simple reaction time.

99
00:03:57,048 --> 00:03:57,928
OK, so how are we going to do this?

100
00:03:57,948 --> 00:03:59,709
We're going to create a file called names.h.

101
00:03:59,749 --> 00:04:01,090
And we're going to put our enums in here.

102
00:04:01,110 --> 00:04:03,071
We're going to put the special register enum thing

103
00:04:03,091 --> 00:04:05,092
and then put our enums inside that.

104
00:04:05,172 --> 00:04:07,153
And notice that this file has no semicolons.

105
00:04:07,753 --> 00:04:10,395
So at compile time, we're going to read this file in twice.

106
00:04:10,908 --> 00:04:15,409
one time to create the enumerations and another time to create the strings. We're going to use

107
00:04:15,469 --> 00:04:19,871
macros and let me show you how it's done. So to create the enumeration we're going to do text

108
00:04:19,931 --> 00:04:25,733
replacement macros to replace whatever is that X is with X and a comma after it. And so we can

109
00:04:25,773 --> 00:04:29,734
create the enum and it just actually just reads in the whole thing at compile time, does all the

110
00:04:29,754 --> 00:04:36,016
text replacement and boom we have our enumeration. Then a second time we define that register enum

111
00:04:36,056 --> 00:04:38,217
as something else. This time we have this hash mark.

112
00:04:38,798 --> 00:04:43,120
X comma that's going to take the thing, put double quotes around it and then a comma after

113
00:04:43,160 --> 00:04:47,621
it and we can read it in, create a string table and now boom they match exactly and it will

114
00:04:47,681 --> 00:04:52,643
never be out of sync. So those are my two tricks. If that was too fast you can go to

115
00:04:52,683 --> 00:04:56,785
game AI pro.com and I put these slides up at the site. You can get them and they'll be

116
00:04:56,805 --> 00:04:57,985
there for about a week. Thank you.

117
00:05:05,553 --> 00:05:10,336
Good afternoon. My name is Jonathan Adamchefsky. I'm a core programmer at Insomniac Games

118
00:05:10,416 --> 00:05:16,720
responsible for our navigation tools and engine systems. And my simplest trick today is to do

119
00:05:16,780 --> 00:05:24,685
with cleaning up navigation mesh for Sunset Overdrive. So Sunset City is the setting of the

120
00:05:24,705 --> 00:05:26,806
game Sunset Overdrive. It's a big detailed place.

121
00:05:27,835 --> 00:05:29,636
There's a lot of buildings, a lot of geometry.

122
00:05:29,776 --> 00:05:32,197
We take all those triangles, we feed them into

123
00:05:32,917 --> 00:05:35,758
our navigation mesh, the navigation mesh generator we use,

124
00:05:35,879 --> 00:05:38,920
recast, and it gives us back a great big mesh

125
00:05:39,860 --> 00:05:40,781
for the entire city.

126
00:05:42,482 --> 00:05:45,083
One of the problems with this, or one of the details

127
00:05:45,123 --> 00:05:47,384
of this that becomes a problem is that this is made up

128
00:05:47,424 --> 00:05:48,865
of a number of separate islands.

129
00:05:49,385 --> 00:05:51,426
So to illustrate that as clearly as I can,

130
00:05:52,326 --> 00:05:55,228
in this view of a building, there is an island

131
00:05:55,668 --> 00:05:56,928
on the awning here.

132
00:05:57,393 --> 00:05:58,774
There are three islands on the roof.

133
00:06:00,035 --> 00:06:01,616
And the ground, that big green area,

134
00:06:01,676 --> 00:06:03,317
is one great big island of NavMesh

135
00:06:03,357 --> 00:06:04,598
that spans the entire city.

136
00:06:05,278 --> 00:06:08,420
The problem comes not with those islands, which

137
00:06:08,640 --> 00:06:12,002
we expect bots to be able to climb over to get up and down

138
00:06:12,022 --> 00:06:13,783
off the building, but inside the building,

139
00:06:14,263 --> 00:06:17,005
there are two more islands contained in there.

140
00:06:17,205 --> 00:06:18,746
And it's these type of islands that

141
00:06:18,786 --> 00:06:20,327
are a continuous source of bugs.

142
00:06:20,787 --> 00:06:21,948
We don't want these islands.

143
00:06:22,508 --> 00:06:25,069
To illustrate again really quickly, shipping container,

144
00:06:25,450 --> 00:06:26,050
island on the top.

145
00:06:26,840 --> 00:06:32,263
another island inside it. So the sorts of bugs that come from this include, uh,

146
00:06:33,124 --> 00:06:37,746
performance problems where, uh, a bot is trying to find a path from a connected

147
00:06:37,886 --> 00:06:42,509
island to an island to which there is no link. A disconnected island. And so we

148
00:06:42,529 --> 00:06:47,011
spend CPU time doing a path search for something that can never possibly succeed.

149
00:06:48,721 --> 00:06:51,544
there are any number of game breaking bugs that can come as a

150
00:06:51,584 --> 00:06:54,927
result of these. So say for example an enemy is blown up

151
00:06:54,987 --> 00:06:58,269
flies through a window on a building which somehow ended up

152
00:06:58,310 --> 00:07:02,353
without collision on it. Ends up inside. Checks to say am I on

153
00:07:02,373 --> 00:07:06,577
nav mesh? Yes I am. Tries to find paths out. Can't find paths

154
00:07:06,677 --> 00:07:09,079
out. The player can't see the bot either. Can't kill it. Can't

155
00:07:09,099 --> 00:07:14,324
finish the mission. Unhappy player. It's a bug. So to clean

156
00:07:14,404 --> 00:07:15,425
up this problem

157
00:07:16,136 --> 00:07:20,798
In the past, what has happened is the design team has had to go through and by hand identify

158
00:07:22,559 --> 00:07:26,621
islands that were not connected and try to mark them up and to have them excluded.

159
00:07:27,481 --> 00:07:32,003
That's a tedious process, that's buggy, it's something we'd love to do automatically.

160
00:07:32,243 --> 00:07:37,586
And we were able to do it by saying, what do we know about the game world?

161
00:07:37,626 --> 00:07:39,167
What do we know about the game environment?

162
00:07:39,207 --> 00:07:41,748
What can we reason about to automate this process?

163
00:07:43,237 --> 00:07:47,600
what we could reason about was markup we have. So take for example what I tried to start

164
00:07:47,620 --> 00:07:53,225
with which was spawn volume. So a spawn volume is a volume place that will find a random

165
00:07:53,285 --> 00:07:58,449
location on navmesh inside the spawn volume and put a bot there. And of course you want

166
00:07:58,710 --> 00:08:02,533
that navmesh to be there. And so you can use that as a starting point and flood fill

167
00:08:03,013 --> 00:08:07,337
throughout the islands from one to one following the links which you can see the purple lines

168
00:08:07,617 --> 00:08:09,779
in the image there show links between islands.

169
00:08:11,016 --> 00:08:12,758
and you can find the reachable parts of the game.

170
00:08:13,098 --> 00:08:17,344
The problem with that is that spawn volumes are sometimes really, really big.

171
00:08:17,704 --> 00:08:21,188
A hundred meters or more, depending on the sort of setup you have.

172
00:08:21,649 --> 00:08:24,553
And by the time you get that big, there's a really good chance you're going to capture

173
00:08:24,673 --> 00:08:29,479
some disconnected island and accidentally mark it as being connected and something to keep.

174
00:08:30,099 --> 00:08:35,147
And so we used a less, in some ways, a more crude approach,

175
00:08:35,227 --> 00:08:38,091
rather than looking where enemies or where bots can come from,

176
00:08:38,411 --> 00:08:41,716
just saying what's been marked up as being connected and keep those things.

177
00:08:42,116 --> 00:08:43,058
And that's a simple...

178
00:08:44,077 --> 00:08:48,402
trick, a simple tool for marking this up. It's something that's easy to explain and to

179
00:08:48,442 --> 00:08:53,207
understand. It's something that's easy to reason about. And it meant that across all of

180
00:08:53,247 --> 00:08:58,752
Sunset City we had a big improvement in quality with a small amount of extra work. We

181
00:08:58,772 --> 00:09:00,474
were able to get rid of about 25% of the triangles.

182
00:09:02,816 --> 00:09:08,740
uh, in disconnected mesh, reducing it from about 400,000 to about 300,000. So if you're using an

183
00:09:08,780 --> 00:09:13,764
automated tool like Recast, uh, I would highly encourage you to spend the time looking at what

184
00:09:13,844 --> 00:09:19,187
you know about your game and what you can apply to that to improve the quality of it, save time

185
00:09:19,207 --> 00:09:24,451
for your designers, save time, uh, give better information for your AI programmers to reason

186
00:09:24,491 --> 00:09:27,853
about and overall end up with better games. Thank you.

187
00:09:35,617 --> 00:09:39,360
So my trick is a generic way to contain all types of data.

188
00:09:39,781 --> 00:09:41,443
Hopefully everybody's familiar with blackboards

189
00:09:41,543 --> 00:09:42,504
as we use them in games.

190
00:09:42,564 --> 00:09:44,646
I'm not thinking traditional blackboard architectures here,

191
00:09:45,126 --> 00:09:46,568
but the kinds of blackboards we have in games.

192
00:09:47,048 --> 00:09:48,890
If you're not, there's a fantastic master class

193
00:09:49,030 --> 00:09:52,534
on AIgamedev.com with Damian Isla and Alex Champendard.

194
00:09:52,954 --> 00:09:53,335
Go look it up.

195
00:09:54,952 --> 00:09:58,534
And by the way, small trick, I keep two blackboards.

196
00:09:58,714 --> 00:09:59,915
Well, really lots of blackboards, right?

197
00:09:59,935 --> 00:10:01,276
So I have the global blackboard

198
00:10:01,616 --> 00:10:04,437
that all the entities can look at to share information.

199
00:10:05,038 --> 00:10:06,999
But then each entity has its own blackboard

200
00:10:07,019 --> 00:10:08,780
where they can keep entity-specific information

201
00:10:08,840 --> 00:10:10,381
like the list of all the other entities

202
00:10:10,441 --> 00:10:11,661
that they can see, for instance.

203
00:10:12,782 --> 00:10:14,763
But that's not really what I wanted to dig into today.

204
00:10:14,963 --> 00:10:15,824
Why is that not advancing?

205
00:10:15,884 --> 00:10:16,144
There we go.

206
00:10:18,274 --> 00:10:22,618
All of my blackboards and also my entities, so I started out with blackboards that were sort of

207
00:10:22,658 --> 00:10:27,663
messy, right? I just had lots of hand selected values that were written on there. Um, and over

208
00:10:27,683 --> 00:10:31,367
time I wanted to be able to put things on them much more easily. So I came up with this idea of a

209
00:10:31,407 --> 00:10:33,669
generic data store, which is really just a hash table.

210
00:10:34,270 --> 00:10:38,772
um, that stores key value pairs. My blackboards inherit from it, my entities also inherit from it.

211
00:10:39,113 --> 00:10:44,316
Now I have the standard way to store data. Um, things that want to look up data or want to store

212
00:10:44,356 --> 00:10:48,478
data don't have to care where they're supposed to store it up. So in the configuration I can say

213
00:10:48,878 --> 00:10:54,422
go look up the value name such and such and look for it on the entity that you're gonna shoot at.

214
00:10:54,522 --> 00:10:59,144
Right? See if that entity is an enemy, for instance. Uh, or whatever other value you need to look for.

215
00:11:00,103 --> 00:11:03,168
The keys are just strings, so I've gone a different route from Steve.

216
00:11:03,188 --> 00:11:05,511
Instead of using enums, I hash all of my strings,

217
00:11:06,453 --> 00:11:09,097
and then my string compares are just integer compares.

218
00:11:09,898 --> 00:11:11,961
So that's another simplest trick to figure out.

219
00:11:13,607 --> 00:11:16,708
The value can be anything. And this is the real power of it, right?

220
00:11:17,108 --> 00:11:21,390
I can store ints, I can store booleans, I can store floats, I can store pointers to objects,

221
00:11:21,830 --> 00:11:26,412
I can store collections of objects. Whatever needs to get stored and shared and passed around,

222
00:11:26,972 --> 00:11:32,115
I can store it. The trick is that I need to make a custom data element. All of my data elements

223
00:11:32,155 --> 00:11:36,016
need to inherit from the same base class so that I can put them in my container together,

224
00:11:36,216 --> 00:11:37,497
because C++ is strongly typed.

225
00:11:38,177 --> 00:11:39,839
So I just have a generic base class.

226
00:11:40,159 --> 00:11:41,200
It has two functions on it.

227
00:11:41,821 --> 00:11:45,064
GetDataType lets me check that the data type is what I think it is.

228
00:11:45,084 --> 00:11:47,146
It's just runtime type checking.

229
00:11:48,908 --> 00:11:49,688
And get is bool.

230
00:11:50,749 --> 00:11:53,770
I didn't have this at first, but it turns out that it's really useful to be able to

231
00:11:53,810 --> 00:11:55,912
check a boolean value for anything.

232
00:11:56,352 --> 00:12:01,495
Because often, I don't, you know, I have some consideration that doesn't want to look up

233
00:12:01,535 --> 00:12:03,457
an object or know what type of object it is.

234
00:12:03,517 --> 00:12:06,158
It just wants to treat it as a boolean and know if it exists or not.

235
00:12:06,599 --> 00:12:09,821
So if I can get a boolean for anything, that turns out to be really powerful.

236
00:12:11,525 --> 00:12:13,467
Inheriting from that is a templated base class

237
00:12:14,287 --> 00:12:17,150
that just takes the type of object as a template argument

238
00:12:17,771 --> 00:12:19,632
and has the functions to get the data value.

239
00:12:19,993 --> 00:12:22,315
It also has some functions that you can implement

240
00:12:22,935 --> 00:12:24,156
to set the data value.

241
00:12:25,057 --> 00:12:27,500
Some things may be implemented so that you can't set them,

242
00:12:27,620 --> 00:12:28,601
some so that you can.

243
00:12:29,141 --> 00:12:31,103
Some can only be set when you construct it.

244
00:12:32,024 --> 00:12:34,486
So there's a canSet function that by default returns false

245
00:12:34,526 --> 00:12:36,948
and a setDataValue that by default asserts.

246
00:12:40,148 --> 00:12:42,089
Inheriting from that is the simple data element,

247
00:12:42,469 --> 00:12:44,931
which just implements all of those functions.

248
00:12:45,552 --> 00:12:46,532
So it stores a value.

249
00:12:46,592 --> 00:12:48,274
When you set it, it just overwrites the value

250
00:12:48,294 --> 00:12:48,854
that it stores.

251
00:12:49,214 --> 00:12:50,755
And then I can store integers, for instance,

252
00:12:50,876 --> 00:12:52,036
by just inheriting from that

253
00:12:52,417 --> 00:12:53,978
and setting the template argument to integer

254
00:12:54,518 --> 00:12:56,340
and implementing the getDataType function

255
00:12:56,800 --> 00:12:58,821
so that I know what type of data element it is.

256
00:13:00,813 --> 00:13:03,195
Object pointers are a little more complicated, but really not much.

257
00:13:03,895 --> 00:13:10,378
When I do object pointers, often I want to be able to have both storage for pointers

258
00:13:10,399 --> 00:13:14,000
that owns the object and will delete it when it gets taken out of the store, and also storage

259
00:13:14,020 --> 00:13:16,882
for things that aren't owned, because both of those turn out to be useful.

260
00:13:17,382 --> 00:13:21,364
So I'll have a base class that specifies the data type, and then I'll have two different

261
00:13:21,384 --> 00:13:22,845
subclasses for owned and unowned.

262
00:13:23,665 --> 00:13:25,646
And that's really kind of all there is to it.

263
00:13:37,949 --> 00:13:44,172
Hi everyone, my name is Reg Graham. So I'm going to start by

264
00:13:44,192 --> 00:13:51,054
introducing the master of ceremonies, Caesar. Let's see if

265
00:13:51,074 --> 00:13:57,357
the sound is playing. No audio is playing. Imagine amazing audio

266
00:13:57,377 --> 00:14:00,278
happening. I'm not going to sing. There you go.

267
00:14:06,567 --> 00:14:07,587
Hey, look at that.

268
00:14:07,647 --> 00:14:08,708
This is nice.

269
00:14:08,908 --> 00:14:09,408
It's moving.

270
00:14:09,428 --> 00:14:10,409
That's all it's doing, folks.

271
00:14:11,409 --> 00:14:12,990
I have my wonderful CA helper here,

272
00:14:13,030 --> 00:14:14,791
who is going to shepherd him along.

273
00:14:15,691 --> 00:14:17,992
He may do sad and terrible things.

274
00:14:18,533 --> 00:14:20,394
He's a very, very simple little robot

275
00:14:20,414 --> 00:14:22,535
that I decided to build in maybe about a week.

276
00:14:22,915 --> 00:14:24,496
Can you hold him up and then set him down,

277
00:14:24,516 --> 00:14:25,796
maybe going up in that direction?

278
00:14:27,017 --> 00:14:28,098
It's very, very simple.

279
00:14:28,138 --> 00:14:28,918
Here, I will send that.

280
00:14:29,238 --> 00:14:31,499
So at the end of, yeah, just let him go somewhere.

281
00:14:32,840 --> 00:14:34,461
Somewhere not too complicated.

282
00:14:36,613 --> 00:14:39,715
So at the end of The Sims 4, I was like, well, what do I want

283
00:14:39,755 --> 00:14:42,737
to do? I don't really want to work on another side project

284
00:14:42,757 --> 00:14:45,418
that's like another game. I want to do something completely

285
00:14:45,458 --> 00:14:48,320
different. So I decided I was going to try my hand at a little

286
00:14:48,340 --> 00:14:51,422
bit of robotics. This is incredibly simple. I use the

287
00:14:51,462 --> 00:14:55,844
Arduino Uno. It has a 16 megahertz clock and 2K of SRAM

288
00:14:55,864 --> 00:14:58,466
for those who don't know what it is. And this is what he looks

289
00:14:58,526 --> 00:15:02,188
like if you were to see him nice and up close. That's going to be

290
00:15:02,228 --> 00:15:03,529
a sad corner for him over there.

291
00:15:05,135 --> 00:15:07,056
What he has is two continuous motion servos.

292
00:15:07,816 --> 00:15:08,596
That's what lets him move.

293
00:15:08,837 --> 00:15:11,418
He has two infrared LEDs along with two sensors.

294
00:15:12,058 --> 00:15:13,739
If he completely explodes, you can turn him off

295
00:15:13,799 --> 00:15:15,119
by pressing the little back thing.

296
00:15:17,397 --> 00:15:20,979
What happens is the IR sensors will, or the IR LEDs will send

297
00:15:21,140 --> 00:15:24,842
out infrared light signals. What that does is it reflects off of

298
00:15:24,903 --> 00:15:27,304
something and gets hit by these sensors right here. If he

299
00:15:27,344 --> 00:15:30,287
detects that there's something there, he'll turn. Now things

300
00:15:30,347 --> 00:15:33,469
love to soak infrared light, so we have whisker switches as

301
00:15:33,509 --> 00:15:36,131
well. The whisker switches, when he hits something, he'll hit

302
00:15:36,191 --> 00:15:39,714
it, he'll back up, he might be doing that right now. He'll

303
00:15:39,754 --> 00:15:42,736
stop, back up, go around because he's hit something particularly

304
00:15:42,777 --> 00:15:43,037
bad.

305
00:15:45,282 --> 00:15:48,185
a slight spoiler alert in order to get him to even work in this

306
00:15:48,285 --> 00:15:52,369
room I had to put tape over these IR sensors because there's

307
00:15:52,409 --> 00:15:55,011
a hell of a lot of infrared signal happening in this room.

308
00:15:55,232 --> 00:15:59,095
So he just freaked out. He just was afraid and alone. This is

309
00:15:59,135 --> 00:16:02,318
an incredibly simple robot. Oh I have two I have three debug

310
00:16:02,458 --> 00:16:05,021
LEDs. He has a blue light on right now which is his move

311
00:16:05,081 --> 00:16:07,783
forward state. This is this is your debugger if you've ever

312
00:16:07,803 --> 00:16:10,225
done anything in robotics you're lucky that you have that.

313
00:16:12,047 --> 00:16:17,170
So I want to show you just the software side which is it's 1100 lines of basic C++ style code.

314
00:16:17,250 --> 00:16:18,531
He has a simple state machine.

315
00:16:18,871 --> 00:16:23,574
This is an incredibly trivial robot from anyone who's ever done anything with robotics.

316
00:16:23,594 --> 00:16:25,095
This is like stupidly simple.

317
00:16:25,255 --> 00:16:27,676
I did this in maybe a week including all the hardware.

318
00:16:28,377 --> 00:16:31,198
So that's really all that he is.

319
00:16:32,159 --> 00:16:33,400
But why am I talking about this?

320
00:16:33,840 --> 00:16:38,143
Because for me it helped me learn what it's like to program in what I call the real world.

321
00:16:38,653 --> 00:16:40,473
the actual world that we live in today,

322
00:16:40,533 --> 00:16:42,594
which is a much harder problem to solve.

323
00:16:43,694 --> 00:16:47,055
There are, in fact, entire tracks of academia

324
00:16:47,295 --> 00:16:50,455
and in the real world about how to solve

325
00:16:50,475 --> 00:16:52,296
some of the particularly hard problems

326
00:16:52,476 --> 00:16:54,256
of navigating a room such as this.

327
00:16:55,316 --> 00:16:56,257
He's probably exploded.

328
00:16:56,277 --> 00:16:57,557
There's a switch that you can pull back

329
00:16:57,597 --> 00:16:58,457
if he's completely dead.

330
00:17:00,237 --> 00:17:01,918
So, for example, this is his view.

331
00:17:02,598 --> 00:17:03,418
This is all I get.

332
00:17:03,898 --> 00:17:05,879
I basically get what is effectively the same

333
00:17:05,939 --> 00:17:08,119
as two ray traces and two collision detectors.

334
00:17:09,428 --> 00:17:14,031
Those are on pins 13, 12, 4 and 3 which are either 5 volts or 0 volts which means I have

335
00:17:14,071 --> 00:17:16,853
a 4 bit world representation at this point.

336
00:17:17,253 --> 00:17:18,053
Very very simple.

337
00:17:18,954 --> 00:17:22,736
The key here is that there's no easy way to call get position.

338
00:17:23,297 --> 00:17:27,679
We are all very spoiled by get position, get orientation, any of those things and that

339
00:17:27,739 --> 00:17:29,621
is one thing that creating this little robot taught me.

340
00:17:30,001 --> 00:17:30,641
Where am I?

341
00:17:31,021 --> 00:17:31,782
I have no idea.

342
00:17:32,162 --> 00:17:33,863
I could very well be here.

343
00:17:34,664 --> 00:17:37,886
And there'd be no way that I would be able to detect that that's there, except that,

344
00:17:38,106 --> 00:17:41,528
oh, my left pin is up, is 5 volts.

345
00:17:41,548 --> 00:17:41,688
So...

346
00:17:44,412 --> 00:17:46,572
That's, like I said, there's whole tracks to kind of do this.

347
00:17:46,633 --> 00:17:50,294
So his performance in a beautiful specially designed room,

348
00:17:50,914 --> 00:17:53,235
which is my kitchen with all the doors closed, is 100%.

349
00:17:53,335 --> 00:17:55,536
He happily navigates,

350
00:17:55,556 --> 00:17:57,577
because there's no errant infrared signal,

351
00:17:57,617 --> 00:17:58,758
such as there are in this room.

352
00:17:59,598 --> 00:18:03,159
And all of the obstacles happily reflect infrared light,

353
00:18:03,199 --> 00:18:04,360
so he navigates perfectly.

354
00:18:04,440 --> 00:18:08,021
He never really hits collision, his whiskers at all.

355
00:18:08,482 --> 00:18:09,002
In the real world,

356
00:18:09,022 --> 00:18:10,602
he has maybe a one to two minute success rate.

357
00:18:11,703 --> 00:18:12,643
Is he still going back there?

358
00:18:13,535 --> 00:18:14,375
That surprises me.

359
00:18:15,575 --> 00:18:19,957
He usually reaches some point of massive sadness by now.

360
00:18:20,117 --> 00:18:21,558
Because he's very, very simple.

361
00:18:23,198 --> 00:18:24,839
Let me show you some of his mortal enemies.

362
00:18:25,259 --> 00:18:25,879
Here's one.

363
00:18:26,100 --> 00:18:27,280
These are my girlfriend's shoes.

364
00:18:27,920 --> 00:18:30,501
They're low enough that his sensors can't detect it.

365
00:18:30,841 --> 00:18:32,542
So he'll happily go over, and then he'll just go.

366
00:18:33,839 --> 00:18:36,581
and he'll flip over and then life is just terrible for him

367
00:18:36,621 --> 00:18:39,123
when he flips over. There are many ways to solve this of

368
00:18:39,163 --> 00:18:42,926
course. Here's the real, here's his real like the worst one.

369
00:18:43,547 --> 00:18:47,810
This is my dining room table. That beam there is high enough

370
00:18:47,830 --> 00:18:51,033
that his sensors don't see it. But low enough that all the, if

371
00:18:51,053 --> 00:18:53,535
you guys saw the picture, all those electronics that are

372
00:18:53,555 --> 00:18:55,737
sitting there on that bread board get scraped off.

373
00:18:58,510 --> 00:19:01,773
So that's not fun.

374
00:19:02,013 --> 00:19:03,514
He's gone under there twice now.

375
00:19:03,815 --> 00:19:06,557
And the first time I lost one of the infrared LEDs

376
00:19:06,577 --> 00:19:08,159
because it shorted and blew the LED.

377
00:19:08,199 --> 00:19:09,480
The other time I lost a sensor.

378
00:19:09,540 --> 00:19:10,581
So fun times.

379
00:19:12,283 --> 00:19:13,123
So where am I going with this?

380
00:19:13,183 --> 00:19:16,566
Well, let's take a counter example here,

381
00:19:16,586 --> 00:19:17,407
which is a Sims 4.

382
00:19:18,568 --> 00:19:20,470
On the Sims 4, I have a Sim sitting here at a computer

383
00:19:20,810 --> 00:19:21,951
and there's a guitar to her right.

384
00:19:22,860 --> 00:19:24,962
If I want to run an interaction that causes her to get up and

385
00:19:25,062 --> 00:19:27,764
use that guitar, it is actually really trivial to do that.

386
00:19:27,984 --> 00:19:30,746
Because I know what my position is now, and I know how to walk

387
00:19:30,846 --> 00:19:33,628
all the way over to the guitar where it is, I know the exact

388
00:19:33,768 --> 00:19:36,631
offset of where I need to stand to play the animation to get up

389
00:19:36,691 --> 00:19:40,353
and start playing the guitar. I have no, my robot has no clue

390
00:19:40,373 --> 00:19:42,575
where he is. He's wandering through the grace of this

391
00:19:42,615 --> 00:19:46,398
wonderful CA who is watching him go. That's really the only

392
00:19:46,438 --> 00:19:48,179
reason that he knows where he's going. Someone's going to hit

393
00:19:48,199 --> 00:19:50,201
the little whisker probably. It looks like you're about to test

394
00:19:50,261 --> 00:19:52,182
him. Oh God. This is going to go well.

395
00:19:53,637 --> 00:19:54,778
Yep, there he goes, see?

396
00:19:54,998 --> 00:19:55,599
And he does that.

397
00:19:55,839 --> 00:19:56,979
He keeps going, he's gonna freak out.

398
00:19:57,039 --> 00:19:57,800
Oh no, he's still going.

399
00:19:58,560 --> 00:19:59,961
So that's really it.

400
00:20:00,101 --> 00:20:02,423
So our characters live in this perfect digital world.

401
00:20:03,564 --> 00:20:05,205
And so what I'm saying is that you should go out

402
00:20:05,245 --> 00:20:07,026
and try and build an autonomous robot

403
00:20:07,546 --> 00:20:11,869
and try and see what it's like to solve this type of problem

404
00:20:11,889 --> 00:20:14,111
which I have quite unsuccessfully solved

405
00:20:14,171 --> 00:20:16,032
in my little one week of playing around.

406
00:20:16,712 --> 00:20:17,853
Experience programming in the real world

407
00:20:18,153 --> 00:20:19,754
and except for designing the room,

408
00:20:19,794 --> 00:20:22,276
you don't really get to cheat like we get to do in games.

409
00:20:22,576 --> 00:20:22,816
Thank you.

410
00:20:35,453 --> 00:20:35,694
Hi.

411
00:20:36,654 --> 00:20:39,096
Warframe is synonymous with space ninjas.

412
00:20:40,057 --> 00:20:43,039
And nothing is more ninja than acrobatic parkour moves

413
00:20:43,279 --> 00:20:43,819
and wall running.

414
00:20:45,360 --> 00:20:47,862
Wall running was added for the players

415
00:20:47,902 --> 00:20:50,564
quite early on in the closed beta of Warframe.

416
00:20:50,984 --> 00:20:52,345
And it changed the game up dramatically.

417
00:20:52,945 --> 00:20:55,287
Players can wall run on pretty much any near surface,

418
00:20:55,887 --> 00:20:57,248
any near vertical surface in the game.

419
00:20:57,508 --> 00:21:00,650
And we support this through dynamic runtime sweeps

420
00:21:00,730 --> 00:21:03,692
and calculations to keep them glued to the walls,

421
00:21:04,173 --> 00:21:04,893
defying gravity.

422
00:21:06,352 --> 00:21:08,913
However, this is still one of the more challenging maneuvers

423
00:21:09,153 --> 00:21:10,213
for new players to pull off.

424
00:21:12,194 --> 00:21:13,815
Last year, we added specters to the game.

425
00:21:14,895 --> 00:21:18,877
Specters are NPC-controlled bots that are kind of duplicates

426
00:21:19,177 --> 00:21:20,298
of players' warframes.

427
00:21:20,718 --> 00:21:23,219
They have the same loadout and weapons and equipment

428
00:21:23,239 --> 00:21:24,580
and abilities that the players have.

429
00:21:25,700 --> 00:21:27,601
Initially, they were limited to just a single type

430
00:21:27,641 --> 00:21:28,742
of mission in the game, where they would

431
00:21:28,762 --> 00:21:29,962
be the opposition for the players.

432
00:21:31,201 --> 00:21:33,443
But soon enough, this feature evolved,

433
00:21:33,784 --> 00:21:36,446
and now players can actually craft their own specters

434
00:21:36,486 --> 00:21:39,249
to take with them as allies into any mission in the game.

435
00:21:40,931 --> 00:21:43,573
So these specters have to be able to do everything

436
00:21:43,593 --> 00:21:45,475
the players can do, and they have

437
00:21:45,495 --> 00:21:47,597
to be able to keep up with the player as the player moves

438
00:21:47,617 --> 00:21:48,378
through the environment.

439
00:21:49,980 --> 00:21:51,702
And that includes running on walls.

440
00:21:52,903 --> 00:21:55,425
But how would you get an NPC to run on a wall?

441
00:21:57,905 --> 00:21:59,166
Well, the animation and physics side

442
00:21:59,186 --> 00:22:00,747
is already taken care of for our players.

443
00:22:01,107 --> 00:22:03,009
So the big challenge comes with identifying

444
00:22:03,349 --> 00:22:05,130
where the NPCs can wall run.

445
00:22:06,592 --> 00:22:09,974
And this means having either specific bridge actions placed

446
00:22:09,994 --> 00:22:13,377
in the level by level designers to identify where

447
00:22:13,417 --> 00:22:16,620
these actions can be performed, or having some kind of nav

448
00:22:16,640 --> 00:22:17,280
mesh on the walls.

449
00:22:17,761 --> 00:22:19,742
And these either need to be placed manually,

450
00:22:20,343 --> 00:22:22,164
or you have to come up with some smart algorithm

451
00:22:22,204 --> 00:22:25,106
to automatically detect these areas for you.

452
00:22:26,882 --> 00:22:29,164
Our levels in Warframe are all procedurally generated,

453
00:22:29,884 --> 00:22:32,026
and we combine level chunks together at runtime

454
00:22:32,186 --> 00:22:33,427
to create the runtime level.

455
00:22:34,648 --> 00:22:36,509
And we have a huge amount of level chunks

456
00:22:36,669 --> 00:22:37,710
already released for our game.

457
00:22:37,930 --> 00:22:39,031
We've got hundreds of these things,

458
00:22:39,691 --> 00:22:42,453
and they're all just got their own special characteristics.

459
00:22:43,574 --> 00:22:46,136
So it would take ages for level designers

460
00:22:46,156 --> 00:22:47,737
to have to go through and manually mark up

461
00:22:47,997 --> 00:22:48,818
all these level blocks.

462
00:22:49,979 --> 00:22:51,260
And that would also be very error prone.

463
00:22:52,955 --> 00:22:55,357
Our level geometry is also quite complex

464
00:22:55,397 --> 00:22:56,197
with the collision mesh,

465
00:22:56,878 --> 00:22:58,499
and coming up with a foolproof algorithm

466
00:22:58,719 --> 00:22:59,860
would have taken much more time

467
00:22:59,900 --> 00:23:01,201
than we really had to spend on it.

468
00:23:02,662 --> 00:23:05,604
However, we do have thousands of active players

469
00:23:06,485 --> 00:23:07,685
playing the game every day,

470
00:23:08,946 --> 00:23:11,188
and they are managing to wall run just fine.

471
00:23:11,228 --> 00:23:12,189
Well, most of them are, anyway.

472
00:23:13,530 --> 00:23:15,311
So what if we could leverage our player base

473
00:23:16,011 --> 00:23:18,213
to teach our AI where it can wall run?

474
00:23:21,095 --> 00:23:22,236
So that's exactly what we do.

475
00:23:23,007 --> 00:23:25,549
Every time the player performs a wall run, we drop breadcrumbs

476
00:23:26,129 --> 00:23:28,710
from where he jumps off the ground, where he connects with the wall,

477
00:23:29,250 --> 00:23:31,572
where he jumped off the wall, and where he landed back on the ground again.

478
00:23:33,112 --> 00:23:36,314
Since players can jump all over the place, we need to validate that we get a good sequence.

479
00:23:36,354 --> 00:23:40,536
We need to know that a jump off the ground, connect with the wall,

480
00:23:41,257 --> 00:23:43,518
move along the wall, jump off the wall, land back on the ground again.

481
00:23:44,938 --> 00:23:49,140
We need to then validate that our initial jump point and our final landing point

482
00:23:49,181 --> 00:23:51,242
are both on navmesh and not in some weird...

483
00:23:51,743 --> 00:23:52,805
part of the level.

484
00:23:54,166 --> 00:23:55,347
Once we've got the valid sequence,

485
00:23:56,088 --> 00:23:58,730
we can dynamically create an average for the NPCs

486
00:23:59,051 --> 00:24:01,934
to follow that maps onto that wall run action.

487
00:24:04,136 --> 00:24:06,338
So we only need to do just some clustering and filtering

488
00:24:06,378 --> 00:24:09,461
to ensure that we don't add many multiple variants

489
00:24:09,501 --> 00:24:12,224
of the same link with just very slightly different offsets.

490
00:24:13,125 --> 00:24:14,286
And now the players can follow the,

491
00:24:14,867 --> 00:24:16,008
the NPCs can follow the player.

492
00:24:18,645 --> 00:24:21,047
Currently, we keep these bridges around for the remainder

493
00:24:21,087 --> 00:24:21,828
of the current session.

494
00:24:23,650 --> 00:24:25,971
And we have a pool around the players

495
00:24:26,132 --> 00:24:28,594
so that the ones closer to the players we keep alive longer,

496
00:24:28,634 --> 00:24:30,555
and the ones that are further away we discard so that we

497
00:24:30,575 --> 00:24:32,357
don't waste our memory too much.

498
00:24:33,578 --> 00:24:35,519
But since we're an online game, this feature

499
00:24:35,539 --> 00:24:36,860
will improve and evolve over time.

500
00:24:36,920 --> 00:24:40,243
And we can then upload these links to a database.

501
00:24:41,424 --> 00:24:45,107
And then we can either manually patch our maps afterwards

502
00:24:45,187 --> 00:24:46,508
and release them in the next update.

503
00:24:47,842 --> 00:24:49,683
Or we could just pull those links down dynamically

504
00:24:49,703 --> 00:24:51,844
from the database at runtime and make these links persistent

505
00:24:51,884 --> 00:24:52,905
across multiple sessions.

506
00:24:53,985 --> 00:24:56,166
So in the future, we could potentially

507
00:24:56,206 --> 00:24:58,527
have players teaching NPCs where to wall run

508
00:24:59,008 --> 00:25:01,849
so that NPCs can teach new players where to wall run.

509
00:25:02,629 --> 00:25:03,890
And how awesome is that concept?

