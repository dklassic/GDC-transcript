1
00:00:07,967 --> 00:00:08,527
Hi, everyone.

2
00:00:09,788 --> 00:00:11,209
Thanks for attending our session.

3
00:00:11,249 --> 00:00:15,091
It's pretty late in the day, but thanks for making it out to hear our talk.

4
00:00:16,071 --> 00:00:18,512
This is Tune Rendering in Hi-Fi Rush.

5
00:00:19,693 --> 00:00:30,258
And before we start, GDC told us to remind you to make sure your cell phones don't make noise and fill out the survey after our talk.

6
00:00:34,838 --> 00:00:38,901
Okay, we'd like to start off the talk with brief speaker introductions.

7
00:00:39,441 --> 00:00:40,622
Hi, I'm Kosuke.

8
00:00:41,142 --> 00:00:44,885
I've been working as a graphics programmer at Tango Game Arts since 2011.

9
00:00:46,546 --> 00:00:52,270
For Hi-Fi Rush, I worked as lead graphics programmer working on our core tune rendering.

10
00:00:53,190 --> 00:01:00,315
I went from bloody VFX for zombie headshots and moody survival horror lighting to tune rendering.

11
00:01:06,479 --> 00:01:08,561
Hi, I'm Takashi Komada.

12
00:01:09,821 --> 00:01:12,784
I am a graphics and physics programmer.

13
00:01:14,565 --> 00:01:19,729
I've been working as a programmer at Tang Gameworks since 2016.

14
00:01:22,110 --> 00:01:26,654
On Hi-Fi Rush, I was a graphics, physics, and animation programmer.

15
00:01:32,523 --> 00:01:34,463
Here's the agenda for today's talk.

16
00:01:35,124 --> 00:01:43,586
I'll cover the core Toon rendering topics in the blue frame, and Komada-san will present our ToonFace shadow implementation in the green frame.

17
00:01:46,206 --> 00:01:49,927
Okay, I'm going to start off with a brief introduction of our game.

18
00:01:52,788 --> 00:01:57,189
So before I start, how many people here have played our game?

19
00:01:57,469 --> 00:01:58,269
Can you raise your hand?

20
00:01:59,269 --> 00:02:01,210
Oh wow, that's a lot, thank you.

21
00:02:02,321 --> 00:02:02,541
Okay.

22
00:02:03,062 --> 00:02:03,502
Yeah!

23
00:02:04,302 --> 00:02:08,485
Okay, great.

24
00:02:08,745 --> 00:02:18,271
Okay, but some people didn't raise their hands, so not all of you have played our game, so I'd like to introduce our presentation's pop-up characters first.

25
00:02:18,952 --> 00:02:23,114
The character on the left, Kale, is one of the enemy characters in the game.

26
00:02:23,795 --> 00:02:28,558
Since he's an evil guy, he'll mostly be making difficult demands for the graphics team.

27
00:02:29,358 --> 00:02:29,899
The character...

28
00:02:32,970 --> 00:02:36,631
The character in the middle, Chai, is the main protagonist of the game.

29
00:02:37,151 --> 00:02:41,532
Since he's our friendly hero, he'll mostly be making enthusiastic comments.

30
00:02:42,433 --> 00:02:45,634
And finally, the robot on the right is John.

31
00:02:46,634 --> 00:03:00,738
Despite not having a catchy food name, John made a strong creative push for our tomb visuals, had a conveniently available texture, and is Hi-Fi Rush's creative director, so I've included his comments.

32
00:03:04,616 --> 00:03:11,021
Okay, it's the main topic of our talk today, but Hi-Fi Rush is a game utilizing toon rendering.

33
00:03:11,942 --> 00:03:15,865
A lot of games use toon rendering for characters, but not the environment.

34
00:03:16,366 --> 00:03:19,749
In our game, everything is rendered in a toon style.

35
00:03:20,749 --> 00:03:29,857
A big challenge for the graphics team was how to utilize Unreal Engine 4's modern graphics pipeline and make it work for a 2D toon look.

36
00:03:32,768 --> 00:03:45,877
Another defining characteristic of our game is that we're a rhythm action game that requires a rock-solid 60 FPS in order to minimize input latency and provide the best gameplay feel.

37
00:03:47,078 --> 00:03:53,262
Programmers and artists were told from the very start of development, FPS is top priority.

38
00:03:54,403 --> 00:04:01,188
But at the same time, we were going to support the new Gen 9 hardware, and the team wanted to pursue great graphics

39
00:04:01,633 --> 00:04:03,555
that would do justice to the hardware.

40
00:04:04,996 --> 00:04:12,844
With goals of great graphics, the keywords that our art director defined for the team were sharp, clean, and colorful.

41
00:04:15,427 --> 00:04:24,356
I'll go over the technical makeup of our attempt at great graphics in more detail, but notice that two of our keywords were sharp and clean.

42
00:04:25,615 --> 00:04:34,661
Image quality was very important to us, and in addition to high frame rate, one of the key technical features of our game is its high resolution.

43
00:04:35,802 --> 00:04:43,487
We aim for native resolutions on our console targets for sharp, clean, artifact-free image quality.

44
00:04:44,648 --> 00:04:51,012
We're aware of super-resolution tech, and we support super-resolution plugins for PC, and they're great.

45
00:04:51,991 --> 00:04:59,216
Because our resolution is high to begin with, they allowed us to push the limits of our PC low-end specs even further.

46
00:05:02,438 --> 00:05:10,764
Because we prioritized performance and image quality, a nagging fear during development was that people would be disappointed by our technology.

47
00:05:11,684 --> 00:05:18,569
In the end, it was a great win for us that the game's visual arts was well-received and we got great technical reviews.

48
00:05:19,588 --> 00:05:23,550
Balancing performance, resolution, and rendering features is hard.

49
00:05:24,531 --> 00:05:29,633
As graphics programmers, we're excited by new rendering tech and want great graphics.

50
00:05:30,214 --> 00:05:39,319
But our game emphasized performance and image quality, and the rendering features we chose for the game were carefully considered so we could hit our goals.

51
00:05:42,180 --> 00:05:45,682
If a graphics programmer were to introduce our game, that would be it.

52
00:05:46,977 --> 00:05:53,663
I'll now discuss our toon rendering, starting off with an explanation of the core tech, our deferred toon renderer.

53
00:05:56,145 --> 00:06:05,294
HiFiRush uses Unreal Engine 4, which out of the box is a photorealistic deferred renderer and not a toon renderer.

54
00:06:06,334 --> 00:06:13,481
The lighting is forced, but this is what HiFiRush looks like when toon rendering features are disabled from the game.

55
00:06:14,482 --> 00:06:27,465
The main point of the image is that if we were to use the default UE4 lighting, there would be gradation everywhere, and the image ends up looking too much like it's rendered using a 3D engine.

56
00:06:30,326 --> 00:06:33,987
This is the same scene rendered with Toon rendering features re-enabled.

57
00:06:34,687 --> 00:06:37,308
This is what we were going for as a Toon look.

58
00:06:38,368 --> 00:06:41,049
Shadow gradation is replaced with sharper shadows

59
00:06:41,550 --> 00:06:48,052
and our comic shader has been applied to the various 3D render passes, adding a 2D touch to the image.

60
00:06:49,073 --> 00:06:52,554
This is what sharp, clean, and colorful looks like for us.

61
00:06:55,715 --> 00:07:03,598
Compared to past games with strictly cel-shaded environments, we incorporate a lot of 3D lighting rendering features into the game.

62
00:07:04,618 --> 00:07:08,660
We added rendering passes like static shadow maps and decal-tuned lights

63
00:07:09,414 --> 00:07:18,638
But we also stylized and extended the excellent base UE4 graphics features, such as SSAO and SSR, and made them work for cell shading.

64
00:07:21,259 --> 00:07:26,281
It's possible to write a toon renderer without engine modification in UE4.

65
00:07:28,022 --> 00:07:37,946
In the simplest case of using UE4 post-process materials, the toon post-process is applied after the scene lighting is finished, and most of the rendering is complete.

66
00:07:39,878 --> 00:07:42,799
It's the simplest approach and we wanted to do better.

67
00:07:45,240 --> 00:07:54,764
Since we planned on supporting many lighting features, we wanted to be able to apply tune stylization to each lighting layer with their own stylization parameters.

68
00:07:56,825 --> 00:08:03,528
Another thing we wanted to improve on is that UE4 post-process materials are applied per camera.

69
00:08:04,368 --> 00:08:08,970
We felt that this was too restrictive and wanted to apply different tune colors

70
00:08:09,301 --> 00:08:13,204
and stylizations to different areas within the same camera.

71
00:08:15,825 --> 00:08:25,652
To achieve our goal, we customized Unreal Engine 4 and combined deferred lighting and tune post-process into a single deferred tune rendering pass.

72
00:08:27,833 --> 00:08:30,495
Here's a quick review of regular deferred rendering.

73
00:08:31,776 --> 00:08:35,438
Material information are rendered into G-buffer render targets

74
00:08:36,001 --> 00:08:39,323
and the lighting pass is decoupled from the geometry pass.

75
00:08:40,603 --> 00:08:49,348
Point lights are rendered with sphere geometry and spot lights are rendered with cone geometry in a pass independent from the geometry they are lighting.

76
00:08:51,849 --> 00:08:59,473
In a similar fashion, we want to decouple toon rendering into a pass separate from the mesh's actual geometry rendering.

77
00:09:00,514 --> 00:09:05,036
Our toon post-process volumes work like deferred lights except the shader

78
00:09:05,444 --> 00:09:06,424
is a post-process.

79
00:09:07,304 --> 00:09:14,826
Like deferred lights, our artists can freely move around the tune post-process volume to locally change the tune rendering.

80
00:09:18,287 --> 00:09:26,889
In the slide video, when I move the billboard mesh inside the smaller tune post-process volume, notice that its tune rendering changes.

81
00:09:28,010 --> 00:09:33,671
At its core, our tune post-process volumes are using standard deferred rendering calculations.

82
00:09:34,485 --> 00:09:46,668
We use the scene depth to recreate the world position and use G-buffer information to apply the volumes to post-processing on not the volume box geometry, but the underlying scene geometry.

83
00:09:49,809 --> 00:09:55,610
Our environment artists place many to post-process box volumes throughout our levels.

84
00:09:56,591 --> 00:10:02,312
By placing these volumes, our artists adjust to shading locally per volume

85
00:10:02,694 --> 00:10:04,555
within each area of the level.

86
00:10:08,298 --> 00:10:13,721
The above is a PIX4Windows capture of the timeline for our deferred tune rendering pipeline.

87
00:10:14,702 --> 00:10:25,889
I'm showing you the render passes that are executed in an actual scene in preparation for the tune post-process pass, the render pass of the vox volumes in the previous slides.

88
00:10:29,363 --> 00:10:33,728
quite a few render targets end up getting generated for the toon post process pass.

89
00:10:34,669 --> 00:10:41,216
My earlier test map was very simple looking, but there are quite a bit more lighting layers in an actual scene.

90
00:10:42,117 --> 00:10:48,645
Toon shaded environments tend to look simplified, but there are a lot of layers to our environmental lighting.

91
00:10:52,335 --> 00:11:03,700
Because our deferred toon rendering is a combination of toon lighting and toon post-process, notice that the scene color is completely dark except for emissives before the toon post-process rendering is applied.

92
00:11:04,941 --> 00:11:08,042
A regular deferred renderer has scene depth and G-buffers.

93
00:11:09,163 --> 00:11:17,587
For deferred toon rendering, we have scene depth, G-buffers, plus the various individual lighting pass results, all waiting to be applied.

94
00:11:21,325 --> 00:11:24,866
the TunePose process has available to it all these render targets.

95
00:11:25,566 --> 00:11:26,486
What do we do with them?

96
00:11:27,146 --> 00:11:38,449
Because we have all lighting results as input textures, as was one of our initial goals, we can apply comic stylization to each lighting layer with individual parameters.

97
00:11:41,929 --> 00:11:49,351
Because we apply all shadow types to the scene inside the TunePose process pass, we can easily control the visual look

98
00:11:49,741 --> 00:11:51,622
when different shadow types overlap.

99
00:11:52,522 --> 00:12:04,047
For example, when the player shadow is drawn inside our cascaded shadow maps, we can detect this overlap and adjust the player shadow darkness so it doesn't appear too dark or light.

100
00:12:05,008 --> 00:12:10,810
Stylized shadows and side shadows is a very cool tuned thing and we wanted to make it look good.

101
00:12:14,432 --> 00:12:17,673
UE4 has a great looking deferred rendering implementation

102
00:12:18,151 --> 00:12:22,174
and it was a natural progression for us to extend it to a deferred toon renderer.

103
00:12:23,315 --> 00:12:32,743
We tried to utilize UE4's strengths, but at the same time, didn't want to lose our own visual personality by using the engine too directly.

104
00:12:33,864 --> 00:12:42,411
Locally toon shading different areas by placing toon post process volumes like deferred lights seemed like good usability for our artists.

105
00:12:43,392 --> 00:12:47,315
Deferring all lighting and toon post processes into a single pass

106
00:12:47,782 --> 00:12:56,126
made sense because we wanted our artists to be able to control how different lighting layers combine and interact for Toon.

107
00:12:56,146 --> 00:13:02,429
Okay, that was an overview of our deferred Toon rendering.

108
00:13:03,090 --> 00:13:08,972
Next, I'd like to highlight unique aspects of our Toon lighting during deferred Toon rendering.

109
00:13:09,833 --> 00:13:13,755
I'll cover shadow color 3D textures and ambient cube maps.

110
00:13:14,619 --> 00:13:23,283
The major requirement for our Toon lighting was artists need to be able to add color and adjust brightness, but it can't look too 3D.

111
00:13:24,224 --> 00:13:31,027
To make the scene not look artificial for Toon, artists need to be able to paint the colors themselves.

112
00:13:34,308 --> 00:13:37,430
Environment artists need a way to give color to each location.

113
00:13:38,170 --> 00:13:41,692
Our art director's keywords were sharp, clean, and colorful,

114
00:13:42,492 --> 00:14:03,491
So it was important that artists be able to control the environment's shadows with the colors they wanted In the slide image, the shadow color is a uniform black This is what the scene looks like with shadow color volumes applied The black shadows are now properly colored with artist-authored shadow colors

115
00:14:04,403 --> 00:14:12,528
I'll explain in more detail in the following slides, but shadow color volumes work by mapping a 3D texture to a 3D world position.

116
00:14:15,210 --> 00:14:24,676
Here in the slide video, I'm adding a new local shadow color volume to the scene with a whiter, grayer shadow color 3D texture.

117
00:14:25,777 --> 00:14:30,600
The rendering of the shadow color volumes is like cartoon post-process volume rendering.

118
00:14:31,340 --> 00:14:33,902
The shadows are not applied to the volume

119
00:14:34,244 --> 00:14:39,226
box geometry, but are projected onto the geometry enclosed by the box.

120
00:14:41,768 --> 00:14:47,470
If we look carefully, the shadow color volume colors gradually become darker with increasing height.

121
00:14:48,291 --> 00:15:01,757
This positional color change happens because the enclosed surface world position is converted into the shadow color volumes normalized local 3D coordinates, and this coordinate is used to sample the 3D texture.

122
00:15:02,930 --> 00:15:31,061
The gradually changing colors inside the 3D textures are hand-adjusted by artists to give the desired shadow color nuance our art director wants for the scene Here's an interior scene and its corresponding shadow color 3D texture For interior scenes, our environment is initially unlit and in shadow and we light by adding lighting layers to this state

123
00:15:32,179 --> 00:15:40,563
Because the scene is initially in shadows, artists can use shadow color volumes to adjust the overall base color makeup of the scene.

124
00:15:43,644 --> 00:15:50,827
In addition to 3D textures for shadow colors, we also use cubemaps for post-process ambient brightness adjustments.

125
00:15:53,508 --> 00:15:59,911
Like with our shadow color volumes, we apply ambient cubemaps to the underlying geometry using a box volume.

126
00:16:01,235 --> 00:16:10,239
As mentioned earlier, our interior scenes are initially unlit, and to this state, we add lighting layers, one of which is ambient cubemaps.

127
00:16:12,960 --> 00:16:14,781
Cubemaps need a sampling direction.

128
00:16:15,361 --> 00:16:21,104
Because we are a deferred tune renderer, we can use a world normal stored in the G-buffer for this purpose.

129
00:16:23,765 --> 00:16:28,207
In the slide image, the ambient cubemap volume is being toggled on and off

130
00:16:29,266 --> 00:16:38,392
Notice that in the scene, the underside of the surface is lit brighter than the top and the sides, representing a difference in directional ambient brightness.

131
00:16:40,033 --> 00:16:46,437
This directional brightness comes from the cubemap texture, which our environment artists create by hand.

132
00:16:49,639 --> 00:16:54,142
Okay, in the next section, I'd like to talk about our comic shaders.

133
00:16:57,515 --> 00:17:05,097
It's a recognizable trait of our toon look, but we implemented a comic shader for rendering halftone dots and hatching lines.

134
00:17:07,478 --> 00:17:11,899
Halftone dots are the round dots that we apply to the lit portions of our lighting.

135
00:17:13,660 --> 00:17:18,561
Hatching lines are the rotated lines we apply to the dark shadowed areas of lighting.

136
00:17:21,702 --> 00:17:25,523
The goal of our toon renderer is to render a 3D world as 2D toon.

137
00:17:27,461 --> 00:17:38,307
Our comic shader is a stylization, but at the same time, it's an important element in our deferred tune rendering for making the world look less 3D and more 2D tune.

138
00:17:40,928 --> 00:17:44,550
Here's what a scene from our game looks like with the comic shader turned off.

139
00:17:45,410 --> 00:17:53,735
SSAO GI Bloom make the world look richer, but since we're just applying 3D engine functionality, the final image looks 3D.

140
00:17:55,413 --> 00:18:05,495
Also, the performance-oriented low sample count nature of some of our rendering passes become especially noticeable on our clean-tuned textures.

141
00:18:08,516 --> 00:18:11,596
Here's what the scene looks like with the comic shader enabled.

142
00:18:12,717 --> 00:18:18,898
The scene is stylized, but at the same time, gradation is removed, making everything look less 3D.

143
00:18:19,878 --> 00:18:24,459
The dirty look of GI and SSAO have been made sharper with lines and dots

144
00:18:25,000 --> 00:18:26,841
and the image looks much cleaner.

145
00:18:29,802 --> 00:18:32,643
Here's the comic shader on-off as an animation.

146
00:18:38,885 --> 00:18:42,506
2D sine distance functions are often used in procedural shaders.

147
00:18:43,126 --> 00:18:51,589
For our comic shaders, programmers use SDFs to create the comic shader halftones and hatching lines procedurally inside our shaders.

148
00:18:53,598 --> 00:19:00,080
We just do basic stuff in terms of SDF, but for clarity, I'll go over an example halftone shader.

149
00:19:01,260 --> 00:19:04,942
My example is a post-process, which uses screen space UVs.

150
00:19:06,062 --> 00:19:09,483
The first step is to calculate the distance from the center of the screen.

151
00:19:10,283 --> 00:19:14,045
If this distance is below the halftone radius, we draw a white color.

152
00:19:14,745 --> 00:19:18,566
If the distance is above the halftone radius, we draw a black color.

153
00:19:21,294 --> 00:19:27,537
We take into consideration the aspect ratio to go from an ellipse to a circle.

154
00:19:27,597 --> 00:19:34,600
We don't want large circular dots, but want multiple smaller dots in a grid across the screen.

155
00:19:35,600 --> 00:19:39,782
Using the FRAC instruction, we scale and wrap the screen space UVs.

156
00:19:44,003 --> 00:19:46,885
Art wanted halftones rotated 45 degrees.

157
00:19:47,805 --> 00:19:50,206
For this, we just rotate the grid UV.

158
00:19:52,861 --> 00:19:58,924
Because we are using a simple zero-one step function for the distance function threshold, aliasing can occur.

159
00:20:01,066 --> 00:20:08,850
By using smooth step instead of step, and alpha blending the boundary regions of the halftone dots, we can implement anti-aliasing.

160
00:20:10,831 --> 00:20:16,174
The area inside the yellow frame is the width of the smooth step function where AA is applied.

161
00:20:17,031 --> 00:20:31,300
Since we want to apply anti-aliasing only on the threshold border pixel, we use DDX, DDY instructions to calculate the per pixel rate of change of the distance function and use this value as the basis for our width.

162
00:20:34,622 --> 00:20:45,309
UE4's temporal AA blurs the halftones, so the AA is only obviously noticeable on halftones applied after TAA, such as our bloom halftones.

163
00:20:46,189 --> 00:20:53,272
The difference also becomes not very noticeable with camera movement, so the benefits of AA is somewhat limited for us.

164
00:20:53,892 --> 00:20:58,074
But we kept the calculations for the moments that the user might notice the difference.

165
00:21:00,355 --> 00:21:04,877
So that was an explanation of half tones are rendered using screen space UVs.

166
00:21:05,878 --> 00:21:10,140
Hatching lines are the same shader code, just with UVY fixed to zero.

167
00:21:12,821 --> 00:21:15,202
For effects such as bloom and volumetric fog,

168
00:21:15,765 --> 00:21:18,767
we use screen space UV coordinates in actual scenes.

169
00:21:19,567 --> 00:21:21,228
We don't do anything complicated.

170
00:21:21,729 --> 00:21:26,972
An example shader is close to how we render actual in-game screen space halftones.

171
00:21:29,534 --> 00:21:44,823
Screen space UVs work well for stuff without depth, such as bloom and volumetric fog, but on actual polygonal surfaces, we want our halftones and lines to look as though they are printed on the surface and not attached to the front of the camera.

172
00:21:45,626 --> 00:21:48,247
For these cases, we use world space UVs.

173
00:21:50,228 --> 00:22:00,194
To calculate the world space UV, we use the G-buffer world space normal to calculate the dominant axis of the surface and just project onto this axis's plane.

174
00:22:01,034 --> 00:22:14,001
For example, if the Z value is the largest direction of the world normal, we want to project onto the XY plane, and so we simply use a scaled world position XY as our UV coordinates.

175
00:22:16,072 --> 00:22:19,294
For intersections of planes, we don't use triplanar mapping.

176
00:22:19,934 --> 00:22:26,098
We experiment with it, but blending artifacts were noticeable, and we simply project onto a single plane.

177
00:22:27,038 --> 00:22:34,703
I didn't get complaints about the halftones and lines cutting off at the plane intersections, and the final implementation was kept simple.

178
00:22:37,645 --> 00:22:41,547
One final important feature of our comic shader

179
00:22:43,786 --> 00:22:50,791
Because we procedurally generate our halftones and lines, we can easily adjust their look based on the scene lighting conditions.

180
00:22:51,932 --> 00:22:55,534
We use scene luminance to adjust halftone and hatching line sizes.

181
00:22:56,415 --> 00:23:04,301
For the image in the slide, the GI halftones become larger the closer to the emissive light source, and smaller the further away.

182
00:23:05,241 --> 00:23:11,666
It's a simple technique that allows us to express the lighting's distance attenuation while avoiding gradation.

183
00:23:12,076 --> 00:23:14,557
which makes our scene look more computer generated.

184
00:23:17,678 --> 00:23:21,319
Okay, the next section I'd like to move on to are toon lights.

185
00:23:24,461 --> 00:23:29,883
Hi-Fi Rush's toon shading uses a simple two-tone lit shade toon shading model.

186
00:23:30,763 --> 00:23:41,347
The toon shading's lit shade calculation is not performed in a deferred pass, but is calculated by a global key light that is forward rendered in UE4's base pass.

187
00:23:43,837 --> 00:23:49,281
We chose to forward render our key lights because we could do so without UE4 engine modifications.

188
00:23:50,181 --> 00:24:03,890
In later stages of development, we began utilizing UE4 render commands for data passing and render thread delegates for render pass callbacks that would allow us to implement original render passes game side.

189
00:24:05,051 --> 00:24:12,716
We're now more experienced about how to approach UE4 engine modifications, but that realization came after our core tech was implemented.

190
00:24:15,131 --> 00:24:25,513
We eventually needed to support two key lights, and it may have been more performant to associate the key light with a tuned post-process volume and render it in the later deferred pass.

191
00:24:26,633 --> 00:24:30,674
Our lighting's mix of deferred and forward is probably something we can improve on.

192
00:24:33,294 --> 00:24:41,396
Besides key lights, artists can use familiar light actors such as point lights and spotlights to perform local environmental lighting.

193
00:24:44,093 --> 00:24:48,756
For placeable lights, again, we supported forward lights for the same reason as key lights.

194
00:24:49,797 --> 00:25:00,643
A lot of smaller teams probably struggle with this, but how much UE4 engine modification is safe is something we struggled with, especially in the earlier phases of development.

195
00:25:01,664 --> 00:25:12,551
We initially experimented with forward lights, but decal lights, which run in an original deferred pass, were easier to optimize and eventually more useful for our artists.

196
00:25:13,206 --> 00:25:18,330
My toon light explanation will focus on decal lights since they're more interesting.

197
00:25:21,253 --> 00:25:29,660
Usually with placeable light actors in a 3D engine, light distance attenuation is expressed with color gradation.

198
00:25:30,501 --> 00:25:36,746
For Hi-Fi Rush, this was a big no because using gradation led to the scene looking 3D.

199
00:25:38,608 --> 00:25:40,810
In addition to halftones and hatching lines,

200
00:25:41,431 --> 00:25:45,674
We use cutouts to 2D stylize our tuned light distance attenuation.

201
00:25:46,535 --> 00:25:51,899
The colors become darker the further away from the light source in cutout steps.

202
00:25:55,322 --> 00:25:57,163
The scene in the slide looks unlit.

203
00:25:59,305 --> 00:26:06,611
Add a decal light with cutout light attenuation and the scene is lit by a 3D light without making the scene look 3D.

204
00:26:07,792 --> 00:26:10,654
Decal lights support arbitrary cutout textures

205
00:26:11,576 --> 00:26:18,961
Our art director prepared seven cut-out texture patterns to give variation to the decal lights used throughout our maps.

206
00:26:21,962 --> 00:26:32,749
Decal lights are Hi-Fi Rush's deferred lights, and so when a decal light is placed in the world, they are deferred rendered with a sphere or cone geometry, just like regular deferred lights.

207
00:26:35,931 --> 00:26:38,933
Decal lights' namesake, and what makes them special,

208
00:26:39,491 --> 00:26:44,335
is that they can be assigned to a decal light decal volume to render as a decal.

209
00:26:45,636 --> 00:26:56,466
Environment artists can place lights as light sources in a traditional way, but they can limit the projection volume of the light separately using decal volumes.

210
00:27:00,789 --> 00:27:07,115
One obvious benefit of projecting to a decal volume is a smaller area to render and better performance.

211
00:27:09,113 --> 00:27:32,288
In addition to performance, decal lights provide finer artistic control over which parts of the environment the light affects For example, we can add a separate decal light with its own projection texture specifically to light the wall The scene displays a star cutout projection for the ground, but a tear cutout projection for the wall

212
00:27:39,301 --> 00:27:47,166
In The Evil Within 2, our PBR lights could use clip volumes to prevent spotlights from light leaking to the next room.

213
00:27:48,166 --> 00:27:53,730
Decal light decal volumes also function as clip volumes and can prevent light leaking.

214
00:27:58,072 --> 00:28:03,336
Some of you might be wondering, doesn't decal volumes mean characters are properly lit?

215
00:28:04,056 --> 00:28:07,318
Let's try lighting our game's hero, Chai, with a decal light.

216
00:28:10,137 --> 00:28:14,920
In HiFiRush, character lighting is a separate system from environmental lighting.

217
00:28:15,540 --> 00:28:18,402
Forward lights and decal lights don't affect characters.

218
00:28:22,484 --> 00:28:26,086
Next, I'd like to explain what we do for shadows in HiFiRush.

219
00:28:28,928 --> 00:28:35,412
Having proper shadows for the environment and characters is extremely important for quality, even in tune rendering.

220
00:28:36,434 --> 00:28:41,358
Shadows can be very performance intensive if applied without a strategy.

221
00:28:42,199 --> 00:28:45,462
In UE4, shadows look good, but can be costly.

222
00:28:46,503 --> 00:28:52,008
To balance quality and performance, we were very careful in how we chose to render our shadows.

223
00:28:54,770 --> 00:28:57,152
We limit shadow casting lights for performance.

224
00:28:58,013 --> 00:29:00,215
Toon lights are unable to cast shadows.

225
00:29:02,625 --> 00:29:07,966
For outdoor environmental shadows, we use UE4's standard cascaded shadow maps.

226
00:29:08,766 --> 00:29:22,409
We have our own pre-baked static shadow map system and use it for parts of directional light shadows for performance, but for the most part, we needed the extra quality that dynamic cascaded shadow maps provide us with.

227
00:29:24,790 --> 00:29:31,211
For dynamic shadows other than cascaded shadow maps, artists are required to use shadow-only lights.

228
00:29:32,290 --> 00:29:39,172
Shadow-only lights are customized UE4 PBR lights specializing in only casting dynamic shadows.

229
00:29:40,193 --> 00:29:46,655
Because we were going for a 2D look, having different lights for lighting and shadowing was not a problem.

230
00:29:50,476 --> 00:29:54,137
An exclusive shadow-only light was assigned to the player character.

231
00:29:55,358 --> 00:29:59,559
In outdoor areas, the player's shadow is not drawn by the cascaded shadow mod,

232
00:30:00,080 --> 00:30:03,262
but by this separate, player-exclusive shadow-only light.

233
00:30:06,705 --> 00:30:12,029
Giant bosses are allowed their own shadow-only light because their shadows can look very dramatic.

234
00:30:13,110 --> 00:30:20,896
The character shadow-only light in the slide doesn't cast shadows from the player or the environment and only casts shadows from the giant boss.

235
00:30:24,199 --> 00:30:28,222
Player shadows and some of our static shadow maps are drawn with stylization

236
00:30:28,592 --> 00:30:30,193
for the shadow-to-light transition.

237
00:30:31,353 --> 00:30:41,597
The hatching lines become thinner the further away the shadow becomes from the shadow casting object, representing a 2D toon-style shadow-to-light transition.

238
00:30:44,738 --> 00:30:49,620
Non-player characters use the more cost-effective capsule shadows for their shadowing.

239
00:30:50,660 --> 00:30:53,661
Capsule shadows are standard UE4 functionality.

240
00:30:54,582 --> 00:30:58,043
Artists prepare capsule shapes to approximate the character mesh

241
00:30:58,652 --> 00:31:06,674
and these shapes are used to calculate per pixel visibility towards a global light direction to approximate soft shadows.

242
00:31:07,754 --> 00:31:14,735
It wouldn't work for a photorealistic game, but we can get away with the blobby look of capsule shadows because we are tuned.

243
00:31:17,796 --> 00:31:22,337
Because capsule shadows don't require shadow casting local lights,

244
00:31:22,967 --> 00:31:28,930
we get cost-effective character shadows outdoors, indoors, regardless of lighting conditions.

245
00:31:32,873 --> 00:31:39,537
Capsule shadows become too large and disperse for our small characters that are floating in the air far away from the ground.

246
00:31:40,497 --> 00:31:45,020
For these characters, we implemented a simple AO volume decal system.

247
00:31:46,020 --> 00:31:50,423
CPU raycasts are used to find the proper decal placement world position.

248
00:31:53,007 --> 00:31:59,409
Finally, we also allow a single shadow-only spotlight for the environment team, and that's all they get.

249
00:32:03,470 --> 00:32:04,090
They worked hard.

250
00:32:05,211 --> 00:32:11,713
For the scene in the slide, a shadow-only light casts exclusively from the moving giant robot arms.

251
00:32:12,913 --> 00:32:19,075
The only thing shadow-only lights can do is cast shadows, but just like for the character boss shadows,

252
00:32:19,571 --> 00:32:23,312
A well-placed shadow spotlight can be very dramatic in a tuned look.

253
00:32:26,612 --> 00:32:28,913
I've mentioned we have a static shadow map system.

254
00:32:29,533 --> 00:32:32,854
I'd like to explain this system in more depth in this next section.

255
00:32:34,894 --> 00:32:37,775
Static shadow maps are offline baked shadow maps.

256
00:32:38,435 --> 00:32:42,976
They are important for us both in terms of performance and artist's ease of use.

257
00:32:44,216 --> 00:32:49,357
UE4 has a static shadow map system which is integrated into light mass baking

258
00:32:49,844 --> 00:32:55,247
but we created our own for better integration with our deferred tune rendering pipeline.

259
00:32:58,309 --> 00:33:00,530
Shadow mapping is composed of two steps.

260
00:33:01,130 --> 00:33:07,714
The first step is light space depth map generation from the perspective of the shadow casting light.

261
00:33:08,675 --> 00:33:15,198
The second step is comparing the pixel's light space depth against the depth map to generate the actual shadow map.

262
00:33:16,059 --> 00:33:18,120
What we pre-bake in static shadow maps

263
00:33:18,570 --> 00:33:20,550
is the first depth map capture step.

264
00:33:23,391 --> 00:33:27,272
In the slide image, I'm toggling on and off the static shadow map display.

265
00:33:28,292 --> 00:33:38,794
The environment team had strict limitations on dynamic shadow map usage, and interior environmental shadows will typically disappear completely without static shadow maps.

266
00:33:41,394 --> 00:33:47,175
By placing static shadow map actors in the environment, environment artists can use static shadow maps.

267
00:33:47,998 --> 00:33:58,224
The static shadow map actor is composed of two components, a scene capture camera for capturing the depth map and a deferred box volume for rendering the shadow map.

268
00:33:59,384 --> 00:34:07,388
When the static shadow map actor is selected, the captured depth map is displayed in the lower right corner of the screen in the editor.

269
00:34:09,930 --> 00:34:17,574
Artists use the depth map preview in the lower right portion of the screen to manually maximize depth map coverage of shadow casters

270
00:34:19,237 --> 00:34:21,078
to improve shadow map quality.

271
00:34:23,378 --> 00:34:35,401
Standard comparisons between the pixel's light space depth position and the depth map's light space depth position are performed to render a screen space shadow map inside the static shadow map decal volume.

272
00:34:38,141 --> 00:34:41,642
Without AA, our screen space shadow maps look very jaggy.

273
00:34:42,662 --> 00:34:46,643
We use 4x4 PCF for anti-aliasing our shadow maps.

274
00:34:48,973 --> 00:34:53,795
Here's a GIF animation of 4x4 PCF being toggled on and off.

275
00:34:54,715 --> 00:34:59,137
As you can see, the algorithm does a pretty good job of alleviating jaggies for us.

276
00:35:02,478 --> 00:35:06,700
Here's a screenshot of static shadow map camera placements in an actual scene.

277
00:35:07,640 --> 00:35:12,102
Many static shadow map cameras with small coverage are placed throughout our levels.

278
00:35:14,843 --> 00:35:17,764
Each static shadow map camera renders

279
00:35:18,234 --> 00:35:25,236
its own depth map and its associated render volume owns that static shadow map's depth map texture data.

280
00:35:27,857 --> 00:35:32,078
Even the small handrail in the slide image has its own static shadow map.

281
00:35:34,919 --> 00:35:41,841
Our artists use many static shadow map cameras, not just for artistic reasons, but for texture streaming efficiency as well.

282
00:35:42,761 --> 00:35:46,942
One of the first concerns we had when we considered using static shadow maps

283
00:35:47,247 --> 00:35:49,248
was memory usage and streaming hedges.

284
00:35:50,309 --> 00:36:01,617
We manage static shadow map texture streaming workloads by monitoring texture size and focusing on being able to efficiently distribute streaming across multiple frames.

285
00:36:02,558 --> 00:36:08,102
For this reason, we can't have individual static shadow map textures being too large.

286
00:36:09,423 --> 00:36:14,066
Our static shadow maps are placed in their own streaming level and within the streaming level

287
00:36:14,588 --> 00:36:21,253
We distribute texture streaming across multiple frames by placing a per frame streaming memory limit.

288
00:36:24,415 --> 00:36:28,878
The final topic I'd like to talk about is how we handle global illumination.

289
00:36:31,300 --> 00:36:35,002
Global illumination is being toggled on and off in the slide image.

290
00:36:35,703 --> 00:36:43,128
We felt supporting standard 3D lighting features in our tune rendering was important for quality, and this included GI.

291
00:36:45,014 --> 00:36:54,841
We decided early on that we wanted to try to use UE4 Lightmass since we were satisfied with its quality and baked lighting is great in terms of performance.

292
00:36:55,942 --> 00:37:07,330
At the same time, we also thought a workflow using Lightmass lightmaps was too costly for our artists due to needing to deal with lightmap UVs and possibly long GI bake times.

293
00:37:08,230 --> 00:37:14,635
Toon assets require artists' hand crafting for quality and all artists, including our environment team,

294
00:37:15,097 --> 00:37:17,018
were super busy throughout the project.

295
00:37:19,860 --> 00:37:24,302
We had noticed that lightmass volumetric lightmaps could be used for the environment.

296
00:37:25,583 --> 00:37:31,066
Lightmass volumetric lightmap light probes bake faster and don't require lightmap UVs.

297
00:37:32,027 --> 00:37:40,432
We decided we would customize the volumetric lightmap functionality with a focus on further improving bake iteration speed and usability.

298
00:37:42,728 --> 00:37:54,512
A big factor that allowed this customization is the fact that our game has a tuned art direction, and we can be artistically selective in which parts of the map we apply global illumination.

299
00:37:55,253 --> 00:38:02,435
In this slide image, only a small area around the window has global illumination, and that can be okay for our look.

300
00:38:05,896 --> 00:38:10,318
Here, the same level with the GI Light Probe debug display is enabled.

301
00:38:11,636 --> 00:38:20,803
The environment artist has decided to bake probes around strong emissives, but in areas without a strong light source, no probes are baked.

302
00:38:24,026 --> 00:38:31,552
UE4 has a functionality called Light Mass Importance Volumes that limit light probe baking to the area within the volume.

303
00:38:32,312 --> 00:38:38,137
We customized this functionality to implement our own global illumination lighting volume actor

304
00:38:39,113 --> 00:38:42,954
In Vanilla UE4, light probe data is stored per level.

305
00:38:43,735 --> 00:38:49,297
We customized UE4 so that in our game, light probe data can be stored per actor.

306
00:38:52,718 --> 00:38:58,500
I should mention that we did optimize the UE4 volumetric light map data to save memory.

307
00:38:59,300 --> 00:39:07,963
Because we only need directionless ambient global illumination, we cut down the light probe spherical harmonics 3D textures from eight to one

308
00:39:08,524 --> 00:39:10,104
and it's a huge memory saving.

309
00:39:12,405 --> 00:39:21,047
Since I emphasize bake iteration speed and usability as key points, I'll give a quick overview of what our GI bake workflow looks like.

310
00:39:21,908 --> 00:39:28,049
We start by enclosing the area we want to add global illumination to with a GI lighting volume.

311
00:39:30,210 --> 00:39:34,991
After the volume is placed, artists select from the menu, build selected volumes.

312
00:39:35,976 --> 00:39:43,622
A customized light mass GI baking code is executed, and the GI bake is limited to the area enclosed by the lighting volume.

313
00:39:44,543 --> 00:39:55,471
Bake times are dependent on light mass settings and PC specs, but as a general idea, for a standard dev PC at our company, a bake should finish in a minute or two.

314
00:39:56,932 --> 00:40:03,657
Since the bake is isolated to the selected actor, artists can iterate baking on specific areas quickly.

315
00:40:07,298 --> 00:40:12,019
The GI lighting volume contains parameter for both baking and rendering.

316
00:40:13,019 --> 00:40:21,901
An often used parameter for baking is the detail cell size parameter, which controls the distribution granularity of the generated light probes.

317
00:40:23,161 --> 00:40:27,862
Our environment artists use this parameter to balance bake quality and memory usage.

318
00:40:30,702 --> 00:40:34,863
Finally, the GI lighting volume not only defines the GI bake extent,

319
00:40:35,322 --> 00:40:37,483
but also serves as a rendering volume.

320
00:40:38,503 --> 00:40:43,105
Here, I'm toggling on-off the GI box rendering for a specific volume.

321
00:40:43,805 --> 00:40:47,867
Note how all the other volumes in the scene are unaffected by the toggling.

322
00:40:48,888 --> 00:40:57,831
Deferred rendering of box volume is a local lighting technique that is used throughout our game and makes a final presentation appearance in this slide.

323
00:40:59,712 --> 00:41:01,053
Here are my main references.

324
00:41:01,533 --> 00:41:04,194
Now I'm going to hand it off to Komada-san for a section

325
00:41:05,086 --> 00:41:07,407
our tech, our ToonFace shadow tech.

326
00:41:33,726 --> 00:41:38,489
I'm going to explain the face shadow of Hi-Fi Rush in this section.

327
00:41:42,231 --> 00:41:47,514
The self-shadows of the character in Hi-Fi Rush are in cel-shaded style.

328
00:41:48,995 --> 00:41:57,880
The shadowed and non-shadowed areas are clearly separated, and the shadowed areas are given a specified shadow color.

329
00:42:00,201 --> 00:42:01,602
With shadows like this,

330
00:42:02,520 --> 00:42:08,623
The quality is all about the choice of the shadow color and the shape of the shadow area.

331
00:42:10,744 --> 00:42:20,168
HiFiRush's art concept was sharp, clean, and colorful, so the shadows also needed to always have clean shapes.

332
00:42:24,370 --> 00:42:28,072
Whether pixels in the inner shadow area is determined by

333
00:42:28,976 --> 00:42:35,380
whether the dot product of the pixels, normals, and the right vector is less than the threshold.

334
00:42:37,441 --> 00:42:40,063
This is a typical method for cell shading.

335
00:42:42,644 --> 00:42:45,606
The vertex normal is used for the normal.

336
00:42:46,807 --> 00:42:50,109
However, this method is not used on the face.

337
00:42:54,632 --> 00:42:57,874
The face requires higher quality than other parts.

338
00:42:59,534 --> 00:43:05,358
However, there are problems in achieving the desired quality with vertex normal shadows.

339
00:43:07,699 --> 00:43:14,984
The first problem is that using vertex normals makes it difficult to create a smooth curve.

340
00:43:17,085 --> 00:43:25,551
As shown in the image on the right, depending on the direction of the light, the shadow shapes can become quite messy.

341
00:43:27,185 --> 00:43:35,768
It is because there is a limit to how much geometry can be divided, and the shadow shape is affected by how it is divided.

342
00:43:39,710 --> 00:43:48,673
The second problem is that the shape of the shadow created by vertex normals is easily broken by facial motion.

343
00:43:52,015 --> 00:43:55,496
When the bone orientation changes due to facial motion,

344
00:43:56,809 --> 00:44:03,073
the orientation of the vertex normals also changes, which unintentionally breaks the shadow shape.

345
00:44:05,394 --> 00:44:15,220
In this scene, where the facial expression is extreme, the shadow shape becomes considerably broken depending on the direction of the light.

346
00:44:18,743 --> 00:44:23,946
The third problem is that it is difficult for artists to make adjustments.

347
00:44:26,354 --> 00:44:38,343
Artists can adjust geometry and vertex normals, but it is very difficult for them to avoid problems one and two completely through manual adjustments.

348
00:44:40,725 --> 00:44:52,354
It is difficult to intuitively understand the resulting shape of the vertex normal and geometry adjustments in all the various lighting directions.

349
00:44:55,174 --> 00:45:04,660
Even if you use a normal map instead of vertex normals, problem one may be solved, but problems two and three will not be solved.

350
00:45:08,682 --> 00:45:16,266
To solve these vertex normal problems in HiFiRush, we used a height map-like texture.

351
00:45:18,067 --> 00:45:20,769
Internally, we call this texture a threshold map.

352
00:45:23,317 --> 00:45:26,601
I will explain how to authorize in later slides.

353
00:45:27,943 --> 00:45:30,526
But we'll first explain the calculations involved.

354
00:45:34,551 --> 00:45:42,721
First, calculate the angle between the horizontal component of the right direction and the forward direction of the head.

355
00:45:45,080 --> 00:45:52,966
The horizontal component here refers to the horizontal component in the cardinality system of the head bones.

356
00:45:55,288 --> 00:46:03,014
The threshold value is the angle divided by pi and normalized to a range of zero to one.

357
00:46:05,310 --> 00:46:17,682
then it is determined whether the area is shadow area or not based on whether the sample value of the threshold map is greater than the threshold value.

358
00:46:22,566 --> 00:46:30,554
Since only the horizontal component is considered, the shadow can only be moved in the horizontal direction.

359
00:46:33,339 --> 00:46:36,680
However, this is enough for HiFiRush.

360
00:46:40,501 --> 00:46:50,084
In this video, the light is shining on the right side of the face, but when it is on the left side, the texture is reversed horizontally.

361
00:46:53,188 --> 00:47:03,615
How to use this threshold map is a reproduction of the method introduced in the session by Mihoyo at Unity Seoul 2018.

362
00:47:03,755 --> 00:47:12,561
I will now explain how to author a threshold map.

363
00:47:14,302 --> 00:47:19,546
First, use a desiccator to bake the shadows of the face into textures

364
00:47:20,868 --> 00:47:30,957
by moving a directional light at fixed angles 180 degrees around the character, as shown in the image.

365
00:47:34,160 --> 00:47:39,184
We moved the light every five degrees, so we baked 36 textures.

366
00:47:41,306 --> 00:47:41,907
At this point,

367
00:47:43,331 --> 00:47:52,999
Shadows are shaded using the vertex normals so the shape may not be smooth or shadows may appear in unnecessary areas.

368
00:47:57,063 --> 00:48:01,566
These textures are then detached to the artist's satisfaction.

369
00:48:04,129 --> 00:48:10,394
This process creates a clean shape so artists don't have to create perfect vertex normals.

370
00:48:12,441 --> 00:48:18,924
As you can see, retouching textures is much more intuitive to adjust than vertex normals.

371
00:48:20,945 --> 00:48:25,528
Artists can preview the final look of the shadows in our DCC tool.

372
00:48:31,411 --> 00:48:41,916
Finally, using a dedicated in-house tool, all textures are interpreted like a distance field interpolation and merged into a single texture.

373
00:48:43,544 --> 00:48:45,225
The threshold map is now complete.

374
00:48:50,189 --> 00:48:56,313
I now review how threshold map solved our original vertex normal problems.

375
00:48:58,074 --> 00:49:08,522
Regarding problem one, the shape does not become a smooth curve with a vertex normal, but with a threshold map, it is always smooth as shown in the video.

376
00:49:10,916 --> 00:49:15,519
This is thanks to the artist adjusting the shadow shape through retouching.

377
00:49:17,921 --> 00:49:32,152
Also, since the textures are connected smoothly using distance field like interpolation, the shape changes smoothly when the direction of the light changes.

378
00:49:34,662 --> 00:49:46,225
As an aside, threshold maps have similar characteristics to distance-filled textures and are less prone to artifacts even when the resolution is lowered.

379
00:49:47,185 --> 00:49:55,888
However, in order to maintain a sharp shape even when the camera is zoomed in, we used 2K textures.

380
00:49:59,609 --> 00:50:00,209
Problem two,

381
00:50:01,397 --> 00:50:06,560
where the shape is broken due to facial motion does not occur with a threshold map.

382
00:50:09,302 --> 00:50:17,268
Because in case of threshold map, the shape is mapped with UV, so it's not affected by bones.

383
00:50:22,131 --> 00:50:26,594
As an example, let's change the direction of the light and compare.

384
00:50:28,595 --> 00:50:33,776
When shading with a threshold map, shadow shapes are clean in all right directions.

385
00:50:38,477 --> 00:50:43,679
Problem three is that shading using vertex normals is difficult for artists to adjust.

386
00:50:44,599 --> 00:50:52,401
Again, in the case of a threshold map, artists can intuitively modify the shape by retouching the baked textures.

387
00:50:55,267 --> 00:51:00,711
When shading using vertex normals, the vertex normals were directly used for shading.

388
00:51:01,511 --> 00:51:13,219
When shading using a threshold map, in between light baking and texture merging, there is a step where artists can make intuitively quality adjustments.

389
00:51:15,660 --> 00:51:19,623
This concludes the explanation of face shadows in our game.

390
00:51:20,464 --> 00:51:20,744
Thank you.

391
00:51:29,258 --> 00:51:35,762
Okay, that's it for the content of our presentation, but I'd like to end our talk with some final concluding words.

392
00:51:38,103 --> 00:51:46,428
So our game wanted to do a stylized cel-shaded look for both characters and the environment, and this presented unique rendering challenges.

393
00:51:47,308 --> 00:51:58,054
Unique problems call for unique solutions, and we developed an original deferred post-process volume approach for our attempt at tuned rendering.

394
00:51:58,902 --> 00:52:04,083
We're using UE4, and we adapted many 3D graphics features for toon rendering.

395
00:52:04,763 --> 00:52:09,104
We use well-established graphics techniques and build on the great works of others.

396
00:52:10,144 --> 00:52:13,305
We talked about tech today, but it's toon rendering.

397
00:52:13,725 --> 00:52:23,847
And as you can imagine, there was a lot of crafting and optimizations by our artists not covered today that ultimately determined the quality of the toon graphics.

398
00:52:24,747 --> 00:52:28,688
We had goals of rock-solid 60 FPS, high resolution,

399
00:52:29,167 --> 00:52:30,267
and great looking tune.

400
00:52:30,907 --> 00:52:35,728
And the tech we talked about today helped the HiFiRush team achieve these goals.

401
00:52:37,449 --> 00:52:48,350
And we had more tech we wanted to share info about, but probably be too much of us talking, so we didn't do that.

402
00:52:48,510 --> 00:52:56,712
But we do have bonus slides at the end of the presentation, so when the slides become available for download, everyone can read them.

403
00:52:59,875 --> 00:53:02,857
And our final page is our special thanks page.

404
00:53:03,278 --> 00:53:09,883
We get to present this stuff, but our tune rendering was made possible by the hard work of everyone on the HiFiRush team.

405
00:53:10,543 --> 00:53:16,688
Our final slide is a special thanks page to give a shout out to all the people who made today's talk possible.

406
00:53:18,789 --> 00:53:19,450
OK, that's it.

407
00:53:20,771 --> 00:53:21,911
So we have time for a

408
00:53:29,761 --> 00:53:35,259
A little bit of time for Q&A, so if people have questions, please go to the mics.

409
00:53:41,857 --> 00:53:43,498
Hi, I have a question.

410
00:53:44,219 --> 00:53:46,280
First of all, fantastic talk.

411
00:53:46,380 --> 00:53:58,928
Second, when you were talking about all the more physical 3D features, I couldn't help but notice that you didn't include other PBR inputs like roughness and metalness.

412
00:53:59,089 --> 00:54:02,111
Was that a conscious decision to exclude those because they didn't add anything?

413
00:54:02,331 --> 00:54:03,612
Or what was the thought process?

414
00:54:03,792 --> 00:54:11,637
And am I right that your final only texture inputs to the deferred PBR workflow or deferred lighting workflow was just color?

415
00:54:12,337 --> 00:54:13,717
Yes, we just use color.

416
00:54:14,258 --> 00:54:18,158
In fact, we do use roughness because we have SSR.

417
00:54:18,698 --> 00:54:24,160
So we use the standard UE4 SSR at its lowest setting.

418
00:54:24,720 --> 00:54:26,060
That's about one millisecond.

419
00:54:26,120 --> 00:54:30,101
But still, UE4 SSR is great at the lowest setting, and it looks good.

420
00:54:30,621 --> 00:54:35,182
And we apply a tune stylization to that SSR and use it.

421
00:54:35,622 --> 00:54:38,903
So we do use roughness, but metallic we don't need.

422
00:54:40,444 --> 00:54:42,406
Yeah, we don't do standard PBR.

423
00:54:43,026 --> 00:54:45,368
I think it's mostly base color and roughness for us.

424
00:54:46,389 --> 00:54:46,629
Got it.

425
00:54:46,709 --> 00:54:46,990
Thank you.

426
00:54:47,330 --> 00:54:52,955
And our bonus slides include a section on our G-buffer stencils.

427
00:54:53,435 --> 00:55:02,483
We actually use the UE4 G-buffer slots that we don't use for stencil bits that we use in our tune rendering.

428
00:55:03,023 --> 00:55:03,283
Got it.

429
00:55:03,323 --> 00:55:03,584
Thank you.

430
00:55:07,751 --> 00:55:13,392
Hi, how well did your artists receive this more unique lighting pipeline?

431
00:55:14,792 --> 00:55:15,872
I'm sorry, I couldn't catch.

432
00:55:16,433 --> 00:55:20,553
How well did your artists receive this kind of unique lighting pipeline?

433
00:55:21,553 --> 00:55:29,135
Well, we made the pipeline with artists, so I worked with the environment, lead environment artists to create the pipeline.

434
00:55:29,655 --> 00:55:36,456
And like our ambient, our shadow color volumes and our ambient cubemaps, I worked

435
00:55:37,402 --> 00:55:47,912
Part of that was suggested by them, and this was necessary for the look we were going for, so they were all in.

436
00:55:50,855 --> 00:55:51,796
Does that answer your question?

437
00:55:56,454 --> 00:55:58,555
Hi, I had a question about the threshold maps.

438
00:55:58,815 --> 00:56:03,637
So if I'm understanding correctly, are you creating a sprite for merging all of them together?

439
00:56:03,837 --> 00:56:08,959
And then are you doing any special processing for the base color textures to look sharp?

440
00:56:11,160 --> 00:56:13,881
Can you come back with that question later?

441
00:56:13,901 --> 00:56:14,061
OK.

442
00:56:14,081 --> 00:56:14,281
Sorry.

443
00:56:14,301 --> 00:56:14,621
Sorry.

444
00:56:25,080 --> 00:56:30,522
Hey, I noticed that you guys use a lot of shader code in your presentation here.

445
00:56:31,003 --> 00:56:36,605
I wanted to ask if there was an advantage over using shader code over node-based shader.

446
00:56:37,485 --> 00:56:42,247
We use shader code because our materials were all implemented by programmers.

447
00:56:43,107 --> 00:56:47,269
So it's actually more confusing for us to use shader code.

448
00:56:48,427 --> 00:56:58,132
And one of the benefits of using shader code, we save all our shader codes out into a text file and manage it through Perforce.

449
00:56:58,192 --> 00:57:02,153
And we can search what other programmers shader code easily.

450
00:57:02,233 --> 00:57:11,958
So it's easier for us to write, and it's easier for us to check up on the code that we wrote.

451
00:57:13,059 --> 00:57:13,219
Cool.

452
00:57:13,759 --> 00:57:13,959
Thank you.

453
00:57:21,823 --> 00:57:22,927
There's no more questions.

454
00:57:23,268 --> 00:57:24,493
Thanks for attending our talk.

