1
00:00:07,496 --> 00:00:21,579
So I'm Dave Churchill. Today I'll be talking about the hierarchical portfolio search system that I created to make the AI for Prismata. It's a complex name, but that was just to sell the paper. It's really simple, I promise.

2
00:00:22,959 --> 00:00:33,641
So I made this game with Lunark Studios, but now I'm a faculty member in the computer science department at Memorial University in Newfoundland, which is the easternmost rock in North America.

3
00:00:34,021 --> 00:00:35,782
So, Prismata.

4
00:00:36,880 --> 00:00:40,641
Prismata is a hybrid strategy game that we've been working on.

5
00:00:41,902 --> 00:00:44,142
Two-player game, alternating turns.

6
00:00:44,222 --> 00:00:46,342
You can think of it as sort of Hearthstone

7
00:00:46,503 --> 00:00:48,463
or Magic the Gathering meets StarCraft.

8
00:00:48,743 --> 00:00:51,984
So it's a card game without cards,

9
00:00:52,544 --> 00:00:55,244
and it's a real-time strategy game without the real time.

10
00:00:55,324 --> 00:00:57,405
So it's a really interesting strategic game.

11
00:00:57,885 --> 00:01:00,486
So before I get into the AI system for the game,

12
00:01:00,586 --> 00:01:01,546
I'm going to explain, like,

13
00:01:01,906 --> 00:01:03,426
just some basic properties about the game.

14
00:01:04,586 --> 00:01:04,687
So...

15
00:01:05,746 --> 00:01:06,827
The game has two players.

16
00:01:06,927 --> 00:01:10,611
Here we have the AI up on the top and the player, who's me,

17
00:01:10,831 --> 00:01:11,512
down on the bottom.

18
00:01:12,372 --> 00:01:13,754
And it's alternating turns.

19
00:01:14,014 --> 00:01:15,896
So that means I'll take my complete turn,

20
00:01:16,236 --> 00:01:18,398
and then the opponent will take their complete turn.

21
00:01:21,501 --> 00:01:23,283
So on the bottom half of the screen,

22
00:01:23,523 --> 00:01:25,525
you see my units, player one's units.

23
00:01:25,966 --> 00:01:27,207
And on the top half of the screen,

24
00:01:27,547 --> 00:01:28,848
you see player two's units.

25
00:01:30,947 --> 00:01:34,128
Also, each player has a certain number of resources.

26
00:01:34,448 --> 00:01:36,869
So there are five different resources in the game.

27
00:01:37,929 --> 00:01:40,390
Each of these can purchase a certain number of units.

28
00:01:40,530 --> 00:01:43,451
So certain technologies can only be purchased by certain

29
00:01:43,491 --> 00:01:43,931
resources.

30
00:01:44,591 --> 00:01:46,192
Each player has their own resource pool.

31
00:01:48,214 --> 00:01:52,537
Many of your units can be clicked to activate abilities.

32
00:01:52,737 --> 00:01:55,178
So for example here, I have the drone unit,

33
00:01:55,598 --> 00:01:58,680
which is sort of a worker type unit with an RTS flavor.

34
00:01:59,180 --> 00:02:01,702
And when I click on the drone unit, I get some gold.

35
00:02:02,162 --> 00:02:04,103
So each drone click gives me a gold,

36
00:02:04,784 --> 00:02:07,445
and each unit can only be clicked once per turn.

37
00:02:07,725 --> 00:02:09,306
So once I have some resources,

38
00:02:09,826 --> 00:02:11,467
you see over here on the left side

39
00:02:12,988 --> 00:02:14,309
is some purchasable units.

40
00:02:14,889 --> 00:02:19,991
So unlike most strategy card games, there's no hands or decks in Prismata.

41
00:02:20,391 --> 00:02:23,993
Instead, it's more like Dominion, if you've ever played the Dominion card game,

42
00:02:24,013 --> 00:02:27,154
where you have a shared pool of cards that you can purchase from,

43
00:02:28,514 --> 00:02:30,455
which are randomized at the start of the game.

44
00:02:31,095 --> 00:02:34,276
So unlike an AI for a game maybe like StarCraft, where we

45
00:02:34,316 --> 00:02:37,117
could hard code some build orders or something into the

46
00:02:37,177 --> 00:02:40,958
AI system, the starting state of this game is actually

47
00:02:41,018 --> 00:02:43,319
randomized, which leads to a lot of replayability.

48
00:02:43,859 --> 00:02:46,440
But it's actually really difficult to build an AI when

49
00:02:46,460 --> 00:02:47,800
your starting states are randomized.

50
00:02:48,660 --> 00:02:51,441
So in the game, we click to purchase some units.

51
00:02:51,881 --> 00:02:54,642
And then these units appear directly on the battlefield.

52
00:02:54,802 --> 00:02:55,942
So they don't go into our hand.

53
00:02:56,302 --> 00:02:57,463
They're right on the battlefield.

54
00:02:59,121 --> 00:03:03,667
And then we can attack with our units and defend with some of our units, and then we

55
00:03:03,707 --> 00:03:05,128
pass the turn to our opponent.

56
00:03:05,148 --> 00:03:07,812
So that's basically what a turn is in Prismata.

57
00:03:08,353 --> 00:03:13,760
And knowing the basic rules of the game helps with explaining the AI system that we're going

58
00:03:13,780 --> 00:03:14,340
to create for it.

59
00:03:15,558 --> 00:03:19,623
So two really interesting things about Prismata, which are different than many other strategy

60
00:03:19,643 --> 00:03:24,848
games, is that Prismata is perfect information, which means that there's nothing hidden by

61
00:03:25,009 --> 00:03:25,609
either player.

62
00:03:25,709 --> 00:03:29,574
So like I said, there's no fog of war, there's no decks, there's...

63
00:03:31,035 --> 00:03:32,196
there's no cards in hand.

64
00:03:32,977 --> 00:03:34,958
Also, it's completely deterministic.

65
00:03:35,318 --> 00:03:36,719
And so what this means is there's no

66
00:03:36,819 --> 00:03:37,940
randomness in the gameplay.

67
00:03:38,380 --> 00:03:41,822
So I'm not going to lay a Ragnaros and hope it hits my

68
00:03:41,842 --> 00:03:44,043
opponent's face instead of my own.

69
00:03:44,984 --> 00:03:47,746
Everything I do in the game, there's no randomness, beyond

70
00:03:47,786 --> 00:03:49,927
the initial starting state, which is randomized.

71
00:03:49,947 --> 00:03:50,007
So.

72
00:03:55,188 --> 00:03:58,289
excuse me, some of the A.I. design goals that we had in

73
00:03:58,309 --> 00:04:01,170
Prismata, you know, before you write the A.I. system, you

74
00:04:01,190 --> 00:04:02,791
should have some goals in mind.

75
00:04:03,411 --> 00:04:06,612
So the first and most important was that the game has

76
00:04:06,652 --> 00:04:07,653
some complex rules.

77
00:04:08,493 --> 00:04:11,734
And we wanted to create a really good new player

78
00:04:11,794 --> 00:04:12,314
tutorial.

79
00:04:12,574 --> 00:04:15,376
And so the main point of the A.I. was to sort of

80
00:04:15,456 --> 00:04:18,417
transition people through the rules of the game and make a

81
00:04:18,477 --> 00:04:21,278
really nice new user experience for the game.

82
00:04:22,673 --> 00:04:27,377
Secondary to that was to have an AI that is strong enough

83
00:04:27,638 --> 00:04:30,981
so that it can pose a challenge against experienced players.

84
00:04:31,421 --> 00:04:32,782
So we have some experienced players,

85
00:04:33,123 --> 00:04:34,584
they want to practice new strategies

86
00:04:34,724 --> 00:04:36,005
or build orders, et cetera.

87
00:04:36,746 --> 00:04:38,908
And maybe their friends aren't online

88
00:04:39,388 --> 00:04:41,891
and they don't want to play ranked ladder right now.

89
00:04:41,971 --> 00:04:44,173
So they want to be able to practice against an opponent

90
00:04:44,213 --> 00:04:46,055
that's good enough to put up some sort of fight.

91
00:04:47,948 --> 00:04:51,169
Next also is we just want an enjoyable single player

92
00:04:51,369 --> 00:04:52,009
experience, right?

93
00:04:52,069 --> 00:04:53,770
So we want to have some replay value.

94
00:04:53,810 --> 00:04:56,530
We don't want the AI to do the same thing every single time

95
00:04:56,570 --> 00:04:57,231
you play against it.

96
00:04:58,571 --> 00:05:02,572
And finally, we want as modular a design as possible

97
00:05:02,732 --> 00:05:03,652
for a number of reasons.

98
00:05:04,092 --> 00:05:07,153
So the first is we'd like to have different AI difficulty

99
00:05:07,193 --> 00:05:07,553
settings.

100
00:05:08,133 --> 00:05:12,794
So we want an easy version of the AI, a really hard version

101
00:05:12,814 --> 00:05:14,695
of the AI, and a bunch of things in between.

102
00:05:15,475 --> 00:05:19,518
And also because this is a competitive strategy online video game,

103
00:05:20,238 --> 00:05:25,202
unlike a game like chess, which hasn't been balanced patched since like 940 AD,

104
00:05:26,403 --> 00:05:28,464
this game is going to be constantly changing

105
00:05:28,965 --> 00:05:32,547
as users find like overpowered units or new build orders.

106
00:05:32,927 --> 00:05:36,450
And so the AI system, we don't want to have to recode the whole thing

107
00:05:36,810 --> 00:05:39,832
if a unit changes, right? Because if we had a hard-coded build order

108
00:05:40,193 --> 00:05:43,255
and now the cost changes, we would have to reprogram the whole AI.

109
00:05:43,915 --> 00:05:45,436
and really we really don't want that.

110
00:05:46,536 --> 00:05:49,717
So coming from academia, I naively said,

111
00:05:49,877 --> 00:05:51,618
okay, let's try and use some search.

112
00:05:52,278 --> 00:05:56,319
So, you know, Deep Blue played chess really well

113
00:05:56,779 --> 00:05:59,280
and some Monte Carlo tree search systems

114
00:05:59,360 --> 00:06:01,000
have played the game of Go really well.

115
00:06:01,480 --> 00:06:04,701
And so let's take this huge academic literature

116
00:06:05,041 --> 00:06:07,542
of really smart algorithms and try and apply it

117
00:06:07,782 --> 00:06:10,323
to a retail video game and see how that works out.

118
00:06:11,763 --> 00:06:11,883
So.

119
00:06:13,471 --> 00:06:18,584
Why is using heuristic search difficult for strategy games?

120
00:06:18,644 --> 00:06:19,667
There's a number of reasons.

121
00:06:19,747 --> 00:06:21,291
I'll just go over a couple really quickly.

122
00:06:22,372 --> 00:06:25,173
So first of all it's hugely complex.

123
00:06:25,573 --> 00:06:29,295
So there's a really large number of states that are possible in this game.

124
00:06:29,776 --> 00:06:31,997
For example, units can have different numbers of hit points,

125
00:06:32,978 --> 00:06:35,659
status effects, they can have different abilities,

126
00:06:36,399 --> 00:06:37,660
build times, et cetera.

127
00:06:37,880 --> 00:06:40,322
And all this leads to a gigantic state space.

128
00:06:40,682 --> 00:06:43,203
So we can't just search every possible state in the game,

129
00:06:43,764 --> 00:06:47,346
because as you may know, there's about 10 to the 80 atoms in the universe.

130
00:06:47,586 --> 00:06:50,688
So even if each of those were doing a billion calculations a second.

131
00:06:51,268 --> 00:06:52,449
you know, we'd never solve this.

132
00:06:53,470 --> 00:06:55,992
Also, and probably more importantly,

133
00:06:56,112 --> 00:06:57,694
is the multi-unit control problem

134
00:06:57,954 --> 00:06:59,275
that a lot of strategy games face.

135
00:06:59,816 --> 00:07:03,339
So in a game like chess, we're only moving one piece

136
00:07:03,379 --> 00:07:03,839
at a time.

137
00:07:04,079 --> 00:07:07,102
So we may only need to consider maybe 40 different moves

138
00:07:07,122 --> 00:07:08,263
that we can do at any time.

139
00:07:09,184 --> 00:07:11,186
But in a strategy game, a player move

140
00:07:11,426 --> 00:07:15,109
is actually a combination of actions for each unit

141
00:07:15,129 --> 00:07:16,050
that the player controls.

142
00:07:16,752 --> 00:07:20,780
So in a strategy game, if we have U units and A actions per unit,

143
00:07:20,800 --> 00:07:25,429
we actually have an exponential number of actions at any given time that we have to consider.

144
00:07:26,287 --> 00:07:27,968
So we're trying to do search.

145
00:07:28,128 --> 00:07:29,689
We have some high-level search algorithm.

146
00:07:30,009 --> 00:07:32,811
But we have so many actions that we can't even escape

147
00:07:32,911 --> 00:07:35,653
depth one of this alpha beta search, for example.

148
00:07:36,013 --> 00:07:36,833
And so that's no good.

149
00:07:37,314 --> 00:07:39,575
So we need to reduce the number of actions somehow.

150
00:07:40,135 --> 00:07:41,516
But how do we do this?

151
00:07:41,576 --> 00:07:43,778
People have been trying to do this for a really long time.

152
00:07:44,338 --> 00:07:48,501
And so my pseudo answer to this question, unlike Dave, I

153
00:07:48,541 --> 00:07:51,322
don't claim to be solving all of your NP-hard problems.

154
00:07:51,683 --> 00:07:52,423
But I can certainly help.

155
00:07:53,804 --> 00:07:53,904
So.

156
00:07:54,880 --> 00:07:59,922
The idea of hierarchical portfolio search, I'll call it HPS because it's a bit of a mouthful,

157
00:08:00,603 --> 00:08:06,445
is just two steps. So first, we, instead of searching over an exponential number of moves,

158
00:08:06,945 --> 00:08:12,368
we're going to generate a smaller subset of hopefully intelligent moves using what I'll

159
00:08:12,388 --> 00:08:17,109
describe in the future, which is a portfolio, and then we'll apply some high-level search

160
00:08:17,230 --> 00:08:22,172
algorithm to those subset of moves that we've generated, rather than over everything.

161
00:08:23,473 --> 00:08:26,395
So what are the components of this system so first of all we need a game

162
00:08:26,435 --> 00:08:30,018
state right so this is the current state of the game that we're trying to

163
00:08:31,218 --> 00:08:33,280
decide on a move for for the eye.

164
00:08:34,301 --> 00:08:38,584
We have some actions which in prismata are clicking a unit for example or

165
00:08:38,644 --> 00:08:43,707
purchasing a unit and star craft for example, you'd have you know movement of

166
00:08:43,767 --> 00:08:46,189
a unit or building or training unit cetera.

167
00:08:47,513 --> 00:08:51,036
And then we have a move, which I'm describing as this is the

168
00:08:51,056 --> 00:08:53,217
thing that AI will do to complete its whole turn.

169
00:08:53,658 --> 00:08:56,139
And so a move here is an ordered sequence of actions.

170
00:08:56,419 --> 00:08:58,381
So click this unit, click this unit, click this unit.

171
00:08:59,021 --> 00:09:02,984
And our goal here is to pass in a game state to our AI, and

172
00:09:03,144 --> 00:09:04,925
it will spit out a move that it should do.

173
00:09:04,985 --> 00:09:06,146
And hopefully that move will be good.

174
00:09:07,814 --> 00:09:09,756
Two other components of HPS.

175
00:09:10,377 --> 00:09:13,099
First, we have this player function, I'm going to call it.

176
00:09:13,359 --> 00:09:15,421
And the player function is essentially

177
00:09:15,782 --> 00:09:18,244
doing all the logic of the AI system.

178
00:09:18,745 --> 00:09:21,888
So this player function, it takes in a state s,

179
00:09:22,468 --> 00:09:24,310
it performs the move decision logic,

180
00:09:24,770 --> 00:09:27,633
and it returns the move that it thinks

181
00:09:27,733 --> 00:09:29,075
it should do at that state.

182
00:09:30,467 --> 00:09:34,550
And the key part here is that a lot of AI systems have this

183
00:09:34,750 --> 00:09:35,510
player function.

184
00:09:36,051 --> 00:09:39,654
But in addition to the player function, we have what I call

185
00:09:39,734 --> 00:09:40,995
a partial player function.

186
00:09:41,807 --> 00:09:47,570
So the difference between a partial player is that it will generate a tactical move for

187
00:09:47,590 --> 00:09:52,593
a specific phase of the game or for a specific type of unit in the game.

188
00:09:53,253 --> 00:09:59,397
So you as the game designer, if you want to implement HPS, are going to tactically decompose

189
00:09:59,417 --> 00:10:00,217
your game somehow.

190
00:10:00,357 --> 00:10:01,438
And I'll give some examples of that.

191
00:10:03,184 --> 00:10:06,327
So in Prismata, the game has a number of phases to it.

192
00:10:06,387 --> 00:10:08,748
If you've played a lot of strategic card games, like

193
00:10:08,808 --> 00:10:11,651
Magic the Gathering has an untap, you draw cards, you have

194
00:10:11,691 --> 00:10:12,311
a main phase.

195
00:10:12,972 --> 00:10:16,835
In Prismata, you have a defensive phase where you

196
00:10:16,875 --> 00:10:19,236
assign damage to units in order to block the damage.

197
00:10:19,757 --> 00:10:22,119
You have an ability phase where you click your units.

198
00:10:22,219 --> 00:10:25,321
You have a purchasing phase where you buy new units.

199
00:10:25,882 --> 00:10:29,404
And you have a breaching phase where you assign damage to

200
00:10:29,424 --> 00:10:30,205
your opponent's units.

201
00:10:30,405 --> 00:10:32,106
So the names of these aren't super important.

202
00:10:32,935 --> 00:10:36,838
But the partial players here are tactical sub-algorithms

203
00:10:37,499 --> 00:10:40,321
which generate moves for individual phases.

204
00:10:40,761 --> 00:10:43,484
So if you look under defense here, for example,

205
00:10:43,904 --> 00:10:45,966
I have two partial players that play

206
00:10:46,006 --> 00:10:47,627
the defense phase of Prismata.

207
00:10:48,452 --> 00:10:51,774
One of them might be some optimization algorithm that says,

208
00:10:52,674 --> 00:10:57,117
try to assign damage to our blockers that minimizes the resource cost lost

209
00:10:57,597 --> 00:10:58,638
after my damage is done.

210
00:10:59,238 --> 00:11:03,760
Or another one might be, assign damage to my blockers such that I save the most

211
00:11:03,840 --> 00:11:04,941
attackers for the next turn.

212
00:11:05,719 --> 00:11:09,041
Similarly, an ability partial player may say,

213
00:11:09,241 --> 00:11:10,402
just attack with everything,

214
00:11:11,063 --> 00:11:13,244
or leave back the most blockers that I can.

215
00:11:13,785 --> 00:11:16,907
So what you do is you create this collection

216
00:11:17,347 --> 00:11:18,508
of tactical algorithms,

217
00:11:18,868 --> 00:11:21,290
and this is the portfolio that I was talking about.

218
00:11:24,224 --> 00:11:30,151
Then from this portfolio, a player move that we're interested in the AI doing for a turn

219
00:11:30,771 --> 00:11:34,876
is just one selection from each of those decompositions.

220
00:11:35,356 --> 00:11:40,862
So you take one player, a partial player from the defense, one from the ability, one from

221
00:11:40,882 --> 00:11:44,887
the buy, and one from breach, and this is a player move from the turn.

222
00:11:44,907 --> 00:11:46,268
You just concatenate those moves.

223
00:11:47,766 --> 00:11:48,547
What about other games?

224
00:11:48,787 --> 00:11:51,269
So let's say we're talking about real-time strategy games.

225
00:11:51,930 --> 00:11:55,434
So you can also create portfolios based on the unit

226
00:11:55,454 --> 00:11:56,515
type, for example.

227
00:11:56,715 --> 00:11:59,238
So again, if I'm playing a game like StarCraft, I have a

228
00:11:59,278 --> 00:12:02,601
number of different unit types that are really good at

229
00:12:02,641 --> 00:12:03,702
specific parts of the game.

230
00:12:04,623 --> 00:12:07,746
So my Dragoon unit here is a ranged unit.

231
00:12:07,886 --> 00:12:10,229
So I might have tactical algorithms like attack the

232
00:12:10,269 --> 00:12:10,849
closest thing.

233
00:12:11,525 --> 00:12:14,052
or since it's a relatively fast and long-range unit

234
00:12:14,433 --> 00:12:17,743
i could say take the enemy so attack the closest thing and then back up

235
00:12:18,224 --> 00:12:19,347
or maybe i just a runaway

236
00:12:19,945 --> 00:12:24,748
So I have a number of different tactical algorithms for each of the unit types in the game.

237
00:12:25,209 --> 00:12:28,571
Similarly, if you're playing something like League of Legends or another MOBA game,

238
00:12:28,971 --> 00:12:31,853
you could have these algorithms on a champion by champion basis.

239
00:12:32,473 --> 00:12:35,035
And you can also reuse them between champions.

240
00:12:35,095 --> 00:12:40,418
Like, I could have the same script doing attack closest for the dragoons,

241
00:12:40,919 --> 00:12:42,820
or the tanks, or the mutalisks, etc.

242
00:12:43,840 --> 00:12:44,181
And again...

243
00:12:45,323 --> 00:12:50,367
A player move for a turn is just a selection of one of these for each of the unit types.

244
00:12:51,067 --> 00:12:58,713
So a really good takeaway here is that you can use existing scripts or algorithms to

245
00:12:58,753 --> 00:12:59,854
generate a portfolio.

246
00:13:00,034 --> 00:13:03,737
So if you're saying, oh Dave, we're not going to rewrite our whole AI system just because

247
00:13:03,757 --> 00:13:08,720
you say it's good, well, if you have a bunch of stuff already in place, you can just drop

248
00:13:09,061 --> 00:13:12,243
search on top of all that and hopefully make it more intelligent.

249
00:13:12,563 --> 00:13:13,704
And this is one way of doing that.

250
00:13:15,495 --> 00:13:20,418
So how do we tie everything together so the HPS algorithm

251
00:13:21,059 --> 00:13:23,921
you're going to decide on 3 things so you have a portfolio

252
00:13:24,241 --> 00:13:27,424
that you've decided on which is you know some again some

253
00:13:27,544 --> 00:13:29,525
tactical decomposition within your game.

254
00:13:30,526 --> 00:13:33,808
You have a game state and you have a high level search

255
00:13:33,888 --> 00:13:38,252
algorithm so again what's going to happen is we're going to

256
00:13:38,712 --> 00:13:41,854
first generate the moves using the portfolio.

257
00:13:42,785 --> 00:13:45,547
and then apply the high-level search to that.

258
00:13:46,328 --> 00:13:49,731
And so the real, I guess, novelty of HPS

259
00:13:50,031 --> 00:13:51,293
is in the move generation.

260
00:13:51,573 --> 00:13:53,414
So I'm not going to go into the details

261
00:13:53,455 --> 00:13:56,557
here of any particular high-level search algorithm.

262
00:13:57,198 --> 00:14:00,741
You could use a Monte Carlo tree search, or alpha beta,

263
00:14:00,901 --> 00:14:03,103
or a greedy search, et cetera.

264
00:14:03,584 --> 00:14:06,486
I'm just going to go into the HPS-specific stuff.

265
00:14:08,658 --> 00:14:14,558
For example, in Prismata, how are we doing the move generation using this portfolio?

266
00:14:15,145 --> 00:14:21,849
So this is a sample of a portfolio that we're using in Prismata, which, you know, myself

267
00:14:21,929 --> 00:14:24,771
and the designers collaborate and come up with a set of behaviors.

268
00:14:25,351 --> 00:14:29,354
So we may have a lot of different behaviors for purchasing cards.

269
00:14:29,694 --> 00:14:35,217
So for example, we may say, OK, buy the most attack you can on this turn or buy the most

270
00:14:35,277 --> 00:14:35,678
defense.

271
00:14:36,118 --> 00:14:38,479
So what you do is you create a portfolio.

272
00:14:39,180 --> 00:14:41,240
that is really broad.

273
00:14:41,641 --> 00:14:44,622
So it can do everything that you would want it to do.

274
00:14:44,842 --> 00:14:46,922
It can be aggressive, it can be economic,

275
00:14:46,962 --> 00:14:47,763
it can be defensive.

276
00:14:48,783 --> 00:14:50,323
And then what we do is,

277
00:14:50,564 --> 00:14:52,624
the way we're going to generate moves from this

278
00:14:53,505 --> 00:14:58,046
is to take all possible permutations of this list.

279
00:14:59,427 --> 00:15:02,488
So, for example, here with this portfolio,

280
00:15:02,668 --> 00:15:04,048
the first move I'll generate

281
00:15:04,508 --> 00:15:07,449
is just the concatenation of all the first elements

282
00:15:07,849 --> 00:15:08,309
in this set.

283
00:15:09,060 --> 00:15:10,723
The second move is this one.

284
00:15:11,383 --> 00:15:14,407
Then the third move, the fourth move, et cetera.

285
00:15:14,948 --> 00:15:17,111
And so we're just taking all possible permutations of

286
00:15:17,171 --> 00:15:22,377
these, and then we use these moves as the moves that the

287
00:15:22,417 --> 00:15:23,919
high-level search is going to search over.

288
00:15:25,108 --> 00:15:31,273
So for example, back here, when I had this portfolio with 2 times 3 times 4 times 2,

289
00:15:31,393 --> 00:15:33,214
what's that?

290
00:15:33,254 --> 00:15:35,015
2 times 3 is 6, 6 times, we have 48.

291
00:15:35,976 --> 00:15:41,020
So here we've reduced the branching factor of our search from possibly millions down

292
00:15:41,040 --> 00:15:41,440
to 48.

293
00:15:42,721 --> 00:15:48,125
Now the optimal move may not be part of this 48, but hey, at least you're doing something.

294
00:15:49,005 --> 00:15:54,449
And at least the different types of behaviors that you want are being represented here.

295
00:15:56,108 --> 00:15:59,609
And like I said before, you can use any high level search algorithm you want.

296
00:16:00,209 --> 00:16:07,032
So in Prismata, we use Monte Carlo tree search, we use alpha beta, and we also use random

297
00:16:07,052 --> 00:16:07,472
selection.

298
00:16:07,732 --> 00:16:11,353
So in sometimes, maybe the easier AI, you don't want to spend time on search, you just

299
00:16:11,373 --> 00:16:12,553
want to select a random move.

300
00:16:15,815 --> 00:16:19,656
Other possibilities, you could do, maybe you don't have time for search, so you could do

301
00:16:19,696 --> 00:16:20,776
something like hill climbing.

302
00:16:21,316 --> 00:16:23,437
Or if you're really cool, you could use a genetic algorithm.

303
00:16:24,264 --> 00:16:27,706
or you know you can use machine learning or reinforcement learning the choices

304
00:16:27,746 --> 00:16:28,867
up to you so whatever

305
00:16:29,787 --> 00:16:32,790
really cool state of the art algorithm you want to put on top of this you can

306
00:16:32,810 --> 00:16:35,972
uh... so

307
00:16:36,612 --> 00:16:39,374
another one of our goals was modular design

308
00:16:39,674 --> 00:16:42,857
because we really wanted to have a lot of different AI difficulties

309
00:16:43,397 --> 00:16:45,879
but with if you're using something like a behavior tree

310
00:16:46,759 --> 00:16:48,761
uh... it may be it's hard to sort of

311
00:16:49,721 --> 00:16:52,483
tune that to be easier uh... or more difficult

312
00:16:53,124 --> 00:16:53,304
but

313
00:16:54,377 --> 00:16:57,641
The system we have for Prismata is really, really modular

314
00:16:57,721 --> 00:17:00,204
and really easy to create different AI settings.

315
00:17:00,665 --> 00:17:03,528
So this is the portfolio that we had for Prismata.

316
00:17:04,409 --> 00:17:06,732
And the high level search algorithm that we used

317
00:17:06,992 --> 00:17:09,114
for the hardest difficulty setting in the game

318
00:17:09,535 --> 00:17:10,976
was a Monte Carlo tree search.

319
00:17:12,038 --> 00:17:16,560
So we gave this Monte Carlo tree search three or seven seconds.

320
00:17:16,600 --> 00:17:17,641
You can change the settings.

321
00:17:18,121 --> 00:17:21,143
But just imagine a three-second Monte Carlo tree search

322
00:17:21,523 --> 00:17:24,004
where the AI starts thinking, and three seconds later,

323
00:17:24,064 --> 00:17:24,684
it gives you a move.

324
00:17:25,105 --> 00:17:26,145
Now, that's a long time.

325
00:17:26,485 --> 00:17:28,086
And we were actually worried initially

326
00:17:28,126 --> 00:17:31,088
that users wouldn't want to wait three seconds to get a move

327
00:17:31,128 --> 00:17:31,348
back.

328
00:17:31,988 --> 00:17:35,270
But almost immediately, we had feedback coming in saying,

329
00:17:35,530 --> 00:17:37,191
can I turn the slider up to a minute?

330
00:17:37,691 --> 00:17:39,212
Like, I don't care how long it takes.

331
00:17:39,332 --> 00:17:41,073
I just want the AI to be as good as possible.

332
00:17:41,819 --> 00:17:45,301
And of course, this is possible in a turn-based strategy game.

333
00:17:45,642 --> 00:17:48,243
It may not be possible in a real-time strategy game

334
00:17:48,704 --> 00:17:49,444
to give it this time.

335
00:17:49,824 --> 00:17:51,525
But if you do have that luxury, then you

336
00:17:51,545 --> 00:17:52,786
can give it as much time as you want,

337
00:17:53,046 --> 00:17:53,967
and hopefully it gets better.

338
00:17:55,648 --> 00:17:59,271
So one difficulty down from that was the expert bot,

339
00:17:59,331 --> 00:18:02,553
we called it, which just did a depth 2 alpha beta search.

340
00:18:03,294 --> 00:18:09,039
So it looked maybe, you know, 200 moves, um, 2 depth into the future, and then returned something.

341
00:18:09,600 --> 00:18:13,904
So rather than wait for 3 seconds, the expert bot returns a move almost instantaneously,

342
00:18:14,345 --> 00:18:16,527
but it's still, it's still doing search, right?

343
00:18:16,547 --> 00:18:19,930
So it's still saying, for whatever I can do, and then whatever you can do,

344
00:18:20,130 --> 00:18:22,753
we'll do minimax in there, and return something intelligent.

345
00:18:24,163 --> 00:18:26,563
The medium AI, instead of doing search here,

346
00:18:26,743 --> 00:18:30,164
it just returns a random, one of the random permutations.

347
00:18:30,824 --> 00:18:33,825
And so, even though it's random, it's not a random move,

348
00:18:34,325 --> 00:18:37,386
it's random from within, hopefully, intelligent things.

349
00:18:37,906 --> 00:18:39,567
So it may make mistakes sometimes,

350
00:18:39,847 --> 00:18:41,807
but that's what we want for a medium difficulty.

351
00:18:41,827 --> 00:18:42,367
Okay?

352
00:18:43,507 --> 00:18:46,188
And the easy bot, we just took a lot

353
00:18:46,208 --> 00:18:47,628
of these tactical algorithms out.

354
00:18:47,949 --> 00:18:48,669
So for example,

355
00:18:50,612 --> 00:18:53,936
the hardest AI will have like solvers running,

356
00:18:53,976 --> 00:18:57,441
like knapsack solvers trying to minimize the loss

357
00:18:57,501 --> 00:19:00,605
when it's defending, but the easy bot will just say,

358
00:19:00,765 --> 00:19:03,028
just block from left to right with all of my units.

359
00:19:04,009 --> 00:19:06,392
And so you can plug in these tactical algorithms

360
00:19:06,772 --> 00:19:08,495
and make different difficulty settings

361
00:19:08,535 --> 00:19:09,776
just with these different building blocks.

362
00:19:10,865 --> 00:19:13,406
And the last difficulty that we have is called the pacifist

363
00:19:13,446 --> 00:19:15,547
bot, where we wanted something to play.

364
00:19:16,068 --> 00:19:19,689
We wanted it to play really well, but we didn't want it to

365
00:19:19,769 --> 00:19:20,349
ever attack.

366
00:19:20,689 --> 00:19:23,411
We just wanted something for users to be able to sort of

367
00:19:23,491 --> 00:19:25,151
beat up on and feel really special.

368
00:19:25,672 --> 00:19:30,093
And so it has the same portfolio as our hardest

369
00:19:30,133 --> 00:19:31,974
difficulty, except it never attacks.

370
00:19:32,755 --> 00:19:33,095
And that's it.

371
00:19:33,295 --> 00:19:36,836
So you just plug in the don't attack tactical algorithm

372
00:19:37,897 --> 00:19:39,537
instead of all the different attacking ones

373
00:19:39,557 --> 00:19:40,278
that we were using before.

374
00:19:42,236 --> 00:19:44,517
So what are some of the benefits of this system?

375
00:19:45,398 --> 00:19:48,299
So the really big benefit here is that search

376
00:19:48,600 --> 00:19:51,261
adapts to dynamic scenarios, okay?

377
00:19:51,841 --> 00:19:54,703
So your AI, when you're using search,

378
00:19:55,023 --> 00:19:57,525
it can do things like rush your opponent really aggressively,

379
00:19:58,045 --> 00:20:00,646
it can do economic builds, it can do defensive,

380
00:20:01,047 --> 00:20:02,888
and you don't have to hard code any of this.

381
00:20:03,388 --> 00:20:05,829
Like, based on the units that are in our sets,

382
00:20:06,694 --> 00:20:10,256
it. So if if there's a lot of aggressive units in the set the

383
00:20:10,356 --> 00:20:13,297
A. I. You'll see it actually start rushing the opponent or

384
00:20:13,337 --> 00:20:15,398
if there's a bunch of like huge defenders it will take a

385
00:20:15,438 --> 00:20:17,779
more economic stance and this is all just comes out of

386
00:20:17,799 --> 00:20:18,159
the search.

387
00:20:20,260 --> 00:20:24,162
Also something that I've learned from watching these sessions

388
00:20:24,242 --> 00:20:28,344
up here is that emergent behavior is scary. Designers do

389
00:20:28,404 --> 00:20:32,165
not like emergent behavior because for example, I think

390
00:20:32,326 --> 00:20:33,906
one example someone said was.

391
00:20:35,015 --> 00:20:38,418
they had some sort of dynamic, you know, search-based system for a first-person

392
00:20:38,458 --> 00:20:38,798
shooter

393
00:20:39,519 --> 00:20:43,322
and the AI ended up, like, doing a backflip and throwing a grenade which

394
00:20:43,382 --> 00:20:45,664
bounced off four walls and perfectly hit the guy in the face.

395
00:20:46,525 --> 00:20:49,428
And it just feels unfair and yes it was intelligent

396
00:20:49,828 --> 00:20:51,690
but the designer didn't want that to happen.

397
00:20:52,743 --> 00:20:58,449
And so with HPS, you can easily take those sort of things out of the game.

398
00:20:58,650 --> 00:21:03,254
So you can, it only selects from a known set of moves.

399
00:21:03,595 --> 00:21:08,500
So you're telling it, hey, I only want it to be able to do one of these certain things,

400
00:21:08,960 --> 00:21:13,405
but then it uses the search to optimize which of those certain things are really beneficial.

401
00:21:14,124 --> 00:21:15,666
And it's also really designer friendly.

402
00:21:15,966 --> 00:21:19,190
So once you give someone a really nice configuration file,

403
00:21:19,911 --> 00:21:22,434
for example, about two months ago, the designers of the game

404
00:21:22,775 --> 00:21:26,299
said, OK, Dave, time to crawl out of your AI hole.

405
00:21:27,044 --> 00:21:30,665
and your black box and just tell us how the configuration file works.

406
00:21:31,245 --> 00:21:35,666
And within about two weeks, the AI had gotten almost twice as strong.

407
00:21:35,886 --> 00:21:37,347
So they are really good at the game.

408
00:21:37,907 --> 00:21:39,247
I'm kind of good at AI.

409
00:21:39,727 --> 00:21:44,729
And so they take the AI system that was completely generalized without any hard-coded information

410
00:21:45,269 --> 00:21:47,849
and put in a couple of little build orders here and there.

411
00:21:48,690 --> 00:21:52,531
And it really did improve the strength of the AI and they didn't have to touch a line

412
00:21:52,551 --> 00:21:52,911
of code.

413
00:21:53,091 --> 00:21:54,011
So I think that was pretty cool.

414
00:21:55,956 --> 00:21:58,766
uh... so we did some experiments because i wanted to know whether or not this

415
00:21:58,787 --> 00:21:59,710
stuff was actually working

416
00:22:00,554 --> 00:22:03,816
So the first experiment was to test whether or not

417
00:22:04,716 --> 00:22:06,937
my intuition about these difficulty settings,

418
00:22:07,057 --> 00:22:08,538
whether or not it was actually true.

419
00:22:09,119 --> 00:22:11,180
And so from left to right here, I

420
00:22:11,240 --> 00:22:12,700
played a bunch of round robin matches,

421
00:22:12,740 --> 00:22:15,462
maybe like a million games of the master bot

422
00:22:15,482 --> 00:22:17,423
versus the easy bot, et cetera.

423
00:22:17,963 --> 00:22:20,484
And yes, it does turn out that the intuition was correct.

424
00:22:21,145 --> 00:22:26,047
And the more difficult AIs with the search-based solutions

425
00:22:26,167 --> 00:22:29,149
do beat up on the easier AIs.

426
00:22:30,817 --> 00:22:34,700
Similarly, if you're going to use search, you need to know,

427
00:22:34,820 --> 00:22:37,322
OK, well, the whole point of using search is that if I give

428
00:22:37,363 --> 00:22:40,285
it more time, it should produce better moves.

429
00:22:40,945 --> 00:22:43,267
And so what I did was an experiment where we just give

430
00:22:43,307 --> 00:22:46,670
it, say, 100 milliseconds versus a second versus 3

431
00:22:46,950 --> 00:22:48,792
seconds versus 10 seconds, et cetera.

432
00:22:49,272 --> 00:22:54,176
And yes, this system, the more time you give it, the more

433
00:22:54,236 --> 00:22:56,278
intelligent the move that it will produce.

434
00:22:57,915 --> 00:23:01,418
I also did a really sneaky experiment, which I was really proud of.

435
00:23:02,018 --> 00:23:09,683
So I created, I took the code from our GitHub and made a secret version of the client.

436
00:23:10,123 --> 00:23:16,307
And what this did was it actually queued up on the ranked ladder automatically, played

437
00:23:16,347 --> 00:23:20,269
a game using the AI, and then recorded the results.

438
00:23:21,197 --> 00:23:25,098
And humans, like, not even, you know, the bosses didn't even know I was doing this.

439
00:23:26,639 --> 00:23:28,920
So it was successful, luckily.

440
00:23:29,040 --> 00:23:30,480
I wouldn't have told anyone if it wasn't, right?

441
00:23:31,080 --> 00:23:36,782
So I used the master bot, which is the hardest bot, and I put it on a three-second time setting,

442
00:23:37,162 --> 00:23:39,683
and I put a random delay on all the actions.

443
00:23:39,903 --> 00:23:44,144
So it wasn't just selecting things and then clicking everything like, you know, it was

444
00:23:44,204 --> 00:23:45,665
actually clicking slowly.

445
00:23:46,025 --> 00:23:48,646
So it, trying to pass some sort of prismata turning test.

446
00:23:49,366 --> 00:23:51,768
and nobody e-mailed or said anything.

447
00:23:52,068 --> 00:23:52,728
So it's good.

448
00:23:52,828 --> 00:23:55,590
I think that it passed the Prisma auditory test.

449
00:23:57,071 --> 00:23:58,972
And after all that was said and done,

450
00:23:59,192 --> 00:24:03,195
the AI achieved a rank of 6.5 out of 10 on the ladder.

451
00:24:03,775 --> 00:24:05,196
So I'll tell you what that means in a second,

452
00:24:05,296 --> 00:24:07,117
because that number doesn't matter.

453
00:24:07,698 --> 00:24:09,779
But what you see when you're trying

454
00:24:09,859 --> 00:24:11,420
to test the strength of your AI.

455
00:24:13,792 --> 00:24:17,335
If the people who have been playing against the AI a lot know they're playing against

456
00:24:17,355 --> 00:24:21,538
the AI, they can opponent model it and do things against it that it's weak to.

457
00:24:22,178 --> 00:24:26,862
But when you secretly play against the AI, they don't know the weakness of the player.

458
00:24:26,922 --> 00:24:31,006
And so they're playing a more standard game where they're not trying to exploit an AI.

459
00:24:31,146 --> 00:24:35,149
So I think that this is a more, a better test of sort of where the AI ranks.

460
00:24:36,050 --> 00:24:37,331
So at the time this was done.

461
00:24:39,076 --> 00:24:42,118
This is the ranking distribution of players on our ladder.

462
00:24:42,738 --> 00:24:45,540
And so the AI came about tier 6.5,

463
00:24:45,680 --> 00:24:46,860
which meant that at the time,

464
00:24:47,321 --> 00:24:50,362
it was within the top 25% of people playing the game

465
00:24:50,702 --> 00:24:51,803
in terms of playing strength.

466
00:24:52,443 --> 00:24:54,004
And since then, this experiment was done

467
00:24:54,024 --> 00:24:55,025
like a year and a half ago,

468
00:24:55,145 --> 00:24:56,565
we've been in closed beta for a little while.

469
00:24:58,186 --> 00:24:59,907
And we think that the AI is actually now

470
00:24:59,987 --> 00:25:02,148
maybe within the top 10% of people playing.

471
00:25:02,829 --> 00:25:04,830
And so it's pretty strong, I think.

472
00:25:06,034 --> 00:25:08,496
So were our goals achieved?

473
00:25:09,677 --> 00:25:11,879
I think that it's been really great.

474
00:25:12,619 --> 00:25:14,181
We did a survey of our users.

475
00:25:14,201 --> 00:25:15,562
I don't have the results on the slides.

476
00:25:15,642 --> 00:25:18,544
But they thought that it was really, really great as a new

477
00:25:18,645 --> 00:25:21,227
user experience, especially with the different difficulty

478
00:25:21,267 --> 00:25:21,587
settings.

479
00:25:23,048 --> 00:25:25,571
Whether or not it's good for experienced player training,

480
00:25:25,711 --> 00:25:28,894
it's our top few people, of which we have a few in the

481
00:25:28,934 --> 00:25:31,316
crowd, can really trash the bot.

482
00:25:31,336 --> 00:25:31,396
But

483
00:25:32,736 --> 00:25:36,477
if you're a new player learning the game it takes you maybe a couple of hundred

484
00:25:36,517 --> 00:25:38,017
games to be able to beat the AI

485
00:25:38,577 --> 00:25:43,078
and so it's kind of strong but it's it's not you know it's not a deep blue or

486
00:25:43,178 --> 00:25:44,298
AlphaGo level just yet

487
00:25:45,558 --> 00:25:49,959
I think it users said that it had a lot of replay value so based on the

488
00:25:49,999 --> 00:25:50,299
different

489
00:25:51,339 --> 00:25:55,420
if you have a random assortment of cards the AI can play them all these random

490
00:25:55,440 --> 00:25:58,721
assortments fairly well and so you can keep playing against the AI without a lot

491
00:25:58,741 --> 00:25:59,261
of repetition

492
00:26:00,330 --> 00:26:02,710
And the modular design, I have no metric to really

493
00:26:03,831 --> 00:26:06,331
measure this, but I did think that the designers,

494
00:26:06,972 --> 00:26:09,793
their ability to pick up this system

495
00:26:09,913 --> 00:26:11,773
and modify it without any AI knowledge

496
00:26:11,793 --> 00:26:13,494
was sort of a testament to that.

497
00:26:13,974 --> 00:26:17,055
And also, we've undergone maybe two or three dozen

498
00:26:17,195 --> 00:26:20,116
balance changes where we've changed the costs of units

499
00:26:21,356 --> 00:26:24,777
in the game and changed a couple of game rules even,

500
00:26:25,177 --> 00:26:26,737
and the AI system has held up to that

501
00:26:26,797 --> 00:26:28,678
and hasn't needed to be changed in any way.

502
00:26:29,738 --> 00:26:29,838
So.

503
00:26:30,690 --> 00:26:31,450
One final thought.

504
00:26:32,231 --> 00:26:34,112
Everything I hear from everybody in the video game

505
00:26:34,152 --> 00:26:35,793
industry, we can't spare the cycles.

506
00:26:36,213 --> 00:26:37,614
We'd love to be able to do search.

507
00:26:38,054 --> 00:26:41,437
But I'm not running Monte Carlo tree search on a PS4 or

508
00:26:41,497 --> 00:26:42,077
something like that.

509
00:26:42,217 --> 00:26:44,819
We have two milliseconds to do AI, or one millisecond.

510
00:26:44,859 --> 00:26:45,559
We can't run this.

511
00:26:46,099 --> 00:26:51,323
But my counter to that is that search isn't limited to in

512
00:26:51,423 --> 00:26:52,323
game behavior.

513
00:26:53,744 --> 00:26:54,405
So what does that mean?

514
00:26:55,065 --> 00:26:56,086
Try offline search.

515
00:26:56,466 --> 00:26:59,568
You probably hired 100 people to QA test your game.

516
00:27:00,412 --> 00:27:05,134
But if you can replace people with robots, which is, you know, maybe a way of the future,

517
00:27:05,174 --> 00:27:10,136
maybe you're not allowed, maybe not a lot of people are in on this idea, but this AI,

518
00:27:10,257 --> 00:27:14,799
if it's strong enough, maybe it can't run in real time in your game, but it can be used

519
00:27:14,839 --> 00:27:18,220
for bug testing, or for balance testing, or for stress testing, et cetera.

520
00:27:18,800 --> 00:27:23,662
So I think that even if you don't want to implement this as the decision logic for your

521
00:27:23,702 --> 00:27:27,364
game engine, you can still use these techniques in an offline manner.

522
00:27:28,284 --> 00:27:28,745
Thank you very much.

523
00:27:36,545 --> 00:27:38,656
Apparently there's two minutes for questions if anyone has questions.

524
00:27:51,240 --> 00:27:53,260
In the examples you gave, the portfolios

525
00:27:53,280 --> 00:27:55,741
were for individual components or parts of the game.

526
00:27:55,781 --> 00:27:57,741
And one of the examples you gave was an RTS.

527
00:27:57,761 --> 00:27:59,282
You have a particular unit having

528
00:27:59,422 --> 00:28:02,882
three different models, which uses its logic.

529
00:28:03,803 --> 00:28:05,983
But you didn't recover in that specific case,

530
00:28:06,023 --> 00:28:07,904
because this is clearly a different type of game.

531
00:28:08,304 --> 00:28:11,484
But what happens when a good play

532
00:28:11,685 --> 00:28:15,125
is based on those individual parts kind of working together?

533
00:28:15,625 --> 00:28:17,446
Because an optimal move for one unit.

534
00:28:18,007 --> 00:28:20,571
while it ended up to move for another unit at the same time

535
00:28:24,574 --> 00:28:29,576
So the good thing about the portfolio system is that I gave examples where you're passing

536
00:28:29,596 --> 00:28:31,096
in like algorithms here, right?

537
00:28:31,417 --> 00:28:36,198
But you can also pass in, say, all the individual actions that a unit could do.

538
00:28:36,779 --> 00:28:41,880
So in general, this could search over a wider range of collaborative behaviors.

539
00:28:42,481 --> 00:28:49,443
And since you are searching over all possible permutations of those, then you will get collaborative

540
00:28:49,483 --> 00:28:50,243
behavior out of that.

541
00:28:51,336 --> 00:28:57,722
But if you're using this sort of, you know, passing in scripts or algorithms and you're missing some of that collaborative behavior,

542
00:28:57,982 --> 00:29:04,647
so there's definitely a trade-off between how many nodes you're willing to generate and the level of collaborative behavior that you want to achieve.

543
00:29:05,728 --> 00:29:05,968
Thank you.

544
00:29:08,105 --> 00:29:17,427
I was just going to ask, if you're using alpha beta, implicitly you have some sort of value

545
00:29:17,487 --> 00:29:20,288
function as well as the portfolio of strategies.

546
00:29:20,408 --> 00:29:22,288
What sort of value function did you use here?

547
00:29:22,628 --> 00:29:22,848
Sure.

548
00:29:22,948 --> 00:29:27,249
So Peter's asking about, you know, you can't search the whole game tree when you're doing

549
00:29:27,329 --> 00:29:29,290
alpha beta or Monte Carlo tree search.

550
00:29:29,370 --> 00:29:31,570
And so you need a way to evaluate a node.

551
00:29:32,189 --> 00:29:34,631
So you need to know, or a game state.

552
00:29:34,711 --> 00:29:37,332
So if you look at a game state, a human can come along

553
00:29:37,372 --> 00:29:39,694
and probably say, oh, this person is winning,

554
00:29:39,934 --> 00:29:41,395
and this person is probably losing.

555
00:29:41,835 --> 00:29:43,696
And so we need some sort of evaluation for that.

556
00:29:43,856 --> 00:29:45,657
And what I did, and I didn't want

557
00:29:45,677 --> 00:29:46,818
to get into the details here.

558
00:29:46,918 --> 00:29:47,779
They're all in the paper.

559
00:29:47,839 --> 00:29:49,620
If you go to my website, there's lots of details.

560
00:29:50,260 --> 00:29:53,642
But we tried at first a formula-based evaluation,

561
00:29:53,722 --> 00:29:56,464
sort of like chess, where you give the queen nine points

562
00:29:56,504 --> 00:29:58,265
and a pawn one point, and then sum them up.

563
00:29:58,685 --> 00:30:00,346
But that didn't really end up working very well.

564
00:30:00,950 --> 00:30:07,232
So what I went with was I took a player that I had constructed, a really simple player,

565
00:30:07,812 --> 00:30:10,133
and then did a playout from a given state.

566
00:30:10,813 --> 00:30:13,774
So if you have a state and you have really dumb behaviors,

567
00:30:14,254 --> 00:30:18,835
even though they're dumb, if both people follow this behavior and one person wins,

568
00:30:19,275 --> 00:30:21,896
it probably means that they were winning at that state.

569
00:30:22,736 --> 00:30:26,457
And so we did this playout evaluation rather than a formula-based evaluation.

570
00:30:27,155 --> 00:30:28,762
It's cool, it sounds rather like some of the stuff

571
00:30:28,782 --> 00:30:29,907
that Mark Winans is doing.

572
00:30:29,988 --> 00:30:31,253
It's, yeah, it's an interesting idea.

