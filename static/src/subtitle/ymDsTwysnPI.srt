1
00:00:04,537 --> 00:00:10,079
It's very gratifying to see such an extremely large turnout for math for game programmers.

2
00:00:10,079 --> 00:00:10,740
This is great.

3
00:00:10,740 --> 00:00:12,680
We've had lines up all outside today.

4
00:00:12,680 --> 00:00:15,201
We've had great speakers.

5
00:00:15,201 --> 00:00:20,063
My job is to scare everybody back out of the room by doing vector calculus.

6
00:00:20,063 --> 00:00:22,284
A few reminders before we begin.

7
00:00:22,284 --> 00:00:27,426
First off, if you have a phone, please set it to silent.

8
00:00:27,426 --> 00:00:31,848
Second off, if you are here and your badge has been scanned, you will get an email.

9
00:00:32,353 --> 00:00:34,374
And the email contains surveys.

10
00:00:34,374 --> 00:00:35,855
Please do the survey.

11
00:00:35,855 --> 00:00:37,576
The results go to me.

12
00:00:37,576 --> 00:00:39,037
I will probably ignore them.

13
00:00:39,037 --> 00:00:39,777
I did last year.

14
00:00:39,777 --> 00:00:42,899
People said really nice things.

15
00:00:42,899 --> 00:00:43,819
It was really nice.

16
00:00:43,819 --> 00:00:44,880
So please say nice things.

17
00:00:44,880 --> 00:00:46,801
All right.

18
00:00:46,801 --> 00:00:48,842
So I'm Nicholas.

19
00:00:48,842 --> 00:00:52,804
Today I'm going to be talking about iconic functions

20
00:00:52,804 --> 00:00:54,024
and mean value coordinates.

21
00:00:54,024 --> 00:00:57,426
The official.

22
00:00:57,787 --> 00:01:03,149
description for this talk says a bunch of things, but really what this is sort of about

23
00:01:03,149 --> 00:01:10,452
is the problem of understanding shape. Shapes are surprisingly difficult. Here is an example

24
00:01:10,452 --> 00:01:16,054
shaping computer graphics. It's the famous Stanford bunny. We see it all the time. And

25
00:01:16,054 --> 00:01:16,654
the question is,

26
00:01:17,431 --> 00:01:22,653
If we're working with shapes, say you're doing texture generation or modeling or procedural

27
00:01:22,653 --> 00:01:26,474
content generation is the big one that is going to be an up and coming thing, I think,

28
00:01:26,474 --> 00:01:32,316
this year, judging by the turnout in the procedural session at 3 p.m., then you need to be able

29
00:01:32,316 --> 00:01:35,757
to take shape and you need to be able to meaningfully tell the computer how to understand it.

30
00:01:35,757 --> 00:01:39,718
And you don't want to do this directly, because the

31
00:01:40,820 --> 00:01:46,463
The mathematical framework of how you understand the overall structure of a shape, the global

32
00:01:46,463 --> 00:01:52,447
structure of a shape, involves a lot of heavy lifting from algebraic and differential topology,

33
00:01:52,447 --> 00:01:54,949
and you don't want to deal with that if you can help it.

34
00:01:54,949 --> 00:01:58,411
We're also not going to be talking today about how you store the shape on a computer.

35
00:01:58,411 --> 00:01:59,452
That's Gino's talk.

36
00:01:59,452 --> 00:01:59,872
It's coming up.

37
00:01:59,872 --> 00:02:04,315
I hope you'll stick around for it, because that should be really interesting.

38
00:02:04,315 --> 00:02:06,276
So here is the idea of today's talk.

39
00:02:07,137 --> 00:02:12,342
Instead of trying to understand a shape directly by looking at its triangles and vertices,

40
00:02:12,342 --> 00:02:16,145
we want to put a function on a triangle mesh, okay?

41
00:02:16,145 --> 00:02:21,850
We want the function to have certain properties that are desirable for whatever the challenge

42
00:02:21,850 --> 00:02:23,451
is that we're facing.

43
00:02:23,451 --> 00:02:27,695
We construct the function to have these properties, we put it on the mesh, then we can reason

44
00:02:27,695 --> 00:02:28,696
about the function instead.

45
00:02:28,696 --> 00:02:33,500
And a function is a much nicer thing in some senses than an arbitrary triangle mesh.

46
00:02:34,260 --> 00:02:39,684
So today I'm going to talk about two standard tools in what I do, which is geometric mesh

47
00:02:39,684 --> 00:02:41,225
processing, for doing this.

48
00:02:41,225 --> 00:02:42,986
These are not original tools.

49
00:02:42,986 --> 00:02:45,147
I have not developed these tools.

50
00:02:45,147 --> 00:02:49,390
These are ideas from late 90s onwards.

51
00:02:49,390 --> 00:02:54,913
The math itself goes all the way back to the 18th and 19th century.

52
00:02:56,098 --> 00:02:58,300
Like a lot of stuff which I do in my academic life,

53
00:02:58,300 --> 00:03:01,222
it hasn't really been highlighted by the game development community,

54
00:03:01,222 --> 00:03:04,805
and so that's what we're going to do today.

55
00:03:04,805 --> 00:03:07,587
So we're going to talk about two methods of

56
00:03:07,587 --> 00:03:09,368
working with functions on shapes.

57
00:03:09,368 --> 00:03:11,850
The first of which is harmonic functions,

58
00:03:11,850 --> 00:03:13,751
and the second of which is mean value coordinates.

59
00:03:15,065 --> 00:03:18,308
So, method one, harmonic functions.

60
00:03:18,308 --> 00:03:21,350
So, let's talk about what we would like.

61
00:03:21,350 --> 00:03:22,571
I give you a triangle mesh, M,

62
00:03:22,571 --> 00:03:26,394
and I would like to put a scalar function,

63
00:03:26,394 --> 00:03:28,396
which just means that it's just a float.

64
00:03:28,396 --> 00:03:30,457
It's not a vector function.

65
00:03:30,457 --> 00:03:31,198
That could be GDC 2018.

66
00:03:31,198 --> 00:03:34,961
I have a scalar function on the shape.

67
00:03:34,961 --> 00:03:35,802
I would like it to be

68
00:03:36,883 --> 00:03:41,608
smooth in this, you know, in sort of an intuitive understanding of that word for right now,

69
00:03:41,608 --> 00:03:49,337
and at some points on my mesh I would like to have some control over what the values

70
00:03:49,337 --> 00:03:50,679
of the function are.

71
00:03:50,679 --> 00:03:55,845
So I define it in some places, everywhere else I want it to blend smoothly across the

72
00:03:55,845 --> 00:03:55,965
mesh.

73
00:03:55,965 --> 00:03:56,506
You can think of the...

74
00:03:58,098 --> 00:03:59,719
the following analogy might be helpful.

75
00:03:59,719 --> 00:04:01,580
So here's a couple of bunnies.

76
00:04:01,580 --> 00:04:05,343
You imagine that I have an infinitely cold,

77
00:04:05,343 --> 00:04:08,085
a thing that stays at a certain cold temperature.

78
00:04:08,085 --> 00:04:09,406
I put it on the ears of the bunny,

79
00:04:09,406 --> 00:04:11,548
and you imagine that I have a thing

80
00:04:11,548 --> 00:04:14,891
that maintains a certain constant hot temperature.

81
00:04:14,891 --> 00:04:16,772
It always stays, you know, 100 degrees,

82
00:04:16,772 --> 00:04:19,014
and I put it on the tail of the bunny, and then I wait.

83
00:04:19,014 --> 00:04:23,397
And so over time, what happens is that

84
00:04:24,385 --> 00:04:26,988
areas near the hot point become hotter,

85
00:04:26,988 --> 00:04:28,971
areas near the cold point become colder,

86
00:04:28,971 --> 00:04:31,013
and heat transitions smoothly from hot to cold

87
00:04:31,013 --> 00:04:32,175
through the mesh.

88
00:04:32,175 --> 00:04:34,598
This is the effect we're trying to achieve.

89
00:04:35,729 --> 00:04:40,632
What basically happens over time in the real world is that you reach an equilibrium state.

90
00:04:40,632 --> 00:04:43,193
And this is a course that's known as the heat equation.

91
00:04:43,193 --> 00:04:45,734
This is an example of a partial differential equation.

92
00:04:45,734 --> 00:04:50,096
It's probably the first basic one that you would study in a PDE's course.

93
00:04:50,096 --> 00:04:54,478
So we want to create this effect on a computer with a triangle mesh.

94
00:04:56,754 --> 00:04:58,915
So first let's talk about what we mean by smooth.

95
00:04:58,915 --> 00:05:03,716
So, because this is a math course, we will use math to define what is meant by smooth.

96
00:05:03,716 --> 00:05:06,616
We would like the function on the mesh to be continuous

97
00:05:06,616 --> 00:05:09,817
in the standard sense that you may remember from first year calculus.

98
00:05:09,817 --> 00:05:13,218
We don't want any jumps, we don't want any point discontinuities,

99
00:05:13,218 --> 00:05:14,898
we don't want any weird transitions.

100
00:05:14,898 --> 00:05:18,619
We'd like the change of the function to be smooth as well,

101
00:05:18,619 --> 00:05:22,240
which means that we'd like the derivatives of the function on the mesh

102
00:05:22,240 --> 00:05:25,081
to exist and to be continuous.

103
00:05:25,081 --> 00:05:25,621
We don't want any...

104
00:05:26,641 --> 00:05:31,406
huge changes over small distances in our function,

105
00:05:31,406 --> 00:05:34,670
and we also don't want to have any local maxima or minima,

106
00:05:34,670 --> 00:05:36,712
which is, for instance, a point that just randomly

107
00:05:36,712 --> 00:05:38,153
gets hot or cold for no good reason.

108
00:05:38,153 --> 00:05:40,976
All of these things are sort of undesirable

109
00:05:40,976 --> 00:05:44,379
because we can't control them.

110
00:05:44,379 --> 00:05:46,722
Defining by no sudden changes.

111
00:05:49,189 --> 00:05:50,991
If you think back to multivariate calculus,

112
00:05:50,991 --> 00:05:53,753
you may have learned about the gradient operator.

113
00:05:53,753 --> 00:05:57,355
The gradient operator on a vector-valued function

114
00:05:59,675 --> 00:06:04,076
points in the direction of maximum change.

115
00:06:04,076 --> 00:06:07,558
So in our case, we aren't interested in the direction

116
00:06:07,558 --> 00:06:09,839
as much as we're interested in the length of the gradient.

117
00:06:09,839 --> 00:06:13,180
And so saying that I don't want large changes

118
00:06:13,180 --> 00:06:16,881
means that I want to minimize the length of that gradient

119
00:06:16,881 --> 00:06:20,223
vector of my function everywhere on a mesh.

120
00:06:20,223 --> 00:06:24,104
More formally, we can say, OK, how do I construct length

121
00:06:24,104 --> 00:06:24,424
over mesh?

122
00:06:25,727 --> 00:06:27,047
I might actually try as well.

123
00:06:27,047 --> 00:06:30,388
Each point on the mesh, I want to take the gradient.

124
00:06:30,388 --> 00:06:32,148
I want to take its length squared.

125
00:06:32,148 --> 00:06:33,009
Let's say that's fine.

126
00:06:33,009 --> 00:06:35,509
That's given by that inner product there.

127
00:06:35,509 --> 00:06:38,370
And over the entire mesh, every little bit of area on the mesh,

128
00:06:38,370 --> 00:06:39,951
I want to sum all those up.

129
00:06:39,951 --> 00:06:43,092
And that's a surface integral.

130
00:06:43,092 --> 00:06:46,573
And this is known as the Dirichlet energy of F.

131
00:06:46,573 --> 00:06:48,273
I believe that's the correct pronunciation.

132
00:06:48,273 --> 00:06:49,814
German speakers, pardon me if I'm wrong.

133
00:06:49,814 --> 00:06:49,874
And

134
00:06:52,788 --> 00:06:54,910
This was one of the first problems

135
00:06:54,910 --> 00:06:57,012
that was studied in the calculus of variations.

136
00:06:57,012 --> 00:06:59,815
I was going to say something here.

137
00:06:59,815 --> 00:07:00,376
OK, I did say it.

138
00:07:00,376 --> 00:07:00,496
Good.

139
00:07:00,496 --> 00:07:04,800
Stating that we don't want any local maxima or minima

140
00:07:04,800 --> 00:07:07,363
in our case means that if we take

141
00:07:07,363 --> 00:07:10,686
the divergence of the gradient function on our mesh,

142
00:07:10,686 --> 00:07:11,587
we would like it to be 0.

143
00:07:11,587 --> 00:07:14,951
The reason we'd like it to be 0 is because,

144
00:07:16,338 --> 00:07:20,610
If there's a point where the divergence is greater than zero or less than zero, it means

145
00:07:20,610 --> 00:07:23,899
that the function is curving into or out of a local maxima or minima.

146
00:07:25,926 --> 00:07:28,707
If we actually write down what the divergence of the gradient

147
00:07:28,707 --> 00:07:32,507
is, you end up with this expression here,

148
00:07:32,507 --> 00:07:36,808
which is the sum of the second order partial derivatives

149
00:07:36,808 --> 00:07:37,989
of the function on the mesh.

150
00:07:37,989 --> 00:07:41,390
This is known as the Laplace equation.

151
00:07:41,390 --> 00:07:45,391
Typically, it is written with this little upside down

152
00:07:45,391 --> 00:07:46,691
triangle.

153
00:07:46,691 --> 00:07:52,672
And if f has a Laplacian of 0 everywhere,

154
00:07:52,672 --> 00:07:54,953
then we call f a harmonic function.

155
00:07:57,108 --> 00:08:05,732
So, very trivially, obviously, if this is zero and we integrate it, that integral on

156
00:08:05,732 --> 00:08:07,572
the previous slide is going to be a constant.

157
00:08:07,572 --> 00:08:16,136
In effect, trivially, we can also say that if you have a constant function, it also trivially

158
00:08:16,136 --> 00:08:22,519
minimizes the Dirichlet energy because the gradient everywhere is zero.

159
00:08:22,519 --> 00:08:23,039
There we go.

160
00:08:24,631 --> 00:08:27,714
So by itself, Dirichlet energy is boring.

161
00:08:27,714 --> 00:08:28,955
The Laplacian is fairly boring.

162
00:08:28,955 --> 00:08:31,297
Where it gets exciting for us is if we do the following.

163
00:08:31,297 --> 00:08:33,479
We take our triangle mesh, because we're

164
00:08:33,479 --> 00:08:34,640
dealing with a real object here.

165
00:08:34,640 --> 00:08:37,342
I know this just seems like math for math's sake.

166
00:08:37,342 --> 00:08:42,286
We set some points on the mesh to be some known values, a

167
00:08:42,286 --> 00:08:43,988
and b.

168
00:08:43,988 --> 00:08:45,930
We'd like a to be less than b arbitrarily.

169
00:08:47,378 --> 00:08:49,140
If you're a physicist or a mathematician,

170
00:08:49,140 --> 00:08:50,942
you will call these Dirichlet boundary conditions.

171
00:08:50,942 --> 00:08:52,583
We don't really care.

172
00:08:52,583 --> 00:08:54,825
They're just the points that we want to set on the mesh

173
00:08:54,825 --> 00:08:57,607
to control the behavior of the function

174
00:08:57,607 --> 00:08:58,368
that we are generating.

175
00:08:59,975 --> 00:09:01,555
There's a famous result in mathematics

176
00:09:01,555 --> 00:09:02,855
called the strong maximum principle.

177
00:09:02,855 --> 00:09:05,076
And what the strong maximum principle states

178
00:09:05,076 --> 00:09:08,477
is that f is a harmonic function everywhere

179
00:09:08,477 --> 00:09:09,877
except on its boundary.

180
00:09:09,877 --> 00:09:12,238
And in this case, its boundary is just precisely

181
00:09:12,238 --> 00:09:12,918
where we took the mesh.

182
00:09:12,918 --> 00:09:15,279
And you can imagine that we took a pin everywhere

183
00:09:15,279 --> 00:09:16,739
where we want to put one of these control points,

184
00:09:16,739 --> 00:09:18,840
and we punctured the mesh repeatedly.

185
00:09:18,840 --> 00:09:21,501
Then the holes are the boundary, and everywhere else

186
00:09:21,501 --> 00:09:21,861
is the mesh.

187
00:09:21,861 --> 00:09:24,141
So the strong maximum principle states

188
00:09:24,141 --> 00:09:25,902
that if f is a harmonic function everywhere else,

189
00:09:25,902 --> 00:09:29,143
then you can take any disk on the mesh.

190
00:09:30,089 --> 00:09:32,552
And by disk, I mean you just draw a little circle on it.

191
00:09:32,552 --> 00:09:38,057
And then the function will have its maximum and its

192
00:09:38,057 --> 00:09:41,340
minimum on the boundary of the disk.

193
00:09:41,340 --> 00:09:44,463
So it won't ever obtain a maximum or a

194
00:09:44,463 --> 00:09:45,985
minimum inside the disk.

195
00:09:45,985 --> 00:09:46,966
It will always be on the boundary.

196
00:09:46,966 --> 00:09:48,707
You can draw that anywhere on the mesh, and

197
00:09:48,707 --> 00:09:49,508
that property holds.

198
00:09:50,899 --> 00:09:56,565
This is a very, very, very strong thing we can say about a function on a mesh,

199
00:09:56,565 --> 00:10:04,072
which is why this whole strategy of analyzing meshes by looking at functions on them is so powerful.

200
00:10:04,072 --> 00:10:12,040
So, in particular, what this means for our case is that if I have some maximum and minimum values A and B,

201
00:10:12,040 --> 00:10:13,962
and I have a harmonic function on the mesh,

202
00:10:14,579 --> 00:10:17,761
that has those points at the boundary set to what I want them to be set to,

203
00:10:17,761 --> 00:10:21,503
then it will only ever obtain them there,

204
00:10:21,503 --> 00:10:25,485
and it will smoothly transition between them everywhere else.

205
00:10:25,485 --> 00:10:27,927
So, how do we find this thing?

206
00:10:27,927 --> 00:10:31,649
We have a continuous thing,

207
00:10:31,649 --> 00:10:34,090
which means that it's defined on arbitrary surfaces,

208
00:10:34,090 --> 00:10:37,532
which is that the Laplacian of my function should be equal to zero.

209
00:10:37,532 --> 00:10:42,195
The good news is that I went to last year's talk that I gave,

210
00:10:42,195 --> 00:10:42,795
because I was there.

211
00:10:44,370 --> 00:10:47,772
And there is a well-known discretized equivalent

212
00:10:47,772 --> 00:10:51,014
to the Laplacian operator called the Mesh Laplacian.

213
00:10:51,014 --> 00:10:56,557
It basically tells you how to construct a discrete version

214
00:10:56,557 --> 00:10:57,418
of this on a triangle mesh.

215
00:10:57,418 --> 00:10:59,699
Then what you end up with is you end up

216
00:10:59,699 --> 00:11:02,461
with a system of linear equations, a very large one,

217
00:11:02,461 --> 00:11:03,662
but it's sparse.

218
00:11:03,662 --> 00:11:09,866
You plug it into your favorite standard sparse matrix solver,

219
00:11:09,866 --> 00:11:10,786
and you find the solution.

220
00:11:11,565 --> 00:11:15,706
I'm not going to get too much into how the discretized mesh Laplacian is actually derived

221
00:11:15,706 --> 00:11:19,748
because to be quite honest, what you do is you just, you do this with a cookbook.

222
00:11:19,748 --> 00:11:25,130
And we don't want to get into any of the mechanisms that you can use to actually derive it.

223
00:11:25,130 --> 00:11:28,371
It's enough to know that it exists and sort of have some idea of when and where you would

224
00:11:28,371 --> 00:11:28,592
use it.

225
00:11:28,592 --> 00:11:33,854
I might put some notes in this on the slides to go up on the website because that just

226
00:11:33,854 --> 00:11:35,754
seems to be what we do.

227
00:11:35,754 --> 00:11:35,834
So

228
00:11:37,000 --> 00:11:39,881
The way that you write it is you use this little fellow here.

229
00:11:39,881 --> 00:11:41,201
And basically what it's saying is

230
00:11:41,201 --> 00:11:45,243
that if I take my harmonic function

231
00:11:45,243 --> 00:11:47,983
and I look at the harmonic function

232
00:11:47,983 --> 00:11:50,945
of every vertex on the mesh, then the

233
00:11:52,575 --> 00:11:57,158
Discrete Laplacian is given as a weighted sum of distances

234
00:11:57,158 --> 00:11:59,919
of the function across the mesh edges.

235
00:11:59,919 --> 00:12:03,361
You choose appropriate weights for this to actually work.

236
00:12:03,361 --> 00:12:07,164
It turns out that for this particular application,

237
00:12:07,164 --> 00:12:10,125
last year I said that you could use uniform weights, whatever.

238
00:12:10,125 --> 00:12:13,107
This year you have to use what are called cotangent weights.

239
00:12:13,107 --> 00:12:15,508
Cotangent weights come from the observation

240
00:12:15,508 --> 00:12:17,529
that if you have a triangle lying on its side,

241
00:12:17,529 --> 00:12:19,971
and it's got a base here, that the aspect

242
00:12:19,971 --> 00:12:21,752
ratio of the triangle from width to height.

243
00:12:22,653 --> 00:12:27,881
is a function of the cotangents of the interior angles.

244
00:12:27,881 --> 00:12:29,384
So here we're just taking an average

245
00:12:29,384 --> 00:12:31,668
of those with the height ratios when we're actually

246
00:12:31,668 --> 00:12:34,632
constructing this discretization.

247
00:12:35,842 --> 00:12:39,524
Last year, we used the Laplacian in a matrix form,

248
00:12:39,524 --> 00:12:42,326
where we basically said, OK, I'm going

249
00:12:42,326 --> 00:12:44,848
to take the Laplacian of my mesh.

250
00:12:44,848 --> 00:12:47,730
I'm going to construct this differential representation.

251
00:12:47,730 --> 00:12:49,831
I'm going to take some anchor points.

252
00:12:49,831 --> 00:12:52,993
I'm going to put them at specific locations.

253
00:12:52,993 --> 00:12:58,097
I'm going to invert my matrix with anchor point conditions.

254
00:12:58,097 --> 00:12:59,618
And then I'm going to do a least squares

255
00:12:59,618 --> 00:13:01,619
optimization in order to actually.

256
00:13:02,800 --> 00:13:05,643
create a new deformed mesh that is smooth.

257
00:13:05,643 --> 00:13:08,066
This year, we don't actually need to do any of that.

258
00:13:08,066 --> 00:13:10,649
But it is important to remember from last year

259
00:13:10,649 --> 00:13:12,952
that if you have a least squares problem

260
00:13:12,952 --> 00:13:16,816
where you have some linear equation,

261
00:13:16,816 --> 00:13:18,518
say the form AX equals BA is a max.

262
00:13:18,878 --> 00:13:21,579
is a matrix, B is a vector of known constants,

263
00:13:21,579 --> 00:13:22,840
and X is your unknowns.

264
00:13:22,840 --> 00:13:27,442
And you want to come up with the solution where

265
00:13:27,442 --> 00:13:32,225
each the sum of the difference between X and B squared.

266
00:13:33,562 --> 00:13:36,844
or sum of squared distances, rather, is as small as possible,

267
00:13:36,844 --> 00:13:40,326
then it is a well-known fact that you can do it

268
00:13:40,326 --> 00:13:43,628
by taking your matrix A, transposing it,

269
00:13:43,628 --> 00:13:45,149
multiplying both sides by the transpose.

270
00:13:45,149 --> 00:13:49,151
The resulting linear equation is actually

271
00:13:49,151 --> 00:13:51,212
guaranteed to have a solution.

272
00:13:51,212 --> 00:13:53,614
Furthermore, it is guaranteed to be a symmetric matrix, A

273
00:13:53,614 --> 00:13:56,035
transpose A. It's also guaranteed to be

274
00:13:56,035 --> 00:13:57,896
what is called positive definite, which

275
00:13:57,896 --> 00:14:00,518
means that you can use specialized

276
00:14:00,518 --> 00:14:02,839
of linear algebra packages to actually solve this thing.

277
00:14:04,300 --> 00:14:06,241
Don't write your own linear algebra software kits.

278
00:14:06,241 --> 00:14:08,883
Use, there's code out there that you can use.

279
00:14:08,883 --> 00:14:10,104
There's trollmod, there's talks,

280
00:14:10,104 --> 00:14:11,545
there's a library called Eigen,

281
00:14:11,545 --> 00:14:14,286
which is compatible with most of the licensing needs

282
00:14:14,286 --> 00:14:15,267
we have as game developers.

283
00:14:15,267 --> 00:14:18,489
I've had a few funny issues with it,

284
00:14:18,489 --> 00:14:21,651
and it is very templated.

285
00:14:21,651 --> 00:14:24,232
Anyways, going back to what we're actually talking about,

286
00:14:24,232 --> 00:14:27,054
I said that we have a,

287
00:14:27,983 --> 00:14:29,964
We're trying to find this harmonic function

288
00:14:29,964 --> 00:14:34,346
that has known points, so points where it must hold water.

289
00:14:34,346 --> 00:14:39,428
Using a solver of this type, this least square solution,

290
00:14:39,428 --> 00:14:43,509
does not give me any guarantee that it

291
00:14:43,509 --> 00:14:46,810
will have those boundary points that I so desperately

292
00:14:46,810 --> 00:14:48,191
love and need in order for this to work.

293
00:14:48,191 --> 00:14:51,052
It will try to fit them, but it will do so by distributing

294
00:14:51,052 --> 00:14:52,032
error all over the place.

295
00:14:52,032 --> 00:14:53,973
So we need to actually expand.

296
00:14:54,987 --> 00:14:58,733
our least squares solver in order to satisfy constraints.

297
00:14:58,733 --> 00:15:00,816
So there's two ways of doing this for this particular

298
00:15:00,816 --> 00:15:02,119
problem set up.

299
00:15:02,119 --> 00:15:02,620
System one.

300
00:15:03,607 --> 00:15:07,209
As it turns out, if you just construct the entire system

301
00:15:07,209 --> 00:15:09,330
of linear equations you want for the Laplacian

302
00:15:09,330 --> 00:15:11,371
and for the boundary conditions, you

303
00:15:11,371 --> 00:15:15,173
can actually get something that is solvable without needing

304
00:15:15,173 --> 00:15:16,394
least squares optimization.

305
00:15:16,394 --> 00:15:21,657
The problem is that this is just a little bit numerically

306
00:15:21,657 --> 00:15:24,179
unstable, which means that if you actually

307
00:15:24,179 --> 00:15:26,880
try to run real linear algebra software on this matrix

308
00:15:26,880 --> 00:15:28,641
because its condition number is so awful,

309
00:15:28,641 --> 00:15:29,762
it will basically explode.

310
00:15:29,762 --> 00:15:32,564
And then you're left holding a bunch of pieces and wondering

311
00:15:32,564 --> 00:15:33,004
what happened.

312
00:15:35,369 --> 00:15:35,990
Not recommended.

313
00:15:35,990 --> 00:15:41,674
What we do recommend, typically for this, is going back to another idea from multivariable

314
00:15:41,674 --> 00:15:46,258
calculus and another French mathematician.

315
00:15:46,258 --> 00:15:50,461
When you have a function that you want to minimize, subject to some constraint at some

316
00:15:50,461 --> 00:15:54,664
point, what you traditionally use is you use what is called a Lagrange multiplier.

317
00:15:54,664 --> 00:15:56,445
Maybe you've heard of this, maybe you haven't.

318
00:15:56,445 --> 00:16:01,149
The idea is that instead of minimizing f.

319
00:16:01,764 --> 00:16:07,239
such that some equality constraint holds is that you add a new variable, lambda, and then

320
00:16:07,239 --> 00:16:07,741
you try to minimize.

321
00:16:09,031 --> 00:16:12,134
a thing in three dimensions here, which is x, y, and lambda

322
00:16:12,134 --> 00:16:13,415
are your unknowns.

323
00:16:13,415 --> 00:16:15,537
And you're minimizing f, x, and y,

324
00:16:15,537 --> 00:16:18,200
minus how far off I am from the constraint

325
00:16:18,200 --> 00:16:19,661
that I'm trying to achieve.

326
00:16:19,661 --> 00:16:21,002
And if you need more constraints,

327
00:16:21,002 --> 00:16:22,404
you've got more boundary points, you

328
00:16:22,404 --> 00:16:24,345
want to set specific things when you're

329
00:16:24,345 --> 00:16:27,008
doing a solve like this, you just add more lambdas.

330
00:16:27,008 --> 00:16:28,269
You add one lambda per point.

331
00:16:28,269 --> 00:16:30,631
And yes, your matrix gets larger and larger and larger,

332
00:16:30,631 --> 00:16:31,192
but who cares?

333
00:16:31,192 --> 00:16:31,793
It's still sparse.

334
00:16:32,868 --> 00:16:37,950
So, if you do this, what you end up with is you end up building a system of linear equations.

335
00:16:37,950 --> 00:16:42,692
Top half says, all my discrete Laplacians, using the expression before, are 0.

336
00:16:42,692 --> 00:16:48,735
Second half says, for each of my boundary conditions that I want to be true for these Dirichlet boundary conditions,

337
00:16:48,735 --> 00:16:50,455
I add a Lagrange multiplier.

338
00:16:51,171 --> 00:16:53,913
Then you minimize the resulting quadratic energy

339
00:16:53,913 --> 00:16:56,754
by taking that big matrix, squaring it,

340
00:16:56,754 --> 00:16:59,396
no, sorry, finding its transpose,

341
00:16:59,396 --> 00:17:01,177
multiplying A by the transpose,

342
00:17:01,177 --> 00:17:03,338
multiplying the right-hand side by the transpose,

343
00:17:03,338 --> 00:17:06,300
dump that in your sparse positive definite matrix solver,

344
00:17:06,300 --> 00:17:09,682
and it will basically, for every vertex on your mesh,

345
00:17:09,682 --> 00:17:12,223
it will spit out a harmonic function, basically like magic.

346
00:17:12,223 --> 00:17:13,764
So that's a lot of setup.

347
00:17:13,764 --> 00:17:17,106
So here's what it actually looks like.

348
00:17:17,870 --> 00:17:22,013
So here is a model from one of the papers that I referenced.

349
00:17:22,013 --> 00:17:25,155
And this gives you an idea of some of the useful effects you

350
00:17:25,155 --> 00:17:25,675
can achieve.

351
00:17:25,675 --> 00:17:27,736
And you can immediately see how this would be useful.

352
00:17:27,736 --> 00:17:30,398
So here we have a couple of control points.

353
00:17:30,398 --> 00:17:32,579
We've got one on the top of the head, one on the base of

354
00:17:32,579 --> 00:17:34,220
this statue of dancing children.

355
00:17:36,106 --> 00:17:38,347
And at the top of it, it achieves its maximum,

356
00:17:38,347 --> 00:17:39,728
and the bottom achieves its minimum.

357
00:17:39,728 --> 00:17:42,150
And you can see that it smoothly interplates

358
00:17:42,150 --> 00:17:43,191
the values everywhere.

359
00:17:43,191 --> 00:17:45,192
So you can create stripe effects on meshes

360
00:17:45,192 --> 00:17:47,514
that are very intuitive and natural.

361
00:17:47,514 --> 00:17:50,275
You can smoothly blend textures along surfaces

362
00:17:50,275 --> 00:17:51,516
that are very easy and natural.

363
00:17:51,516 --> 00:17:55,259
So if you have an arbitrary shape like, say, a tank,

364
00:17:55,799 --> 00:17:58,421
and you want to put rust on the tank in some areas,

365
00:17:58,421 --> 00:18:00,823
that you can just imagine, well, your texture

366
00:18:00,823 --> 00:18:04,086
is going to obtain those maximum areas in the areas

367
00:18:04,086 --> 00:18:06,508
where I want rust and minimum areas where I don't want rust.

368
00:18:06,508 --> 00:18:08,469
And you just throw the whole thing in the solver

369
00:18:08,469 --> 00:18:11,592
and it spits out smooth blending for the entire shape

370
00:18:11,592 --> 00:18:12,092
of your tank.

371
00:18:12,593 --> 00:18:14,494
in whatever order you need.

372
00:18:14,494 --> 00:18:15,815
And if you aren't happy with this pattern,

373
00:18:15,815 --> 00:18:17,075
another nice thing is, of course,

374
00:18:17,075 --> 00:18:18,916
is you can always add more constraints.

375
00:18:18,916 --> 00:18:21,758
So here, if you put a constraint on the top of each

376
00:18:21,758 --> 00:18:23,799
of everybody's heads, then you can

377
00:18:23,799 --> 00:18:25,800
see you get the same stripe pattern you were getting

378
00:18:25,800 --> 00:18:27,621
before in this case.

379
00:18:27,621 --> 00:18:29,502
But now you're getting all of the whorls,

380
00:18:29,502 --> 00:18:30,723
and you're getting all of the stripes

381
00:18:30,723 --> 00:18:31,923
exactly where you want them.

382
00:18:31,923 --> 00:18:35,145
So it's a very powerful technique

383
00:18:35,145 --> 00:18:39,548
for smoothly and efficiently creating smooth functions

384
00:18:39,548 --> 00:18:40,968
on just arbitrary triangle meshes.

385
00:18:43,057 --> 00:18:47,198
Here's an application which is very common in computer graphics, and this is where this

386
00:18:47,198 --> 00:18:53,900
originally started, is that if you have a mesh and you want to very quickly slap a texture

387
00:18:53,900 --> 00:18:55,560
map on it, how do you do this?

388
00:18:55,560 --> 00:19:01,802
So one thing you can do is, okay, you cut it so that it is, the mesh is homeomorphic

389
00:19:01,802 --> 00:19:02,842
to a disk.

390
00:19:02,842 --> 00:19:09,023
Basically, it means that if you had it and you flatten it, you can imagine it's made

391
00:19:09,023 --> 00:19:11,304
of rubber or paper or whatever your...

392
00:19:12,657 --> 00:19:18,502
favorite material for topology is, that it has something which is deformable to the shape

393
00:19:18,502 --> 00:19:22,646
of a disk. It doesn't need to be a disk parameterization itself, as long as you can parameterize that

394
00:19:22,646 --> 00:19:27,950
edge. If you take that edge you created, you put UV coordinates on it somewhere in your

395
00:19:27,950 --> 00:19:31,793
standard 2D plane, those are your boundary conditions, one for each of U and V.

396
00:19:32,800 --> 00:19:35,564
And then you find two harmonic functions.

397
00:19:35,564 --> 00:19:38,528
And then what happens, shalomigyalomizoop, is that

398
00:19:38,528 --> 00:19:40,791
suddenly you have parameterized your entire

399
00:19:40,791 --> 00:19:45,858
mesh by magic to fit into the bounds of the texture map that

400
00:19:45,858 --> 00:19:46,579
you were trying to create.

401
00:19:47,515 --> 00:19:52,376
And in fact, it's guaranteed to, in this case, be bijective.

402
00:19:52,376 --> 00:19:53,816
So you can go from one to the other.

403
00:19:53,816 --> 00:19:54,697
There are no inversions.

404
00:19:54,697 --> 00:19:56,017
There are no triangles on top of each other.

405
00:19:56,017 --> 00:20:00,198
As you can see, there's a great deal of uneven distribution

406
00:20:00,198 --> 00:20:01,158
of texture information.

407
00:20:01,158 --> 00:20:03,219
The top of the camel's head, which is furthest away from

408
00:20:03,219 --> 00:20:08,780
the disk, has a higher concentration of checkerboards

409
00:20:08,780 --> 00:20:10,721
on it than the bottom does.

410
00:20:10,721 --> 00:20:12,762
So it is not perfect for all things.

411
00:20:12,762 --> 00:20:14,922
But this will basically get you up and running very fast.

412
00:20:15,851 --> 00:20:18,212
So the sky is the limit here.

413
00:20:18,212 --> 00:20:21,253
Second technique I sort of want to talk to you about today

414
00:20:21,253 --> 00:20:24,895
is mean value coordinates.

415
00:20:24,895 --> 00:20:28,436
So many of you will have seen barycentric coordinates.

416
00:20:28,436 --> 00:20:29,877
In fact, if you're in computer graphics,

417
00:20:29,877 --> 00:20:32,178
you must have seen them or used them at some point

418
00:20:32,178 --> 00:20:34,819
because they are the principle behind which

419
00:20:34,819 --> 00:20:36,780
basically all shading works.

420
00:20:36,780 --> 00:20:38,441
And the idea is that if you have a triangle

421
00:20:38,441 --> 00:20:40,522
and it's hanging around in space,

422
00:20:40,522 --> 00:20:41,462
you can write any...

423
00:20:42,429 --> 00:20:46,753
point on the triangle as a linear combination

424
00:20:46,753 --> 00:20:53,780
of the vertices of the triangle, such that all the weights are

425
00:20:53,780 --> 00:20:57,043
greater than equal to 0, and they sum to 1.

426
00:20:57,043 --> 00:20:59,085
And in fact, at the corners, it's exactly 1.

427
00:20:59,085 --> 00:21:00,726
And the nice thing for our problem

428
00:21:00,726 --> 00:21:03,149
here is that if you have a function at the vertices,

429
00:21:03,149 --> 00:21:07,152
like, say, color information or lighting,

430
00:21:07,152 --> 00:21:07,573
you can then.

431
00:21:08,736 --> 00:21:14,745
smoothly blend that function across the triangle in order to define it on the interior of the

432
00:21:14,745 --> 00:21:17,990
triangle and that's basically how all of computer graphics works is this one thing.

433
00:21:19,724 --> 00:21:24,086
We would like to generalize this to larger classes of polygons.

434
00:21:24,086 --> 00:21:26,447
So for instance, ones that aren't triangles,

435
00:21:26,447 --> 00:21:30,049
like convex polygons, star-shaped polygons.

436
00:21:30,049 --> 00:21:31,910
A star-shaped polygon is a polygon

437
00:21:31,910 --> 00:21:34,010
where there is one central point such

438
00:21:34,010 --> 00:21:36,452
that you can reach it via a straight line

439
00:21:36,452 --> 00:21:37,732
from any other point in the polygon,

440
00:21:37,732 --> 00:21:39,213
and it doesn't go through a boundary.

441
00:21:39,433 --> 00:21:41,496
Even just simple polygons in the plane,

442
00:21:41,496 --> 00:21:42,818
or even just polygons of holes.

443
00:21:42,818 --> 00:21:44,720
What the heck, let's just do them all.

444
00:21:44,720 --> 00:21:46,462
So here's sort of what we would like.

445
00:21:46,462 --> 00:21:48,525
We'd like to maintain this convexity property,

446
00:21:48,525 --> 00:21:50,448
which is that our weights should be positive

447
00:21:50,448 --> 00:21:52,771
when they're inside the polygon and negative outside.

448
00:21:52,771 --> 00:21:54,533
We'd like it to smoothly interpolate data.

449
00:21:55,134 --> 00:22:02,199
thing like colors. We'd like it to satisfy this Lagrange property, which is that at a vertex,

450
00:22:02,199 --> 00:22:06,783
only one weight is set to one, and it's the weight for that vertex, and the rest of them

451
00:22:06,783 --> 00:22:10,205
should be set to zero. Ideally, we would like it that all weights sum to one.

452
00:22:14,197 --> 00:22:16,459
The first stab at this might be to take the cotangents

453
00:22:16,459 --> 00:22:18,681
previously used for the harmonic functions

454
00:22:18,681 --> 00:22:22,584
and just try to use those.

455
00:22:22,584 --> 00:22:25,367
It turns out that those weights actually

456
00:22:25,367 --> 00:22:26,428
violate the convexity.

457
00:22:26,428 --> 00:22:29,531
The weights that you want to use are

458
00:22:29,531 --> 00:22:31,573
invented by a very smart man.

459
00:22:33,393 --> 00:22:35,894
Michael Floter, and they're called mean value coordinate

460
00:22:35,894 --> 00:22:36,615
weights.

461
00:22:36,615 --> 00:22:38,356
And what he did is he took the harmonic map

462
00:22:38,356 --> 00:22:40,417
that we looked at previously, and he

463
00:22:40,417 --> 00:22:43,980
derived a piecewise linear approximation of it,

464
00:22:43,980 --> 00:22:45,461
and then did a whole bunch of trig.

465
00:22:45,461 --> 00:22:48,983
And what happens is you end up with this weight

466
00:22:48,983 --> 00:22:54,407
in terms of the tangents, the angles around a given vertex.

467
00:22:57,845 --> 00:22:59,106
for wherever you're trying to get to.

468
00:22:59,106 --> 00:23:00,428
So you have a point in a polygon v0,

469
00:23:00,428 --> 00:23:03,572
and you're interested in weight i for it,

470
00:23:03,572 --> 00:23:05,615
which is one of the vertices of the polygon.

471
00:23:05,615 --> 00:23:07,097
You compute that function.

472
00:23:07,097 --> 00:23:09,039
This will work like a barycentric coordinate

473
00:23:09,039 --> 00:23:11,943
any time you want to linearly interpolate colors or whatever.

474
00:23:12,903 --> 00:23:16,264
If you make a slight generalization,

475
00:23:16,264 --> 00:23:19,705
which is that you require the angles that you compute here

476
00:23:19,705 --> 00:23:20,725
to be signed.

477
00:23:20,725 --> 00:23:22,846
And a signed angle in this case means

478
00:23:22,846 --> 00:23:24,426
that if you actually compute it by taking

479
00:23:24,426 --> 00:23:27,146
the cross product of the vectors in question,

480
00:23:27,146 --> 00:23:28,987
if you remember from linear algebra,

481
00:23:28,987 --> 00:23:33,688
the length of a cross product length

482
00:23:33,688 --> 00:23:36,128
is, I believe, length of u, length of v, sine theta.

483
00:23:36,128 --> 00:23:38,909
If you actually take the sine of the cross product,

484
00:23:40,169 --> 00:23:42,990
it will tell you what the sign of that angle should be.

485
00:23:42,990 --> 00:23:48,031
This lets you actually generalize it to an arc polygon on a plane.

486
00:23:48,031 --> 00:23:51,932
The good news is also that the weight of a vertex in this thing

487
00:23:51,932 --> 00:23:55,192
depends only on three vertices, itself and its neighbors.

488
00:23:55,192 --> 00:23:59,053
The other good news is you can do all of this in about 20 lines of code,

489
00:23:59,053 --> 00:24:02,314
provided that you have a function for computing the area of a triangle.

490
00:24:02,314 --> 00:24:05,495
Here's why it's cool.

491
00:24:06,512 --> 00:24:10,295
So here you've got a planar polygon, a bunch of layers.

492
00:24:10,295 --> 00:24:13,858
You put color on points, and you can actually smoothly

493
00:24:13,858 --> 00:24:16,139
interplate all of these colors just

494
00:24:16,139 --> 00:24:19,201
by pretending that the entire thing is one big triangle

495
00:24:19,201 --> 00:24:22,304
and using these weights.

496
00:24:22,304 --> 00:24:26,887
This is guaranteed to be smooth everywhere

497
00:24:26,887 --> 00:24:29,009
except at the vertices, where obviously you

498
00:24:29,009 --> 00:24:29,749
control the vertices.

499
00:24:29,749 --> 00:24:31,290
You can screw things up as much as you like.

500
00:24:32,378 --> 00:24:40,227
Other applications of this technique with these coordinates include for instance texture parameterization is if you have something

501
00:24:40,675 --> 00:24:44,295
and you can project its boundary to a plane in a meaningful way.

502
00:24:44,295 --> 00:24:45,616
You can use mean value coordinates

503
00:24:45,616 --> 00:24:47,636
to get all of the interior points onto the plane,

504
00:24:47,636 --> 00:24:50,797
so you can move a big patch meaningfully from 3D space

505
00:24:50,797 --> 00:24:53,537
to 2D space, work on the patch.

506
00:24:53,537 --> 00:24:57,278
You can generalize this to handle 3D polyhedra, which

507
00:24:57,278 --> 00:25:00,399
means you can then do things like cage-based deformation.

508
00:25:00,399 --> 00:25:01,799
It's the same formula.

509
00:25:01,799 --> 00:25:03,219
It's just more work to get there.

510
00:25:03,219 --> 00:25:06,780
You can use it for smooth shading of 2D polygons,

511
00:25:06,780 --> 00:25:07,280
if you wish.

512
00:25:09,436 --> 00:25:11,478
Again, possibilities are endless and it's up to you.

513
00:25:11,478 --> 00:25:15,222
So what I'd really like everybody to take away from

514
00:25:15,222 --> 00:25:21,689
this, regardless of how comfortable you are with

515
00:25:23,206 --> 00:25:28,009
you know, Laplacians or mean value coordinates or whatever,

516
00:25:28,009 --> 00:25:31,670
it is a very powerful technique to be able to take a mesh

517
00:25:31,670 --> 00:25:33,872
and put a function on it and then look at that function

518
00:25:33,872 --> 00:25:34,252
instead.

519
00:25:34,252 --> 00:25:35,573
This is just the tip of the iceberg.

520
00:25:35,573 --> 00:25:39,074
The two methods which I have hastily outlined here and.

521
00:25:39,615 --> 00:25:42,797
I don't expect everybody, you know, I don't expect you to be able to go code them.

522
00:25:42,797 --> 00:25:48,022
I expect you to have sort of had a look at them so that you can now go and see, ah, okay,

523
00:25:48,022 --> 00:25:52,846
these are the things that I need to know in order to be able to understand this and to

524
00:25:52,846 --> 00:25:54,868
have some appreciation of what they can do.

525
00:25:54,868 --> 00:26:00,312
Harmonic maps on a mesh are extremely powerful because you can define boundary conditions

526
00:26:00,312 --> 00:26:01,053
anywhere you want.

527
00:26:02,514 --> 00:26:03,915
Fairly simple to implement if you're

528
00:26:03,915 --> 00:26:05,116
comfortable with linear algebra.

529
00:26:05,116 --> 00:26:07,719
The actual math behind it is scary

530
00:26:07,719 --> 00:26:10,161
because it comes from work being done by mathematicians

531
00:26:10,161 --> 00:26:11,462
in the 18th and 19th century.

532
00:26:11,462 --> 00:26:13,664
The implementation is fairly straightforward

533
00:26:13,664 --> 00:26:16,026
because we're working in a discrete case,

534
00:26:16,026 --> 00:26:18,127
and it's basically sums in a matrix.

535
00:26:18,127 --> 00:26:20,029
Mean value coordinates, very simple.

536
00:26:20,874 --> 00:26:25,797
Again, you just find your formula, you work out your weights for a point that you're interested

537
00:26:25,797 --> 00:26:32,720
in, and then you can linearly interpolate colors, texture data, whatever you feel like,

538
00:26:32,720 --> 00:26:35,301
over the surface of this thing.

539
00:26:35,301 --> 00:26:40,004
I'll have source code for these next week, and I mean it this year.

540
00:26:40,004 --> 00:26:42,465
Last year's source code is still not up.

541
00:26:42,465 --> 00:26:45,866
I will try to rectify that next week as well.

542
00:26:47,095 --> 00:26:50,296
Some references and useful material if you decide that you're interested in this.

543
00:26:50,296 --> 00:26:50,356
The...

544
00:26:50,356 --> 00:26:54,438
Michael Floater did a number of papers on mean value coordinates.

545
00:26:54,438 --> 00:26:57,919
He started with just the convex case, then he did star-shaped arbitrary polygons in 3D

546
00:26:57,919 --> 00:27:01,079
and generalized barycentric coordinates.

547
00:27:01,079 --> 00:27:05,341
Probably the most useful one for our purposes is called Mean Value Coordinates for Arbitrary

548
00:27:05,341 --> 00:27:07,701
Polygonal Polygons, which is a joint paper with Kai Hormann.

549
00:27:08,502 --> 00:27:11,525
There are a number of papers on harmonic fields.

550
00:27:11,525 --> 00:27:15,770
This is a recent example of one which also talks about the fastest methods for updating

551
00:27:15,770 --> 00:27:19,213
a harmonic field, harmonic surface, harmonic mesh.

552
00:27:21,837 --> 00:27:24,438
might be useful to you if you are interested in doing these

553
00:27:24,438 --> 00:27:25,398
in a real-time context.

554
00:27:25,398 --> 00:27:28,640
The setup for that is a little fussy.

555
00:27:28,640 --> 00:27:33,181
There is a public implementation of a harmonic

556
00:27:33,181 --> 00:27:36,042
mapping function in a great library called libigl

557
00:27:36,042 --> 00:27:37,923
by Alec Jacobson.

558
00:27:37,923 --> 00:27:39,963
It is MIT and BSD licensed.

559
00:27:39,963 --> 00:27:42,644
It includes everything that you need to use to go,

560
00:27:42,644 --> 00:27:44,485
and it is header-based.

561
00:27:44,485 --> 00:27:47,506
So you can try this stuff really quickly if you want to

562
00:27:47,506 --> 00:27:49,487
and get a feel for how powerful it is.

563
00:27:51,764 --> 00:27:54,205
There's also a very good talk on Laplacians in general,

564
00:27:54,205 --> 00:27:55,825
which you might want to track down.

565
00:27:55,825 --> 00:28:02,446
And finally, CRC Press has a select books on the expo floor.

566
00:28:02,446 --> 00:28:05,827
This is a recent book by Daniel Cohen-Orr

567
00:28:05,827 --> 00:28:08,148
and a bunch of other very talented authors.

568
00:28:08,148 --> 00:28:09,888
And it includes all the material here

569
00:28:09,888 --> 00:28:13,149
on Laplacians and the Poisson equation for image processing

570
00:28:13,149 --> 00:28:14,769
and a bunch of other useful stuff

571
00:28:14,769 --> 00:28:16,890
that you may want to have in your life.

572
00:28:16,890 --> 00:28:19,150
So I would encourage you to track any of these things

573
00:28:19,150 --> 00:28:19,950
down and read about them.

574
00:28:20,958 --> 00:28:21,598
Questions?

575
00:28:21,598 --> 00:28:37,623
And I am impressed that you all stayed through the vector calculus.

576
00:28:37,623 --> 00:28:39,524
Give yourselves a hand.

577
00:28:39,524 --> 00:28:41,625
Quick question.

578
00:28:41,625 --> 00:28:46,926
Is there sort of a ratio between the number of control points that you can set versus

579
00:28:46,926 --> 00:28:48,587
the number of points you have?

580
00:28:49,762 --> 00:28:52,384
Oh, fun question.

581
00:28:52,384 --> 00:28:57,328
Short answer is that what I would expect to happen

582
00:28:57,328 --> 00:28:59,650
is that, of course, you can over-constrain your problem.

583
00:28:59,650 --> 00:29:03,093
And over-constraint can manifest itself in one of two ways.

584
00:29:03,093 --> 00:29:06,555
First off, what might happen is that your Laplacian matrix may

585
00:29:06,555 --> 00:29:10,018
become numerically unstable in the sense

586
00:29:10,018 --> 00:29:12,180
that its condition number might simply be too high if you

587
00:29:12,180 --> 00:29:14,982
have too many points that are too close to everything else.

588
00:29:14,982 --> 00:29:15,803
In which case, uh,

589
00:29:17,066 --> 00:29:20,352
A direct linear algebra solver will just explode.

590
00:29:20,352 --> 00:29:22,395
An iterative linear algebra solver.

591
00:29:22,395 --> 00:29:25,981
Linear algebra solvers come in two different forms, direct and iterative.

592
00:29:25,981 --> 00:29:27,784
Direct basically attempts to...

593
00:29:29,210 --> 00:29:32,192
crunch the math in the thing directly. And an

594
00:29:32,192 --> 00:29:34,934
iterative one attempts to work by finding increasingly better

595
00:29:34,934 --> 00:29:37,056
and better and better refinements to the solution. An

596
00:29:37,056 --> 00:29:39,037
iterative one will eventually make hay out of it,

597
00:29:39,037 --> 00:29:40,038
but it will be slow as heck.

598
00:29:40,038 --> 00:29:44,401
And of course you may just create something where

599
00:29:44,401 --> 00:29:50,185
it's, it's meaningless, essentially. So there isn't, there isn't

600
00:29:50,185 --> 00:29:54,188
really a point at which it would explode, but

601
00:29:54,188 --> 00:29:56,230
I think I would encourage you to keep those

602
00:29:56,230 --> 00:29:57,751
control points fairly sparse.

603
00:30:01,259 --> 00:30:05,504
Anybody else?

604
00:30:05,504 --> 00:30:08,989
Nope. Wonderful. All right.

605
00:30:08,989 --> 00:30:10,231
Thank you, nicholas.

