1
00:00:04,270 --> 00:00:08,472
So welcome everyone. Make sure to turn off your cell phones, put them on silent.

2
00:00:08,472 --> 00:00:17,515
And if you have a PlayStation Vita or a 3DS with Retro City Rampage DX, get that ready, start up the game.

3
00:00:17,515 --> 00:00:22,297
But again, turn off your volume.

4
00:00:23,734 --> 00:00:26,980
So my talk is on using recorded button input

5
00:00:26,980 --> 00:00:30,427
and a deterministic engine to do automated testing,

6
00:00:30,427 --> 00:00:33,312
instant replays, and a million other things.

7
00:00:33,312 --> 00:00:35,116
Well, a million's an exaggeration.

8
00:00:36,677 --> 00:00:40,179
So, the recipe for this is simply two pieces.

9
00:00:40,179 --> 00:00:41,880
So the recorded button input,

10
00:00:41,880 --> 00:00:45,023
so you record the input that the button presses

11
00:00:45,023 --> 00:00:46,944
and the keys that they press,

12
00:00:46,944 --> 00:00:48,485
and you have a deterministic engine,

13
00:00:48,485 --> 00:00:51,087
which means that if you record the buttons here,

14
00:00:51,087 --> 00:00:52,628
play them back tomorrow,

15
00:00:52,628 --> 00:00:54,490
they play back exactly the same.

16
00:00:54,490 --> 00:01:00,915
So this is about half an hour of the game

17
00:01:00,915 --> 00:01:02,196
playing in 15 seconds.

18
00:01:02,196 --> 00:01:05,958
And if I turned off Vsync, it would run in about five.

19
00:01:13,116 --> 00:01:17,778
So, that's an example of me using it for automated QA.

20
00:01:17,778 --> 00:01:20,599
Because theoretically, you could run it after every single compile,

21
00:01:20,599 --> 00:01:22,540
so any change you make to the code,

22
00:01:22,540 --> 00:01:24,641
you can double-check and make sure that

23
00:01:24,641 --> 00:01:26,241
everything is good and nothing's been broken.

24
00:01:26,241 --> 00:01:30,343
It gives you access to QA 24-7,

25
00:01:30,343 --> 00:01:32,404
so I think we've all been in the case

26
00:01:32,404 --> 00:01:35,285
where we're pulling an all-nighter to submit a milestone

27
00:01:35,285 --> 00:01:37,046
or submit some sort of deadline,

28
00:01:37,046 --> 00:01:40,327
and it saves you from phoning the QA in the middle of the night.

29
00:01:41,707 --> 00:01:43,768
And finally, it allows hands-on QA to be step two.

30
00:01:43,768 --> 00:01:47,191
So you can kind of pre-filter things, run the automated tests.

31
00:01:47,191 --> 00:01:50,514
If they pass, then you get the QA in there to double-check things.

32
00:01:50,514 --> 00:01:53,956
And it's also incredibly multi-platform,

33
00:01:53,956 --> 00:01:56,398
so you can see that I ported to all these platforms,

34
00:01:56,398 --> 00:01:58,640
and all of these platforms work with it,

35
00:01:58,640 --> 00:02:03,164
including the previously unannounced MS-DOS port.

36
00:02:03,164 --> 00:02:05,926
So it's running here on a Pentium 1,

37
00:02:05,926 --> 00:02:08,188
and it would run on a 386 if I still had one.

38
00:02:12,267 --> 00:02:16,090
I also did another thing which I haven't talked about before.

39
00:02:16,090 --> 00:02:19,533
So does anyone have a Vita or a 3DS right now?

40
00:02:19,533 --> 00:02:20,133
Okay.

41
00:02:20,133 --> 00:02:24,237
If you do, you can enter this code on the main menu.

42
00:02:24,237 --> 00:02:29,461
So I started doing this around the time I finished the DX version,

43
00:02:29,461 --> 00:02:32,763
and I started including these automated tests within the game,

44
00:02:32,763 --> 00:02:34,645
so each platform can play through about...

45
00:02:35,439 --> 00:02:38,841
four to eight hours of itself at super speed,

46
00:02:38,841 --> 00:02:40,582
and it just allowed me to,

47
00:02:40,582 --> 00:02:42,643
up to the point of submission to certification,

48
00:02:42,643 --> 00:02:44,504
I can test the build and make sure that it's good.

49
00:02:44,504 --> 00:02:49,187
So use case three was indeed submitting to certification

50
00:02:49,187 --> 00:02:51,369
and all of that.

51
00:02:51,369 --> 00:02:53,450
Last year, I submitted 15 SKUs,

52
00:02:53,450 --> 00:02:56,472
which included nine console cert submissions simultaneously,

53
00:02:56,472 --> 00:02:58,893
without bringing in external QA.

54
00:03:01,039 --> 00:03:03,400
because it really slashes the redundant testing,

55
00:03:03,400 --> 00:03:05,520
because you will find in cases with consoles,

56
00:03:05,520 --> 00:03:06,661
depending on the regions,

57
00:03:06,661 --> 00:03:10,722
they require a separate ROM, a separate executable,

58
00:03:10,722 --> 00:03:12,543
completely separately compiled,

59
00:03:12,543 --> 00:03:14,723
but maybe the only difference is a product code

60
00:03:14,723 --> 00:03:16,584
or a network ID or something like that.

61
00:03:16,584 --> 00:03:20,045
And so it really allows you to really, really fully test one

62
00:03:20,045 --> 00:03:21,985
and then just automate and test the other

63
00:03:21,985 --> 00:03:23,746
and then lightly test it.

64
00:03:23,746 --> 00:03:26,847
And also with resubmissions, I don't know about you guys,

65
00:03:26,847 --> 00:03:28,287
but on two occasions,

66
00:03:28,287 --> 00:03:30,048
on two different console manufacturers,

67
00:03:30,388 --> 00:03:34,730
I've had to resubmit to certification to change two bytes of data.

68
00:03:34,730 --> 00:03:37,191
So, uh, when you have your automated tests,

69
00:03:37,191 --> 00:03:39,432
it really is just, it's not that grueling,

70
00:03:39,432 --> 00:03:42,053
oh my god, I gotta test everything again.

71
00:03:42,053 --> 00:03:44,454
It's just change those two bytes, run the automated tests,

72
00:03:44,454 --> 00:03:47,435
and, you know, as long as you realize it's an isolated change,

73
00:03:47,435 --> 00:03:48,095
you should be good.

74
00:03:48,095 --> 00:03:51,096
Uh, another super valuable thing,

75
00:03:51,096 --> 00:03:53,317
a lot of multiplayer games I know do this,

76
00:03:53,317 --> 00:03:54,598
is catching gameplay bugs.

77
00:03:55,478 --> 00:03:58,420
So every time the game is run, it automatically starts recording.

78
00:03:58,420 --> 00:04:02,184
And then when you exit or when an assert is hit, it dumps that to a file.

79
00:04:02,184 --> 00:04:05,226
And so if a bug occurred, you just stop the game,

80
00:04:05,226 --> 00:04:08,769
flip this switch with the "-autoplayback", command line argument,

81
00:04:08,769 --> 00:04:10,231
and it starts playing itself.

82
00:04:10,231 --> 00:04:14,194
It also saves a file, so you can rename that file and say "-playback",

83
00:04:14,194 --> 00:04:15,315
and then a file name.

84
00:04:15,315 --> 00:04:18,218
You can say "-skiptoframe", so it automatically throttles

85
00:04:18,218 --> 00:04:20,640
and goes right to the bug where it occurs.

86
00:04:21,392 --> 00:04:25,876
By doing this, you can trace down the exact frame where it occurs, the entity in which it occurs,

87
00:04:25,876 --> 00:04:29,138
and from there, you can see in the example on the bottom there,

88
00:04:29,138 --> 00:04:34,103
I've narrowed it down further, so I'm adding some printfs there to investigate further.

89
00:04:36,168 --> 00:04:40,071
For the user end, it also is pretty cool because it allows you to do user replays.

90
00:04:40,071 --> 00:04:44,195
So in both cases, the user can either save replays themselves to watch later,

91
00:04:44,195 --> 00:04:46,117
or they can upload them to the leaderboards.

92
00:04:46,117 --> 00:04:50,040
Now, the huge, huge piece of value here is because all you're doing is storing button input.

93
00:04:50,040 --> 00:04:51,762
It takes up very, very little space.

94
00:04:51,762 --> 00:04:54,184
We're talking 1 kilobyte, 2 kilobyte, 8 kilobytes.

95
00:04:55,165 --> 00:04:59,008
And so you can save that on the leaderboards as attachment data.

96
00:04:59,008 --> 00:05:01,610
That means you don't have to run your own servers or anything.

97
00:05:01,610 --> 00:05:05,373
So you can just sit back, relax, be like a super one-man indie team

98
00:05:05,373 --> 00:05:08,716
and have this going where everyone, once a high score is achieved,

99
00:05:08,716 --> 00:05:10,698
it's uploaded to the leaderboards.

100
00:05:10,698 --> 00:05:13,981
People will be like, how the heck did he accomplish that crazy score?

101
00:05:13,981 --> 00:05:15,842
They can watch the replay and see for themselves.

102
00:05:17,579 --> 00:05:20,643
I also used it to control NPCs during some cut scenes.

103
00:05:20,643 --> 00:05:23,647
And so pathfinding is great from moving from one point to another,

104
00:05:23,647 --> 00:05:27,132
but if you want something way more dynamic, a cool car chase,

105
00:05:27,132 --> 00:05:29,875
you can just record the button input for that vehicle.

106
00:05:29,875 --> 00:05:32,980
And in this case, three vehicles are running pre-recorded input for a sequence.

107
00:05:34,615 --> 00:05:37,597
I also had the classic arcade attract mode.

108
00:05:37,597 --> 00:05:39,958
So if you leave it on the main menu for five seconds,

109
00:05:39,958 --> 00:05:41,559
it'll automatically start playing itself

110
00:05:41,559 --> 00:05:42,720
through various missions.

111
00:05:42,720 --> 00:05:44,861
This was super great for shows like PAX and E3,

112
00:05:44,861 --> 00:05:48,683
because the game is always just demoing itself

113
00:05:48,683 --> 00:05:50,023
even if someone's not playing it.

114
00:05:51,747 --> 00:05:56,011
And in the DOS version, it was super valuable to trim memory.

115
00:05:56,011 --> 00:05:59,094
So once the game is locked, it's not really changing.

116
00:05:59,094 --> 00:06:01,677
You don't have a whole bunch of hands in there modifying

117
00:06:01,677 --> 00:06:03,859
things, the game is pretty stable.

118
00:06:03,859 --> 00:06:05,240
You can really start to dig deep.

119
00:06:05,240 --> 00:06:09,345
And so in this case, with the DOS version, I got it fitting

120
00:06:09,345 --> 00:06:13,028
in 3 and 1 1â„2 megs of RAM, which was pretty crazy and fun.

121
00:06:13,718 --> 00:06:16,259
And that meant trimming everything,

122
00:06:16,259 --> 00:06:20,041
trying to remove extra code that the compiler didn't automatically remove

123
00:06:20,041 --> 00:06:22,282
to compress the executable down, and you name it.

124
00:06:22,282 --> 00:06:25,984
And so one of the cool tricks here is, for example,

125
00:06:25,984 --> 00:06:28,225
I have an array of pathfinding nodes.

126
00:06:28,225 --> 00:06:31,046
Well, how many nodes do I really need for the pathfinding?

127
00:06:31,046 --> 00:06:32,127
Well, I can find that out.

128
00:06:32,547 --> 00:06:35,269
So you just add a bunch of stuff to track that.

129
00:06:35,269 --> 00:06:40,473
You run through, let's say, 12 hours of repeated playthroughs of the game

130
00:06:40,473 --> 00:06:42,035
in a fraction of the time, of course.

131
00:06:42,035 --> 00:06:44,177
And then at the end you have this output of

132
00:06:44,177 --> 00:06:48,060
what was the maximum amount of pathfinding nodes that I used,

133
00:06:48,060 --> 00:06:50,862
and then you can just trim it down, and that was able to save a lot of memory.

134
00:06:52,668 --> 00:06:54,809
So other examples of things that you could do with this

135
00:06:54,809 --> 00:06:56,949
would be speeding up trailer and video creation.

136
00:06:56,949 --> 00:06:58,850
I actually use this a lot for trailers.

137
00:06:58,850 --> 00:07:00,590
There are certain things where if you're playing the game,

138
00:07:00,590 --> 00:07:02,491
something cool happens.

139
00:07:02,491 --> 00:07:04,371
You can play it back without the HUD

140
00:07:04,371 --> 00:07:05,891
or with different languages,

141
00:07:05,891 --> 00:07:08,772
and therefore you can save redundant recording.

142
00:07:08,772 --> 00:07:12,353
You could also theoretically do asynchronous multiplayer.

143
00:07:12,353 --> 00:07:14,373
I didn't do this, but things like Ghost Races

144
00:07:14,373 --> 00:07:18,294
where you just keep track of all the people's vehicles

145
00:07:18,294 --> 00:07:20,035
and play it back at any point.

146
00:07:21,667 --> 00:07:24,868
You can improve remote QA and playtesting, which I used as well.

147
00:07:24,868 --> 00:07:28,049
So even if someone's off-site, if they're playing your game,

148
00:07:28,049 --> 00:07:30,770
they can send you the replay, and it's like you're over their shoulder.

149
00:07:30,770 --> 00:07:32,511
You can see exactly what happened and how.

150
00:07:32,511 --> 00:07:36,272
And you can also generate things like analytics and heat maps.

151
00:07:36,272 --> 00:07:38,853
You can record all the data from playtesters,

152
00:07:38,853 --> 00:07:42,714
or if the game is like three or four days at PAX and E3,

153
00:07:42,714 --> 00:07:45,135
you can record the hundreds or thousands of players.

154
00:07:46,248 --> 00:07:50,430
The advantage here is that if you were to record just plain analytics from that,

155
00:07:50,430 --> 00:07:51,751
you would be stuck.

156
00:07:51,751 --> 00:07:53,512
If after you analyze things you realize,

157
00:07:53,512 --> 00:07:55,293
oh, I didn't think of something in advance,

158
00:07:55,293 --> 00:07:57,474
I really wish I had analytics on this,

159
00:07:57,474 --> 00:08:01,116
you can do that because you just had it stored as button input.

160
00:08:01,116 --> 00:08:05,159
So you can analyze it infinitely as much as you need.

161
00:08:07,368 --> 00:08:10,711
So, good news, I whipped together this source file,

162
00:08:10,711 --> 00:08:13,393
and so basically changed one line of code,

163
00:08:13,393 --> 00:08:16,415
and you should be able to try this out for yourself.

164
00:08:16,415 --> 00:08:17,776
It's well under 300 lines of code,

165
00:08:17,776 --> 00:08:20,379
well under 250 without comments,

166
00:08:20,379 --> 00:08:22,620
and you just have at it.

167
00:08:22,620 --> 00:08:26,544
So, the recorded button input,

168
00:08:26,544 --> 00:08:29,226
there are a few core components for it.

169
00:08:29,226 --> 00:08:30,847
So, for example, buttons or keys,

170
00:08:30,847 --> 00:08:32,308
whether it's pressed or not pressed.

171
00:08:33,033 --> 00:08:35,054
Values, such as the analog stick direction.

172
00:08:35,054 --> 00:08:38,755
Events, so you want to keep track of if a mouse is clicked,

173
00:08:38,755 --> 00:08:40,055
if you touch drag or whatnot.

174
00:08:40,055 --> 00:08:42,396
And debug information, which is optional,

175
00:08:42,396 --> 00:08:45,277
but you definitely do want this during development.

176
00:08:45,277 --> 00:08:47,277
And optionally, if your game isn't fixed frame,

177
00:08:47,277 --> 00:08:49,658
you're going to want to use time deltas in there as well.

178
00:08:49,658 --> 00:08:53,199
RCR specifically, I have a header.

179
00:08:53,199 --> 00:08:55,619
So I store things like the control options, the camera

180
00:08:55,619 --> 00:08:56,760
zoom, the player outfit.

181
00:08:57,637 --> 00:09:00,059
This allows me to get even more versatile,

182
00:09:00,059 --> 00:09:03,822
because there are a whole bunch of different

183
00:09:03,822 --> 00:09:06,944
button configurations depending on the platform.

184
00:09:06,944 --> 00:09:09,926
And so, in certain cases, some platforms have more buttons,

185
00:09:09,926 --> 00:09:11,347
others have less.

186
00:09:11,347 --> 00:09:12,868
And so, in some cases,

187
00:09:12,868 --> 00:09:15,290
one button will do one of two actions on one system,

188
00:09:15,290 --> 00:09:17,031
but just one action on the other.

189
00:09:17,031 --> 00:09:18,713
And in that case, I can just keep track of

190
00:09:18,713 --> 00:09:21,555
which button configuration was this recorded in,

191
00:09:21,555 --> 00:09:23,256
and play back with that.

192
00:09:23,256 --> 00:09:25,798
And so, it further allows you to play back on other systems.

193
00:09:27,143 --> 00:09:29,445
The button streams are just one bit per frame,

194
00:09:29,445 --> 00:09:31,145
whether it's pressed or released, as I mentioned.

195
00:09:31,145 --> 00:09:33,327
The reason I store them separately

196
00:09:33,327 --> 00:09:35,388
is because if one button changes,

197
00:09:35,388 --> 00:09:37,249
you only have to update one button state.

198
00:09:37,249 --> 00:09:41,050
You don't have to update the entire controller state.

199
00:09:41,050 --> 00:09:44,472
Analog stick as well, the left and right sticks are separate.

200
00:09:44,472 --> 00:09:47,554
And event streams, so that's basically saying,

201
00:09:47,554 --> 00:09:48,614
the event, what happened?

202
00:09:48,614 --> 00:09:49,575
Was the mouse pressed?

203
00:09:49,575 --> 00:09:50,755
Was the mouse released?

204
00:09:50,755 --> 00:09:52,696
Did the mouse position move?

205
00:09:52,696 --> 00:09:53,857
What frame did it occur on?

206
00:09:53,857 --> 00:09:56,898
And from that point on, you just do what you need to do.

207
00:09:57,861 --> 00:10:00,462
Debug information, the biggest thing that I stored

208
00:10:00,462 --> 00:10:02,123
was a checksum of the frame.

209
00:10:02,123 --> 00:10:04,624
You can calculate that any way you want.

210
00:10:04,624 --> 00:10:07,326
In my case, I did certain things like entity positions

211
00:10:07,326 --> 00:10:11,108
and directions that they're facing and so on.

212
00:10:11,108 --> 00:10:13,909
And that could be stored in as little as a byte,

213
00:10:13,909 --> 00:10:15,570
because if the checksum changes,

214
00:10:15,570 --> 00:10:18,131
it's very unlikely that the byte is going to match,

215
00:10:18,131 --> 00:10:19,332
but the int would be different.

216
00:10:20,542 --> 00:10:25,787
During development, I stored this per frame, so I can see instantly when it went off the rails, if it went off the rails.

217
00:10:25,787 --> 00:10:30,512
And once I shipped, to keep the file size further down, I just store it once per second.

218
00:10:30,512 --> 00:10:36,758
So in the rare case that it would go off the rails, if someone is watching the replay in the commercial release,

219
00:10:36,758 --> 00:10:39,480
it'll just say, I'm sorry, an error occurred, and stop playing.

220
00:10:42,098 --> 00:10:44,702
I did some simple compression, which worked great.

221
00:10:44,702 --> 00:10:48,308
The first was just RLE compress the button streams.

222
00:10:48,308 --> 00:10:50,812
So that's just like, how long was it held down,

223
00:10:50,812 --> 00:10:52,374
and then how long was it released.

224
00:10:52,374 --> 00:10:54,778
And then I just zedlibbed the entire file,

225
00:10:54,778 --> 00:10:55,819
and that was fantastic.

226
00:10:57,758 --> 00:11:01,319
The other thing that you've got to keep in mind is you've got to pair everything for consistency.

227
00:11:01,319 --> 00:11:04,160
So to keep things clean and simple as possible and consistent,

228
00:11:04,160 --> 00:11:08,501
any time that you're recording something or playing back something,

229
00:11:08,501 --> 00:11:10,002
those should be paired.

230
00:11:10,002 --> 00:11:12,542
So if you're recording, do this, else do that.

231
00:11:12,542 --> 00:11:16,544
The other thing is that you want to make it as low level as possible.

232
00:11:16,544 --> 00:11:19,445
So you access the system API or whatever to figure out

233
00:11:19,445 --> 00:11:21,625
which buttons are actually pressed by the live user.

234
00:11:22,286 --> 00:11:24,728
and then you're generally going to put that into an object

235
00:11:24,728 --> 00:11:26,649
and then the game is going to use that object.

236
00:11:26,649 --> 00:11:28,611
Well, after you get it from the system

237
00:11:28,611 --> 00:11:33,315
and before that object is used by the game,

238
00:11:33,315 --> 00:11:34,956
you want to inject or record the button input.

239
00:11:34,956 --> 00:11:40,541
The more complicated part is building a deterministic engine.

240
00:11:40,541 --> 00:11:42,323
But it's not...

241
00:11:42,763 --> 00:11:44,445
quite as daunting as it could be.

242
00:11:44,445 --> 00:11:47,747
So the most important thing is making sure

243
00:11:47,747 --> 00:11:49,028
everything is properly initialized.

244
00:11:49,028 --> 00:11:51,930
And this is great, because if you make sure

245
00:11:51,930 --> 00:11:53,852
everything's initialized, you're just gonna

246
00:11:53,852 --> 00:11:55,653
kill bugs before you found them.

247
00:11:55,653 --> 00:11:58,095
And you're just gonna have a more stable game.

248
00:11:58,095 --> 00:12:00,036
So an example here is a static Boolean.

249
00:12:00,036 --> 00:12:06,001
If you were to do that, you gotta be really careful.

250
00:12:06,001 --> 00:12:08,122
Random is another thing that can be very dangerous,

251
00:12:08,122 --> 00:12:10,524
but it's easy as heck to take care of.

252
00:12:10,995 --> 00:12:13,177
I recommend that you roll your own random function.

253
00:12:13,177 --> 00:12:17,700
And then the bigger recommendation is that you use separate instances.

254
00:12:17,700 --> 00:12:21,423
And the reason I say that is because if you were to use a separate random instance

255
00:12:21,423 --> 00:12:25,366
for your core game loop, and a separate one for ambient audio effects,

256
00:12:25,366 --> 00:12:27,527
and a separate one for visual effects,

257
00:12:27,527 --> 00:12:31,650
if you were to add more explosions or change the ambient audio,

258
00:12:31,650 --> 00:12:36,534
generally speaking, your pre-recorded input for the gameplay should be fine.

259
00:12:36,534 --> 00:12:38,755
And so if you recorded a game session a year ago...

260
00:12:39,350 --> 00:12:41,671
Theoretically, it shouldn't break it.

261
00:12:41,671 --> 00:12:46,474
The other big thing is to not use system events or callbacks.

262
00:12:46,474 --> 00:12:50,396
And so if your driver or your API has some sort of event

263
00:12:50,396 --> 00:12:53,398
when a sound finishes playing, don't use that.

264
00:12:53,398 --> 00:12:55,459
Because that's inconsistent.

265
00:12:55,459 --> 00:12:57,820
When it occurs will vary.

266
00:12:57,820 --> 00:12:59,721
So the trick is to use your own.

267
00:12:59,721 --> 00:13:03,643
So figure out what the length of the song is, for example.

268
00:13:03,643 --> 00:13:05,084
Calculate that in game ticks.

269
00:13:05,084 --> 00:13:07,285
And then every time your frame runs, tick that.

270
00:13:07,613 --> 00:13:09,014
once that tick reaches the end,

271
00:13:09,014 --> 00:13:11,135
then you kick off your own callback.

272
00:13:11,135 --> 00:13:15,038
Middleware is something that's not the end of the world.

273
00:13:15,038 --> 00:13:17,740
So many, many AAA games are deterministic

274
00:13:17,740 --> 00:13:19,081
and ship with middleware.

275
00:13:19,081 --> 00:13:22,143
Many middleware is deterministic.

276
00:13:22,143 --> 00:13:24,844
And even if it isn't deterministic,

277
00:13:24,844 --> 00:13:27,546
you can evaluate how determined,

278
00:13:27,546 --> 00:13:30,768
like, how much work would it be to make it deterministic?

279
00:13:30,768 --> 00:13:34,371
So it's, again, something that you just have to keep an eye on,

280
00:13:34,371 --> 00:13:35,372
but don't fret about it.

281
00:13:37,371 --> 00:13:43,217
Floating point is a bit of an issue, but it's more if you're trying to be cross-platform.

282
00:13:43,217 --> 00:13:48,141
So if you're just recording a replay on one console and playing it back on that same type

283
00:13:48,141 --> 00:13:52,966
of console, even if it's your friends, you'll be fine in 99.9% of the cases.

284
00:13:53,652 --> 00:13:58,095
And even we're really lucky because some consoles are similar enough that

285
00:13:58,095 --> 00:14:03,678
the replays recorded on PS3, PS4, or Vita play back on each other.

286
00:14:03,678 --> 00:14:06,500
So those systems are luckily just close enough.

287
00:14:06,500 --> 00:14:12,444
The bigger problem will be games on PC, because you do have more differences

288
00:14:12,444 --> 00:14:17,127
even between Intel and AMD and drivers and other configurations.

289
00:14:17,127 --> 00:14:19,128
That specifically is beyond the scope of the talk,

290
00:14:19,128 --> 00:14:21,850
but if you simply google fixed point determinism,

291
00:14:22,373 --> 00:14:26,215
you'll get all the info you need about how to manually specify precision,

292
00:14:26,215 --> 00:14:31,856
save and restore states between drivers, and you can take care of it.

293
00:14:31,856 --> 00:14:36,638
But don't focus on portability unless you really need it.

294
00:14:36,638 --> 00:14:40,059
So unless you realize I'm going to ship this on PC to end users

295
00:14:40,059 --> 00:14:46,401
and it's clear that this is not deterministic between wildly different configurations,

296
00:14:46,401 --> 00:14:47,421
then you can look into it.

297
00:14:47,421 --> 00:14:49,202
If it's simply for your internal testing,

298
00:14:49,202 --> 00:14:51,843
generally speaking, you don't even have to worry about it.

299
00:14:53,794 --> 00:14:55,935
For visual reference, this isn't really a...

300
00:14:55,935 --> 00:14:58,878
This specifically wouldn't apply as much to AAA games,

301
00:14:58,878 --> 00:15:01,500
but if you were doing a simpler game,

302
00:15:01,500 --> 00:15:05,223
something safer... It's all about precision and accumulation.

303
00:15:05,223 --> 00:15:09,807
So, if you were to do just a simple low-precision lookup table

304
00:15:09,807 --> 00:15:12,189
for your sine and cosine, you're fine in most cases.

305
00:15:12,189 --> 00:15:15,011
The less safe would be something like,

306
00:15:15,011 --> 00:15:16,412
if the player's collecting coins,

307
00:15:16,412 --> 00:15:18,654
and a coin is over here, the player's over here,

308
00:15:18,654 --> 00:15:20,576
once you're within the vicinity,

309
00:15:20,576 --> 00:15:22,477
the coin starts homing in on the player.

310
00:15:23,898 --> 00:15:26,439
every single frame you're calculating, well, what's the distance?

311
00:15:26,439 --> 00:15:27,539
How much should I move?

312
00:15:27,539 --> 00:15:31,721
That will, guaranteed, generate precision errors.

313
00:15:31,721 --> 00:15:36,944
And so it might hit the player on frame 300 on this system

314
00:15:36,944 --> 00:15:38,244
and 301 on the other system.

315
00:15:38,244 --> 00:15:40,725
So that's something that you've got to take care of.

316
00:15:40,725 --> 00:15:43,667
Another trick that I used was sandboxing.

317
00:15:43,667 --> 00:15:47,909
So this means that the game is no longer 100%

318
00:15:47,909 --> 00:15:52,931
of the testing that you would like, but 99 is still good.

319
00:15:53,833 --> 00:15:59,275
What I mean by that is that I stub leaderboards, I stub achievements, I stub system utilities, online state.

320
00:15:59,275 --> 00:16:00,896
I fake them all.

321
00:16:00,896 --> 00:16:07,579
And it allows you to just have a solid, consistent piece of code that runs.

322
00:16:08,464 --> 00:16:11,066
you're not going to be testing actually connecting to PSN

323
00:16:11,066 --> 00:16:12,727
because that could be inconsistent.

324
00:16:12,727 --> 00:16:15,489
And there would be ways to try and handle that,

325
00:16:15,489 --> 00:16:16,730
but that's just a lot more work.

326
00:16:16,730 --> 00:16:20,554
So the simpler thing is to just leave that to hands-on testing

327
00:16:20,554 --> 00:16:23,476
and just leave your automated tests to sandbox mode.

328
00:16:23,476 --> 00:16:25,918
The other thing that I do is I have save games,

329
00:16:25,918 --> 00:16:29,301
and I have the option to either save and load them from memory

330
00:16:29,301 --> 00:16:30,862
or save and load them from files.

331
00:16:31,907 --> 00:16:35,189
The cool thing here is that if you have a retail game

332
00:16:35,189 --> 00:16:38,511
and your end user can play these replays,

333
00:16:38,511 --> 00:16:41,052
then it won't affect their save games.

334
00:16:41,052 --> 00:16:42,834
They kick off the automated tests.

335
00:16:42,834 --> 00:16:44,995
It does everything from memory.

336
00:16:44,995 --> 00:16:46,175
They quit the game, restart it.

337
00:16:46,175 --> 00:16:51,699
Everything's as normal with their original save data.

338
00:16:51,699 --> 00:16:53,360
Now, even if you took care of all of that,

339
00:16:53,360 --> 00:16:55,661
you still will encounter some cases where...

340
00:16:56,301 --> 00:16:58,143
your determinism is broken.

341
00:16:58,143 --> 00:17:00,805
And sometimes the simplest solution is the best.

342
00:17:00,805 --> 00:17:04,428
And for me, I did almost everything just by logging things.

343
00:17:04,428 --> 00:17:07,631
So I log when I'm recording, and I log when I'm playing back.

344
00:17:07,631 --> 00:17:11,594
And then you grab a diff tool, I like WinMerge, but anything will work.

345
00:17:11,594 --> 00:17:15,017
WinMerge is free. That's why I like it.

346
00:17:15,017 --> 00:17:19,461
And then you just compare the logs to figure out where things play back correctly or incorrectly.

347
00:17:19,461 --> 00:17:20,582
And...

348
00:17:22,353 --> 00:17:24,974
I think all of us have probably experienced at one point or another

349
00:17:24,974 --> 00:17:27,315
something where the debug works but the release doesn't,

350
00:17:27,315 --> 00:17:28,135
or vice versa.

351
00:17:28,135 --> 00:17:32,076
There's some sort of specific bug, or different configurations,

352
00:17:32,076 --> 00:17:33,677
and so this again helps you do that.

353
00:17:33,677 --> 00:17:37,878
This is an example of the log, and just showing you

354
00:17:37,878 --> 00:17:39,239
this is a very simple thing.

355
00:17:39,239 --> 00:17:42,740
I just show a checksum of the frame, the frame number,

356
00:17:42,740 --> 00:17:47,262
and the exact function in line, which I kicked off this poke.

357
00:17:48,242 --> 00:17:51,525
And then if that doesn't work, you can kick off a verbose mode.

358
00:17:51,525 --> 00:17:56,268
And so in this case, I dump more specific things like the entity position and facing.

359
00:17:56,268 --> 00:18:02,012
And here you can see, okay, so this one thing happened on one and didn't happen on the other,

360
00:18:02,012 --> 00:18:04,974
and then from there, things just went completely off the rails.

361
00:18:06,636 --> 00:18:08,979
The other thing is just bulletproofing your code.

362
00:18:08,979 --> 00:18:10,981
The cool thing is, is that the more deterministic

363
00:18:10,981 --> 00:18:13,224
you make your game, the less bugs you'll have,

364
00:18:13,224 --> 00:18:15,587
the more bugs you'll catch, and vice versa.

365
00:18:15,587 --> 00:18:16,868
The more bugs you kill,

366
00:18:16,868 --> 00:18:19,712
the more deterministic your game will be.

367
00:18:19,712 --> 00:18:21,393
One huge thing I can give you as a tip

368
00:18:21,393 --> 00:18:23,556
is to try and keep your game loop

369
00:18:23,556 --> 00:18:26,199
and your rendering independent.

370
00:18:26,199 --> 00:18:27,120
Don't intertwine them.

371
00:18:27,763 --> 00:18:30,866
And this can be hard for bigger pre-existing code bases,

372
00:18:30,866 --> 00:18:34,008
but it's something that you should strive for.

373
00:18:34,008 --> 00:18:36,129
Because as you could see,

374
00:18:36,129 --> 00:18:37,751
half an hour ran in 15 seconds.

375
00:18:37,751 --> 00:18:40,332
Could run in 15 seconds, as I said, if I turned off Vsync.

376
00:18:40,332 --> 00:18:43,174
Now, of course, it's a simpler game.

377
00:18:43,174 --> 00:18:44,696
But the short of it is,

378
00:18:44,696 --> 00:18:47,918
even if you've got a 3D AAA game,

379
00:18:47,918 --> 00:18:49,999
if you're not running rendering every frame,

380
00:18:49,999 --> 00:18:52,281
you're gonna be able to run it a lot faster.

381
00:18:52,281 --> 00:18:53,182
The other thing is just...

382
00:18:53,607 --> 00:18:57,568
Pull out all the stops. Run static analyzers, sanitizers.

383
00:18:57,568 --> 00:18:59,829
And fiddle around. Now this can just, just for fun,

384
00:18:59,829 --> 00:19:02,770
you can create two different, wildly different game configurations

385
00:19:02,770 --> 00:19:05,351
just to see how robust it is. Does it work in

386
00:19:05,351 --> 00:19:11,654
a 64-bit thing with release optimized and different struct alignment,

387
00:19:11,654 --> 00:19:14,915
different floating point precision. I mean, that's really pushing it.

388
00:19:14,915 --> 00:19:17,376
You don't have to nail that. But if you can,

389
00:19:17,376 --> 00:19:18,236
then that's pretty cool.

390
00:19:20,754 --> 00:19:23,816
As you can see as well, I used it in so many different ways

391
00:19:23,816 --> 00:19:25,398
that the ways can build upon each other.

392
00:19:25,398 --> 00:19:29,240
So the super simple thing would be in Windows, for example,

393
00:19:29,240 --> 00:19:30,261
I created a batch file.

394
00:19:30,261 --> 00:19:33,744
And so you play the game, it records the input,

395
00:19:33,744 --> 00:19:35,565
dumps it to a file, I rename it to Part 1.

396
00:19:35,565 --> 00:19:39,728
And then I load the game again, it loads my saved data.

397
00:19:40,174 --> 00:19:41,435
play again, exit, save too.

398
00:19:41,435 --> 00:19:43,736
And so then when you chain that,

399
00:19:43,736 --> 00:19:46,217
you can just play through the entire game,

400
00:19:46,217 --> 00:19:48,577
and you don't have to make sure that the initialization

401
00:19:48,577 --> 00:19:50,158
and de-initialization is perfect,

402
00:19:50,158 --> 00:19:52,819
because you're just killing the executable and reloading it.

403
00:19:52,819 --> 00:19:55,220
If you want to do this on consoles, though,

404
00:19:55,220 --> 00:19:57,001
and you really want to make it robust,

405
00:19:57,001 --> 00:19:59,462
then you want to have self-contained automated playthroughs.

406
00:19:59,462 --> 00:20:01,543
So again, this is the more advanced thing.

407
00:20:01,543 --> 00:20:02,803
It's really not needed.

408
00:20:02,803 --> 00:20:04,044
I didn't actually implement this

409
00:20:04,044 --> 00:20:06,345
until after the original version shipped in 2012.

410
00:20:07,136 --> 00:20:11,118
So you don't necessarily need it, but it is really cool and it opens more doors.

411
00:20:11,118 --> 00:20:15,861
So this, of course, you've just got to make sure that you properly init and dinit everything.

412
00:20:15,861 --> 00:20:20,924
So once the game shuts down and goes back up to the top of the main loop,

413
00:20:20,924 --> 00:20:25,726
things are as if you just launched the executable.

414
00:20:25,726 --> 00:20:27,728
And I recommend using the in-game save,

415
00:20:27,728 --> 00:20:31,189
otherwise you're going to have to delete the save data before you run this,

416
00:20:31,189 --> 00:20:32,670
depending on what your test is.

417
00:20:34,103 --> 00:20:35,884
And as I kind of mentioned before,

418
00:20:35,884 --> 00:20:39,226
is I just iterate through replay one, two, three, four, five.

419
00:20:39,226 --> 00:20:42,187
Once it reaches the end and it's like, oh, file not found,

420
00:20:42,187 --> 00:20:43,288
then you know you're done.

421
00:20:43,288 --> 00:20:44,949
And it returns control to the user.

422
00:20:44,949 --> 00:20:46,469
So then the user can play the game

423
00:20:46,469 --> 00:20:49,311
and see, did it end up where it should have?

424
00:20:49,311 --> 00:20:51,852
And if you had a build system or something like that,

425
00:20:51,852 --> 00:20:53,433
you could actually spit out information

426
00:20:53,433 --> 00:20:55,994
or just analyze the screen or every which way

427
00:20:55,994 --> 00:20:57,375
to just completely, you don't even

428
00:20:57,375 --> 00:20:58,875
have to look at it yourself.

429
00:20:58,875 --> 00:21:02,297
Level replays where.

430
00:21:04,435 --> 00:21:11,122
the person's been playing the game for a while and then they start playing a level and then it starts recording from there, finishes recording, and then they can play that back.

431
00:21:11,122 --> 00:21:12,243
It's all about state.

432
00:21:12,243 --> 00:21:18,969
The simplest thing is to just completely reset the level state, whether you're playing or playing back or recording.

433
00:21:18,969 --> 00:21:22,232
So it's just consistent. And then again, as I said, you pair things.

434
00:21:22,232 --> 00:21:25,876
So all of your replay code should be the same as the recording code in the same spot.

435
00:21:25,876 --> 00:21:28,598
Entities are the exact same.

436
00:21:29,182 --> 00:21:32,063
So if you wanted to control an entity for a cutscene,

437
00:21:32,063 --> 00:21:33,844
or in some cases, people have actually used this

438
00:21:33,844 --> 00:21:36,085
for racing game AI,

439
00:21:36,085 --> 00:21:38,565
where you actually use button input

440
00:21:38,565 --> 00:21:40,566
to have the other AI players.

441
00:21:40,566 --> 00:21:42,627
This, I know of a game on PS1 that did this,

442
00:21:42,627 --> 00:21:43,567
which is, it's funny.

443
00:21:43,567 --> 00:21:45,628
It doesn't sound like it would work, but it can.

444
00:21:45,628 --> 00:21:48,309
But again, reset the entity state

445
00:21:48,309 --> 00:21:49,829
and keep things consistent

446
00:21:49,829 --> 00:21:52,990
rather than trying to just make sure that things are good.

447
00:21:52,990 --> 00:21:56,151
Backwards compatibility is another thing that I recommend.

448
00:21:56,151 --> 00:21:56,211
And...

449
00:21:58,342 --> 00:22:02,704
It's pretty cool that when the game shipped in 2012 and I recorded some replays then,

450
00:22:02,704 --> 00:22:06,787
that even after I've done the updated DX version and all of that stuff,

451
00:22:06,787 --> 00:22:08,387
those old replays still run.

452
00:22:08,387 --> 00:22:11,789
And it's actually not as daunting as you might think.

453
00:22:11,789 --> 00:22:14,130
It doesn't make your code quite as messy as you might think.

454
00:22:14,130 --> 00:22:15,751
It's simply a matter of saying,

455
00:22:15,751 --> 00:22:18,753
well, what version does this header say it is?

456
00:22:18,753 --> 00:22:21,394
And if it is, well, setRadiusBugEnabled, for example.

457
00:22:23,285 --> 00:22:26,986
And so the big thing I can say here is that I recommend that you try this

458
00:22:26,986 --> 00:22:29,706
even if your game isn't fully deterministic.

459
00:22:29,706 --> 00:22:34,467
Because if you're recording the input every time you play the game,

460
00:22:34,467 --> 00:22:38,428
and a bug occurs, and you kill it and then restart it with the replay,

461
00:22:38,428 --> 00:22:42,529
let's say 50% of the time it goes off the rails and the bug doesn't happen.

462
00:22:42,529 --> 00:22:44,449
Well, 50% of the time it does repro the bug.

463
00:22:44,449 --> 00:22:48,250
And working at other studios, I did have cases where

464
00:22:48,250 --> 00:22:51,731
there was some bug that happened on the PSP that happened...

465
00:22:53,420 --> 00:22:55,581
about an hour into the game.

466
00:22:55,581 --> 00:22:58,862
Okay, no, it was, it happened half an hour into the game,

467
00:22:58,862 --> 00:23:00,783
but it only, but we had to run it in debug mode,

468
00:23:00,783 --> 00:23:02,183
which ran at half the time.

469
00:23:02,183 --> 00:23:04,144
So the play tester, or the QA guy,

470
00:23:04,144 --> 00:23:07,285
had to sit at my desk and play the game in slow-mo

471
00:23:07,285 --> 00:23:09,666
for an hour to try and repro the bug,

472
00:23:09,666 --> 00:23:12,347
because I sure as heck couldn't repro it myself.

473
00:23:12,347 --> 00:23:13,947
And after an hour, he couldn't repro it.

474
00:23:13,947 --> 00:23:15,548
It was just a nightmare.

475
00:23:15,548 --> 00:23:16,708
And it was a crash bug, too.

476
00:23:16,708 --> 00:23:19,609
So having something like this,

477
00:23:19,609 --> 00:23:21,890
it really kills like 99% of those things.

478
00:23:23,548 --> 00:23:25,089
The other thing is, you just start simple.

479
00:23:25,089 --> 00:23:27,189
Like I said, you just record it when the game starts,

480
00:23:27,189 --> 00:23:29,250
stop recording when it finishes.

481
00:23:29,250 --> 00:23:31,290
And then from then, you can just build and build and build.

482
00:23:31,290 --> 00:23:36,671
And so again, download the sample code and check it out.

483
00:23:36,671 --> 00:23:39,192
And thank you.

484
00:23:39,192 --> 00:23:40,372
I'm open for your questions.

485
00:23:40,372 --> 00:23:51,434
So there's a mic over there and there and there.

486
00:23:56,489 --> 00:24:00,515
So I have a question, you mentioned you used metrics.

487
00:24:00,515 --> 00:24:02,238
What did you use to generate the heat maps?

488
00:24:02,238 --> 00:24:04,862
Heat maps are something that I wish I did.

489
00:24:04,862 --> 00:24:07,506
I really, really regret that.

490
00:24:07,917 --> 00:24:13,399
A funny thing that I learned with my game was that we playtested it to death,

491
00:24:13,399 --> 00:24:16,080
and it was getting all these awards, and it was amazing.

492
00:24:16,080 --> 00:24:19,261
And then in the final crunch, I was just like,

493
00:24:19,261 --> 00:24:22,262
oh no, there's some gaps between these missions, I need to add this,

494
00:24:22,262 --> 00:24:24,583
oh, it's too easy here, I need to add a mission here.

495
00:24:24,583 --> 00:24:26,444
And those missions that I didn't playtest,

496
00:24:26,444 --> 00:24:28,985
that I added at the very end, were the ones that people griped on.

497
00:24:29,399 --> 00:24:42,689
And so I recommend everyone do the heat maps, do the play testing, and at the very end if you've got the choice between adding features or just polishing up what's there, polish up what's there.

498
00:24:43,458 --> 00:24:49,204
So how did you manage to get a determination between your debug and release versions of the game?

499
00:24:49,204 --> 00:24:52,387
The big thing there was mainly initialization.

500
00:24:52,387 --> 00:24:57,473
And so I found that almost every time when I found a case where something worked in release

501
00:24:57,473 --> 00:25:02,198
and didn't work in debug or vice versa, it was simply something wasn't initialized, which was just a bug.

502
00:25:02,913 --> 00:25:07,357
But your floating point results would be different for your debug release.

503
00:25:07,357 --> 00:25:11,320
Indeed. So in certain cases you can manually specify precision.

504
00:25:11,320 --> 00:25:13,382
You can do that on PC for sure.

505
00:25:13,382 --> 00:25:16,284
Sometimes the compiler options as well you could try and do that.

506
00:25:16,284 --> 00:25:20,568
But yeah, floating point again could be trickier,

507
00:25:20,568 --> 00:25:23,270
but a lot of AAA games do ship deterministic.

508
00:25:23,270 --> 00:25:28,354
So it is possible, but it's just something that you've got to pay attention to and just Google.

509
00:25:28,462 --> 00:25:32,463
So setting the floating point precision at conservative levels,

510
00:25:32,463 --> 00:25:33,943
did it impact performance?

511
00:25:33,943 --> 00:25:37,564
It all depends on your game, you know.

512
00:25:37,564 --> 00:25:38,865
It's going to vary.

513
00:25:38,865 --> 00:25:40,145
OK.

514
00:25:40,145 --> 00:25:40,405
Thank you.

515
00:25:40,405 --> 00:25:40,645
Hey, Brian.

516
00:25:40,645 --> 00:25:42,206
Thanks for the talk.

517
00:25:42,206 --> 00:25:42,866
Oh, thank you.

518
00:25:42,866 --> 00:25:47,628
So Retro City Rampages runs on a fixed update loop.

519
00:25:47,628 --> 00:25:48,028
Yes.

520
00:25:48,028 --> 00:25:52,249
Do you have any recommendations if you're

521
00:25:52,249 --> 00:25:55,610
using just unfixed update loops?

522
00:25:55,842 --> 00:26:02,445
Yeah, so I would just like we record button streams and analog stick streams and all of that.

523
00:26:02,445 --> 00:26:09,229
I would recommend that you just also keep track of the delta time that was each frame

524
00:26:09,229 --> 00:26:11,970
and then play back with that delta time fed in.

525
00:26:11,970 --> 00:26:12,550
Okay, thank you.

526
00:26:12,550 --> 00:26:12,650
Yeah.

527
00:26:12,650 --> 00:26:12,991
Any other questions?

528
00:26:12,991 --> 00:26:18,753
What was your favorite mission in Retro City Rampage?

529
00:26:19,493 --> 00:26:22,475
It's a funny question because I guess there are two things here.

530
00:26:22,475 --> 00:26:25,316
Number one was, generally speaking, the cop-out answer was

531
00:26:25,316 --> 00:26:28,498
whatever the latest mission I had done was my favorite mission.

532
00:26:28,498 --> 00:26:32,720
The other thing was, once I had been playing the game and developing it for years,

533
00:26:32,720 --> 00:26:35,301
my favorite missions were the last ones I added,

534
00:26:35,301 --> 00:26:38,383
which were, like, challenging to me and really awesome.

535
00:26:38,383 --> 00:26:41,284
And then it turned out that they were too challenging to most people

536
00:26:41,284 --> 00:26:45,186
because they hadn't been playing the game for years.

537
00:26:45,186 --> 00:26:46,586
But...

538
00:26:48,526 --> 00:26:52,308
Yeah, I guess I really like the stomping missions, the jailbreak mission.

539
00:26:52,308 --> 00:26:53,889
That one was pretty fun.

540
00:26:53,889 --> 00:27:01,494
If you were to implement networking play, how would you, have you thought about how

541
00:27:01,494 --> 00:27:03,175
you would log and replay that?

542
00:27:03,973 --> 00:27:21,484
Um, networking is, there are a lot of different ways to do that, um, but you know it's funny, it's a lot of multiplayer games use this automated testing because their game is deterministic because of multiplayer, um, but there are different ways, you aren't necessarily going to be doing

543
00:27:22,764 --> 00:27:28,386
doing your deterministic gameplay isn't necessarily the best way to do networking.

544
00:27:28,386 --> 00:27:32,287
Sometimes you do want to do the correction and stuff like that, so it depends on the game, but

545
00:27:32,287 --> 00:27:39,249
it really is, like I said, low level. So you get the system input, and then before the game uses it,

546
00:27:39,249 --> 00:27:43,710
you inject in there to record and play back. And it would be a similar thing, like your packets,

547
00:27:43,710 --> 00:27:47,151
you just, like, grab them at the top and, like, record and play them back.

548
00:27:52,810 --> 00:27:58,673
Do you have a solution for asynchronous file operations?

549
00:27:58,673 --> 00:27:58,933
Right.

550
00:27:58,933 --> 00:28:00,614
That is an issue.

551
00:28:00,614 --> 00:28:03,735
In that case, I would probably just sandbox it,

552
00:28:03,735 --> 00:28:05,456
so that wouldn't be fully tested.

553
00:28:05,456 --> 00:28:08,177
But then it would just do it synchronously

554
00:28:08,177 --> 00:28:13,619
when you're doing the auto playback and whatnot.

555
00:28:13,619 --> 00:28:16,060
Any other questions?

556
00:28:16,060 --> 00:28:19,062
Does anyone want to see the MS-DOS version?

557
00:28:39,786 --> 00:28:50,150
Reading from the floppy takes a second.

558
00:28:50,150 --> 00:29:00,635
How much time do we have? This might take a moment.

559
00:29:00,635 --> 00:29:05,057
I can fast forward.

560
00:29:05,057 --> 00:29:05,957
Okay, we're close.

561
00:29:10,279 --> 00:29:15,183
Actually, it would be sweet if we did have sound,

562
00:29:15,183 --> 00:29:20,567
because then I could have the PC speaker audio.

563
00:29:20,567 --> 00:29:21,388
So, let's see.

564
00:29:21,388 --> 00:29:22,228
Come on.

565
00:29:22,228 --> 00:29:22,288
Oh.

566
00:29:22,288 --> 00:29:24,690
There we go.

567
00:29:24,690 --> 00:29:33,497
It's funny, it seems like...

568
00:29:34,085 --> 00:29:36,628
We all threw away our 286s, our 386s, and everything.

569
00:29:36,628 --> 00:29:40,932
People have collected Amigas and collected Commodore 64s.

570
00:29:40,932 --> 00:29:42,853
No one cared about their old PC.

571
00:29:42,853 --> 00:29:44,555
They're all in a garbage dump somewhere.

572
00:29:44,555 --> 00:29:48,458
So it's actually surprisingly hard to track those things down.

573
00:29:48,458 --> 00:29:53,663
So it's pretty close.

574
00:29:53,663 --> 00:29:58,067
The big thing was I removed...

575
00:29:58,715 --> 00:30:01,197
the 3D minigames and things like that, but

576
00:30:01,197 --> 00:30:07,202
every single mission otherwise is in here. It's been super fun.

577
00:30:07,202 --> 00:30:10,545
I was done with porting, and so I decided to take some time off, and then during

578
00:30:10,545 --> 00:30:11,186
that time off I

579
00:30:11,186 --> 00:30:16,310
ended up doing this, which isn't really time off, but

580
00:30:16,310 --> 00:30:20,334
my justification was, well, this can't really be monetized very well, so

581
00:30:20,334 --> 00:30:20,974
it's time off.

582
00:30:25,152 --> 00:30:28,416
So I'll announce more about this at some point.

583
00:30:28,416 --> 00:30:30,299
But yeah, it's pretty sweet.

584
00:30:30,299 --> 00:30:30,840
It's wrapped up.

585
00:30:30,840 --> 00:30:34,744
The only thing is that I've got a box of, oh, we're out?

586
00:30:34,744 --> 00:30:34,804
OK.

587
00:30:34,804 --> 00:30:36,787
Well, I'm going to add controller support,

588
00:30:36,787 --> 00:30:37,448
and then we're good.

589
00:30:37,448 --> 00:30:39,831
All right, thanks everyone.

