1
00:00:03,413 --> 00:00:04,173
Good morning, everyone.

2
00:00:04,193 --> 00:00:08,754
I'm Wang Xi from the graphics studio, from Bungie Studio.

3
00:00:08,774 --> 00:00:09,854
I'm a graphics engineer.

4
00:00:10,374 --> 00:00:13,975
Today, I'm going to talk about the automated LOD generation

5
00:00:14,055 --> 00:00:15,915
system for the Halo Reach.

6
00:00:17,336 --> 00:00:19,656
So back to the history of our studio,

7
00:00:20,056 --> 00:00:23,297
we have worked for many game titles like Halo 1, 2, 3.

8
00:00:24,537 --> 00:00:27,478
But surprisingly, we haven't had any real LOD system.

9
00:00:27,898 --> 00:00:30,038
We do have the option which allows artists

10
00:00:30,198 --> 00:00:32,058
to create a low-res model.

11
00:00:32,539 --> 00:00:34,821
for a far away case, but unfortunately,

12
00:00:34,841 --> 00:00:39,245
it turns out to be the most rare used feature in our system.

13
00:00:39,705 --> 00:00:42,588
So, but fortunately, our engine optimized enough,

14
00:00:42,628 --> 00:00:43,989
we can still ship the game.

15
00:00:44,710 --> 00:00:50,015
But in the Halo Reach, we increased the quality bar

16
00:00:50,075 --> 00:00:52,437
for our game, we have a lot of new more stuff

17
00:00:52,477 --> 00:00:54,378
need to be displayed in the runtime.

18
00:00:55,039 --> 00:00:58,382
So we realized we have to have a LOD system

19
00:00:58,602 --> 00:00:59,383
which can save us the.

20
00:01:00,528 --> 00:01:02,710
the cost for rendering the same.

21
00:01:03,431 --> 00:01:06,273
And considering the number of assets in our game,

22
00:01:06,533 --> 00:01:10,096
and also the endless iteration during the production,

23
00:01:10,516 --> 00:01:12,818
we decided this system has to be automated,

24
00:01:12,918 --> 00:01:15,360
which means any update the artist made,

25
00:01:15,880 --> 00:01:19,203
we need to generate the low-res model for them by default.

26
00:01:20,604 --> 00:01:23,206
So that's our motivation to design this system.

27
00:01:24,406 --> 00:01:28,189
And this system was designed by three very simple,

28
00:01:29,185 --> 00:01:36,429
principles. The first thing is like, we need an automated mesh simplification system which can robustly

29
00:01:36,969 --> 00:01:43,172
simplify the raw mesh provided by the artist. And also, we can fit in the animation information

30
00:01:44,012 --> 00:01:48,074
automatically for them, which means, you know, if you have animated character, when we do the

31
00:01:48,114 --> 00:01:54,337
simplification, the low-res version still can be animated properly, you know, as the animator wants.

32
00:01:55,077 --> 00:01:56,018
The second thing is like...

33
00:01:56,732 --> 00:01:59,233
We have really sophisticated material system,

34
00:01:59,273 --> 00:02:02,995
which, you know, composed by the Koutoris model,

35
00:02:03,075 --> 00:02:06,557
Tulip Foam model, and when we switch that thing

36
00:02:06,577 --> 00:02:09,039
to the low-res model, we don't want to keep

37
00:02:09,059 --> 00:02:10,560
this kind of complexity anymore.

38
00:02:11,100 --> 00:02:13,922
So we decided, you know, whether we can unify

39
00:02:14,342 --> 00:02:17,143
the material model, just using one material model

40
00:02:17,204 --> 00:02:19,225
to approximate anything in our game.

41
00:02:20,385 --> 00:02:23,447
And the third idea is, you know,

42
00:02:24,272 --> 00:02:26,974
Because this low-res model will only be rendered

43
00:02:27,594 --> 00:02:31,158
in the faraway case, it sounds like not important

44
00:02:31,238 --> 00:02:33,860
to make sure every pixel correctly.

45
00:02:34,400 --> 00:02:37,343
So we decided using the per-vertex shading model.

46
00:02:38,284 --> 00:02:41,106
Another benefit of that, we don't need to deal with

47
00:02:41,166 --> 00:02:43,048
the texture calling the parameterization

48
00:02:43,448 --> 00:02:44,989
and the texture page-in, page-out

49
00:02:45,149 --> 00:02:47,251
when we're switching different low-res model.

50
00:02:48,052 --> 00:02:51,975
So here's the case of three character in our game.

51
00:02:52,907 --> 00:02:54,608
And when you're in the far away case,

52
00:02:55,068 --> 00:02:57,850
actually we were rendered using this low res,

53
00:02:58,070 --> 00:03:00,191
you know, vertex lighting model.

54
00:03:00,231 --> 00:03:03,153
We call this thing Imposter in our project.

55
00:03:04,834 --> 00:03:08,195
So here is a live video we captured in our engine.

56
00:03:12,177 --> 00:03:17,760
Oh, sorry, I think the sound is too loud.

57
00:03:20,162 --> 00:03:23,684
in the halo, so that's what you see in the shifter title.

58
00:03:24,084 --> 00:03:25,445
But actually in our debugging mode,

59
00:03:25,465 --> 00:03:26,446
when we freeze the camera,

60
00:03:27,406 --> 00:03:31,029
and this yellow line indicated the view frustum.

61
00:03:31,649 --> 00:03:33,550
And when you're flying closer and closer

62
00:03:33,590 --> 00:03:35,171
to what really happened in the far away,

63
00:03:35,691 --> 00:03:37,993
you see all this weapon on the Marine's hand

64
00:03:38,073 --> 00:03:39,594
already switched to the imposter.

65
00:03:40,374 --> 00:03:42,456
And even it's imposter, it's still firing

66
00:03:42,656 --> 00:03:43,857
and killing the enemy.

67
00:03:44,777 --> 00:03:46,018
And for the further case,

68
00:03:46,778 --> 00:03:48,400
you are finding some jackal on the ground

69
00:03:48,680 --> 00:03:49,620
already switched to the.

70
00:03:50,095 --> 00:03:50,595
imposter.

71
00:03:53,896 --> 00:03:56,457
Another interesting case of the imposter is the Elite.

72
00:03:56,958 --> 00:03:59,378
You can see, you know, this Elite switched to the

73
00:03:59,559 --> 00:04:02,120
pretty low-res model, but the filling of the, you know,

74
00:04:02,480 --> 00:04:04,981
alien material, you know, metal filling,

75
00:04:05,321 --> 00:04:08,482
still keep the color and everything still looks

76
00:04:08,642 --> 00:04:09,603
approximately correct.

77
00:04:12,204 --> 00:04:13,924
When we get in further, you will find a lot of

78
00:04:13,944 --> 00:04:17,246
environment stuff switched to this really low-res,

79
00:04:17,746 --> 00:04:19,287
diffuse looking, you know, stuff.

80
00:04:19,673 --> 00:04:22,315
This is our special system to handling the environment

81
00:04:22,755 --> 00:04:23,215
in Pulsar.

82
00:04:23,235 --> 00:04:24,996
I will talk about those later.

83
00:04:38,802 --> 00:04:40,462
Now let's turn back the time.

84
00:04:40,702 --> 00:04:41,763
Let the Pulsar animate.

85
00:04:44,564 --> 00:04:44,764
See?

86
00:04:44,904 --> 00:04:47,225
So this is like, you know, in Pulsar, really.

87
00:04:47,766 --> 00:04:49,086
involving the combat with you.

88
00:04:49,567 --> 00:04:51,207
So which means, you know, when you play the Halo,

89
00:04:51,227 --> 00:04:53,688
you know, you might be killed millions of times

90
00:04:53,748 --> 00:04:55,429
by this little ugly low-res model,

91
00:04:55,469 --> 00:04:58,230
but you know, you don't really realize their existence.

92
00:05:00,831 --> 00:05:04,252
So, let's go to the technical detail of our system.

93
00:05:04,832 --> 00:05:07,894
The first system, first step for the low-res

94
00:05:07,934 --> 00:05:10,315
imposter generation is a mesh simplification.

95
00:05:10,855 --> 00:05:13,156
So here, we show the, you know,

96
00:05:13,176 --> 00:05:15,136
a case of the hunter in our game.

97
00:05:15,417 --> 00:05:17,037
The hunter might be the easiest case.

98
00:05:17,670 --> 00:05:20,890
you know, in our game, because the whole body

99
00:05:21,010 --> 00:05:22,611
just composed by one single mesh.

100
00:05:22,971 --> 00:05:24,951
But even as simple as the hunter case,

101
00:05:25,191 --> 00:05:27,312
you know, you will notice the artist has been,

102
00:05:27,692 --> 00:05:29,912
has tessellated the mesh really unevenly.

103
00:05:30,513 --> 00:05:33,473
If you're sending this mesh to the, you know,

104
00:05:33,833 --> 00:05:35,514
DX progress mesh simplifier,

105
00:05:35,914 --> 00:05:38,034
when you send the budget to be really aggressive,

106
00:05:38,054 --> 00:05:39,435
you will get a, you know,

107
00:05:40,415 --> 00:05:43,276
most likely you will get a very unacceptable result.

108
00:05:44,016 --> 00:05:45,036
So to work around this.

109
00:05:45,860 --> 00:05:48,662
Problem, the first thing we do, we're trying to do

110
00:05:48,723 --> 00:05:51,224
capturing the voxelized image of this model.

111
00:05:51,725 --> 00:05:54,006
So we, using orthogonal projection,

112
00:05:54,327 --> 00:05:56,228
generate the depth image of this character

113
00:05:56,288 --> 00:05:57,189
from different angle.

114
00:05:57,589 --> 00:06:01,272
So along the sixth axis, we get a sixth depth image here.

115
00:06:02,713 --> 00:06:06,656
The brightness of the gradients indicate how close.

116
00:06:07,532 --> 00:06:09,173
that part of pixel toward you.

117
00:06:09,673 --> 00:06:12,456
So using a really standard visual hall technique,

118
00:06:12,556 --> 00:06:15,338
you know, we can generate a work slice representation

119
00:06:15,398 --> 00:06:18,981
of the character, and then we apply a low pass filtering,

120
00:06:19,561 --> 00:06:22,483
and on this work slice mesh we get something like this.

121
00:06:22,824 --> 00:06:25,786
You will notice, you know, the shape of this hunter

122
00:06:25,826 --> 00:06:28,308
has been pushed out a little bit,

123
00:06:28,488 --> 00:06:29,729
but roughly kept the shape,

124
00:06:30,129 --> 00:06:33,111
but the tessellation of the mesh looks way better

125
00:06:33,151 --> 00:06:34,573
than what we have just now.

126
00:06:34,973 --> 00:06:36,534
So when you're sending this thing into mesh,

127
00:06:36,935 --> 00:06:38,755
direct mesh, progress mesh simplifier,

128
00:06:39,175 --> 00:06:40,416
you will get a result like this.

129
00:06:42,016 --> 00:06:45,798
So this one is around like 10% of the vertex count

130
00:06:46,238 --> 00:06:47,178
of the original mesh.

131
00:06:47,558 --> 00:06:51,019
The original hunter mesh is around 10,000 vertex.

132
00:06:51,460 --> 00:06:53,300
This one is around 1,000 vertex.

133
00:06:54,621 --> 00:06:56,421
So this is our mesh simplification idea.

134
00:06:57,161 --> 00:06:58,582
So a lot of people asking us like,

135
00:06:58,662 --> 00:07:00,463
why you do the voxelization?

136
00:07:00,863 --> 00:07:02,583
So I give you three reason for that.

137
00:07:02,743 --> 00:07:05,584
First, you know, the voxelization can help us

138
00:07:05,604 --> 00:07:06,305
to...

139
00:07:07,653 --> 00:07:09,654
remove a lot of unnecessary small feature

140
00:07:09,955 --> 00:07:10,595
over the character.

141
00:07:11,155 --> 00:07:14,457
Secondly, you know, when artists creating the model,

142
00:07:15,037 --> 00:07:17,778
they using, they build each piece by a component

143
00:07:17,918 --> 00:07:19,639
and just, you know, putting them together,

144
00:07:19,659 --> 00:07:22,260
you know, they buffered in the 3D Studio Max.

145
00:07:22,760 --> 00:07:24,621
So this voxelization can help us

146
00:07:25,021 --> 00:07:27,362
remove a lot of unnecessary inside,

147
00:07:27,463 --> 00:07:29,323
you know, interior triangles.

148
00:07:29,962 --> 00:07:31,263
And the third benefit is like,

149
00:07:31,543 --> 00:07:33,504
because we're using the orthogonal projection

150
00:07:33,544 --> 00:07:35,765
to generate the mesh and the localization for everything,

151
00:07:36,345 --> 00:07:38,646
in the later part, when we do the material fitting,

152
00:07:38,686 --> 00:07:41,108
we can easily align this mesh

153
00:07:41,368 --> 00:07:43,129
with our material parameters.

154
00:07:43,309 --> 00:07:44,729
But that's something we can talk about later.

155
00:07:45,470 --> 00:07:49,372
And but the drawback for this algorithm is,

156
00:07:51,073 --> 00:07:53,694
we do notice some case, some small feature,

157
00:07:53,754 --> 00:07:56,755
which if you're hiding inside some features,

158
00:07:57,135 --> 00:07:59,277
because we only do the six-way projection,

159
00:07:59,774 --> 00:08:04,058
you might have the chance to be ignored by voxelization.

160
00:08:04,158 --> 00:08:07,160
But what we found is it's not really a big deal

161
00:08:07,220 --> 00:08:09,342
because normally artists are building the character

162
00:08:09,422 --> 00:08:10,763
by many, many piece.

163
00:08:11,043 --> 00:08:12,825
Each piece is not relatively big.

164
00:08:12,965 --> 00:08:17,689
So as far as we can get the general profile of that piece,

165
00:08:17,729 --> 00:08:19,310
the whole thing assembled together

166
00:08:19,650 --> 00:08:21,892
looks pretty representative for the original model.

167
00:08:23,942 --> 00:08:26,346
So, the next step we need to do, as we promised,

168
00:08:26,506 --> 00:08:29,892
we want to try to simplify all our complicated material model.

169
00:08:30,834 --> 00:08:32,235
So the way we do that is like,

170
00:08:32,375 --> 00:08:34,857
we assume we have no idea how we,

171
00:08:35,357 --> 00:08:36,538
in writing the shader code,

172
00:08:36,598 --> 00:08:39,321
but we just try to apply the different lighting

173
00:08:39,401 --> 00:08:40,021
over the model.

174
00:08:40,462 --> 00:08:42,743
So when we just turn on the diffuse lighting,

175
00:08:43,164 --> 00:08:44,405
you know, we get something like,

176
00:08:45,165 --> 00:08:48,748
like the case of the very right, or very left.

177
00:08:49,409 --> 00:08:51,170
And if we turn off all the lighting,

178
00:08:51,611 --> 00:08:55,054
you know, we get the picture in the very right.

179
00:08:55,334 --> 00:08:57,816
Just show the self-illumination of the character.

180
00:08:58,458 --> 00:09:01,258
And then we can try manipulate the view

181
00:09:01,278 --> 00:09:02,119
and light direction.

182
00:09:02,479 --> 00:09:04,999
We can capturing the maximum reflection.

183
00:09:05,019 --> 00:09:07,260
I'm sorry, I forgot I have the text on top.

184
00:09:07,580 --> 00:09:10,020
In this case, it shows when n dot h,

185
00:09:10,200 --> 00:09:12,221
n is normal, h is half vector.

186
00:09:12,761 --> 00:09:15,341
When those two vector dot together equal to one,

187
00:09:15,621 --> 00:09:18,842
which means that's maximum specular reflection.

188
00:09:19,562 --> 00:09:21,703
And also we can manipulate n dot h

189
00:09:21,743 --> 00:09:23,163
to something less than one.

190
00:09:23,523 --> 00:09:26,484
We can try to figure out how quickly

191
00:09:26,884 --> 00:09:27,964
the specular will fall off.

192
00:09:28,604 --> 00:09:30,985
So this sounds pretty easy, but the challenge is,

193
00:09:31,005 --> 00:09:34,467
you know, for each pixel of the character,

194
00:09:34,848 --> 00:09:36,048
you know, they have different normal.

195
00:09:36,348 --> 00:09:37,789
If you set a one lighting direction,

196
00:09:38,250 --> 00:09:40,751
the end dot end value will be quite different,

197
00:09:40,791 --> 00:09:43,332
you know, across, you know, the whole character.

198
00:09:43,853 --> 00:09:46,894
So we try some method like the BRDF capturing,

199
00:09:46,914 --> 00:09:48,816
we set a bunch of view and light direction,

200
00:09:49,376 --> 00:09:52,698
and trying to say, hey, you know, we totally, you know.

201
00:09:53,032 --> 00:09:54,853
to be agnostic to the shader code

202
00:09:54,953 --> 00:09:56,494
and like be able to have a computation

203
00:09:56,755 --> 00:09:59,517
like 20 lighting directions, 30 view direction.

204
00:10:00,237 --> 00:10:03,020
But unfortunately, we find, you know,

205
00:10:03,580 --> 00:10:06,763
it works perfect for the diffuse and self-illumination,

206
00:10:06,883 --> 00:10:09,225
but it works horrible for the spectra

207
00:10:09,265 --> 00:10:11,486
because that's really high frequency stuff.

208
00:10:12,007 --> 00:10:15,429
So eventually we have to insert a little, you know,

209
00:10:16,050 --> 00:10:18,031
special code in our shader system, you know,

210
00:10:18,112 --> 00:10:20,914
just to manipulate the view and light direction

211
00:10:20,974 --> 00:10:21,975
for each surface pixel.

212
00:10:22,492 --> 00:10:24,754
This one sounds really scary and complicated,

213
00:10:24,794 --> 00:10:28,497
but due to our really smart, sophisticated shader system,

214
00:10:28,857 --> 00:10:34,201
we can totally compile out those special caption section

215
00:10:34,241 --> 00:10:35,982
shader code in our release build,

216
00:10:36,002 --> 00:10:38,064
so which means they have zero impact

217
00:10:38,464 --> 00:10:39,865
for our final game performance,

218
00:10:40,005 --> 00:10:43,468
but make our material simplification way more reliable.

219
00:10:44,028 --> 00:10:47,731
So after you get those four images

220
00:10:47,951 --> 00:10:50,653
represent four different properties of the material,

221
00:10:51,134 --> 00:10:52,215
so we can roughly.

222
00:10:54,033 --> 00:10:58,877
approximate the material's properties.

223
00:10:59,177 --> 00:11:01,699
Like this first image show the diffuse component

224
00:11:01,719 --> 00:11:02,259
we captured.

225
00:11:02,700 --> 00:11:05,982
The second shows the self-enumeration component

226
00:11:06,022 --> 00:11:06,523
we captured.

227
00:11:07,003 --> 00:11:09,165
And this one is the specular.

228
00:11:10,146 --> 00:11:13,188
So we summed all the three components together.

229
00:11:13,208 --> 00:11:15,070
We get something like this.

230
00:11:15,590 --> 00:11:17,772
Actually this guy is composed by maybe five

231
00:11:17,852 --> 00:11:20,794
different shaders, but after we do the material

232
00:11:20,814 --> 00:11:21,375
simplification.

233
00:11:21,782 --> 00:11:23,263
you know, we just got one material,

234
00:11:24,043 --> 00:11:25,925
and each pixel has three properties.

235
00:11:26,545 --> 00:11:28,687
And for each work zone, you know,

236
00:11:29,168 --> 00:11:31,930
we attach this material properties,

237
00:11:32,410 --> 00:11:35,072
and we apply the mesh simplification

238
00:11:36,093 --> 00:11:37,975
with the material property, which means, you know,

239
00:11:38,455 --> 00:11:40,057
if you're sending a textured cube,

240
00:11:40,397 --> 00:11:42,318
because the texture has a different pattern,

241
00:11:42,338 --> 00:11:43,679
has different material distribution,

242
00:11:44,100 --> 00:11:47,663
you end up with more than eight vertex, but, you know.

243
00:11:48,338 --> 00:11:50,559
when you switch to the pro-vertex lighting,

244
00:11:50,899 --> 00:11:52,779
you still keep the pattern,

245
00:11:53,099 --> 00:11:54,480
keep the feeling of the material.

246
00:11:54,780 --> 00:11:55,540
So that's the trade-off.

247
00:11:55,560 --> 00:11:58,260
So you sacrifice a little bit more vertex budget,

248
00:11:58,380 --> 00:12:02,081
but you get a better representation of the original model

249
00:12:02,461 --> 00:12:03,341
and its texture.

250
00:12:05,082 --> 00:12:07,062
So the next thing we need to do is like,

251
00:12:07,402 --> 00:12:10,963
do the animation information fitting.

252
00:12:11,143 --> 00:12:13,063
So we call that skinny information fitting.

253
00:12:13,743 --> 00:12:14,963
The idea is pretty simple.

254
00:12:15,453 --> 00:12:17,914
So let's look back to the raw mesh,

255
00:12:18,394 --> 00:12:20,355
and for each vertex of the character,

256
00:12:20,435 --> 00:12:22,876
we have four different animation bone

257
00:12:22,936 --> 00:12:24,376
attached with that vertex,

258
00:12:24,536 --> 00:12:25,937
and has a different weighting function.

259
00:12:26,657 --> 00:12:28,557
The way we generate the weighting function

260
00:12:28,617 --> 00:12:31,038
for each imposter vertex is,

261
00:12:31,658 --> 00:12:33,419
we first looking back to the original model,

262
00:12:33,839 --> 00:12:35,279
find all the neighbor vertex,

263
00:12:35,699 --> 00:12:39,000
and so we get a list of the bones need to be,

264
00:12:39,120 --> 00:12:40,641
could be involved for the animation.

265
00:12:41,769 --> 00:12:44,629
Because you reference to more than one original vertex,

266
00:12:44,869 --> 00:12:48,810
you might easily end up with more than four animation bones.

267
00:12:49,210 --> 00:12:52,011
We just sorting them by their original weighting

268
00:12:52,531 --> 00:12:55,612
and also the distance, the weighting by the distance

269
00:12:55,832 --> 00:12:58,472
to this low rise vertex.

270
00:12:58,932 --> 00:13:01,173
And so we figured out which animation bone

271
00:13:01,473 --> 00:13:02,653
is the most dominant one.

272
00:13:03,213 --> 00:13:04,734
And so for the imposter model,

273
00:13:05,074 --> 00:13:07,154
we just animated the character with a single bone

274
00:13:07,194 --> 00:13:09,395
rather than the full bone interpolation.

275
00:13:10,619 --> 00:13:12,860
This one sounds like we sacrificed some quality,

276
00:13:12,920 --> 00:13:16,522
but it's turned out to be a really big, you know,

277
00:13:17,062 --> 00:13:19,043
improvement for the imposter performance.

278
00:13:19,564 --> 00:13:21,605
Because, you know, you only need to animate one bone

279
00:13:21,985 --> 00:13:22,965
in your vertex shader.

280
00:13:26,027 --> 00:13:27,908
So, this is the, like, fitted result.

281
00:13:29,809 --> 00:13:32,870
So, that's everything about our, you know,

282
00:13:33,150 --> 00:13:34,171
object imposter system.

283
00:13:34,711 --> 00:13:37,292
You know, it's pretty simple, based on three simple ideas.

284
00:13:38,319 --> 00:13:40,623
But we do find some challenges with this system.

285
00:13:40,663 --> 00:13:43,347
First, you know, when we do the workflow filtering,

286
00:13:43,367 --> 00:13:47,172
we find that the filtering kernel is really sensitive value

287
00:13:47,232 --> 00:13:49,957
because you're setting the kernel to be larger,

288
00:13:50,257 --> 00:13:52,040
you will get a smoother result,

289
00:13:52,440 --> 00:13:54,043
which means the mesh simplification result.

290
00:13:54,719 --> 00:13:57,740
well, looks better, you can use more aggressive budgeting.

291
00:13:58,261 --> 00:14:00,822
But if you make that thing too aggressive,

292
00:14:00,923 --> 00:14:02,744
you will get some better result like this.

293
00:14:03,124 --> 00:14:05,145
Because the neutral pose of the jackal,

294
00:14:05,485 --> 00:14:07,727
the two legs sitting pretty close to each other.

295
00:14:07,787 --> 00:14:09,588
So when you're applying the filtering,

296
00:14:09,628 --> 00:14:11,309
those two legs will be linked together.

297
00:14:12,030 --> 00:14:15,712
And another challenging case for us is the transparency.

298
00:14:16,072 --> 00:14:18,254
We do try some technique to detect

299
00:14:18,274 --> 00:14:20,215
all this transparency stuff, run on different methods,

300
00:14:20,715 --> 00:14:22,676
but it turned out to be not very reliable.

301
00:14:23,164 --> 00:14:25,045
And another thing is very thin geometry,

302
00:14:25,085 --> 00:14:26,546
because when you do the voxelization,

303
00:14:27,026 --> 00:14:29,648
you can easily make the single-faced geometry

304
00:14:29,688 --> 00:14:31,049
to be double-faced voxelized.

305
00:14:31,389 --> 00:14:35,392
That's okay when you generate the source voxelized mesh

306
00:14:35,833 --> 00:14:38,655
for the simplifier, but when you run the simplification,

307
00:14:38,695 --> 00:14:41,016
you can easily get the front and back face

308
00:14:41,116 --> 00:14:43,678
intersect each other, which looks pretty ugly

309
00:14:43,738 --> 00:14:44,339
under the lighting.

310
00:14:44,859 --> 00:14:46,340
So for those two challenging case,

311
00:14:46,720 --> 00:14:47,841
our solution is quite simple.

312
00:14:47,861 --> 00:14:49,062
We just say, hey, do nothing.

313
00:14:49,522 --> 00:14:51,304
So we just give the option to the artist,

314
00:14:51,324 --> 00:14:52,805
say if you notice anything wrong.

315
00:14:53,252 --> 00:14:55,813
just turn off the imposter for that particular part

316
00:14:55,853 --> 00:14:56,494
of the object.

317
00:14:57,454 --> 00:15:00,537
And we try a lot of different character

318
00:15:00,717 --> 00:15:01,797
and asset in our game.

319
00:15:02,138 --> 00:15:05,920
We found set up a reasonable budgeting is very important.

320
00:15:06,480 --> 00:15:11,384
So our experimental result is for the object,

321
00:15:11,604 --> 00:15:16,147
we normally set 12% vertex count of the original mesh.

322
00:15:16,968 --> 00:15:19,589
And we found the transition distance.

323
00:15:19,669 --> 00:15:21,110
Transition distance means, you know.

324
00:15:21,460 --> 00:15:24,222
the distance when you switch from the object to the imposter,

325
00:15:24,742 --> 00:15:27,424
we set it up to be the 30 times of the bounding radius

326
00:15:27,544 --> 00:15:28,164
of the object.

327
00:15:28,524 --> 00:15:32,887
That's a, both of the data are purely experimental result,

328
00:15:33,167 --> 00:15:35,188
so which means if you're trying to apply this technique

329
00:15:35,248 --> 00:15:37,569
in your own game, you need to set up your own data.

330
00:15:38,230 --> 00:15:41,312
So this two data just for your reference.

331
00:15:42,472 --> 00:15:43,713
For the environment object,

332
00:15:43,953 --> 00:15:45,574
which is a little bit different story,

333
00:15:45,914 --> 00:15:49,296
because environment objects mostly like tree, like rocks,

334
00:15:49,576 --> 00:15:50,817
those things are pretty static,

335
00:15:51,389 --> 00:15:54,691
placed in our level, they don't remove,

336
00:15:55,251 --> 00:15:56,492
but they have a lot.

337
00:15:56,912 --> 00:16:02,435
So we find maybe we need a better solution for them.

338
00:16:03,056 --> 00:16:04,656
So the idea is very simple.

339
00:16:05,617 --> 00:16:09,459
Is, what about we just directly base the lighting result

340
00:16:09,519 --> 00:16:12,181
in our progressive color rather than run the shading?

341
00:16:12,701 --> 00:16:15,723
The reason for that is because those environment objects,

342
00:16:15,743 --> 00:16:17,223
they just stay in one location,

343
00:16:17,584 --> 00:16:19,305
they already know what exactly

344
00:16:19,345 --> 00:16:20,525
their lighting condition will be.

345
00:16:21,592 --> 00:16:25,693
So, yeah, we don't need to do all the complicated,

346
00:16:25,753 --> 00:16:27,313
multiple steps, like set up your lighting,

347
00:16:27,653 --> 00:16:29,594
set up your material, do the shading in the picture.

348
00:16:29,634 --> 00:16:32,094
We just say, hey, start everything, render the object.

349
00:16:33,514 --> 00:16:35,155
The second optimization we did is,

350
00:16:35,575 --> 00:16:39,256
we're trying to grouping all the neighbored

351
00:16:39,276 --> 00:16:42,316
environment objects with a similar size

352
00:16:42,456 --> 00:16:43,556
into one group.

353
00:16:44,077 --> 00:16:45,897
So which means, when we do the rendering,

354
00:16:46,257 --> 00:16:49,117
we just do one single draw primitive call,

355
00:16:49,418 --> 00:16:50,758
and we can render a bunch of them.

356
00:16:51,202 --> 00:16:54,222
which save us a big overhead of the CPU time

357
00:16:54,262 --> 00:16:58,164
because the directs and set up the render call

358
00:16:58,404 --> 00:17:00,124
is not that cheap.

359
00:17:00,424 --> 00:17:02,505
And if you do that a thousand times for each frame,

360
00:17:02,865 --> 00:17:04,346
the overhead is significant.

361
00:17:05,606 --> 00:17:07,727
So here is a video show our,

362
00:17:09,187 --> 00:17:11,148
you know, imposed on the environment object.

363
00:17:11,408 --> 00:17:12,328
Look at all those rock.

364
00:17:12,508 --> 00:17:13,968
When you're flying camera further.

365
00:17:15,204 --> 00:17:17,265
you will find that those rocks have actually been fading

366
00:17:17,345 --> 00:17:19,106
to the only diffuse looking poster,

367
00:17:19,146 --> 00:17:22,507
but you will notice their lighting matched pretty good

368
00:17:22,627 --> 00:17:23,748
and it's pretty hard to notice.

369
00:17:24,808 --> 00:17:25,808
And so we're fading the back.

370
00:17:28,770 --> 00:17:30,650
And now I will turn on the debugging mode,

371
00:17:31,251 --> 00:17:33,992
which means, you know, when you're flying the camera away,

372
00:17:34,992 --> 00:17:36,073
if you are already in poster,

373
00:17:36,273 --> 00:17:39,794
we are using the blue wireframe to indicate the switching.

374
00:17:40,534 --> 00:17:42,855
And you will notice that when you're flying really far,

375
00:17:43,672 --> 00:17:46,275
a group of environment objects we are sending,

376
00:17:46,655 --> 00:17:48,057
as it renders one draw call,

377
00:17:48,097 --> 00:17:50,980
we indicate that with a light bounding box.

378
00:17:51,661 --> 00:17:53,923
So that's how our imposter system works

379
00:17:54,023 --> 00:17:55,505
with environment objects.

380
00:17:59,189 --> 00:18:01,952
So that's pretty much everything about

381
00:18:02,112 --> 00:18:04,594
our ultimate LOD system for HaloReach.

382
00:18:06,703 --> 00:18:09,185
It's turned out to be a pretty big win for our performance.

383
00:18:09,345 --> 00:18:11,107
For the dynamic objects characters,

384
00:18:11,607 --> 00:18:14,569
the impulse rendering is about 10 to 20 times faster

385
00:18:15,009 --> 00:18:16,851
than the original model rendering.

386
00:18:17,471 --> 00:18:21,674
And for environment object, it's about 50 to 100 times

387
00:18:22,235 --> 00:18:23,275
faster than the original one.

388
00:18:23,295 --> 00:18:24,736
The reason for that we already explained

389
00:18:24,776 --> 00:18:27,458
because we just using per vertex,

390
00:18:27,518 --> 00:18:29,159
pre-baked color rendering.

391
00:18:29,280 --> 00:18:31,081
So it's supposed to be that cheap.

392
00:18:31,901 --> 00:18:34,784
And on storage UIC for the dynamic object,

393
00:18:35,124 --> 00:18:35,444
which is.

394
00:18:36,215 --> 00:18:37,215
around eight times less.

395
00:18:37,255 --> 00:18:39,356
So it's kind of like a little additional data

396
00:18:40,436 --> 00:18:41,997
sitting beside the original model.

397
00:18:42,437 --> 00:18:45,518
And for the environment, we pay a little bit more

398
00:18:45,558 --> 00:18:49,740
because we need to bake the lighting, which

399
00:18:49,800 --> 00:18:54,222
means for the same environment instance definition,

400
00:18:55,082 --> 00:18:57,363
because for its different placement,

401
00:18:57,383 --> 00:18:58,863
we need to generate a different imposter.

402
00:18:59,224 --> 00:19:02,905
This thing sounds scary, but because the per vertex overhead

403
00:19:02,965 --> 00:19:03,625
is so low.

404
00:19:04,422 --> 00:19:06,544
it turns out we're still five times smaller

405
00:19:06,644 --> 00:19:11,628
than the real memory cost of the full environment object.

406
00:19:12,369 --> 00:19:15,972
And so we find it's a really valuable investment

407
00:19:16,032 --> 00:19:19,595
for our system, considering the three years production time

408
00:19:19,635 --> 00:19:22,397
of the Halo Rage, and we have 100 people's team,

409
00:19:22,898 --> 00:19:25,700
we rarely have the case, artists need to deal

410
00:19:25,720 --> 00:19:28,983
with the system to figure out something's wrong,

411
00:19:29,103 --> 00:19:31,425
and they just go ahead, create their high-res model,

412
00:19:31,445 --> 00:19:33,507
they will get this low-res model for free.

413
00:19:34,311 --> 00:19:37,312
And we also realized it's really important

414
00:19:37,332 --> 00:19:38,632
to provide the manual switch,

415
00:19:38,732 --> 00:19:40,833
which means for any broken case,

416
00:19:41,053 --> 00:19:41,873
we mentioned it before,

417
00:19:42,053 --> 00:19:44,114
and some unsatisfied case,

418
00:19:44,494 --> 00:19:47,515
the artist and the QA team always has the option

419
00:19:47,915 --> 00:19:49,856
to turn it off.

420
00:19:51,176 --> 00:19:53,697
So, there's still something we want to improve

421
00:19:53,717 --> 00:19:56,077
in our future game developing.

422
00:19:56,257 --> 00:20:01,159
One is, we decided using the Direct Smash Simplifier

423
00:20:01,359 --> 00:20:02,039
and Progress Smash.

424
00:20:02,564 --> 00:20:05,386
But in the later, we realize it will be way better

425
00:20:05,446 --> 00:20:07,308
if we can write our own mesh simplifier.

426
00:20:07,648 --> 00:20:10,450
The reason for that is because when we do the capturing

427
00:20:10,610 --> 00:20:13,973
of the model, we capture a lot of information.

428
00:20:14,013 --> 00:20:17,355
And also, artists has a lot of idea

429
00:20:17,816 --> 00:20:20,097
and some hint information we want to provide

430
00:20:20,357 --> 00:20:21,939
to guiding our mesh simplification.

431
00:20:22,359 --> 00:20:24,320
But using the third party mesh simplifier,

432
00:20:24,361 --> 00:20:26,802
we don't have the luxury to customize that.

433
00:20:27,183 --> 00:20:28,344
And if we write it on our own,

434
00:20:28,544 --> 00:20:31,386
we can easily incorporate those information

435
00:20:31,446 --> 00:20:32,306
to guide us to work.

436
00:20:32,686 --> 00:20:33,607
to get a better result.

437
00:20:34,207 --> 00:20:37,030
Another thing we want seriously adding,

438
00:20:37,270 --> 00:20:39,612
allow the artist to customize a low-res model.

439
00:20:39,992 --> 00:20:42,154
Because we find that the artist is still

440
00:20:42,194 --> 00:20:45,256
the guy who knows how this thing is supposed

441
00:20:45,276 --> 00:20:46,097
to look like best.

442
00:20:46,597 --> 00:20:49,620
So we can give them good looking for 90% of case,

443
00:20:49,720 --> 00:20:52,202
but they stay up with 10%, I mean, 5% of case,

444
00:20:52,442 --> 00:20:54,184
they find it will be way better.

445
00:20:54,204 --> 00:20:55,264
I can create my own.

446
00:20:55,785 --> 00:20:59,848
So we think this option is very important for our content team.

447
00:21:00,709 --> 00:21:02,390
So that's all of my talk.

448
00:21:02,739 --> 00:21:03,840
And thank you very much.

449
00:21:04,281 --> 00:21:07,343
And so if you are interested in Bungie Studio,

450
00:21:07,683 --> 00:21:09,905
and we have a bunch of openings, just

451
00:21:09,945 --> 00:21:11,827
feel free to contact our HR.

452
00:21:12,468 --> 00:21:13,789
And so if you have any questions,

453
00:21:14,089 --> 00:21:15,250
please step to the microphone.

454
00:21:19,594 --> 00:21:19,854
Thank you.

455
00:21:32,481 --> 00:21:34,603
Yes, I was curious if in this work,

456
00:21:34,723 --> 00:21:36,084
if you ever run into the case where

457
00:21:36,485 --> 00:21:37,986
due to the reduced amount of vertices,

458
00:21:38,146 --> 00:21:41,049
if you ever were running actually slower doing things

459
00:21:41,209 --> 00:21:45,593
per vertex instead of per pixel, seeing that fewer pixels were

460
00:21:45,613 --> 00:21:47,895
going to be for the object.

461
00:21:48,235 --> 00:21:48,396
Hm?

462
00:21:48,736 --> 00:21:49,757
Can I repeat the question again?

463
00:21:49,937 --> 00:21:50,037
OK.

464
00:21:50,057 --> 00:21:51,659
I haven't heard it.

465
00:21:53,000 --> 00:21:54,801
And when you were using this system,

466
00:21:54,881 --> 00:21:56,123
did you ever run into cases?

467
00:21:56,629 --> 00:21:59,931
where an object still had enough verts in the object,

468
00:22:00,291 --> 00:22:02,513
where it would actually run slower per vertex

469
00:22:03,093 --> 00:22:04,274
rather than per pixel?

470
00:22:04,614 --> 00:22:07,356
Or was it always a win to do everything

471
00:22:07,416 --> 00:22:08,717
per pixel at a distance?

472
00:22:10,338 --> 00:22:12,840
We tried the per vertex simplification before,

473
00:22:12,900 --> 00:22:14,541
like just sending the original mesh.

474
00:22:15,022 --> 00:22:16,282
But the result is not good.

475
00:22:16,343 --> 00:22:19,064
But unfortunately, I haven't have that same shows up,

476
00:22:19,125 --> 00:22:21,386
because that's pretty, pretty early try.

477
00:22:21,446 --> 00:22:23,668
We run a bunch of the objects there.

478
00:22:24,364 --> 00:22:25,925
And we realized, you know, we need,

479
00:22:26,265 --> 00:22:28,007
because when the artist created the model,

480
00:22:28,027 --> 00:22:30,609
you know, their tessellation is really, you know,

481
00:22:30,729 --> 00:22:35,193
arbitrary, so we realized we're using the per pixel solution

482
00:22:35,313 --> 00:22:39,177
to make the source mesh tessellation as even as possible.

483
00:22:39,657 --> 00:22:41,879
We have benefited the follow the mesh simplifier a lot.

484
00:22:41,939 --> 00:22:42,060
So.

485
00:22:42,080 --> 00:22:46,544
We only have time for one more question.

486
00:22:50,867 --> 00:22:51,028
Yeah.

487
00:22:56,475 --> 00:23:01,700
Hi. What simple changes did you make from Halo 2 to Halo Reach

488
00:23:01,760 --> 00:23:03,142
as far as using imposters?

489
00:23:03,582 --> 00:23:06,785
Because in Halo 2, you could see the imposter sometimes

490
00:23:06,826 --> 00:23:07,546
when it was loading.

491
00:23:07,827 --> 00:23:11,590
Did you do some sort of line of sight changes or timing

492
00:23:11,631 --> 00:23:12,011
changes?

493
00:23:12,111 --> 00:23:13,673
Like, what would be the simple changes?

494
00:23:14,933 --> 00:23:18,735
In the Halo 2 and Halo 3, we don't have an imposter system,

495
00:23:18,755 --> 00:23:21,937
but we have a low-res model available,

496
00:23:22,197 --> 00:23:23,458
which means for any object,

497
00:23:23,998 --> 00:23:26,019
artists can create a separate low-res model

498
00:23:26,279 --> 00:23:27,420
and attach with that object

499
00:23:27,480 --> 00:23:28,821
and set up the transition distance.

500
00:23:29,401 --> 00:23:30,902
The problem for that setting is,

501
00:23:31,642 --> 00:23:34,223
for most cases, artists just forget

502
00:23:34,304 --> 00:23:36,104
to create a low-res model.

503
00:23:36,505 --> 00:23:39,907
Another challenge is, because in a full-res model,

504
00:23:39,927 --> 00:23:42,348
you have a lot of fancy material and texture

505
00:23:42,448 --> 00:23:43,428
and it looks awesome.

506
00:23:43,843 --> 00:23:45,743
But when you create a low-res model,

507
00:23:45,763 --> 00:23:47,484
you want to use a cheaper texture,

508
00:23:47,584 --> 00:23:49,044
cheaper lighting, cheaper material model.

509
00:23:49,404 --> 00:23:53,005
To make sure the two versions look similar to each other

510
00:23:53,085 --> 00:23:54,245
is pretty challenging.

511
00:23:54,885 --> 00:23:57,486
Imagine you have really fancy material

512
00:23:57,506 --> 00:23:59,266
which composed with 20 different material,

513
00:23:59,346 --> 00:24:02,887
and if you're trying to mimic that

514
00:24:02,947 --> 00:24:05,308
with just a simple foam shader,

515
00:24:06,648 --> 00:24:08,269
trying to find the right parameter for that

516
00:24:08,349 --> 00:24:11,389
is not a trivial thing for the content team.

517
00:24:12,289 --> 00:24:12,530
Thank you.

518
00:24:14,737 --> 00:24:16,258
So I think it's about the time.

519
00:24:16,278 --> 00:24:17,778
OK, thank you very much.

520
00:24:17,798 --> 00:24:18,019
Thank you.

521
00:24:18,039 --> 00:24:18,299
Thank you.

522
00:24:18,319 --> 00:24:22,101
Thank you.

523
00:24:22,581 --> 00:24:22,781
Thank you.

524
00:24:22,801 --> 00:24:23,041
Thank you.

525
00:24:23,061 --> 00:24:23,282
Thank you.

526
00:24:23,302 --> 00:24:23,642
Thank you.

527
00:24:23,662 --> 00:24:24,222
Oh, I forgot to one thing.

528
00:24:24,242 --> 00:24:25,183
Please fill the evaluation form.

529
00:24:25,343 --> 00:24:25,683
Thank you.

530
00:24:25,703 --> 00:24:32,427
OK.

531
00:24:32,467 --> 00:24:32,987
Good luck, dude.

532
00:24:33,447 --> 00:24:33,768
Thank you.

533
00:24:33,948 --> 00:24:34,828
I think all I need is the sound.

534
00:24:34,868 --> 00:24:34,908
Oh.

535
00:24:34,928 --> 00:24:34,988
Oh.

536
00:24:35,008 --> 00:24:35,048
Oh.

537
00:24:35,068 --> 00:24:35,108
Oh.

538
00:24:35,168 --> 00:24:35,269
Oh.

539
00:24:35,289 --> 00:24:35,369
Oh.

540
00:24:35,389 --> 00:24:35,429
Oh.

541
00:24:35,809 --> 00:24:35,849
Oh.

542
00:24:35,869 --> 00:24:35,909
Oh.

543
00:24:35,929 --> 00:24:35,969
Oh.

544
00:24:40,512 --> 00:24:40,592
Oh.

545
00:24:40,612 --> 00:24:40,652
Oh.

546
00:24:40,672 --> 00:24:40,712
Oh.

547
00:24:41,112 --> 00:24:41,152
Oh.

548
00:24:41,232 --> 00:24:41,272
Oh.

549
00:24:41,292 --> 00:24:41,352
Oh.

550
00:24:41,372 --> 00:24:41,412
Oh.

551
00:24:41,432 --> 00:24:41,512
Oh.

552
00:24:50,099 --> 00:24:53,203
shift to the middle so we can get more people seated or coming in, I guess.

