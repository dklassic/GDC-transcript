1
00:00:06,022 --> 00:00:08,284
Hello, and welcome to our presentation.

2
00:00:09,625 --> 00:00:10,706
My name is Ville Rustie.

3
00:00:10,946 --> 00:00:12,527
I'm a principal animation programmer.

4
00:00:13,268 --> 00:00:15,470
Here with me presenting is Ilkka Kuusela,

5
00:00:16,110 --> 00:00:17,411
principal gameplay animator.

6
00:00:18,792 --> 00:00:21,234
We both are from a company called Remedy.

7
00:00:22,515 --> 00:00:24,337
We are quite a small studio in Finland,

8
00:00:24,837 --> 00:00:28,080
famous from our story-driven action games,

9
00:00:29,701 --> 00:00:32,403
such as Max Payne, Alan Wake, Quantum Break,

10
00:00:32,904 --> 00:00:34,145
and our latest, Control.

11
00:00:36,100 --> 00:00:39,822
In this talk, we will go through how we build our own animation technology,

12
00:00:40,462 --> 00:00:42,583
how we took the responsiveness to the next level,

13
00:00:43,324 --> 00:00:46,446
how we started using this quite new tech called motion matching,

14
00:00:47,186 --> 00:00:48,927
how we created animation-friendly tools,

15
00:00:49,687 --> 00:00:52,869
and how, of course, how we survived through all the craziness

16
00:00:52,889 --> 00:00:55,731
that was happening around us with the project.

17
00:00:57,011 --> 00:00:59,353
But before we start, here's a video of Kontroll.

18
00:02:11,438 --> 00:02:16,704
And quite early in the project, we sat down and started laying out our core game goals.

19
00:02:17,665 --> 00:02:20,347
We wanted to make a fast action game.

20
00:02:21,228 --> 00:02:24,531
This means a much stronger focus on the gameplay than the Quantum Break was.

21
00:02:26,014 --> 00:02:28,476
This also means that the animations can't compromise controls.

22
00:02:29,176 --> 00:02:30,677
It needs to be twice as responsive

23
00:02:30,738 --> 00:02:31,858
what the quantum break was.

24
00:02:32,799 --> 00:02:34,480
We got a lot of feedback on that.

25
00:02:40,865 --> 00:02:44,287
For action, we of course need more enemies on the screen.

26
00:02:44,788 --> 00:02:46,669
This includes supernatural abilities,

27
00:02:46,929 --> 00:02:48,510
include flying and throwing objects.

28
00:02:50,532 --> 00:02:52,874
So how to make game responsive?

29
00:02:53,154 --> 00:02:54,915
For us, this means code-driven movement.

30
00:02:55,811 --> 00:02:57,452
It needs to work without any animations.

31
00:02:58,133 --> 00:03:01,035
And it needs to be easy enough that even the designers can

32
00:03:01,095 --> 00:03:01,535
iterate it.

33
00:03:03,176 --> 00:03:05,838
For animation part, this is quite tricky.

34
00:03:06,098 --> 00:03:08,020
So I started evaluating different options.

35
00:03:10,301 --> 00:03:12,363
And I found out motion matching.

36
00:03:12,803 --> 00:03:15,084
It seems quite good candidate.

37
00:03:16,806 --> 00:03:17,866
So what is motion matching?

38
00:03:18,887 --> 00:03:21,529
It's a tech originally presented by Ubisoft in 2015, Nuclear AI.

39
00:03:23,311 --> 00:03:26,433
and then brought to the bigger audience in 2016 GDC.

40
00:03:27,774 --> 00:03:29,014
It's a database of animations.

41
00:03:29,695 --> 00:03:31,676
We break the path based on the player's input

42
00:03:31,816 --> 00:03:32,857
and then the AI path.

43
00:03:33,737 --> 00:03:36,579
We search through this big database to find the frame

44
00:03:36,959 --> 00:03:39,521
which best matches the character's current pose

45
00:03:39,821 --> 00:03:40,902
and the path we generated.

46
00:03:41,762 --> 00:03:43,643
This search is then repeated every frame.

47
00:03:44,884 --> 00:03:48,126
So in action, we have a character and we have a path.

48
00:03:49,427 --> 00:03:51,108
We have a bunch of points in a path,

49
00:03:51,488 --> 00:03:53,029
some in the future, some in the past.

50
00:03:54,071 --> 00:03:55,952
Then we have points in the character,

51
00:03:57,032 --> 00:04:01,114
such as angle positions, velocities, hip direction,

52
00:04:01,354 --> 00:04:02,335
and then the head height.

53
00:04:04,976 --> 00:04:08,237
Then we generate offline the same information

54
00:04:08,357 --> 00:04:09,058
for animations.

55
00:04:10,839 --> 00:04:14,080
We run through this search through this database

56
00:04:14,740 --> 00:04:16,361
and compute cost for each frame.

57
00:04:17,902 --> 00:04:20,923
Then in the end, we pick the one with the closest.

58
00:04:22,224 --> 00:04:22,704
In this case,

59
00:04:24,110 --> 00:04:25,491
it picked really well.

60
00:04:29,174 --> 00:04:31,356
So I started making prototype.

61
00:04:32,597 --> 00:04:34,658
At that point, we were using Morphine as a middleware,

62
00:04:35,279 --> 00:04:36,580
so I added the custom node to it,

63
00:04:36,960 --> 00:04:38,421
and then simple path prediction.

64
00:04:39,282 --> 00:04:43,445
For animations, we used the Ubisoft Dance Guard

65
00:04:44,185 --> 00:04:44,986
as a reference.

66
00:04:46,707 --> 00:04:48,889
I added the motion shader, which defines

67
00:04:49,509 --> 00:04:52,632
how exactly the potion trajectory is compared.

68
00:04:53,792 --> 00:04:56,133
We chose to use the data-driven approach

69
00:04:57,253 --> 00:05:00,575
to allow quick iteration, what features we need.

70
00:05:01,636 --> 00:05:05,498
So I exposed position, velocity, and direction.

71
00:05:06,478 --> 00:05:12,321
For trajectory channels, I added support

72
00:05:12,361 --> 00:05:13,702
for specifying the time.

73
00:05:14,442 --> 00:05:18,264
So those channels could be in the future or in the past.

74
00:05:18,764 --> 00:05:19,265
For bones.

75
00:05:22,882 --> 00:05:25,044
the information is only relative to current frame.

76
00:05:27,325 --> 00:05:32,429
In order to control this, I added a bunch of markup.

77
00:05:33,510 --> 00:05:36,392
I split the locomotion state into idle, start, stop,

78
00:05:36,452 --> 00:05:36,872
and move.

79
00:05:38,374 --> 00:05:40,555
Then we went through all the animations

80
00:05:40,595 --> 00:05:43,357
that were in the database and tagged those based on this.

81
00:05:44,999 --> 00:05:45,879
And this is how it looked.

82
00:05:47,040 --> 00:05:50,743
So we have our test character walking around.

83
00:05:51,605 --> 00:05:52,526
we generated the path.

84
00:05:52,646 --> 00:05:54,888
The path is the one that is in the ground.

85
00:05:56,310 --> 00:05:58,131
And the character is following quite nicely.

86
00:05:59,793 --> 00:06:02,155
And all this data is just the raw data.

87
00:06:02,756 --> 00:06:04,898
We didn't do much of editing with this.

88
00:06:05,878 --> 00:06:08,741
And it seems to work surprisingly well with this.

89
00:06:12,785 --> 00:06:14,266
So we were happy with this prototype.

90
00:06:15,387 --> 00:06:18,110
We were also happy with the runtime characteristics of it.

91
00:06:19,189 --> 00:06:22,150
The motion matching only needs some small internal state,

92
00:06:22,411 --> 00:06:23,831
like animation index and time.

93
00:06:24,531 --> 00:06:27,153
It's so small that we could easily use that even

94
00:06:27,293 --> 00:06:28,213
in the multiplayer game.

95
00:06:29,474 --> 00:06:31,054
The memory usage is also good.

96
00:06:31,975 --> 00:06:36,717
It's small and consistent, and it's the same in each frame.

97
00:06:38,998 --> 00:06:40,178
But then a surprise happened.

98
00:06:40,658 --> 00:06:41,879
Morphine goes out of market.

99
00:06:42,799 --> 00:06:45,160
So I had to stop doing this prototype.

100
00:06:48,030 --> 00:06:49,331
Now we need to evaluate options.

101
00:06:51,093 --> 00:06:53,454
We checked the Havoc behavior, Granny Animation

102
00:06:53,474 --> 00:06:54,755
Studio, and some others.

103
00:06:55,456 --> 00:06:58,158
But there's not really anything similar available.

104
00:06:59,239 --> 00:07:01,481
We would also have to build quite a lot of tech

105
00:07:01,521 --> 00:07:02,662
on top of those middlewares.

106
00:07:03,302 --> 00:07:04,903
But those middlewares also share the risk

107
00:07:05,063 --> 00:07:06,084
of going out of market.

108
00:07:07,445 --> 00:07:10,467
Seems that for us, the best option is to build our own tech.

109
00:07:12,249 --> 00:07:13,530
And for that, we need a plan.

110
00:07:14,631 --> 00:07:15,671
With past experience.

111
00:07:16,338 --> 00:07:19,660
We wanted to focus on performance, runtime performance,

112
00:07:19,760 --> 00:07:20,760
and the fast iteration.

113
00:07:22,441 --> 00:07:26,143
We wanted to simplify the graphs.

114
00:07:28,164 --> 00:07:32,806
So we wanted more powerful nodes doing complex operations

115
00:07:32,846 --> 00:07:33,947
such as motion matching,

116
00:07:34,807 --> 00:07:36,548
which we chose as to be the core feature.

117
00:07:38,189 --> 00:07:40,630
The old player graph was close to 10,000 nodes.

118
00:07:41,510 --> 00:07:44,532
The top picture you can see is just a small fraction

119
00:07:44,672 --> 00:07:46,073
of complexity that we had.

120
00:07:49,653 --> 00:07:53,896
We chose then that we want to use the expressions instead of math nodes.

121
00:07:54,216 --> 00:07:57,998
All those gray boxes that you can see in the top picture are actually math nodes.

122
00:07:59,639 --> 00:08:05,262
Then we picked the best features from the old middlewares and no state machines.

123
00:08:06,323 --> 00:08:08,184
I will cover that in a later slide.

124
00:08:10,105 --> 00:08:12,566
So we started with code driven movement only.

125
00:08:13,006 --> 00:08:16,708
Single plane tree, input and internal variables and expressions.

126
00:08:18,333 --> 00:08:19,094
And this is how it looks.

127
00:08:19,654 --> 00:08:21,836
So we have a motion matching that will cover

128
00:08:22,457 --> 00:08:23,357
the core locomotion.

129
00:08:24,238 --> 00:08:26,520
Then we have an animation clip to handle mantling.

130
00:08:27,660 --> 00:08:30,403
The select will be either one

131
00:08:30,703 --> 00:08:33,765
depending on the player's action.

132
00:08:34,706 --> 00:08:36,667
Then we have a more traditional nodes

133
00:08:36,887 --> 00:08:38,909
such as Fader Blend and Blend N.

134
00:08:39,670 --> 00:08:41,471
The Blend N covers the aim matrix

135
00:08:42,111 --> 00:08:44,533
and the Fader Blend N applies it only to upper body.

136
00:08:45,474 --> 00:08:48,136
The two bone IK fixes the aiming hand.

137
00:08:48,532 --> 00:08:49,072
in the right place.

138
00:08:52,133 --> 00:08:54,833
For expression, I created own expression language,

139
00:08:55,053 --> 00:08:56,954
quite similar to shader languages.

140
00:08:57,754 --> 00:09:00,875
I hooked that one into graph, which runs

141
00:09:00,955 --> 00:09:02,175
before the graph is evaluated.

142
00:09:02,675 --> 00:09:05,195
This allows us to compute internal variables.

143
00:09:06,256 --> 00:09:08,676
So the input variables are the one that come from the game.

144
00:09:09,236 --> 00:09:11,397
The graph variables are the one that are computed.

145
00:09:12,177 --> 00:09:14,697
The graph itself can use both of these.

146
00:09:16,747 --> 00:09:18,988
In addition to that, I added expression node.

147
00:09:20,049 --> 00:09:21,009
It's a node in a graph.

148
00:09:21,950 --> 00:09:23,850
It can be placed in any point there,

149
00:09:24,371 --> 00:09:26,532
and it only runs when the node is active.

150
00:09:27,492 --> 00:09:30,794
It can modify bones or compute variables for next node.

151
00:09:32,574 --> 00:09:34,275
It's really good for prototyping features,

152
00:09:35,155 --> 00:09:39,617
such as different IK setups.

153
00:09:42,279 --> 00:09:44,540
But then, second surprise, E3 demo.

154
00:09:45,675 --> 00:09:50,056
So we just got this deck running, and now we have six months

155
00:09:50,116 --> 00:09:51,716
to ship hands-off demo.

156
00:09:52,417 --> 00:09:53,777
It needs to have a functional mission,

157
00:09:54,497 --> 00:09:57,117
multiple player abilities, four enemy archetypes,

158
00:09:57,778 --> 00:09:59,638
and everything needs to run on new tech.

159
00:10:05,339 --> 00:10:06,459
We need survival plan.

160
00:10:07,399 --> 00:10:10,580
For locomotion, we chose to use motion matching for all.

161
00:10:11,440 --> 00:10:13,000
We don't have time to do anything else.

162
00:10:14,555 --> 00:10:17,036
In order to allow multiple animators to work with this,

163
00:10:18,297 --> 00:10:19,898
we need to split graphs into layers.

164
00:10:21,039 --> 00:10:23,760
Luckily, we have the expressions to make up

165
00:10:23,920 --> 00:10:25,742
all the missing features that we have.

166
00:10:27,243 --> 00:10:29,544
And luckily, we also have time to work with the tech.

167
00:10:32,246 --> 00:10:33,546
So we added Animation Mixer.

168
00:10:34,227 --> 00:10:36,468
It defines the graph order.

169
00:10:37,049 --> 00:10:40,431
So you can choose if a graph is running

170
00:10:40,491 --> 00:10:42,732
in the pre-physics or post-physics after.

171
00:10:43,580 --> 00:10:46,202
dialog lines or after time timelines.

172
00:10:47,363 --> 00:10:49,785
Each of these graphs here are own files.

173
00:10:50,066 --> 00:10:51,687
They can define their own set of bones,

174
00:10:52,448 --> 00:10:54,029
and they can be shared quite easily

175
00:10:54,109 --> 00:10:56,231
because they are own files, so you can use it

176
00:10:56,431 --> 00:10:57,372
with different characters.

177
00:10:59,934 --> 00:11:02,817
In order to handle the layering, I added the input pose.

178
00:11:04,398 --> 00:11:06,800
It allows graph to read bones from the previous layer,

179
00:11:07,361 --> 00:11:09,243
mix it, and then...

180
00:11:10,779 --> 00:11:15,699
If that node is not active in the layer, it can skip the previous ones as optimization.

181
00:11:18,000 --> 00:11:23,501
So what it means that no state machines? It means no animation specific state machine.

182
00:11:24,361 --> 00:11:27,162
The main idea was that we combine it with the gameplay and AI.

183
00:11:28,062 --> 00:11:32,563
This would then reduce the possibility that these state machines would be mismatching.

184
00:11:33,763 --> 00:11:35,863
It was quite a big issue in Quantum Break.

185
00:11:36,563 --> 00:11:37,163
For example...

186
00:11:38,218 --> 00:11:41,099
Quantum break is quite famous with the infinite fallback.

187
00:11:43,620 --> 00:11:47,302
I spent at least one month trying to fix that one.

188
00:11:47,862 --> 00:11:50,364
And there's still some cases in a shipped game.

189
00:11:53,265 --> 00:11:54,806
So how we do this then?

190
00:11:56,667 --> 00:12:01,409
We have a higher level actions in a blend tree.

191
00:12:01,889 --> 00:12:04,410
We have a select node which chooses which action is active.

192
00:12:05,351 --> 00:12:07,332
Each of these actions then have a.

193
00:12:07,722 --> 00:12:10,584
transition node using the motion matching, which

194
00:12:10,664 --> 00:12:12,965
picks the best transition to come into this.

195
00:12:13,886 --> 00:12:17,728
Then there's the main sequence, which

196
00:12:17,768 --> 00:12:19,850
handles the switching then to the main loop.

197
00:12:20,910 --> 00:12:24,773
This could be a simple case, like the idle loop in here,

198
00:12:25,033 --> 00:12:27,615
or more complex, like motion matching running

199
00:12:27,775 --> 00:12:28,936
or traditional blend tree.

200
00:12:31,217 --> 00:12:33,259
But actually, these features are coming soon.

201
00:12:34,179 --> 00:12:34,700
We are not done.

202
00:12:37,622 --> 00:12:38,803
So we have to cover this somehow.

203
00:12:41,064 --> 00:12:42,765
Luckily, we have this expression language.

204
00:12:43,625 --> 00:12:46,286
We can use it to build a temporary state machine

205
00:12:46,986 --> 00:12:52,609
to handle all this transition, and then use timers to time

206
00:12:52,949 --> 00:12:54,650
when the transition is ending.

207
00:12:55,630 --> 00:12:59,392
This is not the nicest way, but at least we

208
00:13:00,132 --> 00:13:01,413
managed to continue the work.

209
00:13:05,650 --> 00:13:07,832
So meanwhile, we started working with this match node.

210
00:13:08,412 --> 00:13:11,854
It's same kind of database of animations as motion matching.

211
00:13:12,675 --> 00:13:15,457
In addition, it has target position and rotation

212
00:13:15,557 --> 00:13:16,377
coming from the code.

213
00:13:17,618 --> 00:13:19,980
It picks the best animation, a starting frame,

214
00:13:20,640 --> 00:13:22,181
using the same motion matching search.

215
00:13:23,802 --> 00:13:27,685
To actually reach target, it has built-in motion warping support.

216
00:13:28,625 --> 00:13:31,527
And it also allows to do the animation-driven movement.

217
00:13:34,203 --> 00:13:36,764
So to control this, we added some markup.

218
00:13:39,025 --> 00:13:42,607
The match range defines where the animation can be started.

219
00:13:43,668 --> 00:13:48,490
This allows to use different distances for where

220
00:13:48,510 --> 00:13:49,431
to start the animation.

221
00:13:50,912 --> 00:13:53,973
The warping is also controllable by this markup.

222
00:13:55,034 --> 00:13:56,695
So the position and rotation can be

223
00:13:56,755 --> 00:13:59,176
chosen that happens at certain frames.

224
00:14:03,768 --> 00:14:06,129
So in action, we have a character that is running.

225
00:14:07,749 --> 00:14:10,850
At this point, it decides that it wants to go in the cover.

226
00:14:13,431 --> 00:14:15,372
So code generates the target.

227
00:14:16,152 --> 00:14:18,913
The motion matching picks the result.

228
00:14:19,733 --> 00:14:21,954
At this case, it picked something

229
00:14:21,974 --> 00:14:23,715
in further in the animation.

230
00:14:24,195 --> 00:14:28,276
So the positional warping is 73% at this point.

231
00:14:29,577 --> 00:14:31,978
We scale this to actually handle the.

232
00:14:33,093 --> 00:14:33,854
the blending nicely.

233
00:14:35,374 --> 00:14:40,195
And to see this in full action, here's the clip.

234
00:14:44,435 --> 00:14:46,656
And as you can see, the result is 100%.

235
00:14:47,136 --> 00:14:49,396
So it's perfectly matching the target.

236
00:14:53,517 --> 00:14:55,757
At this point, I will switch to Ilkka.

237
00:14:56,517 --> 00:14:59,038
He will cover the more animation-specific things.

238
00:15:02,298 --> 00:15:02,518
Hello!

239
00:15:03,090 --> 00:15:06,051
I'm Jukka Kuusela, Principal Gameplay Animator at Remedy,

240
00:15:06,711 --> 00:15:09,293
and I was working on Control as the animation lead.

241
00:15:10,473 --> 00:15:13,014
And one of our first challenges for the E3 demo

242
00:15:13,174 --> 00:15:15,515
was how to make locomotion work with motion matching.

243
00:15:18,017 --> 00:15:19,937
Our motion matching was pretty much in a state

244
00:15:19,977 --> 00:15:21,458
where we really left it when starting

245
00:15:21,478 --> 00:15:22,739
to work on the new technology.

246
00:15:23,939 --> 00:15:26,280
And we were hitting the infamous 80% quality.

247
00:15:27,261 --> 00:15:29,562
We had all the normal motion matching issues.

248
00:15:30,062 --> 00:15:31,843
Start animations didn't always work.

249
00:15:32,422 --> 00:15:39,025
stops almost never worked. There was some sliding, even more when converted to code driven motion.

250
00:15:39,926 --> 00:15:44,848
Sometimes the character would just get stuck in a single pose and often it just looked like the

251
00:15:44,888 --> 00:15:51,232
character was running weirdly and then when you debug it turns out he's looping some single cycle

252
00:15:52,232 --> 00:15:59,196
from a random animation. And since all the coders were working on getting all the technology ready

253
00:15:59,336 --> 00:15:59,576
for it.

254
00:16:00,495 --> 00:16:03,696
E3, there was no time to improve upon motion matching itself.

255
00:16:04,356 --> 00:16:06,497
So we needed to ship the demo with what we had.

256
00:16:10,399 --> 00:16:13,300
And the way I started to approach motion matching

257
00:16:13,340 --> 00:16:15,981
was that I need to learn how to think like the algorithm.

258
00:16:16,962 --> 00:16:19,303
Once I understand how it works, then I

259
00:16:19,323 --> 00:16:21,904
can start to provide it with animations that work with it.

260
00:16:22,804 --> 00:16:24,945
And if something isn't working, I

261
00:16:24,985 --> 00:16:26,346
can deduce why that's happening.

262
00:16:28,487 --> 00:16:29,647
And often, it's pretty simple.

263
00:16:32,463 --> 00:16:35,124
If you provide motion matching with the kind of animations

264
00:16:35,224 --> 00:16:36,965
it's looking for, it's going to work well.

265
00:16:37,925 --> 00:16:39,406
So we needed to create animations

266
00:16:39,466 --> 00:16:43,548
that match the kind of paths what the game was requesting.

267
00:16:45,369 --> 00:16:47,049
So we created these kind of animations

268
00:16:47,109 --> 00:16:51,091
that had accurate speed and correct acceleration curves.

269
00:16:51,931 --> 00:16:53,592
And that, of course, eliminates sliding

270
00:16:54,332 --> 00:16:56,473
and also improves the way motion matching works.

271
00:16:58,374 --> 00:16:59,595
Here's a workflow example.

272
00:17:00,335 --> 00:17:02,236
So we have a script in MotionBuilder.

273
00:17:03,233 --> 00:17:05,334
And you could specify the movement parameters.

274
00:17:05,754 --> 00:17:08,535
So you would put the same values what the game was using here.

275
00:17:10,355 --> 00:17:13,616
And then we can define what is the direction we are coming

276
00:17:13,656 --> 00:17:17,117
from and where do we want to continue after this animation

277
00:17:17,337 --> 00:17:18,137
and at what speeds.

278
00:17:19,417 --> 00:17:20,598
And then when you run the script,

279
00:17:20,918 --> 00:17:22,938
it will generate movement for the trajectory.

280
00:17:24,338 --> 00:17:26,279
For example, here I generated 180 degree turn.

281
00:17:32,143 --> 00:17:33,684
Then we would bring in motion capture.

282
00:17:35,025 --> 00:17:38,226
Typically, it's quite far from the movement

283
00:17:38,266 --> 00:17:41,148
what we need for the game, because the game

284
00:17:41,188 --> 00:17:42,469
tries to be so responsive.

285
00:17:42,769 --> 00:17:46,510
But then with some editing, we could make it much better

286
00:17:47,331 --> 00:17:48,231
with the game movement.

287
00:17:52,133 --> 00:17:54,634
Now, of course, since we are doing this much editing

288
00:17:54,795 --> 00:17:57,576
on every animation, we couldn't pull off a large database

289
00:17:57,596 --> 00:18:01,238
of animations like is suggested in the earlier motion matching

290
00:18:01,258 --> 00:18:01,498
talks.

291
00:18:02,522 --> 00:18:05,183
So instead we chose to create a pretty traditional set

292
00:18:05,243 --> 00:18:09,004
of animations with start, stops, turns, and so on.

293
00:18:10,484 --> 00:18:12,225
And turns out that this kind of data set

294
00:18:12,345 --> 00:18:14,006
works just fine with motion matching.

295
00:18:14,746 --> 00:18:16,466
End result is more or less similar

296
00:18:16,566 --> 00:18:19,507
to putting the same animations into a state machine.

297
00:18:23,169 --> 00:18:24,549
And doing this kind of animations

298
00:18:24,589 --> 00:18:27,630
got us to a point where start animations were working,

299
00:18:27,670 --> 00:18:28,611
stops were working.

300
00:18:30,331 --> 00:18:31,232
There was less sliding.

301
00:18:31,755 --> 00:18:34,816
thanks to matching the movement between animation and code.

302
00:18:37,056 --> 00:18:39,317
We still have the problem that sometimes the character would

303
00:18:39,337 --> 00:18:40,737
get stuck in a single pose.

304
00:18:41,998 --> 00:18:42,818
It looks like this.

305
00:18:44,018 --> 00:18:45,338
And this started happening when we

306
00:18:45,378 --> 00:18:47,879
started adding turn animations to our database.

307
00:18:49,139 --> 00:18:50,499
And specifically, it happens when

308
00:18:50,519 --> 00:18:53,960
the player is trying to walk an arc, like in this video.

309
00:18:55,861 --> 00:18:57,701
And the reason this happens is that in order

310
00:18:57,721 --> 00:18:59,381
to walk a pattern like this, the player

311
00:18:59,421 --> 00:19:00,682
has to be continuously.

312
00:19:01,078 --> 00:19:03,238
changing the input in order to keep turning.

313
00:19:04,519 --> 00:19:07,520
But the prediction always assumes that we

314
00:19:07,560 --> 00:19:08,840
will keep the current input.

315
00:19:08,880 --> 00:19:11,721
So in practice, it's looking for the kind of data

316
00:19:11,741 --> 00:19:14,042
that begins with a turn, but then

317
00:19:14,082 --> 00:19:15,322
continues to move straight.

318
00:19:17,322 --> 00:19:19,543
And it starts finding this kind of animation

319
00:19:19,763 --> 00:19:21,544
in the end of the turning animations.

320
00:19:22,544 --> 00:19:24,164
And if the player keeps turning, it

321
00:19:24,204 --> 00:19:26,185
might find the same frame over and over again.

322
00:19:27,485 --> 00:19:29,386
And this could be a really hard problem to solve.

323
00:19:29,840 --> 00:19:31,221
But luckily, when you think about it,

324
00:19:32,021 --> 00:19:35,023
we don't actually want motion matching to ever jump

325
00:19:35,043 --> 00:19:36,324
to these frames directly.

326
00:19:37,424 --> 00:19:39,905
They only make sense as part of the turn animation.

327
00:19:41,626 --> 00:19:43,167
So we added a very simple feature

328
00:19:43,387 --> 00:19:45,388
where we could tag parts of the animation

329
00:19:45,728 --> 00:19:47,069
to be ignored by the search.

330
00:19:48,230 --> 00:19:49,910
For example, in this turn animation,

331
00:19:50,651 --> 00:19:53,672
we would leave maybe 10 frames near the beginning of the turn

332
00:19:54,093 --> 00:19:55,273
for motion matching to pick.

333
00:19:55,973 --> 00:19:59,575
And anything after that would be ignored from the search.

334
00:20:00,620 --> 00:20:03,822
These frames are still accessible for continuous playback.

335
00:20:04,302 --> 00:20:05,842
So if this animation starts playing,

336
00:20:05,942 --> 00:20:07,043
it can play all the way through.

337
00:20:10,504 --> 00:20:12,385
And this turned out to be a pretty powerful tool

338
00:20:12,405 --> 00:20:13,785
for controlling motion matching.

339
00:20:15,466 --> 00:20:17,547
One use case was fixing this problem

340
00:20:17,587 --> 00:20:18,867
where you get stuck in a pause.

341
00:20:19,788 --> 00:20:22,929
You could also use it a bit more for stylistic reasons.

342
00:20:22,989 --> 00:20:25,930
For example, if you want to play your stop animation

343
00:20:25,970 --> 00:20:29,472
so that player always plants at least one foot in the stop.

344
00:20:30,492 --> 00:20:33,794
then you can ignore the part where both feet are already

345
00:20:33,834 --> 00:20:36,055
planted to make sure we get enough of the stopping.

346
00:20:37,235 --> 00:20:40,537
And in a similar way, maybe you want your start animations

347
00:20:40,577 --> 00:20:42,017
to always start from the beginning.

348
00:20:43,118 --> 00:20:45,139
So you can ignore all the other frames

349
00:20:45,179 --> 00:20:46,659
to force it to play these animations

350
00:20:46,699 --> 00:20:47,520
from the first frame.

351
00:20:49,201 --> 00:20:51,942
Another good thing to ignore is tails after transitions.

352
00:20:52,802 --> 00:20:55,063
When building a locomotion set, typically what you get

353
00:20:55,223 --> 00:20:57,684
is lots of transitions or changes of directions

354
00:20:58,125 --> 00:20:59,725
that all lead into the same loops.

355
00:21:00,755 --> 00:21:03,076
So in practice, you have these pieces of a loop

356
00:21:03,297 --> 00:21:06,178
scattered all the way across your animation database.

357
00:21:07,719 --> 00:21:10,240
And this is actually why motion matching might start

358
00:21:10,260 --> 00:21:12,001
looping a small piece of animation,

359
00:21:12,021 --> 00:21:13,542
because instead of your main loop,

360
00:21:14,322 --> 00:21:17,684
it can find one of these loops after a transition

361
00:21:17,964 --> 00:21:19,665
and start looping a small part there.

362
00:21:20,805 --> 00:21:23,787
But by ignoring those frames and only letting

363
00:21:23,827 --> 00:21:26,568
them play when the transition is playing

364
00:21:27,588 --> 00:21:30,090
helped us get rid of the problem of getting stuck in a loop.

365
00:21:32,217 --> 00:21:34,919
Also, anything near the end of the animation.

366
00:21:35,579 --> 00:21:36,900
It doesn't really make sense to jump

367
00:21:36,920 --> 00:21:38,121
to the end of the animation

368
00:21:38,141 --> 00:21:39,902
because the animation is just gonna end

369
00:21:40,302 --> 00:21:41,523
and you have to jump somewhere else.

370
00:21:42,824 --> 00:21:44,845
So we were able to reduce some glitchiness

371
00:21:45,166 --> 00:21:47,748
by just ignoring the ends of animations.

372
00:21:49,389 --> 00:21:51,630
And of course, since what the ignore tag is doing,

373
00:21:51,670 --> 00:21:53,451
it's basically limiting the search space.

374
00:21:53,792 --> 00:21:55,513
It also works as an optimization.

375
00:21:56,374 --> 00:21:58,555
In control, we were able to cut our search space

376
00:21:59,015 --> 00:22:00,657
down to 20% of the original.

377
00:22:04,256 --> 00:22:07,180
So after adding the ignore tags to the animations,

378
00:22:07,901 --> 00:22:11,986
we got to a point where the most outstanding issues were fixed.

379
00:22:14,629 --> 00:22:17,152
When it comes to combining abilities with locomotion,

380
00:22:17,893 --> 00:22:19,836
we went for a pretty old school approach

381
00:22:19,936 --> 00:22:22,439
of blending upper body animations

382
00:22:22,499 --> 00:22:23,560
on top of locomotion.

383
00:22:25,667 --> 00:22:28,668
Since locomotion was always facing the direction where you are going,

384
00:22:29,408 --> 00:22:32,409
every animation needed to support all the possible directions.

385
00:22:32,429 --> 00:22:35,070
So we built game matrices out of our animations.

386
00:22:36,691 --> 00:22:39,051
And in some places where it had most impact,

387
00:22:39,612 --> 00:22:40,972
we added full-body animations.

388
00:22:43,833 --> 00:22:45,614
And with that, we got the Retreat demo done.

389
00:22:46,354 --> 00:22:47,534
We had a playable mission,

390
00:22:48,134 --> 00:22:51,255
and we were able to deliver all the intended gameplay features.

391
00:22:52,627 --> 00:22:55,410
We had a couple of set piece animations and intense cinematics

392
00:22:56,210 --> 00:22:59,233
and our first building shift, which is the transforming building.

393
00:23:00,134 --> 00:23:02,336
And all of this was running on a new technology.

394
00:23:03,997 --> 00:23:05,859
Here's a little glimpse into our E3 demo.

395
00:23:58,905 --> 00:24:02,066
Okay. So when building this demo,

396
00:24:03,086 --> 00:24:05,727
we were able to get a lot of important groundwork done.

397
00:24:06,568 --> 00:24:10,049
First of all, by defining what kind of a game we are making,

398
00:24:10,909 --> 00:24:13,990
but also laying foundations for our animation technology.

399
00:24:15,591 --> 00:24:17,772
And we were on track with the main goals we had.

400
00:24:18,472 --> 00:24:22,253
The game was responsive. We had good runtime performance.

401
00:24:23,094 --> 00:24:25,374
And iterating on animation systems was fast

402
00:24:26,836 --> 00:24:30,118
Any change you made could be hot loaded to the game almost instantly.

403
00:24:31,399 --> 00:24:34,481
And as a standard feature, the match node was a great success.

404
00:24:35,342 --> 00:24:38,684
It proved to be a pretty versatile tool and became our go-to option

405
00:24:38,984 --> 00:24:41,506
whenever we needed to do some one-off animations.

406
00:24:44,608 --> 00:24:47,290
Using motion matching was quite difficult for us.

407
00:24:48,050 --> 00:24:50,772
We spent a lot of time debugging it and trying to figure out

408
00:24:50,812 --> 00:24:52,093
why something wasn't working.

409
00:24:53,121 --> 00:24:56,123
And overall, didn't really yet have the level of control

410
00:24:56,143 --> 00:24:57,183
we needed over it.

411
00:24:58,584 --> 00:25:00,205
And we also had some visual issues.

412
00:25:00,905 --> 00:25:03,747
Most notably, we couldn't do straight locomotion

413
00:25:03,767 --> 00:25:04,867
without sliding yet.

414
00:25:08,049 --> 00:25:09,710
To debug motion matching, we already

415
00:25:09,750 --> 00:25:11,331
had some information available.

416
00:25:11,791 --> 00:25:14,692
So we could see what animation was playing, which frame,

417
00:25:15,313 --> 00:25:16,693
and what is the cost of this frame.

418
00:25:17,907 --> 00:25:19,788
And also if the animation was changed,

419
00:25:19,988 --> 00:25:21,649
we could see that what would have been the cost

420
00:25:21,689 --> 00:25:23,490
of continuing the previous animation.

421
00:25:24,751 --> 00:25:27,672
But that didn't really answer all of the questions we were having,

422
00:25:27,712 --> 00:25:30,734
such as, why was my animation interrupted?

423
00:25:31,514 --> 00:25:33,595
Or why isn't my animation getting picked?

424
00:25:35,736 --> 00:25:36,917
And to answer these questions,

425
00:25:36,977 --> 00:25:38,938
Ville created a new animation debugger.

426
00:25:40,118 --> 00:25:42,860
On the left, it shows all the animations in the database.

427
00:25:43,660 --> 00:25:46,681
And on the right, it shows a real time visualization of the costs.

428
00:25:47,678 --> 00:25:49,418
of the different frames in that animation.

429
00:25:50,699 --> 00:25:53,339
So every little bar on the right corresponds

430
00:25:53,379 --> 00:25:54,780
to one frame in the animation.

431
00:25:55,180 --> 00:25:58,260
And the height of the bar tells how much

432
00:25:58,301 --> 00:25:59,741
cost that frame is getting.

433
00:26:03,042 --> 00:26:06,182
It was also possible to hover a mouse on top of the frames

434
00:26:07,403 --> 00:26:09,343
to get more information about that frame,

435
00:26:09,383 --> 00:26:14,044
such as how is this frame tagged, what is its cost,

436
00:26:14,765 --> 00:26:17,285
and how do the different channels contribute to the cost.

437
00:26:20,952 --> 00:26:23,695
You could also tune the motion shader

438
00:26:24,395 --> 00:26:27,878
of the different calls of different channel live

439
00:26:28,099 --> 00:26:30,441
and see how the per frame calls react to this.

440
00:26:31,382 --> 00:26:33,484
So this way you can try to tune your shader

441
00:26:33,504 --> 00:26:38,328
so that motion matching starts picking your animation.

442
00:26:39,589 --> 00:26:42,672
And then you can unpause the game and keep playing

443
00:26:43,372 --> 00:26:45,915
and see how the game feels after the modifications you did.

444
00:26:49,333 --> 00:26:52,955
Finally, it was possible to draw some debug visualization,

445
00:26:53,495 --> 00:26:56,616
like the path points and the skeleton of the character.

446
00:26:57,757 --> 00:26:59,258
And then you could scrub backwards

447
00:26:59,638 --> 00:27:00,939
to a recording of the game,

448
00:27:01,679 --> 00:27:03,900
find the frame, maybe where a glitch happened,

449
00:27:04,981 --> 00:27:06,802
and then you can investigate, for example,

450
00:27:06,842 --> 00:27:09,543
that which animation did it choose

451
00:27:10,643 --> 00:27:12,264
and why did it not choose the animation

452
00:27:12,324 --> 00:27:13,165
I wanted it to choose.

453
00:27:19,114 --> 00:27:21,435
To get even more control over motion matching,

454
00:27:22,676 --> 00:27:25,738
we added a new kind of data-driven category tagging

455
00:27:25,778 --> 00:27:26,158
system.

456
00:27:27,659 --> 00:27:30,160
So it was possible to add custom category

457
00:27:30,240 --> 00:27:32,181
events on the animations.

458
00:27:32,481 --> 00:27:34,182
And then we could request motion matching

459
00:27:34,222 --> 00:27:35,983
to play animations from that category.

460
00:27:37,844 --> 00:27:40,145
And this was a soft category system in the sense

461
00:27:40,185 --> 00:27:43,967
that we could assign penalty for picking animations

462
00:27:44,007 --> 00:27:45,008
from a wrong category.

463
00:27:45,809 --> 00:27:47,771
So if you want to ensure that it's always

464
00:27:47,831 --> 00:27:50,133
paying animation from a specific category,

465
00:27:50,893 --> 00:27:54,856
we can give a really high category penalty, in which case

466
00:27:54,896 --> 00:27:56,618
it forces it to pick those animations.

467
00:27:57,238 --> 00:28:00,181
But it's also possible to give a lower penalty, in which case

468
00:28:00,241 --> 00:28:01,822
it will prioritize the animations

469
00:28:02,463 --> 00:28:03,503
in the correct category.

470
00:28:03,804 --> 00:28:05,745
But if there are no good matches there,

471
00:28:06,065 --> 00:28:07,987
it can then default to the other categories.

472
00:28:11,850 --> 00:28:14,032
The reason our straight flop motion was sliding

473
00:28:14,632 --> 00:28:15,033
was that.

474
00:28:15,837 --> 00:28:17,578
When strafing, you have to be able to move

475
00:28:17,599 --> 00:28:18,879
to every possible direction.

476
00:28:20,401 --> 00:28:23,022
But since we can only have a discrete number of directions

477
00:28:23,082 --> 00:28:26,065
in the animation database, then we

478
00:28:26,085 --> 00:28:28,086
get situations like the top picture here,

479
00:28:28,827 --> 00:28:31,248
where the orange line is showing where the code wants

480
00:28:31,268 --> 00:28:32,169
the character to go.

481
00:28:32,509 --> 00:28:35,131
And the yellow line is the best matching animation for that.

482
00:28:36,732 --> 00:28:39,514
And if you play that animation, but at the same time

483
00:28:39,554 --> 00:28:42,457
move along the orange path, the feet will start sliding.

484
00:28:44,582 --> 00:28:46,802
So to fix this, we made it so that the character gets

485
00:28:46,882 --> 00:28:51,543
rotated so that the animated path is aligned with the path

486
00:28:51,603 --> 00:28:52,683
the code is requesting.

487
00:28:53,063 --> 00:28:54,944
And then we apply a correction on the upper body

488
00:28:55,004 --> 00:28:56,284
to counter for this correction.

489
00:28:57,064 --> 00:29:00,845
So in practice, we are rotating the lower body of the character

490
00:29:02,165 --> 00:29:03,165
to align with the path.

491
00:29:06,826 --> 00:29:09,427
On the animation side, work was proceeding well.

492
00:29:09,447 --> 00:29:12,848
A lot of things that were causing friction early on,

493
00:29:13,008 --> 00:29:14,008
like missing features.

494
00:29:15,406 --> 00:29:18,568
were being fixed, and animators were getting experience

495
00:29:18,608 --> 00:29:19,448
on the technology.

496
00:29:20,809 --> 00:29:23,330
And one nice bonus we get from motion matching

497
00:29:23,370 --> 00:29:25,752
was that now that we had best practices how

498
00:29:25,772 --> 00:29:29,113
to create the animations, every animator on the gameplay team

499
00:29:29,153 --> 00:29:31,295
was able to create their own locomotion sets.

500
00:29:32,815 --> 00:29:35,517
On the player side, we still needed a lot of improvement.

501
00:29:37,218 --> 00:29:39,339
And the main problem was that when players were playing

502
00:29:39,379 --> 00:29:41,560
the game and running around.

503
00:29:41,957 --> 00:29:44,639
and combining abilities and shooting at the same time,

504
00:29:45,019 --> 00:29:46,200
things started getting messy.

505
00:29:47,061 --> 00:29:48,802
We get this awkward process of trying

506
00:29:48,822 --> 00:29:49,983
to shoot behind your back.

507
00:29:52,245 --> 00:29:55,647
Switching between the different abilities didn't look smooth.

508
00:29:56,728 --> 00:29:58,890
And some important animations got

509
00:29:58,930 --> 00:30:01,191
lost in the overall business of the animation.

510
00:30:03,613 --> 00:30:06,996
So what we wanted to do was reduce any kind of issues

511
00:30:07,056 --> 00:30:08,297
caused by changing input.

512
00:30:09,409 --> 00:30:12,311
and make the main actions what the player is performing stand out.

513
00:30:15,392 --> 00:30:17,714
We started from our worst offender, hip firing.

514
00:30:19,415 --> 00:30:21,656
We wanted to get rid of the stiff feeling we get

515
00:30:21,716 --> 00:30:24,317
when combining upper body and lower body animations,

516
00:30:25,258 --> 00:30:28,340
and instead create a full body locomotion set for hip firing.

517
00:30:29,520 --> 00:30:32,562
And we also wanted, now that we could make nice straight locomotion,

518
00:30:32,582 --> 00:30:34,003
we wanted to make a straightening set

519
00:30:35,063 --> 00:30:38,665
so that the character wouldn't have to turn around while moving.

520
00:30:39,558 --> 00:30:41,660
This will perform better on the changing input.

521
00:30:42,361 --> 00:30:44,723
And also, we didn't have to worry about seam handling.

522
00:30:48,986 --> 00:30:50,548
So this is what we were able to create.

523
00:30:52,910 --> 00:30:55,572
And indeed, it worked a lot better than our previous version.

524
00:31:00,216 --> 00:31:03,078
When transitioning between normal locomotion and heap firing,

525
00:31:03,599 --> 00:31:06,941
we did it so that we added the transitions to the motion databases.

526
00:31:08,016 --> 00:31:11,437
So every transition into some hipfire animation

527
00:31:11,517 --> 00:31:14,137
would go into the hipfire database,

528
00:31:14,337 --> 00:31:16,558
and transitions back to normal locomotion

529
00:31:16,578 --> 00:31:18,498
would go to the normal locomotion database.

530
00:31:20,058 --> 00:31:22,939
And to make sure every time we go into hipfiring,

531
00:31:23,539 --> 00:31:26,600
we play some transition, we use the category tags

532
00:31:26,880 --> 00:31:27,820
to force transitions.

533
00:31:29,080 --> 00:31:31,081
For coming back to normal locomotion,

534
00:31:31,541 --> 00:31:32,581
we didn't need to add them.

535
00:31:32,661 --> 00:31:35,622
Motion matching was speaking the right transitions automatically.

536
00:31:38,000 --> 00:31:44,982
And every transition was timed so that in two frames you get from your pose to being ready to shoot.

537
00:31:45,482 --> 00:31:49,784
To give this feeling that as soon as you hit the fire button, the player starts firing the gun.

538
00:31:53,005 --> 00:31:57,026
And while the hand is pointing to the right direction, we let the rest of the body turn a bit slower.

539
00:31:57,206 --> 00:31:59,007
Just to make it feel a bit more natural.

540
00:32:02,848 --> 00:32:05,389
Next up, Fender was launching objects through the air.

541
00:32:07,301 --> 00:32:09,583
It has similar issues as the hipfire.

542
00:32:10,864 --> 00:32:12,865
And since straight locomotion worked for hipfire,

543
00:32:13,146 --> 00:32:15,087
we also wanted to try that for launching.

544
00:32:16,568 --> 00:32:19,290
We were also getting feedback that launch

545
00:32:19,350 --> 00:32:21,732
needs to feel stronger, and we need

546
00:32:21,752 --> 00:32:23,694
to have a better connection between the object

547
00:32:23,954 --> 00:32:24,674
and the character.

548
00:32:25,915 --> 00:32:28,678
And I figured that by using straight locomotion,

549
00:32:28,718 --> 00:32:31,179
we can also get a much more controlled composition

550
00:32:31,199 --> 00:32:33,081
of the character and the object on the screen.

551
00:32:33,845 --> 00:32:36,787
So this way, we can plan for a better connection between them

552
00:32:37,028 --> 00:32:37,368
as well.

553
00:32:38,889 --> 00:32:40,470
Only problem was that we didn't really

554
00:32:40,510 --> 00:32:42,452
have time to build another locomotion set.

555
00:32:43,672 --> 00:32:46,634
So what we did instead was we took the hip fire locomotion,

556
00:32:47,675 --> 00:32:50,077
and for every animation, we would turn the character

557
00:32:50,397 --> 00:32:54,100
90 degrees, switch the pose, and this

558
00:32:54,140 --> 00:32:55,461
gave us the launch locomotion.

559
00:32:56,441 --> 00:32:58,503
Some animations went through a bit more polish,

560
00:32:58,943 --> 00:33:00,885
but the bulk of the work was done like this.

561
00:33:03,370 --> 00:33:07,233
And as a result, we got launching that feels a lot stronger,

562
00:33:07,874 --> 00:33:09,515
works better on the chasing input.

563
00:33:13,398 --> 00:33:15,620
And we were also able to improve the connection

564
00:33:15,660 --> 00:33:17,121
between the object and the character.

565
00:33:24,887 --> 00:33:27,029
For the animations where you launch the object,

566
00:33:27,069 --> 00:33:28,590
we have some full body animations,

567
00:33:29,631 --> 00:33:32,393
such as this one where you run forward and launch the object.

568
00:33:36,037 --> 00:33:38,398
For other directions, we would use the same animation,

569
00:33:38,899 --> 00:33:43,821
but blend it with locomotion, like this.

570
00:33:45,082 --> 00:33:47,083
And we chose to use hip fire locomotion

571
00:33:47,243 --> 00:33:50,244
as a base for this drawing, because that way we

572
00:33:50,284 --> 00:33:52,926
could get some body rotation into the animation as well.

573
00:33:54,426 --> 00:33:59,509
And nicely, it also allowed us to make use of the transitions

574
00:33:59,549 --> 00:34:00,710
we added for the hip fire.

575
00:34:02,629 --> 00:34:04,589
We were also able to blend seamlessly

576
00:34:04,629 --> 00:34:06,990
from full body animation to upper body animation,

577
00:34:07,910 --> 00:34:10,990
like here where the animation starts as full body,

578
00:34:11,371 --> 00:34:12,951
but when the player changes direction,

579
00:34:13,391 --> 00:34:15,531
it seamlessly blends into upper body animation.

580
00:34:21,352 --> 00:34:23,373
And what we got with all of these improvements

581
00:34:23,973 --> 00:34:26,433
was a character that can seamlessly

582
00:34:26,453 --> 00:34:28,273
switch between launching and hip firing

583
00:34:29,314 --> 00:34:32,074
while running around without creating animation issues.

584
00:34:42,737 --> 00:34:44,638
And yeah, in the end, we made it.

585
00:34:45,539 --> 00:34:47,420
We were able to ship the game in three years,

586
00:34:47,800 --> 00:34:49,181
including pre-production time.

587
00:34:50,182 --> 00:34:52,284
Clocking at 10 to 20 hours of gameplay,

588
00:34:52,304 --> 00:34:53,865
this was the biggest Remedy game yet.

589
00:34:55,046 --> 00:34:57,968
We had 11 different enemies, some fights

590
00:34:58,028 --> 00:35:01,171
against big bosses, which was a Remedy first,

591
00:35:01,391 --> 00:35:03,692
25 minutes of cinematics, and two and a half hours

592
00:35:03,732 --> 00:35:04,513
of conversations.

593
00:35:05,774 --> 00:35:07,555
And as you can see from the timeline below,

594
00:35:08,656 --> 00:35:11,498
since shipping the E3 demo, we had one year

595
00:35:11,518 --> 00:35:12,519
to complete the full game.

596
00:35:15,228 --> 00:35:17,369
And most importantly, now we have control

597
00:35:17,449 --> 00:35:20,009
over our animation technology, and we

598
00:35:20,049 --> 00:35:22,210
are in a good place to start building on top of this.

599
00:35:24,010 --> 00:35:24,330
All right.

600
00:35:26,351 --> 00:35:29,971
Now, it's been some time already since shipping control.

601
00:35:31,192 --> 00:35:33,012
So we also wanted to give a quick look

602
00:35:33,092 --> 00:35:35,972
at where we are going with our motion matching since then.

603
00:35:38,153 --> 00:35:40,933
In control, we proved that we can make a game feel responsive.

604
00:35:41,880 --> 00:35:43,661
And since then, the focus has been more

605
00:35:44,321 --> 00:35:46,522
on improving animation quality and making

606
00:35:46,602 --> 00:35:47,863
our workflows less tedious.

607
00:35:50,104 --> 00:35:51,965
And a big part of this has been adding support

608
00:35:51,985 --> 00:35:53,665
for animation-driven motion matching.

609
00:35:54,246 --> 00:35:57,107
This is to give the characters a more grounded, organic feel.

610
00:35:58,868 --> 00:36:01,529
And we have this available both for the player and NPCs.

611
00:36:03,230 --> 00:36:05,671
For player, of course, only using when it makes sense.

612
00:36:06,691 --> 00:36:09,952
We generally still like to use code-driven for the most part.

613
00:36:10,012 --> 00:36:10,773
But it's better off.

614
00:36:11,320 --> 00:36:14,001
Ever cases where we want to prioritize animation quality

615
00:36:14,061 --> 00:36:17,202
over controls, we can always switch to animation driven.

616
00:36:18,502 --> 00:36:21,063
For NPCs, we are animation driven by default,

617
00:36:21,863 --> 00:36:25,605
but still allowing designers to switch to code driven movement

618
00:36:25,805 --> 00:36:28,366
if they want to try different speeds for the enemies,

619
00:36:28,406 --> 00:36:29,026
for example.

620
00:36:31,307 --> 00:36:33,187
The way we do animation driven is

621
00:36:33,227 --> 00:36:36,368
that the characters are still moving along the exact path

622
00:36:36,388 --> 00:36:37,009
that is given.

623
00:36:37,629 --> 00:36:39,950
This is to avoid any kind of path finding issues.

624
00:36:41,095 --> 00:36:43,275
But the speed at which you move along this path

625
00:36:43,575 --> 00:36:44,595
comes from animation.

626
00:36:47,256 --> 00:36:50,277
And adding animation-driven locomotion here

627
00:36:50,537 --> 00:36:51,937
has changed our workflow a bit.

628
00:36:52,117 --> 00:36:55,998
So instead of first generating movement for the trajectory

629
00:36:56,138 --> 00:36:57,618
and then animating on top of that,

630
00:36:57,798 --> 00:37:00,639
we are now animating first and plotting the trajectory

631
00:37:00,799 --> 00:37:01,779
based on the animations.

632
00:37:06,640 --> 00:37:08,300
When using animation-driven movement,

633
00:37:08,380 --> 00:37:09,000
we can choose.

634
00:37:09,994 --> 00:37:12,195
either to use both rotation and position,

635
00:37:13,136 --> 00:37:15,917
or keep positional movement code-driven,

636
00:37:16,377 --> 00:37:18,218
but rotation animation-driven.

637
00:37:18,978 --> 00:37:20,819
And this is good for a playable character

638
00:37:20,859 --> 00:37:24,101
where we still get the benefits of code-driven movement,

639
00:37:25,561 --> 00:37:29,783
but we can reduce issues that come from code-driven rotation

640
00:37:30,164 --> 00:37:32,204
and the animated rotation being off sync.

641
00:37:35,678 --> 00:37:38,499
we are able to specify with animation tags

642
00:37:38,979 --> 00:37:41,260
on which frames do we want to be animation driven.

643
00:37:42,240 --> 00:37:45,302
So for example, if you want to make a 180 degree

644
00:37:45,362 --> 00:37:49,543
turn feel more grounded, we can make part of that turn

645
00:37:49,603 --> 00:37:52,144
animation driven to make it grounded

646
00:37:52,504 --> 00:37:54,965
and have a bit of control over the timing in the animation,

647
00:37:55,366 --> 00:37:57,746
but leave the rest of it still code driven.

648
00:38:01,308 --> 00:38:04,229
Now being animation driven only goes so far.

649
00:38:06,350 --> 00:38:09,152
Because even though the animation technically

650
00:38:09,292 --> 00:38:12,954
can now control the speed, motion matching still

651
00:38:13,014 --> 00:38:15,535
prioritizes animations that are matching

652
00:38:16,455 --> 00:38:17,816
the speed what it's requesting.

653
00:38:19,537 --> 00:38:22,218
And to counter this, we added the option

654
00:38:22,238 --> 00:38:26,320
to use distance instead of time to sample the animations.

655
00:38:26,540 --> 00:38:28,501
So for example, instead of asking,

656
00:38:29,502 --> 00:38:31,443
where am I going to be one second from now?

657
00:38:32,568 --> 00:38:36,470
you can ask where am I going to be after moving along the path for one meter.

658
00:38:37,911 --> 00:38:44,434
And this makes motion matching completely independent of the movement speed. So now

659
00:38:46,295 --> 00:38:52,478
we don't have to use speed as a factor in it. If we want we can do that. So one thing that

660
00:38:52,518 --> 00:38:58,001
works for example is that we can check against current speed and the speed after moving two meters.

661
00:38:59,622 --> 00:39:02,803
but still leave how the acceleration happens

662
00:39:02,843 --> 00:39:04,824
between these totally up for animation.

663
00:39:06,225 --> 00:39:08,746
Or we can completely leave speed out of the matching

664
00:39:09,326 --> 00:39:11,888
and use a category instead for picking animations

665
00:39:11,968 --> 00:39:13,969
in sets that match the speed we want.

666
00:39:16,030 --> 00:39:19,091
And this allows motion matching to work on animation sets

667
00:39:19,371 --> 00:39:22,293
where the speed is organically varying between animations.

668
00:39:26,295 --> 00:39:27,355
There was also one more.

669
00:39:28,005 --> 00:39:32,027
motion channel we had to add to make animation driven movement work.

670
00:39:33,107 --> 00:39:36,289
The problem was that when characters were strafing,

671
00:39:37,009 --> 00:39:40,310
now that the card was no longer rotating the character to face the right

672
00:39:40,350 --> 00:39:43,691
director, it was failing to find the correct animations.

673
00:39:44,832 --> 00:39:47,853
So we added this channel called trajectory direction relative to

674
00:39:47,893 --> 00:39:51,874
velocity. It basically tells you what is my

675
00:39:51,934 --> 00:39:53,935
rotation relative to movement direction.

676
00:39:55,208 --> 00:39:58,229
And this helped it pick correct straight directions

677
00:39:58,449 --> 00:39:59,789
under animation-driven movement.

678
00:40:03,570 --> 00:40:04,550
And that is all we have.

679
00:40:04,790 --> 00:40:05,690
Thank you for listening.

680
00:40:06,731 --> 00:40:07,731
I hope you enjoyed this.

681
00:40:08,531 --> 00:40:10,612
If you like how we work, go check out jobs

682
00:40:10,912 --> 00:40:11,852
at the Remedy website.

683
00:40:12,792 --> 00:40:14,132
And don't hesitate to get in touch

684
00:40:14,313 --> 00:40:15,393
if you want to discuss more.

