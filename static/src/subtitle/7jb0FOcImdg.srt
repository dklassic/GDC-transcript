1
00:00:05,870 --> 00:00:07,551
All right, it's about that time.

2
00:00:08,271 --> 00:00:09,631
If everybody could mute their phones

3
00:00:09,691 --> 00:00:11,971
and please fill out evaluations, that would be great.

4
00:00:13,332 --> 00:00:16,032
I'm gonna get started because in my dry runs,

5
00:00:16,092 --> 00:00:17,032
I filled the whole time,

6
00:00:17,192 --> 00:00:19,053
so I'm gonna try and finish early for questions.

7
00:00:21,533 --> 00:00:23,934
I'm Michael Stallone, I'm lead software engineer

8
00:00:24,034 --> 00:00:26,074
on the engine team at NetherRealm Studios.

9
00:00:26,694 --> 00:00:29,115
We ship Injustice and Mortal Kombat.

10
00:00:31,275 --> 00:00:32,455
What is this talk about?

11
00:00:33,528 --> 00:00:36,291
the how, why, and lessons learned

12
00:00:36,351 --> 00:00:37,872
from switching our network model

13
00:00:38,372 --> 00:00:40,914
from lockstep to rollback in a patch.

14
00:00:42,896 --> 00:00:44,017
This is not a rendering talk.

15
00:00:44,317 --> 00:00:46,398
I know it says eight frames and 16 milliseconds.

16
00:00:46,478 --> 00:00:47,599
I am not a rendering engineer.

17
00:00:47,739 --> 00:00:49,301
I will not be talking about the GPU.

18
00:00:50,161 --> 00:00:52,463
This is also not about the network transport layer.

19
00:00:52,943 --> 00:00:54,625
I won't really be talking about packet loss

20
00:00:54,665 --> 00:00:57,747
and how to cover it up, out of order packet delivery

21
00:00:57,767 --> 00:00:58,568
and that sort of thing.

22
00:00:58,808 --> 00:01:00,089
That's a thing that we're all doing.

23
00:01:00,289 --> 00:01:01,910
I'm just not gonna talk about that.

24
00:01:03,289 --> 00:01:05,972
We are not the first or only people to do rollback networking,

25
00:01:06,072 --> 00:01:07,993
but I haven't seen any GDC talks about it,

26
00:01:08,174 --> 00:01:09,054
so I thought I would give one.

27
00:01:10,115 --> 00:01:12,057
And this is mostly about our experience,

28
00:01:12,337 --> 00:01:13,959
the things that we went through when we did this.

29
00:01:14,819 --> 00:01:16,421
Maybe some of this is applicable to you guys.

30
00:01:19,363 --> 00:01:22,186
Just to give you guys a sense of the scope of what we were,

31
00:01:23,267 --> 00:01:25,109
the time we invested in shipping this thing

32
00:01:25,689 --> 00:01:28,411
was about four to 12 concurrent engineers for nine months.

33
00:01:29,336 --> 00:01:31,216
Roughly seven or eight man years of work

34
00:01:31,276 --> 00:01:33,637
for the initial release and then ongoing support

35
00:01:34,277 --> 00:01:36,378
is part-time work for about six engineers.

36
00:01:37,098 --> 00:01:39,458
Although by now all the engineers understand

37
00:01:39,498 --> 00:01:41,399
how this works and everybody gets to contribute.

38
00:01:42,419 --> 00:01:44,539
Our deadline was the Mortal Kombat X

39
00:01:44,600 --> 00:01:45,600
Game of the Year patch.

40
00:01:48,400 --> 00:01:49,821
Just some background terminology,

41
00:01:50,301 --> 00:01:51,601
things that I'm gonna end up saying

42
00:01:51,641 --> 00:01:52,721
throughout the presentation.

43
00:01:54,122 --> 00:01:55,842
Just wanted to make sure everybody was on the same page.

44
00:01:56,910 --> 00:01:58,511
RTT is round trip time.

45
00:01:58,791 --> 00:02:00,632
It's how long the packet takes to get from you

46
00:02:00,732 --> 00:02:02,653
to your opponent and back.

47
00:02:03,934 --> 00:02:07,617
Network latency is the one-way packet travel time just

48
00:02:07,657 --> 00:02:08,577
from you to your opponent.

49
00:02:09,678 --> 00:02:12,560
Net pause is the game is pausing due to having not

50
00:02:12,620 --> 00:02:13,981
received data in a while.

51
00:02:15,062 --> 00:02:16,883
And QoS is quality of service.

52
00:02:17,063 --> 00:02:18,464
It's a measurement of connection quality.

53
00:02:19,124 --> 00:02:20,965
And if you cross over the QoS boundary

54
00:02:21,085 --> 00:02:22,927
for some length of time, you'll be disconnected.

55
00:02:22,947 --> 00:02:25,088
A couple more.

56
00:02:25,999 --> 00:02:29,840
Input latency, this is basically what the entire talk is about.

57
00:02:30,660 --> 00:02:33,301
Injected delay between a button press and the engine response.

58
00:02:33,621 --> 00:02:35,482
You press a button, how long until the engine

59
00:02:35,622 --> 00:02:36,662
actually responds to it.

60
00:02:37,682 --> 00:02:40,683
The confirm frame, it is the most recent frame

61
00:02:41,203 --> 00:02:42,944
where you have input from all players.

62
00:02:44,564 --> 00:02:46,805
A desync, that is when both clients disagree

63
00:02:46,825 --> 00:02:48,605
about game state, leads to a disconnect.

64
00:02:49,606 --> 00:02:50,306
And dead reckoning.

65
00:02:50,849 --> 00:02:56,273
A super deep topic that is a very common networking model used in games all over the place and has been forever.

66
00:02:57,474 --> 00:03:00,076
I'm not going to talk about it a lot. There's a lot there.

67
00:03:00,436 --> 00:03:02,658
Rollback networking has similarities to Dead Reckoning.

68
00:03:04,139 --> 00:03:06,200
It's usually used in a server authoritative model.

69
00:03:07,101 --> 00:03:08,842
I'm not going to talk very much about it.

70
00:03:10,583 --> 00:03:14,847
Some basics. We are a hard 60Hz 1v1 fighting game.

71
00:03:15,467 --> 00:03:16,608
We do not drop frames.

72
00:03:18,862 --> 00:03:21,485
That leaves you 16.66 milliseconds per frame.

73
00:03:22,185 --> 00:03:23,706
That is the game tick.

74
00:03:23,747 --> 00:03:26,409
That is our render tick.

75
00:03:26,429 --> 00:03:27,710
Everybody is running at 60 hertz.

76
00:03:27,770 --> 00:03:28,931
Nobody's running at a reduced rate.

77
00:03:29,752 --> 00:03:31,013
We are a peer-to-peer game.

78
00:03:31,093 --> 00:03:34,196
This is core to this talk and our decision

79
00:03:34,236 --> 00:03:35,136
on the networking model.

80
00:03:36,578 --> 00:03:40,001
If you're server authoritative, your mileage may vary here.

81
00:03:41,087 --> 00:03:42,688
A network packet is sent once per frame.

82
00:03:43,109 --> 00:03:45,131
I only call that out because we have not unhooked

83
00:03:45,151 --> 00:03:46,553
our networking from our main thread.

84
00:03:46,973 --> 00:03:48,635
It is simply serviced at the top of the frame.

85
00:03:48,995 --> 00:03:50,036
We may unhook it next game.

86
00:03:50,897 --> 00:03:52,559
Standard networking tricks to hide packet loss.

87
00:03:52,599 --> 00:03:53,420
This is what I said before.

88
00:03:55,082 --> 00:03:56,763
There are plenty of people who make a career of this,

89
00:03:57,264 --> 00:03:58,986
handling packet loss, out-of-order packets,

90
00:03:59,026 --> 00:04:00,067
and all of that sort of stuff.

91
00:04:00,868 --> 00:04:01,889
I'm not gonna be talking about it,

92
00:04:02,970 --> 00:04:03,751
even though I keep saying it.

93
00:04:05,857 --> 00:04:06,517
Determinism.

94
00:04:08,157 --> 00:04:09,558
This is hugely important for us.

95
00:04:10,178 --> 00:04:12,378
I'm not sure how hugely important it is for everybody,

96
00:04:12,758 --> 00:04:14,119
but the vast majority of our game

97
00:04:14,179 --> 00:04:15,579
is bit for bit deterministic.

98
00:04:15,639 --> 00:04:18,160
We fence post many values at various points in the tick.

99
00:04:18,740 --> 00:04:20,140
Any divergence is a desync.

100
00:04:20,660 --> 00:04:22,501
This is the foundation that everything is built on.

101
00:04:23,081 --> 00:04:24,661
That means that when we run in development,

102
00:04:25,202 --> 00:04:28,122
every single bit of our thousands of fence posts

103
00:04:28,142 --> 00:04:30,063
in the game is exactly bit for bit identical.

104
00:04:30,523 --> 00:04:32,103
That means if you're doing floating point math,

105
00:04:32,123 --> 00:04:33,104
you're doing it in the right order

106
00:04:33,244 --> 00:04:34,664
on every machine, every time.

107
00:04:35,731 --> 00:04:41,534
That has a lot of implications, but the important part there is the game will play out exactly

108
00:04:41,574 --> 00:04:45,977
the same every single time, provided you've seeded your random stuff in the exact same

109
00:04:45,997 --> 00:04:46,117
way.

110
00:04:48,678 --> 00:04:49,259
The problem.

111
00:04:49,479 --> 00:04:51,200
The whole reason we switched our networking model.

112
00:04:52,020 --> 00:04:55,762
Our online gameplay suffered from inconsistent and high input latency.

113
00:04:56,283 --> 00:04:57,503
The players were not happy.

114
00:04:58,244 --> 00:04:59,144
We are a fighting game.

115
00:04:59,525 --> 00:05:02,666
That means that responsiveness is extremely important.

116
00:05:03,227 --> 00:05:05,288
and predictability is extremely important.

117
00:05:05,348 --> 00:05:08,470
People will execute a combo, they'll input a button

118
00:05:09,051 --> 00:05:11,432
or a string of button presses with a given cadence

119
00:05:11,472 --> 00:05:13,274
and expect that it works every single time.

120
00:05:14,114 --> 00:05:16,276
That's not how it worked prior to us

121
00:05:16,476 --> 00:05:17,497
switching network models.

122
00:05:18,337 --> 00:05:19,898
We had dynamic input latency,

123
00:05:20,479 --> 00:05:22,320
meaning that depending on your network latency

124
00:05:22,340 --> 00:05:23,361
that you were experiencing,

125
00:05:23,661 --> 00:05:25,442
the cadence of your button presses would change.

126
00:05:26,863 --> 00:05:27,864
This is bad for the players.

127
00:05:31,159 --> 00:05:33,320
I'm not going to talk about a ton of things on here.

128
00:05:33,360 --> 00:05:35,080
This is just an overall latency diagram.

129
00:05:35,200 --> 00:05:37,801
You press a button, the hardware injects latency,

130
00:05:37,841 --> 00:05:39,441
the operating system injects latency,

131
00:05:39,861 --> 00:05:42,061
we inject latency, input latency,

132
00:05:42,682 --> 00:05:46,062
and then we have one frame at 60 hertz

133
00:05:46,122 --> 00:05:49,503
for the game sim, our render thread, and our GPU present.

134
00:05:50,143 --> 00:05:51,964
So that's like an overall latency diagram.

135
00:05:54,344 --> 00:05:54,784
Lockstep.

136
00:05:55,444 --> 00:05:58,285
This is what we used previously before we switched over.

137
00:05:58,725 --> 00:05:59,445
This is very simple.

138
00:06:00,494 --> 00:06:02,096
but it's what we use for years.

139
00:06:02,816 --> 00:06:04,177
We only send gamepad data.

140
00:06:04,257 --> 00:06:06,059
We are not sending any game state at all.

141
00:06:06,780 --> 00:06:08,681
The game will not proceed until it has input

142
00:06:08,701 --> 00:06:10,503
from the remote player for the current frame.

143
00:06:11,243 --> 00:06:12,485
Input is delayed by enough frames

144
00:06:12,505 --> 00:06:13,706
to cover the network latency.

145
00:06:14,827 --> 00:06:16,908
Little diagram to show you how that works.

146
00:06:18,790 --> 00:06:20,732
Future frames are coming in from the right side there.

147
00:06:21,793 --> 00:06:25,115
And there's just frame by frame for each guy.

148
00:06:26,080 --> 00:06:28,161
On frame one, we get a pad input.

149
00:06:28,361 --> 00:06:30,682
Somebody's pressing X for frame eight.

150
00:06:30,782 --> 00:06:31,963
This is what I mean by lockstep.

151
00:06:32,003 --> 00:06:34,264
This is what I mean by input latency.

152
00:06:34,604 --> 00:06:36,485
That button that was pressed on frame one

153
00:06:36,505 --> 00:06:37,906
will be executed on frame eight.

154
00:06:40,227 --> 00:06:41,988
So if you look at Batman and Superman,

155
00:06:42,008 --> 00:06:43,069
they're not moving, right?

156
00:06:43,149 --> 00:06:44,009
They're just standing there

157
00:06:44,189 --> 00:06:46,010
because even though you press the button,

158
00:06:46,451 --> 00:06:47,992
we won't respond for seven more frames.

159
00:06:48,772 --> 00:06:50,913
Player two received this input on frame six.

160
00:06:51,593 --> 00:06:52,654
Still nobody moving.

161
00:06:53,274 --> 00:06:54,795
They will respond to this on frame eight.

162
00:06:56,614 --> 00:06:57,695
And they'll do it at the same time.

163
00:06:57,715 --> 00:07:00,157
The effect is pretty subtle, but Superman started to punch.

164
00:07:02,039 --> 00:07:03,040
So that's lockstep.

165
00:07:03,100 --> 00:07:06,002
That was lockstep with a seven frame input delay.

166
00:07:07,103 --> 00:07:09,906
Because we had dynamic input latency, that could vary.

167
00:07:09,946 --> 00:07:12,027
It could be five frames, it could be 15 frames,

168
00:07:12,067 --> 00:07:14,029
depending on the network latency you're experiencing.

169
00:07:15,290 --> 00:07:16,391
15 frames is extreme.

170
00:07:22,136 --> 00:07:22,536
The present.

171
00:07:23,068 --> 00:07:23,969
This is where we are today.

172
00:07:24,689 --> 00:07:27,011
Mortal Kombat X and Injustice 2 have three frames

173
00:07:27,071 --> 00:07:29,894
of input latency and support up to 10 frames,

174
00:07:30,334 --> 00:07:32,196
333 milliseconds of network latency

175
00:07:32,256 --> 00:07:33,056
before pausing the game.

176
00:07:33,777 --> 00:07:35,098
The online experience is much improved

177
00:07:35,118 --> 00:07:35,959
and the players are happy.

178
00:07:36,860 --> 00:07:39,782
So it's three fixed frames of input latency.

179
00:07:39,862 --> 00:07:41,764
We do that to help cover network latency.

180
00:07:42,304 --> 00:07:44,346
It's, you know, if I haven't made it clear,

181
00:07:44,366 --> 00:07:46,448
it is constant, which means it is completely predictable

182
00:07:46,468 --> 00:07:46,968
to the players.

183
00:07:47,949 --> 00:07:49,450
And our previous title would fluctuate

184
00:07:49,470 --> 00:07:50,571
between five and 20 frames.

185
00:07:52,197 --> 00:07:54,838
The next question would be why 10 frames?

186
00:07:56,159 --> 00:07:57,199
This is a latency curve.

187
00:07:57,760 --> 00:08:00,801
This is the graph of a percentage of matches

188
00:08:00,981 --> 00:08:02,622
played at a certain RTT bucket.

189
00:08:03,422 --> 00:08:05,563
So on the left, the numbers or the labels

190
00:08:05,603 --> 00:08:06,283
are very, very small.

191
00:08:06,683 --> 00:08:08,104
But on the left, you have an extremely low

192
00:08:08,124 --> 00:08:08,824
latency connection.

193
00:08:08,864 --> 00:08:10,965
On the right, you have 300 milliseconds plus.

194
00:08:11,606 --> 00:08:13,526
You can see that the vast majority of matches

195
00:08:13,586 --> 00:08:16,448
are played under 300 milliseconds RTT.

196
00:08:17,468 --> 00:08:19,349
What's not actually shown here is there could be

197
00:08:19,389 --> 00:08:21,190
even one more bucket there for like,

198
00:08:22,232 --> 00:08:25,552
300 to 333, and we capture that bucket as well.

199
00:08:26,293 --> 00:08:29,093
By supporting 333 milliseconds round trip time,

200
00:08:29,533 --> 00:08:32,394
we support over 99% of the matches that are being played.

201
00:08:35,915 --> 00:08:38,475
Quick definition or background on what rollback is,

202
00:08:38,695 --> 00:08:40,476
we only send pad data, that's still true.

203
00:08:40,836 --> 00:08:41,676
I keep calling that out

204
00:08:41,736 --> 00:08:43,216
because a lot of dead reckoning solutions

205
00:08:43,276 --> 00:08:44,997
will send a lot of game state back and forth.

206
00:08:45,817 --> 00:08:47,157
We don't, we just send pad data.

207
00:08:48,110 --> 00:08:50,031
The game will proceed without remote input,

208
00:08:50,431 --> 00:08:51,792
and when remote input is received,

209
00:08:51,832 --> 00:08:53,713
we will roll back and then simulate forward.

210
00:08:55,233 --> 00:08:57,294
Same diagram as before for lockstep,

211
00:08:57,834 --> 00:08:59,475
this time for rollback.

212
00:09:03,076 --> 00:09:04,817
Pretty please switch slides, all right.

213
00:09:05,977 --> 00:09:07,978
So yeah, this is the same thing,

214
00:09:08,098 --> 00:09:09,499
but with rollback networking.

215
00:09:09,699 --> 00:09:12,060
So on frame one, input is generated for frame four.

216
00:09:13,842 --> 00:09:15,443
The idea here is that we're seeing this

217
00:09:15,463 --> 00:09:17,864
with the same network latency that I

218
00:09:17,904 --> 00:09:18,925
showed you with the lock step.

219
00:09:19,045 --> 00:09:22,007
So the packet's coming across for frame 4.

220
00:09:22,067 --> 00:09:23,128
Player 1 already hit frame 4.

221
00:09:23,388 --> 00:09:24,849
So his Superman started punching.

222
00:09:25,570 --> 00:09:26,811
But player 2 doesn't know that yet.

223
00:09:27,111 --> 00:09:27,851
So he's not moving.

224
00:09:29,052 --> 00:09:31,114
By the time that gets received on player 2's end,

225
00:09:31,154 --> 00:09:32,114
it's frame 6 already.

226
00:09:32,875 --> 00:09:33,936
He's two frames behind.

227
00:09:34,236 --> 00:09:35,757
He just got data for frame 4.

228
00:09:36,297 --> 00:09:38,639
So frame 4 here is our confirmed frame.

229
00:09:38,659 --> 00:09:40,420
We have input from both players for frame 4.

230
00:09:42,118 --> 00:09:43,459
So we take that back to frame four.

231
00:09:44,039 --> 00:09:45,020
We would call that a rollback.

232
00:09:45,100 --> 00:09:47,262
That's a rollback or a restore to previous state.

233
00:09:48,363 --> 00:09:51,025
We'll simulate frame four, we'll simulate frame five,

234
00:09:51,406 --> 00:09:52,947
and we will simulate our real tick

235
00:09:53,027 --> 00:09:54,929
or our render tick frame six.

236
00:09:55,549 --> 00:09:57,951
We will do all of that within one frame's worth of time.

237
00:09:58,252 --> 00:10:00,854
That's 16.66 milliseconds, we'll simulate all those frames.

238
00:10:02,535 --> 00:10:04,337
Because we're supporting seven frames of rollback,

239
00:10:04,917 --> 00:10:07,139
that's eight total frames simulated in 16.66 milliseconds

240
00:10:07,219 --> 00:10:07,840
in our worst case.

241
00:10:11,321 --> 00:10:13,342
So both guys are doing the exact same thing.

242
00:10:13,382 --> 00:10:14,763
Superman is punching on both screens,

243
00:10:15,503 --> 00:10:17,004
and off they go, they're synced up.

244
00:10:19,926 --> 00:10:21,807
Little comparison between rollback and lockstep.

245
00:10:21,867 --> 00:10:23,888
Again, dead reckoning is another super common approach.

246
00:10:24,668 --> 00:10:26,229
Just don't have time to talk about all of them.

247
00:10:27,550 --> 00:10:29,091
Lockstep is very, very simple.

248
00:10:29,591 --> 00:10:30,772
Because input is delayed,

249
00:10:30,852 --> 00:10:32,653
you really don't have to do anything.

250
00:10:32,893 --> 00:10:34,574
You just play your game as normal.

251
00:10:34,714 --> 00:10:35,634
Every frame will start.

252
00:10:35,674 --> 00:10:37,175
You'll have input for every player.

253
00:10:38,296 --> 00:10:38,696
It's simple.

254
00:10:39,941 --> 00:10:41,322
It's visually smooth as well.

255
00:10:41,863 --> 00:10:44,645
You've delayed things so much that there's no hitch

256
00:10:44,705 --> 00:10:45,686
when you receive input.

257
00:10:45,706 --> 00:10:46,667
You don't have to go back.

258
00:10:46,687 --> 00:10:47,928
You won't glitch anybody's pose.

259
00:10:48,489 --> 00:10:50,190
Online and offline play looks identical.

260
00:10:51,331 --> 00:10:52,793
It is performant because you don't

261
00:10:52,833 --> 00:10:53,814
have to perform rollbacks.

262
00:10:53,974 --> 00:10:56,716
We had massive CPU overhead when we were performing

263
00:10:56,756 --> 00:10:57,897
lockstep networking.

264
00:10:59,159 --> 00:11:00,199
That's a very good thing.

265
00:11:00,260 --> 00:11:03,102
If you're not latency sensitive, lockstep is great.

266
00:11:04,423 --> 00:11:04,844
Robust.

267
00:11:05,852 --> 00:11:08,393
They're both robust, which seems a little silly to show you

268
00:11:08,493 --> 00:11:09,333
on the slide here.

269
00:11:09,854 --> 00:11:12,675
But our experience in the past with peer-to-peer dead

270
00:11:12,715 --> 00:11:15,697
reckoning solutions was that they weren't wildly robust.

271
00:11:16,597 --> 00:11:18,698
They were like, it was just constant whack-a-mole fixing

272
00:11:18,738 --> 00:11:19,178
problems.

273
00:11:19,238 --> 00:11:21,420
So once you've matured your rollback system

274
00:11:21,460 --> 00:11:23,841
and your whole engine is converted over,

275
00:11:23,961 --> 00:11:25,882
it's a very robust solution, same as lockstep.

276
00:11:26,402 --> 00:11:28,983
Low bandwidth, they're both sending only pad data.

277
00:11:29,243 --> 00:11:30,964
You don't have to worry about sending game state.

278
00:11:31,084 --> 00:11:32,525
So that's fantastic.

279
00:11:33,516 --> 00:11:35,538
Lockstep is not responsive at all.

280
00:11:36,239 --> 00:11:37,540
Rollback is responsive.

281
00:11:37,580 --> 00:11:38,781
It's the whole reason we switched.

282
00:11:39,502 --> 00:11:43,085
And this last line is not self-explanatory.

283
00:11:43,625 --> 00:11:44,586
Single frame latency.

284
00:11:45,307 --> 00:11:47,809
What this means is when we were in the lockstep approach,

285
00:11:47,930 --> 00:11:49,711
I said that your dynamic input latency

286
00:11:49,731 --> 00:11:51,072
could vary between five and 20 frames.

287
00:11:52,712 --> 00:11:55,233
If we waited for one of your frames to

288
00:11:56,634 --> 00:11:58,154
bog over the network or be delivered late,

289
00:11:58,194 --> 00:11:59,375
we would have to pause the game.

290
00:11:59,875 --> 00:12:02,656
In order to not do that, we would keep an eye on your RTT

291
00:12:02,776 --> 00:12:04,216
over the past several seconds,

292
00:12:04,677 --> 00:12:06,277
and we would change the amount of input latency

293
00:12:06,337 --> 00:12:07,298
we were experiencing.

294
00:12:07,758 --> 00:12:09,779
So you would basically rubber band your input latency

295
00:12:09,879 --> 00:12:10,859
over the course of a fight,

296
00:12:11,179 --> 00:12:12,720
which meant that a spike in your latency

297
00:12:12,740 --> 00:12:14,540
would actually persist for quite a while,

298
00:12:14,940 --> 00:12:15,961
impacting your input.

299
00:12:16,201 --> 00:12:17,461
That's not the case with rollbacks.

300
00:12:18,642 --> 00:12:21,463
For every packet sent, that is the only latency that matters.

301
00:12:21,743 --> 00:12:24,205
You will essentially, like if you did spike for one frame,

302
00:12:24,565 --> 00:12:26,966
drop enough packets that you bogged,

303
00:12:27,326 --> 00:12:28,347
you would immediately recover,

304
00:12:28,527 --> 00:12:30,307
assuming the packets started coming in again.

305
00:12:31,288 --> 00:12:32,809
Very relevant for wireless connections.

306
00:12:34,289 --> 00:12:36,610
What do we do first when we bit this thing off?

307
00:12:37,671 --> 00:12:40,152
The first goal was to get an idle character rolling back.

308
00:12:40,492 --> 00:12:42,413
Just two guys standing on a fight line doing nothing.

309
00:12:43,409 --> 00:12:46,310
We turned off almost everything, even essential things

310
00:12:46,350 --> 00:12:47,690
that we would have to use for shipping.

311
00:12:47,750 --> 00:12:50,851
We would turn off physics and IK and particles

312
00:12:50,971 --> 00:12:53,011
and the entirety of online, actually,

313
00:12:53,031 --> 00:12:54,452
which sounds kind of nuts,

314
00:12:54,572 --> 00:12:56,612
but we wanted to make it work locally

315
00:12:56,652 --> 00:12:57,733
before we hooked it up online.

316
00:12:59,033 --> 00:13:00,413
So we started doing serialization

317
00:13:00,513 --> 00:13:03,374
because we knew that was going to be the tentpole of this.

318
00:13:03,834 --> 00:13:05,794
Basically, you have to save every single frame

319
00:13:05,955 --> 00:13:07,735
and you have to be able to restore to those frames

320
00:13:07,775 --> 00:13:08,535
in order to roll back.

321
00:13:09,521 --> 00:13:12,422
And we had a debug mode called set rollback frames.

322
00:13:13,243 --> 00:13:16,844
I say seven because that was our decided number of rollback

323
00:13:16,864 --> 00:13:17,685
frames we would support.

324
00:13:19,245 --> 00:13:21,366
I guess as a point of clarity, I keep saying seven.

325
00:13:21,466 --> 00:13:23,467
Earlier I said we support 10 frames of latency.

326
00:13:23,927 --> 00:13:25,988
That's the three frames of static input latency

327
00:13:26,328 --> 00:13:28,469
plus the seven frames of rollback, which

328
00:13:28,509 --> 00:13:29,970
gets us the total of 10 frames.

329
00:13:31,020 --> 00:13:34,020
So this set rollback frame debug mode

330
00:13:34,180 --> 00:13:36,101
was something that we ran with constantly.

331
00:13:36,261 --> 00:13:36,941
Everybody did it.

332
00:13:37,641 --> 00:13:40,262
It was like the number one debug mode

333
00:13:40,282 --> 00:13:42,623
that we used from day one all the way till today.

334
00:13:42,683 --> 00:13:43,323
We still use it.

335
00:13:46,924 --> 00:13:47,304
I'm sorry.

336
00:13:47,344 --> 00:13:48,944
I really don't think I explained really

337
00:13:48,984 --> 00:13:49,584
what was going on there.

338
00:13:49,604 --> 00:13:52,305
The set rollback frame 7 is every single frame of the game

339
00:13:52,485 --> 00:13:54,865
will roll back seven frames and simulate forward.

340
00:13:55,506 --> 00:13:58,026
In the case of no divergence or no remote input

341
00:13:58,086 --> 00:13:58,706
from your opponent.

342
00:13:59,635 --> 00:14:00,776
Visually, this does nothing.

343
00:14:00,976 --> 00:14:02,436
Like, it looks like nothing has happened,

344
00:14:02,516 --> 00:14:04,157
even though you rewound seven frames

345
00:14:04,197 --> 00:14:05,297
and played them all back forward.

346
00:14:06,558 --> 00:14:07,778
So that's how you knew it was working,

347
00:14:08,018 --> 00:14:11,300
was nothing was happening and that was success.

348
00:14:12,660 --> 00:14:14,381
So a quick breakdown of the tick timeline.

349
00:14:14,401 --> 00:14:16,141
This is a diagram I'll use later in the talk.

350
00:14:17,962 --> 00:14:19,343
All I really want to call out here is

351
00:14:19,383 --> 00:14:21,003
we service our input and our online,

352
00:14:21,183 --> 00:14:23,124
like the network stuff, right up at the front of the frame.

353
00:14:23,324 --> 00:14:24,425
It's basically a fixed cost.

354
00:14:25,408 --> 00:14:27,349
A restore is restore to previous state.

355
00:14:27,669 --> 00:14:29,210
It's one of the first things we do in the frame

356
00:14:29,250 --> 00:14:31,231
in the event that you've detected that you have to roll back.

357
00:14:31,991 --> 00:14:34,373
The simulated frames are the ones that you simulate forward

358
00:14:35,033 --> 00:14:36,734
with a stripped down version of the game

359
00:14:37,274 --> 00:14:38,415
to get back to the current tick.

360
00:14:38,475 --> 00:14:40,596
And then we perform the real render at the end,

361
00:14:40,616 --> 00:14:42,517
the full tick with all procedural systems

362
00:14:42,597 --> 00:14:44,578
and non-gameplay affecting things.

363
00:14:44,998 --> 00:14:46,279
This is all one tick, right?

364
00:14:46,459 --> 00:14:47,419
If we're doing our job right,

365
00:14:47,780 --> 00:14:50,221
this takes 16.66 milliseconds and no more.

366
00:14:54,281 --> 00:14:58,805
So one of the things that I talked about was that we did serialization first.

367
00:14:59,486 --> 00:15:04,791
Serialization is a tentpole of this. I'm not going to talk about it a ton, but here's some.

368
00:15:05,652 --> 00:15:11,317
It's the rollback framework. It was a ring buffer sized to the rollback window, meaning it's a ring buffer with one entry per frame.

369
00:15:12,679 --> 00:15:15,503
We support 7 frames, so it's a 7 entry ring buffer.

370
00:15:16,164 --> 00:15:17,686
There's an object serialization interface.

371
00:15:17,706 --> 00:15:18,868
You can see it down on the bottom right.

372
00:15:18,888 --> 00:15:19,849
It's probably a little bit small.

373
00:15:21,071 --> 00:15:24,115
Just a basic virtual interface for some of the various edges

374
00:15:24,155 --> 00:15:27,720
that we have during serialization, saving, and restoration.

375
00:15:29,142 --> 00:15:31,422
There will be entries for object creation and destruction.

376
00:15:31,682 --> 00:15:33,303
This is a huge problem.

377
00:15:33,543 --> 00:15:35,063
If you go the rollback route,

378
00:15:35,103 --> 00:15:36,984
you have to handle rolling back

379
00:15:37,044 --> 00:15:38,464
to before an object was created

380
00:15:38,945 --> 00:15:41,045
and rolling back across the destruction edge as well.

381
00:15:41,785 --> 00:15:43,666
Done naively, this is going to create

382
00:15:43,706 --> 00:15:45,286
and destroy objects all the time.

383
00:15:46,627 --> 00:15:47,867
We only save mutable data.

384
00:15:48,107 --> 00:15:49,048
If something doesn't change,

385
00:15:49,088 --> 00:15:50,488
don't save it if at all possible.

386
00:15:51,068 --> 00:15:53,889
And it is not Delta-based, although maybe it should be.

387
00:15:57,144 --> 00:15:58,624
Restoration is the opposite edge.

388
00:15:58,685 --> 00:15:59,905
This is when we have to roll back

389
00:16:00,065 --> 00:16:01,366
and restore to previous state.

390
00:16:02,127 --> 00:16:03,047
We did this in parallel.

391
00:16:04,008 --> 00:16:04,909
Don't use shared pointer.

392
00:16:04,949 --> 00:16:09,011
Shared ownership for serialization purposes is really bad.

393
00:16:09,271 --> 00:16:11,753
Basically, you would have to have two concepts of ownership,

394
00:16:12,173 --> 00:16:15,355
both the shared ownership, but then a singular owner

395
00:16:15,936 --> 00:16:17,957
that is in charge of serialization.

396
00:16:18,037 --> 00:16:19,538
So we moved away from that.

397
00:16:19,598 --> 00:16:21,419
We just heavily moved towards using unique pointer

398
00:16:21,439 --> 00:16:22,040
for that sort of thing.

399
00:16:23,516 --> 00:16:26,537
The serialization restore edge was a simple load balancing

400
00:16:26,577 --> 00:16:27,377
and priority scheme.

401
00:16:27,397 --> 00:16:29,238
It was a large perf win compared

402
00:16:29,258 --> 00:16:30,298
to the single-threaded version.

403
00:16:30,378 --> 00:16:33,219
So at the very start of this approach,

404
00:16:33,940 --> 00:16:35,980
we were simply doing single-threaded restoration,

405
00:16:36,601 --> 00:16:38,041
and it was a small amount of work

406
00:16:38,061 --> 00:16:39,382
because we didn't know the full set

407
00:16:39,422 --> 00:16:40,762
of everything that we needed to restore,

408
00:16:41,102 --> 00:16:42,683
and it took about 1.3 milliseconds.

409
00:16:43,943 --> 00:16:44,824
At the end of it, I'm sorry, 2.7.

410
00:16:46,044 --> 00:16:47,465
After we parallelized everything,

411
00:16:48,225 --> 00:16:49,765
it went down to 1.3 milliseconds,

412
00:16:49,805 --> 00:16:51,126
and that was for twice as much data.

413
00:16:52,717 --> 00:16:55,240
Also, just a point of note, waking threads is slow.

414
00:16:55,780 --> 00:16:57,082
We're using condition variables.

415
00:16:57,142 --> 00:16:59,324
We found that to be slow largely on both platforms.

416
00:17:00,746 --> 00:17:02,227
That's something that we'll look into in the future,

417
00:17:02,307 --> 00:17:04,610
maybe keeping threads warm, maybe using simple spin locks.

418
00:17:05,030 --> 00:17:06,572
It's a very small amount of performance

419
00:17:06,592 --> 00:17:07,313
that we're losing there.

420
00:17:09,055 --> 00:17:11,497
We also have single-threaded post-serialization fix-ups.

421
00:17:11,577 --> 00:17:12,819
So after you've done the

422
00:17:14,309 --> 00:17:18,031
relatively naive or simple serialization restore work,

423
00:17:18,531 --> 00:17:21,193
we would do a virtual pass over to link up various pointers

424
00:17:21,373 --> 00:17:24,015
and systems that weren't amenable to being serialized.

425
00:17:24,975 --> 00:17:27,477
Maybe that's because it was an asymmetric

426
00:17:27,497 --> 00:17:30,059
serialization relationship where you would serialize

427
00:17:30,079 --> 00:17:31,539
the object, but you'd have other systems

428
00:17:31,559 --> 00:17:33,901
that you really didn't want to pay serialization costs for.

429
00:17:34,401 --> 00:17:36,683
So you would need to hook those guys back up.

430
00:17:38,924 --> 00:17:40,845
Yeah, bulk serialization and immutable data

431
00:17:40,905 --> 00:17:41,646
are hugely preferred.

432
00:17:41,886 --> 00:17:43,587
Yeah, mem copy all your stuff.

433
00:17:45,082 --> 00:17:48,304
or don't change it and therefore don't have to serialize it.

434
00:17:50,586 --> 00:17:52,067
I'm not gonna read all of this.

435
00:17:52,487 --> 00:17:54,549
It's object lifetime, the slides are here

436
00:17:54,669 --> 00:17:56,410
if you guys wanna pull down the deck after the fact.

437
00:17:57,211 --> 00:17:58,632
Deferred deletion and delete and recreate.

438
00:17:58,832 --> 00:18:00,574
You have two choices for your objects,

439
00:18:01,094 --> 00:18:02,115
object lifetime management.

440
00:18:02,776 --> 00:18:03,896
If you do deferred deletion,

441
00:18:03,976 --> 00:18:05,458
you don't really have to handle the creation

442
00:18:05,498 --> 00:18:07,679
and destruction of every object every time they die

443
00:18:07,719 --> 00:18:09,080
and you roll back across that boundary.

444
00:18:09,741 --> 00:18:12,384
Delete and recreate is what you get out of the box naively.

445
00:18:12,845 --> 00:18:15,448
It's, you'll just constantly delete and recreate your objects,

446
00:18:15,468 --> 00:18:17,870
which maybe I'm making that sound bad,

447
00:18:17,930 --> 00:18:20,353
like sometimes the basic approach is exactly what you need.

448
00:18:22,516 --> 00:18:24,358
Recreatables, this is another thing we did

449
00:18:24,438 --> 00:18:26,260
to avoid creating objects all the time.

450
00:18:27,081 --> 00:18:29,203
The gist of it was you would hash that object.

451
00:18:29,958 --> 00:18:33,181
And every time you rolled back and played through the creation edge again,

452
00:18:33,221 --> 00:18:36,123
you would check the hash of essentially the situation you were in.

453
00:18:36,664 --> 00:18:38,585
And if it was the same, you would reuse that object.

454
00:18:39,326 --> 00:18:41,287
This is great for sounds and particles.

455
00:18:41,928 --> 00:18:44,930
They can be non-deterministic, especially for GPU particles.

456
00:18:45,571 --> 00:18:48,653
And since they're non-deterministic, if we were to destroy, recreate,

457
00:18:48,693 --> 00:18:52,136
and re-simulate these guys, we would likely end up with a different result.

458
00:18:52,917 --> 00:18:56,440
What this would mean is this would be chronic, like visual popping.

459
00:18:57,073 --> 00:19:00,295
debatably audio popping if you're doing anything dynamic there as well.

460
00:19:01,956 --> 00:19:05,898
Recreatables, it's a relatively simple thing, but the concept was very powerful.

461
00:19:06,358 --> 00:19:08,199
Just the ability to hash an object and say,

462
00:19:08,539 --> 00:19:11,841
this is the exact same guy, don't remake it, don't re-simulate it.

463
00:19:12,041 --> 00:19:13,362
We saved a lot of performance this way.

464
00:19:16,877 --> 00:19:17,898
What about gameplay script?

465
00:19:18,238 --> 00:19:21,561
We have a proprietary script system called MKScript.

466
00:19:22,061 --> 00:19:23,983
It's C-like, this is what our designers work in.

467
00:19:25,304 --> 00:19:27,685
We did have to support FiberStack unwinding,

468
00:19:27,906 --> 00:19:30,988
FiberStack serialization, and objects on the stack

469
00:19:31,008 --> 00:19:33,270
that contain dynamic allocations were a pain.

470
00:19:34,050 --> 00:19:36,052
We wrapped them up in a type, we registered them,

471
00:19:36,092 --> 00:19:37,113
we cleaned them up separately,

472
00:19:37,253 --> 00:19:38,914
because the stack was just getting zeroed out.

473
00:19:41,676 --> 00:19:42,516
Rollback artifacts.

474
00:19:42,976 --> 00:19:45,037
This is one of the downsides of rollback networking.

475
00:19:45,497 --> 00:19:48,678
You will pop your visuals if the divergence is large.

476
00:19:49,178 --> 00:19:50,459
Divergence is usually minor.

477
00:19:50,959 --> 00:19:52,519
In fact, divergence usually causes

478
00:19:52,579 --> 00:19:53,780
no visual artifacts at all.

479
00:19:54,380 --> 00:19:55,760
Most of the time when you're receiving

480
00:19:55,800 --> 00:19:56,861
remote input from somebody,

481
00:19:56,941 --> 00:19:58,601
it doesn't actually affect your game.

482
00:19:59,561 --> 00:20:01,542
We treat all input as significant,

483
00:20:01,862 --> 00:20:03,623
and we will rollback every time we get data

484
00:20:03,663 --> 00:20:04,403
from the remote player.

485
00:20:05,088 --> 00:20:09,749
you may not have to if you have a more well-guarded input system that knows

486
00:20:09,789 --> 00:20:14,690
whether input is valid and gameplay affecting then you may not have to roll

487
00:20:14,710 --> 00:20:19,112
back all the time but since we need to support divergence and rollback every

488
00:20:19,152 --> 00:20:23,633
single frame of the game it doesn't really save us that much so I have a

489
00:20:23,653 --> 00:20:32,215
video coming up here with this it this is just a fight with rollbacks on an

490
00:20:32,255 --> 00:20:32,815
online fight.

491
00:20:34,815 --> 00:20:35,936
So I mean, see if you can pick it out.

492
00:20:36,036 --> 00:20:37,076
One of these players is local

493
00:20:37,116 --> 00:20:38,257
and one of these players is remote.

494
00:20:40,178 --> 00:20:43,299
So this match was played at the absolute top

495
00:20:43,419 --> 00:20:44,760
of our latency supported.

496
00:20:45,520 --> 00:20:48,321
So this match was played at like 320 milliseconds RTT.

497
00:20:50,622 --> 00:20:51,943
So basically any worse than this

498
00:20:52,003 --> 00:20:58,146
and we would QoS players and disconnect them.

499
00:20:58,166 --> 00:20:59,686
So Deadpool is the local character

500
00:21:00,027 --> 00:21:01,967
and Starfire is the remote player.

501
00:21:02,188 --> 00:21:03,968
So she's the one rolling back constantly.

502
00:21:04,743 --> 00:21:05,524
I'll play it one more time.

503
00:21:06,425 --> 00:21:08,267
She, if you look closely,

504
00:21:08,307 --> 00:21:10,649
she's got some glitchier motion than he does.

505
00:21:11,590 --> 00:21:12,971
And it has everything to do with her

506
00:21:13,011 --> 00:21:14,253
being 300 milliseconds behind.

507
00:21:22,662 --> 00:21:24,544
As you can see, most of the time it just doesn't matter.

508
00:21:24,964 --> 00:21:27,806
This is a terrible connection, and the game plays fine.

509
00:21:29,468 --> 00:21:31,509
As far as the players are concerned, it plays great.

510
00:21:31,529 --> 00:21:32,750
Visually, there are artifacts,

511
00:21:32,790 --> 00:21:35,192
but from an input standpoint, the game is smooth.

512
00:21:40,296 --> 00:21:40,977
How was performance?

513
00:21:41,738 --> 00:21:44,580
When we switched over naively, performance was terrible.

514
00:21:44,980 --> 00:21:46,341
It was really, really bad.

515
00:21:47,282 --> 00:21:49,304
Prior to switching over to rollback networking,

516
00:21:49,344 --> 00:21:51,546
we were idling at nine or 10 milliseconds on the CPU.

517
00:21:52,594 --> 00:21:54,615
After we did the rollback support,

518
00:21:54,655 --> 00:21:56,316
we initially idled at 30 milliseconds,

519
00:21:56,816 --> 00:21:59,037
remembering we have to fit into 1666 here.

520
00:21:59,818 --> 00:22:02,319
The headroom due to the console generation jump was gone.

521
00:22:02,399 --> 00:22:05,040
We'd been playing it fast and loose with our CPU resources

522
00:22:05,481 --> 00:22:07,181
since PS4 and Xbox One came out,

523
00:22:07,782 --> 00:22:09,443
and we had to pay the piper.

524
00:22:10,363 --> 00:22:12,224
So yeah, we had tons of free cores.

525
00:22:12,264 --> 00:22:13,505
This is just a quick capture.

526
00:22:13,565 --> 00:22:14,385
I'll have more like it.

527
00:22:15,329 --> 00:22:17,412
This is from our task graphing system,

528
00:22:17,452 --> 00:22:18,914
which I'll refer to as job graph,

529
00:22:19,254 --> 00:22:20,636
but this is just a performance dump

530
00:22:20,796 --> 00:22:22,959
of the various hardware threads and what was going on.

531
00:22:23,820 --> 00:22:26,023
Yellow is something that's called an exclusive resource,

532
00:22:26,063 --> 00:22:28,846
which is essentially anything with that exclusive resource

533
00:22:29,167 --> 00:22:30,268
cannot run concurrently.

534
00:22:31,370 --> 00:22:33,612
All of that empty gray space is free cores.

535
00:22:35,769 --> 00:22:36,870
We used some performance tools.

536
00:22:37,270 --> 00:22:39,471
I'm not sure what I can, I'm allowed to say,

537
00:22:39,991 --> 00:22:41,832
but Sony and Microsoft performance tools

538
00:22:41,872 --> 00:22:43,033
were incredibly valuable.

539
00:22:43,093 --> 00:22:44,874
We used them all day, every day.

540
00:22:45,474 --> 00:22:49,076
The job graph visualizer, which was the threading layout

541
00:22:49,096 --> 00:22:51,117
that you just saw, as well as a tree-like structure,

542
00:22:51,137 --> 00:22:51,857
which you'll see later.

543
00:22:53,178 --> 00:22:54,599
Rollback loop super pause.

544
00:22:54,679 --> 00:22:56,320
This was, we had a mode in the game

545
00:22:56,840 --> 00:22:58,301
that could roll back to the same frame

546
00:22:58,401 --> 00:22:59,301
over and over and over again.

547
00:23:00,146 --> 00:23:02,326
What we would do is we would set thresholds in the game

548
00:23:02,366 --> 00:23:05,127
that if you went above 16 milliseconds or 15 milliseconds,

549
00:23:05,567 --> 00:23:08,768
we would pseudo-pause the game and just roll back

550
00:23:08,828 --> 00:23:10,648
and re-simulate to the same frame over and over

551
00:23:10,688 --> 00:23:12,868
and over again to catch our bog scenarios,

552
00:23:13,229 --> 00:23:15,189
let you late attach a profiler and dig in.

553
00:23:16,329 --> 00:23:18,770
The pet profiler, there's other GDC talks about this,

554
00:23:19,290 --> 00:23:22,250
but basically it's a CPU profiling tool written in-house

555
00:23:22,370 --> 00:23:25,731
that allows you to set thresholds for various functions.

556
00:23:26,331 --> 00:23:27,771
And performance bots, so that we can see

557
00:23:27,831 --> 00:23:28,632
when bad things happened.

558
00:23:32,267 --> 00:23:33,708
This is that tick timeline from earlier.

559
00:23:33,728 --> 00:23:36,891
I'm gonna go break this down a number of times

560
00:23:36,911 --> 00:23:37,772
over the next couple minutes.

561
00:23:38,373 --> 00:23:39,614
This is a seven frame rollback

562
00:23:39,714 --> 00:23:41,996
on the ship version of Injustice 2 at idle.

563
00:23:42,016 --> 00:23:43,258
It's about 13 milliseconds.

564
00:23:43,878 --> 00:23:45,160
Same thing that you saw previously.

565
00:23:45,200 --> 00:23:47,122
I'm gonna break it down into various sections,

566
00:23:47,162 --> 00:23:50,805
which is our gameplay execution, our engine execution,

567
00:23:51,366 --> 00:23:53,348
and green for saving and restoring.

568
00:23:55,422 --> 00:23:56,583
This is 21 milliseconds.

569
00:23:56,623 --> 00:23:58,403
This is also the ship version of Injustice 2.

570
00:23:58,683 --> 00:23:59,484
It's a spike frame.

571
00:24:00,024 --> 00:24:01,864
This is where Green Arrow did a bad thing

572
00:24:02,024 --> 00:24:04,005
and he spiked out a frame and we actually shipped this.

573
00:24:04,085 --> 00:24:05,065
We probably fixed it later,

574
00:24:05,126 --> 00:24:07,006
but some spikes do make it through.

575
00:24:08,067 --> 00:24:09,467
I call out high thread contention.

576
00:24:09,507 --> 00:24:12,828
Basically, we usually do cooperatively multi-threaded work,

577
00:24:13,368 --> 00:24:15,469
but early on, we also have other things

578
00:24:15,489 --> 00:24:17,070
that are non-cooperatively multi-threaded

579
00:24:17,110 --> 00:24:20,071
like our render thread, our UI thread, and our audio thread.

580
00:24:20,531 --> 00:24:22,631
So they tend to bog us a little bit early in the frame.

581
00:24:23,863 --> 00:24:25,784
This particular spike is due to mesh spawning,

582
00:24:25,844 --> 00:24:27,285
particle spawning, particle attachment,

583
00:24:27,565 --> 00:24:29,346
and a whole bunch of gameplay processes that run.

584
00:24:29,986 --> 00:24:32,348
And I call out here, spikes can persist for eight frames.

585
00:24:33,148 --> 00:24:34,429
If you're doing something heavy here,

586
00:24:34,569 --> 00:24:35,750
like spawning a whole bunch of stuff

587
00:24:35,790 --> 00:24:38,011
and you're not cutting any corners to do that,

588
00:24:38,611 --> 00:24:41,033
you're gonna roll back and replay this frame up to,

589
00:24:41,393 --> 00:24:42,974
you might do that eight times, right?

590
00:24:42,994 --> 00:24:44,635
You might keep crossing this boundary

591
00:24:44,975 --> 00:24:46,576
and keep bogging your game for eight frames.

592
00:24:49,658 --> 00:24:53,559
This is one of the early captures from Mortal Kombat X.

593
00:24:53,619 --> 00:24:54,700
It's a 32 millisecond frame.

594
00:24:55,140 --> 00:24:57,701
I just wanted to call out that the first block

595
00:24:57,821 --> 00:24:59,021
is a fixed cost block.

596
00:24:59,061 --> 00:25:00,761
It's input processing and online handling.

597
00:25:01,041 --> 00:25:02,002
That doesn't change at all.

598
00:25:02,602 --> 00:25:03,642
We had our restore.

599
00:25:03,802 --> 00:25:05,282
It was single threaded and very heavy.

600
00:25:06,083 --> 00:25:08,443
The simulated frames, zero to six here,

601
00:25:08,483 --> 00:25:11,004
took up a large percentage of the overall frame,

602
00:25:11,484 --> 00:25:13,064
larger than what we shipped, obviously.

603
00:25:13,525 --> 00:25:16,465
And the real render tick is substantially similar

604
00:25:16,525 --> 00:25:18,306
to what it was before rollback networking.

605
00:25:18,946 --> 00:25:21,907
What I'm trying to call out here is the majority of our costs

606
00:25:22,607 --> 00:25:25,548
were in the simulation frames, not the final render frame.

607
00:25:25,628 --> 00:25:28,509
That one continued largely to be what it is today,

608
00:25:28,589 --> 00:25:33,491
and it's been optimized, but not necessarily systemically.

609
00:25:35,132 --> 00:25:36,332
It's about multiplicative wins.

610
00:25:36,492 --> 00:25:39,113
If you can do something that works for eight frames,

611
00:25:39,353 --> 00:25:40,073
you should do that.

612
00:25:40,414 --> 00:25:42,014
If you put in an optimization that only works

613
00:25:42,054 --> 00:25:42,814
for your render frame,

614
00:25:43,855 --> 00:25:45,095
your gains are commensurately smaller.

615
00:25:46,662 --> 00:25:47,823
Frame zero is the confirm frame.

616
00:25:47,963 --> 00:25:50,824
This is the frame that I received input from my remote guy

617
00:25:50,844 --> 00:25:52,465
and that's why I rolled back seven frames.

618
00:25:53,785 --> 00:25:56,326
We're gonna run our seven lightweight simulation frames

619
00:25:56,406 --> 00:25:57,547
and then one render frame.

620
00:25:57,907 --> 00:25:59,108
We'll render once at the end of this.

621
00:26:00,488 --> 00:26:01,429
Gonna break this thing down.

622
00:26:02,909 --> 00:26:05,450
Just blitted that across all of the different frames.

623
00:26:05,711 --> 00:26:09,192
Restore is a large green single threaded chunk there.

624
00:26:10,313 --> 00:26:12,113
First thing we did here, we turned off everything cool.

625
00:26:13,223 --> 00:26:15,465
Physics and cloth, raycasts, IK, particle effects,

626
00:26:15,525 --> 00:26:17,486
online, desyncs, we turned off everything.

627
00:26:17,506 --> 00:26:19,247
And I don't mean like, hey, we turned this off

628
00:26:19,267 --> 00:26:20,888
for purposes of development.

629
00:26:21,288 --> 00:26:24,150
What I mean is we run these systems only on the render tick

630
00:26:24,330 --> 00:26:26,691
or some of these only get run on the confirmed frame,

631
00:26:26,711 --> 00:26:28,252
but we only run them once per tick.

632
00:26:28,792 --> 00:26:31,194
Stop running them eight times, they're very expensive.

633
00:26:35,036 --> 00:26:38,358
So that reduces our engine tick on the simulated frames.

634
00:26:38,378 --> 00:26:39,799
You'll notice it doesn't touch anything

635
00:26:39,839 --> 00:26:40,539
on the rendered frame.

636
00:26:42,350 --> 00:26:43,591
Then some easy performance wins.

637
00:26:44,292 --> 00:26:45,232
Don't do string compares.

638
00:26:45,753 --> 00:26:47,815
Don't do things eight times like controller polling

639
00:26:47,835 --> 00:26:48,676
or garbage collection.

640
00:26:50,217 --> 00:26:53,000
Don't update certain systems or whole slews of objects.

641
00:26:53,200 --> 00:26:54,961
Our environment is not gameplay affecting.

642
00:26:55,222 --> 00:26:56,323
Don't update it eight times.

643
00:26:57,725 --> 00:27:00,286
And realistically, death by a thousand paper cuts.

644
00:27:00,586 --> 00:27:02,526
Tons of dynamic allocs, pointer chasing,

645
00:27:02,966 --> 00:27:05,507
or my personal pet peeve is walking sparse lists.

646
00:27:07,208 --> 00:27:08,688
This pattern happens everywhere.

647
00:27:08,828 --> 00:27:10,429
You've got these massive lists of objects

648
00:27:10,889 --> 00:27:14,250
and you're iterating over them to do work on 5% of them.

649
00:27:14,470 --> 00:27:16,271
You've got some virtual function that you're hitting

650
00:27:16,871 --> 00:27:18,892
on 100% of your objects that are actually,

651
00:27:18,972 --> 00:27:19,952
it's gonna do work on 5% of them.

652
00:27:21,593 --> 00:27:22,835
That's a thing.

653
00:27:22,935 --> 00:27:26,439
Bulk allocation and serialization of all of our anim nodes in the anim trees saved us

654
00:27:26,479 --> 00:27:27,180
a half millisecond.

655
00:27:27,260 --> 00:27:28,021
That was a nice win.

656
00:27:29,222 --> 00:27:30,324
And use your profiling tools.

657
00:27:30,724 --> 00:27:32,066
They will tell you what you're doing wrong.

658
00:27:33,488 --> 00:27:34,849
So the engine tick got even smaller.

659
00:27:35,590 --> 00:27:38,073
Game tick hasn't really changed and we haven't touched serialization yet.

660
00:27:39,445 --> 00:27:41,267
This is the more difficult performance wins.

661
00:27:41,407 --> 00:27:43,069
I'm not gonna read the whole slide to you guys.

662
00:27:43,329 --> 00:27:46,031
I will explain the promotable resimulation behavior

663
00:27:46,051 --> 00:27:48,093
because that doesn't explain itself.

664
00:27:48,874 --> 00:27:50,195
Basically, you would have objects

665
00:27:50,335 --> 00:27:52,537
that would be latent in the environment

666
00:27:52,618 --> 00:27:54,920
that are not gameplay affecting right up until they are.

667
00:27:55,380 --> 00:27:57,142
So instead of paying for them all the time,

668
00:27:57,182 --> 00:27:58,923
we would promote them only when needed.

669
00:28:00,407 --> 00:28:02,207
The thing to note there is you need

670
00:28:02,267 --> 00:28:04,768
to know that you're going to need them before you do,

671
00:28:05,168 --> 00:28:07,368
because if you wait too long, you're

672
00:28:07,789 --> 00:28:09,829
inside your rollback window, and that's not

673
00:28:09,849 --> 00:28:11,349
going to be coordinated on both machines.

674
00:28:11,429 --> 00:28:13,990
So you need to see this coming seven frames in advance.

675
00:28:14,870 --> 00:28:15,711
Frequently not an issue.

676
00:28:16,851 --> 00:28:18,951
Aggressive parallelization and graph optimizations.

677
00:28:19,371 --> 00:28:20,612
That is a heck of a bullet point.

678
00:28:21,072 --> 00:28:23,612
We spent a ton of time optimizing our task graph.

679
00:28:24,293 --> 00:28:27,193
And then, yeah, we async tick our UI and audio.

680
00:28:28,105 --> 00:28:30,226
Um, emitter parallelization's a big deal.

681
00:28:30,366 --> 00:28:33,088
Animation pre-sampling wasn't a huge win,

682
00:28:33,208 --> 00:28:35,030
but ended up being fairly painful to implement.

683
00:28:35,670 --> 00:28:37,892
Uh, job priorities, yeah.

684
00:28:40,093 --> 00:28:41,194
Makes our engine tick go faster.

685
00:28:42,455 --> 00:28:43,796
Still, like, obviously you're seeing this,

686
00:28:43,876 --> 00:28:46,177
and serialization is taking up a massive amount of time

687
00:28:46,237 --> 00:28:46,458
for us.

688
00:28:47,518 --> 00:28:49,060
So this is our task graph here.

689
00:28:49,820 --> 00:28:51,282
You're only as fast as your critical path.

690
00:28:52,043 --> 00:28:53,865
Initially, we had that graph that I showed you earlier.

691
00:28:53,885 --> 00:28:55,146
I keep calling it a graph.

692
00:28:55,186 --> 00:28:56,988
It's because this tool generates graphs

693
00:28:57,008 --> 00:28:58,410
that we'll see in the next slide.

694
00:28:59,210 --> 00:29:01,753
But the one on top here is a very sparse,

695
00:29:01,993 --> 00:29:03,655
very wasteful graph, and the one on the bottom

696
00:29:03,695 --> 00:29:04,776
is the one we actually shift.

697
00:29:05,037 --> 00:29:06,438
There's still a little bit of waste at the end.

698
00:29:07,079 --> 00:29:08,220
At the end of the day, you're only as fast

699
00:29:08,240 --> 00:29:08,941
as your critical path.

700
00:29:10,856 --> 00:29:13,841
This is just a capture of a full job graph tick.

701
00:29:13,861 --> 00:29:15,103
This is the render tick.

702
00:29:16,945 --> 00:29:18,808
We can dig in here and see if our dependencies

703
00:29:18,828 --> 00:29:20,491
are all meaningful and if all of this makes sense.

704
00:29:22,817 --> 00:29:24,438
All I really want to call out here is that

705
00:29:24,858 --> 00:29:26,739
our simulated graph is much, much simpler.

706
00:29:26,839 --> 00:29:29,100
There's much fewer actors, much less complexity.

707
00:29:29,740 --> 00:29:32,181
And, I mean, you can see how ludicrously sparse it is.

708
00:29:32,701 --> 00:29:35,322
The total time scale for that is, I think,

709
00:29:35,342 --> 00:29:37,643
half a millisecond to run one of the simulated frames.

710
00:29:37,683 --> 00:29:38,444
That's pretty normal.

711
00:29:39,044 --> 00:29:41,545
So, yeah, I mean, you can see we're largely bound

712
00:29:41,585 --> 00:29:43,386
by animation sampling there.

713
00:29:45,987 --> 00:29:47,047
So, about that threading.

714
00:29:47,948 --> 00:29:50,028
Thread contention's a real thing, as I mentioned earlier.

715
00:29:50,886 --> 00:29:52,707
Our non-cooperatively multi-threaded portions

716
00:29:52,747 --> 00:29:54,988
of the engine do conflict with the rest of our engine.

717
00:29:55,008 --> 00:29:56,069
They do slow us down a bit.

718
00:29:56,669 --> 00:29:58,390
Manage your priorities, manage your affinities.

719
00:29:58,430 --> 00:29:59,650
You want to stick on the same core.

720
00:30:00,331 --> 00:30:01,871
Don't oversubscribe your threads.

721
00:30:02,912 --> 00:30:05,273
Drop thread priority for low priority

722
00:30:05,313 --> 00:30:06,293
or latency-tolerant work.

723
00:30:06,854 --> 00:30:08,935
And be careful of priority inversion and starvation.

724
00:30:09,115 --> 00:30:11,276
That's kind of a no-brainer at this point,

725
00:30:11,356 --> 00:30:13,717
but starvation can sneak up on you.

726
00:30:14,077 --> 00:30:14,938
That's very much a thing.

727
00:30:15,998 --> 00:30:17,639
Threading primitives can cost more than they're worth.

728
00:30:19,615 --> 00:30:21,176
This is kind of another of my pet peeves.

729
00:30:21,296 --> 00:30:25,258
It's very common to insert basic threading primitives

730
00:30:25,298 --> 00:30:27,919
all over the place to guard critical sections of work.

731
00:30:28,719 --> 00:30:31,440
I'm a huge fan of our cooperatively multi-threaded system,

732
00:30:31,480 --> 00:30:32,921
the task graphing that we do,

733
00:30:33,521 --> 00:30:34,542
because it avoids all of this.

734
00:30:35,462 --> 00:30:36,422
And use move semantics

735
00:30:36,462 --> 00:30:38,243
to avoid unnecessary atomic operations.

736
00:30:38,883 --> 00:30:41,124
You don't want to increment and decrement this stuff,

737
00:30:41,525 --> 00:30:42,005
just move it.

738
00:30:45,586 --> 00:30:47,527
So our serialization time went way down.

739
00:30:50,271 --> 00:30:51,512
Do you have to save eight times?

740
00:30:51,532 --> 00:30:53,014
This was a big deal for us, we figured it out.

741
00:30:53,694 --> 00:30:55,636
You only actually have to save the confirm frame,

742
00:30:55,676 --> 00:30:56,777
you don't actually need to save

743
00:30:56,857 --> 00:30:58,078
every frame of your simulation.

744
00:30:59,359 --> 00:31:01,221
You can only ever roll back to a frame

745
00:31:01,241 --> 00:31:03,043
that you actually had input for everybody.

746
00:31:03,904 --> 00:31:06,806
What this does mean though, is you will, on average,

747
00:31:06,846 --> 00:31:09,209
roll back further than you technically had to.

748
00:31:10,550 --> 00:31:12,952
This is a great optimization for your worst case,

749
00:31:13,252 --> 00:31:14,453
but it makes your average case.

750
00:31:15,320 --> 00:31:18,081
better, sorry, your worst case gets much better,

751
00:31:18,121 --> 00:31:19,722
your average case actually gets worse.

752
00:31:20,102 --> 00:31:21,263
We just happen to not care

753
00:31:21,343 --> 00:31:23,724
because we have to fit into 16.66 anyway.

754
00:31:24,204 --> 00:31:26,906
So we heard our average case

755
00:31:26,966 --> 00:31:28,887
and we optimized for our worst case.

756
00:31:30,468 --> 00:31:32,229
So we pack it down, it's 12 milliseconds.

757
00:31:34,970 --> 00:31:36,511
Particle performance, they were special.

758
00:31:37,291 --> 00:31:39,192
Naive approaches were way too expensive.

759
00:31:40,031 --> 00:31:41,732
Particle systems were the largest cause

760
00:31:41,772 --> 00:31:42,693
of performance spikes.

761
00:31:43,834 --> 00:31:45,855
We solved this largely with heavy caching,

762
00:31:46,296 --> 00:31:49,678
reduced re-simulation, and cutting corners

763
00:31:49,738 --> 00:31:51,099
on serialization all over the place.

764
00:31:51,600 --> 00:31:53,281
We would do deferred async initialization

765
00:31:53,301 --> 00:31:55,302
of our particles, and we would automatically

766
00:31:55,362 --> 00:31:56,323
parallelize the emitters.

767
00:31:56,883 --> 00:31:57,904
Initially, that was manual.

768
00:31:57,984 --> 00:32:00,146
We would actually have an artist and an engineer

769
00:32:00,206 --> 00:32:02,087
sit down and break up the emitters

770
00:32:02,127 --> 00:32:04,229
into figuring out which ones could go wide.

771
00:32:04,289 --> 00:32:06,411
But it turns out you can just figure that out offline.

772
00:32:07,231 --> 00:32:09,752
We burned about 100 meg for a runtime cache of our particles.

773
00:32:10,152 --> 00:32:12,213
So that we don't runtime spawn our particles,

774
00:32:12,373 --> 00:32:13,414
it was just too expensive.

775
00:32:15,335 --> 00:32:17,135
These are the particle resimulation modes.

776
00:32:17,476 --> 00:32:18,936
In the initial rollout, our designers

777
00:32:18,956 --> 00:32:20,757
would have to flag every single particle they

778
00:32:20,797 --> 00:32:22,078
made with one of these modes.

779
00:32:22,658 --> 00:32:24,699
Either you resimulate always, in which case,

780
00:32:24,739 --> 00:32:26,980
in a 7 frame rollback, you'll actually resimulate

781
00:32:27,000 --> 00:32:28,300
these particles eight times.

782
00:32:29,241 --> 00:32:30,261
You would do this if.

783
00:32:31,466 --> 00:32:34,309
essentially if your particles couldn't support variable time steps.

784
00:32:34,949 --> 00:32:39,174
So in that case you actually had to simulate them every single time, every single frame

785
00:32:39,194 --> 00:32:41,015
to get a predictable result out the other side.

786
00:32:41,636 --> 00:32:45,980
Resim never, which is I'm only going to simulate you on the render frame.

787
00:32:46,825 --> 00:32:49,648
ResimPredictive, this was by far our most common mode.

788
00:32:50,028 --> 00:32:51,810
What it leverages is the fact that the particles

789
00:32:51,870 --> 00:32:53,731
generally support variable time steps.

790
00:32:54,332 --> 00:32:56,534
We would simulate twice, once on the confirmed frame

791
00:32:56,554 --> 00:32:57,655
and once on the render frame.

792
00:32:58,095 --> 00:32:59,677
What this effectively ends up doing

793
00:32:59,717 --> 00:33:02,019
is giving you this like midpoint thing

794
00:33:02,059 --> 00:33:04,020
where you're doing a seven frame rollback

795
00:33:04,080 --> 00:33:05,962
and you're gonna simulate the guy on frame three

796
00:33:06,062 --> 00:33:07,123
as well as on the render frame,

797
00:33:07,163 --> 00:33:09,025
giving you sort of a midpoint and an endpoint.

798
00:33:09,367 --> 00:33:11,129
so that you get predictable particle playback.

799
00:33:11,949 --> 00:33:14,071
This ends up becoming our default

800
00:33:14,251 --> 00:33:15,612
and we almost never opt out of it.

801
00:33:16,192 --> 00:33:18,054
And then resim not track, this is for stuff

802
00:33:18,074 --> 00:33:19,995
that gets spawned into the environment.

803
00:33:20,035 --> 00:33:22,036
We're never gonna undo it, we're just gonna let it go.

804
00:33:25,216 --> 00:33:26,897
This is the predictive particle cache.

805
00:33:27,598 --> 00:33:30,040
We call it the PPRS, but I don't remember what that stands for.

806
00:33:30,780 --> 00:33:33,102
So it's predictive ticking and serialization.

807
00:33:33,262 --> 00:33:34,903
It may cause visual discontinuities.

808
00:33:35,524 --> 00:33:37,685
The important part here is that what we do

809
00:33:37,745 --> 00:33:40,447
is we hash with really, really loose constraints

810
00:33:40,747 --> 00:33:41,708
on these particle systems.

811
00:33:42,489 --> 00:33:47,974
And the constraints are like, is the player in roughly the same spot and have you done roughly the same thing in the gameplay script?

812
00:33:48,395 --> 00:33:52,619
If so, let's reuse this guy, don't touch him, don't simulate him, don't serialize him.

813
00:33:53,940 --> 00:33:58,605
Asterix, that's not exactly true. We do put a special serialization buffer that sits on top

814
00:33:59,166 --> 00:34:01,028
of the rest of the rollback system for use here.

815
00:34:01,929 --> 00:34:04,690
If the particle simulation inputs match the cache entry,

816
00:34:05,050 --> 00:34:05,590
use the cache.

817
00:34:05,990 --> 00:34:07,531
This was extremely effective.

818
00:34:08,331 --> 00:34:09,452
It's a good template for areas that

819
00:34:09,472 --> 00:34:10,632
don't have to be perfect, where you

820
00:34:10,652 --> 00:34:13,793
can use this lightweight serialization and very

821
00:34:13,953 --> 00:34:17,615
loose hashing algorithm to figure out

822
00:34:17,655 --> 00:34:18,735
what is close enough.

823
00:34:20,136 --> 00:34:22,117
You can't do this for anything that your game actually

824
00:34:22,157 --> 00:34:22,817
relies upon.

825
00:34:23,217 --> 00:34:25,558
This is only for visual discontinuities or maybe

826
00:34:25,638 --> 00:34:25,938
audio.

827
00:34:27,779 --> 00:34:28,820
A quick video of.

828
00:34:30,182 --> 00:34:33,803
What I'm going to show here is I'm going to show particle systems on the local machine

829
00:34:33,843 --> 00:34:36,784
as well as on the remote machine, and you'll see some divergence here.

830
00:34:37,224 --> 00:34:38,944
You'll see things where we mispredicted.

831
00:34:38,984 --> 00:34:41,465
These are particle systems that are input sensitive.

832
00:34:41,905 --> 00:34:46,447
So as you're doing this move, you can, you know, press the right stick or something

833
00:34:46,467 --> 00:34:47,967
and cause the particle to do a different thing.

834
00:34:48,327 --> 00:34:49,368
I'll play this multiple times.

835
00:34:54,149 --> 00:34:56,650
So it's a little hard to see, but if you check it on the remote machine there,

836
00:34:56,670 --> 00:34:59,011
you'll see the laser mispredicts all over the place.

837
00:35:05,154 --> 00:35:07,136
So this is Firestorm, same story.

838
00:35:07,176 --> 00:35:09,798
This particle system is sensitive to your input.

839
00:35:10,178 --> 00:35:12,661
So you'll see that the remote player sometimes shows it

840
00:35:12,821 --> 00:35:16,304
as a distant move and then it corrects to be closer.

841
00:35:17,605 --> 00:35:19,326
This one you'll see almost no divergence.

842
00:35:19,446 --> 00:35:22,989
The reason for that is the input that actually mattered

843
00:35:23,009 --> 00:35:26,112
to the game occurred very early on in the lightning ball.

844
00:35:26,152 --> 00:35:27,834
Like he executed the move before the particle

845
00:35:27,854 --> 00:35:28,594
was ever created.

846
00:35:28,895 --> 00:35:31,197
So those two particles look basically identical.

847
00:35:32,593 --> 00:35:33,993
What I'm gonna show you coming up here is,

848
00:35:34,073 --> 00:35:37,614
that was with our PPRS, the predictive particle system

849
00:35:37,674 --> 00:35:40,095
with the separate state cache on.

850
00:35:40,615 --> 00:35:41,635
This is with it off.

851
00:35:47,656 --> 00:35:50,237
So that's with a particle system that can't,

852
00:35:51,737 --> 00:35:53,798
the reason that PPRS is saving us there

853
00:35:54,378 --> 00:35:56,659
is because it's reusing the exact same object

854
00:35:56,779 --> 00:35:58,319
instead of attempting to re-simulate it.

855
00:35:59,687 --> 00:36:01,748
If you re-simulate that object, that's what you get.

856
00:36:01,768 --> 00:36:03,189
It's because it can't...

857
00:36:07,673 --> 00:36:11,316
I'm flaking out, but the PPRS system there

858
00:36:11,416 --> 00:36:13,017
allows us to reuse that particle effect

859
00:36:13,077 --> 00:36:14,398
and keep the exact same visuals.

860
00:36:14,838 --> 00:36:16,640
It has a non-deterministic simulation,

861
00:36:16,700 --> 00:36:18,521
so when you actually re-simulate it

862
00:36:18,561 --> 00:36:20,983
the eight times necessary, you get a different result.

863
00:36:21,304 --> 00:36:22,665
So it's visually inconsistent.

864
00:36:24,086 --> 00:36:24,826
I'll do it one more time,

865
00:36:24,846 --> 00:36:28,269
because the first two there are a little bit hard to see.

866
00:36:48,072 --> 00:36:50,353
So it may go without saying, I'm showing all of these

867
00:36:50,393 --> 00:36:51,793
under massive latency, right?

868
00:36:51,813 --> 00:36:54,735
This is, these are connections that are right

869
00:36:54,775 --> 00:36:58,917
before our QoS cutoff, 300, 350 millisecond round trip time.

870
00:37:03,539 --> 00:37:06,961
So this one that's about to show here is a demonstration

871
00:37:07,181 --> 00:37:08,802
of why you have to reuse objects

872
00:37:08,842 --> 00:37:10,383
that simulate non-deterministically.

873
00:37:30,083 --> 00:37:31,303
So, checking our work.

874
00:37:32,063 --> 00:37:33,864
We thought we were in trouble.

875
00:37:34,184 --> 00:37:36,505
We were due to ship the game in a month or so,

876
00:37:36,585 --> 00:37:37,685
or the patch for the game,

877
00:37:38,305 --> 00:37:40,106
and we kind of thought we were screwed.

878
00:37:40,586 --> 00:37:42,507
We didn't think, like we were still bogging,

879
00:37:43,207 --> 00:37:47,088
and the problem was we had been so focused

880
00:37:47,308 --> 00:37:48,849
on set rollback frame seven.

881
00:37:49,509 --> 00:37:53,452
which was taking every frame in our game and running it with 7 simulated frames.

882
00:37:53,472 --> 00:37:56,734
We were basically running our worst case scenario every single tick

883
00:37:57,194 --> 00:37:59,315
because that was technically possible.

884
00:37:59,835 --> 00:38:01,817
Turns out that's actually not realistic at all.

885
00:38:02,277 --> 00:38:05,339
QA picked up the game and said, this is fantastic, you have to ship this.

886
00:38:05,819 --> 00:38:09,301
I know you guys think that your performance metrics are all wrong here and that you were bogging.

887
00:38:09,321 --> 00:38:12,303
They're like, this plays leaps and bounds better

888
00:38:12,703 --> 00:38:15,205
than any online experience for Mortal Kombat in the past.

889
00:38:15,225 --> 00:38:16,366
You have to do this.

890
00:38:17,126 --> 00:38:23,251
So basically our benchmark was completely wrong. We were so focused on 7 frames of rollback that it turns out

891
00:38:24,071 --> 00:38:28,955
a human button press cadence is like maybe 6 times a second, usually much less than that.

892
00:38:29,355 --> 00:38:32,398
So the number of times that you actually rollback 7 frames is

893
00:38:33,570 --> 00:38:36,813
really bad connections and only whenever your opponent presses a button

894
00:38:37,613 --> 00:38:42,277
and getting those scenarios to occur in the very few situations that would

895
00:38:42,457 --> 00:38:43,458
actually bog the game

896
00:38:44,019 --> 00:38:47,822
it turns out this is incredibly rare and it doesn't actually impact the actual

897
00:38:47,862 --> 00:38:48,623
player experience

898
00:38:50,024 --> 00:38:51,705
uh... we were still bogging occasionally

899
00:38:52,496 --> 00:38:54,577
and we were net pausing in our worst cases.

900
00:38:55,017 --> 00:38:56,938
So basically, as you reach the latency cap,

901
00:38:57,718 --> 00:39:00,780
if you hadn't received a packet inside the 333 milliseconds

902
00:39:00,820 --> 00:39:02,960
that we supported, we would have to pause the game.

903
00:39:03,801 --> 00:39:06,402
Turns out pausing the game feels terrible, right?

904
00:39:06,522 --> 00:39:08,643
It injects these herky-jerky moments

905
00:39:08,663 --> 00:39:10,204
where the game gets hitches,

906
00:39:10,364 --> 00:39:12,144
it does screw up your button cadence quite a bit.

907
00:39:12,605 --> 00:39:15,126
It turns out that actually just extending the frames

908
00:39:15,166 --> 00:39:15,646
a little bit.

909
00:39:17,772 --> 00:39:18,573
will smooth that out.

910
00:39:19,193 --> 00:39:21,076
So this is a slightly contrived example

911
00:39:21,096 --> 00:39:22,978
because this is injecting 34 milliseconds

912
00:39:23,038 --> 00:39:24,339
spaced out over 10 frames,

913
00:39:24,740 --> 00:39:26,302
which is actually more than we would ever do.

914
00:39:27,002 --> 00:39:29,445
The most we would inject is about two milliseconds per frame

915
00:39:29,806 --> 00:39:31,808
and we will only do this if you're right up

916
00:39:31,828 --> 00:39:32,549
at the top of our...

917
00:39:33,887 --> 00:39:38,569
latency curve right so I mean as you can tell we spent a ton of time optimizing

918
00:39:38,609 --> 00:39:42,490
for the worst possible case the vast majority of our matches never hit any of

919
00:39:42,530 --> 00:39:46,992
these cases and the game plays extremely smoothly. We were just so focused on the

920
00:39:48,212 --> 00:39:54,614
the worst possible experience that we spent a lot of time optimizing for that.

921
00:39:55,414 --> 00:39:57,835
We had all this internal data Q is telling us everything's great.

922
00:39:58,353 --> 00:40:00,474
But we were about to pull the trigger on a pretty large

923
00:40:00,674 --> 00:40:02,596
change to our code base in a game that

924
00:40:02,616 --> 00:40:03,816
had been live for nine months.

925
00:40:04,477 --> 00:40:05,437
So we ran a beta.

926
00:40:05,698 --> 00:40:06,958
We had about 20,000 users.

927
00:40:07,539 --> 00:40:10,361
The public was extremely happy about it.

928
00:40:10,421 --> 00:40:12,402
We were watching all the streamers play locally.

929
00:40:12,522 --> 00:40:14,583
And they were loving it, right?

930
00:40:14,603 --> 00:40:15,224
It was a big deal.

931
00:40:15,724 --> 00:40:17,485
And it really solidified our performance and network

932
00:40:17,525 --> 00:40:17,926
targets.

933
00:40:18,266 --> 00:40:19,887
Again, our benchmarks were all wrong.

934
00:40:19,947 --> 00:40:21,488
We were chasing the wrong thing.

935
00:40:22,789 --> 00:40:23,109
Curveball.

936
00:40:24,050 --> 00:40:26,152
Beta telemetry demonstrated unexpected results.

937
00:40:26,732 --> 00:40:29,294
Most matches had one player rolling back seven frames

938
00:40:29,394 --> 00:40:30,415
every single frame of the game.

939
00:40:30,915 --> 00:40:32,656
Ironically, it was the crazy benchmark

940
00:40:32,676 --> 00:40:34,037
we'd been chasing the entire time.

941
00:40:34,538 --> 00:40:35,538
Turns out we had a bug.

942
00:40:36,807 --> 00:40:39,268
I don't know that it was a bug, but it was something that had to be addressed.

943
00:40:39,888 --> 00:40:41,609
It was basically a performance feedback loop.

944
00:40:42,149 --> 00:40:45,010
Somebody would start rolling back 7 frames, which would occasionally bog them,

945
00:40:45,050 --> 00:40:48,431
which would cause their frames to take longer, which would cause them to bog more

946
00:40:48,871 --> 00:40:51,572
and constantly roll back at the maximum possible distance.

947
00:40:52,252 --> 00:40:56,313
So the players loved it anyway. That's that 95% people said this is awesome.

948
00:40:56,373 --> 00:41:00,214
We had a horrific bug that caused the absolute worst case scenario

949
00:41:00,675 --> 00:41:02,795
and it was still way better than anything we'd had before.

950
00:41:03,395 --> 00:41:05,437
What we did was we artificially slowed down the player

951
00:41:05,457 --> 00:41:07,438
who was ahead to get them back in sync.

952
00:41:07,778 --> 00:41:10,040
We kick this in any time somebody gets more than about

953
00:41:10,060 --> 00:41:11,541
a frame and a half ahead of the other player.

954
00:41:12,081 --> 00:41:14,043
And all you have to do is inject just a little bit of latency

955
00:41:14,083 --> 00:41:15,103
to get people to sync back up.

956
00:41:17,425 --> 00:41:20,147
Fine-tuning. We analyzed our rollback counts

957
00:41:20,727 --> 00:41:23,049
and we used spec saves to reduce rollbacks.

958
00:41:23,969 --> 00:41:26,231
Previously I'd said you only have to save the confirm frame.

959
00:41:26,671 --> 00:41:29,153
That's true, but that causes you to rollback further

960
00:41:29,173 --> 00:41:30,133
than maybe you have to.

961
00:41:31,219 --> 00:41:34,502
If you simulate forward and the input does not diverge,

962
00:41:34,543 --> 00:41:36,745
you get the remote input that you expected to get,

963
00:41:37,606 --> 00:41:39,527
if you had saved that frame, you could use it,

964
00:41:39,888 --> 00:41:41,650
meaning you don't have to roll back all the way.

965
00:41:42,010 --> 00:41:43,652
Now, the extreme of that is save every frame,

966
00:41:43,712 --> 00:41:45,073
but then our performance goes down again.

967
00:41:46,113 --> 00:41:50,695
So we have this spec save system where we will save the confirm frame. You have to do that

968
00:41:51,675 --> 00:41:54,496
in order to always have a consistent thing to roll back to.

969
00:41:55,357 --> 00:41:57,937
Save the simulation midpoint if we have time.

970
00:41:58,297 --> 00:42:01,318
We know we're going to have time because the performance is relatively consistent.

971
00:42:01,779 --> 00:42:06,060
If you're rolling back seven frames, you may not have time to save this midframe,

972
00:42:06,080 --> 00:42:08,021
but if you're rolling back maybe five frames, you can.

973
00:42:08,941 --> 00:42:10,841
Bias the save closer to the confirmed frame,

974
00:42:11,262 --> 00:42:13,162
which is actually further in your past.

975
00:42:13,562 --> 00:42:15,162
This makes it more likely to actually be

976
00:42:15,202 --> 00:42:16,763
confirmed by remote input.

977
00:42:17,043 --> 00:42:19,723
Basically saying, your prediction for remote input

978
00:42:19,784 --> 00:42:21,964
is more likely to match the less time that passes.

979
00:42:23,324 --> 00:42:25,665
Save at the end of the frame, if you have time.

980
00:42:26,265 --> 00:42:28,306
And thresholds are tweakable without patching.

981
00:42:28,366 --> 00:42:30,426
So we could slide these things around in a live environment

982
00:42:30,446 --> 00:42:31,346
and try and find what works.

983
00:42:31,986 --> 00:42:34,047
And these speculative saves reduce the total rollback

984
00:42:34,067 --> 00:42:34,347
count by 30%.

985
00:42:34,387 --> 00:42:34,687
So the reason.

986
00:42:38,919 --> 00:42:40,260
This gets a little bit complicated,

987
00:42:40,320 --> 00:42:42,941
but the speculative saves reducing rollback count

988
00:42:43,242 --> 00:42:44,842
kind of sounds a little non-intuitive.

989
00:42:45,463 --> 00:42:47,924
The main type of rollback that they were saving us from

990
00:42:48,525 --> 00:42:50,486
was what we would call it an RB2.

991
00:42:50,626 --> 00:42:52,086
It's a buffer exhaustion rollback.

992
00:42:52,267 --> 00:42:54,728
It's a, my confirm frame is about to fall off

993
00:42:54,748 --> 00:42:57,249
the end of my buffer, and that's the only thing I saved.

994
00:42:57,690 --> 00:42:59,651
Therefore, we have to roll back into the past

995
00:43:00,191 --> 00:43:02,212
to another frame where I actually have input for,

996
00:43:02,672 --> 00:43:05,194
save that guy, and then we're good.

997
00:43:05,214 --> 00:43:06,995
But I just performed a seven-frame rollback.

998
00:43:07,515 --> 00:43:09,077
even when no input diverged.

999
00:43:09,437 --> 00:43:11,379
You really want to avoid that if at all possible.

1000
00:43:12,820 --> 00:43:13,681
What about all the desyncs?

1001
00:43:14,162 --> 00:43:16,544
Yeah, we made our game a lot more complicated

1002
00:43:16,584 --> 00:43:18,206
and therefore we had a whole lot more desyncs.

1003
00:43:19,207 --> 00:43:20,448
Not running procedural systems

1004
00:43:20,548 --> 00:43:21,949
ended up being a big cause of desyncs.

1005
00:43:22,190 --> 00:43:23,991
Turns out our game code was reliant

1006
00:43:24,051 --> 00:43:25,313
on a whole bunch of procedural things

1007
00:43:25,333 --> 00:43:26,153
that we had turned off.

1008
00:43:26,874 --> 00:43:29,156
IK being a main culprit there.

1009
00:43:30,097 --> 00:43:31,118
Luckily, our tools got better.

1010
00:43:31,771 --> 00:43:32,872
offline desync detection.

1011
00:43:33,252 --> 00:43:36,034
Because we're deterministic, if we playback our pad input

1012
00:43:36,054 --> 00:43:37,816
with the exact same network cadence,

1013
00:43:38,136 --> 00:43:39,417
you get the exact same match.

1014
00:43:39,997 --> 00:43:42,679
Meaning I actually don't need to be online

1015
00:43:42,699 --> 00:43:44,941
in order to desync the game for debugging purposes.

1016
00:43:45,421 --> 00:43:47,843
That's fantastic because not every developer

1017
00:43:47,883 --> 00:43:50,285
wants to have two kits at their desk.

1018
00:43:50,665 --> 00:43:52,066
People don't want to set up online sessions

1019
00:43:52,086 --> 00:43:52,987
to reproduce this thing.

1020
00:43:53,327 --> 00:43:55,429
Being able to do this with one kit was fantastic.

1021
00:43:56,534 --> 00:43:58,796
We would capture the remote input with network delays.

1022
00:43:58,996 --> 00:43:59,877
You could replay the match.

1023
00:44:00,457 --> 00:44:02,839
And since you could replay the match every single time

1024
00:44:02,879 --> 00:44:04,841
deterministically, you could also breadcrumb it

1025
00:44:04,921 --> 00:44:05,482
after the fact.

1026
00:44:05,822 --> 00:44:08,184
So you could inject new desync fence posts, new prints,

1027
00:44:08,204 --> 00:44:10,506
whatever you want, and you could replay that match

1028
00:44:10,526 --> 00:44:11,987
as many times as you needed to zero in

1029
00:44:12,007 --> 00:44:13,128
on what your problem actually was.

1030
00:44:13,488 --> 00:44:14,569
This was completely invaluable.

1031
00:44:14,789 --> 00:44:16,371
That was our normal debugging process

1032
00:44:16,391 --> 00:44:17,211
when a desync happened.

1033
00:44:17,572 --> 00:44:18,672
It was, hey, give me the replay.

1034
00:44:19,213 --> 00:44:20,074
I'm going to look at it locally.

1035
00:44:20,094 --> 00:44:21,255
I'm going to take a look at my logs.

1036
00:44:21,595 --> 00:44:22,736
If that's not what I want, I'm going

1037
00:44:22,756 --> 00:44:24,318
to inject more debugging information

1038
00:44:24,358 --> 00:44:25,759
and keep doing that until I find the problem.

1039
00:44:26,319 --> 00:44:27,500
Final desync rate was less than 0.1%.

1040
00:44:29,082 --> 00:44:31,023
I'm fairly certain it's actually less than 0.01%.

1041
00:44:31,304 --> 00:44:35,227
So what a desync log looks like.

1042
00:44:36,128 --> 00:44:36,989
It's nothing fancy.

1043
00:44:37,149 --> 00:44:37,790
It's a text diff.

1044
00:44:41,192 --> 00:44:44,274
So decent tools general distinct detection and logging which is

1045
00:44:44,294 --> 00:44:47,597
basically what we just talked about the replay files I talked

1046
00:44:47,617 --> 00:44:50,039
about this, but I just to mention it one more time it was

1047
00:44:50,660 --> 00:44:53,022
incredibly valuable you don't get this unless your game is

1048
00:44:53,062 --> 00:44:54,503
completely deterministic and to end.

1049
00:44:55,724 --> 00:44:58,766
And a desync utility, which you can see the small screenshot

1050
00:44:58,786 --> 00:45:01,627
there, the most useful thing that that gave us

1051
00:45:02,188 --> 00:45:04,609
was we can grab desyncs from the wild.

1052
00:45:04,829 --> 00:45:06,791
Any developer can click a button and go

1053
00:45:06,831 --> 00:45:09,853
grab all of the desyncs that occurred in the past day

1054
00:45:09,913 --> 00:45:11,133
or week from the wild.

1055
00:45:11,233 --> 00:45:13,255
So when the game launched, everybody's

1056
00:45:13,295 --> 00:45:15,716
sitting there clicking the give me all my logs,

1057
00:45:15,756 --> 00:45:17,757
let's find out why the game's desyncing and fix that.

1058
00:45:18,238 --> 00:45:19,839
And we got to respond very quickly because of that.

1059
00:45:19,859 --> 00:45:22,160
We didn't have to wait on first party for that.

1060
00:45:22,974 --> 00:45:24,455
And I just call out NRS soak.

1061
00:45:24,535 --> 00:45:27,177
We soak online matches on every kit in the building,

1062
00:45:27,577 --> 00:45:30,579
every night, desyncs get logged to an internal server,

1063
00:45:30,919 --> 00:45:31,920
and we can debug it that way.

1064
00:45:31,940 --> 00:45:33,040
So you catch a lot of this stuff

1065
00:45:33,281 --> 00:45:34,501
way before it gets out into the wild.

1066
00:45:36,303 --> 00:45:37,483
Some low-level lessons learned.

1067
00:45:38,524 --> 00:45:39,385
Limit your mutable state.

1068
00:45:40,437 --> 00:45:42,799
Handles over pointers, wherever performance allows.

1069
00:45:42,899 --> 00:45:44,781
Handles are inherently a double bounce usually,

1070
00:45:44,801 --> 00:45:46,123
it depends on your implementation,

1071
00:45:46,203 --> 00:45:47,965
but they cost extra performance.

1072
00:45:48,425 --> 00:45:50,668
But what they can allow you to do more easily than a pointer

1073
00:45:50,948 --> 00:45:53,591
is basically if you're using a handle,

1074
00:45:54,091 --> 00:45:56,614
when it comes time to fix something up post serialization,

1075
00:45:56,894 --> 00:45:58,076
you basically don't have to.

1076
00:45:59,197 --> 00:46:01,640
Also they can allow asymmetric rollback relationships

1077
00:46:01,660 --> 00:46:02,180
where you have.

1078
00:46:02,796 --> 00:46:05,699
An object that you're referencing via a handle

1079
00:46:06,379 --> 00:46:07,901
and your system is not serialized,

1080
00:46:07,941 --> 00:46:09,602
but the object is or vice versa.

1081
00:46:09,662 --> 00:46:11,724
With a raw pointer, that's much harder to do.

1082
00:46:12,325 --> 00:46:14,507
You end up having to have these strange post fix up calls

1083
00:46:14,527 --> 00:46:15,728
where you go and fix up all the pointers

1084
00:46:15,748 --> 00:46:16,328
in the whole wide world.

1085
00:46:17,429 --> 00:46:19,811
Avoid shared ownerships of mutable resources.

1086
00:46:19,891 --> 00:46:21,673
Again, this is what I talked about very early on.

1087
00:46:22,154 --> 00:46:24,195
Shared ownership, you would end up having to inject

1088
00:46:24,255 --> 00:46:26,538
another concept of like serialization ownership,

1089
00:46:27,258 --> 00:46:28,860
which is super dirty and to be avoided.

1090
00:46:29,917 --> 00:46:31,838
Avoid work in your constructors or destructors.

1091
00:46:31,918 --> 00:46:33,859
Again, if you're preserving object lifetimes

1092
00:46:33,919 --> 00:46:36,640
across these creation and destruction boundaries,

1093
00:46:36,900 --> 00:46:38,821
you can't trust your constructors and destructors

1094
00:46:38,901 --> 00:46:40,122
to trigger when they normally would.

1095
00:46:41,342 --> 00:46:42,783
Lean on mem copies and buffer swaps

1096
00:46:42,823 --> 00:46:43,803
instead of dynamic fixup.

1097
00:46:44,063 --> 00:46:45,624
Yep, yep, do that.

1098
00:46:47,485 --> 00:46:48,345
High-level lessons learned.

1099
00:46:49,418 --> 00:46:50,840
This is a huge one. This is a big deal.

1100
00:46:50,940 --> 00:46:53,042
This feels like, of course, this is the way it should work.

1101
00:46:53,462 --> 00:46:55,564
Design your game systems to drive visual state,

1102
00:46:55,624 --> 00:46:56,405
not depend on it.

1103
00:46:56,885 --> 00:46:58,306
We have a whole bunch of code that says,

1104
00:46:58,406 --> 00:46:59,647
tell me where my right hand is.

1105
00:47:00,088 --> 00:47:01,349
Oh, you know, where is the head?

1106
00:47:01,669 --> 00:47:02,790
And it does all of these things,

1107
00:47:02,810 --> 00:47:05,212
and it's literally saying, tell me where the joint is.

1108
00:47:05,793 --> 00:47:07,554
But if you stop running your procedural systems,

1109
00:47:07,574 --> 00:47:08,635
those answers are all wrong.

1110
00:47:09,116 --> 00:47:10,937
So we end up having to cut a whole bunch of corners

1111
00:47:10,957 --> 00:47:12,138
to make all of those answers right.

1112
00:47:12,699 --> 00:47:14,641
And if we had done a cleaner job up front

1113
00:47:14,681 --> 00:47:16,222
of segregating these two systems,

1114
00:47:16,562 --> 00:47:17,343
we'd be much better off.

1115
00:47:18,393 --> 00:47:20,315
Design systems to update with variable time steps.

1116
00:47:20,455 --> 00:47:22,777
It is extremely convenient when you don't have to run something

1117
00:47:22,797 --> 00:47:24,979
eight times, and you can run it at intermediate points

1118
00:47:25,359 --> 00:47:26,960
and still get effectively the same result.

1119
00:47:27,701 --> 00:47:29,022
If you can update parametrically,

1120
00:47:29,062 --> 00:47:30,604
that's even better because you probably

1121
00:47:30,644 --> 00:47:31,585
only need to update once.

1122
00:47:32,946 --> 00:47:35,128
Everyone should work with debug rollback systems enabled.

1123
00:47:35,388 --> 00:47:37,430
It's the fastest way to find things that go wrong.

1124
00:47:37,970 --> 00:47:40,412
When your designers are not running with debug systems

1125
00:47:40,472 --> 00:47:42,894
enabled, they think everything they're making is just fine,

1126
00:47:42,995 --> 00:47:45,837
only to find out later because QA happened to find a bug.

1127
00:47:47,718 --> 00:47:49,680
Defer processing until after the rollback window

1128
00:47:49,740 --> 00:47:50,500
if reasonable.

1129
00:47:50,961 --> 00:47:52,021
What this means is,

1130
00:47:52,041 --> 00:47:54,763
I don't have to actually roll something back

1131
00:47:54,903 --> 00:47:57,085
if I don't respond to it until I'm guaranteed

1132
00:47:57,125 --> 00:47:58,506
for it to have actually occurred.

1133
00:47:59,237 --> 00:48:01,437
What I mean is, if an event occurs

1134
00:48:01,737 --> 00:48:03,898
and I don't respond to it for seven or eight ticks,

1135
00:48:04,678 --> 00:48:06,938
I'm guaranteed by the time I actually respond to that,

1136
00:48:07,038 --> 00:48:09,179
that event has actually happened on both machines.

1137
00:48:09,219 --> 00:48:10,259
It will not be rolled back.

1138
00:48:10,779 --> 00:48:13,020
This doesn't have to be rollback compliant at that point.

1139
00:48:13,340 --> 00:48:14,620
We do that for our pause menu.

1140
00:48:14,640 --> 00:48:15,880
We do that for our cinematics.

1141
00:48:16,780 --> 00:48:18,961
We will never roll back out of a cinematic.

1142
00:48:19,021 --> 00:48:20,861
We will never roll back into a cinematic.

1143
00:48:21,221 --> 00:48:24,022
So we didn't support our cinematic tool for rollbacks,

1144
00:48:24,342 --> 00:48:26,042
although that causes our gameplay guys some headaches

1145
00:48:26,062 --> 00:48:27,683
because they have to put these boundaries on either side.

1146
00:48:28,951 --> 00:48:31,093
I'll also say in the cinematic vein there,

1147
00:48:31,773 --> 00:48:33,654
we just categorically don't allow anybody

1148
00:48:33,674 --> 00:48:34,995
to roll back across a camera cut.

1149
00:48:36,036 --> 00:48:37,297
That's not for a technical reason,

1150
00:48:37,357 --> 00:48:39,118
that's just incredibly jarring to the player.

1151
00:48:39,839 --> 00:48:41,820
So, I mean, also in Mortal Kombat,

1152
00:48:41,840 --> 00:48:42,761
if you cut a guy's head off,

1153
00:48:43,161 --> 00:48:44,942
we don't wanna roll back before that boundary.

1154
00:48:45,062 --> 00:48:47,224
Like, you just showed you ending the fight

1155
00:48:47,324 --> 00:48:48,925
and it's terrible for the players.

1156
00:48:48,965 --> 00:48:50,286
So there are certain boundaries

1157
00:48:50,326 --> 00:48:52,807
that from a technical standpoint, we could support,

1158
00:48:53,248 --> 00:48:55,970
but from a user standpoint, we should never allow.

1159
00:48:57,095 --> 00:48:58,957
Bog is also no longer a function of a single frame.

1160
00:48:59,257 --> 00:49:00,238
If you've done a terrible thing,

1161
00:49:00,358 --> 00:49:02,160
it will likely persist for the duration

1162
00:49:02,180 --> 00:49:02,941
of your rollback window.

1163
00:49:05,564 --> 00:49:06,004
Future work.

1164
00:49:06,625 --> 00:49:07,746
Multi-thread our gameplay script.

1165
00:49:07,967 --> 00:49:08,968
We have free cores there.

1166
00:49:09,128 --> 00:49:10,750
We can fill them with arbitrary work

1167
00:49:10,890 --> 00:49:12,351
or we can just multi-thread our game script.

1168
00:49:12,912 --> 00:49:14,314
That effort is underway.

1169
00:49:14,514 --> 00:49:15,194
It seems to be going well.

1170
00:49:16,294 --> 00:49:18,095
Extend state-based serialization.

1171
00:49:18,576 --> 00:49:21,477
We do have something in the game where certain objects will

1172
00:49:21,617 --> 00:49:23,278
enter a state, serialize that state,

1173
00:49:23,679 --> 00:49:26,100
and then not serialize the object

1174
00:49:26,140 --> 00:49:27,221
until state changes again.

1175
00:49:28,802 --> 00:49:29,522
That's a great idea.

1176
00:49:29,562 --> 00:49:30,223
We should do more of it.

1177
00:49:31,443 --> 00:49:33,444
Simplify particle serialization or simulation.

1178
00:49:34,025 --> 00:49:36,066
If we can move our particles in a parametric direction,

1179
00:49:36,186 --> 00:49:37,767
everything gets easier and cheaper.

1180
00:49:39,019 --> 00:49:40,540
separate the game state from the visual state,

1181
00:49:41,060 --> 00:49:43,643
and add rollback support for more systems,

1182
00:49:44,103 --> 00:49:46,065
largely just to ease the burden on our gameplay teams.

1183
00:49:48,828 --> 00:49:49,328
Any questions?

1184
00:49:49,788 --> 00:49:50,229
We're hiring.

1185
00:49:57,555 --> 00:50:01,480
Hi there, I work on a lockstep fighting game,

1186
00:50:01,500 --> 00:50:03,183
so first of all, congratulations.

1187
00:50:03,243 --> 00:50:05,386
I'm blown away that you were actually able to pull this off.

1188
00:50:07,469 --> 00:50:11,395
How close to the 60 millisecond performance budget

1189
00:50:11,455 --> 00:50:13,417
were you before you started this process?

1190
00:50:14,157 --> 00:50:15,899
Yep, so the question is, how close were we

1191
00:50:15,959 --> 00:50:18,702
to the 16 millisecond budget or limit

1192
00:50:18,802 --> 00:50:19,843
before we started the process?

1193
00:50:20,404 --> 00:50:23,127
We were, in my opinion, we were a bit lazy

1194
00:50:23,147 --> 00:50:24,488
due to the console generation jump.

1195
00:50:24,849 --> 00:50:27,211
We were running at about 10 milliseconds in an idle frame,

1196
00:50:27,612 --> 00:50:29,494
which gave us plenty of room to spike

1197
00:50:29,554 --> 00:50:30,695
and generally stay in frame.

1198
00:50:31,075 --> 00:50:36,683
I see, so the exercise was basically making sure that you could run the deterministic

1199
00:50:36,723 --> 00:50:41,049
portion of your game within whatever budget you had left, and so you were paring down

1200
00:50:41,089 --> 00:50:46,076
how much was in the deterministic segment and optimizing at the same time, is that the

1201
00:50:46,236 --> 00:50:46,597
gist of it?

1202
00:50:47,418 --> 00:50:50,718
And from a user experience standpoint,

1203
00:50:50,858 --> 00:50:53,279
if you are rolling back, you didn't

1204
00:50:53,359 --> 00:50:55,099
blend into the corrected frame.

1205
00:50:55,119 --> 00:50:56,239
You just went straight to it.

1206
00:50:56,299 --> 00:50:56,660
Is that correct?

1207
00:50:56,680 --> 00:50:57,100
We tried.

1208
00:50:57,660 --> 00:50:59,600
So the question is, did we interpolate

1209
00:50:59,720 --> 00:51:02,741
into the corrected position, corrected pose?

1210
00:51:03,381 --> 00:51:04,501
We experimented with that.

1211
00:51:04,621 --> 00:51:06,081
The short answer was it felt worse.

1212
00:51:08,602 --> 00:51:10,842
Our response from QA was that they wanted

1213
00:51:10,862 --> 00:51:12,302
to see the frames immediately.

1214
00:51:12,982 --> 00:51:14,943
As soon as we could correct it, we should correct it.

1215
00:51:15,443 --> 00:51:17,304
Also, the interpolation led to a lot of foot sliding

1216
00:51:17,324 --> 00:51:17,925
and that sort of thing.

1217
00:51:18,125 --> 00:51:18,305
Right.

1218
00:51:18,325 --> 00:51:20,426
So the user would essentially lose

1219
00:51:20,466 --> 00:51:24,069
between three and eight frames of execution from the other.

1220
00:51:24,089 --> 00:51:26,410
And they didn't really complain about that or care about that?

1221
00:51:26,430 --> 00:51:26,570
No.

1222
00:51:26,610 --> 00:51:27,591
I'll also note that.

1223
00:51:29,235 --> 00:51:31,678
I'd have to rewind all the way to the beginning of the slides.

1224
00:51:31,798 --> 00:51:35,542
The latency curve that I showed, the vast majority of our games

1225
00:51:36,343 --> 00:51:39,887
would be played under four to five frames of latency.

1226
00:51:40,588 --> 00:51:42,570
And we had three frames of static input latency,

1227
00:51:42,650 --> 00:51:44,773
which meant only one or two frames of rollback.

1228
00:51:45,233 --> 00:51:48,116
And that would cover 60% or 70% of the game.

1229
00:51:48,156 --> 00:51:50,339
So most games are played at super smooth.

1230
00:51:50,627 --> 00:51:56,168
So you rarely would run into problems where someone would like hit confirm and then it would be undone and then they'd be pissed off.

1231
00:51:56,208 --> 00:51:57,309
Yep. I mean, it is a thing.

1232
00:51:57,589 --> 00:51:57,929
Yeah.

1233
00:51:58,169 --> 00:51:59,289
It is rare, as you said.

1234
00:51:59,490 --> 00:52:01,130
Hmm. That's awesome. Congratulations.

1235
00:52:01,170 --> 00:52:02,391
It was unexpected, frankly.

1236
00:52:02,511 --> 00:52:02,991
Yeah.

1237
00:52:03,111 --> 00:52:03,371
It was...

1238
00:52:03,791 --> 00:52:04,171
I'm blown away.

1239
00:52:04,191 --> 00:52:05,992
...a lot it would be much more visually jarring.

1240
00:52:06,512 --> 00:52:12,514
I don't know how you did the serialization thing too. That's like super daunting, even considering how to go into that.

1241
00:52:13,494 --> 00:52:17,135
It's not bad. Start by serializing a lot and then optimize it. That's the gist of it.

1242
00:52:17,596 --> 00:52:18,016
Cool. Thanks.

1243
00:52:18,296 --> 00:52:18,516
Thank you.

1244
00:52:21,591 --> 00:52:29,497
So for this new system compared to the older system, it seems like the user reaction time might be a little different.

1245
00:52:30,078 --> 00:52:31,479
Yes.

1246
00:52:32,299 --> 00:52:41,167
Did this drive gameplay changes where maybe moves that needed to be reactable had to be made longer or things that shouldn't be reactable had to be made faster?

1247
00:52:41,487 --> 00:52:45,210
Yeah. I'll repeat the question because I was told to, although it sounds like you're super clear here.

1248
00:52:46,551 --> 00:52:47,152
The question is...

1249
00:52:48,112 --> 00:52:50,916
basically there's reaction time implications to this right moves have

1250
00:52:50,956 --> 00:52:54,541
warm up time it's a highly reactive game people want to respond immediately

1251
00:52:55,141 --> 00:52:59,107
and uh... and your concern is is spot on so did we make changes for mortal combat

1252
00:52:59,167 --> 00:53:01,630
ten which is where we initially patch this in no

1253
00:53:02,191 --> 00:53:05,114
that basically that was one hundred percent engineering effort

1254
00:53:06,135 --> 00:53:09,698
That's 99% engineering, but we didn't touch the gameplay.

1255
00:53:10,039 --> 00:53:12,260
For Injustice 2, yeah, a little bit.

1256
00:53:12,661 --> 00:53:14,282
The designers didn't change much, though.

1257
00:53:14,963 --> 00:53:16,844
As I said, the vast majority of your matches

1258
00:53:16,864 --> 00:53:19,747
will be played with one or two frames of actual rollbacks,

1259
00:53:20,187 --> 00:53:21,628
like three frame static input latency,

1260
00:53:21,708 --> 00:53:22,889
one or two frames of rollbacks.

1261
00:53:24,631 --> 00:53:26,332
Yeah, you're shaving off about one or two frames there.

1262
00:53:26,653 --> 00:53:29,915
So I don't know that our designers adjusted the moves a lot.

1263
00:53:30,015 --> 00:53:31,457
You're right in that.

1264
00:53:32,832 --> 00:53:38,658
Some seven or eight or nine frame punch is incredibly quick and shaving off one two three four or five frames of that is

1265
00:53:39,318 --> 00:53:45,044
The thing comes out like lightning, but the honest truth. This is somewhat my opinion, but it's confirmed around the building is

1266
00:53:47,112 --> 00:53:48,712
Fighting games are about footsies, right?

1267
00:53:49,133 --> 00:53:52,534
It's, I know when I'm in this position, I'm in danger, right?

1268
00:53:52,835 --> 00:53:55,076
And if you're within jab distance of a guy,

1269
00:53:55,776 --> 00:53:57,277
the vast majority of your player base,

1270
00:53:57,897 --> 00:53:59,538
largely including professional players,

1271
00:53:59,858 --> 00:54:02,560
is unable to actually react to that, right?

1272
00:54:02,640 --> 00:54:04,360
It's generally anticipatory.

1273
00:54:04,921 --> 00:54:07,042
So that's the gist of it.

1274
00:54:08,162 --> 00:54:10,844
We do shave off the front end of the attacks

1275
00:54:11,404 --> 00:54:12,605
with some of these rollback frames, though.

1276
00:54:12,816 --> 00:54:17,206
Yeah, I mean, it seems like you could lose seven frames on every single attack, theoretically.

1277
00:54:17,366 --> 00:54:18,690
That is technically possible, yes.

1278
00:54:18,810 --> 00:54:21,055
If you're playing up near the latency cap, that will happen.

1279
00:54:24,652 --> 00:54:27,333
How do I, how do I, like, there's an anecdotal thing.

1280
00:54:27,433 --> 00:54:29,174
We would receive reports during the beta

1281
00:54:29,234 --> 00:54:31,035
for a guy who was like in Brazil

1282
00:54:31,095 --> 00:54:33,956
playing on McDonald's wifi across the ocean,

1283
00:54:34,396 --> 00:54:35,917
raving about how awesome it was.

1284
00:54:36,437 --> 00:54:38,457
Like, is he a super competitive professional player?

1285
00:54:38,477 --> 00:54:39,538
Like, almost certainly not.

1286
00:54:40,238 --> 00:54:42,159
For everybody else, this is fantastic.

1287
00:54:42,179 --> 00:54:43,559
I mean, the pros love it too, right?

1288
00:54:43,880 --> 00:54:46,180
Like when they, like, their input cadence is identical.

1289
00:54:46,421 --> 00:54:47,421
When they show up to a tournament,

1290
00:54:47,461 --> 00:54:49,602
their online practice is actually valid.

1291
00:54:51,317 --> 00:54:53,857
And at the same time, all of their truly competitive events

1292
00:54:53,897 --> 00:54:54,657
are played on a LAN.

1293
00:54:55,038 --> 00:54:56,258
Oh, no, this is clearly better.

1294
00:54:56,278 --> 00:54:58,078
I was just curious if they needed to balance anything.

1295
00:54:58,098 --> 00:54:58,579
Thank you so much.

1296
00:54:58,759 --> 00:54:59,299
Yeah, thank you.

1297
00:55:00,779 --> 00:55:01,239
Great talk.

1298
00:55:01,319 --> 00:55:02,179
Two questions.

1299
00:55:02,259 --> 00:55:05,100
Number one, major engineering effort, seven to eight years.

1300
00:55:05,120 --> 00:55:08,301
Can you give me at least a rough idea of the breakdown

1301
00:55:08,341 --> 00:55:09,661
of where most of that time went?

1302
00:55:09,901 --> 00:55:11,202
Or was it just sort of evenly spent?

1303
00:55:11,682 --> 00:55:13,862
Sure, so the question is seven or eight man years.

1304
00:55:14,283 --> 00:55:16,683
How the heck did that break down?

1305
00:55:17,563 --> 00:55:18,324
Man, good question.

1306
00:55:20,650 --> 00:55:23,833
You know, certainly we lost a man year to desync chasing, no doubt.

1307
00:55:25,955 --> 00:55:29,077
Several man years of that would have been spent doing raw optimization,

1308
00:55:29,338 --> 00:55:31,440
of, you know, graph optimization, that sort of thing.

1309
00:55:32,100 --> 00:55:38,326
So, I would say we probably spent four or five man years of that doing optimization work.

1310
00:55:38,926 --> 00:55:41,549
And we probably spent the balance on correctness.

1311
00:55:42,753 --> 00:55:46,274
And we probably had one or two man years just building

1312
00:55:46,354 --> 00:55:49,376
infrastructure of serialization systems

1313
00:55:49,416 --> 00:55:50,956
and trying to serialize the whole darn game.

1314
00:55:51,437 --> 00:55:54,278
But a lot of it was optimization and desyncs.

1315
00:55:56,141 --> 00:55:58,323
Super interesting. And then the second question I have is

1316
00:55:58,343 --> 00:56:01,806
a lot of that work was making particle effects work.

1317
00:56:02,467 --> 00:56:06,270
And you straight up called out that of course you ideally want to separate

1318
00:56:06,410 --> 00:56:08,452
visuals from gameplay, have gameplay drive visuals.

1319
00:56:08,792 --> 00:56:12,696
What prevented you from just never re-simulating particles ever?

1320
00:56:13,156 --> 00:56:16,640
Just keep their orientations and rotations, and maybe they vanish if the

1321
00:56:16,740 --> 00:56:20,043
confirm doesn't come out right, or maybe they move, they interrupt or something.

1322
00:56:20,458 --> 00:56:23,240
Yeah, so the question is, hey, particles are a visual thing.

1323
00:56:23,280 --> 00:56:24,460
Why the heck are you rolling them back?

1324
00:56:25,681 --> 00:56:31,585
The gist of it is, I was trying to put a number on this

1325
00:56:31,645 --> 00:56:35,367
mentally here, but it basically, some portion of our rollback

1326
00:56:35,427 --> 00:56:37,588
is done for gameplay determinism purposes.

1327
00:56:37,668 --> 00:56:39,790
And some percentage of it is done simply

1328
00:56:39,810 --> 00:56:40,730
to make the game look better.

1329
00:56:41,351 --> 00:56:42,771
So a lot of the particles.

1330
00:56:44,072 --> 00:56:45,394
I hesitate to say all the particles,

1331
00:56:45,474 --> 00:56:47,155
but a lot of the particles were rolled back

1332
00:56:47,375 --> 00:56:49,457
purely for visual purposes and visual correctness,

1333
00:56:49,918 --> 00:56:51,439
not for gameplay determinism.

1334
00:56:52,960 --> 00:56:55,863
Also, that PPRS system prevented us

1335
00:56:55,903 --> 00:56:58,545
from rolling back the vast majority of our particles.

1336
00:56:58,866 --> 00:57:01,428
So by the end of it, we really were not rolling them back much.

1337
00:57:01,668 --> 00:57:04,050
That PPRS thing really sort of saved our bacon there.

1338
00:57:04,771 --> 00:57:06,472
I will try and knock these questions out real quick,

1339
00:57:06,492 --> 00:57:07,293
and then I will talk outside.

1340
00:57:07,313 --> 00:57:08,815
I think I have like one minute left or two minutes.

1341
00:57:09,879 --> 00:57:14,022
Hello, on LittleBigPlanet we used a very similar system.

1342
00:57:14,983 --> 00:57:18,385
And our biggest issues were performance and out of syncs.

1343
00:57:18,545 --> 00:57:21,607
You've covered really nicely the performance tips,

1344
00:57:22,268 --> 00:57:24,369
but do you have any tips for A,

1345
00:57:24,469 --> 00:57:26,391
structuring your code to avoid out of syncs,

1346
00:57:26,911 --> 00:57:29,213
and B, detecting and tracking down

1347
00:57:29,253 --> 00:57:30,634
the cause of the out of sync?

1348
00:57:31,214 --> 00:57:33,896
Yeah, so the question is desyncs are a real pain.

1349
00:57:34,236 --> 00:57:35,437
Do you have any tips and tricks there?

1350
00:57:36,198 --> 00:57:37,178
Oh man, deep topic.

1351
00:57:40,465 --> 00:57:43,426
we lean so heavily on the fact that we were fully deterministic and we could

1352
00:57:43,466 --> 00:57:46,807
replay those matches. I know that's not going to help you architecturally

1353
00:57:46,847 --> 00:57:50,387
necessarily, but being able to play them back and being able to breadcrumb it, if

1354
00:57:50,427 --> 00:57:55,028
you can't do that, you have to do that. It was just a complete lifesaver.

1355
00:57:56,729 --> 00:57:59,669
I'll talk to you afterwards. I'd love for the whole room to hear it, but

1356
00:57:59,689 --> 00:58:02,110
I just don't have time to dive super deep on that.

1357
00:58:04,811 --> 00:58:06,391
I believe you guys are on PC as well, right?

1358
00:58:07,142 --> 00:58:08,182
we ship a PC client.

1359
00:58:08,362 --> 00:58:09,123
Yeah, okay.

1360
00:58:09,163 --> 00:58:12,044
So, with respect to variable hardware,

1361
00:58:12,284 --> 00:58:16,486
when some player's on actually hitting 16 milliseconds,

1362
00:58:17,706 --> 00:58:19,427
how does your system work

1363
00:58:20,228 --> 00:58:23,089
if one person's running at like 30 FPS or something?

1364
00:58:23,615 --> 00:58:27,397
Yeah, my understanding, we don't ship the PC client in-house, we outsource it.

1365
00:58:27,818 --> 00:58:32,321
But my understanding is that they, the short answer is they net pause more frequently.

1366
00:58:32,861 --> 00:58:37,184
Like a lot of these safeguards that we have to ensure like a certain latency footprint,

1367
00:58:38,665 --> 00:58:44,048
they exist, but on PC they just, it's a lot fuzzier, so they do end up pausing the game more.

1368
00:58:45,249 --> 00:58:46,630
with variable hardware and variable,

1369
00:58:46,750 --> 00:58:49,171
I guess the network experience is probably basically identical,

1370
00:58:49,431 --> 00:58:51,012
but they'll net pause the game more frequently.

1371
00:58:51,672 --> 00:58:53,132
One very interesting thing to note

1372
00:58:53,232 --> 00:58:56,434
is that if you are bogging, maybe due to hardware

1373
00:58:56,514 --> 00:58:59,255
or whatever, that does impact your RTT

1374
00:58:59,295 --> 00:59:01,136
because your network send rate is changed

1375
00:59:01,296 --> 00:59:03,277
and your network receive rate is effectively changed.

1376
00:59:04,077 --> 00:59:06,418
That can lead to really weird feedback loops.

1377
00:59:07,918 --> 00:59:08,959
I'm not sure what's being done there.

1378
00:59:09,979 --> 00:59:10,339
Cool, thank you.

1379
00:59:10,560 --> 00:59:10,800
Thank you.

1380
00:59:15,607 --> 00:59:17,350
save state each time you're saving it?

1381
00:59:17,370 --> 00:59:17,891
Is it like 20 megs?

1382
00:59:17,931 --> 00:59:19,634
The question is, how big is the save buffer?

1383
00:59:20,195 --> 00:59:27,267
It's small, measured in K, you know, maybe a meg per frame, probably less.

