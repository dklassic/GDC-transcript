1
00:00:05,890 --> 00:00:08,253
Okay, hello.

2
00:00:08,253 --> 00:00:09,134
Small announcement.

3
00:00:09,134 --> 00:00:14,240
Could everyone please silence their mobile phones?

4
00:00:14,240 --> 00:00:15,662
Thank you all for coming.

5
00:00:15,662 --> 00:00:17,244
Really appreciate it.

6
00:00:17,244 --> 00:00:18,926
Welcome to Player Traversal Mechanics

7
00:00:18,926 --> 00:00:21,088
in the vast world of Horizon Zero Dawn.

8
00:00:21,088 --> 00:00:23,291
My name is Paul van Grinsven,

9
00:00:23,291 --> 00:00:24,953
and I'm a game programmer at Guerrilla.

10
00:00:26,154 --> 00:00:30,122
I would like to start off with a short video that gives the impression of the various player

11
00:00:30,122 --> 00:00:32,828
traversal mechanics in the fast world of Horizon Zero Dawn.

12
00:00:32,828 --> 00:00:37,658
As the game has just been released this week, you might have already seen some glimpses

13
00:00:37,658 --> 00:00:37,998
of it.

14
00:01:14,045 --> 00:01:16,947
So who is this flame-haired female warrior?

15
00:01:16,947 --> 00:01:18,728
Who are we dealing with?

16
00:01:18,728 --> 00:01:21,390
Let me introduce to you Aloy, a tribal outcast

17
00:01:21,390 --> 00:01:24,292
searching to understand her origins.

18
00:01:24,292 --> 00:01:27,134
Aloy is an adventurer with a lot of agility and endurance.

19
00:01:27,134 --> 00:01:30,156
Growing up in the wild in years of training

20
00:01:30,156 --> 00:01:32,237
made her into a very strong climber

21
00:01:32,237 --> 00:01:34,718
with well-developed fighting and hunting skills.

22
00:01:36,770 --> 00:01:39,751
The world of Horizon is huge, and most of the terrain

23
00:01:39,751 --> 00:01:41,452
is procedurally generated.

24
00:01:41,452 --> 00:01:43,833
The world sports a lot of different ecotopes.

25
00:01:43,833 --> 00:01:47,034
There's a large variety of rivers, forests, vegetation,

26
00:01:47,034 --> 00:01:49,836
climates, and wildlife.

27
00:01:49,836 --> 00:01:52,177
Next to that, the world is also filled with man-made

28
00:01:52,177 --> 00:01:55,498
structures and settlements, both indoor as well as outdoor.

29
00:01:55,498 --> 00:01:58,560
All of this makes it quite challenging for a game

30
00:01:58,560 --> 00:02:01,321
programmer to implement a solid traversal system.

31
00:02:03,715 --> 00:02:06,095
So now that you had a small introduction to Horizon,

32
00:02:06,095 --> 00:02:08,196
let's have a very quick look on what will be covered

33
00:02:08,196 --> 00:02:09,036
during this presentation.

34
00:02:09,036 --> 00:02:12,877
I will explain very briefly what the goals and constraints

35
00:02:12,877 --> 00:02:15,158
were for the traversal mechanics,

36
00:02:15,158 --> 00:02:18,379
a short look at our tools, workflow, and animation pipeline.

37
00:02:18,379 --> 00:02:20,800
Then we'll start off with a breakdown

38
00:02:20,800 --> 00:02:24,641
on how we achieved creating responsive navigation,

39
00:02:24,641 --> 00:02:26,281
followed by an in-depth description

40
00:02:26,281 --> 00:02:29,162
of our more advanced traversal mechanics,

41
00:02:29,162 --> 00:02:31,523
and last, some of our future plans will be discussed.

42
00:02:34,120 --> 00:02:37,605
To begin with, I would like to say a few things about the goals and constraints that we had

43
00:02:37,605 --> 00:02:39,687
for player traversal at the start of the project.

44
00:02:39,687 --> 00:02:45,114
From the design point of view, the overall requirement was to have responsive and fluid

45
00:02:45,114 --> 00:02:46,436
movement.

46
00:02:46,436 --> 00:02:51,642
Horizon is an open-world action RPG, so responsiveness is a big influence on the actual gameplay.

47
00:02:52,640 --> 00:02:55,922
The traversal development team consists of two programmers,

48
00:02:55,922 --> 00:02:59,184
three animators, one designer, and one producer.

49
00:02:59,184 --> 00:03:00,685
And from a technical point of view,

50
00:03:00,685 --> 00:03:03,647
everything needed to run at a minimum of 30 FPS.

51
00:03:03,647 --> 00:03:06,869
And as the terrain is mostly procedurally generated,

52
00:03:06,869 --> 00:03:10,552
we also had to make sure that all the movement would work

53
00:03:10,552 --> 00:03:13,153
properly everywhere in the world, no matter where you are.

54
00:03:15,953 --> 00:03:20,356
At Guerrilla, our animators work with both Maya as well as MotionBuilder.

55
00:03:20,356 --> 00:03:26,940
Morpheme is used as an animation middleware consisting of an animation authoring application, Morpheme Connect, and a runtime engine.

56
00:03:26,940 --> 00:03:34,645
Morpheme Connect allows our animators to graphically author blend trees, state machines, and transition logic.

57
00:03:34,645 --> 00:03:38,547
All this animation behavior for a character is stored in an animation network.

58
00:03:39,603 --> 00:03:42,445
The Morpheme runtime code that is integrated into our Decima

59
00:03:42,445 --> 00:03:45,128
engine then takes care of instantiating such animation

60
00:03:45,128 --> 00:03:47,710
networks and handles the runtime playback.

61
00:03:47,710 --> 00:03:52,074
The Decima engine is our own in-house developed engine,

62
00:03:52,074 --> 00:03:54,916
consisting of an editor and a runtime.

63
00:03:54,916 --> 00:03:58,239
The Decima editor is our authoring tool that allows

64
00:03:58,239 --> 00:04:00,921
users to graphically build huge and dynamic game worlds,

65
00:04:00,921 --> 00:04:02,783
including all systems and logic.

66
00:04:05,816 --> 00:04:07,878
We wanted the world of Horizon to have a lot of

67
00:04:07,878 --> 00:04:10,060
similarities with our current world, covering a lot of

68
00:04:10,060 --> 00:04:11,521
different landscapes.

69
00:04:11,521 --> 00:04:13,543
The image on the slide shows a typical

70
00:04:13,543 --> 00:04:15,164
traversable area in Horizon.

71
00:04:15,164 --> 00:04:17,546
You can see a lot of differences in elevation in

72
00:04:17,546 --> 00:04:18,487
the terrain.

73
00:04:18,487 --> 00:04:21,669
And unlike the Dutch landscape I'm used to, it's not flat at

74
00:04:21,669 --> 00:04:21,870
all.

75
00:04:23,228 --> 00:04:25,608
During the presentation, I will explain the various

76
00:04:25,608 --> 00:04:27,949
mechanics that we have developed that will allow

77
00:04:27,949 --> 00:04:30,589
Aloy, here standing on the left of the screen, to reach

78
00:04:30,589 --> 00:04:32,530
the far right of the screen.

79
00:04:32,530 --> 00:04:36,091
So if we want to get anywhere, we first have to make sure

80
00:04:36,091 --> 00:04:37,731
that Aloy is able to start moving.

81
00:04:37,731 --> 00:04:43,352
In our opinion, the feel of responsiveness of a

82
00:04:43,352 --> 00:04:46,113
controllable third-person character is mostly defined by

83
00:04:46,113 --> 00:04:47,533
the starts and stops.

84
00:04:47,533 --> 00:04:50,514
That is why, for Horizon, we really want to get a fluid and

85
00:04:50,514 --> 00:04:52,274
responsive start-stop system.

86
00:04:53,089 --> 00:04:55,550
The system should support left and right footedness,

87
00:04:55,550 --> 00:04:58,290
and the movement has to be very easy to control,

88
00:04:58,290 --> 00:05:00,790
where the character should always go into the direction

89
00:05:00,790 --> 00:05:02,571
of the player's input.

90
00:05:02,571 --> 00:05:06,231
Let me introduce you to the first problem

91
00:05:06,231 --> 00:05:09,212
we encountered during the early prototyping of our start-stop

92
00:05:09,212 --> 00:05:09,972
system.

93
00:05:09,972 --> 00:05:13,033
When trying to transition from a stop to a start,

94
00:05:13,033 --> 00:05:14,853
the movement input wasn't directly

95
00:05:14,853 --> 00:05:16,593
handled in the animation network,

96
00:05:16,593 --> 00:05:19,254
as we were first waiting for the stop animation

97
00:05:19,254 --> 00:05:20,314
to be completely finished.

98
00:05:20,937 --> 00:05:26,445
This was done because the stop animation contains some nice secondary motion which we would like to show.

99
00:05:26,445 --> 00:05:29,589
Let me visualize what this problem looks like in the next video.

100
00:05:29,589 --> 00:05:34,716
On the top right you can see the input of the controller.

101
00:05:34,716 --> 00:05:38,781
Note the latency between the input and the actual movement of Aloy.

102
00:05:50,067 --> 00:05:53,508
The solution to this problem relies heavily on the use of

103
00:05:53,508 --> 00:05:55,308
animation events.

104
00:05:55,308 --> 00:05:58,229
Within Morpheme, each animation clip can be

105
00:05:58,229 --> 00:06:02,350
annotated with such events, which have a time, a duration,

106
00:06:02,350 --> 00:06:02,630
and an ID.

107
00:06:02,630 --> 00:06:05,911
The animators can control when and for how long events are

108
00:06:05,911 --> 00:06:07,951
active, and how events are blended with

109
00:06:07,951 --> 00:06:10,092
multiple animations.

110
00:06:10,092 --> 00:06:12,813
Morpheme Runtime will provide a list of currently active

111
00:06:12,813 --> 00:06:14,393
events to the game after each update.

112
00:06:15,443 --> 00:06:18,444
This is an important tool for the game logic to synchronize

113
00:06:18,444 --> 00:06:20,485
its own state with the animation network.

114
00:06:20,485 --> 00:06:26,186
We solved the problem for the unresponsive stop to start

115
00:06:26,186 --> 00:06:28,947
transition by allowing an early reaction during the

116
00:06:28,947 --> 00:06:32,047
period of time that the exit allowed event is active.

117
00:06:32,047 --> 00:06:35,748
When during this event any movement input is given, an

118
00:06:35,748 --> 00:06:38,649
early transition to the start animation is triggered to

119
00:06:38,649 --> 00:06:39,789
increase responsiveness.

120
00:06:40,942 --> 00:06:45,446
If no movement input is given, we just continue playing the stop animation until the end,

121
00:06:45,446 --> 00:06:48,229
before transitioning to the idle.

122
00:06:48,229 --> 00:06:52,594
Normally, the exit allowed events are only active at the end part of the animation clip.

123
00:06:52,594 --> 00:06:55,337
The next video demonstrates the result.

124
00:07:12,295 --> 00:07:14,956
Let's continue on the start system by taking a closer look

125
00:07:14,956 --> 00:07:16,997
into the setup of our directional starts.

126
00:07:16,997 --> 00:07:19,758
We have three states controlling how to start.

127
00:07:19,758 --> 00:07:23,179
We have a forward start state, and a left, and a right one.

128
00:07:23,179 --> 00:07:26,981
The forward state includes all animations for starting to

129
00:07:26,981 --> 00:07:29,542
move more or less forward within a 45 degree angle.

130
00:07:29,542 --> 00:07:33,443
Note that we have no support for stepping backwards, as

131
00:07:33,443 --> 00:07:35,064
Horizon is all about moving forward.

132
00:07:36,865 --> 00:07:39,147
As you might have noticed, there are transitions possible

133
00:07:39,147 --> 00:07:40,949
between the different start states.

134
00:07:40,949 --> 00:07:43,431
This is done to make sure that we can already trigger a new

135
00:07:43,431 --> 00:07:44,812
start in a different direction.

136
00:07:44,812 --> 00:07:46,353
We found out that this increased

137
00:07:46,353 --> 00:07:48,234
responsiveness even further.

138
00:07:48,234 --> 00:07:54,159
Within the start system, we have three animation variables

139
00:07:54,159 --> 00:07:55,820
that control the animation network.

140
00:07:55,820 --> 00:07:59,183
A Boolean variable move that indicates if we are willing to

141
00:07:59,183 --> 00:08:03,046
move, a float variable speed, representing how fast we are

142
00:08:03,046 --> 00:08:04,007
willing to move.

143
00:08:04,488 --> 00:08:07,229
and a float variable heading, indicating the direction in

144
00:08:07,229 --> 00:08:09,770
which we would like to move.

145
00:08:09,770 --> 00:08:12,351
Movement in code is handled with a movement velocity and a

146
00:08:12,351 --> 00:08:12,911
turn speed.

147
00:08:12,911 --> 00:08:16,032
The turn speed is dependent on the movement speed.

148
00:08:16,032 --> 00:08:22,874
So the faster we move, the faster we are able to turn.

149
00:08:22,874 --> 00:08:26,014
Aloy has the ability to make a moving 180 degree turn by

150
00:08:26,014 --> 00:08:27,975
quickly steering the movement stick in the opposite

151
00:08:27,975 --> 00:08:28,515
direction.

152
00:08:29,471 --> 00:08:32,432
Since gamepad sticks and fingers are slow, such sudden

153
00:08:32,432 --> 00:08:35,733
changes in movement direction still take a few frames.

154
00:08:35,733 --> 00:08:38,194
They're definitely not instant.

155
00:08:38,194 --> 00:08:40,775
To handle this properly, we are keeping a history of the

156
00:08:40,775 --> 00:08:44,496
last three movement input directions and base our stops,

157
00:08:44,496 --> 00:08:45,756
turns, and starts on that.

158
00:08:45,756 --> 00:08:49,057
Movement speed and direction are always

159
00:08:49,057 --> 00:08:53,079
instantly updated, though.

160
00:08:53,079 --> 00:08:56,660
The image on the slide represents the blend tree of a

161
00:08:56,660 --> 00:08:57,500
directional start.

162
00:08:58,338 --> 00:09:01,580
As you can see, it contains four blend nodes.

163
00:09:01,580 --> 00:09:05,183
The first blend node is blending on the move heading,

164
00:09:05,183 --> 00:09:05,904
45, 90, and 180 degree.

165
00:09:05,904 --> 00:09:11,208
This makes sure we match the correct direction of the start.

166
00:09:11,208 --> 00:09:14,270
Per direction, we can achieve three different speed ranges.

167
00:09:14,270 --> 00:09:16,932
We have slow walk, fast walk, and jog.

168
00:09:16,932 --> 00:09:19,895
And these inputs are blended on the move speed variable.

169
00:09:23,009 --> 00:09:25,691
With the setup of a directional start in mind, let's focus on

170
00:09:25,691 --> 00:09:28,673
the animation metadata in the animation clips.

171
00:09:28,673 --> 00:09:31,655
This diagram shows the trajectory of a 90 degree

172
00:09:31,655 --> 00:09:33,736
directional start.

173
00:09:33,736 --> 00:09:36,438
All directional start animations are annotated with

174
00:09:36,438 --> 00:09:37,678
various events.

175
00:09:37,678 --> 00:09:41,601
And one very important one is the local motion event.

176
00:09:41,601 --> 00:09:45,003
This event tells us at runtime if we should use animation

177
00:09:45,003 --> 00:09:45,904
driven movement.

178
00:09:47,021 --> 00:09:49,524
So during the first part of this animation where the

179
00:09:49,524 --> 00:09:52,627
trajectory is rotating, we let the animation completely

180
00:09:52,627 --> 00:09:54,509
dictate the movement of our character.

181
00:09:54,509 --> 00:09:57,692
This is done to make sure we end in the correct direction

182
00:09:57,692 --> 00:10:00,875
as the player requested, and it reduces the amount of

183
00:10:00,875 --> 00:10:02,497
foot sliding.

184
00:10:02,497 --> 00:10:05,019
When the locomotion event is no longer active, the

185
00:10:05,019 --> 00:10:07,081
character's movement will be completely driven by the

186
00:10:07,081 --> 00:10:08,363
regular movement code again.

187
00:10:12,766 --> 00:10:15,667
The use of the locomotion event did cause the problem

188
00:10:15,667 --> 00:10:18,127
that our character's movement became unresponsive

189
00:10:18,127 --> 00:10:20,928
and uncontrollable during so-called micro-movement.

190
00:10:20,928 --> 00:10:23,708
Our movement logic was set up as shown

191
00:10:23,708 --> 00:10:25,869
in the diagram on the slide.

192
00:10:25,869 --> 00:10:28,009
In this example, we transitioned to a stop

193
00:10:28,009 --> 00:10:30,550
if the movement stick is released during a start.

194
00:10:30,550 --> 00:10:33,891
Because the stop animation contains animation

195
00:10:33,891 --> 00:10:35,531
driven forward movement,

196
00:10:35,531 --> 00:10:37,372
transitioning from a start to a stop

197
00:10:37,372 --> 00:10:40,012
would take away all control for the player,

198
00:10:40,012 --> 00:10:42,533
not giving him any chance to steer or abort.

199
00:10:43,739 --> 00:10:48,481
We solve this problem by introducing steps and shuffles in the start state and remove

200
00:10:48,481 --> 00:10:56,185
the transitions from a start to a stop and from a stop to a start.

201
00:10:56,185 --> 00:10:59,666
Steps and shuffles are start motions combined with stop motions.

202
00:10:59,666 --> 00:11:05,429
Shuffles are considered directional motions where the footedness stays the same, but quick

203
00:11:05,429 --> 00:11:08,710
rotation and small forward displacement is applied in the motion.

204
00:11:09,912 --> 00:11:14,195
The shuffle is triggerable by quickly tapping the movement stick in any direction.

205
00:11:14,195 --> 00:11:20,278
We define a step as a small forward motion where the player switches footedness.

206
00:11:20,278 --> 00:11:26,342
The step is triggerable by letting go of the movement stick once the feet have started to cross each other.

207
00:11:26,342 --> 00:11:29,224
It only contains forward displacement and no rotation.

208
00:11:29,224 --> 00:11:35,628
Each directional start then contains an event for when we allow the transition to a step or shuffle.

209
00:11:38,815 --> 00:11:41,638
So let's focus again on the animation metadata in a 90

210
00:11:41,638 --> 00:11:43,720
degree directional start.

211
00:11:43,720 --> 00:11:46,963
The moment we want to stop moving, the current playback

212
00:11:46,963 --> 00:11:49,726
position in the animation determines if it will trigger

213
00:11:49,726 --> 00:11:51,868
a step or a shuffle.

214
00:11:51,868 --> 00:11:54,571
When we have reached the end of the animation clip and we

215
00:11:54,571 --> 00:11:57,094
still want to keep moving, we allow an early

216
00:11:57,094 --> 00:11:58,075
transition to the cycle.

217
00:11:59,750 --> 00:12:02,973
All transitions from a start animation to either a step or

218
00:12:02,973 --> 00:12:06,195
a shuffle are synchronized transitions, meaning that the

219
00:12:06,195 --> 00:12:09,217
time in the source animation is synced with the destination

220
00:12:09,217 --> 00:12:10,779
animation.

221
00:12:10,779 --> 00:12:12,820
Here's a short video that shows what this

222
00:12:12,820 --> 00:12:13,661
looks like in action.

223
00:12:40,588 --> 00:12:43,229
Now that we're able to start a stop, let's continue with the

224
00:12:43,229 --> 00:12:43,769
next obstacle.

225
00:12:43,769 --> 00:12:46,489
As seen in the image, there's some elevation

226
00:12:46,489 --> 00:12:48,250
noticeable in the terrain.

227
00:12:48,250 --> 00:12:50,971
Smoothly standing on and walking over such rough and

228
00:12:50,971 --> 00:12:53,712
wild surfaces turned out to be quite challenging.

229
00:12:53,712 --> 00:12:59,373
Before going into detail on how we achieve smooth movement, I

230
00:12:59,373 --> 00:13:01,774
would first like to mention the constraints that we had to

231
00:13:01,774 --> 00:13:02,434
take into account.

232
00:13:03,379 --> 00:13:06,701
For the player character, we don't use a navigation mesh.

233
00:13:06,701 --> 00:13:09,162
Mostly for memory budget reasons, we didn't have one,

234
00:13:09,162 --> 00:13:12,305
making certain things a little bit harder.

235
00:13:12,305 --> 00:13:16,047
Player navigation is done by simulating a capsule shape

236
00:13:16,047 --> 00:13:17,468
through the physics world.

237
00:13:17,468 --> 00:13:18,989
So no real magic happening here.

238
00:13:18,989 --> 00:13:21,831
We do have a maximum slope angle of 50 degrees

239
00:13:21,831 --> 00:13:24,793
and a maximum speed of alloy six meters per second

240
00:13:24,793 --> 00:13:26,835
while sprinting.

241
00:13:26,835 --> 00:13:29,316
The maximum height that alloy can jump

242
00:13:29,316 --> 00:13:30,557
is 1.5 meters above the ground.

243
00:13:31,688 --> 00:13:34,890
Our capsule collider supports different predefined sizes,

244
00:13:34,890 --> 00:13:39,132
where the default standing size is 1.8 meters high and 70

245
00:13:39,132 --> 00:13:44,214
centimeters wide.

246
00:13:44,214 --> 00:13:46,475
For implementing smooth movement along an even

247
00:13:46,475 --> 00:13:49,697
terrain, we need to know what the ground surface gradient is,

248
00:13:49,697 --> 00:13:52,078
and we definitely like to ignore high frequency

249
00:13:52,078 --> 00:13:53,618
differences in elevation.

250
00:13:54,467 --> 00:14:01,271
Therefore, we cannot directly rely on the contact normal of the capsule's intersection with the ground, since that's very sensitive to that.

251
00:14:01,271 --> 00:14:10,318
We solve this by constructing a contact plane from four collision probes around the player's capsule collider and smooth out the results over time.

252
00:14:10,318 --> 00:14:21,225
If you look at the top view image on the slide, you can see that we have four probes around the player, marked with a blue dot.

253
00:14:22,297 --> 00:14:26,079
All the probes have a fixed start and end offset relative to the player's position...

254
00:14:26,079 --> 00:14:29,922
and are aligned with the orientation of the player.

255
00:14:29,922 --> 00:14:33,344
The contact plane can then be constructed by calculating a plane normal...

256
00:14:33,344 --> 00:14:37,868
which is the cross product of the direction between the right and left contact position...

257
00:14:37,868 --> 00:14:42,191
with the direction between the front and back contact position.

258
00:14:42,191 --> 00:14:45,293
We then smooth out the resulting normal with a previous one...

259
00:14:45,293 --> 00:14:47,675
to rule out even more high frequency noise.

260
00:14:48,807 --> 00:14:53,989
Note that some intersection points of the probes are rejected because of two extreme angles.

261
00:14:53,989 --> 00:15:00,191
But as long as we have three or more contact positions, we can construct our plane normal.

262
00:15:00,191 --> 00:15:06,893
Once we have constructed our contact plane, simply projecting Aloy desired movement onto it will make her move smoothly over the terrain.

263
00:15:06,893 --> 00:15:12,935
The forward and lateral slope angles are also sent by the game logic to the animation network,

264
00:15:12,935 --> 00:15:16,516
which allows Aloy to play additive animations based on the slope angle.

265
00:15:19,908 --> 00:15:23,810
To prevent us from having to waste precious cycles while waiting for the probe results,

266
00:15:23,810 --> 00:15:25,591
we decided to probe async.

267
00:15:25,591 --> 00:15:30,193
The collision probes are scheduled so they can be executed on different threads later

268
00:15:30,193 --> 00:15:30,634
in the frame.

269
00:15:30,634 --> 00:15:35,917
However, this means that the results of our probes are lacking one frame as we have to

270
00:15:35,917 --> 00:15:38,438
wait for the frame to be finished to gather our results.

271
00:15:38,438 --> 00:15:47,763
So now that the movement is smooth along uneven terrain, how do we keep the feet aligned with

272
00:15:47,763 --> 00:15:48,123
the ground?

273
00:15:49,480 --> 00:15:52,802
The solution for this is to procedurally adjust the position

274
00:15:52,802 --> 00:15:55,964
and orientation of the legs and feet.

275
00:15:55,964 --> 00:15:57,945
Duration events in the animations

276
00:15:57,945 --> 00:16:01,387
decide when the feet and legs are allowed to be adjusted.

277
00:16:01,387 --> 00:16:04,528
And our code decides where the feet are allowed to be placed,

278
00:16:04,528 --> 00:16:06,889
depending on the game state and the results of the collision

279
00:16:06,889 --> 00:16:07,230
probe.

280
00:16:10,536 --> 00:16:13,679
So, placing a foot on uneven terrain works as follows.

281
00:16:13,679 --> 00:16:18,382
We start by doing a raycast from knee height downwards to the collision mesh...

282
00:16:18,382 --> 00:16:21,085
...to detect any surface underneath the foot.

283
00:16:21,085 --> 00:16:25,248
The intersection point is sent back to the two-bone IK solver...

284
00:16:25,248 --> 00:16:29,011
...where the chain will be solved from ankle to knee to hips...

285
00:16:29,011 --> 00:16:30,953
...with adjustments of the pelvis as well.

286
00:16:32,682 --> 00:16:35,745
All animations have been annotated with foot rest events

287
00:16:35,745 --> 00:16:38,467
that control when a foot is resting on the ground.

288
00:16:38,467 --> 00:16:41,410
And so we know when adjustment has to be fully active.

289
00:16:41,410 --> 00:16:44,312
Separate events are used per foot.

290
00:16:44,312 --> 00:16:51,198
The described approach works quite well in most situations.

291
00:16:51,198 --> 00:16:53,800
But one specific case that it can't handle

292
00:16:53,800 --> 00:16:55,702
is shown here on the slide.

293
00:16:55,702 --> 00:16:58,764
Standing close to a cliff with one foot in the air.

294
00:16:58,764 --> 00:17:00,966
We've been calling this the floating foot problem.

295
00:17:01,807 --> 00:17:08,974
This happens when the downward raycast is not hitting any ground below the foot.

296
00:17:08,974 --> 00:17:15,700
We solve this problem by adding a fallback mechanism in the case that the raycast is unable to detect the ground.

297
00:17:15,700 --> 00:17:21,266
Once this happens, we perform another intersection test, but then with a swept sphere instead of a ray,

298
00:17:21,266 --> 00:17:25,730
so we can actually cover the whole size of the foot to find an intersection with the surface.

299
00:17:27,119 --> 00:17:32,324
This wider intersection test could find intersections that have a horizontal offset from the foot,

300
00:17:32,324 --> 00:17:34,887
but that's handled perfectly fine by the IK.

301
00:17:34,887 --> 00:17:39,272
However, the fallback mechanism is only enabled for alloy,

302
00:17:39,272 --> 00:17:44,977
as MPCs are always attached to a navigation mesh that guarantees to have a valid surface underneath.

303
00:17:44,977 --> 00:17:47,660
The next video will demonstrate the result.

304
00:18:04,847 --> 00:18:10,551
It's not only small differences in elevation that Aloy will encounter when traversing our world.

305
00:18:10,551 --> 00:18:15,795
She also has to deal with blocking obstacles like rocks, broken trees, robot parts, etc.

306
00:18:15,795 --> 00:18:22,560
As Aloy is very agile, we wanted her to effortlessly traverse most obstacles on her way.

307
00:18:22,560 --> 00:18:24,401
And so, our Vault system was born.

308
00:18:27,747 --> 00:18:31,549
Our vault system is capable of performing three types of moves.

309
00:18:31,549 --> 00:18:34,952
We support step up, step over and step off.

310
00:18:34,952 --> 00:18:41,156
The detection distances and parameters that are used are dependent on the current type of movement.

311
00:18:41,156 --> 00:18:45,899
For example, swimming or sprinting has different detection settings compared to normal walking.

312
00:18:49,391 --> 00:18:53,432
In the vault system, the first step is to see if we are actually allowed to vault.

313
00:18:53,432 --> 00:19:00,193
Our level designers can disable vaulting in certain gameplay areas by placing trigger volumes.

314
00:19:00,193 --> 00:19:03,734
Besides that, individual game assets can also be marked as not vaultable.

315
00:19:03,734 --> 00:19:08,015
For example, a table with a pickup on top of it.

316
00:19:08,015 --> 00:19:11,696
If the player is allowed to vault, we start by scheduling collision probes.

317
00:19:12,098 --> 00:19:16,562
This scheduling is done the same way as how we detect the surface gradient.

318
00:19:16,562 --> 00:19:23,148
So again, we will be one frame late as the results will only be available in the next frame.

319
00:19:23,148 --> 00:19:26,651
Moving on to the next frame.

320
00:19:26,651 --> 00:19:29,534
We're now able to process the results from previous frame.

321
00:19:29,534 --> 00:19:34,818
The collision probe that we scheduled is a swept sphere intersection test in front of Aloy.

322
00:19:34,818 --> 00:19:39,322
The probe starts at the standing height and ends a few meters below the starting point.

323
00:19:40,525 --> 00:19:44,568
If the intersection point of the swept sphere is higher than our current position, it means

324
00:19:44,568 --> 00:19:49,751
we should start analyzing the obstacle shape for a possible step up or step over.

325
00:19:49,751 --> 00:19:55,154
If the intersection point has a horizontal offset relative to the starting point, it

326
00:19:55,154 --> 00:19:59,197
means there is no direct ground underneath the starting point and we have probably hit

327
00:19:59,197 --> 00:20:02,599
an edge and should start searching for a possible step off.

328
00:20:05,649 --> 00:20:08,311
Because we don't use a navigation mesh for the player,

329
00:20:08,311 --> 00:20:10,572
we have no directly available metrics

330
00:20:10,572 --> 00:20:11,993
for the shape of the obstacle.

331
00:20:11,993 --> 00:20:16,815
Because of this, we have to do some smart shape analysis

332
00:20:16,815 --> 00:20:18,656
to another set of collision probes.

333
00:20:18,656 --> 00:20:22,218
These multiple collision probes are downward raycast

334
00:20:22,218 --> 00:20:24,900
in front of us with a fixed offset in between.

335
00:20:24,900 --> 00:20:28,002
This way, we can detect the depth of the obstacle

336
00:20:28,002 --> 00:20:30,243
and determine if the obstacle is flat enough

337
00:20:30,243 --> 00:20:31,283
to actually stand on.

338
00:20:32,770 --> 00:20:36,653
By looking at the height differences of the intersection positions of the raycast, we

339
00:20:36,653 --> 00:20:42,418
can see if we should be stepping onto the obstacle or if we can actually step over it.

340
00:20:42,418 --> 00:20:46,581
For a step-off, the same logic is applied as a step-on, the only difference is that

341
00:20:46,581 --> 00:20:51,524
the intersection position should be lower than Aloy's current position.

342
00:20:51,524 --> 00:20:55,487
Once the obstacle shape has been analyzed, we store all metrics of the found obstacle,

343
00:20:55,487 --> 00:20:58,790
which allows us to choose a matching animation to trigger.

344
00:21:03,095 --> 00:21:07,276
Transition selection is based on a scoring system with weighted variables.

345
00:21:07,276 --> 00:21:12,997
For each transition, we calculate the score and the transition with the highest score will be triggered.

346
00:21:12,997 --> 00:21:17,158
First, we have to make sure the transition is actually possible for the obstacle metrics.

347
00:21:17,158 --> 00:21:26,741
Each transition is categorized by an obstacle type, normal or climbable, and a vault type, step up, step over, step off.

348
00:21:26,741 --> 00:21:31,662
Every transition contains metrics of the corresponding vault motion.

349
00:21:32,460 --> 00:21:36,224
Next to that, each transition is allowed in defined ranges.

350
00:21:36,224 --> 00:21:39,186
Maximum upwards displacement, maximum forwards displacement,

351
00:21:39,186 --> 00:21:39,546
et cetera.

352
00:21:39,546 --> 00:21:42,649
By comparing the obstacle metrics

353
00:21:42,649 --> 00:21:46,612
with the animation metrics, we can select a transition

354
00:21:46,612 --> 00:21:47,493
that suits best.

355
00:21:47,493 --> 00:21:51,136
And as we prefer climbable vaults over normal vaults,

356
00:21:51,136 --> 00:21:53,258
each transition to a climbable obstacle

357
00:21:53,258 --> 00:21:54,299
receives a bonus score.

358
00:21:57,621 --> 00:22:00,303
So having looked at finding a valid full transition,

359
00:22:00,303 --> 00:22:03,085
let's now move on to executing one.

360
00:22:03,085 --> 00:22:05,086
As a result of supporting a variable range

361
00:22:05,086 --> 00:22:08,128
for each full transition, we introduced a problem.

362
00:22:08,128 --> 00:22:11,390
The obstacle has probably never the exact same metrics

363
00:22:11,390 --> 00:22:14,533
as the motion in the animation.

364
00:22:14,533 --> 00:22:17,535
So how can we make sure that the transition

365
00:22:17,535 --> 00:22:21,377
will match the obstacle and actually intersect

366
00:22:21,377 --> 00:22:21,858
with the shape?

367
00:22:21,858 --> 00:22:24,019
We use animation warping to solve this problem.

368
00:22:27,298 --> 00:22:33,400
Animation warping is the bending and stretching of an animated motion to reach a specific position at a specific time.

369
00:22:33,400 --> 00:22:40,462
The advantage of warping is that you don't need a lot of unique animations to cover all cases.

370
00:22:40,462 --> 00:22:45,703
Another nice thing is that while warping the destination position can be adjusted during playback.

371
00:22:49,280 --> 00:22:53,422
The image on the slide gives a rough idea of what animation warping does.

372
00:22:53,422 --> 00:23:00,887
On the left side you see the original motion and the right shows the warped motion.

373
00:23:00,887 --> 00:23:05,490
In order to efficiently spread out the warping adjustments over time, we need to know the

374
00:23:05,490 --> 00:23:09,973
total remaining displacement at any time in the animation.

375
00:23:09,973 --> 00:23:12,795
So this will require an analysis of the animation.

376
00:23:15,800 --> 00:23:21,464
In Horizon Zero Dawn all the warping is operating on each axis individually.

377
00:23:21,464 --> 00:23:26,367
So, consider this graph to be the displacement over time on the forward axis of the trajectory

378
00:23:26,367 --> 00:23:28,008
bone relative to the start position.

379
00:23:28,008 --> 00:23:34,653
Let's say if our current frame is at the orange dotted line, you can see that the next frame

380
00:23:34,653 --> 00:23:39,796
will contain a lot of forward displacement, the frame after that will contain almost no

381
00:23:39,796 --> 00:23:44,419
forward displacement and the frame after that will contain some backwards displacement,

382
00:23:44,419 --> 00:23:44,640
etc.

383
00:23:49,077 --> 00:23:55,559
By summing up the displacement of the remaining frames, we know our total remaining displacement.

384
00:23:55,559 --> 00:24:00,440
To warp this animation for every frame that's played, we need to add a little bit of extra

385
00:24:00,440 --> 00:24:01,801
displacement and rotation.

386
00:24:01,801 --> 00:24:07,062
The amount of motion that's added each frame is dependent on the amount of displacement

387
00:24:07,062 --> 00:24:10,543
in the animation for that frame, and the amount that's still remaining.

388
00:24:14,535 --> 00:24:18,958
Calculating the amount of extra displacement that is needed is done by dividing the current

389
00:24:18,958 --> 00:24:25,901
displacement by the remaining displacement, multiplied by the requested destination displacement.

390
00:24:25,901 --> 00:24:30,304
Note that the extra displacement is always pointing in the direction of the requested

391
00:24:30,304 --> 00:24:35,806
destination.

392
00:24:35,806 --> 00:24:41,309
We improved this basic warping technique with several enhancements that improved the usability

393
00:24:41,309 --> 00:24:43,210
and quality of the warp motions a lot.

394
00:24:43,968 --> 00:24:47,830
During the warp motions of our vaults, we needed to make sure that the hands are placed

395
00:24:47,830 --> 00:24:49,691
exactly on the obstacle shape.

396
00:24:49,691 --> 00:24:55,073
To achieve this, we have extended our warping logic to allow any bone to reach the given

397
00:24:55,073 --> 00:24:56,014
destination.

398
00:24:56,014 --> 00:25:01,856
This is done by calculating the offset of the hand bone to the trajectory bone at any

399
00:25:01,856 --> 00:25:05,958
point in the animation and subtract its offset from the destination position.

400
00:25:05,958 --> 00:25:10,640
This makes sure the hand bone will end up at the destination position.

401
00:25:11,917 --> 00:25:13,977
One note, when using this technique,

402
00:25:13,977 --> 00:25:20,620
the trajectory is defined by the motion of the hand bone.

403
00:25:20,620 --> 00:25:22,581
Another enhancement that we have implemented

404
00:25:22,581 --> 00:25:24,882
is to warp only during specific time ranges.

405
00:25:24,882 --> 00:25:28,083
For example, when both feet are still on the ground,

406
00:25:28,083 --> 00:25:30,704
you probably don't want to enable the warping yet,

407
00:25:30,704 --> 00:25:32,204
as this will introduce foot sliding.

408
00:25:32,204 --> 00:25:36,286
This is done by using specific animation events

409
00:25:36,286 --> 00:25:39,407
that represents the time window when warping can be applied.

410
00:25:40,371 --> 00:25:44,716
Multiple events are allowed in one animation clip.

411
00:25:44,716 --> 00:25:48,901
This is a very powerful enhancement to warping,

412
00:25:48,901 --> 00:25:51,244
and it's very easy to implement.

413
00:25:51,244 --> 00:25:53,386
If the animation event isn't active in a frame,

414
00:25:53,386 --> 00:25:55,629
we don't take the displacement into account

415
00:25:55,629 --> 00:25:58,492
when calculating our remaining displacement.

416
00:25:58,492 --> 00:26:00,835
This is illustrated by the graph on the slide.

417
00:26:05,444 --> 00:26:08,106
One problem is that sometimes you don't want to reach the

418
00:26:08,106 --> 00:26:10,847
destination at the end of the animation, but at a specific

419
00:26:10,847 --> 00:26:14,289
time in the animation.

420
00:26:14,289 --> 00:26:17,732
We solve this by allowing a user-defined arrival time.

421
00:26:17,732 --> 00:26:20,273
The arrival time is indicated by a specific

422
00:26:20,273 --> 00:26:21,274
event in the animation.

423
00:26:21,274 --> 00:26:27,517
The remaining displacement of the animation used in a

424
00:26:27,517 --> 00:26:29,799
warping formula is calculated till the

425
00:26:29,799 --> 00:26:30,960
user-defined arrival time.

426
00:26:31,912 --> 00:26:34,752
The displacement after this is not affecting the warping,

427
00:26:34,752 --> 00:26:37,373
but can be used for post-arrival motions,

428
00:26:37,373 --> 00:26:40,514
such as a landing animation.

429
00:26:40,514 --> 00:26:44,455
The last enhancement that we have implemented

430
00:26:44,455 --> 00:26:48,156
that can really help improving the quality of the warp motions

431
00:26:48,156 --> 00:26:52,198
is to preserve the original velocity of the animation.

432
00:26:52,198 --> 00:26:55,059
One noticeable problem that is caused by warping an animation

433
00:26:55,059 --> 00:26:58,720
is that adding displacement can cause unnatural speedups.

434
00:27:00,785 --> 00:27:08,690
We solved this issue by also adjusting the playback speed of the warped animation.

435
00:27:08,690 --> 00:27:16,734
To illustrate this, the graph on the slide shows the result of an animation warping to twice its own distance.

436
00:27:16,734 --> 00:27:21,157
You can see in the graph, marked with an orange line, that this doubles the velocity.

437
00:27:26,367 --> 00:27:29,790
To solve the unnatural speedup, we modify the playback speed

438
00:27:29,790 --> 00:27:32,252
to cancel out the speed increase.

439
00:27:32,252 --> 00:27:35,776
In this example case, we play back at half the speed.

440
00:27:35,776 --> 00:27:38,238
There are limits to how much faster or slower

441
00:27:38,238 --> 00:27:40,340
we can play the animation

442
00:27:40,340 --> 00:27:42,121
before it starts looking unnatural as well.

443
00:27:42,121 --> 00:27:45,604
Therefore, we let our animators control these

444
00:27:45,604 --> 00:27:47,006
on a per animation basis.

445
00:27:51,450 --> 00:27:54,172
The use of animation warping allowed us to turn the Vault

446
00:27:54,172 --> 00:27:57,594
system into a very versatile system that we use for a lot

447
00:27:57,594 --> 00:28:00,976
of different features, such as diving into water, climbing

448
00:28:00,976 --> 00:28:03,458
out of water, grabbing ledges.

449
00:28:03,458 --> 00:28:05,359
Here's a short video demonstrating all of these

450
00:28:05,359 --> 00:28:10,263
features.

451
00:28:10,263 --> 00:28:12,164
We start by triggering a step off.

452
00:28:12,164 --> 00:28:16,327
Then there's a step on to a climbable obstacle.

453
00:28:21,898 --> 00:28:24,020
followed by a step on to a normal obstacle.

454
00:28:24,020 --> 00:28:28,303
As you can see, all vaulting is triggered automatically.

455
00:28:28,303 --> 00:28:37,509
I don't press any buttons for triggering the various vaults.

456
00:28:37,509 --> 00:28:38,630
We have various variations.

457
00:28:38,630 --> 00:28:40,871
Here we have a step over with the left hand.

458
00:28:40,871 --> 00:28:43,613
And for that same height,

459
00:28:43,613 --> 00:28:48,536
we also have one with the right hand.

460
00:28:48,536 --> 00:28:49,657
We can dive into water.

461
00:28:51,772 --> 00:28:52,812
and climb out of water.

462
00:28:52,812 --> 00:29:00,495
All of this makes Aloy pretty exhausted.

463
00:29:00,495 --> 00:29:07,739
Not all obstacles in the world can be vaulted.

464
00:29:07,739 --> 00:29:11,440
Sometimes Aloy's only option to cross it is to jump.

465
00:29:11,440 --> 00:29:17,423
So let's take a look at how Aloy can jump to the ledges at the other side of this river.

466
00:29:20,695 --> 00:29:26,278
I would first like to explain very briefly how we annotate the world with environmental metadata.

467
00:29:26,278 --> 00:29:30,521
The world of Horizon is split up in big tiles.

468
00:29:30,521 --> 00:29:34,663
Each tile is 5 x 12 x 5 x 12 meters and currently we have more than 100 of them.

469
00:29:34,663 --> 00:29:41,727
Each tile is streamable and 3 x 3 tiles around Aloy's position are always loaded.

470
00:29:44,793 --> 00:29:48,094
A single tile contains various environmental metadata.

471
00:29:48,094 --> 00:29:50,594
The most common one is probably the collision mesh,

472
00:29:50,594 --> 00:29:52,995
which in our case is pretty low detailed

473
00:29:52,995 --> 00:29:55,615
and is available everywhere in the world.

474
00:29:55,615 --> 00:29:59,916
It tells us where Aloy can and cannot go.

475
00:29:59,916 --> 00:30:03,217
It also provides information about surface materials

476
00:30:03,217 --> 00:30:06,097
for impact sounds and effects.

477
00:30:06,097 --> 00:30:08,418
Besides that, we have other types of metadata,

478
00:30:08,418 --> 00:30:11,518
such as volumes that indicate where you can swim

479
00:30:11,518 --> 00:30:14,399
and volumes for defining where Aloy can be installed.

480
00:30:15,590 --> 00:30:18,212
We also have information of all the roads in the world,

481
00:30:18,212 --> 00:30:21,175
their width, their connections, and all of the junctions.

482
00:30:21,175 --> 00:30:25,398
But the most important one for the traversal system is that

483
00:30:25,398 --> 00:30:28,000
we have annotated geometry that identify

484
00:30:28,000 --> 00:30:29,182
traversable routes.

485
00:30:32,440 --> 00:30:35,623
All geometry in the world can be annotated by either points

486
00:30:35,623 --> 00:30:36,023
or lines.

487
00:30:36,023 --> 00:30:39,685
The points or lines can be attached to static geometry,

488
00:30:39,685 --> 00:30:42,507
but also to dynamic, movable geometry.

489
00:30:42,507 --> 00:30:46,430
These points and lines form what we call an annotation.

490
00:30:46,430 --> 00:30:50,153
The annotation can contain multiple tags, which makes

491
00:30:50,153 --> 00:30:51,934
them very abstract and versatile.

492
00:30:51,934 --> 00:30:53,735
And in the next slide, I will explain why.

493
00:30:53,735 --> 00:30:57,438
As all our geometry is streamable, the annotations

494
00:30:57,438 --> 00:30:59,199
will happily stream along with it.

495
00:30:59,862 --> 00:31:04,406
And as already mentioned, they provide semantics for various

496
00:31:04,406 --> 00:31:09,431
gameplay systems, such as our traversal system.

497
00:31:09,431 --> 00:31:12,133
In this image, the red lines highlight the annotations.

498
00:31:12,133 --> 00:31:16,437
We use text to indicate which traversal mechanics are

499
00:31:16,437 --> 00:31:18,779
allowed on the annotated geometry.

500
00:31:18,779 --> 00:31:21,662
For example, climbable means that Aloy can hang with her

501
00:31:21,662 --> 00:31:25,325
hands on the annotation, where balanceable means that Aloy

502
00:31:25,325 --> 00:31:26,847
can stand with her feet on it.

503
00:31:27,804 --> 00:31:30,286
Unstable means that it should look like that you could fall

504
00:31:30,286 --> 00:31:33,308
off at any moment by playing an additive animation.

505
00:31:33,308 --> 00:31:36,991
And ziplineable means that she is able to zipline along the

506
00:31:36,991 --> 00:31:38,292
annotation.

507
00:31:38,292 --> 00:31:40,974
Multiple tags are allowed on a single annotation.

508
00:31:40,974 --> 00:31:46,298
Before I continue explaining the traversal mechanics that

509
00:31:46,298 --> 00:31:49,841
use these annotations, I would first like to describe how we

510
00:31:49,841 --> 00:31:52,823
did set up our jump system, because attaching to one of

511
00:31:52,823 --> 00:31:55,305
the annotations often happens from a jump.

512
00:31:57,423 --> 00:32:00,685
In Horizon, our jump trajectory is split up in two phases.

513
00:32:00,685 --> 00:32:04,448
We have a pre-apex phase, which is animation driven,

514
00:32:04,448 --> 00:32:08,472
and we have the post-apex phase, which is code driven.

515
00:32:08,472 --> 00:32:12,975
As already mentioned, animation driven movement takes away control.

516
00:32:12,975 --> 00:32:15,297
Therefore, we added in-air steering.

517
00:32:15,297 --> 00:32:17,839
During the complete take-off and falling phase,

518
00:32:17,839 --> 00:32:20,822
we allow adjustments on the orientation of alloy,

519
00:32:20,822 --> 00:32:22,943
which results in bending the trajectory.

520
00:32:24,420 --> 00:32:28,703
By applying dampening on the forward momentum when the player lets go of the movement stick,

521
00:32:28,703 --> 00:32:34,428
we simulate in-air braking, and this improves controllability even more.

522
00:32:34,428 --> 00:32:40,493
We are using an animation-driven take-off to guarantee that the trajectory matches the jump motion.

523
00:32:40,493 --> 00:32:43,315
In our previous games, the complete trajectory was co-driven,

524
00:32:43,315 --> 00:32:48,179
which made it hard for our animators to create a matching motion for all the different speed ranges.

525
00:32:49,873 --> 00:32:52,755
So with all of these improvements on controllability,

526
00:32:52,755 --> 00:32:55,257
you could think that jumping towards a specific destination

527
00:32:55,257 --> 00:32:56,598
is a piece of cake.

528
00:32:56,598 --> 00:33:00,080
So I've prepared a demonstration to see this in action.

529
00:33:00,080 --> 00:33:11,487
As you can see, it is still annoyingly difficult

530
00:33:11,487 --> 00:33:13,529
for the player to time and predict a jump

531
00:33:13,529 --> 00:33:14,869
to end at a specific location,

532
00:33:14,869 --> 00:33:17,011
or at least for an amateur like me.

533
00:33:21,973 --> 00:33:24,635
So how can we improve this behavior?

534
00:33:24,635 --> 00:33:27,937
It would really help if we were able to predict the jump

535
00:33:27,937 --> 00:33:31,299
trajectory so we can apply small adjustments to guide the

536
00:33:31,299 --> 00:33:34,741
player to a specific traversable destination.

537
00:33:34,741 --> 00:33:37,923
One important note is that we absolutely want to maintain

538
00:33:37,923 --> 00:33:40,605
the illusion of control.

539
00:33:40,605 --> 00:33:45,508
To be able to predict the jump trajectory at runtime, we need

540
00:33:45,508 --> 00:33:48,009
to know the full motion of our jump animation.

541
00:33:49,112 --> 00:33:59,639
This is why we analyze our animated motion during the offline conversion process and store all the metadata in so-called motion tables.

542
00:33:59,639 --> 00:34:05,362
Motion tables are databases of animation metadata for individual animation states.

543
00:34:05,362 --> 00:34:15,428
They contain information about how the displacement, speed, time, etc. changes for animation states dependent on the animation variables that affect the animation state.

544
00:34:16,430 --> 00:34:19,171
These motion tables are, for example, used for storing the

545
00:34:19,171 --> 00:34:21,692
animation metrics in the vault transitions, as

546
00:34:21,692 --> 00:34:25,954
mentioned earlier.

547
00:34:25,954 --> 00:34:28,896
In an offline step, we populate our motion tables by

548
00:34:28,896 --> 00:34:34,038
analyzing the resulting motion of all animation states for

549
00:34:34,038 --> 00:34:36,199
all valid permutations of input variables.

550
00:34:36,199 --> 00:34:38,120
This is quite an expensive task.

551
00:34:38,120 --> 00:34:41,982
At runtime, we are able to query the database for a given

552
00:34:41,982 --> 00:34:44,383
state with the active runtime animation variables.

553
00:34:45,258 --> 00:34:48,261
Based on the active set of animation variables, several

554
00:34:48,261 --> 00:34:51,023
stored results are then blended together to form a

555
00:34:51,023 --> 00:34:53,045
final resulting set of metadata.

556
00:34:53,045 --> 00:34:56,288
Here's a rough example of how that works.

557
00:34:56,288 --> 00:35:02,173
This example shows a simple animation state that blends

558
00:35:02,173 --> 00:35:05,116
three animations together, depending on two input values

559
00:35:05,116 --> 00:35:08,018
that are set by the game logic.

560
00:35:08,018 --> 00:35:09,480
In this case, variables x and y.

561
00:35:10,720 --> 00:35:16,763
The blend node simply blends two animations together when the weight depends on the input variable.

562
00:35:16,763 --> 00:35:20,985
In this case when X is 0, 100% of A will be blended with 0% of B.

563
00:35:20,985 --> 00:35:29,510
And when X is 0.5, A and B will be equally blended.

564
00:35:29,510 --> 00:35:36,254
For our motion table, we want to pre-calculate all metrics for our animation state for certain combinations of input values.

565
00:35:37,261 --> 00:35:43,884
We are only interested in combinations of input values that make any of the blend nodes choose a single one of its inputs.

566
00:35:43,884 --> 00:35:51,907
In this case, we have a total of four input values possible for the two different blend nodes.

567
00:35:51,907 --> 00:35:55,189
X can either be 0 or 1 and Y can either be 4 or 8.

568
00:35:56,652 --> 00:35:59,333
Because there's no blend node attached to the input value

569
00:35:59,333 --> 00:36:02,615
when y equals 8, we have a total of three combinations

570
00:36:02,615 --> 00:36:03,075
possible.

571
00:36:03,075 --> 00:36:06,817
So for these three combinations of input values,

572
00:36:06,817 --> 00:36:10,378
the animation metrics are stored in the table.

573
00:36:10,378 --> 00:36:16,161
Querying metrics for arbitrary input values is now just a

574
00:36:16,161 --> 00:36:19,242
matter of blending the stored results together.

575
00:36:19,242 --> 00:36:21,843
Applying the same blending as in the animation network to

576
00:36:21,843 --> 00:36:24,584
the values stored in the motion table results in a

577
00:36:24,584 --> 00:36:25,325
valid outcome.

578
00:36:30,312 --> 00:36:34,493
Now that we are able to query the metrics of a jump motion, we can easily calculate

579
00:36:34,493 --> 00:36:39,615
the position of our apex by adding the complete displacement from a take-off animation to

580
00:36:39,615 --> 00:36:41,275
a take-off position.

581
00:36:41,275 --> 00:36:45,777
This will be the initial position of the falling face.

582
00:36:45,777 --> 00:36:50,498
The initial velocity will be the velocity of the last frame from the take-off animation,

583
00:36:50,498 --> 00:36:54,059
which again is also queried from the motion table.

584
00:36:54,059 --> 00:36:58,701
Using these positions, we can construct a parabolic trajectory as shown on the slide.

585
00:37:02,362 --> 00:37:05,363
With the constructed parabolic trajectory, we can now start

586
00:37:05,363 --> 00:37:07,245
searching for nearby jump destinations.

587
00:37:07,245 --> 00:37:11,187
This is done by gathering all possible targets within a

588
00:37:11,187 --> 00:37:13,769
certain radius of alloy.

589
00:37:13,769 --> 00:37:16,590
We iterate over our jump trajectory with a fixed time

590
00:37:16,590 --> 00:37:20,293
step to see if a target is reachable at any given moment

591
00:37:20,293 --> 00:37:22,554
during the jump.

592
00:37:22,554 --> 00:37:25,296
Targets that are above our apex are never reachable,

593
00:37:25,296 --> 00:37:27,497
because it would look too unnatural.

594
00:37:28,696 --> 00:37:33,938
If a target is close enough to our originally predicted trajectory, we can calculate a skill

595
00:37:33,938 --> 00:37:39,461
factor of the parabola by defining the desired displacement by the original displacement.

596
00:37:39,461 --> 00:37:45,124
This way we know how much extra velocity is needed to reach the target.

597
00:37:45,124 --> 00:37:51,127
We only allow guiding to targets for which the change of velocity is within an adjustable

598
00:37:51,127 --> 00:37:51,747
limit.

599
00:37:51,747 --> 00:37:57,369
This makes it very easy for designers to tweak and control the snappiness of the jump guidance

600
00:37:57,369 --> 00:37:57,730
system.

601
00:38:01,745 --> 00:38:05,405
The previous slide showed how we could predict the trajectory if the target position was

602
00:38:05,405 --> 00:38:06,666
exactly in front of Aloy.

603
00:38:06,666 --> 00:38:12,147
But since we support in-air steering, we should also allow some bending of the trajectory

604
00:38:12,147 --> 00:38:15,107
to reach a certain destination.

605
00:38:15,107 --> 00:38:19,928
We are able to account for this by calculating the required turn speed by constructing a

606
00:38:19,928 --> 00:38:25,429
circle that goes through both our current position as our destination position.

607
00:38:25,429 --> 00:38:28,990
We can do this in 2D since we are only focusing on heading changes.

608
00:38:30,340 --> 00:38:34,484
By calculating the angle between the vector from the current position to the circle center

609
00:38:34,484 --> 00:38:39,467
and the target position to the circle center, divided by the travel time, we have our turn

610
00:38:39,467 --> 00:38:39,768
speed.

611
00:38:39,768 --> 00:38:46,713
If the desired turn speed is bigger than an adjustable limit, again, we don't ally guidance

612
00:38:46,713 --> 00:38:47,754
to this destination.

613
00:38:47,754 --> 00:38:52,357
The next video will show this jump guidance system in full effect.

614
00:38:55,039 --> 00:38:57,740
In this video, I will pause the game, press the jump button,

615
00:38:57,740 --> 00:39:00,221
and then you can see the original trajectory

616
00:39:00,221 --> 00:39:02,962
as a white line and the predicted trajectory

617
00:39:02,962 --> 00:39:04,543
with a colored line.

618
00:39:04,543 --> 00:39:21,830
The green circle is the circle used

619
00:39:21,830 --> 00:39:23,231
for calculating our turn speed.

620
00:39:24,418 --> 00:39:25,579
It's a really big green line.

621
00:39:25,579 --> 00:39:26,720
I think I can leap onto the tall neck from here.

622
00:39:26,720 --> 00:39:26,920
Made it.

623
00:39:26,920 --> 00:39:47,493
I should be able to jump onto the tall neck from here.

624
00:39:47,493 --> 00:39:48,654
We're almost there now.

625
00:39:48,654 --> 00:39:52,036
The world of Horizon is filled with rock walls like this,

626
00:39:52,036 --> 00:39:54,278
which Aloy can climb without much of a problem.

627
00:39:57,845 --> 00:40:02,207
To give our designers maximum control, Aloy can only climb on annotated geometry.

628
00:40:02,207 --> 00:40:08,510
While climbing, she is physically attached to the geometry at a single point.

629
00:40:08,510 --> 00:40:13,753
While climbing with hands, this attach point is between the hands.

630
00:40:13,753 --> 00:40:17,095
This is also the position where Aloy's trajectory joint is located.

631
00:40:17,095 --> 00:40:21,437
When Aloy is standing on an annotation, the attach point is located between the feet.

632
00:40:25,553 --> 00:40:28,576
We trigger transitional animations when climbing from

633
00:40:28,576 --> 00:40:30,997
one annotation to another.

634
00:40:30,997 --> 00:40:34,380
First of all, we look for all nearby destinations and find

635
00:40:34,380 --> 00:40:37,022
the one that has the best combination

636
00:40:37,022 --> 00:40:39,043
of distance and angle.

637
00:40:39,043 --> 00:40:41,985
Then we go through all our possible transition animations

638
00:40:41,985 --> 00:40:45,648
and currently we have more than 100 of them, and find the

639
00:40:45,648 --> 00:40:49,411
one whose motions would need the least amount of warping.

640
00:40:50,825 --> 00:40:54,186
Each transition has conditions and ranges that we take into

641
00:40:54,186 --> 00:40:57,506
account, and we also check if the transition's motion won't

642
00:40:57,506 --> 00:40:58,547
collide with anything.

643
00:40:58,547 --> 00:41:02,288
And in the end, we will trigger the best transition

644
00:41:02,288 --> 00:41:08,929
that we found and warp it to our founded destination.

645
00:41:08,929 --> 00:41:11,270
During climbing, we use IK on the hands and

646
00:41:11,270 --> 00:41:13,391
feet to guide them.

647
00:41:13,391 --> 00:41:17,292
For the hands, we always make sure they are placed onto the

648
00:41:17,292 --> 00:41:17,452
geometry.

649
00:41:18,592 --> 00:41:24,655
This can either be on the current position or when we are performing a transition on the destination position.

650
00:41:24,655 --> 00:41:31,178
While climbing we also continually check if our feet can be placed against the geometry in front of us.

651
00:41:31,178 --> 00:41:41,004
If no geometry is available at the foot position, the IK on the feet can be turned off and we will let the feet just dangle.

652
00:41:41,004 --> 00:41:45,566
To find the IK rest position we are using multiple collision probes to find an intersection position.

653
00:41:46,603 --> 00:41:50,746
For the hands, we use a slightly tilted probe that goes through the palm of the hands.

654
00:41:50,746 --> 00:41:57,092
And for the feet, we use two sets of collision probes to allow Aloy to pull up her legs a bit more.

655
00:41:57,092 --> 00:42:01,575
Each of the four limbs can be controlled individually.

656
00:42:01,575 --> 00:42:06,719
Our animations control when the hands and feet should be resting on the geometry and when not.

657
00:42:06,719 --> 00:42:11,684
They have an animation event that drives our IKs and also locks the limbs.

658
00:42:11,684 --> 00:42:14,446
The next video shows the probing and IKs in action.

659
00:42:16,448 --> 00:42:20,651
Here Aloy is hanging with IKs enabled on the hand and feet.

660
00:42:20,651 --> 00:42:25,675
The green lines visualize the intersection tests.

661
00:42:25,675 --> 00:42:28,496
Now Aloy is hanging without IKs enabled on the feet.

662
00:42:28,496 --> 00:42:31,999
The red lines visualize there's no valid geometry for her feet

663
00:42:31,999 --> 00:42:32,859
to rest against.

664
00:42:32,859 --> 00:42:38,903
One of the bigger challenges that we

665
00:42:38,903 --> 00:42:42,986
had to support for climbing was climbing on dynamic objects.

666
00:42:43,806 --> 00:42:45,646
such as the toll neck.

667
00:42:45,646 --> 00:42:47,827
For example, not all assets in our game

668
00:42:47,827 --> 00:42:50,408
have the same update frequency.

669
00:42:50,408 --> 00:42:53,248
Aloy, for example, is updated at a higher frequency

670
00:42:53,248 --> 00:42:55,409
than our toll neck.

671
00:42:55,409 --> 00:42:58,249
So when jumping towards a toll neck or climbing on one,

672
00:42:58,249 --> 00:43:01,170
we have to compensate the motion of all the toll neck's

673
00:43:01,170 --> 00:43:03,651
annotation for this difference in update frequency.

674
00:43:03,651 --> 00:43:07,132
Next to that, we also have to correctly apply

675
00:43:07,132 --> 00:43:12,533
the motion of the object we're attached to to Aloy's body.

676
00:43:13,958 --> 00:43:18,021
To make sure our feet and hands are placed correctly on the Climb asset, the collision

677
00:43:18,021 --> 00:43:23,005
probing also needs to be in sync with the desired update frequency.

678
00:43:23,005 --> 00:43:28,629
Since Tonics are updated at a much lower frequency, their collision volumes also move at a much

679
00:43:28,629 --> 00:43:30,511
lower frequency.

680
00:43:30,511 --> 00:43:35,894
So ELOS probing for collision should also be performed at the same lower frequency to

681
00:43:35,894 --> 00:43:37,035
stay in sync.

682
00:43:42,238 --> 00:43:45,679
Well, that brings us to the end of the final section.

683
00:43:45,679 --> 00:43:48,980
Now, I would like to emphasize on what we think worked well

684
00:43:48,980 --> 00:43:51,141
and what didn't work that well.

685
00:43:51,141 --> 00:43:53,121
First of all, what worked really well for us

686
00:43:53,121 --> 00:43:55,322
is having the ability to distinguish

687
00:43:55,322 --> 00:43:57,843
between early reactions and late reactions

688
00:43:57,843 --> 00:44:01,804
when transitioning between animations based on events.

689
00:44:01,804 --> 00:44:04,285
This really allowed us to make the character feel

690
00:44:04,285 --> 00:44:06,225
more responsive and helped us a lot

691
00:44:06,225 --> 00:44:09,847
in improving the overall quality of our movement system.

692
00:44:11,674 --> 00:44:16,476
The abstract text on the annotations that provide semantics for a traversal system allowed

693
00:44:16,476 --> 00:44:21,177
us to create a very reliable jump prediction system as well as a very flexible climbing

694
00:44:21,177 --> 00:44:21,537
system.

695
00:44:21,537 --> 00:44:26,919
Because we select climb transitions based on the required displacement needed to reach

696
00:44:26,919 --> 00:44:32,040
a destination, the climbing system managed to even climb moving dynamic geometry.

697
00:44:33,980 --> 00:44:37,603
In the jump guidance system, there are only two variables to tweak.

698
00:44:37,603 --> 00:44:41,706
We have a maximum change in velocity and a maximum change in turn speed.

699
00:44:41,706 --> 00:44:47,111
Therefore, the designers were able to find their desired balance between snappiness and realism.

700
00:44:47,111 --> 00:44:52,135
A guided trajectory also allows us to already anticipate on the landing,

701
00:44:52,135 --> 00:44:59,241
making it possible to seamlessly blend to a landing animation that fits the destination,

702
00:44:59,241 --> 00:45:01,883
such as toll necks, zip lines, war crawls, etc.

703
00:45:05,171 --> 00:45:07,092
So what didn't work that well?

704
00:45:07,092 --> 00:45:11,194
Because most of our traversal systems and tools were

705
00:45:11,194 --> 00:45:14,616
developed from scratch upon switching from Killzone to

706
00:45:14,616 --> 00:45:19,018
Horizon, our level designers initially didn't have the

707
00:45:19,018 --> 00:45:22,220
visualization and editor tools to optimize areas for

708
00:45:22,220 --> 00:45:23,080
traversability.

709
00:45:23,080 --> 00:45:26,422
Our ambition was to have a lot more traversable paths

710
00:45:26,422 --> 00:45:29,183
throughout the world than what we ended up shipping with.

711
00:45:30,828 --> 00:45:33,512
While the Vault system eventually worked out fine,

712
00:45:33,512 --> 00:45:35,955
it is probably not the best and efficient way

713
00:45:35,955 --> 00:45:37,077
to implement it.

714
00:45:37,077 --> 00:45:40,541
A big improvement would be to also support the navigation

715
00:45:40,541 --> 00:45:43,004
mesh for the player, as this would also

716
00:45:43,004 --> 00:45:44,606
solve other problems as well.

717
00:45:44,606 --> 00:45:47,650
For example, preventing the player from getting stuck

718
00:45:47,650 --> 00:45:49,673
or entering inaccessible areas.

719
00:45:53,063 --> 00:45:56,046
And last but not least, we've reached the point where our

720
00:45:56,046 --> 00:45:59,008
animation networks have become very complex and hard to

721
00:45:59,008 --> 00:45:59,869
maintain.

722
00:45:59,869 --> 00:46:03,131
This is mostly because both programmers as well as

723
00:46:03,131 --> 00:46:05,353
animators alter them.

724
00:46:05,353 --> 00:46:07,955
We are looking into making things more manageable by

725
00:46:07,955 --> 00:46:11,937
moving more of the decision logic from the network to code

726
00:46:11,937 --> 00:46:14,800
as well as applying stricter ownership of the networks.

727
00:46:18,054 --> 00:46:20,615
So what are we thinking of next?

728
00:46:20,615 --> 00:46:23,577
One of the most interesting talks last year at the GDC for

729
00:46:23,577 --> 00:46:26,999
us was the talk by Simon Clavey, Ubisoft Montreal,

730
00:46:26,999 --> 00:46:27,979
about motion matching.

731
00:46:27,979 --> 00:46:32,281
Since there are few similarities with what we've

732
00:46:32,281 --> 00:46:35,183
been exploring for Horizon, we are very interested in

733
00:46:35,183 --> 00:46:39,445
researching some of its possibilities.

734
00:46:39,445 --> 00:46:41,666
As already mentioned, in a small postmortem, we are

735
00:46:41,666 --> 00:46:44,628
probably going to investigate player navigation through the

736
00:46:44,628 --> 00:46:45,728
use of a navigation mesh.

737
00:46:47,660 --> 00:46:52,405
We are also very interested in using full body IK for our various mechanics.

738
00:46:52,405 --> 00:46:59,353
We didn't get to it for Horizon because of time constraints and regular 2 bone IK was giving fine results.

739
00:46:59,353 --> 00:47:02,876
But full body IK sounds like a very useful upgrade.

740
00:47:06,122 --> 00:47:08,824
I would really like to thank everyone at Guerrilla, Team

741
00:47:08,824 --> 00:47:11,546
Traversal, and especially my colleague Thijs Kruijten for

742
00:47:11,546 --> 00:47:13,467
helping preparing this presentation.

743
00:47:13,467 --> 00:47:16,149
Thijs and I have been working a lot together on these

744
00:47:16,149 --> 00:47:18,891
mechanics, and therefore, we'll be joining the stage for

745
00:47:18,891 --> 00:47:19,652
the Q&A sessions.

746
00:47:19,652 --> 00:47:25,016
Finally, I would like to end by thanking you all for your

747
00:47:25,016 --> 00:47:25,896
attention and interest.

748
00:47:25,896 --> 00:47:29,799
Please fill in the feedback form that should have been

749
00:47:29,799 --> 00:47:31,761
sent to your email.

750
00:47:31,761 --> 00:47:34,423
And if anyone has any questions, we will be pleased

751
00:47:34,423 --> 00:47:34,963
to answer them.

752
00:47:49,862 --> 00:47:52,363
uh all right so you mentioned that there was a lot of

753
00:47:52,363 --> 00:47:56,046
annotation of your uh assets that uh either I didn't catch

754
00:47:56,046 --> 00:48:00,068
what those designers or artists had to do. Um. Mostly artists.

755
00:48:00,068 --> 00:48:02,890
Okay. And there was also a lot of uh times where you mentioned

756
00:48:02,890 --> 00:48:06,152
that designers could tweak parameters on like to get a good

757
00:48:06,152 --> 00:48:10,695
balance between realism and and snappiness. Um so my question is

758
00:48:10,695 --> 00:48:14,217
how much of a burden did all that annotation work place on

759
00:48:14,217 --> 00:48:17,980
the designers and artists and how did you mitigate it? Um

760
00:48:18,747 --> 00:48:25,014
Well, the annotations were mostly done in Maya.

761
00:48:25,014 --> 00:48:26,796
And the tweaking of the variables

762
00:48:26,796 --> 00:48:30,220
is happening in our Desma editor.

763
00:48:30,220 --> 00:48:36,046
So there, the designers can tweak the values.

764
00:48:37,115 --> 00:48:39,576
Hi, Zach Toops, New Mexico State.

765
00:48:39,576 --> 00:48:41,197
This is great, thanks.

766
00:48:41,197 --> 00:48:45,040
I was wondering how you kind of signal to players

767
00:48:45,040 --> 00:48:48,022
sort of like where they're going to land

768
00:48:48,022 --> 00:48:49,883
since you're sort of dynamically adjusting.

769
00:48:49,883 --> 00:48:52,305
And I heard in one of the videos her kind of like saying,

770
00:48:52,305 --> 00:48:54,246
oh, I could jump to that from here.

771
00:48:54,246 --> 00:48:56,548
Is that kind of one of the ways you did that?

772
00:48:56,548 --> 00:48:59,530
And did you use your dynamic adjustment system

773
00:48:59,530 --> 00:49:02,732
to kind of like contextually change that?

774
00:49:02,732 --> 00:49:06,394
Are you wondering how we make it clear for the player?

775
00:49:06,781 --> 00:49:09,944
Yeah, if I'm playing, how do I know where I'm going to land

776
00:49:09,944 --> 00:49:12,346
when I try to jump on something?

777
00:49:12,346 --> 00:49:13,847
It's mostly intuitive.

778
00:49:13,847 --> 00:49:19,052
It's like only when it's within your forward movement,

779
00:49:19,052 --> 00:49:19,792
we adjust you there.

780
00:49:19,792 --> 00:49:22,915
So it's never really like a surprise

781
00:49:22,915 --> 00:49:25,237
that you'll land somewhere.

782
00:49:25,237 --> 00:49:27,279
So because it's in your path, it should already

783
00:49:27,279 --> 00:49:30,242
be clear that that's the location you'll end up at.

784
00:49:30,751 --> 00:49:33,173
But did you ever kind of run into any issues where it was

785
00:49:33,173 --> 00:49:36,956
just a little bit further than you kind of allowed it to be?

786
00:49:36,956 --> 00:49:38,838
I mean, is this something that came up in play testing?

787
00:49:38,838 --> 00:49:41,019
Or did it just kind of seem to work all around?

788
00:49:41,019 --> 00:49:43,762
I think it's mostly a matter of tweaking.

789
00:49:43,762 --> 00:49:47,525
We tweaked everything so it's exactly intuitive, and it's

790
00:49:47,525 --> 00:49:48,205
never too snappy.

791
00:49:48,205 --> 00:49:51,108
Because that's the thing we want to prevent.

792
00:49:51,108 --> 00:49:54,270
You don't want the player to suddenly grab a ledge that

793
00:49:54,270 --> 00:49:56,492
you didn't want to grab at all.

794
00:49:56,492 --> 00:49:57,573
Thanks.

795
00:49:59,593 --> 00:50:07,361
Hello. Thank you for the presentation. It was great, very informative for me.

796
00:50:07,361 --> 00:50:15,948
And what was the reason for not using navigation meshes?

797
00:50:15,948 --> 00:50:20,232
Well, mostly for memory budget reasons, we didn't have one for the player.

798
00:50:26,012 --> 00:50:27,773
All right, I guess me.

799
00:50:27,773 --> 00:50:28,153
Hi.

800
00:50:28,153 --> 00:50:31,475
So you talked about the annotation system and a little

801
00:50:31,475 --> 00:50:33,355
bit about how designers or artists had to

802
00:50:33,355 --> 00:50:34,176
interact with that.

803
00:50:34,176 --> 00:50:37,517
Did you ever put any thought into using auto-generating

804
00:50:37,517 --> 00:50:41,099
some of that information by doing pre-physics tests as a

805
00:50:41,099 --> 00:50:43,920
process on assets they had brought in?

806
00:50:43,920 --> 00:50:46,661
I'm curious if you had considered that and rejected

807
00:50:46,661 --> 00:50:47,841
it, or time constraints, et cetera.

808
00:50:48,588 --> 00:50:51,649
We actually did some experiments with that.

809
00:50:51,649 --> 00:50:54,990
And it turned out that it was quite OK.

810
00:50:54,990 --> 00:51:01,273
But we also like to have total control, mostly

811
00:51:01,273 --> 00:51:02,273
from the design side.

812
00:51:02,273 --> 00:51:06,675
They wanted to have total control over traversal paths.

813
00:51:06,675 --> 00:51:11,377
Apparently, we didn't want to have a world where you could

814
00:51:11,377 --> 00:51:12,838
just climb everywhere.

815
00:51:12,838 --> 00:51:15,399
That's kind of mostly a design decision.

816
00:51:15,399 --> 00:51:17,740
Cool, thank you very much.

817
00:51:19,510 --> 00:51:25,435
Hi, thanks for the talk, really informative, really thorough.

818
00:51:25,435 --> 00:51:29,098
You talked at one point when mantling normal obstacles,

819
00:51:29,098 --> 00:51:31,600
you could do left or right handed.

820
00:51:31,600 --> 00:51:37,024
Was that all randomized or did you analyze based

821
00:51:37,024 --> 00:51:38,205
on the shape of the object?

822
00:51:38,745 --> 00:51:42,788
Well, we have various variations for the different heights,

823
00:51:42,788 --> 00:51:45,650
but I think for every height,

824
00:51:45,650 --> 00:51:47,471
we have a couple of variations.

825
00:51:47,471 --> 00:51:49,613
So then we have a left hand and a right hand,

826
00:51:49,613 --> 00:51:53,055
and that's actually just completely random.

827
00:51:53,055 --> 00:51:55,697
Got you. Was there any thought to maybe having

828
00:51:55,697 --> 00:51:57,739
that as part of the selection parameters?

829
00:51:57,739 --> 00:52:01,962
Maybe with the angled log,

830
00:52:01,962 --> 00:52:04,804
the left hand being higher up would

831
00:52:04,804 --> 00:52:07,446
be a little more natural than the right hand.

832
00:52:08,314 --> 00:52:10,915
Like was there thought with that or?

833
00:52:10,915 --> 00:52:11,815
Well, not really.

834
00:52:11,815 --> 00:52:13,496
That's not how it works in our case.

835
00:52:13,496 --> 00:52:13,976
Gotcha, thanks.

836
00:52:13,976 --> 00:52:15,177
That was actually the question I was gonna ask.

837
00:52:15,177 --> 00:52:15,737
But I have another one.

838
00:52:15,737 --> 00:52:16,397
So with a lot of this,

839
00:52:16,397 --> 00:52:19,318
like with the vault traversals and stuff,

840
00:52:19,318 --> 00:52:23,700
it seems like it could have been used pretty easily

841
00:52:23,700 --> 00:52:24,141
on NPCs.

842
00:52:24,141 --> 00:52:27,582
Did you give that any consideration or try it

843
00:52:27,582 --> 00:52:32,604
or clearly out of the picture?

844
00:52:32,604 --> 00:52:35,626
I think we did do some experiments with it.

845
00:52:37,651 --> 00:52:40,973
I don't actually know why we never went that way.

846
00:52:41,178 --> 00:52:46,700
Currently the fault system is pretty expensive because we do a lot of physics probing everywhere.

847
00:52:46,700 --> 00:52:51,402
So if we enable that on NPCs then it becomes, yeah,

848
00:52:51,402 --> 00:52:56,004
then we're probably not going to hit that 30 FPS requirement.

849
00:52:56,004 --> 00:52:58,765
But like the NPCs are attached to a navigation mesh,

850
00:52:58,765 --> 00:53:03,607
but because of time constraints we never made a fault system based on the navigation mesh.

851
00:53:03,607 --> 00:53:04,967
But that could be a next step.

852
00:53:04,967 --> 00:53:07,268
I mean you could just like put boulders in front of them

853
00:53:07,268 --> 00:53:09,429
and not mark them out of the navigation mesh and they just...

854
00:53:10,114 --> 00:53:11,976
go right through them with this system.

855
00:53:11,976 --> 00:53:13,717
Yeah, could be.

856
00:53:13,717 --> 00:53:16,019
But yeah, because of time constraints,

857
00:53:16,019 --> 00:53:18,821
we haven't actually done anything with NPCs and vaulting.

858
00:53:18,821 --> 00:53:19,222
OK.

859
00:53:19,222 --> 00:53:20,363
Thanks.

860
00:53:22,192 --> 00:53:34,302
Hi, thank you for the great talk. I have a question. You mentioned that you detect if the obstacle is deep enough to climb it by ray casting before the player.

861
00:53:34,302 --> 00:53:41,288
So didn't you have a problem with really narrow shelves when the player is moving almost parallel to the shelf?

862
00:53:41,288 --> 00:53:47,893
So the rays would all hit the shelf, but it's really very, very narrow.

863
00:53:50,686 --> 00:53:55,409
Yeah, well, currently, I think the minimum depth

864
00:53:55,409 --> 00:53:58,791
of an obstacle is something around 30 centimeters,

865
00:53:58,791 --> 00:54:01,153
and that's also where the first race starts.

866
00:54:01,153 --> 00:54:02,414
So that's how we are.

867
00:54:02,414 --> 00:54:06,256
And yeah, otherwise, the whole system won't work.

868
00:54:06,256 --> 00:54:07,637
So then you don't jump over it.

869
00:54:08,159 --> 00:54:15,085
Okay, but do you put some special constraints on how the geometry must be constructed?

870
00:54:15,085 --> 00:54:20,070
Or artists were free to create anything?

871
00:54:20,070 --> 00:54:24,353
At Guerrilla, most of the time our artists don't have constraints.

872
00:54:24,353 --> 00:54:25,915
Like, they can do whatever they want.

873
00:54:25,915 --> 00:54:29,578
And we have to make sure that our systems are working.

874
00:54:29,578 --> 00:54:30,179
Okay, thank you.

875
00:54:34,028 --> 00:54:37,872
You mentioned that vaulting was automatic and didn't require any player input

876
00:54:37,872 --> 00:54:44,179
Basically just as long as they're moving along they would automatically vault over obstacles. I'm curious how you protected the player from

877
00:54:44,179 --> 00:54:52,007
Accidentally triggering a vault on like objects. Maybe they didn't intend to vault over like a small wall. They're running alongside or something

878
00:54:52,007 --> 00:54:54,770
We do have like

879
00:54:58,088 --> 00:55:00,590
methods of excluding vaulting over objects.

880
00:55:00,590 --> 00:55:03,033
You can mark them as unvaultable,

881
00:55:03,033 --> 00:55:07,617
you can put them in a volume that excludes all vaulting.

882
00:55:07,617 --> 00:55:09,780
So we have exclusion options there.

883
00:55:09,780 --> 00:55:10,300
Okay, thank you.

884
00:55:10,300 --> 00:55:10,340
Hi.

885
00:55:10,340 --> 00:55:10,961
Thank you, great talk.

886
00:55:10,961 --> 00:55:12,002
I'm also interested in using a full-body IK in the future.

887
00:55:22,780 --> 00:55:26,062
What would be a benefit you get from using full body IK

888
00:55:26,062 --> 00:55:27,222
for next game?

889
00:55:27,222 --> 00:55:30,243
For us currently, it's for example,

890
00:55:30,243 --> 00:55:34,045
really interested in the melee combat system.

891
00:55:34,045 --> 00:55:36,806
So currently, we just blend a couple of animations

892
00:55:36,806 --> 00:55:38,427
to reach a certain height.

893
00:55:38,427 --> 00:55:41,808
But that would be perfect for full body animations.

894
00:55:41,808 --> 00:55:47,750
But also, like having full body animations for on steep slopes

895
00:55:47,750 --> 00:55:49,031
and that kind of things.

896
00:55:49,031 --> 00:55:49,351
Thank you.

897
00:55:54,157 --> 00:56:00,179
Hey guys, when you were talking about the climbing, you mentioned that some of the NPCs

898
00:56:00,179 --> 00:56:05,842
are updated with lower frequency and when Aloy is climbing on them, you basically dump

899
00:56:05,842 --> 00:56:06,362
her down as well.

900
00:56:06,362 --> 00:56:12,364
Did you try to bump up the update frequency of the NPCs rather than...

901
00:56:15,935 --> 00:56:22,199
We didn't want to do that because that will increase the performance cost.

902
00:56:22,199 --> 00:56:28,243
If you only do that just because you want to know where the annotations are, it's quite

903
00:56:28,243 --> 00:56:30,945
high penalty to pay.

904
00:56:30,945 --> 00:56:33,086
So it was just performance reasons.

905
00:56:33,086 --> 00:56:33,667
Yeah.

906
00:56:33,667 --> 00:56:34,267
Okay, cool.

907
00:56:39,867 --> 00:56:48,829
I wanted to know at the runtime level, why did you use morpheme and what tasks you delegated

908
00:56:48,829 --> 00:56:50,970
to this middleware?

909
00:56:50,970 --> 00:56:59,252
Because in all of what you described, you're telling how you programmed the animation,

910
00:56:59,252 --> 00:57:02,473
but what did morpheme, the runtime part, what did it do?

911
00:57:03,457 --> 00:57:04,939
And what did you make it do?

912
00:57:04,939 --> 00:57:07,964
The runtime code is just a part of Morpheme.

913
00:57:07,964 --> 00:57:10,407
And that's just integrated into our DECIMA engine.

914
00:57:10,407 --> 00:57:12,531
So that handles the runtime playback

915
00:57:12,531 --> 00:57:16,096
of the animation networks.

916
00:57:16,096 --> 00:57:16,998
Is that what you meant?

917
00:57:20,059 --> 00:57:22,602
Not really.

918
00:57:22,602 --> 00:57:27,066
For example, when you cook your animation assets

919
00:57:27,066 --> 00:57:31,291
from a Maya motion builder, you go through first a cooking

920
00:57:31,291 --> 00:57:32,592
step in Morphine, right?

921
00:57:32,592 --> 00:57:33,453
That's what you showed.

922
00:57:33,453 --> 00:57:36,016
And what does it do?

923
00:57:36,016 --> 00:57:39,299
And at runtime, what couldn't you do?

924
00:57:39,299 --> 00:57:42,863
And what did this middleware do for you?

925
00:57:42,863 --> 00:57:43,663
I'm not sure if I'm clear.

926
00:57:44,577 --> 00:57:47,838
So Morphium is two parts.

927
00:57:47,838 --> 00:57:51,739
It's an altering tool that allows you to import animations

928
00:57:51,739 --> 00:57:55,320
from Maya Motion Builder and make a whole blending tree

929
00:57:55,320 --> 00:57:57,101
and state machine for it.

930
00:57:57,101 --> 00:58:00,002
And then you have a runtime engine,

931
00:58:00,002 --> 00:58:04,863
which is capable of playing back those state machines

932
00:58:04,863 --> 00:58:10,165
and blend trees and basically providing a pose

933
00:58:10,165 --> 00:58:13,486
at any frame for any frame.

934
00:58:16,724 --> 00:58:23,950
Hi, I was just wondering if you used any physics animation on her body, or was it all full body animation?

935
00:58:23,950 --> 00:58:31,336
Yeah, currently we have three physics states, so we have soft key, hard key and we have ragdolls.

936
00:58:33,417 --> 00:58:35,918
Hey, thanks for the talk.

937
00:58:35,918 --> 00:58:37,839
You talked about your annotation system

938
00:58:37,839 --> 00:58:41,740
that you used for marking up the environment for climbing.

939
00:58:41,740 --> 00:58:44,181
But for the vaulting, it sounds like it's

940
00:58:44,181 --> 00:58:45,421
using a different system.

941
00:58:45,421 --> 00:58:49,422
So I'm wondering why you're not using annotations as well

942
00:58:49,422 --> 00:58:50,523
for the vaulting system.

943
00:58:53,299 --> 00:58:56,981
Well, we wanted our fault system to be completely dynamic.

944
00:58:56,981 --> 00:58:59,763
For example, when you kill a big raptor, it will lose all

945
00:58:59,763 --> 00:59:00,463
of its parts.

946
00:59:00,463 --> 00:59:03,305
And then if you run up to it, it will automatically work,

947
00:59:03,305 --> 00:59:05,306
because we have those physics probes.

948
00:59:05,306 --> 00:59:12,050
And we don't want to have our artist also annotate all the

949
00:59:12,050 --> 00:59:14,471
geometry in the world to also make the faulting possible.

950
00:59:14,471 --> 00:59:16,873
So we had to come up with a dynamic system.

951
00:59:16,873 --> 00:59:17,313
Thanks.

952
00:59:23,570 --> 00:59:26,672
I was just curious about your AI nav meshes.

953
00:59:26,672 --> 00:59:30,274
Was that restricted to smaller areas

954
00:59:30,274 --> 00:59:32,836
that allowed you to get away with using the memory for that,

955
00:59:32,836 --> 00:59:36,038
or compared to the physics you had for the player

956
00:59:36,038 --> 00:59:37,279
instead of a nav mesh there?

957
00:59:37,279 --> 00:59:43,383
Well, we don't know much about the navigation mesh for the AI.

958
00:59:43,383 --> 00:59:47,045
I know it's just generated,

959
00:59:47,045 --> 00:59:50,588
but I don't know exactly how it is.

960
00:59:50,789 --> 00:59:54,211
how it's implemented or generated.

961
00:59:54,211 --> 00:59:57,753
Well, I mean, it was too much of a memory cost

962
00:59:57,753 --> 00:59:59,994
for you to put on Aloy, right?

963
00:59:59,994 --> 01:00:01,995
So, but the NPCs were okay.

964
01:00:01,995 --> 01:00:03,656
Yeah, NPCs have a navigation mesh,

965
01:00:03,656 --> 01:00:06,798
but like Aloy can currently traverse the whole world,

966
01:00:06,798 --> 01:00:08,959
so also on the really steep slopes

967
01:00:08,959 --> 01:00:14,122
and like the navigation mesh is a bit constrained

968
01:00:14,122 --> 01:00:17,064
to like smaller, flatter terrain, so.

969
01:00:17,064 --> 01:00:18,865
So it's much more coarse, basically.

970
01:00:18,865 --> 01:00:19,425
Yeah, yeah.

971
01:00:19,425 --> 01:00:19,986
Okay, I think, yeah.

972
01:00:19,986 --> 01:00:20,486
Got it.

973
01:00:24,246 --> 01:00:24,449
OK.

974
01:00:24,449 --> 01:00:25,220
Thank you.

975
01:00:25,220 --> 01:00:25,464
Thank you.

