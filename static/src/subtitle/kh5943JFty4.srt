1
00:00:04,987 --> 00:00:08,670
I'm Alex, I'm one of the co-founders and the CTO at Servius.

2
00:00:09,330 --> 00:00:13,814
Today I'll be talking about just generally our tech stack, how it developed.

3
00:00:16,920 --> 00:00:22,445
I'm trying to give advice for how we learned to generally make it flexible and extensible

4
00:00:22,525 --> 00:00:27,388
for cross-platform VR game development across multiple games and genres.

5
00:00:27,528 --> 00:00:32,112
Lots of it is based on the mistakes that we made that we learned from, so hopefully you

6
00:00:32,132 --> 00:00:33,613
guys can avoid some of those mistakes.

7
00:00:34,394 --> 00:00:39,157
And just some examples of some of the technologies that we've developed over the last few years

8
00:00:39,217 --> 00:00:42,520
and how they helped us get where we are today.

9
00:00:44,068 --> 00:00:47,029
So some of our previous titles that you may have heard of,

10
00:00:47,109 --> 00:00:51,051
Raw Data, it's a FPS sci-fi shooter.

11
00:00:51,111 --> 00:00:52,111
Those videos are playing, right?

12
00:00:52,651 --> 00:00:53,832
There, cool.

13
00:00:53,852 --> 00:00:57,033
Sci-fi shooter, hero-based combat.

14
00:00:57,893 --> 00:00:58,793
That was our first title.

15
00:00:58,853 --> 00:00:59,914
Then we made Spring Vector,

16
00:00:59,974 --> 00:01:02,835
which is sort of a Mario Kart racer

17
00:01:02,895 --> 00:01:07,917
that has this locomotion system we call fluid locomotion

18
00:01:08,137 --> 00:01:09,458
that has a whole bunch of different moves.

19
00:01:10,358 --> 00:01:15,401
Electronauts, EDM, Remix, kind of experience application.

20
00:01:16,641 --> 00:01:19,983
Creed is a boxing game based on the Creed movie IP.

21
00:01:21,464 --> 00:01:24,646
So in general, we've always been interested in motion control,

22
00:01:24,726 --> 00:01:28,548
driven mechanics, and see how we can create unique experiences

23
00:01:28,928 --> 00:01:30,469
using VR hardware.

24
00:01:32,730 --> 00:01:36,532
And the last two titles that we recently released this year

25
00:01:37,293 --> 00:01:39,374
is Battle Wake, which is a

26
00:01:40,165 --> 00:01:41,805
Pirate Ship Combat Game.

27
00:01:42,906 --> 00:01:46,928
So vehicular locomotion on the ocean

28
00:01:47,608 --> 00:01:50,049
with other ships that you're shooting at

29
00:01:50,069 --> 00:01:51,750
and using different abilities against those ships.

30
00:01:52,751 --> 00:01:54,231
And also Westworld Awakening,

31
00:01:54,651 --> 00:01:57,313
which is based on the Westworld IP

32
00:01:57,993 --> 00:02:00,554
and it's set in the actual Westworld world.

33
00:02:00,894 --> 00:02:02,175
And it was a collaboration with HBO.

34
00:02:04,712 --> 00:02:08,376
So, raw data, this is the first game that we released.

35
00:02:08,656 --> 00:02:12,159
There was a long kind of development cycle with a lot of iteration.

36
00:02:13,740 --> 00:02:19,085
A lot of the stuff that went into it, we actually started working in Unity.

37
00:02:19,185 --> 00:02:23,830
So this is going to be a pretty Unreal-heavy talk, because as we transitioned to Unreal,

38
00:02:23,850 --> 00:02:26,472
a lot of our existing tech has moved to Unreal.

39
00:02:26,993 --> 00:02:28,654
We started working in Unity originally, so...

40
00:02:31,936 --> 00:02:36,078
A lot of our knowledge kind of transitioned to Unreal and gave us a chance to rewrite that and improve on it.

41
00:02:36,378 --> 00:02:42,260
And some of the most foundational pieces of tech that we developed even back in Unity days is this interaction system.

42
00:02:42,620 --> 00:02:47,182
I mean that's pretty key to making a VR experience with motion controller mechanics,

43
00:02:47,623 --> 00:02:50,444
using your hands to interact with the world.

44
00:02:50,504 --> 00:02:56,946
The interaction system that I'm referring to here is really how we set up the

45
00:02:59,068 --> 00:03:02,257
I guess the association between the player interacting with something in the world, like

46
00:03:02,277 --> 00:03:04,744
the starting of the interaction and the stopping of the interaction.

47
00:03:06,086 --> 00:03:09,288
There's a lot of different components and movable pieces that are in the system.

48
00:03:10,589 --> 00:03:17,313
Particularly, one set of objects live on the character side, the other set of objects live on the interaction side.

49
00:03:17,753 --> 00:03:23,257
On the character side, we have obviously the avatar that has these avatar hands that have these interactor components.

50
00:03:24,358 --> 00:03:28,261
Within the interactor components, they have a slew of what are called initiators.

51
00:03:28,641 --> 00:03:31,863
So these are objects that are responsible for setting up...

52
00:03:33,104 --> 00:03:36,325
Essentially, the paradigm of how an interaction starts.

53
00:03:36,345 --> 00:03:38,366
So most simple example is pressing a button.

54
00:03:39,046 --> 00:03:41,447
But you can create, it's a base abstract class,

55
00:03:41,467 --> 00:03:43,428
so you can create any kind of implementation you want.

56
00:03:43,468 --> 00:03:45,129
So for example, even something based on touch.

57
00:03:45,329 --> 00:03:47,330
So a typical example is like a hand scanner.

58
00:03:47,390 --> 00:03:48,931
If I put my hand on a hand scanner,

59
00:03:49,291 --> 00:03:51,032
then interaction is just going to automatically start.

60
00:03:52,930 --> 00:04:10,374
And then the initiators themselves, sorry if my programming names aren't great, I keep trying to rename these things, but they're they have these surveyors, they essentially survey the world for interactions and range so they're responsible for setting up how you find an attraction that can be initiated.

61
00:04:12,859 --> 00:04:17,001
So a simple example is something close to the hand or potentially shooting a ray from

62
00:04:17,021 --> 00:04:17,401
your hand.

63
00:04:18,361 --> 00:04:23,344
But this is once again a very abstract kind of interface up to the game to decide how

64
00:04:23,364 --> 00:04:28,126
we want to implement these and what initiators are set up, connected to what surveyors.

65
00:04:29,015 --> 00:04:34,157
On the interaction side, we have the root interaction actor that has these interaction

66
00:04:34,197 --> 00:04:34,678
controllers.

67
00:04:34,998 --> 00:04:38,439
So the controllers serve the purpose of grouping hand grips together.

68
00:04:38,459 --> 00:04:41,961
And these are the hand grips that an interactor actually interacts with.

69
00:04:43,342 --> 00:04:47,764
So typical interaction, you will actually grab a hand grip, essentially, in the world.

70
00:04:49,785 --> 00:04:55,028
And the controllers also define what initiators they respond to and what kind of surveyables

71
00:04:55,068 --> 00:04:57,969
they have, which let them be discovered by the surveyors.

72
00:04:59,390 --> 00:05:06,091
So this is a fairly flexible architecture that has let us do all interactions from all our games going forward.

73
00:05:06,231 --> 00:05:14,273
I mean, we've been continuously improving it, obviously, but just breaking it up into these pieces has helped us generally keep it very flexible.

74
00:05:14,773 --> 00:05:17,354
So the other part of this is the interaction positioning system.

75
00:05:18,134 --> 00:05:21,215
So once the interaction starts, the question is what happens.

76
00:05:21,315 --> 00:05:25,156
So a typical example of interaction will be you holding an object.

77
00:05:25,816 --> 00:05:29,658
So this is kind of a tree-based hierarchical architecture that we built,

78
00:05:30,798 --> 00:05:35,021
where you essentially, the positionable nodes are connected together.

79
00:05:35,901 --> 00:05:40,523
There's constraints, or a list of constraints that you can assign between these connections.

80
00:05:41,270 --> 00:05:47,854
So, and this allows us to do things like a shotgun, where it has just a, you know, a trigger grip, but it also has a pump controller.

81
00:05:48,794 --> 00:05:55,558
The pump is attached to essentially the pump controller, and there's a linear constraint that the designers can set how much it moves.

82
00:05:56,379 --> 00:05:58,320
And there's a grip that's attached to the pump controller.

83
00:05:59,070 --> 00:06:03,854
Now our constraints also fire events, like when they hit different limits, so it's very

84
00:06:03,894 --> 00:06:08,797
easy to then use this to set up logic in the shotgun to respond to the events of it hitting

85
00:06:08,837 --> 00:06:11,038
the different limits to basically like cock the shotgun.

86
00:06:11,919 --> 00:06:15,841
But this is also reusable for like say a slide wheel switch where we have the...

87
00:06:17,042 --> 00:06:18,982
It's a slightly more, I guess, complicated example

88
00:06:19,042 --> 00:06:23,124
where the grip itself also has a constraint to the controller.

89
00:06:23,704 --> 00:06:25,064
And we can set up a constraint that

90
00:06:25,164 --> 00:06:28,385
lets the hand go parallel to the grip

91
00:06:28,425 --> 00:06:30,846
and even rotate around the grip so

92
00:06:30,866 --> 00:06:33,787
that you can get a much more natural rotation

93
00:06:33,807 --> 00:06:34,747
and position around the grip.

94
00:06:35,588 --> 00:06:39,469
So all these elements, all these components

95
00:06:39,489 --> 00:06:41,670
are kind of reusable and just tunable in the editor.

96
00:06:41,810 --> 00:06:44,010
And you can put these pieces together however you want.

97
00:06:46,490 --> 00:06:51,051
And another system that we started developing back from those days is the marionette.

98
00:06:52,192 --> 00:06:55,033
This is basically a procedural IK animation solution.

99
00:06:56,693 --> 00:07:00,755
So, driving the entire characters animation based on the head and hands.

100
00:07:01,795 --> 00:07:06,117
And I would say the foot placement particularly in raw data was still pretty rough.

101
00:07:06,257 --> 00:07:06,817
That was actually...

102
00:07:07,448 --> 00:07:12,212
The marionette was mainly written by our director of research who came on.

103
00:07:13,033 --> 00:07:16,896
The foot placement, I'm going to have to admit, was written by me back then.

104
00:07:17,817 --> 00:07:20,820
He has now polished it up and made it much better in Battlewake.

105
00:07:21,380 --> 00:07:24,603
So if you play Battlewake, you'll see yourself standing around the table, messing around

106
00:07:24,623 --> 00:07:27,645
with other people, and you'll see a much more polished foot placement.

107
00:07:30,301 --> 00:07:36,746
Weapon system is another core system that we developed in raw data that we have basically continued to use to this day in all our games.

108
00:07:38,067 --> 00:07:42,671
It's flexible enough to even use for you know the in-spam vector when you shoot things out of your hands.

109
00:07:42,811 --> 00:07:49,317
That's still the weapon system, and it's still also driving all the weapons in our battle wake, and it's also fairly modular.

110
00:07:50,898 --> 00:07:54,101
We broke it up into different components so that once again game can

111
00:07:54,601 --> 00:07:56,503
The first thing that we're going to look at is the fire mode.

112
00:07:56,523 --> 00:07:59,506
So fire mode is basically a fire mode that defines completely different systems as long as it implements interface.

113
00:07:59,727 --> 00:08:08,877
So one core part of it is a fire mode component that defines essentially the behavior of when it tries to do damage.

114
00:08:09,037 --> 00:08:13,903
So the most typical one is automatic, you hold the trigger down or just keep firing at a constant rate.

115
00:08:14,455 --> 00:08:16,037
You can implement burst fire that way.

116
00:08:16,157 --> 00:08:17,418
You can also implement spooling.

117
00:08:17,978 --> 00:08:19,159
You can implement charge shot.

118
00:08:19,659 --> 00:08:22,582
Charge shot entailing you holding the trigger down,

119
00:08:22,822 --> 00:08:24,083
charges up shot, and you shoot it.

120
00:08:24,643 --> 00:08:26,245
And nice thing here is in raw data,

121
00:08:26,305 --> 00:08:28,386
like our guns could actually go between different modes

122
00:08:29,707 --> 00:08:30,748
because of your different powers.

123
00:08:30,948 --> 00:08:33,130
So once again, encapsulating that in a separate component

124
00:08:33,190 --> 00:08:36,173
allowed the weapon to just completely transform

125
00:08:36,233 --> 00:08:38,274
its behavior by just switching what fire mode component

126
00:08:38,294 --> 00:08:38,775
it was using.

127
00:08:39,450 --> 00:08:52,623
And the FireMirror component talks to our Damager component, which is, once again, just a base interface that just responds to some simple API, like tryDamage, and it's up to it to determine what to do, how to detect something that can be damaged.

128
00:08:53,303 --> 00:08:55,445
RayTraced is a very simple implementation of that.

129
00:08:57,047 --> 00:08:59,009
but that it can be further extended for,

130
00:08:59,350 --> 00:09:00,912
you know, we implemented penetrating damage.

131
00:09:01,192 --> 00:09:02,894
So it wasn't just a simple hit scan,

132
00:09:02,934 --> 00:09:08,040
but it actually did a multi-trace and decreased damage

133
00:09:08,080 --> 00:09:10,123
as it would go through different materials.

134
00:09:10,143 --> 00:09:12,986
And then there's also projectile implementation,

135
00:09:13,066 --> 00:09:14,708
which is spawned projectile actor

136
00:09:14,768 --> 00:09:15,990
that's simulated through the world.

137
00:09:16,750 --> 00:09:21,994
Volume based is also a simple notation where if you want to do like a flamethrower, etc.

138
00:09:22,374 --> 00:09:27,457
Then there's an ammo system that's also decoupled that hooks into this and a firing effect system.

139
00:09:28,017 --> 00:09:33,821
So all these are fairly decoupled and by breaking it up into these different pieces,

140
00:09:33,861 --> 00:09:37,643
we're able to reuse this for our AI and even just autonomous turrets.

141
00:09:38,684 --> 00:09:42,906
Or even in Spring Vector, there's like traps that in the world that

142
00:09:43,628 --> 00:09:45,034
You try to dodge.

143
00:09:45,777 --> 00:09:48,609
So on the flip side, this is when we started developing our damage systems.

144
00:09:50,119 --> 00:09:51,620
One part of it is a damageable component.

145
00:09:52,421 --> 00:09:57,725
So the damageable component allowed you to author, essentially, the damageable attributes

146
00:09:57,965 --> 00:10:00,167
on a per-body region basis.

147
00:10:01,588 --> 00:10:05,711
There's a damage asset that's associated, essentially, and it can be reused by different

148
00:10:05,731 --> 00:10:06,191
characters.

149
00:10:07,472 --> 00:10:12,876
And it also is had a – the damageable attribute is a fairly abstract class that you can inherit

150
00:10:13,016 --> 00:10:16,479
that can essentially override how damage is dealt.

151
00:10:16,579 --> 00:10:18,821
So you could make, like, an armor attribute or –

152
00:10:19,671 --> 00:10:23,532
potentially something that responds differently to different kind of elemental damage.

153
00:10:24,332 --> 00:10:29,014
And this allowed us to support dismemberment headshots because now we can track

154
00:10:29,534 --> 00:10:32,775
essentially health on a per-damageable body basis.

155
00:10:34,195 --> 00:10:36,556
Additionally, this is when we started developing a hit reaction system.

156
00:10:36,876 --> 00:10:40,777
So this allows you to essentially associate the damage events to an appropriate response.

157
00:10:42,479 --> 00:10:44,139
Most basic is plain animation.

158
00:10:44,320 --> 00:10:47,401
So now our animators can make, for example,

159
00:10:47,441 --> 00:10:48,782
an animation for you getting shot

160
00:10:49,022 --> 00:10:51,464
with a shotgun in the chest versus getting shot

161
00:10:51,784 --> 00:10:52,784
in your arm with a pistol.

162
00:10:53,625 --> 00:10:57,827
And this allows the designers to author how these are connected.

163
00:10:58,688 --> 00:11:00,329
Other properties that you can trigger

164
00:11:00,629 --> 00:11:04,031
is ragdoll physicalization, partial ragdoll

165
00:11:04,351 --> 00:11:07,433
or in what the impulses are, or potentially

166
00:11:07,493 --> 00:11:09,654
whether it causes a dismemberment event or a gib

167
00:11:09,694 --> 00:11:10,454
event even.

168
00:11:11,575 --> 00:11:27,885
And another example is it allows you to, for example, rotate according to damage direction so that if we have an animation of you getting knocked back, for those cases we actually want you to rotate the hit entity to face towards the hit direction so that the animation can properly push them in that direction.

169
00:11:29,184 --> 00:11:30,566
So this is a system we are actually currently

170
00:11:30,767 --> 00:11:32,329
heavily refactoring for our next title

171
00:11:33,130 --> 00:11:34,732
because it just became just one giant mess

172
00:11:34,833 --> 00:11:36,916
and we are modularizing it much more

173
00:11:37,236 --> 00:11:40,621
so that it's made out of these hit reaction modules

174
00:11:40,701 --> 00:11:42,203
that are edit inline new objects,

175
00:11:42,283 --> 00:11:43,365
if you're familiar with Unreal.

176
00:11:44,526 --> 00:11:50,911
So that we can, like one big part of this is selecting what the hit reaction is and the other one part is triggering it.

177
00:11:51,411 --> 00:12:00,457
So by breaking these up into modules, we are, instead of having this one giant object that every game was trying to stick new things, it just became giant up to six things.

178
00:12:00,617 --> 00:12:02,999
We're breaking it up so then you can have like a ragdoll module.

179
00:12:03,319 --> 00:12:04,800
You're going to have an animation module.

180
00:12:05,121 --> 00:12:07,603
And that thing can also tell you what the waiting is

181
00:12:07,663 --> 00:12:10,505
to determine whether that hit reaction should be picked.

182
00:12:12,887 --> 00:12:15,028
So this is our first title, and it was also multiplayer.

183
00:12:15,409 --> 00:12:19,552
So we've built most of our system with multiplayer in mind.

184
00:12:20,012 --> 00:12:24,876
Multiplayer is not something you want to add on mid-development.

185
00:12:24,916 --> 00:12:26,918
You're going to end up realizing some of your design decisions

186
00:12:26,958 --> 00:12:28,679
just don't make sense for multiplayer, don't work.

187
00:12:28,759 --> 00:12:30,160
You're going to end up rewriting your systems.

188
00:12:32,382 --> 00:12:41,787
So it really helps that we build our systems with multiplier in mind because now we have this whole family of systems that we can plug in and create new kind of multiplier experiences.

189
00:12:41,807 --> 00:12:47,810
This is when we also start working on some of our backend services. We have our own dedicated service solution hosted on AWS.

190
00:12:49,143 --> 00:12:57,407
This does allow us to do PC cross platform between Oculus and and Vive stores and just today actually was shipped the Vive port.

191
00:12:58,707 --> 00:13:02,989
Battlewake update, so that we can do it with the Vive port as well.

192
00:13:03,830 --> 00:13:09,152
PSVR is something we really want to support and obviously quest in the future, something we're looking at something you have to keep in mind though.

193
00:13:10,132 --> 00:13:17,555
Not only are you dealing with just just even getting it to work, but you have to keep in mind of TRCs the platforms have different rules around.

194
00:13:18,576 --> 00:13:25,941
cross-platform and on top of that now you're really locked into updating both versions at the same time which can be pretty challenging.

195
00:13:26,021 --> 00:13:32,046
So especially if you're a smaller developer just having updating every single SKU at the same time can be pretty challenging.

196
00:13:32,966 --> 00:13:37,229
We also develop our own leaderboard solution so that we can do cross-platform leaderboards.

197
00:13:38,991 --> 00:13:41,673
So raw data was in early access when PSVR shipped.

198
00:13:41,873 --> 00:13:46,756
We weren't originally going to port it to PSVR, or we weren't originally going to release it on PSVR.

199
00:13:46,916 --> 00:13:47,077
But...

200
00:13:48,494 --> 00:14:10,746
I'm just working on it was a great new platform. Massive new players are pouring into VR so we couldn't really pass that opportunity. So, we had to port raw data in early access. We did learn a lot about what it takes to develop for a more constrained system. Now we have PSVR as a leads queue and our quest. One of the biggest things we had to. We've.

201
00:14:11,506 --> 00:14:17,308
We had to figure out pretty quick is spawning actors dynamically at runtime is just way too expensive.

202
00:14:17,568 --> 00:14:21,809
I mean you're getting at least like sometimes 10 milliseconds, 20 milliseconds spikes.

203
00:14:22,269 --> 00:14:25,810
And you know you only have like a 16 millisecond budget.

204
00:14:25,910 --> 00:14:27,951
So we modified the engine to have a...

205
00:14:28,591 --> 00:14:47,154
To make it much more easy for us to spawn a whole bunch of actor instances and have them essentially in a dormant state, and when they leave the dormancy and enter the dormancy automatically enable and disable systems like collision and simulation by taking the physics actor in and out of the physics scene, also taking it out of the rendering scene so the thing wouldn't render.

206
00:14:47,614 --> 00:14:53,635
And also, of course, callbacks to inside of the actors and components that the thing was coming in and out of the pool.

207
00:14:53,976 --> 00:15:00,957
So this makes it much, instead of you having to manually every time, like, go through every single actor's components and reset them,

208
00:15:01,277 --> 00:15:05,478
this makes it much easier for us to just add, set up whatever actors we want for pooling.

209
00:15:05,958 --> 00:15:08,599
And on top of that, once again, all our systems are now built with pooling in mind.

210
00:15:09,019 --> 00:15:14,460
So that really helps as we tackle new games, because we know we just can't be spawning all these actor instances.

211
00:15:15,000 --> 00:15:17,183
There are some exciting and fun elements to get tried and tested by developers.

212
00:15:31,602 --> 00:15:37,243
A lot of tools for performance there and pulling is something we developed because particularly

213
00:15:37,303 --> 00:15:42,704
we you know a lot of the UIs end up just being kind of stacks essentially of you click on

214
00:15:42,764 --> 00:15:44,024
one button and your screen comes on.

215
00:15:44,464 --> 00:15:47,925
Well now we can just dynamically crawl through our screens based on the buttons because they

216
00:15:47,945 --> 00:15:51,306
know which screens they're going to and just automatically pre-spawn all those instances.

217
00:15:51,766 --> 00:15:55,647
So you don't have to do as much manual labor to set up like what is being pulled.

218
00:15:57,041 --> 00:16:00,262
Async overlap system, so we discovered that overlaps in Unreal,

219
00:16:00,282 --> 00:16:03,103
and that refers to essentially you have one trigger box,

220
00:16:03,743 --> 00:16:07,785
as a continuity of one shape overlapping with another shape.

221
00:16:07,805 --> 00:16:12,747
So it's helpful for detecting when a character steps into a fire or something,

222
00:16:12,867 --> 00:16:14,528
or a character reaches a new checkpoint.

223
00:16:15,048 --> 00:16:17,849
Now the Unreal implementation is pretty expensive,

224
00:16:18,290 --> 00:16:21,511
because essentially if you enable an overlap every time you move a component,

225
00:16:21,571 --> 00:16:23,732
it will do a physics scene query right there on the game thread.

226
00:16:24,252 --> 00:16:25,654
If you have a lot of things running around,

227
00:16:25,914 --> 00:16:30,718
each time a thing moves, it will cost 0.2, 0.3 milliseconds.

228
00:16:31,099 --> 00:16:32,560
Those things really stack up.

229
00:16:32,580 --> 00:16:35,243
So we built our own really simple async overlap system

230
00:16:36,684 --> 00:16:41,148
that is completely homegrown, but it's also much more simple.

231
00:16:41,168 --> 00:16:44,051
You essentially assign objects in different sets.

232
00:16:44,091 --> 00:16:46,193
And you say, this set of objects overlaps

233
00:16:46,213 --> 00:16:47,074
with this set of objects.

234
00:16:48,055 --> 00:17:04,823
The nice thing is you're not limited by the number of physics channels. You know, with physics, you have like 32 or 16 channels or something. We don't really have to deal with that. And it's much easier to debug because it's all our code and it's just really it's just box and box overlaps. It's a simple calculation.

235
00:17:06,750 --> 00:17:10,631
And button remapping is an issue we had in porting raw data in mid-development.

236
00:17:11,051 --> 00:17:13,111
We had to redesign some mechanics that just didn't work.

237
00:17:13,771 --> 00:17:18,593
And we had to explicitly check for platform to determine button behavior.

238
00:17:18,613 --> 00:17:21,853
So this is pretty messy and this is something we've been dealing with.

239
00:17:22,293 --> 00:17:27,515
And only now I think we're coming out with a much cleaner design for dealing with this in Unreal.

240
00:17:28,242 --> 00:17:32,525
So moving on from raw data, we wanted to really do something

241
00:17:32,545 --> 00:17:32,885
different.

242
00:17:33,965 --> 00:17:37,187
We were tired of the gritty kind of environment,

243
00:17:37,227 --> 00:17:38,668
realistic graphics and shooting.

244
00:17:38,688 --> 00:17:41,689
We wanted to just really kind of pivot.

245
00:17:42,610 --> 00:17:45,371
And so we prototyped this platforming game

246
00:17:46,332 --> 00:17:47,032
called Spring Vector.

247
00:17:47,593 --> 00:17:51,095
And this is kind of built almost like one of those,

248
00:17:51,415 --> 00:17:53,416
I guess there's a TV show or something.

249
00:17:55,249 --> 00:17:56,350
Essentially it's an obstacle course.

250
00:17:57,050 --> 00:18:01,851
And we found that climbing was surprisingly a comfortable experience.

251
00:18:02,492 --> 00:18:06,053
So we were really excited about that, but the joystick movement between the obstacles

252
00:18:07,273 --> 00:18:11,455
definitely was uncomfortable for people and broke up the sense, the fluidity of the climbing.

253
00:18:12,475 --> 00:18:16,436
But we just couldn't see how teleporting would work with an obstacle course,

254
00:18:16,556 --> 00:18:18,017
where you can just teleport around obstacles.

255
00:18:19,357 --> 00:18:21,818
So we realized since climbing was so comfortable,

256
00:18:22,258 --> 00:18:24,519
just using your hands to move around was...

257
00:18:25,317 --> 00:18:26,258
Definitely a way to go.

258
00:18:27,459 --> 00:18:32,965
So, we ended up prototyping and developing a lot of different mechanics that use your hands to move around.

259
00:18:33,466 --> 00:18:38,791
A lot of it was built around the concept of the stride, just as we climbing where you grab a node and you.

260
00:18:39,225 --> 00:18:43,887
Through this, you release the grab button with the movement.

261
00:18:43,967 --> 00:18:45,807
You essentially, every time you press the button,

262
00:18:45,847 --> 00:18:47,808
you are making contact with the ground.

263
00:18:48,068 --> 00:18:49,409
And then as you move your hand back,

264
00:18:49,469 --> 00:18:50,849
you're essentially pushing yourself in the ground.

265
00:18:50,869 --> 00:18:53,471
And as you release, it's as if your foot

266
00:18:53,511 --> 00:18:54,331
is taking off the ground.

267
00:18:54,371 --> 00:18:57,212
So you're basically creating impulses that push you forward.

268
00:18:57,632 --> 00:19:00,674
And that kind of movement system is surprising and comfortable

269
00:19:00,714 --> 00:19:03,094
because I think it really helps trick your brain that it's

270
00:19:03,115 --> 00:19:04,435
the environment that's moving, not you.

271
00:19:05,636 --> 00:19:16,702
And then we also built jumping that's based on the same kind of concept, we added flying that allowed you to put your hands in front of you, and even added steering by steering your hands, which was also turned surprising comfortable.

272
00:19:18,022 --> 00:19:21,985
This is, there was a lot of user testing at the office to especially with the most.

273
00:19:23,287 --> 00:19:24,007
Not sure if you can hear me well.

274
00:19:24,027 --> 00:19:24,808
I'm going to go ahead and get started.

275
00:19:24,848 --> 00:19:24,928
Okay.

276
00:19:24,948 --> 00:19:27,329
So we built this for nausea prone users to make sure this is as comfortable as possible.

277
00:19:27,349 --> 00:19:31,572
We would make these systems kind of tunable at runtime with like buttons or whatever and

278
00:19:31,672 --> 00:19:36,416
basically run people through it and ask them whether different configurations would get

279
00:19:36,456 --> 00:19:36,996
them comfortable.

280
00:19:37,997 --> 00:19:41,739
We took it to GDC, too, and had a lot of great feedback there.

281
00:19:42,680 --> 00:19:47,764
But the funny thing is, once we took it to GDC, we realized that climbing was now the

282
00:19:47,804 --> 00:19:50,646
hardest part of the system, even though that's where it started.

283
00:19:52,938 --> 00:20:02,980
So, and the other thing we realized is, you know, it's one thing to take your game to show floor and have someone standing there and make sure that the users understand what they're doing.

284
00:20:03,461 --> 00:20:16,564
But teaching players how to use your system is, is really complicated, even raw data we had a lot of issues with players understand like we put in a bunch of tutorials but teaching players, especially new to VR is really tough.

285
00:20:16,984 --> 00:20:18,504
We brought in focus testers and

286
00:20:19,665 --> 00:20:23,608
To try to run through our tutorials and polish that up.

287
00:20:23,808 --> 00:20:26,070
And we revamped climbing.

288
00:20:26,090 --> 00:20:27,872
I think we made great...

289
00:20:29,473 --> 00:20:35,678
Sorry, I didn't realize it was...

290
00:20:36,058 --> 00:20:36,699
Can you guys hear that?

291
00:20:37,520 --> 00:20:37,980
Is it loud?

292
00:20:38,000 --> 00:20:40,902
I don't know how to control this.

293
00:20:40,922 --> 00:20:44,065
This is just a really cool video I'd like to show.

294
00:20:44,085 --> 00:20:46,287
I can't even see the video.

295
00:20:46,327 --> 00:20:47,548
I don't know why the screen doesn't show you.

296
00:20:48,529 --> 00:20:48,749
Okay.

297
00:21:09,845 --> 00:21:13,752
Yeah, so obviously some people figure it out and like we're total badasses at this.

298
00:21:13,913 --> 00:21:15,015
We're even better than our players.

299
00:21:15,095 --> 00:21:19,143
But at the same time, a lot of people are still like too confused with the whole pressing, releasing button.

300
00:21:19,544 --> 00:21:21,327
So we knew we had to polish that further.

301
00:21:22,990 --> 00:21:29,436
And at the same time, we also, a new project was spinning up and wanted to tackle another genre, and that was Creed, boxing.

302
00:21:29,596 --> 00:21:36,422
We did some melee in raw data, but it was very simple. Your hands were kinematic, they would just go through essentially the enemies.

303
00:21:38,004 --> 00:21:46,171
And, you know, one of the characters even had a sword, so she could slice enemies, but some people said it really felt like you were using a baseball bat rather than a laser katana.

304
00:21:46,770 --> 00:21:48,532
So we really wanted to polish that experience up,

305
00:21:48,992 --> 00:21:51,735
and particularly the sense of the impact of your punch.

306
00:21:52,035 --> 00:21:54,618
So that's the physical collision detection of the hands.

307
00:21:55,859 --> 00:21:58,801
So we played around with physical simulation

308
00:21:58,861 --> 00:22:00,323
for your weapons and hands in the past,

309
00:22:00,943 --> 00:22:03,205
essentially using rigid body constraints.

310
00:22:04,006 --> 00:22:06,188
But in raw data, during our early pre-production,

311
00:22:07,442 --> 00:22:08,663
We decided to go away from that.

312
00:22:09,884 --> 00:22:11,705
The weapons would get stuck in the environment sometimes,

313
00:22:11,746 --> 00:22:13,727
but we'd get really confused, especially new users.

314
00:22:14,147 --> 00:22:16,549
And it really didn't serve any purpose in the game, really.

315
00:22:16,569 --> 00:22:20,392
And then here, we decided to try to tackle this problem again,

316
00:22:20,472 --> 00:22:22,674
but in a much more controlled environment in a boxing ring.

317
00:22:23,074 --> 00:22:26,076
And here, because we had PTSD from all the physics,

318
00:22:26,176 --> 00:22:28,298
we decided we're just going to sweep the spheres ourselves

319
00:22:29,079 --> 00:22:30,960
and have more control over, essentially,

320
00:22:31,040 --> 00:22:31,981
what the collisions were doing.

321
00:22:34,123 --> 00:22:38,247
I think that had pretty good results.

322
00:22:38,687 --> 00:22:40,409
We were doing the same for the enemy's AI,

323
00:22:40,849 --> 00:22:43,131
so that if you block, and even in multiplayer,

324
00:22:43,171 --> 00:22:46,034
so if you blocked and the enemy tried to punch you,

325
00:22:46,374 --> 00:22:48,997
the sphere would hit and the AK would offset the hand,

326
00:22:49,417 --> 00:22:53,041
and that really added some sense of physicality to the combat.

327
00:22:54,532 --> 00:23:01,757
We also wanted to not just make the act of punching impactful, we wanted to make it also

328
00:23:01,857 --> 00:23:05,179
the act of getting punched more real, more immersive.

329
00:23:05,599 --> 00:23:09,082
So in raw data we had these giant robots that would run at you and charge you and hit you

330
00:23:09,122 --> 00:23:09,862
and you'd fly back.

331
00:23:10,443 --> 00:23:12,745
So flying back is typically relatively comfortable.

332
00:23:12,765 --> 00:23:16,168
I mean, moving forward is the most comfortable, but we realize that flying back is also not

333
00:23:16,188 --> 00:23:16,508
too bad.

334
00:23:16,969 --> 00:23:18,490
But this is a boxing game.

335
00:23:18,610 --> 00:23:21,913
We didn't want to make you actually fly out of the court.

336
00:23:22,013 --> 00:23:26,477
So we first developed this kind of knockback mechanic, where if you get punched hard enough,

337
00:23:26,497 --> 00:23:29,500
you get knocked out of your body, which is a surprisingly comfortable experience and

338
00:23:29,520 --> 00:23:29,720
also.

339
00:23:30,160 --> 00:23:46,498
Pretty fun mini game trying to match up what your character is doing, forcing you to kind of experience what's happening, but took it taking a step further, getting completely knocked out your body. And that's also a mini game, it gets consecutively harder the more you get knocked out, you have to like run faster and this is where we.

340
00:23:47,693 --> 00:23:51,335
Put back the fluid locomotion, but minus the whole stride

341
00:23:51,415 --> 00:23:52,576
concept.

342
00:23:52,616 --> 00:23:54,997
Realize just moving your hands fast to move forward

343
00:23:55,057 --> 00:23:55,998
is relatively comfortable.

344
00:23:56,418 --> 00:23:59,200
We ended up adding it to also as an option

345
00:23:59,500 --> 00:24:00,560
inside of the actual matches.

346
00:24:00,640 --> 00:24:02,602
But once again, we simplified it.

347
00:24:02,662 --> 00:24:05,083
Just hold two buttons and move your hands.

348
00:24:05,483 --> 00:24:07,564
And that was still pretty comfortable.

349
00:24:09,906 --> 00:24:14,528
So after these two games, some common patterns of issues

350
00:24:14,608 --> 00:24:15,188
started emerging.

351
00:24:17,477 --> 00:24:22,621
Rather foolishly, I would say, we put most of our code in this one core service plugin,

352
00:24:22,641 --> 00:24:25,243
thinking, oh, it's a plugin, so we're going to share it with all our games,

353
00:24:25,684 --> 00:24:31,168
and this is how all the games should work. Well, the thing is, VR was relatively new,

354
00:24:31,188 --> 00:24:34,731
so things were developing really fast. A lot of our assumptions for how the hardware

355
00:24:35,212 --> 00:24:38,915
was going to work just didn't work. And on top of that, we're tackling all these different genres,

356
00:24:39,275 --> 00:24:40,757
which was really breaking our assumption.

357
00:24:41,717 --> 00:24:53,545
And on top of that, just having everything in one place just made things way too coupled, made it difficult to refactor systems in isolation, or even just debug systems in isolation, it was kind of unclear what was connected to what.

358
00:24:54,826 --> 00:25:07,834
So our solution was to get rid of the base classes, we had these. So, we prefix all our core systems with SVR just to make it easier to immediately identify where everything is. Our game code also has its own prefixes based on on the

359
00:25:08,983 --> 00:25:09,764
Based on the code name.

360
00:25:10,284 --> 00:25:12,025
So we got rid of all our base classes,

361
00:25:12,866 --> 00:25:14,947
like game mode, game state, pawn, and player state.

362
00:25:16,008 --> 00:25:17,889
It was convenient to like, when you start a new project,

363
00:25:17,949 --> 00:25:19,270
I'm just gonna subclass these classes,

364
00:25:19,310 --> 00:25:20,951
and all of a sudden, technically everything works.

365
00:25:21,151 --> 00:25:24,213
Except for we realized that all these assumptions

366
00:25:24,233 --> 00:25:25,494
were just constantly getting broken,

367
00:25:25,554 --> 00:25:27,315
and teams were just kinda arguing about

368
00:25:27,335 --> 00:25:30,777
what was the right way to do things at the base level.

369
00:25:30,978 --> 00:25:32,959
So instead we just decoupled things

370
00:25:32,999 --> 00:25:35,220
into independent plugins with abstraction layers.

371
00:25:36,241 --> 00:25:39,222
And to make the process of starting new projects easier,

372
00:25:39,262 --> 00:25:44,185
we have this template that has configurations

373
00:25:44,205 --> 00:25:46,466
of these really important base classes.

374
00:25:47,266 --> 00:25:49,127
But really, these serve as shells

375
00:25:49,467 --> 00:25:53,489
as a way to put together our systems with loose connections.

376
00:25:53,949 --> 00:25:55,510
And they really serve as an example.

377
00:25:55,930 --> 00:25:59,552
So once a project starts, it's a complete branch

378
00:25:59,772 --> 00:26:01,012
of these classes.

379
00:26:01,593 --> 00:26:04,014
And people are free to hack together these classes.

380
00:26:05,134 --> 00:26:06,195
From that from then on.

381
00:26:07,356 --> 00:26:16,722
So this is when we basically started this great pluginification. You can see a screenshot of our old serious plugin which has a whole bunch of folders that shouldn't even be there anyway.

382
00:26:17,762 --> 00:26:28,989
And then on the right you have 37 current plugins that we have, and with more coming, and just even without within these plugins themselves we're trying to instill more of a

383
00:26:29,870 --> 00:26:40,672
So we want to make sure that we get a sense of modularity and breaking things up so there's actually multiple modules within these things so that it's easier to swap out subsystems within these systems if game decides to do so.

384
00:26:41,972 --> 00:26:54,994
Like I mentioned, for example, in a damage we have the hit reaction we have the damageable in the weapon system. We have the fire modes, the damagers and the firing effects. All those have base abstract classes and living in, and then they all live in their own separate module so theoretically, those subsystems can be completely separate.

385
00:26:55,014 --> 00:26:59,415
And so we want to make sure that we get a sense of modularity and breaking things up so that it's easier to swap out subsystems within these systems if game decides to do so.

386
00:26:59,535 --> 00:27:01,336
Completely swapped out in the game, they need to.

387
00:27:03,278 --> 00:27:03,979
So BattleWake.

388
00:27:05,240 --> 00:27:06,421
BattleWake is the last game we shipped.

389
00:27:07,742 --> 00:27:11,926
It's a, like I said, it's a pirate combat simulator.

390
00:27:12,427 --> 00:27:14,929
This builds up on a lot of our existing tech.

391
00:27:16,350 --> 00:27:19,493
You know, we wouldn't have been able to get to that point

392
00:27:19,613 --> 00:27:21,155
as fast as we could have.

393
00:27:21,775 --> 00:27:24,898
One of its main pillars is obviously vehicle locomotion.

394
00:27:26,139 --> 00:27:29,621
There was a lot of work put in here to make it a comfortable experience.

395
00:27:30,002 --> 00:27:34,204
Some of it was learned from fluid locomotion, a lot of the comfort effects that we developed.

396
00:27:34,505 --> 00:27:39,027
Obviously the water tech was another big element and that had to actually be tuned

397
00:27:39,348 --> 00:27:44,571
so that you get the impression of a rocky ocean but actually there's a lot of fakery going on

398
00:27:44,631 --> 00:27:47,833
so then when it gets under your ship the ocean actually comes down.

399
00:27:48,794 --> 00:27:55,217
I don't know when we're going to tackle a big killer combo game next, but one system that's for sure

400
00:27:55,237 --> 00:27:59,159
we're going to probably start using a lot in the future is this ECS projectile system that we built.

401
00:28:00,099 --> 00:28:04,161
So this directly hooks into our current weapon system. It's essentially a new type of damager,

402
00:28:04,581 --> 00:28:10,424
but this damager talks to this new projectile system because our old projectile system would

403
00:28:10,464 --> 00:28:13,246
spawn a projectile actor. Now in this game we're trying to spawn

404
00:28:13,886 --> 00:28:16,248
You know, thousands of projectiles flying through the world.

405
00:28:16,508 --> 00:28:20,450
It would just be far too inefficient to actually simulate each one of these actors individually.

406
00:28:21,011 --> 00:28:22,552
So this is a much more data-driven approach.

407
00:28:23,792 --> 00:28:27,275
Essentially, the projectile definition is we have a data asset.

408
00:28:27,615 --> 00:28:30,797
Within the data asset, there's a bunch of edit inline new objects.

409
00:28:32,037 --> 00:28:35,139
Inline new objects, you can think of them as almost like components or whatever.

410
00:28:35,979 --> 00:28:37,560
So, there's four of them.

411
00:28:37,980 --> 00:28:42,082
Damage.axisBase, projectileMovementBase, projectileCollision and projectileFX.

412
00:28:42,983 --> 00:28:44,204
So these are abstract.

413
00:28:44,764 --> 00:28:47,145
You can declare different types.

414
00:28:48,566 --> 00:28:49,726
Some movement.

415
00:28:49,766 --> 00:28:54,188
You can just, the standard one, it basically just simulates gravity and travels in a straight

416
00:28:54,229 --> 00:28:54,689
trajectory.

417
00:28:54,769 --> 00:28:55,289
But if you want.

418
00:28:55,652 --> 00:28:59,393
If the player wants to, they can create a crazy one that does a spiral collision.

419
00:28:59,413 --> 00:29:01,534
SVR Damage Access Base, it's actually what's used in all our damage systems.

420
00:29:01,654 --> 00:29:04,095
Once again, you can make any kinds of damage calculators and attach it to anything, to

421
00:29:04,115 --> 00:29:04,595
the weapon itself.

422
00:29:22,202 --> 00:29:24,503
changes the damage according to the distance from a shot,

423
00:29:25,163 --> 00:29:28,104
or how many things it got hit in its path.

424
00:29:29,005 --> 00:29:32,466
And projectile effects, there's actually a list of them

425
00:29:32,506 --> 00:29:33,786
that are attached to this data asset.

426
00:29:33,826 --> 00:29:39,148
Like one of them is an instant static mesh projectile effects,

427
00:29:39,488 --> 00:29:41,709
which essentially there's an instant static mesh manager

428
00:29:42,109 --> 00:29:45,110
which renders all the cannonballs in one draw call.

429
00:29:46,864 --> 00:29:49,025
There's a projectile manager, and essentially it

430
00:29:49,345 --> 00:29:50,985
maintains a projectile collection array.

431
00:29:51,385 --> 00:29:55,127
It's an array for each one of these data assets.

432
00:29:55,767 --> 00:29:57,627
And inside of this collection, there's

433
00:29:57,827 --> 00:30:00,028
essentially a list of projectile instances

434
00:30:00,168 --> 00:30:01,168
with all that data.

435
00:30:01,188 --> 00:30:04,689
So this is just kind of standard ECS data-driven approach,

436
00:30:04,729 --> 00:30:08,231
so that all the data is laid out in one flat buffer,

437
00:30:08,651 --> 00:30:11,011
and it's all in a pool, so that cycling

438
00:30:11,031 --> 00:30:13,452
through all these things is just really great for the cache.

439
00:30:14,749 --> 00:30:19,975
Another thing that we developed that we're already actually using in our future titles

440
00:30:20,055 --> 00:30:22,038
is damage decal composition.

441
00:30:23,420 --> 00:30:27,865
Essentially we wanted to give great feedback to the player about the locational damage

442
00:30:27,905 --> 00:30:28,306
on the ships.

443
00:30:31,049 --> 00:30:38,334
The feedback exactly how much damage you're also dealing to the ship now the simple approach would have been to just attach decal components

444
00:30:38,614 --> 00:30:44,678
To the ship now the problem is here you're on the on the rendering side. You're now incurring you know

445
00:30:44,698 --> 00:30:46,420
charcoal per decal

446
00:30:47,220 --> 00:30:50,142
And on the CPU side, our ships are moving around.

447
00:30:50,202 --> 00:30:52,343
So now you're updating each one of these decals

448
00:30:52,903 --> 00:30:54,584
on the CPU whenever your ship moves.

449
00:30:55,245 --> 00:30:57,626
So, and on top of that, like, we have weapons

450
00:30:57,686 --> 00:31:01,368
that are just, like, raised and just sliced through the ship,

451
00:31:01,529 --> 00:31:02,309
like, every frame.

452
00:31:02,349 --> 00:31:04,951
Like, that would have just spawned so many decals.

453
00:31:06,311 --> 00:31:09,293
So instead, we essentially project.

454
00:31:10,374 --> 00:31:13,216
We have a projection of the ship from four different angles.

455
00:31:14,196 --> 00:31:17,439
And we essentially have a damage map

456
00:31:17,799 --> 00:31:19,700
for how the damage map looks.

457
00:31:19,780 --> 00:31:21,942
And the decals are just essentially,

458
00:31:22,883 --> 00:31:23,823
we have a render target.

459
00:31:23,924 --> 00:31:26,686
And decals are rendered into the render target as masks.

460
00:31:27,146 --> 00:31:29,127
And we can use the four channels to display

461
00:31:29,147 --> 00:31:29,988
a different kind of damage.

462
00:31:30,528 --> 00:31:31,549
And it's locational, too.

463
00:31:32,290 --> 00:31:35,933
And the nice thing is here is the damage itself

464
00:31:35,973 --> 00:31:38,274
can be animated, too, because it's a damage map.

465
00:31:39,095 --> 00:31:41,156
So whatever the artists want to do,

466
00:31:43,358 --> 00:31:49,642
They can and it's nice because it's coherent throughout the entire ship instead of you

467
00:31:49,662 --> 00:31:51,443
spawning little spots per ship.

468
00:31:52,023 --> 00:31:56,685
So nice thing about this is we're now going to be using it on our characters, because

469
00:31:56,705 --> 00:32:01,748
in the past we didn't really have a clear, a clean way of displaying damage on a character's

470
00:32:01,768 --> 00:32:02,048
body.

471
00:32:03,749 --> 00:32:04,790
So future developments.

472
00:32:06,504 --> 00:32:12,848
a player movement refactor if I had to outline another big problem that or big mistake that we did.

473
00:32:14,669 --> 00:32:17,751
And this actually started during essentially Westworld's development.

474
00:32:19,292 --> 00:32:33,021
So it's, I guess, a problem of just sharing too much and I guess trying to put everything inside a service plugin also is an example of that I think sometimes engineers get really excited about the concept of over sharing everything instead of trying to make

475
00:32:33,482 --> 00:32:38,847
We're trying to branch out sometimes, so we really tried to reuse the character movement component in Unreal as much as possible.

476
00:32:40,209 --> 00:32:46,255
But that was really a mistake because that thing was really built for just traditional joystick movement or AI movement and just trying to stick.

477
00:32:47,528 --> 00:32:50,330
player VR movement in there has been a nightmare,

478
00:32:50,410 --> 00:32:53,512
especially trying to put in completely different movement

479
00:32:53,532 --> 00:32:55,833
mechanics like fluid locomotion and climbing.

480
00:32:55,893 --> 00:32:57,855
And it just became this one giant file

481
00:32:57,895 --> 00:33:00,776
of lots of things happening.

482
00:33:00,817 --> 00:33:02,498
Then you weren't really sure how things were connected.

483
00:33:02,538 --> 00:33:04,059
And then on top of that, we're now

484
00:33:04,099 --> 00:33:06,240
trying to support different locomotion styles

485
00:33:06,280 --> 00:33:08,862
like joystick movement, fluid locomotion, and teleport.

486
00:33:09,222 --> 00:33:11,363
And now you have even more complexity there,

487
00:33:11,383 --> 00:33:12,804
trying to go between these different things.

488
00:33:13,945 --> 00:33:18,586
So we decided to throw all that out and basically started building everything kind of from scratch.

489
00:33:19,246 --> 00:33:21,087
We based on this state machine approach.

490
00:33:21,427 --> 00:33:26,748
So we have this state machine that maintains the current state.

491
00:33:27,969 --> 00:33:30,229
So it's a base class, movement state, SVR movement state.

492
00:33:30,629 --> 00:33:34,230
You can subclass that and really it's up to you to calculate the desired delta.

493
00:33:34,851 --> 00:33:37,051
And that can be subclassed for different locomotion types.

494
00:33:38,719 --> 00:33:42,822
So fluid, et cetera, or joystick, teleport.

495
00:33:42,982 --> 00:33:44,883
And now it's very easy for you to, A,

496
00:33:46,064 --> 00:33:47,084
switch between these different modes,

497
00:33:47,104 --> 00:33:48,625
because you just say this is the state.

498
00:33:49,105 --> 00:33:50,746
It's up to you to determine when you're switching

499
00:33:50,766 --> 00:33:52,427
between different states, because you still could have

500
00:33:52,467 --> 00:33:55,109
a climbing state that makes sense

501
00:33:55,169 --> 00:33:56,230
that would transition from there.

502
00:33:57,270 --> 00:33:59,251
And there's also support for additive movement state,

503
00:33:59,331 --> 00:34:02,293
because turning in place using, essentially,

504
00:34:02,333 --> 00:34:05,515
the joystick to do a quick turn, that's an additive state.

505
00:34:06,396 --> 00:34:07,456
So that can be added on top.

506
00:34:09,277 --> 00:34:13,399
And on top of that, the handling itself is also further decoupled in a separate object.

507
00:34:13,640 --> 00:34:15,581
There's a base movement input manager.

508
00:34:16,301 --> 00:34:21,164
And you can declare one that works with a specific movement state.

509
00:34:21,604 --> 00:34:23,465
You can switch these things around dynamically.

510
00:34:23,505 --> 00:34:26,487
So you could make one, for example, for different platforms if you needed to.

511
00:34:27,147 --> 00:34:31,790
Or you could decide in our game, we do like the joystick movement implementation,

512
00:34:31,830 --> 00:34:36,072
but we just want to completely throw out how we're talking to the movement state.

513
00:34:36,932 --> 00:34:38,673
So that's given us a lot of flexibility

514
00:34:38,753 --> 00:34:41,054
and really helped clean that up a lot.

515
00:34:42,895 --> 00:34:44,496
And just generally having full control

516
00:34:44,536 --> 00:34:46,097
now of the character collision logic,

517
00:34:46,477 --> 00:34:48,778
just outside of any assumptions of the character movement,

518
00:34:48,918 --> 00:34:50,959
just really helped us really polish that.

519
00:34:50,979 --> 00:34:52,680
And then on the topic of input,

520
00:34:52,840 --> 00:34:55,821
that's another like, it has been another big pain point of ours.

521
00:34:56,061 --> 00:34:59,363
Unreal comes with this input system that's INI driven.

522
00:34:59,883 --> 00:35:03,305
So it's nice because, you know, anytime you have INI,

523
00:35:05,362 --> 00:35:25,207
Data driven methods of modifying your system, you know, you can't really target for you to introduce bugs, it's easier for you to change things without having to recompile everything. The problem is with that solution is it was really designed with traditional keyboard and joysticks in mind, I mean like the engine has been around for like 20 years or however long. So, one.

524
00:35:26,908 --> 00:35:36,421
I didn't want a unique feature of using motion controllers is there's two hands right so you actually have two of the same buttons on both hands. So, really wanted a system that.

525
00:35:37,550 --> 00:35:41,971
would understand, would be intelligent about the fact that it's the same button, but it's

526
00:35:41,991 --> 00:35:42,812
actually different hands.

527
00:35:43,512 --> 00:35:47,794
And on top of that, dealing with the fact that actually there's on PC, we have drastically

528
00:35:47,834 --> 00:35:52,135
different kind of motion controllers, like Vive controller versus Oculus controller,

529
00:35:52,615 --> 00:35:54,636
sort of similar buttons, but not really.

530
00:35:54,936 --> 00:36:00,158
And we really wanted a much cleaner way of setting up bindings for this platform versus

531
00:36:00,238 --> 00:36:03,420
this platform, instead of doing a bunch of ugly platform checks within the code.

532
00:36:03,880 --> 00:36:06,541
We built this new INI-driven system SVR input

533
00:36:06,961 --> 00:36:10,143
based on the Unreal vanilla implementation.

534
00:36:10,163 --> 00:36:12,764
It dynamically modifies the input bindings

535
00:36:13,705 --> 00:36:15,385
according to which motion controller you have.

536
00:36:16,346 --> 00:36:18,367
Also, we built in control scheme selection,

537
00:36:18,447 --> 00:36:19,608
so once again, all INI-driven.

538
00:36:19,788 --> 00:36:22,989
This cleans up a lot of the code,

539
00:36:23,269 --> 00:36:24,890
but now we just have to tell the input system,

540
00:36:24,930 --> 00:36:26,351
hey, this is the by string,

541
00:36:26,531 --> 00:36:27,511
this is the variant they're using,

542
00:36:27,571 --> 00:36:28,492
or this is the variant using,

543
00:36:28,512 --> 00:36:30,213
and the system automatically rebinds everything.

544
00:36:30,833 --> 00:36:32,434
And we also have dominant hand selection.

545
00:36:32,854 --> 00:36:34,554
So whenever you switch to left-handedness,

546
00:36:34,614 --> 00:36:36,855
we typically switch all the buttons from left to right hand.

547
00:36:37,795 --> 00:36:39,816
So all the bindings, once again, just

548
00:36:39,876 --> 00:36:41,697
automatically get swapped around.

549
00:36:41,857 --> 00:36:43,297
When you say, this is the binding,

550
00:36:43,337 --> 00:36:45,058
you say specifically, do you want it for both hands?

551
00:36:45,098 --> 00:36:47,058
Do you want it for primary hand or secondary hand?

552
00:36:47,699 --> 00:36:51,840
And also, you can explicitly turn on input components

553
00:36:51,860 --> 00:36:52,940
for left hand versus right hand.

554
00:36:52,960 --> 00:36:54,901
So this is really great for the interaction system,

555
00:36:55,341 --> 00:36:56,582
because when you grab an object, you

556
00:36:56,602 --> 00:36:58,182
could be grabbing it with the left hand or the right hand.

557
00:36:59,443 --> 00:37:04,328
And with default Unreal, you're basically just binding to both buttons and then checking which hand is holding it.

558
00:37:04,688 --> 00:37:11,074
Now you just bind to the event and you just, when the interaction starts and stops, you just basically tell the input component which hands are holding it.

559
00:37:11,714 --> 00:37:15,598
So this is just a really messy example of how we were doing some stuff in raw data.

560
00:37:15,998 --> 00:37:16,839
We're checking which...

561
00:37:17,940 --> 00:37:21,103
Which platform we were on, we're still using input component in one place,

562
00:37:21,143 --> 00:37:25,026
but we also had these hard-coded button events on the interactive component.

563
00:37:26,427 --> 00:37:27,428
And this is really messy.

564
00:37:28,128 --> 00:37:31,631
And this is an example of how we're binding stuff for fluid locomotion.

565
00:37:31,771 --> 00:37:34,254
It's all config-driven.

566
00:37:34,354 --> 00:37:37,836
We have this concept of ambidextrous keys, essentially, as in for both hands.

567
00:37:37,857 --> 00:37:40,439
I don't know if that name makes sense, but that's what I'm using.

568
00:37:40,859 --> 00:37:43,601
And essentially, you now say, like, this is the left button, this is the right button.

569
00:37:44,042 --> 00:37:54,290
This is the buttons how I'm going to refer them to this is the platforms that I'm going to be using it on. And when you add the binding you say what side mode it is, whether it's for the secondary hand the primary hand or both hands.

570
00:37:55,771 --> 00:38:04,659
And, yeah, so this that has really helped us clean things up so in conclusion, yeah, definitely try to break your systems into decoupled modular blocks.

571
00:38:05,819 --> 00:38:11,821
It might mean there's more maintenance and more boilerplate code connecting things, but

572
00:38:11,841 --> 00:38:14,162
over the long term it's going to be easier for you to manage this.

573
00:38:15,103 --> 00:38:18,664
If you want to do multiplayer, definitely keep multiplayer in mind, but definitely keep

574
00:38:18,724 --> 00:38:19,764
multiplatform in mind.

575
00:38:19,824 --> 00:38:25,326
If you're trying to do, and nowadays VR is so fractured, try to develop systems with

576
00:38:26,067 --> 00:38:27,667
all the different controller variants in mind.

577
00:38:28,668 --> 00:38:29,748
Stay nimble, I guess.

578
00:38:31,109 --> 00:38:32,550
And yeah, think about future games.

579
00:38:32,570 --> 00:38:34,552
Think about when we're picking projects,

580
00:38:34,592 --> 00:38:36,874
we're explicitly thinking about, OK, how can we

581
00:38:36,934 --> 00:38:39,456
pick projects that let us develop tech that will then

582
00:38:39,636 --> 00:38:40,997
help us with future projects?

583
00:38:41,718 --> 00:38:43,019
So yeah, thanks.

584
00:38:54,873 --> 00:39:00,017
Do you come up with an interesting system and then design a game around it?

585
00:39:00,137 --> 00:39:05,781
Or do you start with, I found a game and now I'm going to make an interesting locomotion or modular gun system around it?

586
00:39:09,658 --> 00:39:20,425
Both kind of happened, but we definitely do like to think about what challenges in VR we haven't solved yet, or other people haven't solved yet, or at least haven't solved to the level that we think is great.

587
00:39:20,445 --> 00:39:25,868
And then we see, particularly lately, what IP fits into that, which really helps with the marketing angle.

588
00:39:27,009 --> 00:39:30,671
I mean, with game, it's always about the gameplay mechanics.

589
00:39:31,412 --> 00:39:36,275
You can have a bad story, but good gameplay mechanics, but if it's the other way around, then it's not a good game.

