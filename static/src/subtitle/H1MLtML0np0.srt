1
00:00:06,019 --> 00:00:06,279
Hello.

2
00:00:08,801 --> 00:00:10,322
Just gonna start off with the basics.

3
00:00:11,162 --> 00:00:12,663
Please put your cell phones on quiet,

4
00:00:12,703 --> 00:00:14,364
otherwise I'm gonna get very distracted

5
00:00:14,384 --> 00:00:15,225
and it'll be really funny.

6
00:00:16,806 --> 00:00:18,827
And also don't forget to fill in your evaluations

7
00:00:18,907 --> 00:00:20,428
at the end of the session

8
00:00:20,488 --> 00:00:21,909
so that hopefully I can get invited back.

9
00:00:24,091 --> 00:00:26,052
So my name is Chris Savoie

10
00:00:26,252 --> 00:00:29,154
and I was the lead UI programmer on Tom Clancy's The Division.

11
00:00:30,270 --> 00:00:33,572
In my role, I created the UI solution that we use in the game.

12
00:00:34,133 --> 00:00:38,856
And I had the fortunate opportunity to help develop a lot of the core technologies used in the Snowdrop engine.

13
00:00:39,777 --> 00:00:45,040
Today I'd like to share some of the hard lessons that we learned while building the UI system for Snowdrop and The Division.

14
00:00:47,442 --> 00:00:53,066
For those who haven't played it, Tom Clancy's The Division is a third-person, cover-based shooter online RPG.

15
00:00:54,357 --> 00:00:57,559
It's a Tom Clancy game where you play as a high-tech government

16
00:00:57,679 --> 00:01:00,580
agent during the fall of New York due to a virus outbreak.

17
00:01:02,801 --> 00:01:04,261
One of the key pieces of technology

18
00:01:04,542 --> 00:01:08,143
is an AR system that links your character to the central AI

19
00:01:08,203 --> 00:01:10,704
system, Isaac, which will feed your character

20
00:01:10,764 --> 00:01:13,165
with information about your current situation

21
00:01:13,265 --> 00:01:14,026
and the world around you.

22
00:01:16,427 --> 00:01:18,167
So it was very early on that we decided

23
00:01:18,247 --> 00:01:20,888
that we wanted to make a fully diegetic UI for the game.

24
00:01:22,968 --> 00:01:24,968
Every UI element that went into the game

25
00:01:25,148 --> 00:01:27,609
was framed in the idea that this wasn't just for the player,

26
00:01:27,969 --> 00:01:29,329
but also for the character that you play.

27
00:01:31,830 --> 00:01:32,830
So here's the plan for today.

28
00:01:33,410 --> 00:01:35,951
I'll start by covering a bit how our node graph

29
00:01:36,111 --> 00:01:37,311
and UI technology work.

30
00:01:38,371 --> 00:01:40,852
Then I want to talk about the importance of rapid iteration

31
00:01:40,972 --> 00:01:42,632
and the various things that we did to improve it.

32
00:01:43,953 --> 00:01:45,873
After that, I'll get into some of the gritty details

33
00:01:46,113 --> 00:01:48,634
of how we work and some of the performance issues

34
00:01:48,654 --> 00:01:49,174
that we faced.

35
00:01:50,137 --> 00:01:52,178
And in the final part I just have some general lessons

36
00:01:52,538 --> 00:01:54,179
about what went well and what we would like

37
00:01:54,199 --> 00:01:55,239
to improve upon in the future.

38
00:01:58,161 --> 00:01:59,701
So what makes Snowdrop so special?

39
00:02:00,762 --> 00:02:02,202
The Division was the first game to ship

40
00:02:02,443 --> 00:02:04,424
on the Snowdrop engine that we developed at Massive.

41
00:02:05,104 --> 00:02:06,725
At the heart of our engine lies a powerful

42
00:02:06,765 --> 00:02:08,205
node graph visual scripting system.

43
00:02:08,626 --> 00:02:11,007
This single system is used to create content

44
00:02:11,027 --> 00:02:12,087
for many parts of the engine,

45
00:02:12,167 --> 00:02:14,068
from familiar shaders and mission scripting,

46
00:02:14,128 --> 00:02:15,429
but also for particle systems,

47
00:02:15,829 --> 00:02:17,650
graphical objects, animations, AI behaviors,

48
00:02:17,690 --> 00:02:19,431
and many more, including of course UI.

49
00:02:21,791 --> 00:02:23,552
As a quick example of how it all works,

50
00:02:23,572 --> 00:02:25,773
I recorded myself doing a quick health bar prototype.

51
00:02:27,033 --> 00:02:30,775
First, I output the health as text

52
00:02:31,015 --> 00:02:33,036
by concatenating the current and maximum health,

53
00:02:34,036 --> 00:02:37,078
though you should try to avoid concatenating strings

54
00:02:37,518 --> 00:02:40,019
because it doesn't really work well with localization.

55
00:02:40,499 --> 00:02:41,580
But in this example, it's okay.

56
00:02:42,620 --> 00:02:43,901
So I just do a quick test here

57
00:02:43,941 --> 00:02:45,402
to make sure that the values are responding.

58
00:02:46,649 --> 00:02:49,250
I'm then just going to add a bit of a background to the element

59
00:02:49,390 --> 00:02:52,012
that's going to change color based on your total health.

60
00:02:54,273 --> 00:02:57,175
I also add a blurred background to it, mostly out of habit,

61
00:02:57,536 --> 00:03:00,818
but this really is what adds a lot of readability

62
00:03:01,158 --> 00:03:02,439
to the UI elements in our game.

63
00:03:03,960 --> 00:03:08,162
I use a gradient to transition the colors as you get damaged.

64
00:03:09,783 --> 00:03:11,825
So green for good and red for bad.

65
00:03:14,691 --> 00:03:20,695
give it a test. It's all working as designed. Now I'm just going to move it into 3D space.

66
00:03:22,096 --> 00:03:26,338
And then I attach it to the player. Unfortunately, when we move it into 3D, it gets really, really

67
00:03:26,378 --> 00:03:31,001
huge so I need to scale it down a bit. And then I just move it above the player's head

68
00:03:31,882 --> 00:03:37,965
since the player position is generally at the foot. And then I basically just enable

69
00:03:38,005 --> 00:03:40,667
it in game, hit save, and then we have a new piece of UI running in the game.

70
00:03:43,618 --> 00:03:45,839
So you might have noticed that at no point

71
00:03:46,060 --> 00:03:48,441
was there any direct manipulation of the UI.

72
00:03:49,002 --> 00:03:50,303
This is one of the main differences

73
00:03:50,403 --> 00:03:53,425
in the Snowdrop UI system is that we have no canvas.

74
00:03:54,686 --> 00:03:56,527
To be honest, this just started with a problem of time.

75
00:03:56,787 --> 00:03:58,969
We focused on developing the node system first

76
00:03:59,029 --> 00:04:01,431
before the UI tools, but every time the topic came up

77
00:04:01,471 --> 00:04:03,032
to add direct canvas manipulation,

78
00:04:03,112 --> 00:04:05,674
it didn't really feel worth the time investment.

79
00:04:07,715 --> 00:04:09,817
Another big difference is that we run an immediate mode

80
00:04:10,197 --> 00:04:10,978
instead of retained mode.

81
00:04:11,762 --> 00:04:14,583
Put simply, this just means that we redraw the UI every frame

82
00:04:14,723 --> 00:04:17,083
instead of trying to pre-generate everything on screen.

83
00:04:17,904 --> 00:04:19,624
While this does come with a performance cost,

84
00:04:19,724 --> 00:04:21,724
it also means that being dynamic and flexible

85
00:04:21,924 --> 00:04:22,925
are at the root of the system.

86
00:04:23,685 --> 00:04:25,565
We'll get more into the performance cost of that later, though.

87
00:04:28,026 --> 00:04:30,086
The system is also vector graphic driven.

88
00:04:30,206 --> 00:04:32,607
We tend to prefer to build shapes with triangles

89
00:04:32,747 --> 00:04:34,047
instead of using texture masking.

90
00:04:34,786 --> 00:04:36,127
This comes with a few key benefits.

91
00:04:36,247 --> 00:04:38,770
First is that we can reduce the GPU load

92
00:04:38,850 --> 00:04:40,611
by only rendering the pixels that we use.

93
00:04:41,512 --> 00:04:42,993
And the second is that our tech artists

94
00:04:43,234 --> 00:04:44,595
can really flex their creativity.

95
00:04:45,436 --> 00:04:47,497
So this effect was made by one of our technical artists

96
00:04:47,597 --> 00:04:50,060
while just experimenting with various data processing

97
00:04:50,340 --> 00:04:51,401
and point rendering techniques.

98
00:05:00,433 --> 00:05:02,313
By using primarily vector graphics,

99
00:05:02,694 --> 00:05:06,595
it allows us to render all the UI at 4K on PS4 Pro

100
00:05:06,815 --> 00:05:08,836
without really having to change any of the data whatsoever.

101
00:05:10,416 --> 00:05:13,197
Finally, our UI system is tightly integrated

102
00:05:13,237 --> 00:05:14,718
with our overall render pipeline,

103
00:05:15,158 --> 00:05:16,878
and it uses the same shader backend.

104
00:05:17,518 --> 00:05:19,539
This means that we can share shader techniques

105
00:05:19,699 --> 00:05:21,660
and have access to the same render resources

106
00:05:21,840 --> 00:05:22,980
as any other system in the game.

107
00:05:23,670 --> 00:05:25,070
like the depth in the normal buffers.

108
00:05:26,011 --> 00:05:28,232
Any artist that has made a shader for a 3D object

109
00:05:28,292 --> 00:05:30,153
or particle system can easily jump in

110
00:05:30,253 --> 00:05:31,674
and make shaders for the UI.

111
00:05:33,275 --> 00:05:35,316
Since UI can just render over top of everything,

112
00:05:35,656 --> 00:05:37,357
it makes it very easy to add new post effects

113
00:05:37,937 --> 00:05:38,817
into the pipeline as well.

114
00:05:40,238 --> 00:05:42,719
Many of our skill post effects were done in the UI system.

115
00:05:42,840 --> 00:05:45,021
Here, I built a small UI to test a few of them out.

116
00:05:45,661 --> 00:05:47,642
I just enable it in game and hit save,

117
00:05:48,843 --> 00:05:51,264
and then I can just test that all these effects

118
00:05:51,404 --> 00:05:52,785
are working well in the game.

119
00:05:58,342 --> 00:06:02,563
To get information from the game, a coder just writes a new node to provide that information,

120
00:06:02,803 --> 00:06:05,063
like the position or health of the entity that I used earlier.

121
00:06:06,803 --> 00:06:08,744
To get more information, we just add more nodes.

122
00:06:09,524 --> 00:06:15,946
We had nearly 5,500 nodes when we shipped the recent survival DLC last Christmas.

123
00:06:18,946 --> 00:06:20,987
These nodes may have been made for the UI,

124
00:06:21,207 --> 00:06:23,067
but they can also be used in any other system,

125
00:06:23,147 --> 00:06:25,688
like graphical objects, to make them react to the player's presence.

126
00:06:27,282 --> 00:06:29,743
Here I have a turret object that I made out of

127
00:06:29,763 --> 00:06:30,524
a few different meshes.

128
00:06:30,704 --> 00:06:31,904
I identify the head parts of it,

129
00:06:32,204 --> 00:06:34,065
and I can use the player's position

130
00:06:34,606 --> 00:06:36,406
so that the turret will always face the player.

131
00:06:42,129 --> 00:06:44,930
And then I just hit save, and then it's updated in game

132
00:06:45,070 --> 00:06:46,251
and tracking the player's position.

133
00:06:50,233 --> 00:06:51,993
Nodes in Snowdrop can do much more

134
00:06:52,033 --> 00:06:52,974
than just getting set data.

135
00:06:54,106 --> 00:06:56,968
In the UI system, they act as a visual scripting language.

136
00:06:57,028 --> 00:06:59,490
So we have many nodes that affect the flow of execution

137
00:06:59,550 --> 00:07:00,590
with branching and looping.

138
00:07:02,752 --> 00:07:05,654
Most of our systems share a high level of interconnectivity.

139
00:07:05,754 --> 00:07:08,195
So from the UI, we can add objects to the world,

140
00:07:08,395 --> 00:07:10,957
run skills, or spawn separate UI objects.

141
00:07:11,557 --> 00:07:13,218
On the other side, world objects and skills

142
00:07:13,258 --> 00:07:14,099
can also spawn UI.

143
00:07:16,625 --> 00:07:18,687
The freedom of our nodes does come at a bit of a cost.

144
00:07:18,967 --> 00:07:20,749
It can sometimes be difficult to understand

145
00:07:20,829 --> 00:07:22,871
who's doing what and where certain things are coming from.

146
00:07:23,912 --> 00:07:25,434
For that, we do have a very thorough

147
00:07:25,474 --> 00:07:27,977
dependency tracking system, so you can always figure out

148
00:07:28,497 --> 00:07:30,559
who's owning what and who's the responsibility of things.

149
00:07:34,377 --> 00:07:36,698
The Snowdrop graph system is also very extensible.

150
00:07:37,159 --> 00:07:39,520
It's very easy to add new data types to the system.

151
00:07:39,580 --> 00:07:40,560
It's actually almost too easy.

152
00:07:41,801 --> 00:07:44,963
When I made this slide, we were up to 278 data types.

153
00:07:45,683 --> 00:07:47,484
They range from basic types like interfloat

154
00:07:48,024 --> 00:07:50,626
to very complex types that have custom behaviors

155
00:07:50,686 --> 00:07:52,446
and editors associated, like the gradient

156
00:07:52,466 --> 00:07:53,147
that I showed earlier.

157
00:07:54,868 --> 00:07:56,589
The numbers of types in the system

158
00:07:56,629 --> 00:07:57,889
doesn't really affect anything, however,

159
00:07:58,009 --> 00:07:59,890
since at runtime, it all gets optimized away.

160
00:08:02,930 --> 00:08:04,350
To make life easier, we have a system

161
00:08:04,670 --> 00:08:06,811
to enable automatic conversion between types,

162
00:08:07,672 --> 00:08:09,012
which you can see by the yellow lines here.

163
00:08:09,813 --> 00:08:12,854
It's also easy to make nodes that support multiple data types

164
00:08:12,874 --> 00:08:14,235
to either avoid conversion costs

165
00:08:14,375 --> 00:08:15,895
or to optimize for specific cases.

166
00:08:18,236 --> 00:08:19,757
And if code doesn't provide enough data,

167
00:08:20,137 --> 00:08:21,598
users can just make their own variables

168
00:08:21,698 --> 00:08:23,359
using almost any available data type.

169
00:08:24,359 --> 00:08:25,640
And we also have global variables,

170
00:08:26,040 --> 00:08:27,601
mainly so our content creators can just shoot themselves

171
00:08:27,641 --> 00:08:28,301
in the foot all the time.

172
00:08:30,467 --> 00:08:32,729
While it's a bit hacky to glue systems together

173
00:08:32,789 --> 00:08:35,210
using global variables, they can easily solve problems

174
00:08:35,250 --> 00:08:37,331
that would take much more time to code a system for.

175
00:08:38,111 --> 00:08:40,453
We did ship with around 1,600 globals.

176
00:08:41,213 --> 00:08:43,534
Actually, our entire menu system was done

177
00:08:43,734 --> 00:08:46,996
using purely global variables, which more or less worked.

178
00:08:49,978 --> 00:08:52,239
The best thing to come out of having a single graph system

179
00:08:52,419 --> 00:08:55,060
is that, in a lot of cases, work done in one system

180
00:08:55,080 --> 00:08:56,021
would benefit all systems.

181
00:08:56,947 --> 00:08:58,727
During the development of our UI system,

182
00:08:58,747 --> 00:09:00,387
we added better variable support,

183
00:09:00,667 --> 00:09:01,847
timeline-based animations,

184
00:09:03,088 --> 00:09:05,048
and expanded on supporting arrays of data.

185
00:09:05,768 --> 00:09:07,308
All of these features have benefited

186
00:09:07,468 --> 00:09:09,509
and been used in many other graph systems in the engine.

187
00:09:12,409 --> 00:09:14,990
We also have assets in Snowdrop that we call compounds.

188
00:09:15,650 --> 00:09:17,870
They're basically node graph snippets.

189
00:09:18,450 --> 00:09:21,371
They're used in the UI to create reusable behaviors

190
00:09:21,451 --> 00:09:23,431
like buttons or common styles

191
00:09:23,491 --> 00:09:25,212
like how many shadow layers to use.

192
00:09:26,430 --> 00:09:28,411
However, since they can be used in any system,

193
00:09:28,451 --> 00:09:30,592
we also have a wealth of generic compounds

194
00:09:30,612 --> 00:09:31,973
that can be used just about anywhere.

195
00:09:32,894 --> 00:09:34,134
We have about 3,000 of them.

196
00:09:39,017 --> 00:09:40,477
Having everyone work with the same language

197
00:09:40,697 --> 00:09:42,438
just generally helps out around the office as well.

198
00:09:42,919 --> 00:09:44,900
It means that level scripters, artists, coders,

199
00:09:44,920 --> 00:09:47,201
and designers all speak the same base language.

200
00:09:47,241 --> 00:09:50,042
So while each graph system might work

201
00:09:50,102 --> 00:09:51,123
in slightly different ways,

202
00:09:51,823 --> 00:09:53,724
we at least have a common ground for communication.

203
00:09:57,312 --> 00:09:59,012
So that's a little taste of the Snowdrop engine,

204
00:09:59,652 --> 00:10:01,692
but its biggest secret lies in its iteration times.

205
00:10:02,613 --> 00:10:05,433
Iteration is one of our core pillars in the Snowdrop engine.

206
00:10:06,013 --> 00:10:08,093
In every system, tool, and piece of code,

207
00:10:08,133 --> 00:10:10,154
we constantly think of ways to see our changes

208
00:10:10,194 --> 00:10:10,974
faster and faster.

209
00:10:13,894 --> 00:10:14,935
This starts with our code base.

210
00:10:15,315 --> 00:10:17,075
We're constantly keeping an eye on compile times.

211
00:10:17,895 --> 00:10:20,116
In general, compile times for coders is only around a minute,

212
00:10:21,276 --> 00:10:22,296
especially now that we've upgraded

213
00:10:22,336 --> 00:10:24,596
to the Visual Studio 2015 compiler

214
00:10:24,616 --> 00:10:25,617
with its improved link times.

215
00:10:27,457 --> 00:10:29,038
And it's really worth upgrading to that

216
00:10:29,078 --> 00:10:30,619
if you haven't already, it helps a lot.

217
00:10:32,540 --> 00:10:35,842
We advocate both refactoring code to make it more efficient

218
00:10:36,202 --> 00:10:37,883
and removing code that isn't used anymore

219
00:10:38,023 --> 00:10:41,384
to keep our code base as small and clean as possible.

220
00:10:44,086 --> 00:10:46,387
We also make sure startup times are very fast as well.

221
00:10:47,167 --> 00:10:48,788
Getting to the character select screen

222
00:10:49,108 --> 00:10:50,409
or to the start page of our editor

223
00:10:50,629 --> 00:10:51,730
is actually just a few seconds.

224
00:10:54,329 --> 00:10:56,670
Loading into Manhattan can take a minute or two,

225
00:10:57,171 --> 00:10:58,371
since it is such a huge level,

226
00:10:58,811 --> 00:11:00,932
but opening it in our editor is actually quite quick,

227
00:11:00,992 --> 00:11:02,673
since we're able to stream load everything

228
00:11:02,753 --> 00:11:04,014
much more aggressively in that case.

229
00:11:04,914 --> 00:11:07,836
And our users can also hide large parts of the level

230
00:11:07,856 --> 00:11:09,196
so that they can work much more efficiently.

231
00:11:11,978 --> 00:11:14,359
For the UI specifically, it starts with being a

232
00:11:14,479 --> 00:11:15,880
what you see is what you get editor,

233
00:11:16,560 --> 00:11:18,861
being connected to the game and seeing results immediately.

234
00:11:19,602 --> 00:11:21,483
And it ends with only having to hit save

235
00:11:21,843 --> 00:11:23,043
to see your changes running in game.

236
00:11:23,988 --> 00:11:28,169
This has been absolutely key to developing things like our menu system and our mega map.

237
00:11:29,570 --> 00:11:31,991
So not only do we build UI and see the results right away,

238
00:11:32,351 --> 00:11:35,172
but we're always connected to live data, so in our editor viewport,

239
00:11:35,772 --> 00:11:39,433
we get a lot more flexibility to play around with ideas or even make some debug features.

240
00:11:40,293 --> 00:11:44,035
Like these debug UI graphs that show our input actions reacting in real time.

241
00:11:51,910 --> 00:11:53,991
It's not just the UI that updates live,

242
00:11:54,031 --> 00:11:55,271
but nearly all data in our game.

243
00:11:56,012 --> 00:11:57,592
We can save an object in the editor

244
00:11:57,672 --> 00:11:58,873
and it updates immediately in world,

245
00:11:59,113 --> 00:12:00,254
or change our input scripting,

246
00:12:00,394 --> 00:12:01,534
or just about any piece of data.

247
00:12:03,035 --> 00:12:04,636
Our goal is that the only time a developer

248
00:12:04,676 --> 00:12:06,977
needs to restart the editor is when getting a new version.

249
00:12:07,677 --> 00:12:09,198
And even then, they should be able to get back

250
00:12:09,238 --> 00:12:10,458
to where they were in very little time.

251
00:12:11,359 --> 00:12:13,000
The less time they spend getting up and running,

252
00:12:13,300 --> 00:12:14,500
the more time they have to make content.

253
00:12:17,897 --> 00:12:19,838
As one last element to iteration times

254
00:12:19,898 --> 00:12:22,059
is that we implement continuous integration

255
00:12:22,179 --> 00:12:23,000
with live deployment.

256
00:12:24,201 --> 00:12:26,002
What this means is that as soon as a programmer

257
00:12:26,042 --> 00:12:28,183
submits their code, our build machines will pick it up,

258
00:12:28,463 --> 00:12:30,844
compile the various targets, do some basic testing,

259
00:12:30,964 --> 00:12:33,245
and once all of that passes, the build is immediately

260
00:12:34,026 --> 00:12:35,607
made available to the development floor.

261
00:12:36,847 --> 00:12:39,248
We found that overall, the benefits of a coder

262
00:12:39,289 --> 00:12:41,049
being able to fix a bug or add a feature

263
00:12:41,470 --> 00:12:43,831
and have that change on the floor in under 30 minutes

264
00:12:44,091 --> 00:12:46,012
far outweigh any risk of a bad change

265
00:12:46,072 --> 00:12:47,293
causing problems in production.

266
00:12:49,335 --> 00:12:53,339
Our UI team all sit together, so our artists and coders

267
00:12:53,420 --> 00:12:54,701
are only a few feet away from each other.

268
00:12:55,301 --> 00:12:56,823
We're constantly working back and forth,

269
00:12:56,963 --> 00:12:58,244
implementing nodes and features,

270
00:12:58,725 --> 00:13:01,308
being able to react to them quickly enough

271
00:13:01,468 --> 00:13:02,529
so that they're never really blocked

272
00:13:02,549 --> 00:13:03,430
from working on a feature.

273
00:13:04,271 --> 00:13:06,793
This connection to the artists is what really shaped

274
00:13:06,853 --> 00:13:08,215
our UI system to what it is today.

275
00:13:10,845 --> 00:13:13,686
We use compounds, which are those reusable groups of nodes,

276
00:13:13,786 --> 00:13:14,866
for sharing functionality.

277
00:13:16,127 --> 00:13:17,707
These are an important part of our workflow.

278
00:13:18,327 --> 00:13:21,168
We can take any other graph or set of nodes

279
00:13:21,228 --> 00:13:23,169
and create a reusable component out of them.

280
00:13:24,330 --> 00:13:26,030
These can then be used in any other graph

281
00:13:26,070 --> 00:13:27,671
that supports the nodes that it contains.

282
00:13:29,391 --> 00:13:32,272
A great feature of them is that we can quickly replace them

283
00:13:32,292 --> 00:13:32,733
with code.

284
00:13:32,813 --> 00:13:35,373
This allows artists to create complex systems

285
00:13:35,413 --> 00:13:37,834
that they need, and we can easily replace them

286
00:13:37,874 --> 00:13:40,375
with an optimized code system if the need arises.

287
00:13:41,442 --> 00:13:43,764
Writing code for a finish system is way faster

288
00:13:43,804 --> 00:13:45,225
than having a coder trying to guess

289
00:13:45,265 --> 00:13:46,146
what an artist might need.

290
00:13:49,048 --> 00:13:51,190
Iteration, however, does come with a bit of a cost

291
00:13:51,230 --> 00:13:52,531
that's best summed up by Uncle Ben.

292
00:13:53,012 --> 00:13:54,593
With great power comes great responsibility.

293
00:13:55,774 --> 00:13:57,735
When it becomes so easy to make tiny changes,

294
00:13:57,755 --> 00:13:59,237
and then another, and then another,

295
00:13:59,997 --> 00:14:01,538
it also becomes easy to get lost in your work.

296
00:14:02,839 --> 00:14:04,521
Usually this just results in having to kick people

297
00:14:04,541 --> 00:14:05,742
out of the office because they're having

298
00:14:06,042 --> 00:14:06,963
way too much fun working.

299
00:14:09,272 --> 00:14:11,194
Unfortunately, in other cases, it might cause features

300
00:14:11,214 --> 00:14:14,236
to take a bit longer by losing track of time

301
00:14:14,436 --> 00:14:15,437
while trying to perfect them.

302
00:14:16,118 --> 00:14:18,079
So it's good to make sure that you have clear goals

303
00:14:18,119 --> 00:14:19,000
and deadlines in place,

304
00:14:19,440 --> 00:14:21,001
or people will just keep iterating forever.

305
00:14:23,443 --> 00:14:24,544
Towards the end of a project,

306
00:14:24,664 --> 00:14:26,866
quicker iteration can be really great

307
00:14:26,906 --> 00:14:28,767
for being able to squash those last minute bugs,

308
00:14:29,848 --> 00:14:31,890
but it also really helps to have someone in place

309
00:14:32,030 --> 00:14:33,451
that can also shut down the process.

310
00:14:34,072 --> 00:14:36,173
Those simple little changes at the end of a project

311
00:14:36,313 --> 00:14:38,595
can also easily lead to introducing new bugs.

312
00:14:42,438 --> 00:14:44,319
So now it's time to get into some of the details

313
00:14:44,399 --> 00:14:45,279
of how the system works.

314
00:14:47,581 --> 00:14:50,382
The actual UI system of Snowdrop is deceptively simple.

315
00:14:51,302 --> 00:14:53,304
The basic setup is that everything is split

316
00:14:53,344 --> 00:14:54,944
between widgets and graphics.

317
00:14:55,665 --> 00:14:58,406
Widgets take up space and are our primary source

318
00:14:58,706 --> 00:14:59,407
of mouse input.

319
00:15:00,287 --> 00:15:03,469
Graphics are used to add flavor and are generally sized

320
00:15:03,569 --> 00:15:05,070
relative to the widget they're on.

321
00:15:06,796 --> 00:15:09,598
The funny thing is that we only really have five widgets.

322
00:15:10,178 --> 00:15:13,120
Instead of giving our designers buttons and combo boxes

323
00:15:13,180 --> 00:15:15,021
and very complex widgets,

324
00:15:15,562 --> 00:15:17,723
we just gave them the very basics

325
00:15:17,803 --> 00:15:19,384
and let them build the functionality they need.

326
00:15:20,245 --> 00:15:21,385
It turns out you don't need to have

327
00:15:21,445 --> 00:15:23,447
a very complex widget library to ship games,

328
00:15:23,647 --> 00:15:24,467
especially on consoles.

329
00:15:26,489 --> 00:15:27,629
So it all starts with a window.

330
00:15:28,050 --> 00:15:29,511
This basically just tells the system

331
00:15:29,631 --> 00:15:31,032
where to start a new UI element.

332
00:15:32,012 --> 00:15:33,513
When combined with a coordinate frame,

333
00:15:33,733 --> 00:15:35,114
that can be in either 2D or 3D.

334
00:15:37,216 --> 00:15:40,678
It will automatically vertically stack all widgets given to it

335
00:15:41,679 --> 00:15:45,442
and it also is there to control how UI elements layer over top of each other.

336
00:15:48,083 --> 00:15:49,784
Text is our primary mode of communication.

337
00:15:50,385 --> 00:15:53,507
All our fonts are generated on the fly to keep memory down to what we use.

338
00:15:54,347 --> 00:15:58,370
The system has a rich formatting library to help customize text in additional ways

339
00:15:58,430 --> 00:16:00,612
by adding icons, line breaks, coloring, and much more.

340
00:16:04,852 --> 00:16:06,553
Images are the second mode of communication,

341
00:16:06,673 --> 00:16:08,214
though most of the time we're just using

342
00:16:08,314 --> 00:16:10,455
flat colors or gradients instead of actual textures.

343
00:16:11,835 --> 00:16:13,636
And it supports a bit more than just your

344
00:16:14,116 --> 00:16:15,597
basic imported DDS files.

345
00:16:16,117 --> 00:16:17,638
We have sprites, sheet systems,

346
00:16:17,858 --> 00:16:19,298
and for improved performance,

347
00:16:19,379 --> 00:16:21,119
or we can just support any loose image

348
00:16:21,159 --> 00:16:21,940
that you care to use.

349
00:16:24,832 --> 00:16:27,134
The stack container is pretty much the only thing

350
00:16:27,174 --> 00:16:28,275
we have for sorting elements.

351
00:16:29,016 --> 00:16:31,458
It just literally puts things one on top of each other.

352
00:16:32,438 --> 00:16:33,559
Or there's an option on it,

353
00:16:33,579 --> 00:16:34,980
you can put things beside each other as well.

354
00:16:35,101 --> 00:16:36,682
So you can stack vertically or horizontally.

355
00:16:39,884 --> 00:16:42,627
The scroll box is probably the only complicated widget

356
00:16:42,667 --> 00:16:45,609
that we have, and it basically just moves

357
00:16:46,450 --> 00:16:51,394
its internal contents around and defines a clip area

358
00:16:51,494 --> 00:16:52,094
that's used to...

359
00:16:54,448 --> 00:16:57,230
so that it won't render outside of defined space.

360
00:16:57,991 --> 00:17:00,052
So it's pretty much used for just scrolling content around

361
00:17:00,092 --> 00:17:01,753
and clipping it off.

362
00:17:04,415 --> 00:17:06,837
For graphics, we get a whole seven types of graphics,

363
00:17:07,077 --> 00:17:08,398
starting with more text,

364
00:17:09,259 --> 00:17:11,881
because sometimes you want more text in the background,

365
00:17:12,241 --> 00:17:13,262
not just in the foreground.

366
00:17:13,922 --> 00:17:15,243
We found that there were a lot of cases

367
00:17:15,303 --> 00:17:17,765
where we wanted to define space with a widget,

368
00:17:17,965 --> 00:17:20,267
but then use the text in the background

369
00:17:20,287 --> 00:17:21,448
to have a lot more flexibility

370
00:17:21,488 --> 00:17:23,009
with how it's rendered and displayed.

371
00:17:26,163 --> 00:17:28,624
In the graphics, you get more than just your basic square images.

372
00:17:29,465 --> 00:17:31,646
So we're able to cut some corners here or curve them.

373
00:17:36,028 --> 00:17:38,869
Lines can be used for a lot of things,

374
00:17:39,370 --> 00:17:41,951
like pointing things out in the world or framing other elements.

375
00:17:45,153 --> 00:17:46,513
Points are great for effects.

376
00:17:46,713 --> 00:17:50,515
You can make a random mess or a more controlled effect with just a little bit of math.

377
00:17:53,988 --> 00:17:55,269
And then we have arbitrary shapes,

378
00:17:55,349 --> 00:17:57,310
because sometimes even artists don't know what they want.

379
00:18:01,232 --> 00:18:03,394
Sectors are a really cool graphic that we have.

380
00:18:03,894 --> 00:18:06,155
They're basically just circles or parts of circles.

381
00:18:07,096 --> 00:18:08,917
Anything that you see that's a circle in the division

382
00:18:09,197 --> 00:18:11,418
was made with one of the sector nodes that we have.

383
00:18:12,039 --> 00:18:13,800
And it really helped to sort of define

384
00:18:15,401 --> 00:18:16,922
that graphic style of the division.

385
00:18:19,373 --> 00:18:21,334
And then finally we have custom graphics,

386
00:18:21,434 --> 00:18:22,935
which is basically everything else.

387
00:18:24,075 --> 00:18:25,756
Because something like drawing all of the streets

388
00:18:25,796 --> 00:18:27,737
of Manhattan through the regular line node

389
00:18:27,777 --> 00:18:29,497
was a little bit too much for that node to handle.

390
00:18:29,577 --> 00:18:32,018
So making a quick custom node for that

391
00:18:33,759 --> 00:18:36,140
was much better equipped to handle the amount of data

392
00:18:36,420 --> 00:18:37,441
in a much more efficient way.

393
00:18:39,701 --> 00:18:42,062
We also have a node that allows us to draw

394
00:18:42,102 --> 00:18:44,723
almost any regular graphical object directly in the UI

395
00:18:44,803 --> 00:18:46,304
so it can be layered properly with the UI.

396
00:18:49,610 --> 00:18:50,411
But that's pretty much it.

397
00:18:50,971 --> 00:18:53,033
We have a few other minor bells and whistles,

398
00:18:53,133 --> 00:18:55,354
but these 12 elements comprise the bulk of the work

399
00:18:55,394 --> 00:18:57,116
that's done every day in the UI system.

400
00:18:57,876 --> 00:18:59,437
By keeping the basic usage of the system

401
00:18:59,477 --> 00:19:02,319
as simple as possible, it allows to build up

402
00:19:02,379 --> 00:19:04,541
complex behaviors in layers where the designers

403
00:19:04,581 --> 00:19:06,302
and artists have full control at each step.

404
00:19:09,630 --> 00:19:11,191
So this might come as a surprise to some of you,

405
00:19:11,531 --> 00:19:13,491
but the Snowdrop engine does not currently have

406
00:19:13,591 --> 00:19:14,531
any form of reflection.

407
00:19:15,452 --> 00:19:18,672
That is, there's no way to automatically expose

408
00:19:18,712 --> 00:19:21,753
the inner workings of the data to editors.

409
00:19:22,773 --> 00:19:25,034
Today, almost all nodes are written by coders,

410
00:19:26,334 --> 00:19:28,434
but a bulk of the nodes, however, are quite trivial.

411
00:19:30,695 --> 00:19:33,295
So for easy nodes, we just declare the number of inputs

412
00:19:33,335 --> 00:19:36,796
and output pins, the types, and use this handy

413
00:19:36,836 --> 00:19:38,617
calculate method to do the processing.

414
00:19:39,611 --> 00:19:41,652
This allows programmers to add simple functionality

415
00:19:41,852 --> 00:19:42,353
very quickly.

416
00:19:45,635 --> 00:19:47,356
In other cases, it gets a little more complex.

417
00:19:47,857 --> 00:19:50,398
This is most of the code for this little node

418
00:19:50,438 --> 00:19:53,220
which goes through a lot of pain to output a matrix.

419
00:19:54,161 --> 00:19:56,042
But it's a really, really good matrix,

420
00:19:56,082 --> 00:19:57,863
like high quality, perfect matrix.

421
00:20:01,946 --> 00:20:02,987
It might seem like a lot of work

422
00:20:03,067 --> 00:20:04,408
to manually declare each node,

423
00:20:04,788 --> 00:20:06,069
but it also means that we have nodes

424
00:20:06,089 --> 00:20:07,790
that do exactly what they need and no more.

425
00:20:08,825 --> 00:20:11,106
We can craft each node to be as simple or as complex

426
00:20:11,146 --> 00:20:13,887
as we need to be, and with short iteration times,

427
00:20:14,007 --> 00:20:15,287
it's not nearly as bad as it sounds.

428
00:20:18,088 --> 00:20:19,269
By coding each node in this way,

429
00:20:19,329 --> 00:20:21,870
we have full control over how they execute.

430
00:20:22,370 --> 00:20:23,770
Do they need to run every frame?

431
00:20:23,830 --> 00:20:25,331
Can they be evaluated on startup?

432
00:20:25,491 --> 00:20:27,372
Or even having debug nodes that remove themselves

433
00:20:27,392 --> 00:20:28,152
from the final game.

434
00:20:30,917 --> 00:20:33,298
And in the editor, we can customize nearly every aspect,

435
00:20:33,358 --> 00:20:35,419
so complex nodes are easy to work with.

436
00:20:35,499 --> 00:20:37,840
For example, when selecting any UI node,

437
00:20:38,240 --> 00:20:40,261
you see the element in the editor that's selected,

438
00:20:40,661 --> 00:20:43,842
and our positional nodes provide elements in the viewport

439
00:20:43,862 --> 00:20:45,103
so you can interact with them directly.

440
00:20:51,705 --> 00:20:53,426
Unfortunately, our UI is not a cheap system.

441
00:20:54,126 --> 00:20:55,486
I'll break down a typical game frame

442
00:20:56,327 --> 00:20:57,427
so you can see what's going on.

443
00:20:58,356 --> 00:21:01,057
I'm going to use this scene, which is in the middle of the fight

444
00:21:01,097 --> 00:21:03,698
that takes place while trying to establish your base of operations.

445
00:21:04,338 --> 00:21:05,718
That happens fairly early on in the game.

446
00:21:07,739 --> 00:21:10,800
Here's a snapshot of our in-game profiler running on console.

447
00:21:12,140 --> 00:21:14,421
There's a lot of unused CPU time in this frame,

448
00:21:14,861 --> 00:21:18,402
but that's actually to be expected since the fight isn't really that heavy of a fight.

449
00:21:21,023 --> 00:21:24,204
To the left, we have the update of our game systems,

450
00:21:24,784 --> 00:21:26,965
input, agents, and the player, and a few other things.

451
00:21:29,271 --> 00:21:31,612
To the right, we have a big block that is the calling

452
00:21:31,692 --> 00:21:33,333
and the update of all our graphical objects

453
00:21:33,374 --> 00:21:34,134
and particle systems.

454
00:21:34,874 --> 00:21:37,196
This generally will fill up as much CPU time as it can

455
00:21:37,236 --> 00:21:38,757
to try to offload the GPU.

456
00:21:41,198 --> 00:21:43,580
And then in the middle, we have the UI,

457
00:21:43,600 --> 00:21:44,761
which is all the orange bits.

458
00:21:45,641 --> 00:21:46,702
It takes up a decent chunk,

459
00:21:46,802 --> 00:21:48,323
but it is also very multi-threaded.

460
00:21:50,524 --> 00:21:52,886
Early in the frame, we do a small bit of management

461
00:21:52,946 --> 00:21:54,346
to prepare for the updates to come.

462
00:21:56,052 --> 00:21:57,652
Next, we do a few high priority graphs

463
00:21:57,672 --> 00:21:59,792
that need to finish before the rest of the UI system can run.

464
00:21:59,872 --> 00:22:02,253
This is mostly preparing a bunch of matrices

465
00:22:02,273 --> 00:22:04,073
that will be used by other UI systems

466
00:22:04,093 --> 00:22:05,513
so we don't have to constantly recalculate them.

467
00:22:07,974 --> 00:22:09,154
Then we get to the bulk of the work,

468
00:22:09,314 --> 00:22:10,334
executing the node graphs,

469
00:22:11,114 --> 00:22:12,275
with a little tail for preparing

470
00:22:12,295 --> 00:22:13,355
the render commands for the frame.

471
00:22:16,415 --> 00:22:18,456
And this last area is the time we take

472
00:22:18,656 --> 00:22:20,336
on the CPU side of the render thread,

473
00:22:20,376 --> 00:22:21,676
submitting data to the GPU.

474
00:22:22,397 --> 00:22:23,397
I'd show the GPU cost,

475
00:22:23,437 --> 00:22:25,157
but it's almost non-existent most of the time.

476
00:22:26,852 --> 00:22:29,352
Staying in budget while developing a rich, complicated UI

477
00:22:29,472 --> 00:22:31,913
has been a major challenge since we're so CPU heavy.

478
00:22:32,933 --> 00:22:36,014
The areas here represent about 12 milliseconds of total work

479
00:22:36,174 --> 00:22:38,555
updating nearly 100 root graphs per frame.

480
00:22:39,736 --> 00:22:42,256
In total, we run over 300 graphs per frame

481
00:22:42,416 --> 00:22:44,077
across all our various systems

482
00:22:44,117 --> 00:22:45,677
comprising of nearly 30,000 nodes.

483
00:22:50,299 --> 00:22:52,660
Multithreading should now be basic knowledge for coders.

484
00:22:53,520 --> 00:22:54,800
This is just the world we live in today.

485
00:22:55,742 --> 00:22:57,683
My four year old phone had four cores,

486
00:22:58,003 --> 00:22:58,903
current consoles have eight,

487
00:22:59,003 --> 00:23:00,424
and these numbers are just gonna keep increasing.

488
00:23:01,644 --> 00:23:05,206
We no longer have a simple 33 millisecond frame for 30 FPS.

489
00:23:05,546 --> 00:23:07,907
On either console, it's around 200 milliseconds

490
00:23:07,988 --> 00:23:09,108
across all available cores.

491
00:23:10,509 --> 00:23:11,969
And all those cores need to be shared

492
00:23:12,029 --> 00:23:14,251
among so many complex and interconnected systems

493
00:23:14,731 --> 00:23:15,891
that it's no longer an option

494
00:23:15,931 --> 00:23:18,453
to just let one or two of the tech guys fix everything.

495
00:23:20,033 --> 00:23:21,294
All coders need to be on board now.

496
00:23:21,964 --> 00:23:23,926
Even our freshest interns will run into

497
00:23:23,946 --> 00:23:25,647
and need to solve complex threading issues

498
00:23:25,747 --> 00:23:27,149
very quickly when starting at Massive.

499
00:23:29,731 --> 00:23:30,572
And to make things worse,

500
00:23:30,632 --> 00:23:33,234
multi-threading is extremely complex for games.

501
00:23:34,375 --> 00:23:36,737
At our high level, we have a tasking system

502
00:23:36,857 --> 00:23:39,899
to sort dependencies between systems

503
00:23:39,960 --> 00:23:41,601
and allow major systems to run in parallel.

504
00:23:42,382 --> 00:23:43,823
At the mid-level, we have a few different ways

505
00:23:43,863 --> 00:23:45,324
of processing work in multiple threads.

506
00:23:48,287 --> 00:23:50,288
So our systems, like the UI, can go wide.

507
00:23:51,207 --> 00:23:53,408
And then at the low level, you just have to work diligently

508
00:23:53,528 --> 00:23:55,909
with different access patterns to ensure safe access to data.

509
00:23:57,991 --> 00:24:00,152
So first off, you need to make sure that every coder

510
00:24:00,192 --> 00:24:02,373
understands all the threading primitives at hand

511
00:24:02,554 --> 00:24:05,555
and when to use them, like only using spin locks for very

512
00:24:05,595 --> 00:24:08,077
tiny operations and always avoiding

513
00:24:08,357 --> 00:24:09,758
mutexes as much as possible.

514
00:24:11,899 --> 00:24:13,940
Second is to make sure that every coder understands

515
00:24:13,960 --> 00:24:16,182
the various types of access patterns that are commonly

516
00:24:16,302 --> 00:24:16,502
used.

517
00:24:17,322 --> 00:24:19,324
Every game system has different requirements

518
00:24:19,564 --> 00:24:20,745
that need to be optimized for.

519
00:24:21,861 --> 00:24:23,763
Some systems can use deferred processing,

520
00:24:23,923 --> 00:24:25,544
but others that need to stay frame synced

521
00:24:25,905 --> 00:24:27,906
might need to operate in designated safe areas

522
00:24:27,926 --> 00:24:29,688
during the frame for best performance.

523
00:24:31,069 --> 00:24:33,511
While some other non-critical systems are totally okay

524
00:24:33,571 --> 00:24:35,513
with just having mutexes to protect their data.

525
00:24:39,596 --> 00:24:40,937
And multi-threading isn't just a challenge

526
00:24:40,978 --> 00:24:41,898
for coders anymore either.

527
00:24:43,300 --> 00:24:45,602
I'm sure most games end up with loads of global variables

528
00:24:45,642 --> 00:24:46,662
to tie systems together,

529
00:24:47,863 --> 00:24:50,304
and when artists can interact with those in multiple threads,

530
00:24:50,664 --> 00:24:52,745
they can run into the same issues that coders.

531
00:24:54,766 --> 00:24:57,867
We had a lot of issues before shipping with our menu states

532
00:24:58,207 --> 00:25:00,348
because those were managed with global variables.

533
00:25:00,729 --> 00:25:01,989
It took us a while to figure out

534
00:25:02,009 --> 00:25:03,290
that it was actually a threading problem

535
00:25:03,310 --> 00:25:04,891
that was causing some of our last minute bugs.

536
00:25:08,152 --> 00:25:10,233
And when your script system is multi-threaded,

537
00:25:10,733 --> 00:25:12,114
who controls what's threaded and what isn't?

538
00:25:13,672 --> 00:25:15,573
Trying to figure out how to run things efficiently

539
00:25:15,614 --> 00:25:17,315
can be a challenge, and it's usually where coders

540
00:25:17,335 --> 00:25:18,116
still need to step in.

541
00:25:19,317 --> 00:25:22,500
The UI uses a simple high-low priority system

542
00:25:22,540 --> 00:25:25,363
to split dependencies, but our graph objects and particles

543
00:25:25,783 --> 00:25:28,526
have a much more rigorous set of options and constraints

544
00:25:28,586 --> 00:25:30,148
since there's just so many of them in the world.

545
00:25:31,269 --> 00:25:33,731
On the other side, our scripts don't do much threading

546
00:25:33,771 --> 00:25:35,473
at all, but that's mainly because they're running

547
00:25:35,533 --> 00:25:37,375
on our servers, which use a completely different

548
00:25:37,395 --> 00:25:38,436
threading model to our main game.

549
00:25:41,147 --> 00:25:42,628
Unfortunately, I don't have a lot of answers here.

550
00:25:43,008 --> 00:25:44,848
It's an area that we're still focusing a lot of effort

551
00:25:44,968 --> 00:25:46,669
on solving, and it's a work in progress.

552
00:25:47,769 --> 00:25:50,390
What does help is having more technical artists.

553
00:25:50,930 --> 00:25:52,871
That is, artists or designers that have a lot more

554
00:25:52,931 --> 00:25:54,711
technical expertise than you would normally expect,

555
00:25:54,832 --> 00:25:56,672
often having experience with scripting languages

556
00:25:57,052 --> 00:25:57,993
or other node-based tools.

557
00:26:01,654 --> 00:26:03,414
So life isn't always a rosy 30 FPS.

558
00:26:03,794 --> 00:26:05,395
Sometimes you just end up in a bad situation

559
00:26:05,435 --> 00:26:06,695
and need to figure out what's going on.

560
00:26:09,953 --> 00:26:12,394
In this example, we see a huge outlier in our thread times,

561
00:26:13,454 --> 00:26:15,835
and we already see the graph name that's causing the issue,

562
00:26:15,855 --> 00:26:17,056
so we can already start to take a look

563
00:26:17,096 --> 00:26:18,316
into what's going on here.

564
00:26:20,397 --> 00:26:22,378
So we clearly see that it's a megamap that's acting up,

565
00:26:22,458 --> 00:26:23,179
but what's going on?

566
00:26:23,519 --> 00:26:26,480
In Snowdrop, we have the tools to be able to see

567
00:26:26,520 --> 00:26:27,921
where the cost is going in a graph.

568
00:26:28,521 --> 00:26:30,562
Following the cost of the megamap,

569
00:26:30,582 --> 00:26:32,403
we find out that, unfortunately, in this case,

570
00:26:32,603 --> 00:26:34,043
it's just trying to do too much at once.

571
00:26:34,738 --> 00:26:35,738
so there's no easy fix.

572
00:26:36,398 --> 00:26:38,539
Unfortunately, just executing over 8,000 nodes

573
00:26:38,579 --> 00:26:39,979
in a single thread is still too much

574
00:26:39,999 --> 00:26:40,779
for the system to handle.

575
00:26:41,820 --> 00:26:43,320
So the two choices we have are,

576
00:26:43,700 --> 00:26:44,780
can we multi-thread this,

577
00:26:45,140 --> 00:26:46,841
or can we just do things more efficiently?

578
00:26:47,481 --> 00:26:49,742
In this case, the answer is to try to move work

579
00:26:49,782 --> 00:26:50,502
into multiple threads.

580
00:26:52,702 --> 00:26:57,123
In general, almost all of our performance improvements

581
00:26:57,504 --> 00:26:59,164
fell into one of these two categories.

582
00:27:01,843 --> 00:27:04,265
The easy one is just simply identifying what work

583
00:27:04,445 --> 00:27:05,425
can be put in other threads.

584
00:27:06,006 --> 00:27:08,687
So instead of rendering each enemy's health bar and name

585
00:27:08,787 --> 00:27:11,329
in a single loop, we can split it up to run across threads.

586
00:27:12,689 --> 00:27:14,811
The second category, and the area where we saw

587
00:27:14,831 --> 00:27:17,252
the biggest gains by far, was converting loops

588
00:27:17,372 --> 00:27:18,292
into data arrays.

589
00:27:19,333 --> 00:27:21,254
So even better than looping over each enemy

590
00:27:21,354 --> 00:27:22,995
or even processing them in multiple threads,

591
00:27:23,535 --> 00:27:24,636
is just do them all at the same time.

592
00:27:29,278 --> 00:27:31,520
This was the most powerful part of our node graph system.

593
00:27:32,326 --> 00:27:35,008
Since any interpreted system has overhead and processing,

594
00:27:35,528 --> 00:27:37,049
you need to be able to do more with less.

595
00:27:37,570 --> 00:27:40,532
In our case, it's about 300 to 500 instructions of setup

596
00:27:40,592 --> 00:27:42,833
to execute a single node plus a virtual function call.

597
00:27:44,214 --> 00:27:45,655
We can either write complex nodes

598
00:27:45,675 --> 00:27:47,156
that try to do all the work for us,

599
00:27:47,637 --> 00:27:50,739
or use arrays of data to do all the work in a single pass.

600
00:27:52,100 --> 00:27:53,741
To support this, we have a lot of fun ways

601
00:27:53,781 --> 00:27:55,162
to work with data, like filtering

602
00:27:55,202 --> 00:27:56,703
based on complex conditions.

603
00:27:57,583 --> 00:27:59,865
In this example, I can quickly filter a list of entities

604
00:27:59,925 --> 00:28:01,246
based on how close they are to the player.

605
00:28:04,115 --> 00:28:05,696
An interesting side effect of this is that

606
00:28:06,117 --> 00:28:08,478
as programmers start to become more familiar with the system,

607
00:28:08,938 --> 00:28:10,439
they start to learn new and interesting ways

608
00:28:10,479 --> 00:28:11,160
to work with data.

609
00:28:12,300 --> 00:28:14,682
I think that data-driven development is an area

610
00:28:14,722 --> 00:28:15,903
that all programmers can benefit

611
00:28:15,943 --> 00:28:17,143
from knowing a lot more intimately.

612
00:28:18,024 --> 00:28:20,025
In addition to making low-level systems data-driven,

613
00:28:20,105 --> 00:28:21,246
we should also think of how to make

614
00:28:21,286 --> 00:28:22,467
our content more data-driven.

615
00:28:23,367 --> 00:28:25,388
There's no point in having a super-optimized

616
00:28:25,408 --> 00:28:27,270
render pipeline when very basic scripts

617
00:28:27,290 --> 00:28:28,210
are taking up all your CPU.

618
00:28:31,055 --> 00:28:32,996
This is an example graph I made when developing

619
00:28:33,056 --> 00:28:34,417
for loops in the UI system.

620
00:28:35,177 --> 00:28:37,338
It does a brute force collision between 100 squares

621
00:28:37,658 --> 00:28:39,058
as they try to get out of each other's way.

622
00:28:39,739 --> 00:28:41,439
While at work, the approach was very slow,

623
00:28:41,519 --> 00:28:43,220
taking 20 milliseconds to run the graph.

624
00:28:45,661 --> 00:28:47,462
Compare this with the same approach using arrays.

625
00:28:47,902 --> 00:28:49,162
I still need to loop over each bug,

626
00:28:49,203 --> 00:28:51,163
but I don't need a second recursive loop.

627
00:28:51,724 --> 00:28:53,104
This approach does the exact same work

628
00:28:53,304 --> 00:28:54,645
in only .6 milliseconds.

629
00:28:57,384 --> 00:28:59,487
And not only is it faster, it actually took about

630
00:29:00,069 --> 00:29:02,373
100 or 30% fewer nodes to do the same work.

631
00:29:07,142 --> 00:29:08,725
Sometimes though, it's the small features

632
00:29:08,745 --> 00:29:09,546
that make a big difference.

633
00:29:10,579 --> 00:29:12,520
One of the best little things we added was the ability

634
00:29:12,580 --> 00:29:15,442
to hold the control button and mouse over any UI element

635
00:29:15,703 --> 00:29:17,684
and show what file it's being drawn from.

636
00:29:18,425 --> 00:29:20,146
When you have data from all over the place,

637
00:29:20,567 --> 00:29:22,628
it's hard to keep track of, so this became essential

638
00:29:22,668 --> 00:29:25,370
to being able to quickly track down bugs in the end,

639
00:29:25,410 --> 00:29:26,631
especially when it's in graphs

640
00:29:26,671 --> 00:29:29,814
that may not be done by your team.

641
00:29:32,656 --> 00:29:34,398
To ease the localization burden,

642
00:29:34,438 --> 00:29:35,639
we added a few small features

643
00:29:35,679 --> 00:29:37,640
that drastically reduced the implementation overhead.

644
00:29:38,413 --> 00:29:42,335
like automatically trying to figure out what to show for a given game action

645
00:29:42,836 --> 00:29:45,657
on console or on PC or on PC with a console controller.

646
00:29:48,699 --> 00:29:50,800
Since we shipped the division in Arabic,

647
00:29:51,000 --> 00:29:53,842
we also added support for right to left languages through various means.

648
00:29:54,843 --> 00:29:58,485
In any list of UI elements, you can quickly reverse the order.

649
00:29:58,965 --> 00:30:02,187
So for text, we have an auto-justification mode

650
00:30:02,207 --> 00:30:04,108
that will be left to right depending on the current language.

651
00:30:09,047 --> 00:30:12,090
We already had a system in place to input data into our strings,

652
00:30:12,951 --> 00:30:16,313
so we simply extended it so that we can interpret numbers

653
00:30:16,554 --> 00:30:18,675
into language-specific replacement rules.

654
00:30:19,916 --> 00:30:22,499
It turns out there are very concrete rules for every language

655
00:30:22,559 --> 00:30:25,301
about what types of replacements exist for different numbers.

656
00:30:25,641 --> 00:30:27,703
I suggest you check out that link for more information.

657
00:30:31,486 --> 00:30:33,788
Another one was an in-game test for color blindness.

658
00:30:34,728 --> 00:30:37,048
Since the UI had a lot of render control

659
00:30:37,188 --> 00:30:38,649
and also has the final render pass,

660
00:30:39,069 --> 00:30:41,249
it was really easy to just transform all the colors

661
00:30:41,410 --> 00:30:43,530
in a way that can be used to see where you might be having

662
00:30:43,570 --> 00:30:44,710
difficulty with certain colors.

663
00:30:45,891 --> 00:30:47,351
We use this to figure out what colors

664
00:30:47,391 --> 00:30:49,692
we needed to change for our various colorblind options.

665
00:30:51,412 --> 00:30:54,533
We simply enable it in our in-game debug menu, which

666
00:30:54,573 --> 00:30:56,093
was also made with our UI system.

667
00:30:57,274 --> 00:31:02,115
And then we used it to see what item colors worked and didn't

668
00:31:02,135 --> 00:31:04,195
work with the various different colorblind.

669
00:31:10,918 --> 00:31:12,939
So I hope you were able to take away a few things

670
00:31:12,959 --> 00:31:14,099
from our experience on the division,

671
00:31:14,319 --> 00:31:16,820
like the importance of iteration, threading, and data.

672
00:31:18,300 --> 00:31:21,821
I do have a few other things that we learned,

673
00:31:21,841 --> 00:31:23,441
and, or that we would like to do better in the future

674
00:31:23,481 --> 00:31:24,141
that I would like to share.

675
00:31:27,842 --> 00:31:30,343
It's very easy for me to say that our UI system

676
00:31:30,403 --> 00:31:32,963
is just as equally developed by our artists

677
00:31:33,083 --> 00:31:34,024
as it was by our coders.

678
00:31:35,284 --> 00:31:38,725
Every feature was reviewed and approved by the team members.

679
00:31:39,788 --> 00:31:41,449
We're always delivering code for someone else,

680
00:31:41,709 --> 00:31:44,010
so the user should have a say in how it works in the end.

681
00:31:47,870 --> 00:31:50,351
Throughout the whole project, we had a constant feedback loop

682
00:31:50,391 --> 00:31:51,351
with our tools and systems.

683
00:31:52,452 --> 00:31:54,772
Any request or complaint was considered

684
00:31:54,832 --> 00:31:55,873
and addressed if possible.

685
00:31:57,173 --> 00:31:58,933
It's most important to do this during crunch,

686
00:31:59,613 --> 00:32:01,294
when everyone is really, really stressed,

687
00:32:02,114 --> 00:32:04,875
that we take time to listen and see if we can do

688
00:32:04,995 --> 00:32:06,835
even some small things to improve development.

689
00:32:07,901 --> 00:32:09,941
Sometimes it's just simple little things like

690
00:32:10,101 --> 00:32:11,682
trying to reduce the number of clicks required

691
00:32:11,702 --> 00:32:12,742
to do common operations,

692
00:32:13,302 --> 00:32:14,763
or finally fixing that editor crash

693
00:32:14,783 --> 00:32:16,863
that's causing just one person to constantly restart.

694
00:32:21,364 --> 00:32:22,324
By the end of the project,

695
00:32:22,604 --> 00:32:24,305
I had a huge list of features and improvements

696
00:32:24,345 --> 00:32:25,665
that we didn't get a chance to implement.

697
00:32:26,725 --> 00:32:27,946
We've been slowly tackling them

698
00:32:28,026 --> 00:32:29,726
so that we can just continue to improve

699
00:32:30,386 --> 00:32:31,507
the tools for our users.

700
00:32:37,127 --> 00:32:38,567
To get the most out of your code,

701
00:32:38,927 --> 00:32:40,247
I think threading and data need to be

702
00:32:40,267 --> 00:32:41,428
in the back of your minds at all time.

703
00:32:42,508 --> 00:32:43,908
Multi-threading was considered a lot

704
00:32:43,968 --> 00:32:45,649
for the internals of the UI system,

705
00:32:46,229 --> 00:32:47,369
but not as much for the users.

706
00:32:48,190 --> 00:32:50,610
We had a lot of hard to track issues towards the end

707
00:32:50,630 --> 00:32:52,291
that could have been prevented with some tools

708
00:32:52,331 --> 00:32:53,871
for users to manage their data better.

709
00:32:56,592 --> 00:32:58,932
Getting data models correct can be a challenge,

710
00:32:59,112 --> 00:33:00,153
but it's well worth the effort.

711
00:33:01,250 --> 00:33:03,532
It took us a while to fully appreciate the power

712
00:33:03,692 --> 00:33:04,852
of a data-driven approach,

713
00:33:05,373 --> 00:33:06,773
but it made the single biggest difference

714
00:33:06,893 --> 00:33:08,875
in performance in the division.

715
00:33:14,057 --> 00:33:15,938
While our UI system is very powerful,

716
00:33:16,399 --> 00:33:18,160
the main complaint that we get over and over

717
00:33:18,240 --> 00:33:19,660
is that it's too complicated to use.

718
00:33:20,541 --> 00:33:22,562
It does take a while for someone to really get into,

719
00:33:23,302 --> 00:33:25,664
and most of our work is done by technical artists

720
00:33:25,784 --> 00:33:27,305
that usually have some scripting background.

721
00:33:29,722 --> 00:33:33,505
The big reason for the difficulty is the lack of direct canvas manipulation.

722
00:33:34,366 --> 00:33:39,050
I firmly believe now though that had we added it, it would have actually limited the creativity

723
00:33:39,150 --> 00:33:40,952
even if it did make some things easier to do.

724
00:33:41,953 --> 00:33:46,838
By removing the canvas, the designer has to really work hard to understand the system.

725
00:33:47,338 --> 00:33:50,641
And it was through this special connection that a lot of magic really started to happen

726
00:33:50,661 --> 00:33:51,121
with Division.

727
00:33:54,721 --> 00:33:56,502
We're constantly trying to improve our workflow,

728
00:33:56,802 --> 00:33:59,323
but in ways that doesn't dumb down the entire system.

729
00:34:00,064 --> 00:34:02,045
I've been against adding direct canvas manipulation

730
00:34:02,065 --> 00:34:04,006
because I believe it would just make our artists lazy

731
00:34:04,666 --> 00:34:06,427
and take a lot of creativity out of our design.

732
00:34:10,249 --> 00:34:12,450
As is the usual case, it's hard to find time

733
00:34:12,470 --> 00:34:15,852
to prepare documentation and good examples

734
00:34:15,872 --> 00:34:16,512
during development.

735
00:34:17,877 --> 00:34:19,017
We tried to make it a priority,

736
00:34:20,037 --> 00:34:21,838
and we do have a bunch of wiki pages

737
00:34:21,898 --> 00:34:23,458
and video tutorials and things like that,

738
00:34:23,798 --> 00:34:24,799
but there's always room for more.

739
00:34:26,139 --> 00:34:27,579
I think the biggest problem that we had

740
00:34:28,580 --> 00:34:31,400
wasn't necessarily the lack of documentation,

741
00:34:32,041 --> 00:34:33,201
but the organization of it.

742
00:34:33,981 --> 00:34:35,602
You can have all the help pages in the world,

743
00:34:36,242 --> 00:34:37,682
but if you can't find them, it's not gonna help.

744
00:34:41,143 --> 00:34:42,584
And I find this is one of the most important,

745
00:34:43,604 --> 00:34:45,424
but often overlooked lessons that I can offer,

746
00:34:45,564 --> 00:34:46,625
is just keep it simple.

747
00:34:49,700 --> 00:34:52,181
It's very easy for programmers to fall in the trap

748
00:34:52,541 --> 00:34:53,582
of overthinking things.

749
00:34:54,462 --> 00:34:55,183
More often than not,

750
00:34:55,223 --> 00:34:57,284
the solution is much easier than it seems.

751
00:34:58,144 --> 00:35:00,266
I find borrowing from test-driven development

752
00:35:00,346 --> 00:35:01,126
can help a lot here.

753
00:35:01,967 --> 00:35:05,088
You start by writing what you need the code to do,

754
00:35:05,528 --> 00:35:07,129
and then you fill in the code to do that,

755
00:35:07,810 --> 00:35:08,430
and then you stop.

756
00:35:09,371 --> 00:35:11,152
If you added any more code than you needed,

757
00:35:11,292 --> 00:35:12,212
then you added too much code.

758
00:35:15,026 --> 00:35:15,967
The same goes for tools.

759
00:35:16,487 --> 00:35:18,549
It can often be a bit of a balancing act

760
00:35:18,609 --> 00:35:20,230
between what someone thinks they need

761
00:35:20,410 --> 00:35:21,251
and what they actually need.

762
00:35:22,351 --> 00:35:24,453
But simple tools that work consistently

763
00:35:24,553 --> 00:35:26,615
and quickly without crashing are going to be

764
00:35:26,715 --> 00:35:29,477
far more useful than barely functioning complex tools.

765
00:35:33,860 --> 00:35:35,161
That actually went a lot quicker than I thought.

766
00:35:38,123 --> 00:35:39,404
So I hope you were able to get some ideas

767
00:35:39,484 --> 00:35:40,705
out of our experience on the division

768
00:35:40,945 --> 00:35:42,606
to improve your own games and engines.

769
00:35:43,858 --> 00:35:47,259
At this point, I'd just like to give a shout out to Anders Johansson,

770
00:35:47,279 --> 00:35:49,560
our lead UI designer, and Lars Vincent,

771
00:35:49,700 --> 00:35:51,640
our lead UI artist on the division, because

772
00:35:52,260 --> 00:35:55,141
I firmly believe that they were as much a part of making this UI system

773
00:35:55,401 --> 00:35:56,261
as any of our coders.

774
00:35:59,182 --> 00:36:02,303
If anyone has any questions about anything related to Snowdrop or the division,

775
00:36:02,803 --> 00:36:05,124
I'm more than happy to answer as best I can.

776
00:36:05,164 --> 00:36:05,744
Thank you for listening.

777
00:36:14,330 --> 00:36:15,390
Hi, enjoyed that, thank you.

778
00:36:15,631 --> 00:36:15,871
Thanks.

779
00:36:16,071 --> 00:36:19,653
You talked about how users still ask for the ability

780
00:36:19,673 --> 00:36:21,394
to directly manipulate the canvas,

781
00:36:21,454 --> 00:36:24,496
but you reasoned that forcing them to understand the system

782
00:36:24,536 --> 00:36:25,877
resulted in a lot of magic.

783
00:36:26,598 --> 00:36:28,519
Can you describe that more?

784
00:36:28,599 --> 00:36:30,080
I was really surprised to hear that.

785
00:36:32,201 --> 00:36:36,044
So, yeah, all of our Node Graph systems

786
00:36:36,064 --> 00:36:37,745
are basically like scripting languages.

787
00:36:37,765 --> 00:36:39,786
So you're basically, you're building the logic

788
00:36:39,846 --> 00:36:41,227
to build your UI system.

789
00:36:43,361 --> 00:36:45,823
And like every time we sit down and we evaluate and we're like,

790
00:36:45,843 --> 00:36:49,005
what's it going to cost to bring this sort of direct canvas manipulation?

791
00:36:49,065 --> 00:36:50,966
And then we plug in the numbers and we're like, okay,

792
00:36:50,986 --> 00:36:52,928
it's going to take like three months or four months or whatever.

793
00:36:53,728 --> 00:36:57,271
And then at the end it's like, what are we really going to improve the situation

794
00:36:57,351 --> 00:37:00,033
for, for people? Um, and it's like, okay,

795
00:37:00,053 --> 00:37:02,754
we might get some things to be able to just like stretch and move things,

796
00:37:02,794 --> 00:37:05,776
but you can already do that with the nodes once you get a chance to learn them.

797
00:37:05,816 --> 00:37:08,318
So it's just, it's, it's that level. It's like when we,

798
00:37:08,358 --> 00:37:12,041
when we think about the coder investment to just add all of the work, um,

799
00:37:13,113 --> 00:37:14,434
It just never feels worth it.

800
00:37:18,077 --> 00:37:18,277
Hi.

801
00:37:19,017 --> 00:37:19,518
Oh, sorry.

802
00:37:19,618 --> 00:37:21,379
Here you go.

803
00:37:21,639 --> 00:37:25,022
I worked on a similar system on a much smaller scale,

804
00:37:25,242 --> 00:37:27,204
and I was wondering how did you handle merge conflicts

805
00:37:27,264 --> 00:37:29,065
putting all your code into data?

806
00:37:31,687 --> 00:37:32,047
Not well.

807
00:37:34,729 --> 00:37:36,391
It became a bit of an issue.

808
00:37:39,900 --> 00:37:42,604
post-launch when we had a lot of different branches and stuff like that.

809
00:37:43,786 --> 00:37:44,987
We actually ended up implementing

810
00:37:47,031 --> 00:37:49,855
instead of, well, as sort of like a quick fix,

811
00:37:50,776 --> 00:37:54,041
we basically set it up so that you can't modify data in two branches.

812
00:37:55,346 --> 00:37:57,347
And then we just have some processes in place so that,

813
00:37:57,547 --> 00:37:58,988
like if you, obviously you have to,

814
00:37:59,588 --> 00:38:01,629
but once you know that you're causing a conflict

815
00:38:01,649 --> 00:38:03,449
between the branches, then you can sort of take

816
00:38:03,469 --> 00:38:05,630
the steps necessary to resolve that ahead of time,

817
00:38:06,330 --> 00:38:08,251
instead of having, ending up in a situation

818
00:38:08,271 --> 00:38:10,572
where you have lots of data modified in multiple branches

819
00:38:10,612 --> 00:38:14,213
and then you end up in the merge hell.

820
00:38:14,313 --> 00:38:16,134
So by just adding a quick feature that basically said,

821
00:38:16,254 --> 00:38:17,595
I'm about to cause a conflict,

822
00:38:18,475 --> 00:38:21,056
it allowed us to sort of get ahead of the problems.

823
00:38:22,136 --> 00:38:22,756
It's awesome, thank you.

824
00:38:24,046 --> 00:38:24,226
Hi.

825
00:38:24,846 --> 00:38:27,288
I was wondering how your team handled

826
00:38:27,348 --> 00:38:30,509
ownership of cross-disciplinary issues.

827
00:38:30,529 --> 00:38:33,751
Like for the main menu, you had to frame the character

828
00:38:33,871 --> 00:38:35,011
and also put the UI up.

829
00:38:35,432 --> 00:38:38,833
So how were you able to communicate

830
00:38:38,873 --> 00:38:41,014
and make sure the framing worked and showed

831
00:38:41,034 --> 00:38:41,855
the UI at the same time?

832
00:38:44,579 --> 00:38:47,941
I'm not sure I kind of get the question. I mean for the case of the main menu,

833
00:38:49,622 --> 00:38:54,504
that's all controlled sort of in our UI system. So the UI takes control of the camera and frames it.

834
00:38:54,865 --> 00:38:58,887
I think we even add a couple lights in the world to make sure that the player is lit at all times, even at night.

835
00:38:58,967 --> 00:39:00,448
But that was the UI team that handled that.

836
00:39:01,093 --> 00:39:01,873
It was the UI team.

837
00:39:02,114 --> 00:39:05,836
I mean, we also communicate very closely with all the other teams and stuff like that, just

838
00:39:05,856 --> 00:39:09,779
to make sure that, like I said, we added a bunch of lights in the world so that we're

839
00:39:09,819 --> 00:39:11,980
not busting our light budget and things like that.

840
00:39:12,921 --> 00:39:17,524
So most of the people on the division, we all work fairly close together.

841
00:39:17,544 --> 00:39:22,227
So there's actually a lot of cross-disciplinary, like, crossover and stuff like that.

842
00:39:22,948 --> 00:39:23,188
Thank you.

843
00:39:26,993 --> 00:39:30,095
Hey, could you talk a little bit about how you build the Node

844
00:39:30,135 --> 00:39:32,717
graphs and execute them, or how you optimize them?

845
00:39:35,299 --> 00:39:38,122
Well, for that, I guess one of the things I was going to

846
00:39:38,142 --> 00:39:42,725
suggest is, hands up, would anyone be interested in sort of

847
00:39:42,765 --> 00:39:44,206
a live demo of the UI system?

848
00:39:46,288 --> 00:39:46,849
OK, wow.

849
00:39:47,349 --> 00:39:52,253
All right, in that case, at 1 o'clock at the Ubisoft booth.

850
00:39:53,873 --> 00:39:55,034
I'll have the editor up and running,

851
00:39:55,354 --> 00:39:57,516
and I can give a live demo and then

852
00:39:58,036 --> 00:40:00,878
go over that general process if you want.

853
00:40:01,318 --> 00:40:01,598
Thank you.

854
00:40:02,058 --> 00:40:05,220
Hi.

855
00:40:05,500 --> 00:40:07,621
I'm just interested in a little bit more information

856
00:40:07,661 --> 00:40:10,003
about the loops versus data arrays.

857
00:40:10,523 --> 00:40:11,764
Is that distinction as in you're then

858
00:40:11,804 --> 00:40:13,425
passing the full array to the node

859
00:40:13,465 --> 00:40:16,427
and handling that code side rather than node execution

860
00:40:16,467 --> 00:40:16,787
in loops?

861
00:40:18,049 --> 00:40:24,475
Exactly. So the way our node system is built is that each piece of data, it doesn't matter if it's one or more.

862
00:40:26,097 --> 00:40:32,322
And so then we move that looping basically directly into code and then we remove all the overhead of the actual...

863
00:40:33,724 --> 00:40:39,109
script processing and it made huge like as the example I showed it made one

864
00:40:39,129 --> 00:40:43,593
graph go from 20 milliseconds to 0.6 and so we got we got those gains pretty much

865
00:40:43,653 --> 00:40:47,557
anytime we did that it was gains like that. And have you looked at being able

866
00:40:47,577 --> 00:40:51,641
to write the nodes back down into code and compile them into code to remove that overhead?

867
00:40:53,823 --> 00:40:57,387
One of the problems is is just since we have our node system that works in

868
00:40:58,519 --> 00:40:59,459
a whole bunch of different ways.

869
00:41:00,280 --> 00:41:02,321
Like, we have the same system that works

870
00:41:02,361 --> 00:41:04,443
in a whole bunch of different contexts.

871
00:41:06,465 --> 00:41:08,226
It's just a huge amount of work to both

872
00:41:08,766 --> 00:41:10,408
write the code that does the work and then also

873
00:41:10,528 --> 00:41:12,149
make sure that it compiles down to proper code

874
00:41:12,169 --> 00:41:13,370
that's going to work in all situations.

875
00:41:13,850 --> 00:41:16,792
However, we do have some types of graphs,

876
00:41:16,832 --> 00:41:18,534
like our shader graphs, which effectively do that.

877
00:41:19,134 --> 00:41:20,915
They're basically generating the shader code.

878
00:41:20,956 --> 00:41:22,657
So, it's definitely something that we've

879
00:41:22,677 --> 00:41:24,298
sort of talked about, but it's...

880
00:41:25,999 --> 00:41:30,901
I think it's a hard, in our case, it's a hard thing to do on such like a global scale

881
00:41:31,161 --> 00:41:33,743
just because all our graphs actually function in very different ways.

882
00:41:34,723 --> 00:41:34,983
Thank you.

883
00:41:37,604 --> 00:41:43,167
Hey, you alluded to giving developers control over certain rendering aspects like the depth

884
00:41:43,227 --> 00:41:44,027
buffer, things like that.

885
00:41:44,067 --> 00:41:48,569
Could you explain a little bit about how much flexibility there is in terms of where widgets

886
00:41:48,609 --> 00:41:51,770
and graphics can be rendered and how they interact with post effects and things like

887
00:41:51,790 --> 00:41:51,870
that?

888
00:41:53,019 --> 00:41:56,382
Sure, so the UI system is like,

889
00:41:57,544 --> 00:41:58,945
it's directly integrated into the render,

890
00:41:59,005 --> 00:42:02,409
so we pretty much on a feature by feature basis,

891
00:42:02,469 --> 00:42:03,651
we can sort of add and remove.

892
00:42:05,493 --> 00:42:06,313
you know, whatever we want.

893
00:42:06,353 --> 00:42:07,973
We just need to put the time in to do it.

894
00:42:08,033 --> 00:42:09,474
So when we ship the division,

895
00:42:09,494 --> 00:42:11,994
our UI actually had seven render passes

896
00:42:13,594 --> 00:42:16,275
and would make use of some of the data

897
00:42:16,315 --> 00:42:17,735
that's generated from the game.

898
00:42:17,835 --> 00:42:20,155
So the game's depth buffer and things like that

899
00:42:20,235 --> 00:42:21,116
at various different points.

900
00:42:21,816 --> 00:42:23,896
And then we can sort of use the different data

901
00:42:23,996 --> 00:42:24,856
during the different passes

902
00:42:24,896 --> 00:42:26,416
to achieve a whole bunch of different effects.

903
00:42:26,456 --> 00:42:27,697
So we use them for things like

904
00:42:28,517 --> 00:42:29,977
highlighting enemies behind walls

905
00:42:30,577 --> 00:42:32,237
after we pulse and things like that.

906
00:42:33,678 --> 00:42:33,818
That.

907
00:42:34,478 --> 00:42:34,598
Yeah.

908
00:42:34,947 --> 00:42:41,928
helps. Hi, I was a little late so tell me if I'm asking about

909
00:42:42,008 --> 00:42:45,869
something that you're talking about. I have a rather simple

910
00:42:46,009 --> 00:42:52,231
question. How you handle stuff like layouting, what is the

911
00:42:52,391 --> 00:42:56,652
centered topping left or something like this? Is this?

912
00:42:57,092 --> 00:42:58,212
Like anchoring? Yeah.

913
00:43:00,285 --> 00:43:06,589
So when I explain, so we have a window and we have coordinate frames and our 2D coordinate frame basically supports all the anchoring for that.

914
00:43:07,669 --> 00:43:12,372
And so you can anchor to the left, you can position things based on pixel or percentage positions.

915
00:43:13,633 --> 00:43:20,077
And then we also have built-in support for like safe areas on consoles and multi-screen support on PC for different things like that.

916
00:43:20,657 --> 00:43:22,998
Local scaling, yes, something like that.

917
00:43:23,338 --> 00:43:23,639
For what?

918
00:43:24,259 --> 00:43:25,160
Local scaling.

919
00:43:26,000 --> 00:43:27,201
Scaling, yeah, we have a...

920
00:43:28,404 --> 00:43:30,184
I think we can do like automatic scaling.

921
00:43:30,324 --> 00:43:34,845
A lot of the scaling we do on our own just because we found that especially with things

922
00:43:34,905 --> 00:43:42,126
in 3D versus 2D, there isn't sort of an automatic scaling that's applied to everything.

923
00:43:42,506 --> 00:43:46,427
There's a few options for different types of automatic scaling, but we just found like

924
00:43:46,867 --> 00:43:49,688
different UI in different situations would have slightly different requirements.

925
00:43:49,748 --> 00:43:55,909
So we sort of just kept those all as options that can be manipulated in each situation.

926
00:43:56,189 --> 00:44:14,157
and any errors in context of scaling. If you have any problems when move from one for example you

927
00:44:14,177 --> 00:44:24,722
know one scaling for example and another yeah from uh.

928
00:44:26,708 --> 00:44:35,863
50% more and things like you have gap between some elements and they look differently.

929
00:44:36,464 --> 00:44:36,584
Oh.

930
00:44:36,784 --> 00:44:37,586
This.

931
00:44:38,828 --> 00:44:39,128
Yeah.

932
00:44:39,208 --> 00:44:39,910
Something like that.

933
00:44:41,698 --> 00:44:45,099
I mean, I guess it's hard to, I guess, explain without an example.

934
00:44:45,139 --> 00:44:52,141
Maybe that's something at the live demo I can try to sort of sort out how we do that.

935
00:44:52,201 --> 00:44:57,043
But generally, like if you within an individual element, if you scale it,

936
00:44:57,083 --> 00:44:58,123
it's going to scale uniformly.

937
00:44:58,143 --> 00:45:00,044
So you're not going to introduce gaps or anything like that.

938
00:45:00,644 --> 00:45:03,185
If you have multiple different elements and you're trying to manage the scaling

939
00:45:03,245 --> 00:45:06,566
between them in a synchronous way, then if you mess up the math,

940
00:45:06,766 --> 00:45:08,087
then you can end up in a bad situation.

941
00:45:13,635 --> 00:45:17,177
I had a question about clipping.

942
00:45:17,297 --> 00:45:22,981
So when you can bring up the main menu, you can do it at any point in the game and you

943
00:45:23,001 --> 00:45:25,622
could be right close to a wall or you could be clipping next to an object.

944
00:45:26,002 --> 00:45:27,283
How did you deal with clipping?

945
00:45:27,723 --> 00:45:30,285
And I had to follow up another question about the mega map.

946
00:45:31,967 --> 00:45:33,588
Originally you had the the

947
00:45:34,468 --> 00:45:37,849
Megamap kind of start off as part of the game world

948
00:45:38,089 --> 00:45:43,571
So I think it was in the first reveal that you guys showed the megamap was kind of like in the sea

949
00:45:44,511 --> 00:45:49,372
Are you fading out the complete city to gray when you're doing the megamap now in the game?

950
00:45:50,333 --> 00:45:53,293
Was that just because of clipping issues and that kind of thing?

951
00:45:54,260 --> 00:46:01,223
Right, so for the main menu clipping, in general we just detect as soon as the camera hits something.

952
00:46:02,203 --> 00:46:08,705
We found that it was, there were too many edge cases when trying to keep the camera in a safe space.

953
00:46:09,525 --> 00:46:13,927
So we found in the end it was just better to, as soon as the camera just hits something and we're going to clip,

954
00:46:14,647 --> 00:46:17,548
we sort of go into this mode where we kind of blank out the world using the...

955
00:46:20,038 --> 00:46:21,259
I'm trying to remember the term,

956
00:46:21,279 --> 00:46:23,701
but we basically just use sort of like the general color of the world.

957
00:46:23,781 --> 00:46:26,703
So, so it's not like a fixed color that we sort of like,

958
00:46:26,723 --> 00:46:28,185
we don't gray out the world to a fixed color.

959
00:46:28,205 --> 00:46:31,407
We do it to a color that sort of makes sense to the current state of the world.

960
00:46:32,308 --> 00:46:34,510
For the mega map, we do a similar technique.

961
00:46:35,891 --> 00:46:37,532
Most cases when you bring up the mega map,

962
00:46:37,552 --> 00:46:39,234
you're going to still see the world a little bit.

963
00:46:39,894 --> 00:46:41,816
And then we just, we sort of fade it out for,

964
00:46:41,836 --> 00:46:44,798
for like for clipping like, you know,

965
00:46:44,838 --> 00:46:45,799
because there's going to be things that.

966
00:46:48,164 --> 00:46:51,328
and for readability because we have found that towards the end,

967
00:46:51,348 --> 00:46:54,332
like when you had the world and the megamap at the same time,

968
00:46:54,392 --> 00:46:58,537
it just became too noisy and it was hard to read and make use of it.

969
00:46:58,597 --> 00:47:00,820
So you get it for a moment when you first open the megamap,

970
00:47:00,840 --> 00:47:03,643
but then we fade out the world so that you're focused on using the megamap.

971
00:47:09,139 --> 00:47:10,681
All right, I guess that's about it.

972
00:47:10,741 --> 00:47:12,604
So yeah, one o'clock today at the Ubisoft booth.

973
00:47:12,764 --> 00:47:15,968
I'll have a live demo of the Snowdrop engine up and running

974
00:47:16,409 --> 00:47:20,154
and if anyone wants to see how the UI system works,

975
00:47:21,075 --> 00:47:21,796
feel free to stop by.

976
00:47:22,637 --> 00:47:22,878
Thank you.

