1
00:00:06,785 --> 00:00:08,325
All right.

2
00:00:08,325 --> 00:00:10,346
Yeah, my name is Mika Vehkela, and I

3
00:00:10,346 --> 00:00:13,908
work for Remedy Entertainment as a lead AI programmer.

4
00:00:13,908 --> 00:00:16,609
And in this session, together with Bobby and Ben,

5
00:00:16,609 --> 00:00:20,510
I talk about our experiences working with behavior trees.

6
00:00:20,510 --> 00:00:23,111
And in my part, I'm going to be talking a little bit

7
00:00:23,111 --> 00:00:27,533
about a quick touch up on this blackboard and database, which

8
00:00:27,533 --> 00:00:30,414
is used together with behavior trees

9
00:00:30,414 --> 00:00:32,075
almost in all the implementations.

10
00:00:32,075 --> 00:00:35,396
Then the most of the talk that I'm going to give

11
00:00:35,396 --> 00:00:36,036
is about decorators.

12
00:00:37,230 --> 00:00:41,111
And then little bit about splitting the trees and then

13
00:00:41,111 --> 00:00:44,632
also about coordination using the ever trees.

14
00:00:44,632 --> 00:00:48,533
So some of the challenge areas that I've faced using multiple

15
00:00:48,533 --> 00:00:51,614
different implementations in different games have been

16
00:00:51,614 --> 00:00:54,454
always the same thing it sounds like a simple stuff, but it

17
00:00:54,454 --> 00:00:59,435
still comes up time after time it's the generalization and

18
00:00:59,435 --> 00:01:02,936
granularity of tasks so the so in in like pre production

19
00:01:02,936 --> 00:01:03,436
production.

20
00:01:04,370 --> 00:01:07,352
And then of course between game projects as well so you would like to of course

21
00:01:07,352 --> 00:01:12,017
build eventually this library of reusable building blocks of decorators

22
00:01:12,017 --> 00:01:16,941
and notes that you could use then you know in in future games as well.

23
00:01:16,941 --> 00:01:21,505
And then also there seems to be this question especially from designers

24
00:01:21,505 --> 00:01:24,528
working with this this implementation is that how do you deal with

25
00:01:24,528 --> 00:01:27,190
interruptions and transitions in the behavior trees.

26
00:01:28,265 --> 00:01:31,326
But before I go to all these notes and decorators, a quick

27
00:01:31,326 --> 00:01:33,007
glance at these databases.

28
00:01:33,007 --> 00:01:37,109
So most often what people have in conjunction with the

29
00:01:37,109 --> 00:01:40,831
behavior trees is some kind of a blackboard implementation

30
00:01:40,831 --> 00:01:43,312
and also this kind of sensory systems that the sensors will

31
00:01:43,312 --> 00:01:46,773
basically reflect the data from the game world from all

32
00:01:46,773 --> 00:01:50,975
over the memory and then store it inside a database, a

33
00:01:50,975 --> 00:01:52,296
compressed format.

34
00:01:52,936 --> 00:01:55,637
And the behavior tree is only reading through this database.

35
00:01:55,637 --> 00:01:57,578
It can read and write there.

36
00:01:57,578 --> 00:01:59,679
So it's still a good idea to keep in mind

37
00:01:59,679 --> 00:02:02,521
that the simpler this implementation of the database

38
00:02:02,521 --> 00:02:05,122
is, and the data format, and the more compact it is,

39
00:02:05,122 --> 00:02:07,943
the easier it's going to be to implement all of your nodes

40
00:02:07,943 --> 00:02:10,645
and decorators, especially for conditions.

41
00:02:10,645 --> 00:02:12,345
It also makes the debugging easier,

42
00:02:12,345 --> 00:02:13,606
which is pretty obvious.

43
00:02:13,606 --> 00:02:17,408
But if you have a very condensed and a nice implementation,

44
00:02:17,408 --> 00:02:20,890
you can just basically list out of all the properties

45
00:02:20,890 --> 00:02:22,390
that this NPC knows of.

46
00:02:23,695 --> 00:02:25,956
And then finally, of course, it performs better,

47
00:02:25,956 --> 00:02:28,176
because if you have a very compressed set of data

48
00:02:28,176 --> 00:02:29,837
that you're accessing, it's going

49
00:02:29,837 --> 00:02:33,518
to be much better than accessing the memory all over the place.

50
00:02:33,518 --> 00:02:35,539
So one example, and I'm using this kind

51
00:02:35,539 --> 00:02:37,400
of method in this presentation, how

52
00:02:37,400 --> 00:02:40,141
you could implement the database would

53
00:02:40,141 --> 00:02:43,402
be to have one single dictionary per tracked

54
00:02:43,402 --> 00:02:46,203
entity or a known entity for each of the NPCs.

55
00:02:46,203 --> 00:02:47,564
And this dictionary is just a.

56
00:02:48,584 --> 00:02:55,368
list of properties, key value pairs that this NPC knows of each of these tracked entities.

57
00:02:55,368 --> 00:03:01,130
So in this example, for example, we have an entry for self, the agent itself, and in this

58
00:03:01,130 --> 00:03:05,993
example it would have only one property, primary target, set to enemy01, which happens to be

59
00:03:05,993 --> 00:03:11,155
the other entry, another dictionary in your database that has one property which is visible

60
00:03:11,155 --> 00:03:11,436
is true.

61
00:03:12,436 --> 00:03:17,441
And you can reference these entries in the database in your decorators and nodes

62
00:03:17,441 --> 00:03:19,603
just by using a string path.

63
00:03:19,603 --> 00:03:25,549
So for example, self.primaryTarget means that you take a look at the self entity

64
00:03:25,549 --> 00:03:28,132
and you read the primaryTarget property.

65
00:03:28,132 --> 00:03:29,834
This happens to point out to enemy01,

66
00:03:29,834 --> 00:03:34,618
so now you read from enemy01 the value of the visible property.

67
00:03:37,857 --> 00:03:40,739
Okay, let's move on and go finally to the actual

68
00:03:40,739 --> 00:03:42,761
behavior tree stuff, the nodes and decorators.

69
00:03:42,761 --> 00:03:44,422
So a very quick recap.

70
00:03:44,422 --> 00:03:46,964
You obviously, behavior trees consist of root node,

71
00:03:46,964 --> 00:03:49,926
control flow nodes, which are the selectors,

72
00:03:49,926 --> 00:03:53,108
sequence nodes, parallel nodes,

73
00:03:53,108 --> 00:03:55,730
and then your execution nodes or tasks.

74
00:03:55,730 --> 00:03:58,112
What you also have in many implementations

75
00:03:58,112 --> 00:04:00,073
is some kind of decorator nodes.

76
00:04:00,073 --> 00:04:03,075
So you may implement your conditions as decorator nodes,

77
00:04:03,075 --> 00:04:05,877
and in this example, you would have, for example,

78
00:04:05,877 --> 00:04:07,378
two conditions for this sequence.

79
00:04:08,266 --> 00:04:10,567
So the above one, the abort condition,

80
00:04:10,567 --> 00:04:14,349
would have to be met before it can select the child behavior

81
00:04:14,349 --> 00:04:16,029
sequence.

82
00:04:16,029 --> 00:04:18,390
Also, the first child node of the sequence

83
00:04:18,390 --> 00:04:20,911
must be able to succeed, because if it would fail,

84
00:04:20,911 --> 00:04:23,313
the sequence would, of course, also be aborted.

85
00:04:23,313 --> 00:04:26,294
So both of these conditions have to be met before the sequence

86
00:04:26,294 --> 00:04:27,314
can be activated.

87
00:04:27,314 --> 00:04:31,916
So if this happens now, the sequence is activated.

88
00:04:31,916 --> 00:04:35,318
It would proceed to the first task, the middle one there.

89
00:04:36,623 --> 00:04:39,447
And if the abort condition now would turn to be false,

90
00:04:39,447 --> 00:04:41,910
of course it would abort the sequence

91
00:04:41,910 --> 00:04:43,773
and exit this whole branch.

92
00:04:43,773 --> 00:04:45,155
But if the other one, the condition,

93
00:04:45,155 --> 00:04:48,279
the first child of the sequence, would turn later to be false,

94
00:04:48,279 --> 00:04:50,181
it would have no effect whatsoever.

95
00:04:52,575 --> 00:04:55,777
So these would be the control activation and deactivation

96
00:04:55,777 --> 00:04:56,517
decorators.

97
00:04:56,517 --> 00:04:59,319
Then you have modify termination status decorators,

98
00:04:59,319 --> 00:05:02,040
which would be something like always succeed.

99
00:05:02,040 --> 00:05:05,742
So this always just succeeds when its child is completed.

100
00:05:05,742 --> 00:05:07,923
Even if the child fails, it will report itself

101
00:05:07,923 --> 00:05:09,204
as success to the parent.

102
00:05:09,204 --> 00:05:11,345
So in this example, it would make the first task

103
00:05:11,345 --> 00:05:13,146
as optional in the sequence.

104
00:05:13,146 --> 00:05:14,987
Regardless of the task failing or succeeding,

105
00:05:14,987 --> 00:05:17,128
the sequence will proceed to the final task.

106
00:05:18,136 --> 00:05:22,279
And then you can have something like this add-on functionalities, for example,

107
00:05:22,279 --> 00:05:25,721
if the last task would now fail, it would set a property.

108
00:05:25,721 --> 00:05:30,524
So these decorators are very nice for doing cool-down or retry mechanisms

109
00:05:30,524 --> 00:05:33,446
without having to implement it inside the task itself.

110
00:05:33,446 --> 00:05:37,048
So all these are kind of nice and very useful.

111
00:05:37,048 --> 00:05:39,590
I'm sure that you guys are using them with your behavior trees.

112
00:05:40,542 --> 00:05:43,525
But there's also another way to think about them which would be instead of

113
00:05:43,525 --> 00:05:45,888
decorative nodes, node decorators.

114
00:05:45,888 --> 00:05:51,174
And there's a nice example, so Miesko Zielinski did this for the Unreal 4's

115
00:05:51,174 --> 00:05:52,836
behavior trees.

116
00:05:52,836 --> 00:05:56,060
So it basically means that the decorators are part of the nodes

117
00:05:56,060 --> 00:05:58,203
themselves. They are not actually nodes at all.

118
00:05:58,929 --> 00:06:04,351
So this will create, in my mind, more compact visual representation of your behavior trees

119
00:06:04,351 --> 00:06:09,052
and it also allows more options to simplify your nodes in an easier way.

120
00:06:09,052 --> 00:06:13,373
So the common types again would be that you have the activation and deactivation controlling

121
00:06:13,373 --> 00:06:17,675
decorators inside the node, but now in this case you can easily see that this sequence,

122
00:06:17,675 --> 00:06:22,296
they are within the sequence, both of the abort and the regular condition.

123
00:06:23,823 --> 00:06:25,923
You can have the termination status modifiers.

124
00:06:25,923 --> 00:06:28,684
Again, it's much easier to see that now this task always

125
00:06:28,684 --> 00:06:29,444
succeeds.

126
00:06:29,444 --> 00:06:32,145
You can have parallel execution by having

127
00:06:32,145 --> 00:06:33,526
updatable decorators.

128
00:06:33,526 --> 00:06:36,206
Unreal, I believe, calls them services.

129
00:06:36,206 --> 00:06:38,627
And then finally, you can have the same add-on functionality

130
00:06:38,627 --> 00:06:42,428
that if this task, the right one, would fail, it sets a

131
00:06:42,428 --> 00:06:44,929
cool-down property to 10 seconds in this example.

132
00:06:45,920 --> 00:06:49,081
So comparing these two approaches, at least myself,

133
00:06:49,081 --> 00:06:52,362
I prefer the left one because it makes it much more condensed.

134
00:06:52,362 --> 00:06:54,523
And especially when dealing with big behavior trees,

135
00:06:54,523 --> 00:06:57,364
when they tend to actually grow up,

136
00:06:57,364 --> 00:06:59,765
you would like to, of course, be able to read those trees,

137
00:06:59,765 --> 00:07:02,026
especially if they're altered by multiple people

138
00:07:02,026 --> 00:07:04,027
in an easier way.

139
00:07:04,027 --> 00:07:05,848
So that's one of the kind of the major things

140
00:07:05,848 --> 00:07:07,868
that I personally like with this kind of an approach.

141
00:07:08,869 --> 00:07:15,714
So a few more examples of what you can, like how you can try to build your library of this reusable building blocks

142
00:07:15,714 --> 00:07:22,359
with decorators and more general purpose nodes is an example of a retry mechanism.

143
00:07:22,359 --> 00:07:26,862
So you can have this selector that will first try to, of course, activate the press button behavior.

144
00:07:26,862 --> 00:07:30,525
It would be a general purpose behavior where the NPC is trying to press a button.

145
00:07:30,525 --> 00:07:33,827
Maybe it even has the animation control inside this behavior.

146
00:07:33,827 --> 00:07:35,408
Let's assume that it would now fail.

147
00:07:35,408 --> 00:07:38,111
So for some reason, pressing this button didn't succeed.

148
00:07:39,085 --> 00:07:41,608
So we have this general purpose decorator that says, well,

149
00:07:41,608 --> 00:07:45,752
if I fail, set last try property to be the timestamp of now.

150
00:07:45,752 --> 00:07:48,514
Also, we have a condition that checks

151
00:07:48,514 --> 00:07:52,538
that if time since this property is more than 10 seconds,

152
00:07:52,538 --> 00:07:54,520
then you're allowed to select the node.

153
00:07:54,520 --> 00:07:57,403
So if you now fail, it would take at least 10 seconds

154
00:07:57,403 --> 00:07:58,644
before you can reselect the node.

155
00:07:58,644 --> 00:08:01,607
So the selector will happily select the next behavior,

156
00:08:01,607 --> 00:08:02,668
which is play animation.

157
00:08:03,388 --> 00:08:07,270
And we can now also add this general purpose loop decorator,

158
00:08:07,270 --> 00:08:08,830
also very common in many implementations,

159
00:08:08,830 --> 00:08:11,411
where instead of having the play animation to contain

160
00:08:11,411 --> 00:08:14,112
a selection of I want to loop this animation,

161
00:08:14,112 --> 00:08:16,433
or maybe an option inside the animation resource itself,

162
00:08:16,433 --> 00:08:18,734
you can bring it forth in the behavior tree itself

163
00:08:18,734 --> 00:08:21,815
and say whenever this task succeeds,

164
00:08:21,815 --> 00:08:24,596
it will start over again and won't report to its parent

165
00:08:24,596 --> 00:08:25,716
that it has completed.

166
00:08:25,716 --> 00:08:28,497
So in this example, it would make this play animation

167
00:08:28,497 --> 00:08:29,518
to simply play forever.

168
00:08:30,089 --> 00:08:34,694
But of course, since the selector is monitoring the higher priority branch, the press button,

169
00:08:34,694 --> 00:08:38,758
eventually it can be reselected because the time stamp will be more than 10 seconds old

170
00:08:38,758 --> 00:08:40,500
and it will retry the press button.

171
00:08:40,500 --> 00:08:45,406
So again, you don't have to implement this retry mechanism into any of these behaviors,

172
00:08:45,406 --> 00:08:48,048
but use a general purpose set of decorators and behaviors.

173
00:08:49,893 --> 00:08:53,895
An example of look at, so you can have two types of parallel execution things.

174
00:08:53,895 --> 00:08:58,118
Now with these updatable decorators, so a parallel node will execute a move to,

175
00:08:58,118 --> 00:09:02,321
which will move to a next waypoint. At the same time there's a look at behavior,

176
00:09:02,321 --> 00:09:06,863
which would try to look at a location of primary point of interest,

177
00:09:06,863 --> 00:09:09,765
if it is set. And then you can have an updatable decorator

178
00:09:09,765 --> 00:09:13,388
that is separated from the look at, so the look at doesn't figure out what it should look.

179
00:09:13,388 --> 00:09:16,630
It simply just looks at a point that has been set in the database.

180
00:09:17,339 --> 00:09:20,222
So the scan point of interest will be scanning around the

181
00:09:20,222 --> 00:09:23,485
agent and setting this primary point of interest if it finds

182
00:09:23,485 --> 00:09:25,046
something interesting.

183
00:09:25,046 --> 00:09:26,848
And now the look at would of course pick it up and start

184
00:09:26,848 --> 00:09:27,728
looking at that point.

185
00:09:27,728 --> 00:09:31,091
In this example, the updatable decorator could also be of

186
00:09:31,091 --> 00:09:33,534
course put into this look at node itself.

187
00:09:33,534 --> 00:09:37,297
Then we have debugging.

188
00:09:37,297 --> 00:09:42,141
So we can also use these decorators very easily.

189
00:09:43,792 --> 00:09:47,954
to help you debugging the behavioral trees so you can have tag decorators.

190
00:09:47,954 --> 00:09:53,736
So it's a simple decorator where you can give any string, in this case, in combat or in patrol.

191
00:09:53,736 --> 00:09:58,739
And you don't have to care, as a designer or a programmer, how did these nodes get selected.

192
00:09:58,739 --> 00:10:04,381
The behavior tree can be complex, like above these behaviors, you don't have to care

193
00:10:04,381 --> 00:10:07,983
where this is, or if somebody refactors the tree somehow, you don't have to care.

194
00:10:07,983 --> 00:10:11,064
Also, you don't have to care what happens inside these nodes.

195
00:10:11,845 --> 00:10:15,389
whenever to notice active this time would be active and there can be a

196
00:10:15,389 --> 00:10:20,194
simple way to be basic query which tags are active at this moment and you can

197
00:10:20,194 --> 00:10:23,477
display them for example on top of the characters head showing the guys now in

198
00:10:23,477 --> 00:10:27,542
combat or in patrol this could of course also be used outside of debugging and

199
00:10:27,542 --> 00:10:30,184
maybe control the the game playing in some way.

200
00:10:31,416 --> 00:10:35,698
Same thing you could do with message decorators instead of tagging something

201
00:10:35,698 --> 00:10:40,001
you can basically have a message decorator that sends a message

202
00:10:40,001 --> 00:10:44,363
on activation of the node, on deactivation of the node and possibly even sends every update

203
00:10:44,363 --> 00:10:48,745
some kind of message either to your debugging systems or possibly to the gameplay systems as well.

204
00:10:49,305 --> 00:10:54,268
Finally of course break point decorators which act in the same way so if the

205
00:10:54,268 --> 00:10:58,630
node gets activated and perhaps there's a condition if the condition is met then

206
00:10:58,630 --> 00:11:02,492
the game will for example pause and zoom to this actor so it can be very helpful

207
00:11:02,492 --> 00:11:06,034
if you have multiple actors running around to have this condition that you

208
00:11:06,034 --> 00:11:09,856
can flag I want to monitor these particular NPCs and if any of them

209
00:11:09,856 --> 00:11:13,718
happen to select this one node you would pause the game and zoom to that place

210
00:11:13,718 --> 00:11:16,800
and see okay now the guy is about to perform this action.

211
00:11:18,126 --> 00:11:23,411
So with all these examples, what I wanted to sort of bring forth is that building a

212
00:11:23,411 --> 00:11:29,976
library of reusable tasks actually is more like balancing out how to extract options

213
00:11:29,976 --> 00:11:35,301
from your tasks into decorators and kind of balancing the library of decorators and nodes

214
00:11:35,301 --> 00:11:35,541
together.

215
00:11:35,541 --> 00:11:41,366
And of course it wouldn't matter in which way you implement them, but I personally prefer

216
00:11:41,366 --> 00:11:44,309
these decorators to be the property of nodes themselves.

217
00:11:45,417 --> 00:11:46,618
A little bit about interruptions.

218
00:11:46,618 --> 00:11:48,198
So we could have a case like this.

219
00:11:48,198 --> 00:11:50,760
There's a selector that has a higher priority behavior,

220
00:11:50,760 --> 00:11:52,840
jump to safety, if there's a grenade

221
00:11:52,840 --> 00:11:54,021
within five meters of the NPC.

222
00:11:54,021 --> 00:11:57,542
Let's assume that there is no grenade yet.

223
00:11:57,542 --> 00:11:58,863
So the selector would pick a sequence.

224
00:11:58,863 --> 00:12:01,584
And its sequence, the first thing that it tries to do

225
00:12:01,584 --> 00:12:03,385
is a heroic, super slow vault to cover.

226
00:12:03,385 --> 00:12:04,766
Let's say that takes 15 seconds.

227
00:12:04,766 --> 00:12:06,026
It looks really awesome.

228
00:12:06,026 --> 00:12:08,047
And it's going to take the character outside of the nav

229
00:12:08,047 --> 00:12:09,708
mesh and do all kinds of funny things.

230
00:12:09,708 --> 00:12:11,729
And it's going to be very difficult to interrupt it

231
00:12:11,729 --> 00:12:13,910
in a meaningful and good looking way.

232
00:12:14,708 --> 00:12:18,729
While he's now in halfway through this vault animation,

233
00:12:18,729 --> 00:12:21,250
let's say that the grenade lands next to it.

234
00:12:21,250 --> 00:12:23,451
So what the behavior tree will do, it doesn't really care.

235
00:12:23,451 --> 00:12:24,951
It simply selects the jump to safety

236
00:12:24,951 --> 00:12:26,292
and deactivates this other one.

237
00:12:26,292 --> 00:12:26,752
What to do?

238
00:12:26,752 --> 00:12:31,153
So, of course, I don't think it's a problem

239
00:12:31,153 --> 00:12:31,974
of the behavior tree.

240
00:12:31,974 --> 00:12:34,094
Personally, I think that that's exactly what should happen.

241
00:12:34,094 --> 00:12:36,275
So the task that gets interrupted may, of course,

242
00:12:36,275 --> 00:12:37,075
do some cleanup.

243
00:12:37,075 --> 00:12:38,696
Perhaps it wants to tell the animation system

244
00:12:38,696 --> 00:12:40,216
to stop playing this animation.

245
00:12:40,216 --> 00:12:41,117
Maybe it doesn't.

246
00:12:41,722 --> 00:12:45,145
So the second thing that it can do is also the jump to safety that gets selected.

247
00:12:45,145 --> 00:12:48,968
It doesn't have to fail if it cannot perform immediately this jump to safety.

248
00:12:48,968 --> 00:12:51,230
So perhaps you want to just wait out

249
00:12:51,230 --> 00:12:55,994
that the body is able to perform the action that you want here.

250
00:12:55,994 --> 00:13:00,918
What I'm trying to say is that it's really not oftentimes a problem of the behavior trees

251
00:13:00,918 --> 00:13:05,722
to deal with these interruptions, even though there's a lot of these questions of what should be done.

252
00:13:05,722 --> 00:13:09,425
But sometimes you might still have the case that...

253
00:13:10,092 --> 00:13:14,613
you want to commit to an action and you do not want to interrupt this in the

254
00:13:14,613 --> 00:13:18,274
behavior tree itself. So you could also of course add an uninterruptible

255
00:13:18,274 --> 00:13:21,775
decorator into your node. And this would be quite simple to implement so the

256
00:13:21,775 --> 00:13:26,296
only thing it means is that if there's an uninterruptible node it will freeze

257
00:13:26,296 --> 00:13:31,378
all the the condition monitoring on top of the tree like throughout the

258
00:13:31,378 --> 00:13:32,678
parent hierarchy of this tree.

259
00:13:33,511 --> 00:13:35,252
You can chain also those uninterruptibles.

260
00:13:35,252 --> 00:13:37,394
So if there's a child node to this uninterruptible,

261
00:13:37,394 --> 00:13:40,276
of course that would then set the parenting hierarchy

262
00:13:40,276 --> 00:13:41,757
to be uninterruptible as well.

263
00:13:41,757 --> 00:13:44,099
But personally, I wouldn't really use this.

264
00:13:44,099 --> 00:13:45,280
I would try to avoid them at all costs,

265
00:13:45,280 --> 00:13:48,742
because eventually you could get the tree getting stuck

266
00:13:48,742 --> 00:13:52,265
and weird issues that the guy is performing very long sequences

267
00:13:52,265 --> 00:13:54,046
and not reacting to anything.

268
00:13:54,046 --> 00:13:54,507
So splitting the trees.

269
00:13:58,105 --> 00:14:03,267
That's the next thing. This is like a workflow thing and I also think it's something that people do very often.

270
00:14:03,267 --> 00:14:06,188
So you can have two types of ways to split your trees.

271
00:14:06,188 --> 00:14:11,290
As a property of behavior trees, of course, any sub-tree can be always considered as its own tree.

272
00:14:11,290 --> 00:14:20,733
So what you can do is have reference nodes. So this would be design time nodes, where you can just extract a part of the behavior tree and save it to a separate resource.

273
00:14:20,933 --> 00:14:24,834
And then you set in the parenting tree that contains this tree a reference node

274
00:14:24,834 --> 00:14:28,916
and you refer this behavior. It's a pretty standard node to have in your

275
00:14:28,916 --> 00:14:32,997
behavior tree implementations. So this is designed and it merges during export

276
00:14:32,997 --> 00:14:36,899
or load. So it reduces the perceived complexity of the tree, not really

277
00:14:36,899 --> 00:14:40,860
the actual complexity of the tree. And the main benefit is of course that it allows

278
00:14:40,860 --> 00:14:45,042
you to edit these behavior trees

279
00:14:45,042 --> 00:14:48,243
by multiple people at the same time without having to worry about the merge conflicts.

280
00:14:48,962 --> 00:14:52,065
and you shouldn't go like crazy about these and start immediately doing them.

281
00:14:52,065 --> 00:14:55,749
You should basically build this one tree and whenever it seems like logical,

282
00:14:55,749 --> 00:15:00,233
you should then take a piece of the tree and save it to another resource.

283
00:15:00,233 --> 00:15:03,657
Effectively refactoring your trees as you go.

284
00:15:04,390 --> 00:15:08,715
There's also these other types of nodes which allows the dynamic attachment of

285
00:15:08,715 --> 00:15:12,779
behavior trees. So it's just a placeholder node that's saying, well,

286
00:15:12,779 --> 00:15:16,123
if there's nothing attached at this node at runtime, the node always fails.

287
00:15:16,123 --> 00:15:19,406
It cannot be activated. And you can, from somewhere in code, you can attach a

288
00:15:19,406 --> 00:15:23,430
behavior tree here and then it would just do the same thing as the statically

289
00:15:23,430 --> 00:15:26,774
attached trees. Then it would appear as part of the tree.

290
00:15:28,439 --> 00:15:31,901
So what you can do with these dynamic trees is smart objects,

291
00:15:31,901 --> 00:15:32,561
for example.

292
00:15:32,561 --> 00:15:35,203
So instead of having fixed pipeline smart objects where

293
00:15:35,203 --> 00:15:37,464
you have, for example, a list of actions or animations

294
00:15:37,464 --> 00:15:41,586
to perform when you try to use these things,

295
00:15:41,586 --> 00:15:44,788
you could simply have them as containers for behavior trees

296
00:15:44,788 --> 00:15:46,769
and maybe a small piece of a database that's

297
00:15:46,769 --> 00:15:49,050
embedded with this smart object.

298
00:15:49,050 --> 00:15:52,012
So it's essentially instructions of how

299
00:15:52,012 --> 00:15:53,633
to use this smart object.

300
00:15:55,903 --> 00:15:57,524
You could also have items and weapons.

301
00:15:57,524 --> 00:15:59,706
So instead of having everything put into the character themselves,

302
00:15:59,706 --> 00:16:02,268
you could have the combat part of the tree

303
00:16:02,268 --> 00:16:04,249
actually be embedded into the weapon itself.

304
00:16:04,249 --> 00:16:06,711
This would allow you, especially in the prototyping phase,

305
00:16:06,711 --> 00:16:07,912
to build a single NPC,

306
00:16:07,912 --> 00:16:11,015
and depending on the weapon, you can change how it actually behaves.

307
00:16:11,015 --> 00:16:14,017
Maybe later on you still want to put all the behavior trees inside the character,

308
00:16:14,017 --> 00:16:15,919
but this way you can dynamically say,

309
00:16:15,919 --> 00:16:18,581
if I give this guy a pistol, maybe he wants to use cover,

310
00:16:18,581 --> 00:16:20,222
and he wants to fight quite close by.

311
00:16:21,248 --> 00:16:24,251
And if you give him a shotgun, maybe he's not using cover in the same way.

312
00:16:24,251 --> 00:16:26,413
Maybe he wants to perform a different set of actions instead.

313
00:16:26,413 --> 00:16:31,017
And then you can do more than just the smart objects in your level scripting.

314
00:16:31,017 --> 00:16:35,641
So, for example, for spawning, again, instead of having fixed pipeline spawning animations

315
00:16:35,641 --> 00:16:39,144
that the guy rushes through the door in some kind of awesome way,

316
00:16:39,144 --> 00:16:45,029
you just put a behavior tree that overrides your master tree at a very high level.

317
00:16:45,607 --> 00:16:48,729
When the guy is spawning, maybe it has some kind of sequence, similar sequence to

318
00:16:48,729 --> 00:16:52,893
rush through this door or has some, is using like move to behaviors, but it can

319
00:16:52,893 --> 00:16:57,616
also do things like if the enemy happens to be very close by, maybe I don't want

320
00:16:57,616 --> 00:17:01,540
to commit into this long animation and expose myself, but instead just take a

321
00:17:01,540 --> 00:17:03,321
shortcut and start shooting back immediately.

322
00:17:03,321 --> 00:17:09,786
So this would be such a simple example. So this smart object could be as simple as

323
00:17:09,786 --> 00:17:13,610
just a list of animations as you would have in your fixed pipeline smart objects.

324
00:17:13,754 --> 00:17:16,835
And then you could attach it into this child tree node.

325
00:17:16,835 --> 00:17:18,936
And the node itself can be also very simple.

326
00:17:18,936 --> 00:17:21,856
So you can have the cool-down mechanism implemented again

327
00:17:21,856 --> 00:17:26,058
with these generators, general purpose decorators.

328
00:17:26,058 --> 00:17:27,738
And for weapons, of course, you don't

329
00:17:27,738 --> 00:17:31,119
want to detach the tree if this child tree is not active.

330
00:17:31,119 --> 00:17:33,940
But for smart objects, when you have finished

331
00:17:33,940 --> 00:17:35,980
using the smart object, you can add this decorator

332
00:17:35,980 --> 00:17:38,141
that says, when this node terminates,

333
00:17:38,141 --> 00:17:39,642
it detaches the smart object.

334
00:17:42,256 --> 00:17:47,503
And then finally, there's this thing that bihertories are oftentimes used and mostly

335
00:17:47,503 --> 00:17:51,428
used only to control your characters, but they could also be used to do coordination

336
00:17:51,428 --> 00:17:51,708
between NPCs.

337
00:17:51,708 --> 00:17:51,748
So...

338
00:17:51,748 --> 00:17:52,710
Thanks for watching!

339
00:17:52,710 --> 00:17:52,770
Bye!

340
00:17:52,770 --> 00:17:52,870
Bye!

341
00:17:52,870 --> 00:17:52,930
Bye!

342
00:17:52,930 --> 00:17:53,070
Bye!

343
00:17:53,070 --> 00:17:53,190
Bye!

344
00:17:53,190 --> 00:17:53,330
Bye!

345
00:17:53,330 --> 00:17:53,791
Bye!

346
00:17:53,791 --> 00:17:53,851
Bye!

347
00:17:53,851 --> 00:17:53,991
Bye!

348
00:17:53,991 --> 00:17:54,051
Bye!

349
00:17:54,051 --> 00:17:54,131
Bye!

350
00:17:54,131 --> 00:17:54,232
Bye!

351
00:17:54,232 --> 00:17:54,332
Bye!

352
00:17:54,332 --> 00:17:54,392
Bye!

353
00:17:54,392 --> 00:17:54,792
Bye!

354
00:17:54,792 --> 00:17:55,193
Bye!

355
00:17:55,722 --> 00:18:00,386
What you could have is a volume for a room, like a box, whatever shape of a volume, and

356
00:18:00,386 --> 00:18:05,070
you can add a behavior tree to this volume as well, and a database to go with it.

357
00:18:05,070 --> 00:18:07,772
And this behavior tree, of course, wouldn't have moved behaviors because the volume is

358
00:18:07,772 --> 00:18:12,395
not moving much or controlling the body in any way, but you would basically have a custom

359
00:18:12,395 --> 00:18:15,698
set of nodes and decorators that you could build up, which would be updating goals and

360
00:18:15,698 --> 00:18:19,781
objectives, influence maps with updatable decorators, assigning roles.

361
00:18:20,242 --> 00:18:24,443
and communicating with the NPCs either by writing that are in the visual memory

362
00:18:24,443 --> 00:18:28,325
or just writing to its own memory and opportunistically these NPCs could be

363
00:18:28,325 --> 00:18:32,226
reading from this database and altering their own actions.

364
00:18:32,226 --> 00:18:37,408
So as a wrap up, I personally think that the way that Unreal has for example

365
00:18:37,408 --> 00:18:42,050
implemented the decorators, it's a great way, it simplifies the complexity,

366
00:18:42,050 --> 00:18:46,852
at least the perceived complexity, and it allows an easier way in my mind

367
00:18:46,852 --> 00:18:49,333
to implement this kind of reusable building blocks.

368
00:18:49,913 --> 00:18:51,353
for your behavior trees and for your games.

369
00:18:51,353 --> 00:18:53,995
You shouldn't be limited to a single static tree.

370
00:18:53,995 --> 00:18:57,596
Use a lot of these dynamic and static reference nodes.

371
00:18:57,596 --> 00:19:00,337
And finally, behavior trees are not character specific.

372
00:19:00,337 --> 00:19:02,638
Also, they are not the only mechanism

373
00:19:02,638 --> 00:19:04,199
to control your characters.

374
00:19:04,199 --> 00:19:06,220
And I think Bobby will touch upon this subject

375
00:19:06,220 --> 00:19:07,180
a little bit more now.

376
00:19:07,180 --> 00:19:09,141
Oh, and there's of course read more.

377
00:19:09,141 --> 00:19:11,642
So AI game dev has a lot of articles about this

378
00:19:11,642 --> 00:19:14,523
and the Unreal 4 is very well documented

379
00:19:14,523 --> 00:19:16,164
as well as Angry Ants behave.

380
00:19:16,164 --> 00:19:18,145
So Bobby, your turn.

381
00:19:27,295 --> 00:19:30,898
All right, so for my part, it's going to be a little bit more of a best practices talk.

382
00:19:30,898 --> 00:19:33,700
We're going to talk about some problems with behavior trees.

383
00:19:33,700 --> 00:19:35,541
We're also going to discuss some of the solutions.

384
00:19:35,541 --> 00:19:41,326
Nothing I'm going to really discuss today here is going to be revolutionary in terms

385
00:19:41,326 --> 00:19:42,567
of reinventing the wheel or anything like that.

386
00:19:42,567 --> 00:19:44,208
We're not going to do anything crazy.

387
00:19:44,208 --> 00:19:47,390
What I'm going to do is I'm going to provide some observations and suggestions.

388
00:19:47,390 --> 00:19:50,713
People have touched on this in the past, but I want to go a bit more deep.

389
00:19:51,653 --> 00:19:54,054
And I want to kind of hope that I can prevent some pain

390
00:19:54,054 --> 00:19:56,974
for people in the room and also kind of kick off some discussions.

391
00:19:56,974 --> 00:20:02,515
As kind of an intro to this, I just want to discuss my perspective on engineering.

392
00:20:02,515 --> 00:20:04,316
I don't believe in silver bullets.

393
00:20:04,316 --> 00:20:06,996
I believe that every technique, every approach we have has pros and cons.

394
00:20:06,996 --> 00:20:10,877
And in games especially, we tend to lose our perspective a lot

395
00:20:10,877 --> 00:20:12,577
and we tend to brute force our solutions.

396
00:20:12,577 --> 00:20:17,058
It's our job to sort of look at the tools we have and understand them deeply

397
00:20:17,058 --> 00:20:20,098
and understand where they work, where they don't, the pros and the cons.

398
00:20:21,160 --> 00:20:25,685
Also in games we have this mentality of sort of milestone driven, goal driven,

399
00:20:25,685 --> 00:20:29,208
feature driven approaches where sometimes we lose sight of the bigger picture

400
00:20:29,208 --> 00:20:30,189
chasing a small goal.

401
00:20:30,189 --> 00:20:36,375
In my experience the better the tooling we have the better the workflows, the more

402
00:20:36,375 --> 00:20:40,238
iterations we can do the better the end result is and so to have good tools

403
00:20:40,238 --> 00:20:41,720
you need to understand what the flaws are.

404
00:20:43,320 --> 00:20:45,201
So before I dive into the behavior tree stuff,

405
00:20:45,201 --> 00:20:47,682
I'm gonna discuss a little bit of visualization.

406
00:20:47,682 --> 00:20:50,463
I tend to kind of think of trees in a different way to most.

407
00:20:50,463 --> 00:20:54,924
Kind of the traditional approaches you saw in Mika's display

408
00:20:54,924 --> 00:20:57,325
and Angry Ant in Unreal 4 is sort of this kind of

409
00:20:57,325 --> 00:21:00,326
vertical approach where we both have the priority

410
00:21:00,326 --> 00:21:04,088
as well as the sequence order of nodes running horizontally.

411
00:21:04,088 --> 00:21:06,368
So you'll see that both priority, high to low,

412
00:21:06,368 --> 00:21:08,609
is left to right, as well as actions left to right.

413
00:21:08,609 --> 00:21:11,910
I prefer to visualize trees in more of a kind of

414
00:21:12,504 --> 00:21:18,029
reading approach, in my kind of preferred way of visualization, I kind of have the priority

415
00:21:18,029 --> 00:21:19,570
going from top to bottom.

416
00:21:19,570 --> 00:21:22,453
So when we branch, we kind of branch vertically.

417
00:21:22,453 --> 00:21:25,816
And then the actions are running left to right, sort of like a sequence or a timeline.

418
00:21:25,816 --> 00:21:29,259
That helps me reason about behavior just a little bit better, because I'm like, okay,

419
00:21:29,259 --> 00:21:33,823
well, I made this choice, and now I'm going to make this choice, then I'll make the third

420
00:21:33,823 --> 00:21:34,143
choice.

421
00:21:34,143 --> 00:21:36,485
Okay, I've made the choice, now I kind of go left to right.

422
00:21:37,118 --> 00:21:40,319
So, I'm going to start off discussing some of the problems.

423
00:21:40,319 --> 00:21:43,380
Behavior trees are inherently bad at two things.

424
00:21:43,380 --> 00:21:46,222
Those interruptions and transitions

425
00:21:46,222 --> 00:21:47,902
and behavior prioritization.

426
00:21:47,902 --> 00:21:50,563
Now, I know a lot of you are going to pull out

427
00:21:50,563 --> 00:21:52,844
pitchforks and torches,

428
00:21:52,844 --> 00:21:55,085
and yes, you've shipped games with behavior trees

429
00:21:55,085 --> 00:21:56,086
and everything worked out fine,

430
00:21:56,086 --> 00:21:58,407
and you know, you got everything done,

431
00:21:58,407 --> 00:22:00,807
and you can, but just hear me out.

432
00:22:00,807 --> 00:22:00,928
So,

433
00:22:02,292 --> 00:22:06,594
Currently the most sort of common approach to behavior trees that I've seen in the industry

434
00:22:06,594 --> 00:22:07,594
is event driven.

435
00:22:07,594 --> 00:22:12,016
That basically means that as we kind of traverse the tree, at every single point we register

436
00:22:12,016 --> 00:22:14,357
these monitor nodes until we hit a behavior that we run.

437
00:22:14,357 --> 00:22:16,618
These monitor nodes get updated every frame.

438
00:22:16,618 --> 00:22:21,820
And the deeper we are in the tree, the kind of more monitors we need to kind of check

439
00:22:21,820 --> 00:22:24,221
the higher priority behaviors.

440
00:22:24,221 --> 00:22:28,843
And when one of these monitors ends up triggering, it will end up causing the tree to sort of

441
00:22:28,843 --> 00:22:29,163
abort.

442
00:22:30,386 --> 00:22:32,889
reset and kind of go into that behavior they triggered.

443
00:22:32,889 --> 00:22:34,611
And this is happening through the conditions

444
00:22:34,611 --> 00:22:36,813
that are being set for these monitors and the entries.

445
00:22:36,813 --> 00:22:39,276
This leads us to our first big problem

446
00:22:39,276 --> 00:22:42,299
and that is static prioritization of the trees.

447
00:22:42,299 --> 00:22:44,041
So imagine I'm currently in fighting.

448
00:22:44,041 --> 00:22:45,342
How do I go to investigating?

449
00:22:45,342 --> 00:22:48,385
Well, the only way to transition from high-low priorities

450
00:22:48,385 --> 00:22:51,489
is to either abort or complete that behavior.

451
00:22:52,495 --> 00:22:57,562
To abort, we usually need to then start sprinkling these special case conditions in these behaviors.

452
00:22:57,562 --> 00:23:01,227
So if I was fighting and I lose sight of my target, I need to now write a bunch of conditions

453
00:23:01,227 --> 00:23:05,152
and they're saying, well, if I lose sight of target, fail this behavior, then the behavior

454
00:23:05,152 --> 00:23:08,136
tree will reset and then I can jump into a lower priority behavior.

455
00:23:09,631 --> 00:23:14,533
This kind of ends up polluting the tree, especially the high-level behaviors with low priority

456
00:23:14,533 --> 00:23:15,093
ones.

457
00:23:15,093 --> 00:23:19,354
It's kind of implicitly because you're trying to cater for the transition lower down by

458
00:23:19,354 --> 00:23:23,816
canceling a high-level thing, which greatly ends up increasing the complexity of the tree.

459
00:23:23,816 --> 00:23:27,877
And then there's another even worse problem, which is that we often need to change the

460
00:23:27,877 --> 00:23:32,079
priorities of our kind of high-level states based on the context of the situation.

461
00:23:32,819 --> 00:23:35,141
To highlight this, I'm actually going to have some audience participation.

462
00:23:35,141 --> 00:23:36,843
I'm going to show you an AI design.

463
00:23:36,843 --> 00:23:38,765
I'm going to give you a few seconds to kind of look at it

464
00:23:38,765 --> 00:23:39,766
and tell me if you understand this.

465
00:23:39,766 --> 00:23:41,267
You guys get this? Do you see what it's doing?

466
00:23:41,267 --> 00:23:42,048
Does everybody kind of...

467
00:23:42,048 --> 00:23:42,509
No? Yes? People get this?

468
00:24:00,029 --> 00:24:01,970
Okay, so I'm gonna ask some questions,

469
00:24:01,970 --> 00:24:04,311
see if somebody can answer.

470
00:24:04,311 --> 00:24:08,353
You should just shout out in the room.

471
00:24:08,353 --> 00:24:09,833
When can a super attack occur?

472
00:24:09,833 --> 00:24:12,995
There we go.

473
00:24:12,995 --> 00:24:14,535
What happens after I do a super attack?

474
00:24:14,535 --> 00:24:17,917
Cool, and from attack pattern two, what can I do?

475
00:24:17,917 --> 00:24:19,718
Okay, simple, right?

476
00:24:19,718 --> 00:24:20,538
What about this?

477
00:24:20,538 --> 00:24:25,140
The same diagram, the same AI system.

478
00:24:25,140 --> 00:24:26,120
It's a little bit harder to read.

479
00:24:27,383 --> 00:24:29,405
And this is inherent to behavior trees

480
00:24:29,405 --> 00:24:32,447
because behavior trees are directed acyclic graphs.

481
00:24:32,447 --> 00:24:34,248
It means they have no loops.

482
00:24:34,248 --> 00:24:36,070
They don't have cycles.

483
00:24:36,070 --> 00:24:38,611
That AI design and AI designs in general are cyclic.

484
00:24:38,611 --> 00:24:41,373
Even the most basic combat behavior cycles

485
00:24:41,373 --> 00:24:44,376
between things like fight from cover, fight from position,

486
00:24:44,376 --> 00:24:45,556
or wait, no, go back to cover.

487
00:24:45,556 --> 00:24:47,698
We're constantly cycling these behaviors.

488
00:24:47,698 --> 00:24:49,339
And what we're trying to do is we're trying

489
00:24:49,339 --> 00:24:52,301
to model cyclic behavior with a cyclic data structure.

490
00:24:52,301 --> 00:24:53,602
And yes, it can be done.

491
00:24:53,602 --> 00:24:55,383
It doesn't mean we should.

492
00:24:57,225 --> 00:25:00,267
So, how do we do this modeling of the cyclic behavior?

493
00:25:00,267 --> 00:25:02,308
A lot of you in the room are probably doing this

494
00:25:02,308 --> 00:25:03,269
without realizing it.

495
00:25:03,269 --> 00:25:06,952
We end up doing preconditions to get the required results.

496
00:25:06,952 --> 00:25:09,434
So for example, we'll have stuff in our knowledge saying,

497
00:25:09,434 --> 00:25:11,555
hey, did I just do a charge attack?

498
00:25:11,555 --> 00:25:12,056
Yes, okay, cool.

499
00:25:12,056 --> 00:25:14,337
Then I can do this through another set of conditions

500
00:25:14,337 --> 00:25:15,018
somewhere else.

501
00:25:16,200 --> 00:25:21,064
Unfortunately, this requires us to sort of track this kind of stuff in an agent knowledge,

502
00:25:21,064 --> 00:25:24,947
and it kind of pollutes it with execution and control flow data for the tree inside

503
00:25:24,947 --> 00:25:28,851
of the agent knowledge, which is supposed to be kind of the agent's personal state about

504
00:25:28,851 --> 00:25:29,691
himself.

505
00:25:29,691 --> 00:25:34,776
It also greatly increases complexity, which ends up hurting robustness, understandability,

506
00:25:34,776 --> 00:25:37,518
and obviously performance, since we have these monster trees we have to evaluate.

507
00:25:39,093 --> 00:25:42,714
Worst of all is that we're creating these implicit transition dependencies between the

508
00:25:42,714 --> 00:25:45,095
subtrees and the agent data.

509
00:25:45,095 --> 00:25:49,056
Now, anybody doing computer science should be beaten into at some point that implicit

510
00:25:49,056 --> 00:25:52,257
dependencies and dependencies in general are not good things.

511
00:25:52,257 --> 00:25:59,680
And a personal metric of mine for code quality is more like how easy is it to delete that

512
00:25:59,680 --> 00:25:59,780
code.

513
00:26:00,912 --> 00:26:04,053
I'll look at a piece of code and say, if I want to delete this thing, how many areas

514
00:26:04,053 --> 00:26:04,573
do I have to touch?

515
00:26:04,573 --> 00:26:08,935
If it's simply just copy, paste, delete and everything works, then that is good code quality.

516
00:26:08,935 --> 00:26:12,716
If I have to delete that, touch this, change this, undo this hook, remove this pointer

517
00:26:12,716 --> 00:26:14,536
here, we've got problems.

518
00:26:14,536 --> 00:26:18,937
So I'm going to ask you, like, how easy would it be, for example, for me to delete one of

519
00:26:18,937 --> 00:26:19,378
these behaviors?

520
00:26:19,378 --> 00:26:21,918
Well, I'm going to have to delete all the preconditions.

521
00:26:22,744 --> 00:26:25,187
in potentially super attack inside of charge attack.

522
00:26:25,187 --> 00:26:26,268
I'm gonna have to find every place

523
00:26:26,268 --> 00:26:29,051
that I've hooked into this to kind of fake

524
00:26:29,051 --> 00:26:31,033
the cyclic flow in an acyclic structure.

525
00:26:31,033 --> 00:26:34,596
And so over time this works, but all the solutions,

526
00:26:34,596 --> 00:26:37,219
especially later you get into a production,

527
00:26:37,219 --> 00:26:38,700
end up looking like this, where you've beaten

528
00:26:38,700 --> 00:26:41,683
this square peg into a round hole with a lot of force

529
00:26:41,683 --> 00:26:43,545
to the point where now you can't even get it out

530
00:26:43,545 --> 00:26:45,287
if you tried.

531
00:26:46,720 --> 00:26:49,521
And now that we've discussed kind of the transitions and the interruptions and

532
00:26:49,521 --> 00:26:52,082
this kind of priority, we also have another thing is that often when we do

533
00:26:52,082 --> 00:26:55,704
these transitions, additionally we have to signal to the player that, hey,

534
00:26:55,704 --> 00:26:57,484
I actually switched state.

535
00:26:57,484 --> 00:27:00,505
So normally, kind of simplest case, we play an animation and sound.

536
00:27:00,505 --> 00:27:04,387
But sometimes it gets more complex and we have to do things like, oh,

537
00:27:04,387 --> 00:27:06,788
I have to turn to target, I got to pull out my gun, I got to do a bark,

538
00:27:06,788 --> 00:27:07,688
maybe wait a second.

539
00:27:07,688 --> 00:27:11,609
Or if we're doing like a boss fight in a brawler, we need to do something like

540
00:27:11,609 --> 00:27:14,390
taunt the player, wait for a bit, that kind of thing.

541
00:27:15,331 --> 00:27:17,252
That is purely kind of like a visual state.

542
00:27:17,252 --> 00:27:19,394
It's not decision making, it's nothing.

543
00:27:19,394 --> 00:27:21,095
It's just saying, okay, you know,

544
00:27:21,095 --> 00:27:23,897
let the plane know what's happening and he can react to it.

545
00:27:23,897 --> 00:27:26,359
And these reactions and behaviors unfortunately end up,

546
00:27:26,359 --> 00:27:28,160
again, being shoved into the tree

547
00:27:28,160 --> 00:27:29,942
and we end up with situations like this.

548
00:27:29,942 --> 00:27:31,723
So this is a subset of the previous example

549
00:27:31,723 --> 00:27:34,045
where you'll see now we have little trees

550
00:27:34,045 --> 00:27:35,206
inside of the other trees saying,

551
00:27:35,206 --> 00:27:37,307
oh, if I'm transitioning from this state, do this thing.

552
00:27:37,307 --> 00:27:39,909
If I'm transitioning from this state, do this thing.

553
00:27:39,909 --> 00:27:41,931
And even worse now, we have...

554
00:27:42,914 --> 00:27:45,775
a lower priority behavior handling higher priority behavior.

555
00:27:45,775 --> 00:27:47,136
So now we've got spaghetti everywhere.

556
00:27:47,136 --> 00:27:47,856
We just don't know it.

557
00:27:47,856 --> 00:27:49,517
Everything's linked to everything,

558
00:27:49,517 --> 00:27:51,158
everything's handling everything,

559
00:27:51,158 --> 00:27:52,559
every flag in the tree,

560
00:27:52,559 --> 00:27:53,799
you change one setting here

561
00:27:53,799 --> 00:27:56,921
and you don't know what triggers where.

562
00:27:56,921 --> 00:27:58,141
Now I guess a lot of you in the audits

563
00:27:58,141 --> 00:27:59,022
are basically saying like,

564
00:27:59,022 --> 00:28:00,603
okay, well, behavior trees are awful, right?

565
00:28:00,603 --> 00:28:01,123
You know, like, that,

566
00:28:01,123 --> 00:28:03,944
you were supposed to tell me how to use them,

567
00:28:03,944 --> 00:28:04,484
not how bad they are.

568
00:28:04,484 --> 00:28:09,387
So behavior trees are actually kind of good,

569
00:28:09,387 --> 00:28:10,067
but

570
00:28:10,360 --> 00:28:12,362
They're good in a different sort of way.

571
00:28:12,362 --> 00:28:14,663
Like if you look at the Wikipedia definition for behavior,

572
00:28:14,663 --> 00:28:16,925
it says it's a mathematical model of plan execution.

573
00:28:16,925 --> 00:28:18,646
I think that's super important,

574
00:28:18,646 --> 00:28:20,388
something we've kind of forgotten.

575
00:28:20,388 --> 00:28:22,909
It's a plan execution model.

576
00:28:22,909 --> 00:28:24,791
And that sort of implies that there's a plan.

577
00:28:24,791 --> 00:28:28,233
You know, not that the behavior tree is the plan,

578
00:28:28,233 --> 00:28:30,835
that it's just executing somebody else's plan.

579
00:28:32,138 --> 00:28:34,299
Behavior trees are really, really good

580
00:28:34,299 --> 00:28:37,361
at describing a complex sequence of actions to perform.

581
00:28:37,361 --> 00:28:40,022
So I'm gonna show you a simple behavior now,

582
00:28:40,022 --> 00:28:42,903
and I'm gonna ask you again a question,

583
00:28:42,903 --> 00:28:50,066
and hopefully you guys will shout out at me.

584
00:28:50,066 --> 00:28:51,146
What does this behavior do?

585
00:28:51,146 --> 00:28:55,408
As soon as somebody knows, just shout out.

586
00:28:55,408 --> 00:28:55,628
Stuff.

587
00:28:55,628 --> 00:28:58,569
And Dave is wrong.

588
00:28:58,569 --> 00:28:59,390
Pardon?

589
00:29:03,492 --> 00:29:06,034
Okay, and when do we look for a new position, for example?

590
00:29:06,034 --> 00:29:10,918
Kind of if we don't have a good position.

591
00:29:10,918 --> 00:29:13,260
You see that there's a little branch in there,

592
00:29:13,260 --> 00:29:14,561
but yes, for the most part,

593
00:29:14,561 --> 00:29:15,922
this is a very simple approach

594
00:29:15,922 --> 00:29:17,763
for doing a fight from position.

595
00:29:17,763 --> 00:29:19,384
Not a cover, just in the open.

596
00:29:19,384 --> 00:29:21,786
I'm shooting as soon as I maybe don't have a good position

597
00:29:21,786 --> 00:29:23,327
based on line of sight or whatever.

598
00:29:23,327 --> 00:29:24,108
I find a new position.

599
00:29:24,108 --> 00:29:25,129
And when I'm stuck in a good position,

600
00:29:25,129 --> 00:29:26,750
I'm shooting the player and he aims at me,

601
00:29:26,750 --> 00:29:28,211
I'm like, okay, well, let's move.

602
00:29:28,211 --> 00:29:29,672
Let's give him a bit of a challenge,

603
00:29:29,672 --> 00:29:30,733
a pattern gameplay or something.

604
00:29:32,652 --> 00:29:36,457
So a lot of people kind of think of behavior trees as decision making.

605
00:29:36,457 --> 00:29:39,240
If we look at like a standard Russell Norvig,

606
00:29:39,240 --> 00:29:42,384
the behavior trees kind of fit into decision making.

607
00:29:42,384 --> 00:29:45,107
That's where people have lumped them into.

608
00:29:45,107 --> 00:29:50,754
Personally, I think of behavior trees as more of a control layer in between

609
00:29:50,754 --> 00:29:52,196
actuation and decision making.

610
00:29:53,078 --> 00:29:54,840
You know, we can still make some decisions in the trees,

611
00:29:54,840 --> 00:29:57,903
but those decisions shouldn't change our overall AI goal

612
00:29:57,903 --> 00:29:58,223
or AI state.

613
00:29:58,223 --> 00:30:01,607
They're simply decisions to execute our decision.

614
00:30:01,607 --> 00:30:03,869
If we've said, okay, you're fighting from cover,

615
00:30:03,869 --> 00:30:05,891
the behavior tree can make some decisions saying,

616
00:30:05,891 --> 00:30:08,113
hey, I should pop up now, or I should dodge to the left,

617
00:30:08,113 --> 00:30:08,853
or I should do a reload.

618
00:30:08,853 --> 00:30:10,795
But they should never say, you know what,

619
00:30:10,795 --> 00:30:12,317
I actually think it's better for me

620
00:30:12,317 --> 00:30:13,858
to go outside of cover right now,

621
00:30:13,858 --> 00:30:15,460
even though this is the cover behavior.

622
00:30:18,302 --> 00:30:19,723
For example, in the previous example,

623
00:30:19,723 --> 00:30:21,864
we made the decision of, if I don't have a line of sight,

624
00:30:21,864 --> 00:30:22,964
I find a position with line of sight.

625
00:30:22,964 --> 00:30:26,466
So if we work under this conception of these simpler

626
00:30:26,466 --> 00:30:30,407
execution trees, we need a high granularity of actions.

627
00:30:30,407 --> 00:30:34,529
We need actions that are more like move, look at, reload,

628
00:30:34,529 --> 00:30:35,470
fire.

629
00:30:35,470 --> 00:30:38,391
I've seen implementation of behavior trees

630
00:30:38,391 --> 00:30:41,672
with the actions that are a little bit more coarse.

631
00:30:41,672 --> 00:30:44,133
They're like fight from position, fight from cover,

632
00:30:44,133 --> 00:30:45,574
that degree of things, where you're

633
00:30:45,574 --> 00:30:46,874
using a behavior tree like a decision tree for the most

634
00:30:46,874 --> 00:30:47,295
part.

635
00:30:48,863 --> 00:30:51,004
So simpler and smaller trees, obviously,

636
00:30:51,004 --> 00:30:54,186
each one executing just a single goal.

637
00:30:54,186 --> 00:30:56,767
And we also need to make some decisions in the tree,

638
00:30:56,767 --> 00:30:58,268
as I mentioned.

639
00:30:58,268 --> 00:30:59,709
So for example, we'll decide whether we have

640
00:30:59,709 --> 00:31:00,329
a good position or not.

641
00:31:00,329 --> 00:31:03,391
Now if we move to the simple execution-oriented approach,

642
00:31:03,391 --> 00:31:04,431
we have several benefits.

643
00:31:04,431 --> 00:31:06,272
Obviously they're easy to build because you're solving

644
00:31:06,272 --> 00:31:08,313
a very small problem in isolation.

645
00:31:08,313 --> 00:31:10,795
They're easy to understand and debug.

646
00:31:10,795 --> 00:31:12,416
In like less than 15 seconds,

647
00:31:12,416 --> 00:31:14,537
you guys could sort of understand what was going on.

648
00:31:15,327 --> 00:31:17,168
And that's what you want to do if you have a new hire coming

649
00:31:17,168 --> 00:31:17,948
into your code base.

650
00:31:17,948 --> 00:31:20,409
You don't want him scratching his head for three days

651
00:31:20,409 --> 00:31:21,009
trying to do something wrong.

652
00:31:21,009 --> 00:31:24,630
It's also easy to identify the working data set.

653
00:31:24,630 --> 00:31:27,030
If you want to parallelize your agent updates or something,

654
00:31:27,030 --> 00:31:28,891
it's good to know exactly what data you're using so you can

655
00:31:28,891 --> 00:31:31,812
kind of isolate that out so you don't have any kind of race

656
00:31:31,812 --> 00:31:33,612
conditions or anything like that or overriding of data.

657
00:31:34,598 --> 00:31:36,560
They're also easy to test independently.

658
00:31:36,560 --> 00:31:39,041
Again, if you know your data, you can build a test harness

659
00:31:39,041 --> 00:31:40,802
and just have that behavior being tested, saying,

660
00:31:40,802 --> 00:31:42,883
does my fight from position behavior work?

661
00:31:42,883 --> 00:31:44,124
Well, let's just test that.

662
00:31:44,124 --> 00:31:45,945
Don't run the whole AI, don't run anything,

663
00:31:45,945 --> 00:31:47,906
just run that behavior and test it out.

664
00:31:47,906 --> 00:31:48,826
And they perform better.

665
00:31:48,826 --> 00:31:50,027
Cutting out, I think.

666
00:31:52,081 --> 00:31:55,025
Now, obviously you're going to say, well, how do you author these things?

667
00:31:55,025 --> 00:31:55,866
What are the rules?

668
00:31:55,866 --> 00:31:59,792
Well, my general rule of thumb is I basically say to myself, OK, I've made

669
00:31:59,792 --> 00:32:02,095
this decision, I want to go to cover and I want to fight from cover.

670
00:32:02,095 --> 00:32:04,678
What are the steps I need to do to execute that?

671
00:32:05,328 --> 00:32:07,248
That's generally how I kind of think.

672
00:32:07,248 --> 00:32:08,909
I like simplistic approaches.

673
00:32:08,909 --> 00:32:10,950
Maybe I'm a bit slow in my old age.

674
00:32:10,950 --> 00:32:13,330
But I kind of like things that are simpler to understand,

675
00:32:13,330 --> 00:32:16,091
simpler to build, simpler to reason about.

676
00:32:16,091 --> 00:32:17,512
Especially like three months later

677
00:32:17,512 --> 00:32:19,032
when I come back to something,

678
00:32:19,032 --> 00:32:21,333
I don't want to be like, what did I do here?

679
00:32:21,333 --> 00:32:22,313
What idiot wrote this?

680
00:32:22,313 --> 00:32:23,273
Oh, it was me.

681
00:32:23,900 --> 00:32:26,882
You know, so again, I guess a lot of people are saying,

682
00:32:26,882 --> 00:32:29,224
well, first you said they're bad, then they're not.

683
00:32:29,224 --> 00:32:31,265
Now you're saying, don't use it for decision making,

684
00:32:31,265 --> 00:32:32,446
but I can make some decisions.

685
00:32:32,446 --> 00:32:33,807
It's like, what should I actually do?

686
00:32:33,807 --> 00:32:35,929
Well, we're spoiled for choice.

687
00:32:35,929 --> 00:32:37,770
We have a lot of techniques available to us.

688
00:32:37,770 --> 00:32:39,332
We have state machines, we have planners,

689
00:32:39,332 --> 00:32:40,633
we have utility systems.

690
00:32:40,633 --> 00:32:43,315
These days there's a revival of neural networks,

691
00:32:43,315 --> 00:32:44,756
machine learning, that kind of stuff.

692
00:32:44,756 --> 00:32:47,338
We have a lot of these options out.

693
00:32:47,338 --> 00:32:48,919
You don't have to pick one.

694
00:32:48,919 --> 00:32:51,301
You can pick multiple, you know?

695
00:32:52,540 --> 00:32:57,683
choose. What I've kind of found to be an elegant approach to solving this problem, for me at least, is

696
00:32:57,683 --> 00:33:02,185
something I like to call a hierarchical finite state machine behavior tree hybrid, or

697
00:33:02,185 --> 00:33:04,427
hoversome but-a-her, for short. Rolls off the tongue.

698
00:33:04,427 --> 00:33:06,868
Hoversome but-a-her.

699
00:33:06,868 --> 00:33:14,052
So, I guess a lot of you are asking me, like, state machines, you know, didn't we go through this already?

700
00:33:14,052 --> 00:33:17,795
You know, there's problems, you know, that kind of thing. And there's a whole bunch of you probably going like,

701
00:33:17,795 --> 00:33:21,417
I've seen this movie, I know how this ends. But, hear me out.

702
00:33:22,199 --> 00:33:25,921
So state machines are excellent for describing states and transitions.

703
00:33:25,921 --> 00:33:29,303
They're easy to visualize, they're easy to author, they're easy to understand.

704
00:33:29,303 --> 00:33:31,784
They're horrible for defining sequence of actions.

705
00:33:31,784 --> 00:33:32,444
Absolutely horrible.

706
00:33:32,444 --> 00:33:35,666
Behavior trees are excellent for describing sequence of actions,

707
00:33:35,666 --> 00:33:38,588
and they can do parallel execution of actions.

708
00:33:38,588 --> 00:33:41,790
But they're awful for describing transitions and these cyclic behaviors.

709
00:33:41,997 --> 00:33:44,338
Both of these techniques are relatively well proven,

710
00:33:44,338 --> 00:33:46,678
they're well understood, they're super low risk.

711
00:33:46,678 --> 00:33:48,459
You know, there's a very high reward.

712
00:33:48,459 --> 00:33:50,539
But alone, both of them have their problems.

713
00:33:50,539 --> 00:33:53,900
And what we're trying to do is kind of combine them together

714
00:33:53,900 --> 00:33:55,480
to kind of build something that's greater

715
00:33:55,480 --> 00:33:56,440
than the sum of the parts.

716
00:33:56,440 --> 00:34:00,241
We want to kind of accentuate the pros of one

717
00:34:00,241 --> 00:34:02,502
and the pros of the other and try to minimize the cons

718
00:34:02,502 --> 00:34:04,362
by just avoiding them at all.

719
00:34:04,362 --> 00:34:05,523
So I'll give you an example of this

720
00:34:05,523 --> 00:34:09,303
based on the simple combat investigation AI system.

721
00:34:10,297 --> 00:34:12,518
If we look at this diagram, it's kind of the same as before,

722
00:34:12,518 --> 00:34:14,159
except it's a little bit more clear.

723
00:34:14,159 --> 00:34:15,899
We can say, okay, our combat behaviors

724
00:34:15,899 --> 00:34:17,921
can alternate between these three.

725
00:34:17,921 --> 00:34:19,721
We know that from each one, we can go to the next

726
00:34:19,721 --> 00:34:22,323
and alternate back depending on what's necessary.

727
00:34:22,323 --> 00:34:24,584
We can say, okay, we can go from idle to combat,

728
00:34:24,584 --> 00:34:26,225
but if we want to go back to idle,

729
00:34:26,225 --> 00:34:27,626
we have to go through an investigation

730
00:34:27,626 --> 00:34:30,107
because maybe our game loop is set up to say,

731
00:34:30,107 --> 00:34:31,788
fight, when I lose a target, I investigate,

732
00:34:31,788 --> 00:34:35,129
if I can't find him, oh well, go back to idle.

733
00:34:35,129 --> 00:34:37,511
If I was alerted in my idle, like I heard a noise,

734
00:34:38,390 --> 00:34:39,951
then it's okay to go back to a relaxed idle.

735
00:34:39,951 --> 00:34:42,351
It's sort of very clear that you can look at this

736
00:34:42,351 --> 00:34:43,872
and say, yeah, I get what this is doing, you know?

737
00:34:43,872 --> 00:34:44,032
Cool.

738
00:34:44,032 --> 00:34:47,073
Also, if you click one of these transitions,

739
00:34:47,073 --> 00:34:49,773
you can then set up a set of conditions there saying,

740
00:34:49,773 --> 00:34:52,494
hey, if these conditions are met, I do this transition,

741
00:34:52,494 --> 00:34:54,034
but I just play a simple reaction behavior.

742
00:34:54,034 --> 00:34:56,455
Or, hey, if there's a different set of conditions,

743
00:34:56,455 --> 00:34:58,236
then I need to do something more complex.

744
00:34:58,236 --> 00:35:00,196
It gives you the flexibility there

745
00:35:00,196 --> 00:35:01,957
to kind of do specific transitions.

746
00:35:03,470 --> 00:35:05,650
And again, it's very simple to understand.

747
00:35:05,650 --> 00:35:08,491
And now again, if we go back to my code quality metric,

748
00:35:08,491 --> 00:35:11,673
if I want to delete investigate, what do I do?

749
00:35:11,673 --> 00:35:13,213
I select investigate and I hit delete.

750
00:35:13,213 --> 00:35:14,914
All the transitions go with it.

751
00:35:14,914 --> 00:35:17,755
All the logic for the special cases go with it.

752
00:35:17,755 --> 00:35:19,295
Everything's clear.

753
00:35:19,295 --> 00:35:20,876
It's like it never existed.

754
00:35:20,876 --> 00:35:23,417
And I think that to be a very kind of elegant solution

755
00:35:23,417 --> 00:35:24,417
for that.

756
00:35:24,417 --> 00:35:24,477
Now,

757
00:35:25,275 --> 00:35:27,336
I don't want you to miss the point here.

758
00:35:27,336 --> 00:35:28,017
Don't get me wrong.

759
00:35:28,017 --> 00:35:30,498
This approach obviously isn't perfect.

760
00:35:30,498 --> 00:35:31,638
Pros and cons everywhere.

761
00:35:31,638 --> 00:35:33,579
There are some tricks with this approach

762
00:35:33,579 --> 00:35:36,340
that you need to know, like regarding how you do hierarchies

763
00:35:36,340 --> 00:35:37,921
and entry states and that kind of thing.

764
00:35:37,921 --> 00:35:39,602
If you want more details about this, ping me.

765
00:35:39,602 --> 00:35:41,383
I'm available this week, whatever.

766
00:35:41,383 --> 00:35:43,724
But my point isn't about the state machines.

767
00:35:43,724 --> 00:35:45,265
I could have just as easily used a planner

768
00:35:45,265 --> 00:35:46,905
or some other technique.

769
00:35:46,905 --> 00:35:50,087
For example, these sort of execution behavior trees

770
00:35:50,087 --> 00:35:51,327
are great for use with like a HTM planner

771
00:35:51,327 --> 00:35:53,388
where the tasks themselves are the trees.

772
00:35:54,989 --> 00:35:57,211
My point, and that I'm trying to get to this talk,

773
00:35:57,211 --> 00:35:59,674
is that behavior trees are not an ideal technique

774
00:35:59,674 --> 00:36:01,516
for decision making.

775
00:36:01,516 --> 00:36:03,618
We are abusing them, and through that abuse,

776
00:36:03,618 --> 00:36:06,081
we're scaring new people from these things.

777
00:36:06,081 --> 00:36:08,143
I've had situations where I've come to a company

778
00:36:08,143 --> 00:36:10,005
and looked at a behavior tree with 40,000 nodes

779
00:36:10,005 --> 00:36:12,027
and been like,

780
00:36:12,027 --> 00:36:12,388
oh.

781
00:36:13,723 --> 00:36:18,087
And then it's like a week later, I know maybe one tiny portion of it.

782
00:36:18,087 --> 00:36:22,210
We are making things unnecessarily complicated for ourselves,

783
00:36:22,210 --> 00:36:23,991
and we're sort of drowning in some complexity.

784
00:36:23,991 --> 00:36:26,293
When you get to a point where you want to do a simple combat behavior,

785
00:36:26,293 --> 00:36:29,415
and it takes you three weeks of breaking stuff

786
00:36:29,415 --> 00:36:31,937
and kind of trying to figure out a way to crowbar it in,

787
00:36:31,937 --> 00:36:33,718
we have problems.

788
00:36:33,718 --> 00:36:36,781
So, what I'm trying to get at is fundamentally is...

789
00:36:37,936 --> 00:36:41,719
understand what you're building with, whether it's behavior trees or any other approach.

790
00:36:41,719 --> 00:36:46,262
Behavior trees especially is that these sort of cyclic problems are not very well discussed

791
00:36:46,262 --> 00:36:46,582
or known.

792
00:36:46,582 --> 00:36:48,604
That's something to keep in mind.

793
00:36:48,604 --> 00:36:53,187
So in conclusion, I'm just going to give you some do's and don'ts, just basically wrapping

794
00:36:53,187 --> 00:36:54,769
up what I just talked about.

795
00:36:54,769 --> 00:36:58,692
It's simply behavior trees are excellent at describing individual behaviors, hence the

796
00:36:58,692 --> 00:37:00,553
name, I guess, behavior trees.

797
00:37:00,553 --> 00:37:01,354
So use them for that.

798
00:37:01,354 --> 00:37:06,838
Keep them as small and as simple as possible and combine them with other techniques to

799
00:37:06,838 --> 00:37:07,698
get the most out of them.

800
00:37:08,723 --> 00:37:10,924
Also, things that are bad is, as I said,

801
00:37:10,924 --> 00:37:13,265
interruption transitions, the cyclic problem,

802
00:37:13,265 --> 00:37:15,787
and please stop building large monolithic trees

803
00:37:15,787 --> 00:37:17,868
that have multiple responsibilities.

804
00:37:17,868 --> 00:37:20,008
You know, don't have this massive tree

805
00:37:20,008 --> 00:37:22,590
with the static prioritization of combat over,

806
00:37:22,590 --> 00:37:25,251
investigation over this, over that.

807
00:37:25,251 --> 00:37:28,452
Imagine trying to build a boss battle in a behavior tree.

808
00:37:28,452 --> 00:37:29,613
It's gonna be a nightmare.

809
00:37:30,721 --> 00:37:34,205
So, you wouldn't do that, you'd probably use the state machine for that.

810
00:37:34,205 --> 00:37:40,653
And that's what I'm trying to get at, is kind of understand the tools that you're using.

811
00:37:40,653 --> 00:37:43,957
And more than anything else, is stop using behavior trees for your decision-making logic.

812
00:37:43,957 --> 00:37:44,537
Use them where they work.

813
00:37:44,537 --> 00:37:51,025
So Ben is now going to kick in with something a little bit more interesting and complex.

814
00:38:00,142 --> 00:38:01,603
Hello everyone.

815
00:38:01,603 --> 00:38:04,185
My name is Ben Weber and I'm on the science team at Twitch.

816
00:38:04,185 --> 00:38:06,987
Today I'm gonna be talking about a lot of my experience

817
00:38:06,987 --> 00:38:09,489
with behavior trees during my graduate study

818
00:38:09,489 --> 00:38:12,431
at UC Santa Cruz.

819
00:38:12,431 --> 00:38:14,493
So, here's the topics I'll be covering

820
00:38:14,493 --> 00:38:15,634
for my section of this talk.

821
00:38:15,634 --> 00:38:17,595
A lot of my experience was with the reactive

822
00:38:17,595 --> 00:38:19,977
planning language and there's a lot of different features

823
00:38:19,977 --> 00:38:21,638
of that language that are useful when you're

824
00:38:21,638 --> 00:38:22,559
authoring behavior trees.

825
00:38:22,559 --> 00:38:24,901
So I wanna give some ideas and inspiration

826
00:38:24,901 --> 00:38:26,322
for some patterns you can use from that.

827
00:38:27,445 --> 00:38:29,747
Also, as you start to author more complex trees,

828
00:38:29,747 --> 00:38:32,389
you start to see patterns being used over and over again.

829
00:38:32,389 --> 00:38:33,690
I actually didn't follow Bobby's advice

830
00:38:33,690 --> 00:38:35,552
and made one big monolithic tree.

831
00:38:35,552 --> 00:38:36,913
Had I seen this talk before,

832
00:38:36,913 --> 00:38:38,374
I might have done things differently.

833
00:38:38,374 --> 00:38:41,337
But I'll give some ideas for how I handle that complexity.

834
00:38:41,337 --> 00:38:43,058
And then third, I'll talk about some extensions

835
00:38:43,058 --> 00:38:43,739
to behavior trees.

836
00:38:43,739 --> 00:38:45,961
So Bobby talked about finite state machines

837
00:38:45,961 --> 00:38:47,962
being used in collaboration with behavior trees.

838
00:38:47,962 --> 00:38:49,984
I'll talk about some learning mechanisms

839
00:38:49,984 --> 00:38:50,805
I used with behavior trees.

840
00:38:52,548 --> 00:38:54,429
So a lot of my experience with behavior trees is actually

841
00:38:54,429 --> 00:38:56,750
with the Able Reactive Planning Language.

842
00:38:56,750 --> 00:38:59,091
And this was a language that was used to author

843
00:38:59,091 --> 00:39:01,172
the autonomous characters in Facade.

844
00:39:01,172 --> 00:39:02,993
So a reactive planning language is like an HTM

845
00:39:02,993 --> 00:39:05,274
where you basically execute as you're planning.

846
00:39:05,274 --> 00:39:07,235
And it has a number of primitives

847
00:39:07,235 --> 00:39:08,876
that are similar to behavior trees.

848
00:39:08,876 --> 00:39:11,377
So you can kind of talk about it in a similar way.

849
00:39:11,377 --> 00:39:15,199
There's selectors, there's parallel and sequential nodes.

850
00:39:15,199 --> 00:39:16,300
They just have different terms.

851
00:39:16,300 --> 00:39:18,020
So I'll try to map those to the common terms

852
00:39:18,020 --> 00:39:18,841
here in this talk.

853
00:39:19,500 --> 00:39:23,742
One of the node types that's really useful when authoring agents that need to handle a lot of goals

854
00:39:23,742 --> 00:39:27,184
and do kind of concurrent action pursuit is spawn goal.

855
00:39:27,184 --> 00:39:30,426
And this is a node type where you basically create a new goal to pursue,

856
00:39:30,426 --> 00:39:34,368
but it's a separate thread of execution from the current node.

857
00:39:34,368 --> 00:39:39,190
Scoped at the node that it's created from, it's basically a selector node,

858
00:39:39,190 --> 00:39:42,452
but it's pursued concurrently from the current execution flow.

859
00:39:42,452 --> 00:39:44,193
And if that node goes away, the parent node...

860
00:39:44,560 --> 00:39:46,602
is removed, then that goal goes away as well.

861
00:39:46,602 --> 00:39:49,004
So it's a way of doing concurrent goal pursuit

862
00:39:49,004 --> 00:39:50,625
that's scoped within a particular task.

863
00:39:50,625 --> 00:39:52,847
So I'll provide an example of how that's used

864
00:39:52,847 --> 00:39:54,829
within a bot that I produced.

865
00:39:54,829 --> 00:39:57,191
Another example is working memory modifiers.

866
00:39:57,191 --> 00:39:59,513
So Mika already talked about these decorator patterns

867
00:39:59,513 --> 00:40:01,574
where you can read and write from the blackboard.

868
00:40:01,574 --> 00:40:03,436
I'll talk about how that's used

869
00:40:03,436 --> 00:40:04,757
in the system that I produced.

870
00:40:05,708 --> 00:40:07,550
And then a third node type is success test.

871
00:40:07,550 --> 00:40:10,173
And this is a type of node where you basically

872
00:40:10,173 --> 00:40:11,494
can combine it with a wait step

873
00:40:11,494 --> 00:40:13,255
to suspend the execution of your tree.

874
00:40:13,255 --> 00:40:14,817
So if there's a set of conditions

875
00:40:14,817 --> 00:40:17,499
that you want to become true before you proceed,

876
00:40:17,499 --> 00:40:19,141
you can use this node type to do so.

877
00:40:19,141 --> 00:40:21,843
So you basically continue to perform an action

878
00:40:21,843 --> 00:40:23,145
until a set of conditions is met.

879
00:40:24,584 --> 00:40:26,765
So I use this tool that actually runs asynchronous

880
00:40:26,765 --> 00:40:29,207
from the decision cycle thread, and it creates issues

881
00:40:29,207 --> 00:40:31,248
whenever you need to actually execute actions in the game.

882
00:40:31,248 --> 00:40:33,349
This probably isn't a problem if you're using

883
00:40:33,349 --> 00:40:35,470
a behavior tree library, but I did have some issues

884
00:40:35,470 --> 00:40:37,651
with things like task scheduling and resource contention

885
00:40:37,651 --> 00:40:39,552
where you need to make sure that if you have

886
00:40:39,552 --> 00:40:42,374
concurrent goal pursuit that you're setting state

887
00:40:42,374 --> 00:40:45,136
or locking behaviors so that you don't have multiple goals

888
00:40:45,136 --> 00:40:47,757
that are trying to use the same unit

889
00:40:47,757 --> 00:40:51,019
or cause multiple threads of execution to happen

890
00:40:51,019 --> 00:40:52,200
for one character at the same time.

891
00:40:53,077 --> 00:40:57,117
Also, I had a performance issue with dynamic behavior

892
00:40:57,117 --> 00:40:59,478
expansion, where you can actually pass parameters to

893
00:40:59,478 --> 00:41:00,438
your selector nodes.

894
00:41:00,438 --> 00:41:04,179
So a lot of what you can do to expand the tree is done at

895
00:41:04,179 --> 00:41:06,820
runtime, which isn't really too big of a performance issue.

896
00:41:06,820 --> 00:41:09,100
But in the initial days of Behavior Trees, I think that

897
00:41:09,100 --> 00:41:09,920
was more of a concern.

898
00:41:09,920 --> 00:41:14,421
So a lot of my experience with Behavior Trees was authoring a

899
00:41:14,421 --> 00:41:15,141
bot for StarCraft.

900
00:41:15,141 --> 00:41:18,042
So this was called IceBot, and this was done back in 2010.

901
00:41:18,042 --> 00:41:18,422
And

902
00:41:19,124 --> 00:41:21,125
It was based on this reactive planning language.

903
00:41:21,125 --> 00:41:23,167
And what I wanted to do was have something that could play

904
00:41:23,167 --> 00:41:25,148
at the level of like Flash here, where you could do

905
00:41:25,148 --> 00:41:26,269
hundreds of actions per minute.

906
00:41:26,269 --> 00:41:28,611
You could do really cool text switches.

907
00:41:28,611 --> 00:41:31,292
You can learn from demonstrations and have this evolving metagame.

908
00:41:31,292 --> 00:41:33,714
So I tried to author this huge monolithic behavior tree

909
00:41:33,714 --> 00:41:35,916
that could handle all those situations.

910
00:41:36,845 --> 00:41:40,946
So some of the design patterns I came up with as I expanded this tree

911
00:41:40,946 --> 00:41:46,548
were things like daemon behaviors where this is a fixation of the agent that's done

912
00:41:46,548 --> 00:41:48,569
concurrently with other tasks being performed.

913
00:41:48,569 --> 00:41:53,191
And it's a way of handling kind of low priority actions that need to continuously be pursued.

914
00:41:53,191 --> 00:41:58,733
There's this concept of managers where the AI is built into different subsystems.

915
00:41:58,733 --> 00:42:01,914
So when you have something complex, you have a lot of different actions to take,

916
00:42:01,914 --> 00:42:04,355
different competencies to manage, it's good to split up the behavior.

917
00:42:05,555 --> 00:42:07,036
To coordinate between these different managers,

918
00:42:07,036 --> 00:42:08,536
I use some message passing patterns,

919
00:42:08,536 --> 00:42:10,538
and that's similar to some of the decorator patterns,

920
00:42:10,538 --> 00:42:12,219
but I'll show examples of this.

921
00:42:12,219 --> 00:42:14,400
And then behavior locking is another version

922
00:42:14,400 --> 00:42:17,241
of message passing where one manager will prevent

923
00:42:17,241 --> 00:42:18,782
another one from doing an action.

924
00:42:18,782 --> 00:42:21,564
And finally, unit subtasks, which is basically

925
00:42:21,564 --> 00:42:23,505
using the unit for a short amount of time

926
00:42:23,505 --> 00:42:25,926
and then giving it back to the manager that owns it.

927
00:42:26,813 --> 00:42:29,015
So I'll talk through different examples of this

928
00:42:29,015 --> 00:42:30,236
and actually provide some ABLE code

929
00:42:30,236 --> 00:42:31,657
and talk about how that works.

930
00:42:31,657 --> 00:42:33,638
So daemon behaviors are basically a way of

931
00:42:33,638 --> 00:42:35,880
handling a set of actions that need to be

932
00:42:35,880 --> 00:42:37,281
pursued concurrently.

933
00:42:37,281 --> 00:42:40,624
So I use this in my system to basically make sure that

934
00:42:40,624 --> 00:42:42,846
units that need ammunition produced are basically

935
00:42:42,846 --> 00:42:44,828
always topping those up if they have them.

936
00:42:44,828 --> 00:42:47,090
And this is implemented with the spawn goal behavior.

937
00:42:47,270 --> 00:42:52,712
which then calls a selector node that pursues a goal kind of persistently.

938
00:42:52,712 --> 00:42:54,913
So it basically spawns a selector node,

939
00:42:54,913 --> 00:42:56,733
it has a node decorator that says,

940
00:42:56,733 --> 00:42:58,914
while true, continue pursuing the sub-goal.

941
00:42:58,914 --> 00:43:00,895
So in the case of this ammunition example,

942
00:43:00,895 --> 00:43:05,337
it basically spawns a goal to always be topping up the ammunition for the agent.

943
00:43:06,722 --> 00:43:10,125
So how this is realized in iSpot is through this

944
00:43:10,125 --> 00:43:12,207
daemon behavior for restocking units.

945
00:43:12,207 --> 00:43:14,069
So here's some Able code.

946
00:43:14,069 --> 00:43:19,374
Able is translated to Java code and then compiled into

947
00:43:19,374 --> 00:43:20,555
byte code for runtime.

948
00:43:20,555 --> 00:43:22,137
So it's not a data structure or a tree.

949
00:43:22,137 --> 00:43:25,700
It's actually a language that gets compiled, which has some

950
00:43:25,700 --> 00:43:28,042
side effects, but it was what I used at the time.

951
00:43:28,422 --> 00:43:30,444
So first there's two behaviors in this example.

952
00:43:30,444 --> 00:43:33,107
There's initial tree, which is the root behavior,

953
00:43:33,107 --> 00:43:33,828
which is parallel.

954
00:43:33,828 --> 00:43:36,170
And then there's a second behavior called restock units,

955
00:43:36,170 --> 00:43:37,992
which is another parallel behavior.

956
00:43:37,992 --> 00:43:39,633
Each of these has two steps.

957
00:43:39,633 --> 00:43:42,156
The root behavior basically says,

958
00:43:42,156 --> 00:43:44,258
create a Spawn Gulf to restock units,

959
00:43:44,258 --> 00:43:45,519
and then go set up the managers,

960
00:43:45,519 --> 00:43:47,060
which I'll talk about in a second.

961
00:43:47,581 --> 00:43:51,484
And then the second behavior is basically continuing to pursue these different behaviors.

962
00:43:51,484 --> 00:43:56,069
So with persistent means continue to pursue this, and subgoal is equivalent to selector.

963
00:43:56,069 --> 00:44:02,574
So you're basically continuing to look at training new interceptors or new scarabs for your carriers

964
00:44:02,574 --> 00:44:07,819
or reavers in your Starcraft bot. So these are units that are empty in terms of ammunition when

965
00:44:07,819 --> 00:44:10,522
you start them, so you need to actually produce units for them to be useful.

966
00:44:13,550 --> 00:44:16,975
So to decompose StarCraft gameplay into something more manageable,

967
00:44:16,975 --> 00:44:20,840
I used this concept of managers, which is basically different subsystems.

968
00:44:20,840 --> 00:44:24,845
And this is something that was pretty common with StarCraft bots that were authored for the AI competition,

969
00:44:24,845 --> 00:44:28,510
where people would make like a tactics manager that handles combat,

970
00:44:28,510 --> 00:44:30,873
a strategy manager for handling the build order.

971
00:44:30,953 --> 00:44:34,677
things like resource manager, tactics,

972
00:44:34,677 --> 00:44:35,719
reconnaissance, and so on.

973
00:44:35,719 --> 00:44:37,962
So here's some examples of some of the managers

974
00:44:37,962 --> 00:44:39,443
that I used in my system.

975
00:44:39,443 --> 00:44:40,965
You have things like the income manager,

976
00:44:40,965 --> 00:44:43,709
which is responsible for managing the worker units

977
00:44:43,709 --> 00:44:46,052
for gathering resources.

978
00:44:46,052 --> 00:44:47,213
You have a construction manager,

979
00:44:47,213 --> 00:44:49,376
which is responsible for actually producing units

980
00:44:49,376 --> 00:44:50,357
when there's a request.

981
00:44:51,588 --> 00:44:53,930
The tactics manager handles actually forming squads

982
00:44:53,930 --> 00:44:56,433
and then detailed behavior like micromanagement,

983
00:44:56,433 --> 00:44:57,814
dancing units around, things like that.

984
00:44:57,814 --> 00:44:59,676
And then there's a scouting manager

985
00:44:59,676 --> 00:45:01,437
which is responsible for reconnaissance.

986
00:45:01,437 --> 00:45:03,419
So it actually takes a worker unit and goes around the map

987
00:45:03,419 --> 00:45:05,581
and later on in the game it handles other units.

988
00:45:06,590 --> 00:45:08,812
There's also this high-level strategy manager,

989
00:45:08,812 --> 00:45:11,155
which actually doesn't perform any actions itself.

990
00:45:11,155 --> 00:45:12,676
It coordinates with the other managers

991
00:45:12,676 --> 00:45:14,738
to actually execute those actions.

992
00:45:14,738 --> 00:45:16,240
So it selects the build order,

993
00:45:16,240 --> 00:45:17,902
but it doesn't go about actually telling

994
00:45:17,902 --> 00:45:19,243
the units what to produce.

995
00:45:19,243 --> 00:45:21,906
That's done through some message passing examples.

996
00:45:23,342 --> 00:45:25,723
So here's an example of one of the managers in iSpot.

997
00:45:25,723 --> 00:45:28,664
This is a subset of the behaviors that get called

998
00:45:28,664 --> 00:45:29,845
for the income manager.

999
00:45:29,845 --> 00:45:32,326
So at the top, you have behaviors like pump probes,

1000
00:45:32,326 --> 00:45:34,747
where this is, again, using that persistent keyword,

1001
00:45:34,747 --> 00:45:37,388
where it's continuing to run this selector node

1002
00:45:37,388 --> 00:45:40,529
for pumping probes, which means keep producing worker units

1003
00:45:40,529 --> 00:45:42,370
while a set of preconditions is met.

1004
00:45:42,370 --> 00:45:44,971
So you would have different instances

1005
00:45:44,971 --> 00:45:46,152
of pump probe behaviors

1006
00:45:46,152 --> 00:45:47,893
with different sets of preconditions.

1007
00:45:47,893 --> 00:45:50,254
But basically, this is saying try to produce probes

1008
00:45:50,254 --> 00:45:52,735
if those behaviors are ready to be activated.

1009
00:45:53,131 --> 00:45:55,893
There's also things like putting workers on gas,

1010
00:45:55,893 --> 00:45:58,875
taking workers off gas, which helps manage the income ratio

1011
00:45:58,875 --> 00:46:01,537
between minerals and gas for the unit.

1012
00:46:01,537 --> 00:46:03,819
There's other behaviors where it actually has to coordinate

1013
00:46:03,819 --> 00:46:04,839
with some of the other managers.

1014
00:46:04,839 --> 00:46:07,601
So for processing an expansion request,

1015
00:46:07,601 --> 00:46:10,043
the manager doesn't actually decide when to expand.

1016
00:46:10,043 --> 00:46:11,504
That's done from the strategy manager.

1017
00:46:11,504 --> 00:46:13,666
But the income manager is responsible

1018
00:46:13,666 --> 00:46:15,627
for transferring workers to that new unit,

1019
00:46:15,627 --> 00:46:17,208
to dispatching the construction requests

1020
00:46:17,208 --> 00:46:17,889
and things like that.

1021
00:46:17,889 --> 00:46:20,131
And what's great about this is you can actually

1022
00:46:20,131 --> 00:46:22,372
kind of decouple these managers a bit.

1023
00:46:22,898 --> 00:46:26,827
make sure that the strategy matter uh... handles things like it's now time to

1024
00:46:26,827 --> 00:46:27,288
attack

1025
00:46:27,288 --> 00:46:27,949
time to expand

1026
00:46:27,949 --> 00:46:31,616
and in commanders responsible for more the tactical actions within that

1027
00:46:34,015 --> 00:46:36,135
So to achieve coordination between these different managers,

1028
00:46:36,135 --> 00:46:39,277
we need to have some message passing or coordination between them.

1029
00:46:39,277 --> 00:46:40,957
Here's how this is done in Able.

1030
00:46:40,957 --> 00:46:44,759
You basically have these sequential behaviors that I show,

1031
00:46:44,759 --> 00:46:47,560
basically what a message producer is and a message consumer.

1032
00:46:47,560 --> 00:46:51,461
The message producer has one step, which is a mental act.

1033
00:46:51,461 --> 00:46:53,642
And in Able, this is inline Java code,

1034
00:46:53,642 --> 00:46:57,683
where you basically say, grab your working memory or your blackboard.

1035
00:46:58,184 --> 00:47:00,805
and create a new object called a message working memory element

1036
00:47:00,805 --> 00:47:02,546
and put that on the blackboard system.

1037
00:47:02,546 --> 00:47:05,908
So it's basically just saying, grab a reference to this,

1038
00:47:05,908 --> 00:47:07,829
add an element to the blackboard.

1039
00:47:07,829 --> 00:47:11,331
And then the second behavior here is actually consuming that,

1040
00:47:11,331 --> 00:47:14,212
dispatching a subgoal to complete that task,

1041
00:47:14,212 --> 00:47:16,273
and then removing it from memory.

1042
00:47:16,273 --> 00:47:17,374
So there's two steps here.

1043
00:47:18,014 --> 00:47:21,375
First, there's a precondition not really considered a step,

1044
00:47:21,375 --> 00:47:23,496
which looks for something on working memory.

1045
00:47:23,496 --> 00:47:25,516
So if there is a message working memory element

1046
00:47:25,516 --> 00:47:27,817
on the blackboard, it binds that to the message parameter.

1047
00:47:27,817 --> 00:47:30,658
It then calls a subgoal with that message.

1048
00:47:30,658 --> 00:47:34,259
So enable, you can actually call selectors with parameters.

1049
00:47:34,259 --> 00:47:37,100
And then once that's completed, at the end,

1050
00:47:37,100 --> 00:47:39,661
we'll clean that up and remove it from the blackboard.

1051
00:47:39,661 --> 00:47:42,102
So it's a way of actually having different managers

1052
00:47:42,102 --> 00:47:43,342
communicate with each other.

1053
00:47:43,342 --> 00:47:45,203
And you can create all sorts of different objects

1054
00:47:45,203 --> 00:47:46,023
with different parameters.

1055
00:47:48,052 --> 00:47:51,253
So I talked about an example where you actually need agents to coordinate.

1056
00:47:51,253 --> 00:47:54,533
So you might have the strategy manager say,

1057
00:47:54,533 --> 00:47:55,874
it's now time to produce a gateway.

1058
00:47:55,874 --> 00:47:59,455
It creates a working memory element that says, produce a gateway.

1059
00:47:59,455 --> 00:48:03,016
And the construction manager will go process that request.

1060
00:48:03,016 --> 00:48:05,057
But you also have situations where you want...

1061
00:48:05,930 --> 00:48:07,590
another manager to not perform an action.

1062
00:48:07,590 --> 00:48:09,191
So I call this kind of behavior locking,

1063
00:48:09,191 --> 00:48:12,432
where in StarCraft you might want to remove worker units

1064
00:48:12,432 --> 00:48:14,793
from gas and focus on minerals.

1065
00:48:14,793 --> 00:48:17,014
So here's an example of where we're actually using

1066
00:48:17,014 --> 00:48:19,515
the success test node type.

1067
00:48:19,515 --> 00:48:21,956
And the way this reads is basically,

1068
00:48:21,956 --> 00:48:25,637
first you're gonna bind an assimilator parameter

1069
00:48:25,637 --> 00:48:28,058
if there is a simulator working memory element in memory.

1070
00:48:28,519 --> 00:48:30,699
And the not condition here says,

1071
00:48:30,699 --> 00:48:33,320
do not succeed if there's one of these on the blackboard.

1072
00:48:33,320 --> 00:48:35,280
So it's a negation term that you can use.

1073
00:48:35,280 --> 00:48:38,181
So basically the way this is gonna work is,

1074
00:48:38,181 --> 00:48:42,302
if there's a simulator ready, it's gonna proceed.

1075
00:48:42,302 --> 00:48:43,182
But if there's not one yet,

1076
00:48:43,182 --> 00:48:45,282
or if there's this element working memory

1077
00:48:45,282 --> 00:48:46,683
that says don't proceed,

1078
00:48:46,683 --> 00:48:48,663
it's gonna suspend the execution of that behavior.

1079
00:48:48,663 --> 00:48:51,144
So it's a way of actually blocking

1080
00:48:51,144 --> 00:48:52,984
other managers from executing.

1081
00:48:52,984 --> 00:48:54,584
So it's essentially a fancy decorator,

1082
00:48:54,584 --> 00:48:57,405
but this suspending of execution's a great way

1083
00:48:57,405 --> 00:48:57,485
to...

1084
00:48:58,345 --> 00:49:01,327
execute authors, or I mean, to author behaviors,

1085
00:49:01,327 --> 00:49:03,788
because you can do a sequence of steps,

1086
00:49:03,788 --> 00:49:05,369
which is useful when you have things

1087
00:49:05,369 --> 00:49:07,329
that have a lot of preconditions.

1088
00:49:07,329 --> 00:49:09,250
So this is used in an example when you're doing things

1089
00:49:09,250 --> 00:49:13,132
like expanding and you want to focus all your workers

1090
00:49:13,132 --> 00:49:17,254
on minerals versus gas, and you can basically have

1091
00:49:17,254 --> 00:49:20,235
the strategy manager decide to perform that

1092
00:49:20,235 --> 00:49:22,496
high-level strategy, and then have the income manager

1093
00:49:22,496 --> 00:49:24,137
handle the actual tactics of that.

1094
00:49:26,015 --> 00:49:29,298
And then one more pattern I use is this idea of unit subtasks.

1095
00:49:29,298 --> 00:49:32,641
So this is where you're actually using a unit for a

1096
00:49:32,641 --> 00:49:35,844
few seconds or a duration, and then returning it to its

1097
00:49:35,844 --> 00:49:37,125
original task.

1098
00:49:37,125 --> 00:49:40,107
So an example of where this is useful in StarCraft is if

1099
00:49:40,287 --> 00:49:42,548
you have a unit that's being kind of harassed

1100
00:49:42,548 --> 00:49:44,828
by an enemy worker unit, you want to basically

1101
00:49:44,828 --> 00:49:46,709
counter-attack and then return to mining.

1102
00:49:46,709 --> 00:49:49,489
So this is where you want to spawn a goal

1103
00:49:49,489 --> 00:49:51,570
to handle the harassment and then return it

1104
00:49:51,570 --> 00:49:52,350
to the mining task.

1105
00:49:52,350 --> 00:49:55,451
So this is used in a few different ways in iSpot.

1106
00:49:55,451 --> 00:49:57,331
One is for micromanagement tasks.

1107
00:49:57,331 --> 00:49:58,992
So you group units into squads,

1108
00:49:58,992 --> 00:50:00,992
but then you want to be able to do tactical behavior

1109
00:50:00,992 --> 00:50:03,553
where you have units dance around and then return to action.

1110
00:50:04,253 --> 00:50:06,855
I already mentioned this worker defense case.

1111
00:50:06,855 --> 00:50:09,177
And then also another example is construction.

1112
00:50:09,177 --> 00:50:11,699
So you actually claim a unit, you go produce a building,

1113
00:50:11,699 --> 00:50:13,261
and then you return it to the income manager.

1114
00:50:13,261 --> 00:50:15,283
So this is an authoring pattern I

1115
00:50:15,283 --> 00:50:18,606
use whenever you have overlapping between managers

1116
00:50:18,606 --> 00:50:19,526
that have to share units.

1117
00:50:21,315 --> 00:50:24,936
So here's an example of what this looks like with able code.

1118
00:50:24,936 --> 00:50:28,557
This is for a Dragoon dance behavior, where basically

1119
00:50:28,557 --> 00:50:32,218
if a Dragoon is taking damage, you want to back off and then

1120
00:50:32,218 --> 00:50:34,139
re-engage the enemy, because it makes your units more

1121
00:50:34,139 --> 00:50:35,659
effective in combat.

1122
00:50:35,659 --> 00:50:37,840
So here's another example of where the success

1123
00:50:37,840 --> 00:50:39,100
test is being used.

1124
00:50:39,100 --> 00:50:43,381
This will bind the unit parameter to a Dragoon if

1125
00:50:43,381 --> 00:50:43,682
there is one.

1126
00:50:44,386 --> 00:50:47,289
on the blackboard where it says that damage is true,

1127
00:50:47,289 --> 00:50:48,931
so it's recently taken damage,

1128
00:50:48,931 --> 00:50:50,993
and it's not currently in a flea condition.

1129
00:50:50,993 --> 00:50:54,998
So basically this behavior is kind of executing

1130
00:50:54,998 --> 00:50:57,220
until this set of conditions is met.

1131
00:50:57,220 --> 00:50:57,921
When that

1132
00:50:58,530 --> 00:51:01,132
set of conditions is met, then a mental act is used

1133
00:51:01,132 --> 00:51:03,434
to basically say, set the status of this unit to flee,

1134
00:51:03,434 --> 00:51:06,237
and then spawn rule is used to actually handle

1135
00:51:06,237 --> 00:51:07,838
this subset of behavior.

1136
00:51:07,838 --> 00:51:11,961
So, this is actually introducing more state into the tree,

1137
00:51:11,961 --> 00:51:14,283
but we're actually spawning a separate thread of execution

1138
00:51:14,283 --> 00:51:15,904
to handle this micromanagement task.

1139
00:51:15,904 --> 00:51:17,986
So there'd be a number of different behaviors to handle,

1140
00:51:17,986 --> 00:51:19,627
like the actual placement of the unit,

1141
00:51:19,627 --> 00:51:21,829
how to engage and reengage with the unit,

1142
00:51:21,829 --> 00:51:23,250
and then once that behavior is completed,

1143
00:51:23,250 --> 00:51:25,372
it would change that flag again back to,

1144
00:51:26,807 --> 00:51:28,928
basically it's not fleeing, it's now in attack mode,

1145
00:51:28,928 --> 00:51:31,050
and that would clean up this behavior.

1146
00:51:31,050 --> 00:51:34,372
So it's a way of saying, like, handle this set of behavior

1147
00:51:34,372 --> 00:51:36,774
and then return the unit whenever it's available

1148
00:51:36,774 --> 00:51:37,315
to be claimed.

1149
00:51:39,199 --> 00:51:42,340
So here's an overview of the agent in action.

1150
00:51:42,340 --> 00:51:44,300
It is one big monolithic tree.

1151
00:51:44,300 --> 00:51:46,641
Basically at the start you have these different managers.

1152
00:51:46,641 --> 00:51:49,721
This is basically expanding as new behaviors

1153
00:51:49,721 --> 00:51:51,722
are being executed in the game.

1154
00:51:51,722 --> 00:51:54,383
So at the start you have things like the construction manager

1155
00:51:54,383 --> 00:51:57,963
and income manager that are just pumping probes,

1156
00:51:57,963 --> 00:52:00,864
warping in pylons, creating some gateways.

1157
00:52:00,864 --> 00:52:03,565
And then once the agent progresses further into the game,

1158
00:52:03,565 --> 00:52:06,605
the tactics manager will start forming squads.

1159
00:52:06,605 --> 00:52:08,106
You'll have the reconnaissance manager

1160
00:52:09,226 --> 00:52:11,667
grab units and go scout the opponent.

1161
00:52:11,667 --> 00:52:14,088
And later in the game, once you have a big enough force,

1162
00:52:14,088 --> 00:52:15,288
like the strategy manager will create

1163
00:52:15,288 --> 00:52:17,469
timing attack working memory element,

1164
00:52:17,469 --> 00:52:19,769
which basically tells the agent to

1165
00:52:19,769 --> 00:52:22,250
create a squad to go engage the enemy units.

1166
00:52:22,250 --> 00:52:25,091
So, this will proceed a bit.

1167
00:52:25,091 --> 00:52:27,932
Some units will be produced.

1168
00:52:27,932 --> 00:52:31,053
And then it will start to engage the enemy.

1169
00:52:31,053 --> 00:52:35,114
And then as behaviors are executing,

1170
00:52:35,114 --> 00:52:36,975
you basically see it turn blue,

1171
00:52:36,975 --> 00:52:38,695
which means that the tree's been expanded.

1172
00:52:40,652 --> 00:52:44,415
Now the unit's kind of scouting in the middle there.

1173
00:52:44,415 --> 00:52:44,875
And here we go.

1174
00:52:44,875 --> 00:52:47,817
So now the agent's actually engaging the enemy,

1175
00:52:47,817 --> 00:52:49,759
and you'll see that once these units

1176
00:52:49,759 --> 00:52:50,759
start to take a lot of damage,

1177
00:52:50,759 --> 00:52:53,502
they'll basically back off and then re-engage the enemy.

1178
00:52:53,502 --> 00:52:55,883
So that's an example of using that unit subtask behavior.

1179
00:52:55,883 --> 00:52:58,766
So the agent uses just these different managers

1180
00:52:58,766 --> 00:53:01,108
to do different subsets of the behavior

1181
00:53:01,108 --> 00:53:02,148
and execution of the agent.

1182
00:53:03,494 --> 00:53:06,218
It's doing all the decision-making within the strategy manager,

1183
00:53:06,218 --> 00:53:08,461
which is itself implemented as a behavior tree.

1184
00:53:08,461 --> 00:53:11,525
But it's a nice way of decoupling those dependencies between the managers.

1185
00:53:13,986 --> 00:53:16,967
So what I've shown so far is basically a scripted agent

1186
00:53:16,967 --> 00:53:19,748
where the build order and decision making was done

1187
00:53:19,748 --> 00:53:21,289
through the strategy manager.

1188
00:53:21,289 --> 00:53:23,950
And what I wanted to look at was how can we actually learn

1189
00:53:23,950 --> 00:53:25,770
from demonstration from professional players?

1190
00:53:25,770 --> 00:53:28,491
So that was part of the big inspiration for this agent.

1191
00:53:28,491 --> 00:53:30,852
And the way I achieved this was through

1192
00:53:30,852 --> 00:53:31,772
a few different patterns.

1193
00:53:31,772 --> 00:53:34,533
So here's kind of an overview of the agent architecture

1194
00:53:34,533 --> 00:53:36,874
where you have a set of learning components

1195
00:53:36,874 --> 00:53:39,175
which feed off the data from replays.

1196
00:53:39,175 --> 00:53:42,036
They then interface with either the agent's blackboard,

1197
00:53:42,036 --> 00:53:43,057
which is called the working memory.

1198
00:53:43,602 --> 00:53:46,583
or with the behavior library and active behavior tree.

1199
00:53:46,583 --> 00:53:49,324
So the most direct way of basically interfacing

1200
00:53:49,324 --> 00:53:51,325
with external systems is basically reading

1201
00:53:51,325 --> 00:53:52,846
and writing to the blackboard.

1202
00:53:52,846 --> 00:53:55,027
So if you just open that up to other components

1203
00:53:55,027 --> 00:53:57,428
to read and write to, you can do things like

1204
00:53:57,428 --> 00:53:59,990
the particle system I used where it basically tracks

1205
00:53:59,990 --> 00:54:01,991
where it thinks enemy units are,

1206
00:54:01,991 --> 00:54:06,413
and then the agent can use those estimated locations

1207
00:54:06,413 --> 00:54:08,234
to determine where to attack.

1208
00:54:08,234 --> 00:54:10,235
Basically, writing to the blackboard

1209
00:54:10,235 --> 00:54:13,016
was the most direct way of extending the system.

1210
00:54:15,340 --> 00:54:21,546
Another way of extending behavior trees is actually having an external component

1211
00:54:21,546 --> 00:54:25,410
generate the behaviors to execute. So instead of authoring everything, you can

1212
00:54:25,410 --> 00:54:30,535
basically have a set of replays that populate some of the behaviors to perform. So

1213
00:54:30,535 --> 00:54:34,379
here's an example of what this might look like. You basically have a replay file

1214
00:54:35,060 --> 00:54:36,621
and then on the right you have a behavior

1215
00:54:36,621 --> 00:54:37,521
that would get generated.

1216
00:54:37,521 --> 00:54:40,363
So this was actually done by a project at Georgia Tech

1217
00:54:40,363 --> 00:54:42,504
called Darmok, where they actually called it

1218
00:54:42,504 --> 00:54:46,766
case-based planning, and you basically feed it replays,

1219
00:54:46,766 --> 00:54:47,967
it creates a behavior library,

1220
00:54:47,967 --> 00:54:49,408
and then executes those at runtime.

1221
00:54:49,408 --> 00:54:51,989
I did something similar, but I actually did it

1222
00:54:51,989 --> 00:54:54,770
by basically placing new elements in working memory

1223
00:54:54,770 --> 00:54:57,332
one at a time, kind of as a build order sequence.

1224
00:54:57,332 --> 00:54:59,173
But I think it's great to show this example here

1225
00:54:59,173 --> 00:55:00,293
because it shows.

1226
00:55:00,534 --> 00:55:02,336
some of the types of work that can be done.

1227
00:55:02,336 --> 00:55:05,261
And it's interesting to see that you can create behaviors

1228
00:55:05,261 --> 00:55:06,903
at runtime from examples.

1229
00:55:06,903 --> 00:55:12,191
And then a third way to basically extend behavior trees

1230
00:55:12,191 --> 00:55:14,515
is by having other components.

1231
00:55:15,064 --> 00:55:16,625
augment the state of the tree,

1232
00:55:16,625 --> 00:55:19,287
so adding new nodes or removing nodes.

1233
00:55:19,287 --> 00:55:22,829
So this is a basically way of having external components

1234
00:55:22,829 --> 00:55:24,750
say, here's a goal I want to pursue.

1235
00:55:24,750 --> 00:55:26,511
So I use this in two ways in my system.

1236
00:55:26,511 --> 00:55:29,653
The first way was for, basically,

1237
00:55:29,653 --> 00:55:31,875
I had a system that detected whenever

1238
00:55:31,875 --> 00:55:33,976
the opponent was doing something

1239
00:55:33,976 --> 00:55:34,717
outside of your expectations.

1240
00:55:34,717 --> 00:55:37,178
When this happened, a discrepancy was fired

1241
00:55:37,178 --> 00:55:41,301
and then a new spawn goal was used to basically say,

1242
00:55:41,301 --> 00:55:42,782
pursue this new tech switch.

1243
00:55:43,739 --> 00:55:48,987
I also used it for this mixed initial model I built where you basically say like...

1244
00:55:49,872 --> 00:55:57,554
It was a GUI where you basically say select which build order to do and that created a spawn goal for the system to pursue a new

1245
00:55:57,554 --> 00:55:59,755
behavior to execute. So

1246
00:55:59,755 --> 00:56:04,636
basically, it's a way of having external components tell the agent what to do and it's useful for

1247
00:56:04,636 --> 00:56:07,377
removing some of the decision-making logic from the agent.

1248
00:56:07,377 --> 00:56:10,718
So instead of having the behavior tree decide when to attack,

1249
00:56:10,718 --> 00:56:14,259
having the tree decide what the build order can be, you can have external components do that.

1250
00:56:14,639 --> 00:56:17,842
And if you've set your agent up with this manager subsystem

1251
00:56:17,842 --> 00:56:19,303
and message passing between them,

1252
00:56:19,303 --> 00:56:21,805
you can basically swap out one of those managers

1253
00:56:21,805 --> 00:56:23,647
with an external component.

1254
00:56:23,647 --> 00:56:25,469
So it's a great way of adding

1255
00:56:25,469 --> 00:56:26,289
some extensibility to the tree.

1256
00:56:26,289 --> 00:56:29,492
And there's also some features of ABLE

1257
00:56:29,492 --> 00:56:32,635
that I didn't really interact with that are useful to note.

1258
00:56:32,635 --> 00:56:35,697
So joint goals and behaviors are basically

1259
00:56:35,697 --> 00:56:37,939
an approach you can use to have multiple ABLE agents

1260
00:56:37,939 --> 00:56:40,982
actually agree to perform an action and coordinate on that.

1261
00:56:40,982 --> 00:56:41,042
So.

1262
00:56:41,903 --> 00:56:44,024
As Roxanne just mentioned in her talk,

1263
00:56:44,024 --> 00:56:45,885
dialogue was something that was challenging

1264
00:56:45,885 --> 00:56:46,926
to actually execute,

1265
00:56:46,926 --> 00:56:48,847
because you have a lot of autonomous agents

1266
00:56:48,847 --> 00:56:51,588
and they actually need to agree on a task to perform.

1267
00:56:51,588 --> 00:56:53,829
With Able, this was actually a primitive

1268
00:56:53,829 --> 00:56:55,050
built into the language,

1269
00:56:55,050 --> 00:56:57,071
so it made it easy to author interactions

1270
00:56:57,071 --> 00:56:59,632
like where Grace and Trip argue about their trip to Italy

1271
00:56:59,632 --> 00:57:00,353
or things like that.

1272
00:57:01,381 --> 00:57:07,002
Another feature is meta behaviors where you can actually introspect and change the layout

1273
00:57:07,002 --> 00:57:11,364
of the tree or change, say, the priority of steps in the tree at runtime.

1274
00:57:11,364 --> 00:57:17,185
And it's a really powerful authoring tool, but it's also kind of dangerous because it's

1275
00:57:17,185 --> 00:57:23,507
opening up the tree to a lot of potential issues with orphan goals and things like that.

1276
00:57:23,507 --> 00:57:26,668
So you need to be careful when you kind of change things at runtime, but it's a powerful

1277
00:57:26,668 --> 00:57:26,908
tool.

1278
00:57:27,725 --> 00:57:30,906
And then more of a kind of academic project that was done

1279
00:57:30,906 --> 00:57:33,547
was this idea of partial programming where you

1280
00:57:33,547 --> 00:57:35,988
under-specify your preconditions for a behavior

1281
00:57:35,988 --> 00:57:38,489
and then the proper preconditions to use

1282
00:57:38,489 --> 00:57:39,830
are learned at run time.

1283
00:57:39,830 --> 00:57:42,191
So you basically specify a reward function

1284
00:57:42,191 --> 00:57:45,032
and then a policy is developed as an agent runs

1285
00:57:45,032 --> 00:57:46,533
in order to figure out when to perform

1286
00:57:46,533 --> 00:57:47,793
those different actions.

1287
00:57:47,793 --> 00:57:49,434
So this would be complicated to do with something,

1288
00:57:49,434 --> 00:57:51,635
the scale of StarCraft, but if you have

1289
00:57:51,635 --> 00:57:52,836
a much more refined environment,

1290
00:57:52,836 --> 00:57:54,816
it's a really cool approach to use.

1291
00:57:56,656 --> 00:57:58,438
I hope you've learned a lot about behavior trees today.

1292
00:57:58,438 --> 00:58:00,760
We talked about node decorators,

1293
00:58:00,760 --> 00:58:02,542
we've talked about some best practices

1294
00:58:02,542 --> 00:58:04,804
and some extension to behavior trees.

1295
00:58:04,804 --> 00:58:06,305
They're a powerful tool for authoring

1296
00:58:06,305 --> 00:58:10,249
and can be applied to a variety of different situations.

1297
00:58:10,249 --> 00:58:10,429
Thanks.

1298
00:58:10,429 --> 00:58:20,039
Thank you.

