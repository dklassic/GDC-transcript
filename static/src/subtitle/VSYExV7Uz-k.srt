1
00:00:05,823 --> 00:00:10,346
So in the next 30 minutes, I will talk about why building a UI framework can be beneficial

2
00:00:10,346 --> 00:00:16,390
for multiple teams, a project's company, how to approach, the overview of our main UI framework

3
00:00:16,390 --> 00:00:18,331
components, and about benefits.

4
00:00:18,331 --> 00:00:21,433
But first, I would like to make just a quick introduction.

5
00:00:21,433 --> 00:00:26,616
My name is Natalia Rybrova, and I started my career as a UI designer in games around

6
00:00:26,616 --> 00:00:28,777
nine years ago working on the AAA project.

7
00:00:28,777 --> 00:00:34,461
But after that, I was mainly focused on creating free-to-play mobile games in different genres.

8
00:00:35,328 --> 00:00:37,788
And right now, I'm a UI UX designer at Cyber Games.

9
00:00:37,788 --> 00:00:41,929
But when I joined the company around three years ago,

10
00:00:41,929 --> 00:00:45,570
we were only 40 employees and had a lot of ambitions to grow.

11
00:00:45,570 --> 00:00:46,310
Right now, we are more than 100.

12
00:00:46,310 --> 00:00:48,691
We have multiple independent teams

13
00:00:48,691 --> 00:00:50,612
working on different projects.

14
00:00:50,612 --> 00:00:52,352
But during that intensive growth,

15
00:00:52,352 --> 00:00:53,932
it was very important to restructure

16
00:00:53,932 --> 00:00:57,913
the process of the UI development

17
00:00:57,913 --> 00:00:58,693
and make it more effective.

18
00:00:58,693 --> 00:01:01,154
So why build a UI framework?

19
00:01:03,680 --> 00:01:06,543
Several years ago, front-end frameworks for web development

20
00:01:06,543 --> 00:01:07,524
became very popular.

21
00:01:07,524 --> 00:01:11,007
And the accessibility of HTML, CSS, and Java

22
00:01:11,007 --> 00:01:13,189
combined together with the software

23
00:01:13,189 --> 00:01:16,172
that allowed designers to turn their mockups into code

24
00:01:16,172 --> 00:01:18,835
led them focused on creating unified design systems

25
00:01:18,835 --> 00:01:21,077
and design itself rather than on implementation.

26
00:01:21,077 --> 00:01:23,460
And it was a pretty big step forward.

27
00:01:24,325 --> 00:01:26,246
But if we're talking about games built in Unity,

28
00:01:26,246 --> 00:01:28,647
the situation is a little bit different.

29
00:01:28,647 --> 00:01:30,967
Unity UI system has never been perfect,

30
00:01:30,967 --> 00:01:33,948
and it requires to know a programming language like C

31
00:01:33,948 --> 00:01:34,968
Sharp for advanced use.

32
00:01:34,968 --> 00:01:37,869
And C Sharp is much more complex than HTML.

33
00:01:37,869 --> 00:01:42,150
And the third-party solutions, like solutions

34
00:01:42,150 --> 00:01:45,191
you can find maybe in Unity as a store,

35
00:01:45,191 --> 00:01:48,252
are usually not well supported or poorly adopted for mobiles.

36
00:01:49,513 --> 00:01:52,456
And of course, some of you can argue and say,

37
00:01:52,456 --> 00:01:55,559
sure, there are still a lot of games that use Unity UI,

38
00:01:55,559 --> 00:01:57,240
so why wasn't it enough for us?

39
00:01:57,240 --> 00:01:58,962
And we had two main reasons for it.

40
00:01:58,962 --> 00:02:01,905
And the first reason was that designers

41
00:02:01,905 --> 00:02:04,767
didn't have enough control over the implementation.

42
00:02:04,767 --> 00:02:09,291
And this is a simplified version of the pipeline

43
00:02:09,291 --> 00:02:10,392
we had before the UI framework.

44
00:02:10,958 --> 00:02:15,782
And the implementation part, as you see, completely belonged to engineers, mostly because of the

45
00:02:15,782 --> 00:02:22,047
complexity, and it made the process of redesigning and iterating very slow and demanding.

46
00:02:22,047 --> 00:02:28,753
And because designers didn't have enough control, it sometimes led to a static and interaction

47
00:02:28,753 --> 00:02:32,095
inconsistency, and especially closer to deadlines.

48
00:02:32,095 --> 00:02:38,260
And we also didn't have good technical solutions that were unified across the projects.

49
00:02:39,967 --> 00:02:43,948
And so the second reason was that very often multiple teams

50
00:02:43,948 --> 00:02:47,330
had to solve similar problems implementing in developing UI.

51
00:02:47,330 --> 00:02:51,111
And designs and technical solutions varied,

52
00:02:51,111 --> 00:02:53,352
and there was no consistency across the projects.

53
00:02:53,352 --> 00:02:56,453
And you know when it happens, player experience suffers,

54
00:02:56,453 --> 00:02:58,094
and so does the company's brand.

55
00:02:59,281 --> 00:03:01,562
And besides, it was also very time consuming.

56
00:03:01,562 --> 00:03:03,882
It was very difficult to maintain.

57
00:03:03,882 --> 00:03:08,504
And teams were less flexible because simply people

58
00:03:08,504 --> 00:03:09,864
had different set of skills.

59
00:03:09,864 --> 00:03:12,505
And problems were solved differently.

60
00:03:12,505 --> 00:03:15,486
And knowledge sharing is something

61
00:03:15,486 --> 00:03:18,327
that happened that permanently in the companies.

62
00:03:18,327 --> 00:03:21,988
And so back then, we tried different approaches,

63
00:03:21,988 --> 00:03:24,288
like making UI kits, writing specifications,

64
00:03:24,288 --> 00:03:26,069
making guidelines.

65
00:03:26,804 --> 00:03:33,346
And the problem was that all those solutions were static deliverables that nobody wanted to

66
00:03:33,346 --> 00:03:37,988
use. And it was also inconvenient to use and maintain them up to date with limited

67
00:03:37,988 --> 00:03:42,509
resources. And it also required a lot of communications between designers and engineers.

68
00:03:43,484 --> 00:03:46,845
And so the third party solutions that improved collaborations

69
00:03:46,845 --> 00:03:49,346
between also designers and engineers,

70
00:03:49,346 --> 00:03:52,326
like for example Zeppelin that used web design,

71
00:03:52,326 --> 00:03:55,107
were just expensive and also were not perfect

72
00:03:55,107 --> 00:03:57,608
because required some communication

73
00:03:57,608 --> 00:03:59,368
between designers and engineers.

74
00:03:59,368 --> 00:04:02,549
But however, we already knew one thing,

75
00:04:02,549 --> 00:04:04,890
that if you could make an accurate

76
00:04:04,890 --> 00:04:07,130
and reusable implementation once,

77
00:04:07,130 --> 00:04:09,611
we were much more confident in the design quality.

78
00:04:09,978 --> 00:04:13,959
And it was also very easy to maintain it from one place and then share it across the

79
00:04:13,959 --> 00:04:21,042
projects. And so that's why to unify our UI on implementation level, we started to build our own

80
00:04:21,042 --> 00:04:25,543
UI framework. How to approach. So the first step for us was to define principles and

81
00:04:25,543 --> 00:04:32,926
components we wanted to reuse across the projects. And the initial idea is based on atomic

82
00:04:32,926 --> 00:04:38,188
design approach. And then build our application. At this time, we found it was very important

83
00:04:38,530 --> 00:04:43,573
where like, it considers UI as a set of elements and behavioral patterns, and I assume most

84
00:04:43,573 --> 00:04:49,235
of you are pretty familiar with the concept where basic building blocks, like atoms, like

85
00:04:49,235 --> 00:04:54,418
buttons, labels, transitions, even color palettes, can be combined into more complex

86
00:04:54,418 --> 00:04:59,900
components, like molecules that can be combined into organisms, and organisms can be

87
00:04:59,900 --> 00:05:05,843
grouped into screens that provide context. And since the UI framework we built was

88
00:05:07,571 --> 00:05:10,593
meant to support multiple projects.

89
00:05:10,593 --> 00:05:14,076
It consists of technologically unified components

90
00:05:14,076 --> 00:05:16,598
that can be skinned and combined into templates

91
00:05:16,598 --> 00:05:18,860
that can be then combined into screens,

92
00:05:18,860 --> 00:05:21,622
and reusable behavioral patterns and transitions.

93
00:05:21,622 --> 00:05:25,906
And visual language was intentionally excluded

94
00:05:25,906 --> 00:05:28,048
and moved to a lower project-based level

95
00:05:28,048 --> 00:05:30,469
because we wanted not just to create a UI system

96
00:05:30,469 --> 00:05:32,631
for a specific project, but a universal tool

97
00:05:32,631 --> 00:05:35,474
that would allow us to create UI system

98
00:05:35,474 --> 00:05:36,895
for any project, saving time.

99
00:05:37,593 --> 00:05:42,599
And so after we had defined these principles and components, we built them as a

100
00:05:42,599 --> 00:05:47,485
prefabs with a hierarchy that made sense for the desirable functionality with the

101
00:05:47,485 --> 00:05:53,212
minimum hierarchy. And we actually had to rebuild most of the basic uh components

102
00:05:53,212 --> 00:05:55,715
that were already present in Unity UI.

103
00:05:56,772 --> 00:06:01,674
And we actually had to do it because even though UI framework expands Unity UI,

104
00:06:01,674 --> 00:06:04,654
some of the components were not just suitable for us.

105
00:06:04,654 --> 00:06:08,996
And the main reason was because they were not adapted for mobile.

106
00:06:08,996 --> 00:06:15,697
And in some complex cases, Unity UI requires programming knowledge for advanced use.

107
00:06:15,697 --> 00:06:19,058
And just to illustrate, I would like to show you as an example

108
00:06:19,058 --> 00:06:23,680
one of the simplest UI framework components, like the button.

109
00:06:24,771 --> 00:06:30,293
and it has an improved structure for providing feedback and it also has more of a hierarchy.

110
00:06:30,293 --> 00:06:36,695
And one of the biggest differences that we have is that the framework button has a hit

111
00:06:36,695 --> 00:06:42,538
box child object that basically is invisible image that defines the interaction area for

112
00:06:42,538 --> 00:06:42,998
the button.

113
00:06:43,760 --> 00:06:49,363
And it's placed above the animated part, it's placed above the graphics so it prevents the

114
00:06:49,363 --> 00:06:52,404
situation of click not being registered in two cases.

115
00:06:52,404 --> 00:06:58,688
When we interact with the small size elements in mobile or when due to scaling during the

116
00:06:58,688 --> 00:07:04,071
animation for example in the press state when these small elements can become even smaller.

117
00:07:04,938 --> 00:07:11,182
And just to show you, so you can see at the top you can see the Unity button and the Unity

118
00:07:11,182 --> 00:07:14,224
Collider scales together with the Unity button when I press it.

119
00:07:14,224 --> 00:07:20,288
And at the bottom there is a framework button and I have a selected hitbox and it stays

120
00:07:20,288 --> 00:07:28,073
the same so even I press it, it still defines the interactable area for the button and it's

121
00:07:28,073 --> 00:07:28,213
the same.

122
00:07:28,213 --> 00:07:34,277
And so framework buttons use only animators for providing feedback.

123
00:07:35,177 --> 00:07:38,697
So we don't have an option like unity button

124
00:07:38,697 --> 00:07:42,158
that provides like simple feedback like tink-tink as pride.

125
00:07:42,158 --> 00:07:44,999
But it's mainly because using animators

126
00:07:44,999 --> 00:07:48,500
we can actually create any type of feedback we need

127
00:07:48,500 --> 00:07:51,281
and plus it's very easy to reuse animators

128
00:07:51,281 --> 00:07:54,982
across the components with the desirable behavior.

129
00:07:54,982 --> 00:08:00,083
And so the template we use for like framework button

130
00:08:00,083 --> 00:08:02,484
has an improved also animator state machine

131
00:08:02,484 --> 00:08:04,124
that can be easily copied and adjusted.

132
00:08:04,955 --> 00:08:10,839
and we improved some transition times and we also added a release non-click state for

133
00:08:10,839 --> 00:08:16,883
our buttons and we completely excluded hover state which only caused problems on mobile.

134
00:08:16,883 --> 00:08:26,649
Other components like radio groups, tabs, toggles, progress bars, they all had gone

135
00:08:26,649 --> 00:08:33,714
from the same rework process and combined and composed a library of the template assets.

136
00:08:34,837 --> 00:08:39,519
There, we of course have some special components we developed specifically for the UI

137
00:08:39,519 --> 00:08:43,861
framework like view config and transition config. I will return a little bit later. But

138
00:08:43,861 --> 00:08:50,623
instantiated this templates can be skinned, animated and extended, extended according to

139
00:08:50,623 --> 00:08:56,126
specific project style. And then they can be added to a specific project style library

140
00:08:56,126 --> 00:09:00,407
which is like very custom. We call skin assets and uh.

141
00:09:01,932 --> 00:09:07,537
The name may be not the perfect one because in SkinnyAssets.org also can be included some

142
00:09:07,537 --> 00:09:12,682
components, for example, like combinations of components with a specific anchoring or

143
00:09:12,682 --> 00:09:15,084
hierarchy for different project needs.

144
00:09:15,084 --> 00:09:19,628
And so it's very easy to instantiate them with one click from a specific window.

145
00:09:21,142 --> 00:09:27,043
And to show an example how we use it, I just want to show you a little video.

146
00:09:27,043 --> 00:09:31,965
It's not a real game, I just made this case specifically for this talk.

147
00:09:31,965 --> 00:09:38,446
And so I have a press of a pop-up and I want to fill it with the skin assets and here I

148
00:09:38,446 --> 00:09:45,568
just add some list item, like two, and then I want to, for example, to add a button, just

149
00:09:45,568 --> 00:09:46,528
adjust the position.

150
00:09:48,075 --> 00:09:50,978
And basically, you can see how just in a second,

151
00:09:50,978 --> 00:09:57,687
I can create a variation of a pop-up using this window

152
00:09:57,687 --> 00:10:00,571
without going anywhere and looking for anything else.

153
00:10:00,571 --> 00:10:03,534
I can, of course, also adjust some sprites or text.

154
00:10:03,876 --> 00:10:10,720
And we know and we expect this to become obsolete after we start to use nested prefabs, but

155
00:10:10,720 --> 00:10:17,143
we built the UI framework even before nested prefabs were announced last summer, so we

156
00:10:17,143 --> 00:10:19,604
were pretty much satisfied with the solution.

157
00:10:19,604 --> 00:10:22,206
So yeah, it was fine so far.

158
00:10:22,206 --> 00:10:31,371
And the second reason, the second step in building the UI framework for us was to provide

159
00:10:31,371 --> 00:10:32,651
freedom for non-engineers.

160
00:10:33,843 --> 00:10:38,506
And it's actually one of the main benefits of the UI framework because right now designers

161
00:10:38,506 --> 00:10:44,971
can implement UI without a big necessity to code. And it significantly reduces the

162
00:10:44,971 --> 00:10:49,995
iteration time between designers and engineers and also designers get much more involved in

163
00:10:49,995 --> 00:10:51,676
the implementation process.

164
00:10:52,513 --> 00:10:57,655
And the use right now help from engineers only to create complex transitions or just

165
00:10:57,655 --> 00:10:59,476
when we need to work with data.

166
00:10:59,476 --> 00:11:05,259
But even though we right now also work on some solutions where designers also can start

167
00:11:05,259 --> 00:11:06,260
to work with data.

168
00:11:06,260 --> 00:11:12,363
And it's much more easier for them to start testing the aesthetics and it happens much

169
00:11:12,363 --> 00:11:13,443
earlier in the process.

170
00:11:14,917 --> 00:11:20,939
And very important to say that it only became possible

171
00:11:20,939 --> 00:11:25,201
after we gave designers freedom to work

172
00:11:25,201 --> 00:11:25,921
with two main complex areas.

173
00:11:25,921 --> 00:11:28,483
And these are navigations and transitions

174
00:11:28,483 --> 00:11:31,804
between the screens and controlling the rendering

175
00:11:31,804 --> 00:11:34,305
order of multiple layers, including 3D.

176
00:11:34,305 --> 00:11:37,747
Because let's be honest, just to add some sprites

177
00:11:37,747 --> 00:11:40,548
in the projects and make layouts in Unity.

178
00:11:40,938 --> 00:11:45,839
It's not that difficult for designers, but if we're talking about creating transitions

179
00:11:45,839 --> 00:11:49,780
and flows, this is where things get difficult.

180
00:11:49,780 --> 00:11:56,502
And to dive into the details, I would like to present one of our main components in the

181
00:11:56,502 --> 00:11:58,602
UI framework, the slice.

182
00:11:58,602 --> 00:12:04,084
And so slices serve as containers of canvases, graphics, and cameras.

183
00:12:05,005 --> 00:12:07,585
And a slice can be built as an entire screen,

184
00:12:07,585 --> 00:12:11,607
like loading screen or 3D model,

185
00:12:11,607 --> 00:12:15,028
or they can be built as a part of the screen,

186
00:12:15,028 --> 00:12:17,568
like for example, pop-up or top bar

187
00:12:17,568 --> 00:12:18,969
or bottom navigation bar, and so on.

188
00:12:18,969 --> 00:12:22,970
And so the framework slice template

189
00:12:22,970 --> 00:12:27,731
consists of a root object with three million children,

190
00:12:27,731 --> 00:12:32,433
and those are cameras, graphics, and animation targets.

191
00:12:32,433 --> 00:12:33,233
And let's take a close look.

192
00:12:34,490 --> 00:12:40,294
cameras. So the Slice template comes with one autographic camera per default. It's

193
00:12:40,294 --> 00:12:46,218
because it's most commonly used cameras for 2D graphics if of course we assume that we

194
00:12:46,218 --> 00:12:52,142
have our UI's 2D. And we can add as many cameras as we want, but if it serves a purpose,

195
00:12:52,142 --> 00:12:58,767
but of course we should be mindful about the performance. And the usual case where we

196
00:12:58,767 --> 00:13:01,249
need multiple cameras can be when we need to

197
00:13:02,630 --> 00:13:10,116
render both 2D and 3D, and so we can use orthographic and perspective cameras accordingly.

198
00:13:10,116 --> 00:13:16,301
And so, added cameras, they just got automatically referenced in the field we called camera list.

199
00:13:16,301 --> 00:13:21,606
And the order of the cameras determines the rendering order.

200
00:13:21,606 --> 00:13:28,972
And where this, like, last camera is rendered topmost and was pretty much inspired by Unity

201
00:13:28,972 --> 00:13:30,633
render order, Unity UI.

202
00:13:32,060 --> 00:13:36,905
And so at the end, we can easily build multiple layers,

203
00:13:36,905 --> 00:13:40,889
operate with them, and correctly build a hierarchy

204
00:13:40,889 --> 00:13:42,271
just in a short period of time.

205
00:13:42,271 --> 00:13:45,294
And if I want to change the order of the cameras,

206
00:13:45,294 --> 00:13:47,777
I just don't need to operate with any values.

207
00:13:47,777 --> 00:13:51,501
I just need to drag the camera I want to render topmost

208
00:13:51,501 --> 00:13:54,684
at the bottom of the camera list, and that's it.

209
00:13:55,769 --> 00:14:00,412
neat and designers really like to work with it where they don't need to

210
00:14:00,412 --> 00:14:02,254
Assign any like camera depth and so on

211
00:14:02,254 --> 00:14:06,837
Graphics acts as a parents for all the graphics contained in the slice and

212
00:14:06,837 --> 00:14:11,201
the children of the graphics expect to be canvases and

213
00:14:11,201 --> 00:14:21,769
Because what is where the 2d gets rendered and the children on the canvases expected to be slice panels

214
00:14:21,769 --> 00:14:22,529
And this is another

215
00:14:23,417 --> 00:14:27,259
UI framework component, which is very important for us,

216
00:14:27,259 --> 00:14:29,520
because slice parents, they of course,

217
00:14:29,520 --> 00:14:32,401
parents of graphics assets for our slice,

218
00:14:32,401 --> 00:14:36,243
and they are also very similar to your generic Unity panel,

219
00:14:36,243 --> 00:14:39,365
but it has an added component that allows us

220
00:14:39,365 --> 00:14:42,826
to associate this panel with a specific animation target.

221
00:14:42,826 --> 00:14:48,229
And animation targets is actually our favorite feature

222
00:14:48,229 --> 00:14:51,391
that we developed for this UI framework,

223
00:14:51,391 --> 00:14:52,791
because animation target.

224
00:14:54,029 --> 00:14:56,951
they propagate animations for our slice panels.

225
00:14:56,951 --> 00:15:00,914
And this is the way for us to reuse animations

226
00:15:00,914 --> 00:15:03,796
across all slice panels in our projects,

227
00:15:03,796 --> 00:15:06,418
independent of amount of children and naming.

228
00:15:06,418 --> 00:15:10,661
And if you have ever worked with a Unity animation system,

229
00:15:10,661 --> 00:15:13,083
you probably know how painful it can be

230
00:15:13,083 --> 00:15:15,584
to be tied to a specific naming

231
00:15:15,584 --> 00:15:18,647
if you want to reuse an animation.

232
00:15:20,109 --> 00:15:24,910
Right now it's possible because it's basically an obstruction layer that allows us to reuse

233
00:15:24,910 --> 00:15:29,572
animations because we are assigning just an animation target type to a specific panel.

234
00:15:29,572 --> 00:15:36,054
So we don't care what's underneath it, we don't care how it calls, but we just assign

235
00:15:36,054 --> 00:15:36,834
the type.

236
00:15:36,834 --> 00:15:43,216
And I would like, of course, to go into more details, but I would need a longer presentation,

237
00:15:43,216 --> 00:15:44,316
so let's move on.

238
00:15:45,057 --> 00:15:52,481
So, to assign and execute these animations, we need to use our slice somewhere. And for that

239
00:15:52,481 --> 00:15:58,684
purpose, the UI framework has another component we called view config. And this is basically a

240
00:15:58,684 --> 00:16:05,327
recipe for our UI system about how to build and present a view or if you can, you can call it a

241
00:16:05,327 --> 00:16:12,551
screen. And so, we need to fill in the information the system needs to know about how to build

242
00:16:12,551 --> 00:16:13,532
this view correctly.

243
00:16:14,572 --> 00:16:18,114
And a view config can include one or multiple slices.

244
00:16:18,114 --> 00:16:22,017
It has to have at least one slice.

245
00:16:22,017 --> 00:16:25,219
And slices also can be shared across the views.

246
00:16:25,219 --> 00:16:30,122
And again, the rendering order defined by order,

247
00:16:30,122 --> 00:16:33,564
like where I add my slices in this view config.

248
00:16:33,564 --> 00:16:36,366
And it's also very easy to manipulate

249
00:16:36,366 --> 00:16:38,747
with this view in run time.

250
00:16:38,747 --> 00:16:41,369
So to illustrate, I have another small example.

251
00:16:43,229 --> 00:16:46,451
So here I have a view config that I called inventory screen,

252
00:16:46,451 --> 00:16:51,934
and please notice it doesn't have a top bar here.

253
00:16:51,934 --> 00:16:55,977
And what I need to do is just like in the inspector,

254
00:16:55,977 --> 00:16:59,959
I just need to add another slice, I need to reference it.

255
00:16:59,959 --> 00:17:03,561
So let's say it's top bar, it's the same top bar

256
00:17:03,561 --> 00:17:05,022
I have in the character screen.

257
00:17:05,022 --> 00:17:09,965
And it immediately added this top bar

258
00:17:09,965 --> 00:17:12,547
in the inventory screen view.

259
00:17:14,310 --> 00:17:23,385
So it's pretty easy, it's very fast, and it literally takes seconds and I can do it one time.

260
00:17:23,385 --> 00:17:27,653
So I can reshuffle all my small pieces of my UI and create different combinations.

261
00:17:28,624 --> 00:17:32,545
So the benefits are the redesign and iterations right now

262
00:17:32,545 --> 00:17:34,445
are very fast.

263
00:17:34,445 --> 00:17:37,946
And once I broke down my UI into small pieces

264
00:17:37,946 --> 00:17:41,687
and assembled them, I can combine different setups

265
00:17:41,687 --> 00:17:43,628
and it's just a matter of seconds.

266
00:17:43,628 --> 00:17:47,549
And the render order of the slices in the view config

267
00:17:47,549 --> 00:17:48,949
defines the rendering order.

268
00:17:49,799 --> 00:17:53,462
And it's also very easy to show or hide previous views.

269
00:17:53,462 --> 00:17:55,923
It's just a matter of ticking the checkbox.

270
00:17:55,923 --> 00:18:00,526
So if I want to hide the previous view behind the pop-up

271
00:18:00,526 --> 00:18:02,628
I just opened, I can just easily do it.

272
00:18:02,628 --> 00:18:06,530
And after we have defined the view,

273
00:18:06,530 --> 00:18:11,273
the UI system knows what to show, but it doesn't know how.

274
00:18:11,273 --> 00:18:13,575
I mean, in the previous example it already knew how,

275
00:18:13,575 --> 00:18:16,857
but for knowing how it needs another component

276
00:18:16,857 --> 00:18:18,538
that we call transition config.

277
00:18:19,516 --> 00:18:23,019
And the UI framework provides transition examples

278
00:18:23,019 --> 00:18:28,484
for different configurations, like sliding, scaling.

279
00:18:28,484 --> 00:18:31,327
It can be instant transitions, or it can be absolutely

280
00:18:31,327 --> 00:18:32,988
custom animation.

281
00:18:32,988 --> 00:18:36,852
And after that, all these transitions

282
00:18:36,852 --> 00:18:40,555
can be copied, adjusted, and they can easily

283
00:18:40,555 --> 00:18:42,837
be assigned for every view config.

284
00:18:44,875 --> 00:18:51,041
And uh, so to show this also a small example how we use transition configs.

285
00:18:51,041 --> 00:18:55,926
So here I have a popup settings which has an animator popup transition config.

286
00:18:56,894 --> 00:19:01,856
And it looks like this, so you see the background fading,

287
00:19:01,856 --> 00:19:04,136
like pop-up is scaling.

288
00:19:04,136 --> 00:19:05,957
And what I want to do is just change it

289
00:19:05,957 --> 00:19:09,898
to the slide right transition config that I created before,

290
00:19:09,898 --> 00:19:11,759
like both hiding and showing.

291
00:19:11,759 --> 00:19:15,660
And as you can see, immediately will apply the changes.

292
00:19:19,826 --> 00:19:26,569
So, the benefits of the transition config, so the main one is that it operates with a

293
00:19:26,569 --> 00:19:32,392
whole slice panel through the animation target, which is again an obstruction layer that allows

294
00:19:32,392 --> 00:19:39,055
us to reuse animations across all slice panels without depending on object naming.

295
00:19:40,364 --> 00:19:47,091
They can be also reused not only across the views, but also can be reused across the projects.

296
00:19:47,091 --> 00:19:53,898
So if we work with multiple projects that want to reuse the specific transition between

297
00:19:53,898 --> 00:19:57,682
the screens, we can easily do it without redoing it again and again.

298
00:19:58,823 --> 00:20:05,388
and it allow us to create different combinations of animations for multiple slice panels in one slice

299
00:20:05,388 --> 00:20:12,213
so as you saw before I had like a combination of a background that just was fading

300
00:20:12,213 --> 00:20:19,319
and the pop-up content was scaling and it's possible because I just broke down my content

301
00:20:19,319 --> 00:20:23,642
to two slice panels which has two different animation target types.

302
00:20:25,055 --> 00:20:33,021
And so right now I just would like to show you how we execute animations or navigations

303
00:20:33,021 --> 00:20:41,747
using the UI framework because I mentioned that it's very easy just to create flows.

304
00:20:41,747 --> 00:20:43,789
And this is also just a small example.

305
00:20:43,789 --> 00:20:50,774
So now I'm just running a project and I have a starting prefab where I can assign my starting

306
00:20:50,774 --> 00:20:53,156
view and right now it's a splash screen.

307
00:20:54,057 --> 00:21:01,839
kind of a splash screen. I can use any. And as you can see, this has a view has a button,

308
00:21:01,839 --> 00:21:07,961
start button. Right now it does nothing. But let's assume I would like to execute navigation

309
00:21:07,961 --> 00:21:15,323
to another screen. The character. And so what I need to do is just to find this button in

310
00:21:15,323 --> 00:21:18,263
the hierarchy. And I need to add one navigation script.

311
00:21:20,138 --> 00:21:28,941
and then I will have a field with animation target, this I'm adding a view I want to navigate,

312
00:21:28,941 --> 00:21:38,885
it's like GTC start view, and then I just need to add a function, navigation, execute

313
00:21:38,885 --> 00:21:39,845
navigation.

314
00:21:39,845 --> 00:21:44,687
And that's basically it, and I didn't touch any transitions, so it will happen instantly.

315
00:21:44,687 --> 00:21:47,608
Just press apply.

316
00:21:47,608 --> 00:21:49,968
And I can operate it with any button.

317
00:21:50,919 --> 00:21:52,860
press and navigation happens.

318
00:21:53,810 --> 00:21:56,052
So as you can see, it's super fast.

319
00:21:56,052 --> 00:22:01,554
It's very easy for designers to just start create these views.

320
00:22:01,554 --> 00:22:05,577
And it's not only fast, but right now I'm

321
00:22:05,577 --> 00:22:10,659
doing the animated prototypes not using other software,

322
00:22:10,659 --> 00:22:13,981
like before I used like Principles and Sketch.

323
00:22:13,981 --> 00:22:17,143
But right now I'm just using Unity

324
00:22:17,143 --> 00:22:21,425
because it's so much easier and the result

325
00:22:21,425 --> 00:22:22,786
looks like the final result.

326
00:22:22,786 --> 00:22:23,266
And.

327
00:22:23,625 --> 00:22:32,728
Just to make a quick maybe recap, I would like to say that the UI framework is built around this concept

328
00:22:32,728 --> 00:22:35,729
of navigations between the views that reference slices.

329
00:22:35,729 --> 00:22:40,371
And navigations are requested to be done between the views.

330
00:22:40,371 --> 00:22:47,754
And views can reference one or multiple slice, and slices are responsible for containing graphics and logic.

331
00:22:47,754 --> 00:22:50,995
And in a specific case, like slice panels and animation targets.

332
00:22:52,327 --> 00:22:56,049
And slices can be included in one or multiple views,

333
00:22:56,049 --> 00:22:57,430
and they can be shared across.

334
00:22:57,430 --> 00:23:00,471
And so navigation transitions right now

335
00:23:00,471 --> 00:23:01,872
can be built by a designer,

336
00:23:01,872 --> 00:23:03,753
and once they're built,

337
00:23:03,753 --> 00:23:06,935
they can be easily reused across the views

338
00:23:06,935 --> 00:23:09,216
and also across the projects,

339
00:23:09,216 --> 00:23:11,137
and it's easy to start prototyping

340
00:23:11,137 --> 00:23:12,818
inside the project, saving time.

341
00:23:16,016 --> 00:23:16,956
technical unification.

342
00:23:16,956 --> 00:23:22,279
So interaction design principles and basic UI architecture

343
00:23:22,279 --> 00:23:25,680
is unified to maintain the holistic design,

344
00:23:25,680 --> 00:23:28,101
and is very much less time consuming

345
00:23:28,101 --> 00:23:31,042
and requires less resources to develop and to maintain.

346
00:23:31,042 --> 00:23:35,844
So we have right now like one or two dedicated engineers

347
00:23:35,844 --> 00:23:39,946
that help us to maintain the UI framework.

348
00:23:42,158 --> 00:23:44,239
It's also much easier to drive the UI innovations.

349
00:23:44,239 --> 00:23:47,641
So once a good solution is found and implemented

350
00:23:47,641 --> 00:23:50,062
in the UI framework, all the projects

351
00:23:50,062 --> 00:23:51,423
get the benefits of using it.

352
00:23:51,423 --> 00:23:53,924
And of course, in-house development

353
00:23:53,924 --> 00:23:58,226
allows us to adapt it very fast to all technical needs

354
00:23:58,226 --> 00:24:00,107
and not wait.

355
00:24:00,107 --> 00:24:02,488
Yeah, it's just really nice.

356
00:24:02,488 --> 00:24:06,270
But of course, it's very important

357
00:24:06,270 --> 00:24:08,491
to remember that building a UI framework is not just

358
00:24:08,491 --> 00:24:09,211
a silver bullet.

359
00:24:10,229 --> 00:24:12,751
We still complement it with other tools.

360
00:24:12,751 --> 00:24:17,035
And just to give you an example, we still

361
00:24:17,035 --> 00:24:20,698
use TextMeshPro stylesheets for coherent typography.

362
00:24:20,698 --> 00:24:24,240
So it's the place we control all the text styles

363
00:24:24,240 --> 00:24:25,281
for the projects.

364
00:24:25,281 --> 00:24:27,243
And we can easily adjust it, and then it

365
00:24:27,243 --> 00:24:32,427
will propagate the changes across all the text styles

366
00:24:32,427 --> 00:24:32,727
we need.

367
00:24:32,727 --> 00:24:35,169
You work with the desaturated assets

368
00:24:35,169 --> 00:24:38,692
and use Unity color library.

369
00:24:39,682 --> 00:24:42,823
and easy, very easy to adjust these color palettes

370
00:24:42,823 --> 00:24:46,984
and it will also propagate the colors across all the assets.

371
00:24:46,984 --> 00:24:49,505
Yes, with the nested prefabs it will be much easier

372
00:24:49,505 --> 00:24:51,386
and we're also waiting for it.

373
00:24:51,386 --> 00:24:54,567
And yeah, we'll also draw all our assets,

374
00:24:54,567 --> 00:24:57,328
this regarding the project style in vector

375
00:24:57,328 --> 00:24:59,368
and we are working right now

376
00:24:59,368 --> 00:25:01,569
on integrating NSVG importer to Unity.

377
00:25:02,686 --> 00:25:06,388
and to support the original assets inside the project so

378
00:25:06,388 --> 00:25:11,971
we can always have original assets inside the project and keep them up to date and

379
00:25:11,971 --> 00:25:17,335
if we need to correct something we just need to open it from Unity project and save it back.

380
00:25:18,691 --> 00:25:22,453
And we still use UI systems in Sketch,

381
00:25:22,453 --> 00:25:27,057
and we still use other software for creating prototypes,

382
00:25:27,057 --> 00:25:31,439
especially in the concepting phase.

383
00:25:31,439 --> 00:25:33,861
So there are still a lot of things

384
00:25:33,861 --> 00:25:36,243
that support our UI framework.

385
00:25:36,243 --> 00:25:38,224
And so in the end, I just want to say so.

386
00:25:39,548 --> 00:25:42,270
It doesn't matter how you build your UI framework,

387
00:25:42,270 --> 00:25:44,771
but having a living design system of components

388
00:25:44,771 --> 00:25:47,373
and interaction patterns inside the projects

389
00:25:47,373 --> 00:25:49,694
can give you a lot of benefits.

390
00:25:49,694 --> 00:25:54,516
And it's not right now for our engineers or game designers

391
00:25:54,516 --> 00:25:56,457
to start to use this UI framework

392
00:25:56,457 --> 00:25:58,999
and start creating good-looking screens,

393
00:25:58,999 --> 00:26:02,160
just opening the project, because all the guidelines

394
00:26:02,160 --> 00:26:03,901
are already inside it.

395
00:26:03,901 --> 00:26:07,083
You don't need to go and look to other guidelines

396
00:26:07,083 --> 00:26:07,783
or read documentation.

397
00:26:07,783 --> 00:26:07,863
And

398
00:26:09,602 --> 00:26:15,684
Of course, first of all, UI framework for us was a time-saving measure that allows our

399
00:26:15,684 --> 00:26:22,526
designers to focus on research, design, and testing rather than on implementation.

400
00:26:22,526 --> 00:26:23,907
And I think that's it.

401
00:26:23,907 --> 00:26:25,267
Thank you so much for listening.

402
00:26:25,267 --> 00:26:34,470
I think we have some time for Q&A, just four minutes, maybe several questions if you have.

403
00:26:44,615 --> 00:26:46,496
I have a small question, if I may.

404
00:26:46,496 --> 00:26:53,298
Could you share with us how big was the team developing

405
00:26:53,298 --> 00:26:56,279
the UI framework, or how much time did you guys

406
00:26:56,279 --> 00:26:59,040
take to develop that framework?

407
00:26:59,040 --> 00:27:04,921
Yeah, actually we had one year of one engineer's time

408
00:27:04,921 --> 00:27:08,042
that work dedicated, like work on this thing

409
00:27:08,042 --> 00:27:12,163
with the support sometimes and advice from other engineers.

410
00:27:13,730 --> 00:27:17,072
But mostly, yes, it's one engineer that helped.

411
00:27:17,072 --> 00:27:22,236
Of course, you shouldn't probably just put the UI framework on engineers

412
00:27:22,236 --> 00:27:26,558
because they don't want to work with UI usually.

413
00:27:26,558 --> 00:27:28,220
But yeah, it's not that much.

414
00:27:28,220 --> 00:27:28,680
It wasn't too bad.

415
00:27:28,680 --> 00:27:30,921
Thank you.

416
00:27:30,921 --> 00:27:31,182
Of course.

417
00:27:40,062 --> 00:27:49,607
Hi. Yes, I would like to know if you came up with the need to make debugging tools for your UI framework?

418
00:27:49,607 --> 00:28:01,794
I mean, it all happens inside the tools team, so the engineer who worked on the UI framework was a part of the tools team

419
00:28:01,794 --> 00:28:06,376
and we still have a bigger thing for our internal components.

420
00:28:08,348 --> 00:28:10,529
inside this thing?

421
00:28:10,529 --> 00:28:23,737
I mean, the question was, because if the designers and these other persons in the team who doesn't

422
00:28:23,737 --> 00:28:31,241
have the technical skill, maybe they have problems and you have to go to the programmer

423
00:28:31,241 --> 00:28:34,383
who makes the tool for support.

424
00:28:34,383 --> 00:28:36,845
I mean, if you have that kind of problems in your project.

425
00:28:37,491 --> 00:28:45,777
Now, the thing is, our teams are pretty small and we have usually one UI UX designer per team.

426
00:28:45,777 --> 00:28:48,639
So, we...

427
00:28:48,639 --> 00:28:55,204
Yeah, I mean, if something is wrong, it's very easy to communicate, so...

428
00:28:55,204 --> 00:28:59,307
I think our UI UX designers, like, test it themselves.

429
00:28:59,307 --> 00:28:59,747
Usually, yeah.

430
00:29:03,492 --> 00:29:07,053
I know that we use a similar system.

431
00:29:07,053 --> 00:29:07,393
Okay.

432
00:29:07,393 --> 00:29:09,893
But especially with transitions.

433
00:29:09,893 --> 00:29:11,014
Yeah.

434
00:29:11,014 --> 00:29:11,734
And input.

435
00:29:11,734 --> 00:29:16,355
I know there's a few, QA really love to just keep tapping things.

436
00:29:16,355 --> 00:29:19,935
So how does it know what the topmost one is?

437
00:29:19,935 --> 00:29:25,917
So if you have like the slide transition, push the button to open it and then push it

438
00:29:25,917 --> 00:29:26,497
again.

439
00:29:26,497 --> 00:29:26,857
Uh-huh.

440
00:29:26,857 --> 00:29:31,918
Is there like, like does it know what the topmost?

441
00:29:32,438 --> 00:29:38,881
So the rendering order defined by order, I placed the slices in this view list.

442
00:29:38,881 --> 00:29:42,203
So if I want to change it, I just can drag it.

443
00:29:42,203 --> 00:29:46,425
Like, it's... that's the beauty of it, because it's just super easy.

444
00:29:46,425 --> 00:29:50,266
You don't need to, like, mess with numbers or anything.

445
00:29:50,266 --> 00:29:54,268
So the UI... well, if you tap anywhere on the screen, it'll know...

446
00:29:54,998 --> 00:29:58,620
like don't interact with the screens behind?

447
00:29:58,620 --> 00:29:59,160
Yeah, yeah.

448
00:29:59,160 --> 00:29:59,320
Okay.

449
00:29:59,320 --> 00:30:00,361
Of course.

450
00:30:00,361 --> 00:30:03,142
It's just completely different view.

451
00:30:03,142 --> 00:30:06,364
So if you navigate to another view, it just open.

452
00:30:06,364 --> 00:30:10,686
We just can choose to show or to hide the previous,

453
00:30:10,686 --> 00:30:13,487
but you won't be able to interact.

454
00:30:13,487 --> 00:30:16,989
Yeah, we also like, I remember this thing.

455
00:30:17,907 --> 00:30:18,247
Hi.

456
00:30:18,247 --> 00:30:18,407
Hi.

457
00:30:18,407 --> 00:30:22,988
I was wondering, you mentioned data bindings

458
00:30:22,988 --> 00:30:26,609
and how you plan to rule out sort of remove engineers.

459
00:30:26,609 --> 00:30:27,969
Yeah, it's in the plans.

460
00:30:27,969 --> 00:30:28,649
Can you elaborate?

461
00:30:28,649 --> 00:30:30,209
Or is it still something very?

462
00:30:30,209 --> 00:30:32,570
Yeah, it's still in our plans, actually,

463
00:30:32,570 --> 00:30:36,191
because it's not something that you will.

464
00:30:36,191 --> 00:30:39,491
We're already testing it, but I wouldn't

465
00:30:39,491 --> 00:30:41,372
like go into more explanations.

466
00:30:41,372 --> 00:30:43,612
Yeah, but it's still in development right now.

467
00:30:43,612 --> 00:30:43,993
All right.

468
00:30:43,993 --> 00:30:44,193
Yeah.

469
00:30:44,193 --> 00:30:44,733
I understand.

470
00:30:44,733 --> 00:30:45,213
Thank you.

471
00:30:45,353 --> 00:30:51,178
but it's definitely will make our lives much easier. I think this was the last question. I

472
00:30:51,178 --> 00:31:00,645
think we can continue in the hall if you want. You're very welcome. Thank you so much again.

