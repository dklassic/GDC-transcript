1
00:00:06,762 --> 00:00:07,083
Thank you.

2
00:00:09,072 --> 00:00:09,354
All right.

3
00:00:09,374 --> 00:00:10,097
Let's do this.

4
00:00:10,459 --> 00:00:10,680
All right.

5
00:00:10,700 --> 00:00:11,062
Let's do this.

6
00:00:13,441 --> 00:00:14,601
All right, so hello everyone.

7
00:00:14,881 --> 00:00:15,782
Oh, my voice echoes.

8
00:00:17,742 --> 00:00:19,742
So my name is Gillian Smith, as Dave said.

9
00:00:19,983 --> 00:00:22,003
I am an assistant professor at Northeastern University,

10
00:00:22,043 --> 00:00:23,623
which is in Boston, Massachusetts.

11
00:00:23,703 --> 00:00:25,824
I'm very grateful to be here, weather isn't snow.

12
00:00:27,384 --> 00:00:29,365
And to give you a little bit of background in why it is

13
00:00:29,605 --> 00:00:32,366
and the kind of work I've been doing in content generation,

14
00:00:32,706 --> 00:00:35,046
I've been interested in procedural content generation

15
00:00:35,106 --> 00:00:36,567
as it intersects with game design

16
00:00:36,627 --> 00:00:38,467
to enable new playable experiences.

17
00:00:39,647 --> 00:00:40,808
Mixed-initiative design tools,

18
00:00:40,848 --> 00:00:42,369
which we'll be talking about in this talk.

19
00:00:43,329 --> 00:00:44,910
Recently, I've been doing a little bit of work

20
00:00:44,950 --> 00:00:46,851
looking into the history of content generation

21
00:00:46,911 --> 00:00:50,873
across games since about the mid-'60s or so.

22
00:00:52,174 --> 00:00:54,315
And the kind of games that I've generated content for

23
00:00:54,355 --> 00:00:56,716
in the past in my research have been Super Mario World,

24
00:00:57,656 --> 00:00:59,517
Western role-playing game-style levels,

25
00:00:59,697 --> 00:01:00,478
and puzzle games.

26
00:01:01,598 --> 00:01:01,878
Thanks.

27
00:01:03,039 --> 00:01:04,500
And I'm Julian Togelius.

28
00:01:05,000 --> 00:01:06,801
I'm currently at New York University.

29
00:01:08,298 --> 00:01:12,240
I've been doing various kinds of things in procedural congeneration.

30
00:01:12,260 --> 00:01:19,523
I started out with trying to figure out how to control, use evolutionary algorithms to control game characters.

31
00:01:19,563 --> 00:01:21,384
And I was like, hey, why not turn it around?

32
00:01:21,604 --> 00:01:24,586
Why not, you know, come up with the levels and stuff instead?

33
00:01:25,411 --> 00:01:30,877
So, I've been using lots of different methods, typically from the biologically inspired,

34
00:01:31,297 --> 00:01:38,706
statistical and similar non-symbolic realms to do content generation in various games,

35
00:01:38,746 --> 00:01:42,471
including racing games, Super Mario Bros., StarCraft, etc.

36
00:01:45,599 --> 00:01:50,181
So this is kind of the whirlwind tour of procedural content generation.

37
00:01:50,881 --> 00:01:53,243
So we're going to be talking about four main things today.

38
00:01:53,923 --> 00:01:58,325
The first is giving a very high-level overview of different technical approaches and algorithms

39
00:01:58,365 --> 00:02:03,588
that you can use for content generation, specifically looking at what we're calling gameplay-oriented

40
00:02:03,628 --> 00:02:04,008
PCG.

41
00:02:05,009 --> 00:02:06,951
A lot of procedural content generation

42
00:02:07,031 --> 00:02:08,132
that you may have seen from, like,

43
00:02:08,152 --> 00:02:09,453
the computer graphics community

44
00:02:09,493 --> 00:02:12,937
would be for procedural textures or, like, height maps

45
00:02:13,377 --> 00:02:15,360
or procedural flame effects.

46
00:02:15,780 --> 00:02:16,761
We're really more interested

47
00:02:16,801 --> 00:02:19,404
in the kind of procedural content generation

48
00:02:19,424 --> 00:02:23,248
that's for content that players will really deeply interact with

49
00:02:23,388 --> 00:02:25,230
and form part of the gameplay experience.

50
00:02:27,152 --> 00:02:29,132
After giving this sort of very high-level overview

51
00:02:29,172 --> 00:02:32,293
of algorithms, we'll talk about sort of practical advice

52
00:02:32,313 --> 00:02:34,674
for if you want to put content generation into your game,

53
00:02:34,974 --> 00:02:36,695
what are some of the things you might want to think about,

54
00:02:37,575 --> 00:02:40,096
talk about using PCG to actually help designers,

55
00:02:40,116 --> 00:02:41,417
not just replace designers,

56
00:02:42,437 --> 00:02:45,458
and then end with sort of a very, again, high-level overview

57
00:02:45,498 --> 00:02:47,579
of different debugging and visualization strategies

58
00:02:47,619 --> 00:02:48,399
you might want to use.

59
00:02:50,087 --> 00:02:53,029
I think the key theme across all of this presentation

60
00:02:53,049 --> 00:02:54,810
is that there's no magic bullet.

61
00:02:55,410 --> 00:02:56,571
We all know this, right?

62
00:02:56,591 --> 00:02:58,973
There's a lot of different algorithms you can use for this,

63
00:02:59,393 --> 00:03:00,314
and they've got trade-offs.

64
00:03:00,614 --> 00:03:02,555
And so the goal that we have with this presentation

65
00:03:02,615 --> 00:03:05,297
is to try to make those trade-offs a little more clear.

66
00:03:05,877 --> 00:03:07,578
We're not gonna be here and tell you like,

67
00:03:07,638 --> 00:03:10,240
grammars, those are the best way to generate content

68
00:03:10,300 --> 00:03:11,541
in the one true way, right?

69
00:03:11,761 --> 00:03:12,762
They're good for some things

70
00:03:12,822 --> 00:03:14,063
and not as good for other things.

71
00:03:16,485 --> 00:03:19,789
So with that, let's dive in a little bit to some of the,

72
00:03:19,889 --> 00:03:22,711
we've identified sort of four high level approaches

73
00:03:22,751 --> 00:03:24,473
that people can use for content generation.

74
00:03:25,254 --> 00:03:28,176
Talk about what they are and what some of the trade-offs

75
00:03:28,297 --> 00:03:30,118
are in terms of what they're good at and bad at.

76
00:03:32,289 --> 00:03:35,351
So the first method that, or set of methods

77
00:03:35,432 --> 00:03:37,193
that we can think about are what we're calling

78
00:03:37,253 --> 00:03:38,274
constructive methods.

79
00:03:39,215 --> 00:03:42,037
So these are typically very ad hoc methods

80
00:03:42,417 --> 00:03:44,719
where you might piece together large building blocks

81
00:03:44,759 --> 00:03:45,380
of content.

82
00:03:46,180 --> 00:03:47,902
Spelunky is a really good example

83
00:03:49,023 --> 00:03:52,105
of a system that uses a kind of constructive method.

84
00:03:52,205 --> 00:03:54,747
There's pre-designed by humans, tiles.

85
00:03:55,268 --> 00:03:56,729
that get placed next to each other,

86
00:03:56,749 --> 00:03:59,751
and then a second pass in the algorithm goes through

87
00:03:59,791 --> 00:04:01,833
and decorates all of those tiles

88
00:04:02,733 --> 00:04:05,095
with loot and enemies and so on.

89
00:04:05,135 --> 00:04:08,097
And Darius Kazemi has a really great blog post online

90
00:04:08,678 --> 00:04:09,719
that should be pretty Googleable

91
00:04:10,619 --> 00:04:12,000
that talks about specifically how

92
00:04:12,040 --> 00:04:14,102
the Spelunky level generation algorithm works.

93
00:04:16,038 --> 00:04:17,819
Really, constructive methods are about

94
00:04:17,859 --> 00:04:20,400
sort of directing randomness, right?

95
00:04:20,440 --> 00:04:23,561
So you could just place a call to a random number generator

96
00:04:23,881 --> 00:04:25,021
and get a bunch of random stuff

97
00:04:25,041 --> 00:04:26,161
that shows up on your screen.

98
00:04:27,122 --> 00:04:30,943
So we try a few different ways to try to influence

99
00:04:30,983 --> 00:04:32,683
that random number generator to give something

100
00:04:32,703 --> 00:04:34,264
that feels a bit more designally

101
00:04:34,924 --> 00:04:36,144
than just being like at the mercy

102
00:04:36,184 --> 00:04:37,425
of your random number generator.

103
00:04:38,025 --> 00:04:39,305
So these can include things like

104
00:04:39,946 --> 00:04:42,126
paying careful attention to your knowledge representation

105
00:04:42,166 --> 00:04:42,846
and using very,

106
00:04:43,347 --> 00:04:45,868
carefully crafted blocks that fit together nicely,

107
00:04:46,829 --> 00:04:48,489
altering your random number distribution

108
00:04:48,509 --> 00:04:50,671
so you're not just pulling from a uniform distribution,

109
00:04:51,411 --> 00:04:52,211
and lookup tables.

110
00:04:52,692 --> 00:04:55,093
And sort of my tagline for constructive methods is like,

111
00:04:55,133 --> 00:04:57,254
we want to hack something together that works, right?

112
00:04:57,574 --> 00:05:00,476
And it'll probably only work for this game and nothing else,

113
00:05:00,976 --> 00:05:03,117
but like, let's just get something working.

114
00:05:04,658 --> 00:05:09,281
What's really nice about a constructive approach is that it's typically very lightweight algorithmically.

115
00:05:09,661 --> 00:05:12,403
Sort of like a few calls to a random number generator and you're done.

116
00:05:14,104 --> 00:05:22,268
It puts more sort of burden onto designers and artists and level designers to be able to design your modular content that's going to go together though, right?

117
00:05:22,308 --> 00:05:29,133
Which can be a lot if you need to suddenly think about like all possible pairs of all possible tile sets, like what's going to happen.

118
00:05:30,885 --> 00:05:34,228
It's pretty customized to the designs, it's not very extensible.

119
00:05:36,109 --> 00:05:39,912
And really the main peril, I think, of these systems is that you're constantly fighting

120
00:05:39,972 --> 00:05:41,794
against human pattern recognition skill.

121
00:05:42,414 --> 00:05:46,698
We're really good at detecting patterns in content, and you'll see patterns in content

122
00:05:46,718 --> 00:05:47,258
very quickly.

123
00:05:48,559 --> 00:05:52,480
And we kind of wanted to give like an extreme example of each possible approach.

124
00:05:52,520 --> 00:05:58,081
So the extreme example I would say for a constructive method is the AD&D dungeon generation system,

125
00:05:58,141 --> 00:06:03,723
which is a paper-based system for procedurally generating an entire dungeon as you go.

126
00:06:03,743 --> 00:06:09,885
It has four pages of lookup tables tied to each possible dice roll you can do for placing

127
00:06:09,905 --> 00:06:11,905
like all of this crazy stuff in.

128
00:06:11,945 --> 00:06:15,026
And it's like, it's kind of awe-inspiring, really.

129
00:06:16,620 --> 00:06:17,681
Yeah, sounds like a lot of fun.

130
00:06:17,921 --> 00:06:18,161
Yeah.

131
00:06:18,201 --> 00:06:20,562
I mean.

132
00:06:20,822 --> 00:06:24,383
So the more sort of structured way, in a sense,

133
00:06:24,563 --> 00:06:26,944
of doing bottom-up content generation,

134
00:06:27,424 --> 00:06:29,445
if you compare to constructive methods, is grammars.

135
00:06:29,885 --> 00:06:33,927
And this is grammars right off like Computer Science 101

136
00:06:34,027 --> 00:06:37,248
or 102 fame or Chomsky fame or something.

137
00:06:37,268 --> 00:06:38,228
They're used for linguistics.

138
00:06:38,688 --> 00:06:42,050
So basically, you define an ontology of objects.

139
00:06:42,990 --> 00:06:43,910
that can exist in the world,

140
00:06:44,071 --> 00:06:45,731
and then you design a set of production rules,

141
00:06:46,832 --> 00:06:51,174
and what object gives can be in each production step

142
00:06:51,474 --> 00:06:53,295
be transformed into what else.

143
00:06:54,275 --> 00:06:58,217
Um, this has been probably most famously used for, um...

144
00:06:59,338 --> 00:07:01,901
for generating vegetation, plants and trees,

145
00:07:01,961 --> 00:07:03,142
think speed tree for example,

146
00:07:03,603 --> 00:07:05,205
but it can be used for lots of other things as well.

147
00:07:05,545 --> 00:07:07,247
So here in the background you see a part

148
00:07:07,307 --> 00:07:10,431
of Joris Dorman's grammatical system

149
00:07:10,451 --> 00:07:14,915
for generating dungeons and quests in Zelda-like games.

150
00:07:16,165 --> 00:07:18,466
It's, uh, right.

151
00:07:18,926 --> 00:07:19,606
Yeah, that one.

152
00:07:19,646 --> 00:07:20,726
Yeah, that computer is good.

153
00:07:21,707 --> 00:07:23,147
It has this very broad applicability.

154
00:07:24,088 --> 00:07:25,148
You can do lots of other things,

155
00:07:25,188 --> 00:07:28,509
and it's easy to sort of combine different design elements.

156
00:07:29,070 --> 00:07:33,811
You have a, um, it, you can get surprisingly complex results

157
00:07:34,411 --> 00:07:37,393
that still adhere to basic design principles

158
00:07:37,893 --> 00:07:39,813
out of very little you put in, in a sense.

159
00:07:39,833 --> 00:07:40,914
So it's very useful in that sense.

160
00:07:42,544 --> 00:07:45,004
The perils of overgenerating,

161
00:07:45,224 --> 00:07:46,945
or, like, the power of overgenerating

162
00:07:46,985 --> 00:07:48,285
is also a peril of overgenerating.

163
00:07:49,026 --> 00:07:51,006
You can generate huge structures

164
00:07:51,826 --> 00:07:53,747
that often show a lot of regularity,

165
00:07:53,807 --> 00:07:55,868
perhaps more regularity than you would actually want to do.

166
00:07:57,188 --> 00:08:00,009
So, um, but this can be solved

167
00:08:00,049 --> 00:08:02,029
by combining it with some sort of testing procedure

168
00:08:02,429 --> 00:08:04,150
where you sort of, if you generate something

169
00:08:04,170 --> 00:08:05,950
that doesn't actually look good or doesn't play well,

170
00:08:06,871 --> 00:08:08,031
according to some automatic measure,

171
00:08:08,051 --> 00:08:09,551
you can cut it down and regenerate.

172
00:08:11,013 --> 00:08:11,834
Which brings us to...

173
00:08:12,694 --> 00:08:13,595
Which brings us to...

174
00:08:13,755 --> 00:08:15,737
So, constructive methods and grammars

175
00:08:15,777 --> 00:08:17,198
are really more bottom-up approaches.

176
00:08:17,218 --> 00:08:19,079
Like, you define a set of rules

177
00:08:19,139 --> 00:08:21,181
and kind of see what bubbles up

178
00:08:21,361 --> 00:08:22,462
and, like, what interesting,

179
00:08:22,522 --> 00:08:24,023
surprising, emergent things happen.

180
00:08:24,764 --> 00:08:26,525
The other two approaches that we want to talk about

181
00:08:26,565 --> 00:08:28,306
are really more top-down methods,

182
00:08:28,407 --> 00:08:32,350
where you as a designer and AI programmer,

183
00:08:32,590 --> 00:08:34,952
like, in combination, that's what's cool about PCG.

184
00:08:34,972 --> 00:08:36,933
You're, like, doing AI and design together.

185
00:08:38,594 --> 00:08:41,476
You can sort of specify high level goals that you have

186
00:08:41,616 --> 00:08:43,398
and let the system figure out what to create

187
00:08:43,438 --> 00:08:44,738
that meets those high level goals.

188
00:08:46,119 --> 00:08:49,402
So there's a relatively new within the academic

189
00:08:49,442 --> 00:08:51,943
procedural content generation community approach

190
00:08:51,963 --> 00:08:53,464
of looking at constraint based systems

191
00:08:53,524 --> 00:08:55,626
to be able to do procedural content generation.

192
00:08:56,486 --> 00:08:59,028
The idea behind these systems is that you specify

193
00:08:59,809 --> 00:09:02,952
what you want to be true about your final content

194
00:09:03,312 --> 00:09:05,894
using logical language.

195
00:09:07,215 --> 00:09:10,638
So you could say, like, I want to have a cave system

196
00:09:10,838 --> 00:09:13,380
and it should be 30 by 30 tiles,

197
00:09:13,901 --> 00:09:15,822
and I want there to be at least five rooms,

198
00:09:15,963 --> 00:09:17,644
and I want those rooms to be connected

199
00:09:17,744 --> 00:09:19,245
by at least 10 corridors,

200
00:09:20,106 --> 00:09:21,127
and I want there to be...

201
00:09:22,068 --> 00:09:23,931
lots of enemies in at least one of the rooms,

202
00:09:23,971 --> 00:09:26,354
and you're giving these very high-level design constraints,

203
00:09:26,735 --> 00:09:28,137
and then you kind of hit the generate button

204
00:09:28,177 --> 00:09:31,582
and let this off-the-shelf constraint solver

205
00:09:31,682 --> 00:09:34,767
figure out what all of the different variables are

206
00:09:34,967 --> 00:09:36,149
and what they need to be set to.

207
00:09:37,129 --> 00:09:39,150
to create a system for you.

208
00:09:39,751 --> 00:09:42,732
So an example of a like out in the wild right now game

209
00:09:42,752 --> 00:09:44,513
that uses constraint-based PCG

210
00:09:45,213 --> 00:09:47,495
is this educational puzzle game called Refraction,

211
00:09:48,275 --> 00:09:50,176
which is from University of Washington,

212
00:09:50,236 --> 00:09:54,218
where you're trying to control how lasers move around and bend

213
00:09:54,278 --> 00:09:55,759
so that you can power spaceships

214
00:09:55,899 --> 00:09:57,540
with fractional portions of lasers.

215
00:09:59,241 --> 00:10:02,526
This is a really powerful way of doing content generation.

216
00:10:03,728 --> 00:10:06,093
You need to be able to figure out how to express

217
00:10:06,373 --> 00:10:08,637
your entire domain in logic programming, though,

218
00:10:08,677 --> 00:10:10,220
which is a non-trivial task.

219
00:10:11,161 --> 00:10:13,045
Though, we're working on making it a little easier.

220
00:10:14,794 --> 00:10:18,956
So some of the really great things about constraint-based systems, you can make promises about design

221
00:10:19,056 --> 00:10:23,297
issues and guarantee that you will meet those promises, which is huge.

222
00:10:23,337 --> 00:10:27,499
Coming from grammars where you've got this emergent stuff that bubbles up, you can't

223
00:10:27,519 --> 00:10:28,439
make any promises.

224
00:10:28,459 --> 00:10:32,441
It's hard to even make promises about playability, like validity.

225
00:10:33,021 --> 00:10:35,442
With constraint systems, you can guarantee validity.

226
00:10:37,163 --> 00:10:41,625
It's a fairly flexible and general purpose language that you can use, so it's very extensible.

227
00:10:42,265 --> 00:10:45,327
Anything that you can figure out how to express in it will work.

228
00:10:45,367 --> 00:10:50,189
You don't need to like tack on a bunch of extra custom created AI modules.

229
00:10:51,530 --> 00:10:54,852
Some of the cons are you need to define your domain very, very tightly, including what

230
00:10:54,912 --> 00:10:56,312
seems like common sense rules.

231
00:10:56,392 --> 00:11:00,675
So this is an AI system called Tanagra that uses numerical constraint solving.

232
00:11:01,275 --> 00:11:08,538
And it's like just even like specifying that platforms need to be attached to each other feels like a very common sense

233
00:11:08,979 --> 00:11:12,260
Constraint you need to explicitly make that clear to the AI system

234
00:11:13,121 --> 00:11:17,783
And it can have some scalability issues and those scalability issues are not super well understood right now

235
00:11:20,815 --> 00:11:23,499
As an extreme example, Variations Forever

236
00:11:23,579 --> 00:11:25,302
is a constraint-based PCG system

237
00:11:25,342 --> 00:11:29,908
to generate an entire space of potential arcade-style games.

238
00:11:30,629 --> 00:11:32,612
And so you can specify the rules for the games

239
00:11:32,692 --> 00:11:34,795
using constraints as well

240
00:11:34,995 --> 00:11:37,899
and get really weird stuff that comes out of it.

241
00:11:39,692 --> 00:11:54,614
Yeah. So another system which is more top down than bottom up or another sort of class of systems is optimization based systems, also called search based systems, depending on which, which country you're from, right, right, right.

242
00:11:56,466 --> 00:11:58,207
We have not disagreed over this at all, ever.

243
00:11:59,728 --> 00:12:02,570
So this is basically the idea of using an evolutionary

244
00:12:02,690 --> 00:12:05,111
algorithm or something similar, a stochastic

245
00:12:05,552 --> 00:12:08,934
optimization algorithm, to evolve your content.

246
00:12:09,394 --> 00:12:12,236
So evolutionary algorithms is the easiest idea in the world.

247
00:12:12,596 --> 00:12:13,857
You just take Darwinian evolution.

248
00:12:14,077 --> 00:12:16,618
You have lots of content, different levels or whatever,

249
00:12:17,579 --> 00:12:18,459
randomly generated.

250
00:12:18,980 --> 00:12:22,902
You keep the good ones, throw away the bad ones, and make

251
00:12:23,762 --> 00:12:25,303
mutated copies of the good ones.

252
00:12:25,403 --> 00:12:27,124
Maybe you let them sort of cross over with each other.

253
00:12:28,845 --> 00:12:31,727
And this works very well in theory.

254
00:12:32,127 --> 00:12:33,788
It often works very well in practice.

255
00:12:34,749 --> 00:12:37,050
Despite the extreme simplicity of the ID,

256
00:12:37,931 --> 00:12:41,213
it requires quite a lot of sophistication to use sometimes.

257
00:12:43,034 --> 00:12:45,816
The fitness function you need here is one of the key parts.

258
00:12:45,956 --> 00:12:47,757
You need a fitness function to sort of judge

259
00:12:47,837 --> 00:12:49,098
how good the content is.

260
00:12:50,630 --> 00:12:53,752
This idea can be used in very different scales,

261
00:12:54,112 --> 00:12:55,693
from just trying to tune your game

262
00:12:56,593 --> 00:12:58,074
to creating a completely new game.

263
00:12:58,094 --> 00:12:59,235
So what you see in the background here

264
00:12:59,715 --> 00:13:02,076
is Paul Tussaud's City Conquest, which

265
00:13:02,156 --> 00:13:06,099
used evolutionary algorithms to tune it quite successfully,

266
00:13:06,139 --> 00:13:06,659
as I understand.

267
00:13:09,200 --> 00:13:15,548
The other example you see here in the background is Cameron Brown's Ludi system.

268
00:13:15,568 --> 00:13:16,489
Well, it's not actually that.

269
00:13:16,690 --> 00:13:22,377
It's actually the game Yabaloth, which is a simple board game you can buy in a box set,

270
00:13:22,497 --> 00:13:25,941
which is apparently out there making money, which was not designed by the...

271
00:13:26,662 --> 00:13:30,444
game designer Cameron Brown, but designed by the system that Cameron Brown built,

272
00:13:30,524 --> 00:13:35,207
which uses evolutionary algorithms to explore the space of different board games.

273
00:13:35,668 --> 00:13:39,230
He sort of made it easy for himself by constraining himself to a very sort of narrow set of board games.

274
00:13:39,990 --> 00:13:43,793
But nevertheless, it works very well here.

275
00:13:44,813 --> 00:13:46,334
So, the screen's too low for me.

276
00:13:47,450 --> 00:13:49,992
The power of these systems is that they're extremely general.

277
00:13:50,612 --> 00:13:53,474
You can basically put anything in there, and it will work.

278
00:13:54,834 --> 00:13:58,297
And it requires relatively little domain knowledge to set

279
00:13:58,617 --> 00:14:01,759
an evolutionary system up to search for content.

280
00:14:02,419 --> 00:14:06,101
The perils are, one, is that it can be very, very slow.

281
00:14:06,441 --> 00:14:09,243
So if you need something that sort of is guaranteed to

282
00:14:09,283 --> 00:14:10,924
generate a new level or a new sort of

283
00:14:11,509 --> 00:14:13,590
enemy or whatever before the next frame,

284
00:14:14,050 --> 00:14:16,011
maybe you shouldn't trust evolutionary computation.

285
00:14:16,711 --> 00:14:18,652
Maybe it might be far too slow.

286
00:14:19,413 --> 00:14:21,734
But if you do it on design time, it's a different thing.

287
00:14:22,094 --> 00:14:24,115
The other parallel is that you really need to come up with a

288
00:14:24,155 --> 00:14:26,356
fitness function that captures what you actually want to

289
00:14:26,396 --> 00:14:31,298
capture, which is trickier than what you will expect.

290
00:14:33,439 --> 00:14:33,619
Right.

291
00:14:36,113 --> 00:14:38,994
So to take an extreme example here, this is a very fascinating one.

292
00:14:39,074 --> 00:14:46,278
This is Michael Cook's Angelina, which is a backer name for a novel game involving

293
00:14:46,358 --> 00:14:48,098
labyrinth I named Angelina.

294
00:14:50,119 --> 00:14:58,503
So this system tries to come up with complete games, including mechanics, levels.

295
00:14:59,295 --> 00:15:06,917
And it even chooses sort of themes for its games and graphics by, for example, reading the Guardian

296
00:15:07,697 --> 00:15:09,777
and then using that as input to an evolution or algorithm.

297
00:15:10,797 --> 00:15:13,818
Therefore, you get these sort of rather odd themes here.

298
00:15:14,198 --> 00:15:17,799
This is a very fascinating system that is really trying to push the boundaries

299
00:15:17,859 --> 00:15:21,260
and do something that has not been done before.

300
00:15:21,340 --> 00:15:23,260
If it was successful, most of us would be unemployed.

301
00:15:25,261 --> 00:15:28,282
Unfortunately, fortunately, it's not really working.

302
00:15:29,267 --> 00:15:29,570
all the way.

303
00:15:30,643 --> 00:15:36,785
So at the end of this sort of survey of these four main classes of content generation algorithms,

304
00:15:37,166 --> 00:15:41,007
there are several others which we did not really find the time to include here.

305
00:15:41,527 --> 00:15:47,749
We just sort of point out that very often the greatest power can be had from combining them.

306
00:15:48,089 --> 00:15:54,251
So you can combine basically examples we have, optimization and grammars, constraints and grammars,

307
00:15:54,411 --> 00:15:59,353
optimization and constraints, and you can have multiple layers of constructive algorithms

308
00:15:59,373 --> 00:15:59,993
on top of each other.

309
00:16:00,393 --> 00:16:07,139
So what you see in background, that's a Super Mario Bros. level generated by an evolutionary grammatical system.

310
00:16:07,199 --> 00:16:12,203
So basically, a system that evolves grammars that create Mario levels.

311
00:16:13,224 --> 00:16:16,146
And with some pretty good effect, actually.

312
00:16:16,206 --> 00:16:23,012
You can get a very large number of levels that look like this, and that look completely different, but according to the same pattern, very easily.

313
00:16:26,302 --> 00:16:34,751
So, yeah, so, excuse me. So, in summary, the sort of four main classes of algorithms that we've talked about at a very high level.

314
00:16:34,871 --> 00:16:38,555
At the end of this talk, we'll give you some resources to go find out a little bit more about them.

315
00:16:40,537 --> 00:16:42,678
And each one sort of has these different trade-offs.

316
00:16:43,018 --> 00:16:46,019
So constructive algorithms can be very, very simple to author,

317
00:16:46,839 --> 00:16:49,321
can be very highly customized to your particular game,

318
00:16:50,421 --> 00:16:52,302
but they can lead to this peril of having

319
00:16:52,342 --> 00:16:54,163
a lot of repetitiveness in your content

320
00:16:54,243 --> 00:16:56,524
that players will start to see very, very quickly.

321
00:16:56,544 --> 00:16:59,445
And they're ad hoc, so they're not really extensible

322
00:16:59,505 --> 00:17:03,366
across games, or if you want to be able to modify,

323
00:17:03,526 --> 00:17:05,167
like if your game design changes,

324
00:17:05,227 --> 00:17:06,948
there might be a lot of backwards work

325
00:17:06,988 --> 00:17:07,628
that you need to do.

326
00:17:08,649 --> 00:17:12,634
Constraint-based systems are really powerful for being able to give all of these design guarantees.

327
00:17:12,654 --> 00:17:16,978
You're using a declarative language to be able to describe all of your content,

328
00:17:17,039 --> 00:17:21,263
which means that while the logic programming language is not super friendly to designers,

329
00:17:22,084 --> 00:17:24,847
unless they're, you know, really super into AI as well.

330
00:17:26,649 --> 00:17:30,411
the general mode of thinking in our experience

331
00:17:30,431 --> 00:17:33,072
has been really more accessible to non-technical designers.

332
00:17:34,092 --> 00:17:35,412
The peril being that you need to figure out

333
00:17:35,452 --> 00:17:38,033
how to translate all of that stuff to different constraints.

334
00:17:38,794 --> 00:17:40,694
And also debugging constraint-based systems

335
00:17:40,734 --> 00:17:42,355
can be very challenging, because often,

336
00:17:42,455 --> 00:17:44,796
if you give a conflicting set of constraints to it,

337
00:17:45,336 --> 00:17:47,437
and tell it to find an answer,

338
00:17:47,497 --> 00:17:48,737
it'll just tell you that it can't.

339
00:17:49,037 --> 00:17:51,078
It won't tell you why it can't do that.

340
00:17:52,199 --> 00:17:55,180
Optimization-based approaches have really good generality

341
00:17:56,140 --> 00:17:58,881
and very interesting emergent behavior can come out of them.

342
00:17:59,701 --> 00:18:01,802
But it can be very hard to define your fitness function

343
00:18:02,262 --> 00:18:04,143
and very tempting to try to define it as like,

344
00:18:04,203 --> 00:18:05,644
what's a fun level?

345
00:18:05,784 --> 00:18:08,505
And then you end up with this like weird situation

346
00:18:08,545 --> 00:18:11,546
where you're trying to come up with a mathematical definition of fun

347
00:18:11,606 --> 00:18:13,366
which is on the ranking 0 to 1.

348
00:18:13,746 --> 00:18:17,108
Which Julian thinks is possible and I think maybe not.

349
00:18:17,668 --> 00:18:20,269
And they're also, they can be fairly slow.

350
00:18:21,249 --> 00:18:23,930
Grammars, again, have a lot of emergent properties

351
00:18:23,970 --> 00:18:26,191
that come out of them, and they're relatively easy to offer,

352
00:18:26,831 --> 00:18:28,591
but you need to spend a lot of time thinking about

353
00:18:28,631 --> 00:18:30,732
how you're going to filter the content that comes out.

354
00:18:33,533 --> 00:18:37,414
So with all of that, sort of very high-level overview,

355
00:18:38,454 --> 00:18:40,375
now you know sort of four main classes

356
00:18:41,395 --> 00:18:43,256
of algorithms for content generation.

357
00:18:43,916 --> 00:18:45,937
How do you pick what you want to do,

358
00:18:45,977 --> 00:18:47,677
and what are some of the design considerations

359
00:18:47,697 --> 00:18:49,938
you might have when you're making a content generator?

360
00:18:51,639 --> 00:18:54,840
And there's sort of four different classes of things that you might want to think about,

361
00:18:54,880 --> 00:18:57,021
and I'll delve into each one of these in just a minute.

362
00:18:57,741 --> 00:19:01,382
You can think about what the building blocks are that you're constructing from, right?

363
00:19:01,482 --> 00:19:07,204
Are you working with pre-authored chunks of content from someone in the level design team?

364
00:19:07,984 --> 00:19:14,486
Or are you working with sub-components, kind of like a tile set, with no semantic knowledge

365
00:19:14,526 --> 00:19:15,146
attached to it?

366
00:19:15,887 --> 00:19:19,128
Is that what you're trying to do with stages in between?

367
00:19:19,987 --> 00:19:23,870
Do you need your content generator to run online in response to what players are doing?

368
00:19:24,431 --> 00:19:26,892
Or do you need it, or is it okay if it runs offline?

369
00:19:29,021 --> 00:19:30,882
And then I think the two that I'm maybe the most

370
00:19:31,322 --> 00:19:35,024
interested in recently is what kind of player interaction

371
00:19:35,084 --> 00:19:37,785
do you want to have with your content generator, if at all?

372
00:19:38,485 --> 00:19:40,046
Do you want to just be generating content

373
00:19:40,086 --> 00:19:42,027
and then the player gets dumped into that content

374
00:19:42,067 --> 00:19:46,189
and it's as though a human had created it, right?

375
00:19:46,249 --> 00:19:47,749
It's just the computer happened to do it?

376
00:19:48,710 --> 00:19:50,490
Or do you want players to actually be able

377
00:19:50,510 --> 00:19:52,711
to manipulate that content generation system

378
00:19:52,771 --> 00:19:55,973
as part of play, which can lead to some interesting things?

379
00:19:56,453 --> 00:20:00,399
And then also the extent to which you want to have control

380
00:20:00,500 --> 00:20:02,322
over the content that comes out.

381
00:20:02,363 --> 00:20:06,108
Do you want to be able to directly influence aspects of

382
00:20:06,128 --> 00:20:07,190
the player experience?

383
00:20:09,380 --> 00:20:12,561
So we can think about the building blocks aspect

384
00:20:12,621 --> 00:20:14,943
as sort of a question of data versus process.

385
00:20:15,683 --> 00:20:19,025
So authored chunks, which I should maybe

386
00:20:19,105 --> 00:20:22,067
have a better term for, these are these pre-authored

387
00:20:22,147 --> 00:20:25,409
big set pieces that you can just glue together

388
00:20:25,429 --> 00:20:26,149
in different ways.

389
00:20:26,930 --> 00:20:27,970
Or maybe you've got templates.

390
00:20:27,991 --> 00:20:30,972
This is like the Mad Libs of procedural content generation.

391
00:20:31,352 --> 00:20:33,013
A lot of stuff that's human authored,

392
00:20:33,474 --> 00:20:36,035
and then some rules to control what goes

393
00:20:36,095 --> 00:20:37,216
into the different slots.

394
00:20:37,396 --> 00:20:39,576
and maybe those rules are really finely crafted

395
00:20:40,837 --> 00:20:43,597
to be able to make sort of always valid design,

396
00:20:44,038 --> 00:20:45,498
like design-controlled content,

397
00:20:46,358 --> 00:20:50,639
or maybe those rules are a little crazier, like Mad Libs,

398
00:20:50,679 --> 00:20:52,579
so that you get weird stuff coming out at the end.

399
00:20:53,240 --> 00:20:56,440
But these are both very data-oriented ways of thinking

400
00:20:56,480 --> 00:20:57,901
about procedural content generation

401
00:20:57,921 --> 00:21:01,141
that maybe lend themselves to data-oriented algorithms

402
00:21:01,161 --> 00:21:03,462
that you would want to use, like a constructive algorithm,

403
00:21:03,962 --> 00:21:04,882
or maybe like a grammar.

404
00:21:04,922 --> 00:21:07,063
Grammars are really good for template-based.

405
00:21:07,784 --> 00:21:12,850
control. On the other end of the spectrum, and this is probably where a lot of

406
00:21:13,030 --> 00:21:16,755
academic research and procedural content generation has been focusing, is on

407
00:21:17,056 --> 00:21:21,301
process-oriented content generation. So what if the amount of content

408
00:21:21,341 --> 00:21:22,963
that your algorithm has to work with

409
00:21:23,904 --> 00:21:26,384
is like a single level component.

410
00:21:26,545 --> 00:21:28,525
So maybe if it's Super Mario World,

411
00:21:28,625 --> 00:21:30,406
your level component might be a platform

412
00:21:30,426 --> 00:21:31,626
with an enemy on top of it.

413
00:21:32,246 --> 00:21:34,747
Like this has some semantic information attached to it

414
00:21:34,767 --> 00:21:38,989
that you can kind of tell the AI system what that means.

415
00:21:40,909 --> 00:21:45,673
But it's not really enough to be a meaningful piece of player experience on its own.

416
00:21:46,313 --> 00:21:50,436
So you need to have this intelligent process that's running, that's trying to capture some

417
00:21:50,476 --> 00:21:53,458
amount of design knowledge for how to assemble content.

418
00:21:54,639 --> 00:22:01,144
You're trying to take the designer's brains and squish it down into an algorithm without

419
00:22:01,204 --> 00:22:02,204
lobotomizing them.

420
00:22:04,372 --> 00:22:07,313
So these are much more process-oriented ways.

421
00:22:07,413 --> 00:22:12,875
And you may want to work with, at the component level, maybe you don't have a big design team

422
00:22:12,915 --> 00:22:16,857
that can put together huge amounts of content for you, so you're trapped.

423
00:22:17,197 --> 00:22:20,578
This is like the reducing authoring burden argument for content generation, right?

424
00:22:20,598 --> 00:22:24,559
If you don't want to have big set pieces, you want to have smaller pieces, then you're

425
00:22:24,579 --> 00:22:28,481
going to need a much more complicated algorithm to be able to fit those smaller pieces together,

426
00:22:28,541 --> 00:22:31,782
and there you're starting to look at something like evolutionary algorithms.

427
00:22:32,603 --> 00:22:33,724
or constraint-based systems.

428
00:22:36,247 --> 00:22:38,749
Algorithm speed is often a big question, right?

429
00:22:39,210 --> 00:22:40,411
And this is kind of the no-brainer.

430
00:22:40,451 --> 00:22:44,996
If you want your content generator to be able to run online and respond to players, you're

431
00:22:45,036 --> 00:22:47,599
going to need to pick something that's pretty fast, right?

432
00:22:48,220 --> 00:22:49,441
Grammars are pretty fast.

433
00:22:49,862 --> 00:22:53,906
You can customize your constructive whatever you've created to be pretty fast.

434
00:22:55,007 --> 00:22:58,929
Constraint-based systems, it depends on the size of your domain and what you're working with.

435
00:22:59,649 --> 00:23:02,150
You can have a constraint-based system that will generate...

436
00:23:02,170 --> 00:23:04,351
So, like, Tanagra, which you'll see in a minute,

437
00:23:06,072 --> 00:23:08,213
generates levels using a constraint-based system,

438
00:23:08,233 --> 00:23:10,874
but its domain is so constrained that it can do that in real time.

439
00:23:10,934 --> 00:23:13,955
If you want to have, like, a massive piece of content that you're generating,

440
00:23:14,335 --> 00:23:16,456
you're looking at, sort of, on the order of a few minutes,

441
00:23:16,516 --> 00:23:19,638
maybe in a few hours, to generate something that's not going to work online.

442
00:23:20,638 --> 00:23:22,599
For evolutionary approaches, you can think of having

443
00:23:22,640 --> 00:23:23,980
a human in the loop, right?

444
00:23:24,000 --> 00:23:26,322
So you could replace your fitness function

445
00:23:26,862 --> 00:23:28,283
with humans voting.

446
00:23:28,984 --> 00:23:30,305
And the game Galactic Arms Race,

447
00:23:30,505 --> 00:23:31,626
which you should all go look up

448
00:23:31,686 --> 00:23:32,726
if you haven't heard of it before,

449
00:23:33,327 --> 00:23:34,768
uses this really effectively.

450
00:23:35,728 --> 00:23:37,049
If you're running offline, then you can be

451
00:23:37,089 --> 00:23:39,111
a lot more flexible in the algorithm that you choose.

452
00:23:41,372 --> 00:23:42,673
And then finally, we can think, like,

453
00:23:42,713 --> 00:23:43,694
what about the players, right?

454
00:23:43,734 --> 00:23:45,035
Maybe we shouldn't think about them finally.

455
00:23:45,075 --> 00:23:46,476
Maybe we should think about them first.

456
00:23:47,877 --> 00:23:48,297
But the...

457
00:23:50,007 --> 00:23:52,309
The type of control that you want to be able to have

458
00:23:52,349 --> 00:23:54,731
really dictates the kind of algorithm that you have.

459
00:23:54,791 --> 00:23:57,312
So if you want sort of parameterized control,

460
00:23:57,332 --> 00:24:00,234
sort of civilization map generation style control

461
00:24:00,294 --> 00:24:01,735
where you can tweak in the beginning,

462
00:24:02,436 --> 00:24:03,517
like I want there to be lakes,

463
00:24:04,137 --> 00:24:05,658
and I want there to be no barbarians,

464
00:24:05,698 --> 00:24:07,579
and a few other things, these are parameters, right?

465
00:24:08,500 --> 00:24:10,361
That tends to lend itself fairly well

466
00:24:10,421 --> 00:24:13,043
to weighting different rules in your grammar.

467
00:24:14,764 --> 00:24:17,826
If you want indirect control over what's being created,

468
00:24:17,906 --> 00:24:18,067
like...

469
00:24:21,480 --> 00:24:25,201
Like, say, in Galactic Arms Race, it's a space shooter game where the weapons are procedurally

470
00:24:25,241 --> 00:24:31,364
generated and the way that those weapons get generated is by evolving the next weapon based

471
00:24:31,424 --> 00:24:33,845
on the one that you've used the most frequently in the game.

472
00:24:34,725 --> 00:24:36,666
So that's a really indirect kind of control.

473
00:24:36,706 --> 00:24:40,428
You can also think of, like, the experience manager in Left 4 Dead as sort of an indirect

474
00:24:40,508 --> 00:24:44,390
kind of control that the player might have over what's going on in your system.

475
00:24:45,499 --> 00:24:47,800
And then you can also think about what level

476
00:24:47,840 --> 00:24:49,440
of design control you want to have.

477
00:24:49,561 --> 00:24:51,421
So do you want experiential control,

478
00:24:51,461 --> 00:24:53,663
where you're actually explicitly modeling some aspect

479
00:24:53,703 --> 00:24:55,523
of the player's experience, like the pacing

480
00:24:55,563 --> 00:24:56,544
of a platforming level?

481
00:24:57,324 --> 00:24:59,465
Or are you good with compositional control,

482
00:24:59,525 --> 00:25:01,686
which is really more like saying,

483
00:25:01,746 --> 00:25:04,848
I want 50% of this world to be covered with ocean,

484
00:25:04,908 --> 00:25:08,050
and 20% of it should be built up cities.

485
00:25:08,850 --> 00:25:11,071
And that can guide the kind of decision making

486
00:25:11,091 --> 00:25:11,831
you're making as well.

487
00:25:15,714 --> 00:25:19,639
Yeah, so we talked a lot about individual methods

488
00:25:19,699 --> 00:25:21,621
and types of methods for generating content

489
00:25:22,302 --> 00:25:23,303
and when you should use one,

490
00:25:23,383 --> 00:25:25,226
when you should use the other, and so on,

491
00:25:25,326 --> 00:25:27,389
and by now it should be getting clear

492
00:25:27,409 --> 00:25:31,414
that there are lots of trade-offs and, I mean, confusing.

493
00:25:31,774 --> 00:25:32,916
But then there's also the matter of...

494
00:25:33,833 --> 00:25:35,955
Where in the chain are you going to use this?

495
00:25:36,035 --> 00:25:36,956
How are you going to use this?

496
00:25:37,357 --> 00:25:39,740
Are you going to use an algorithm as game runs or

497
00:25:40,701 --> 00:25:41,461
design time?

498
00:25:41,582 --> 00:25:44,545
Or are you just going to let it produce some content for

499
00:25:44,565 --> 00:25:45,326
you and be happy with it?

500
00:25:45,886 --> 00:25:47,568
Or can you somehow interact with it?

501
00:25:47,929 --> 00:25:48,029
So.

502
00:25:48,970 --> 00:26:08,160
Recently, there's been a couple of prototypes developed on how you can come up with authoring tools for different games that use the full power of these AI methods to create content, but together with you, and in a sort of dialogue with you, in a mixed initiative fashion, meaning that you can take initiatives, and the program can also take initiatives.

503
00:26:08,820 --> 00:26:16,024
So we'll briefly show three examples that all come out of academia, actually out of our own labs.

504
00:26:20,255 --> 00:26:21,955
but which showcases in various ways.

505
00:26:21,975 --> 00:26:22,976
The first here is Tanagra.

506
00:26:23,016 --> 00:26:23,456
Are you going to?

507
00:26:23,676 --> 00:26:24,256
Yeah, yeah.

508
00:26:24,276 --> 00:26:25,696
So I can talk very quickly about Tanagra.

509
00:26:25,716 --> 00:26:29,617
I think Tanagra was shown at the AI Summit three or four years

510
00:26:29,657 --> 00:26:30,477
ago, I want to say.

511
00:26:30,577 --> 00:26:32,958
So five or six.

512
00:26:33,018 --> 00:26:34,478
Well, that makes me feel old, doesn't it?

513
00:26:34,498 --> 00:26:36,459
Yeah.

514
00:26:38,117 --> 00:26:43,118
So Tanagra is a system that uses a combination of constraints and reactive planning, which

515
00:26:43,218 --> 00:26:49,080
is really like it's actually a grammar going on, to have human-computer interaction for

516
00:26:49,120 --> 00:26:51,020
creating platformer levels.

517
00:26:51,500 --> 00:26:53,321
This is a prototype tool.

518
00:26:53,381 --> 00:26:57,222
It's obviously not ready to go out into the real world and be used by platformer level

519
00:26:57,242 --> 00:27:00,542
designers, but it's sort of playing with the idea of what this could look like.

520
00:27:00,582 --> 00:27:05,624
So the idea is that the human and the computer can interact in real time to collaborate on

521
00:27:05,644 --> 00:27:06,984
what the design of the level should be.

522
00:27:08,505 --> 00:27:16,751
The human is sort of, through interacting in the user interface, is continually editing constraints that are placed onto the level,

523
00:27:17,452 --> 00:27:24,697
and the machine is sort of brainstorming ideas for what levels can look like that meet the constraints that you're adding onto the system.

524
00:27:25,898 --> 00:27:31,542
And it provides a level of experiential control, so you can actually, as a designer, directly manipulate the pacing of the level.

525
00:27:31,562 --> 00:27:35,425
You can say, I want it to be fast-paced in the middle, slower-paced at the end.

526
00:27:37,192 --> 00:27:40,454
and it will create geometry that meets

527
00:27:40,534 --> 00:27:42,935
those pacing constraints without you needing to say

528
00:27:42,975 --> 00:27:44,556
what geometry should go into place.

529
00:27:44,576 --> 00:27:48,618
So I'm going to show, I'm going to kind of skip around

530
00:27:48,658 --> 00:27:50,379
in this video a little bit because it's,

531
00:27:52,259 --> 00:27:54,380
there we go, whoops, come on.

532
00:27:58,763 --> 00:27:58,983
There we go.

533
00:27:59,003 --> 00:27:59,223
There we go.

534
00:28:00,692 --> 00:28:02,532
So this is, you can hit the generate button

535
00:28:02,552 --> 00:28:04,493
and it generates a bunch of different ideas

536
00:28:04,513 --> 00:28:05,754
for what levels could look like.

537
00:28:06,475 --> 00:28:08,616
You could draw in platforms,

538
00:28:09,216 --> 00:28:10,757
and anything that's showing in in dark

539
00:28:10,857 --> 00:28:12,378
is a constrained system,

540
00:28:13,498 --> 00:28:15,579
and generate stuff that fits in between them.

541
00:28:16,760 --> 00:28:18,141
You can play test in the editor,

542
00:28:18,161 --> 00:28:20,702
and this is what happens when you tell a computer scientist

543
00:28:20,722 --> 00:28:22,843
to make the art, the computer scientist is me,

544
00:28:23,523 --> 00:28:25,264
to make the art for your AI tool,

545
00:28:26,245 --> 00:28:28,226
because I know how to draw robots and birds and that's it.

546
00:28:29,399 --> 00:28:31,941
This is the part where you can directly manipulate the pacing.

547
00:28:31,981 --> 00:28:33,902
So there's this beat timeline down at the bottom

548
00:28:33,942 --> 00:28:39,046
where you can add in areas where the player needs to be taking more actions.

549
00:28:39,147 --> 00:28:41,528
You can remove actions off from the end.

550
00:28:42,609 --> 00:28:46,973
And you can see that the level geometry is continually updating to meet...

551
00:28:48,274 --> 00:28:51,299
Sort of the pacing that you want and you can regenerate at any time

552
00:28:51,960 --> 00:28:57,368
You can also grab platforms drag them around and it will automatically keep up with what's going on

553
00:28:57,408 --> 00:29:00,653
So this is a direct interaction where the content generation system

554
00:29:01,349 --> 00:29:04,450
Yeah, so, and whereas Tanagra has these ideas

555
00:29:04,691 --> 00:29:06,952
about, like, co-authoring with a machine

556
00:29:07,012 --> 00:29:09,093
based on the constraint-based systems,

557
00:29:09,113 --> 00:29:11,734
the Sentient Sketchbook is another idea

558
00:29:11,814 --> 00:29:13,975
of using evolutionary system

559
00:29:14,035 --> 00:29:16,056
and other kind of search-based systems

560
00:29:16,076 --> 00:29:17,737
to assist the player.

561
00:29:18,117 --> 00:29:20,698
So this is a system for general,

562
00:29:20,958 --> 00:29:23,599
sort of strategy game sketch generation.

563
00:29:25,060 --> 00:29:26,861
Let me talk a little bit about this video.

564
00:29:26,901 --> 00:29:27,481
How do you start it?

565
00:29:27,841 --> 00:29:29,162
Just hit the thing.

566
00:29:29,842 --> 00:29:30,082
The thing.

567
00:29:30,958 --> 00:29:32,139
The thing, Julian, the thing.

568
00:29:32,679 --> 00:29:33,199
The thing.

569
00:29:34,600 --> 00:29:35,060
You show me.

570
00:29:36,780 --> 00:29:37,961
Oh, there's a mouse pointer, right?

571
00:29:37,981 --> 00:29:40,202
Oh, beautiful.

572
00:29:40,462 --> 00:29:41,102
Okay, good.

573
00:29:41,542 --> 00:29:44,463
Right, so this is the Sentient Sketchbook 2.

574
00:29:44,563 --> 00:29:45,823
Is it playing? Yeah, right?

575
00:29:46,364 --> 00:29:48,865
You create, it represents the strategy game maps

576
00:29:48,885 --> 00:29:50,425
as sort of high-level chunks.

577
00:29:51,663 --> 00:29:54,944
which absolutely represents like impassable areas,

578
00:29:55,064 --> 00:29:56,545
which could be walls and so on in StarCraft,

579
00:29:57,145 --> 00:30:00,007
or bases, resources, and so on.

580
00:30:00,487 --> 00:30:02,728
So as you go along and edit and draw things here,

581
00:30:03,208 --> 00:30:05,369
you see those little screens to the right.

582
00:30:05,750 --> 00:30:07,430
These are suggestions that are based

583
00:30:07,470 --> 00:30:08,531
on what you're currently editing,

584
00:30:08,571 --> 00:30:10,312
which is generated using evolutionary search,

585
00:30:10,852 --> 00:30:12,153
and something called novelty search,

586
00:30:12,313 --> 00:30:14,674
which is a way of finding diverse,

587
00:30:16,174 --> 00:30:18,015
similar but diverse sort of content.

588
00:30:19,516 --> 00:30:24,501
It also gives you these little sort of meters that gives you immediate feedback as you edit about like the balance.

589
00:30:24,561 --> 00:30:29,065
Do you have like the same amount of bases next to you?

590
00:30:30,486 --> 00:30:32,908
And you have space around the base, access to resources and so on.

591
00:30:33,769 --> 00:30:42,216
You can get these various views that show you, based on gameplay features, various aspects of fairness and game balance.

592
00:30:43,751 --> 00:30:45,433
And as you go along, you might choose

593
00:30:45,513 --> 00:30:48,515
to implement one or several of these suggestions

594
00:30:48,675 --> 00:30:49,656
and replace your map with it.

595
00:30:50,057 --> 00:30:52,379
Every time you do it, the tool learns from you

596
00:30:52,419 --> 00:30:57,243
and tries to figure out what kind of aesthetic preferences

597
00:30:57,263 --> 00:30:57,643
you have.

598
00:30:58,784 --> 00:31:02,067
This person is trying to generate very sparse maps.

599
00:31:02,107 --> 00:31:05,369
So this person is trying to generate maps

600
00:31:05,389 --> 00:31:06,911
with lots of choke points and so on.

601
00:31:06,971 --> 00:31:08,212
So it has various detectors

602
00:31:08,232 --> 00:31:09,813
for these sort of design features.

603
00:31:11,816 --> 00:31:17,478
And as you go along with this, you can then come up with,

604
00:31:17,498 --> 00:31:19,318
you can export it to various kind of game modes.

605
00:31:20,799 --> 00:31:23,920
We have an export for StarCraft and also for our own

606
00:31:23,960 --> 00:31:26,781
sort of simple map format here.

607
00:31:27,761 --> 00:31:30,722
But it's trying to operate at a somewhat more abstract level.

608
00:31:30,762 --> 00:31:34,363
It's not the level of a particular strategy game, but

609
00:31:34,523 --> 00:31:37,844
of some sort of abstraction of what goes

610
00:31:37,904 --> 00:31:38,624
into a strategy game.

611
00:31:39,920 --> 00:31:43,942
We take an example of something which is a lot more tailored to a particular game.

612
00:31:44,262 --> 00:31:51,704
We have what we call a rope bossom, or a ropossom, or something, which is a level generator for

613
00:31:51,804 --> 00:31:56,425
Cut the Rope, this mobile puzzle game which has been very, very successful.

614
00:31:57,626 --> 00:32:05,848
Uses tree search and grammar-based genetic programming, so basically evolving grammars,

615
00:32:06,469 --> 00:32:07,949
so to both come up with levels.

616
00:32:08,389 --> 00:32:09,970
and to help you solve levels in real time.

617
00:32:11,651 --> 00:32:12,411
It's... what's it?

618
00:32:12,551 --> 00:32:13,191
Clique?

619
00:32:14,172 --> 00:32:14,352
Good.

620
00:32:15,112 --> 00:32:15,292
Right.

621
00:32:16,013 --> 00:32:16,173
No?

622
00:32:16,973 --> 00:32:17,794
Yeah. Right.

623
00:32:19,434 --> 00:32:20,455
So we have the same thing here.

624
00:32:20,475 --> 00:32:21,095
We have an editor,

625
00:32:21,876 --> 00:32:24,797
which actually is, like, a clone of the Cutthroat game

626
00:32:25,077 --> 00:32:25,978
using the original assets,

627
00:32:26,098 --> 00:32:28,059
which they were happy to let us use.

628
00:32:28,499 --> 00:32:30,120
Um, you can put things out there.

629
00:32:30,892 --> 00:32:32,494
you can press a button to check for playability,

630
00:32:32,774 --> 00:32:35,156
and it gives you the complete sequence of actions

631
00:32:35,176 --> 00:32:38,098
you need to take to sort of, um, to play the game.

632
00:32:38,939 --> 00:32:41,401
This uses a pretty interesting tree search algorithm,

633
00:32:41,441 --> 00:32:43,843
which I won't get into here, but it took us some thinking.

634
00:32:44,623 --> 00:32:47,245
Um, and it can also sort of, you know,

635
00:32:47,265 --> 00:32:49,888
there's a separate way of visualizing what's gonna happen,

636
00:32:49,948 --> 00:32:52,450
which is an occlusion-based view,

637
00:32:52,590 --> 00:32:54,431
which, um, which shows you...

638
00:32:54,932 --> 00:32:56,854
what kind of effects each component has

639
00:32:57,275 --> 00:32:57,996
as you put them in here,

640
00:32:58,817 --> 00:33:00,058
and what includes it,

641
00:33:00,138 --> 00:33:02,121
and what sort of paths you can actually need to take.

642
00:33:03,542 --> 00:33:06,206
You can at any point sort of fix parts of the design

643
00:33:06,266 --> 00:33:08,048
and have it regenerate the rest of the design.

644
00:33:08,068 --> 00:33:10,451
And, yeah.

645
00:33:11,552 --> 00:33:13,735
So I guess we don't have time to go through this very much.

646
00:33:17,177 --> 00:33:27,926
Alright, so I wanted to close with some thoughts on how to actually visualize and debug these systems.

647
00:33:28,166 --> 00:33:38,295
So you've got, Adam Smith has this way of talking about generative systems where you're sculpting a design space, basically.

648
00:33:38,315 --> 00:33:45,621
You need to shift your thinking from how to design a single piece of content to how to create an entire space of potential content.

649
00:33:46,201 --> 00:33:49,162
And he has this very nice clay-based metaphor that I just,

650
00:33:49,402 --> 00:33:50,823
I really love, it feels very artsy.

651
00:33:53,304 --> 00:33:55,744
But it's tempting when we build generative systems

652
00:33:56,405 --> 00:33:58,165
to just hit the generate button a few times,

653
00:33:58,205 --> 00:34:01,066
say yeah, this looks like it's making reasonable stuff.

654
00:34:02,107 --> 00:34:04,308
So I guess my generator is done, right?

655
00:34:05,768 --> 00:34:08,129
But it's difficult to actually sample

656
00:34:08,309 --> 00:34:09,369
reasonably from the space,

657
00:34:09,389 --> 00:34:11,530
and actually Nathan in his talk is gonna be talking

658
00:34:11,570 --> 00:34:13,411
a little bit about a solution he has for this.

659
00:34:14,311 --> 00:34:18,034
You can think of it as like if you have a hundred coins and you flip them,

660
00:34:18,654 --> 00:34:22,377
you would expect that 50 times you would get heads and 50 times you would get tails.

661
00:34:22,797 --> 00:34:27,481
But it's entirely possible that you'd get heads like 90 times and tails 10 times.

662
00:34:28,281 --> 00:34:30,403
So it's hard to

663
00:34:30,743 --> 00:34:36,587
know that when you hit the generate button, you're really getting a representative sample from this massive space of content that you're making.

664
00:34:38,032 --> 00:34:41,835
So one of the ways that we've talked about trying to resolve this problem

665
00:34:42,275 --> 00:34:45,597
is by trying to actually map out the expressive range of a generative system.

666
00:34:46,478 --> 00:34:49,160
And roughly the way that we've been mapping this out

667
00:34:49,840 --> 00:34:53,662
is defining several numerical metrics or numerical scores

668
00:34:53,723 --> 00:34:55,544
for the content that your system can produce.

669
00:34:57,622 --> 00:35:00,383
generating a huge amount of content from that system.

670
00:35:00,423 --> 00:35:02,924
And with lightweight methods, that will go relatively quickly.

671
00:35:02,984 --> 00:35:06,725
With heavier weight methods, you might need to run this system

672
00:35:06,765 --> 00:35:07,705
overnight or something.

673
00:35:09,406 --> 00:35:12,807
And then score each piece of content that you create

674
00:35:13,307 --> 00:35:16,088
and map out with a 2D histogram that can

675
00:35:16,108 --> 00:35:17,448
be visualized as a heat map.

676
00:35:18,989 --> 00:35:22,252
what kind of space of content you're getting.

677
00:35:22,332 --> 00:35:25,615
So these are, each one of these graphs is a heat map

678
00:35:26,456 --> 00:35:29,139
for a different generator for a 2D platforming game,

679
00:35:29,419 --> 00:35:32,321
mapping sort of a rough approximation of difficulty

680
00:35:32,482 --> 00:35:37,606
on the Y axis against a rough approximation of linearity,

681
00:35:38,387 --> 00:35:40,669
so like how flat the levels are basically.

682
00:35:42,190 --> 00:35:47,415
And you can see that each system is creating very different looking spaces of levels.

683
00:35:47,535 --> 00:35:53,840
So the green points in these maps are sort of areas where the generator is biased towards

684
00:35:53,940 --> 00:35:57,223
creating a lot of levels in that space, and then it falls off.

685
00:35:57,263 --> 00:36:02,988
So we even have some systems like in the top right, that system creates kinds of levels

686
00:36:03,768 --> 00:36:06,290
that the system in the middle top.

687
00:36:06,851 --> 00:36:08,011
will never be able to create.

688
00:36:08,711 --> 00:36:10,552
So it's kind of interesting to be able to look

689
00:36:10,612 --> 00:36:12,693
at the space of content that you can get.

690
00:36:14,174 --> 00:36:15,355
For reference, some of the metrics

691
00:36:15,375 --> 00:36:18,176
that we're talking about here are leniency,

692
00:36:18,236 --> 00:36:20,777
which is like an objective approximation to difficulty.

693
00:36:21,478 --> 00:36:24,879
By weighting each component that appears in a level

694
00:36:24,959 --> 00:36:27,080
by how much harm the player would come to

695
00:36:27,161 --> 00:36:29,242
were they to fail the interaction with it.

696
00:36:29,942 --> 00:36:32,783
So like if you fail the interaction with a gap, you're dead.

697
00:36:33,704 --> 00:36:35,986
If you fail the interaction with a Goomba,

698
00:36:36,686 --> 00:36:38,808
then you've just like lost your power up, right?

699
00:36:38,848 --> 00:36:41,470
So it's not quite as harsh as a Gap is.

700
00:36:42,991 --> 00:36:46,194
Also linearity, like density of challenges,

701
00:36:46,814 --> 00:36:48,916
and then pattern density and pattern variation

702
00:36:48,956 --> 00:36:51,678
are two metrics that are looking at how close

703
00:36:51,758 --> 00:36:56,161
to the original Mario levels, the generated levels appear.

704
00:36:58,079 --> 00:37:03,163
The other cool thing that you can do when you've got this ability to visualize the generative space

705
00:37:03,724 --> 00:37:07,106
is that you can look at how your generative space is changing

706
00:37:08,227 --> 00:37:13,932
when you vary certain input parameters and uncover unintentional biases that you might have in your generative system.

707
00:37:14,752 --> 00:37:18,234
So these are a bunch of heat maps for a single level generator,

708
00:37:19,274 --> 00:37:23,195
where each one is a different configuration of input parameters to it.

709
00:37:23,775 --> 00:37:28,517
And for the sake of time, I won't say exactly what all of those parameters are,

710
00:37:28,597 --> 00:37:30,178
but suffice to say they're different.

711
00:37:31,138 --> 00:37:34,219
And you can see that there are certain configurations of parameters

712
00:37:34,279 --> 00:37:39,581
that bias the generator towards creating particular kinds of content more than others.

713
00:37:41,673 --> 00:37:46,894
And you can talk to us and ask us about exactly how this is working after the talk if you would like.

714
00:37:46,954 --> 00:37:50,175
So we wanted to close with just some further resources and ideas.

715
00:37:50,835 --> 00:37:58,858
So if you if your interest is piqued by this like very high level very whirlwind overview of like all of procedural content generation.

716
00:37:58,878 --> 00:38:01,718
Yeah, man, like 40 minutes. That's hard to do.

717
00:38:03,399 --> 00:38:05,541
These are some resources that you might find useful.

718
00:38:06,081 --> 00:38:08,323
So there's the Procedural Content Generation Google Group.

719
00:38:08,363 --> 00:38:09,964
This is a Google group and a mailing list

720
00:38:10,024 --> 00:38:12,646
that consists of indie game developers,

721
00:38:12,686 --> 00:38:14,607
I think some people from AAA industry,

722
00:38:14,807 --> 00:38:17,349
and academics who are all sort of talking

723
00:38:17,409 --> 00:38:18,910
about procedural content generation.

724
00:38:18,990 --> 00:38:20,832
It varies in its amount of activity.

725
00:38:20,932 --> 00:38:24,094
And please, if you join this, as many of you

726
00:38:24,134 --> 00:38:25,455
might be logging in and trying to do now,

727
00:38:25,895 --> 00:38:30,318
please write something in the reason for joining box

728
00:38:30,358 --> 00:38:31,960
so we know that you're not a bot.

729
00:38:32,280 --> 00:38:32,801
Right.

730
00:38:33,182 --> 00:38:35,507
And if you join, please contribute to the discussion.

731
00:38:35,527 --> 00:38:37,371
There's a thread saying introducing ourselves.

732
00:38:37,532 --> 00:38:40,378
Please add to that, introduce yourselves, and so on.

733
00:38:41,230 --> 00:38:43,311
There's two game jams that are going on.

734
00:38:44,151 --> 00:38:47,272
One happened last November called the Procedural Content Generation Jam.

735
00:38:47,452 --> 00:38:49,012
It will be coming back again in 2015.

736
00:38:49,232 --> 00:38:50,733
That's organized by Mike Cook.

737
00:38:51,493 --> 00:38:55,274
There's also the AI-based game jam that's being organized by Alex Zook.

738
00:38:55,354 --> 00:38:58,214
That's going to be taking place around the end of March.

739
00:38:58,534 --> 00:38:59,755
Those are websites for those.

740
00:39:00,495 --> 00:39:04,456
There's a wiki that has sort of information about different algorithms we've talked about.

741
00:39:04,896 --> 00:39:10,797
And in progress textbook that's currently free online at pcgbook.com, co-edited by Julia.

742
00:39:11,077 --> 00:39:15,759
Yes, it will continue to be free, but it will also come out as like a physical book.

743
00:39:15,859 --> 00:39:17,119
PCGBook.com.

744
00:39:17,339 --> 00:39:18,180
Have a look at it right now.

745
00:39:18,840 --> 00:39:22,481
And then finally, these are some of the academic venues where PCG research gets published.

746
00:39:22,561 --> 00:39:23,982
We know that the paywall is a thing.

747
00:39:24,022 --> 00:39:27,823
We know that the paywall is a huge pain, and we hate it as much as you all do.

748
00:39:28,463 --> 00:39:32,625
The first three of these are either open access or mostly open access, which means you don't

749
00:39:32,665 --> 00:39:35,546
need to pay to be able to find our work that we're doing.

750
00:39:35,966 --> 00:39:38,387
And with that, I think we should transition to Nathan.

751
00:39:38,407 --> 00:39:38,607
Thank you.

752
00:39:38,627 --> 00:39:38,987
Thank you.

