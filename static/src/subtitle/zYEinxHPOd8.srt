1
00:00:05,783 --> 00:00:11,625
I'm Alex Silkin, I'm a co-founder and CTO at Servius, and today I'll be talking about

2
00:00:11,806 --> 00:00:16,848
porting your VR game to the Oculus Quest in the context of Creed.

3
00:00:18,709 --> 00:00:22,991
So the key takeaways of this talk, I'm going to talk about some common pitfalls that you'll

4
00:00:23,011 --> 00:00:25,472
probably fall into, like we did.

5
00:00:26,452 --> 00:00:28,853
Some recommended workflows for...

6
00:00:29,613 --> 00:00:34,096
Getting that thing squeezed onto the quest and just some examples of the tricks we had

7
00:00:34,116 --> 00:00:36,558
to do to get it running on the quest.

8
00:00:38,259 --> 00:00:41,161
And just a bit of an intro about the game.

9
00:00:41,181 --> 00:00:43,302
Are these videos playing?

10
00:00:46,924 --> 00:00:49,665
I'm sorry, I don't usually use Macs.

11
00:00:50,425 --> 00:00:53,927
So it's a boxing game, it's based on the Creed movie.

12
00:00:54,527 --> 00:00:59,529
It was originally launched last fall on the PC and PlayStation platforms.

13
00:01:00,850 --> 00:01:02,531
It was our third Unreal Engine game.

14
00:01:02,951 --> 00:01:05,532
PlayStation was the lead SKU for this game.

15
00:01:07,473 --> 00:01:11,416
This is because you really want to have your most constrained platform as your lead SKU.

16
00:01:11,616 --> 00:01:14,899
We learned this the hard way with Raw Data, our first Unreal Engine

17
00:01:15,619 --> 00:01:20,123
title that came out on the PlayStation. PlayStation VR came out

18
00:01:21,364 --> 00:01:23,325
while Raw Data was in early access,

19
00:01:23,385 --> 00:01:24,686
so we weren't really planning to

20
00:01:25,087 --> 00:01:31,031
initially release it on the platform, and we just learned the hard way that trying to downport an experience is just really, really tough.

21
00:01:31,592 --> 00:01:32,292
So I know this talk is

22
00:01:33,093 --> 00:01:37,636
Title porting a title to the quest, but I guess my first advice to you is don't do it.

23
00:01:38,376 --> 00:01:39,897
Just develop for the quest from the beginning.

24
00:01:41,338 --> 00:01:46,801
And unfortunately, we had to do this again for Creed, but that's because Docus Quest came out

25
00:01:46,821 --> 00:01:51,364
almost a year after Creed came out. But it was such an amazing opportunity for us because we

26
00:01:51,384 --> 00:01:55,527
got to ship Creed as a launch title for the quest. So we just couldn't pass it.

27
00:01:56,708 --> 00:01:59,829
But it was it was not easy.

28
00:01:59,849 --> 00:02:00,330
So

29
00:02:03,340 --> 00:02:04,561
Here, where the video is playing?

30
00:02:04,941 --> 00:02:04,981
OK.

31
00:02:05,061 --> 00:02:06,582
All right.

32
00:02:06,642 --> 00:02:07,062
Never mind.

33
00:02:08,743 --> 00:02:12,164
So you should really understand what you're developing for.

34
00:02:12,264 --> 00:02:16,626
So let's talk about what a Quest is, and what's special

35
00:02:16,647 --> 00:02:18,767
about it, what's different about it, than developing for

36
00:02:18,787 --> 00:02:20,908
a traditional console PC.

37
00:02:21,549 --> 00:02:24,550
So the Quest architecture is a little different than what

38
00:02:24,570 --> 00:02:25,291
you're probably used to.

39
00:02:25,871 --> 00:02:30,493
It has a tile-based renderer, also something called

40
00:02:30,533 --> 00:02:31,253
binning-based renderer.

41
00:02:31,754 --> 00:02:34,576
Essentially, PC and PSVR use immediate mode rendering.

42
00:02:35,037 --> 00:02:37,419
The entire screen is rendered together.

43
00:02:37,980 --> 00:02:44,086
But these mobile GPUs, what they do is they divide up the screen into tiles.

44
00:02:44,366 --> 00:02:47,169
The tiles are much smaller than what's demonstrated here on the screen.

45
00:02:47,209 --> 00:02:48,630
This is just for demonstrated purposes.

46
00:02:49,731 --> 00:02:52,614
And your draw calls are submitted as normal.

47
00:02:52,714 --> 00:02:55,196
You're not submitting them on a per-tile basis.

48
00:02:55,650 --> 00:02:59,553
You're still submitting them normally for the entire screen, but when the GPU goes through

49
00:02:59,573 --> 00:03:04,456
and divides up the tiles, this is called the binning process, it takes all the triangles,

50
00:03:04,817 --> 00:03:07,899
it sorts them, and it figures out which tiles are which.

51
00:03:08,524 --> 00:03:14,229
which tiles the triangles belong to. And then the GPU processes these tiles sequentially.

52
00:03:14,249 --> 00:03:18,733
So unlike the once again traditional graphics cards that you're probably used to,

53
00:03:19,094 --> 00:03:23,798
there's no VRAM, there's no dedicated RAM that the graphics card uses.

54
00:03:24,098 --> 00:03:27,241
It's actually a shared memory between CPU and GPU.

55
00:03:28,682 --> 00:03:33,127
This does mean that the GPU does not require as much memory because it's going through

56
00:03:33,147 --> 00:03:36,872
these small tiles, so it's much more efficient, so it's great for battery life, etc.

57
00:03:37,372 --> 00:03:42,919
But this is an important consideration for what things are just inefficient on this platform.

58
00:03:44,949 --> 00:03:53,051
So the rough target you should aim for is 300,000 verts for your entire scene, characters, etc.

59
00:03:53,151 --> 00:03:54,631
Creed shipped with around 200,000.

60
00:03:54,671 --> 00:03:58,772
You should aim for around 100 to 150 draw calls.

61
00:03:59,912 --> 00:04:01,272
Creed shipped with around 70.

62
00:04:01,432 --> 00:04:05,974
We were pretty aggressive with our environment optimization,

63
00:04:06,054 --> 00:04:08,394
merging a lot of things down to get those draw calls down.

64
00:04:09,354 --> 00:04:13,355
And something that you can't really change is

65
00:04:14,062 --> 00:04:14,782
I'm going to go ahead and run this.

66
00:04:14,802 --> 00:04:15,162
So, this is a demo.

67
00:04:15,182 --> 00:04:16,823
This is a demo of how Oculus Quest renders at 72 frames per second.

68
00:04:16,843 --> 00:04:18,144
That's the refresh rate of the screen.

69
00:04:18,644 --> 00:04:22,766
That is roughly equal to 13.8 milliseconds for a frame.

70
00:04:23,166 --> 00:04:28,249
This is how much, this is the time you have for your GPU and your CPU, all the threads

71
00:04:28,329 --> 00:04:32,471
to do all the work for the frame and submit it to the system to render.

72
00:04:33,172 --> 00:04:37,654
And this is non-negotiable and you have to understand because the system is, you know,

73
00:04:37,934 --> 00:04:38,514
it's like vertically...

74
00:04:39,735 --> 00:04:43,557
But as with VSync, you're really locked to this refresh rate.

75
00:04:43,577 --> 00:04:46,479
So if you miss, I like to call it like a train,

76
00:04:46,719 --> 00:04:48,400
if you miss this train, you have to wait for the next train.

77
00:04:48,700 --> 00:04:50,441
So you have to wait at the train station,

78
00:04:50,562 --> 00:04:51,662
waiting for the next train to arrive.

79
00:04:51,702 --> 00:04:56,205
So even if your frame took like 14 milliseconds,

80
00:04:56,245 --> 00:04:57,606
15 milliseconds, you have to wait

81
00:04:57,626 --> 00:04:58,667
for the next time refresh rate.

82
00:04:59,727 --> 00:05:02,889
So essentially, if you keep missing that budget

83
00:05:02,929 --> 00:05:04,831
by even a little bit, now you're,

84
00:05:05,291 --> 00:05:06,512
essentially each one of your frames

85
00:05:06,532 --> 00:05:08,053
is actually taking like 27 milliseconds,

86
00:05:08,073 --> 00:05:09,213
so you're just halving your frame rate.

87
00:05:09,474 --> 00:05:12,977
So you're essentially now your game is only running at 36 FPS,

88
00:05:13,077 --> 00:05:15,719
which is pretty vomit-inducing in VR.

89
00:05:15,860 --> 00:05:19,163
So you have to be really careful and strict about these budgets.

90
00:05:20,244 --> 00:05:23,347
So the tools in the debug environment,

91
00:05:23,387 --> 00:05:25,148
you have OVR metrics tool.

92
00:05:25,689 --> 00:05:29,532
That's pretty useful for a heads-up display that

93
00:05:29,552 --> 00:05:31,234
gives you some stats, particularly FPS.

94
00:05:31,734 --> 00:05:33,176
So if you're running a shipping build,

95
00:05:33,376 --> 00:05:34,917
you don't have a lot of your tools available.

96
00:05:35,398 --> 00:05:42,381
This is a nice handy way to just get some data when you're validating one of those final shipping builds.

97
00:05:42,821 --> 00:05:44,221
RenderDoc is really vital.

98
00:05:48,443 --> 00:05:52,625
It will really let you inspect what is happening in your scene.

99
00:05:53,065 --> 00:05:57,127
So if you're using Unreal, using a material editor, like a graphical editor,

100
00:05:58,567 --> 00:06:03,449
for your materials, it's a graphical tool, you connect some nodes together, and then that outputs some shader code.

101
00:06:03,949 --> 00:06:04,170
Well...

102
00:06:05,010 --> 00:06:09,415
You don't really know what it's outputting unless you really look at it, and sometimes

103
00:06:09,435 --> 00:06:12,419
the results can surprise you and they can be less than efficient.

104
00:06:14,321 --> 00:06:17,244
And you can also look at your draw call costs.

105
00:06:18,078 --> 00:06:24,264
So you have to be really mindful of the fact that unlike the normal, you know, traditional

106
00:06:24,324 --> 00:06:28,949
architectures, your draw calls are impacted by this GPU binning process because your draw

107
00:06:28,969 --> 00:06:30,691
calls don't immediately go and render.

108
00:06:30,711 --> 00:06:33,774
They have to go through this binning process, which means all your draw call costs are a

109
00:06:33,814 --> 00:06:33,994
little...

110
00:06:35,600 --> 00:06:39,283
grow a little bit, but you do get a relative cost to your

111
00:06:39,303 --> 00:06:41,845
draw calls to understand what's expensive, because not all

112
00:06:41,865 --> 00:06:42,886
draw calls are equal.

113
00:06:44,227 --> 00:06:47,130
You have a budget of $100, $150, but some draw calls are

114
00:06:47,190 --> 00:06:48,651
more expensive than other draw calls.

115
00:06:49,191 --> 00:06:50,232
So it's just a rough target.

116
00:06:51,553 --> 00:06:56,798
Snapdragon is good for just seeing how your threads are

117
00:06:56,998 --> 00:06:59,960
lined up, so you can see if you have scheduling issues, if

118
00:06:59,980 --> 00:07:00,861
you're stalling on things.

119
00:07:02,382 --> 00:07:03,463
Then you have Android Studio.

120
00:07:03,483 --> 00:07:03,963
So.

121
00:07:05,406 --> 00:07:10,329
We really, even with PlayStation, we really advocate trying to develop as much as possible on the PC.

122
00:07:10,369 --> 00:07:11,870
The iteration time is so much faster.

123
00:07:12,050 --> 00:07:13,411
You just click play and you're there.

124
00:07:13,591 --> 00:07:16,633
You know, with a Quest, you have to deploy to the target platform.

125
00:07:16,673 --> 00:07:18,054
It's a long process.

126
00:07:19,958 --> 00:07:23,120
But every once in a while, you do have to debug on the target

127
00:07:23,140 --> 00:07:23,560
platform.

128
00:07:23,840 --> 00:07:25,261
So most of the time you're running gameplay code.

129
00:07:25,841 --> 00:07:27,481
If there's a bug in your gameplay code,

130
00:07:27,621 --> 00:07:28,982
it's not really platform specific.

131
00:07:29,042 --> 00:07:32,343
But every once in a while, there's something that shows up.

132
00:07:32,623 --> 00:07:35,664
So we advocate you to use Android Studio over Visual

133
00:07:35,684 --> 00:07:38,085
Studio, because with Visual Studio, we saw that sometimes

134
00:07:38,205 --> 00:07:40,346
even stepping a line of code could take like 20 seconds.

135
00:07:40,906 --> 00:07:41,767
It was just way slower.

136
00:07:42,887 --> 00:07:45,748
And on the topic of using PC to iterate,

137
00:07:46,329 --> 00:07:49,330
so I'm sorry if everything is kind of unreal.

138
00:07:50,142 --> 00:07:51,922
context because we're Unreal developers.

139
00:07:52,302 --> 00:07:54,303
Some of these things are still applicable to other engines.

140
00:07:54,363 --> 00:07:57,624
But with Unreal, you can basically launch the engine

141
00:07:57,944 --> 00:08:00,005
with these console parameters

142
00:08:00,265 --> 00:08:02,886
that essentially emulate the hardware

143
00:08:03,006 --> 00:08:05,467
rendering capabilities of the Quest,

144
00:08:05,527 --> 00:08:07,588
or at least the rendering hardware interface,

145
00:08:07,968 --> 00:08:10,329
so that you get a more accurate representation

146
00:08:10,529 --> 00:08:12,790
of how the scene will look on your PC.

147
00:08:13,110 --> 00:08:14,170
Of course, it's not as good, once again,

148
00:08:14,230 --> 00:08:16,271
as testing on a target platform,

149
00:08:16,291 --> 00:08:17,751
but really try to use as many...

150
00:08:18,654 --> 00:08:21,776
So, we got the thing to compile and deploy the device and very disappointingly the things

151
00:08:22,256 --> 00:08:23,517
just crashed on startup.

152
00:08:36,264 --> 00:08:37,105
So that's not fun, right?

153
00:08:37,225 --> 00:08:38,126
So what's going on with us?

154
00:08:38,226 --> 00:08:39,508
So we're running out of memory.

155
00:08:39,548 --> 00:08:41,150
So most likely, it's going to happen to you too.

156
00:08:41,230 --> 00:08:45,515
If you're developing for a much more powerful platform

157
00:08:45,535 --> 00:08:47,717
with a lot of memory, you're most likely

158
00:08:47,737 --> 00:08:48,999
going to start running out of memory

159
00:08:49,059 --> 00:08:50,300
as your first kind of.

160
00:08:50,978 --> 00:08:52,318
I'm going to show you how to do that.

161
00:08:52,418 --> 00:08:57,019
So, Quest only has 2.75 gigabytes of RAM for your application.

162
00:08:57,039 --> 00:09:03,140
That's pretty small in comparison to, like, desktops that have 16 gigabytes of RAM nowadays, easily.

163
00:09:04,180 --> 00:09:06,881
So, in Unreal, you can use a console command, memory port full.

164
00:09:07,561 --> 00:09:12,122
That would just give you a nice memory port of everything that's loaded in your scene.

165
00:09:12,602 --> 00:09:13,882
All the textures, et cetera.

166
00:09:14,802 --> 00:09:16,223
Static meshes, assets.

167
00:09:17,363 --> 00:09:24,967
You know, game game objects, actor instances, and for us textures were easily the thing that was blowing us way past the budget.

168
00:09:24,987 --> 00:09:32,110
So as a quick hack, we just like globally clamped all the textures to really small size just to let us launch.

169
00:09:32,930 --> 00:09:36,192
The game on the device just to start playing around with it.

170
00:09:36,392 --> 00:09:38,352
I mean, you can just clamp it to like 32 by 32.

171
00:09:38,872 --> 00:09:41,854
Everything will look like Doom from the 90s,

172
00:09:41,914 --> 00:09:43,094
but at least a launch.

173
00:09:43,874 --> 00:09:46,255
And definitely use ASDC compression.

174
00:09:46,375 --> 00:09:51,017
So this will shrink your texture sizes, which is great,

175
00:09:51,177 --> 00:09:54,158
obviously, for once again, managing the RAM applications.

176
00:09:54,198 --> 00:09:56,859
But it's also great for perf, because now the GPU

177
00:09:57,479 --> 00:09:58,079
doesn't have to.

178
00:09:59,872 --> 00:10:04,517
load the textures in the GPU.

179
00:10:04,637 --> 00:10:08,321
So smaller textures will mean the GPU can do its work faster.

180
00:10:09,422 --> 00:10:15,208
So after we got our mem report, we found that a lot of our assets were loaded that we didn't

181
00:10:15,348 --> 00:10:16,249
need to.

182
00:10:16,549 --> 00:10:20,974
This was the result of us being kind of sloppy because we could get away with it on PlayStation

183
00:10:20,994 --> 00:10:21,734
VR and we weren't…

184
00:10:22,055 --> 00:10:23,635
So, we're not quite hitting that memory limit.

185
00:10:23,655 --> 00:10:30,797
So, in Unreal, there's a console command that essentially allows you to get the reference paths to any asset.

186
00:10:31,057 --> 00:10:35,898
So, we essentially did a dive through, found textures that were questionable,

187
00:10:36,118 --> 00:10:41,599
like why is this UI texture loaded in the middle of the game that's normally from the main menu, things of that nature.

188
00:10:42,539 --> 00:10:46,940
So, for us, this has actually been still, I mean, to this day, often a...

189
00:10:47,801 --> 00:10:54,513
I should mention that the UMG is the usual culprit of a lot of stuff being loaded that shouldn't be loaded.

190
00:10:56,664 --> 00:10:58,506
A lot of different UMG widgets.

191
00:10:59,466 --> 00:11:01,268
UMG is the framework for UI in Unreal.

192
00:11:01,768 --> 00:11:04,230
Just referencing a bunch of things that it shouldn't reference.

193
00:11:05,511 --> 00:11:08,814
Referencing characters from different game modes, etc.

194
00:11:09,675 --> 00:11:11,376
And UI textures also do not stream.

195
00:11:12,037 --> 00:11:15,620
So that's an additional kind of gotcha in Unreal.

196
00:11:15,640 --> 00:11:17,982
So that really increases the problem.

197
00:11:19,243 --> 00:11:22,726
And then we had a lot of unnecessary hard references to assets.

198
00:11:23,306 --> 00:11:29,091
So for example, we'll have a data table for a system that refers to, say, character assets

199
00:11:29,731 --> 00:11:34,455
or audio for some system for every single map or for every single character.

200
00:11:34,615 --> 00:11:39,599
Well, in Creed, you're only ever in one ring, and you're only ever fighting one character.

201
00:11:40,099 --> 00:11:43,302
So instead of having those be as hard references,

202
00:11:43,362 --> 00:11:45,684
there should really be soft references, so dynamically loading them.

203
00:11:46,444 --> 00:11:53,968
And somewhat Unreal specific, but just in general, you should try to avoid blueprint dependencies.

204
00:11:54,908 --> 00:12:03,492
Blueprints are, you know, the essentially the archetypes, templates of an actor that is spawned or like a prefab if you use Unity.

205
00:12:04,092 --> 00:12:10,115
So sometimes people don't realize that casting a blueprint class to another class is a hard reference because you essentially need to...

206
00:12:10,535 --> 00:12:16,438
access its functions and properties etc. So it's better to use an interface potentially to break

207
00:12:16,458 --> 00:12:20,720
that up if you want to make a blueprint interface or just move the reference function or variable to

208
00:12:20,740 --> 00:12:27,743
C++ so you can just cast to a C++ base class because accessing the C++ class doesn't require

209
00:12:27,763 --> 00:12:34,166
you to load the blueprint class reference. So anyway so let's move on to optimization time so

210
00:12:34,926 --> 00:12:36,587
allegedly this is where the fun begins.

211
00:12:38,007 --> 00:12:38,428
Um so

212
00:12:39,345 --> 00:12:41,107
Let's find the bottleneck.

213
00:12:41,247 --> 00:12:45,310
You know, with optimization, you should really do it in a data-driven manner.

214
00:12:45,451 --> 00:12:51,456
Figure out what's actually costing you, you know, wasting your cycles and target that.

215
00:12:52,697 --> 00:12:56,420
And this is kind of potentially not a very scientific approach of trial and error.

216
00:12:57,141 --> 00:12:59,302
So in Unreal, there's a stat unit command.

217
00:12:59,322 --> 00:13:01,124
It's pretty standard to like get a...

218
00:13:01,992 --> 00:13:05,197
You can see the frame timing and see how much your threads are taking.

219
00:13:05,718 --> 00:13:11,909
But it's a little useless because, you know, as I mentioned, you're basically locked to

220
00:13:11,949 --> 00:13:12,590
72 frames per second.

221
00:13:12,610 --> 00:13:15,695
So your frame time is always going to be like 14 milliseconds or whatever.

222
00:13:16,160 --> 00:13:19,543
and then your game thread is potentially going to be waiting on the draw thread to catch up.

223
00:13:20,004 --> 00:13:25,349
So really you want to be trying to isolate what it is that's causing you to go over the budget.

224
00:13:25,909 --> 00:13:30,453
So the trial and error here is if you think it's the CPU thread, just pause and unpause the game.

225
00:13:30,674 --> 00:13:32,435
That would just pause all your gameplay logic.

226
00:13:32,870 --> 00:13:34,431
And if your frame rate suddenly stabilizes,

227
00:13:34,531 --> 00:13:35,752
then you know that's your bottleneck.

228
00:13:36,213 --> 00:13:37,154
If you think it's your fill rate,

229
00:13:37,374 --> 00:13:42,058
so fill rate being the cost of shading every single pixel,

230
00:13:42,479 --> 00:13:45,281
we'll just decrease the screen resolution to like 10%.

231
00:13:46,022 --> 00:13:47,804
And if suddenly your frame rate stabilizes,

232
00:13:47,864 --> 00:13:49,165
then you know that's your bottleneck.

233
00:13:49,765 --> 00:13:52,988
Shaders in Unreal is a show materials console command,

234
00:13:53,229 --> 00:13:55,391
which essentially just turns off all the shaders.

235
00:13:55,451 --> 00:13:58,433
Everything is just shaded with like a standard gray shader.

236
00:13:59,402 --> 00:14:04,385
And draw calls, there's constant commands to toggle specific objects, like show static

237
00:14:04,425 --> 00:14:05,726
meshes, show skeleton meshes.

238
00:14:06,206 --> 00:14:10,169
Once again, if you just hide all your static meshes and your frame rate stabilizes, you

239
00:14:10,189 --> 00:14:12,170
know that's the thing that's bringing you over your budget.

240
00:14:13,865 --> 00:14:18,168
So once you kind of start isolating your general bottleneck,

241
00:14:18,509 --> 00:14:20,250
that's when you want to start drilling into the stats.

242
00:14:20,270 --> 00:14:26,114
So Unreal has a pretty complex stat system, essentially,

243
00:14:26,695 --> 00:14:29,477
and you type in stat space and the stat group name.

244
00:14:29,617 --> 00:14:35,601
So stat RHI, stat scene rendering, those are some good examples of stats

245
00:14:35,742 --> 00:14:37,543
that give you an idea of what's going on.

246
00:14:39,224 --> 00:14:42,365
StatRHI, for example, will tell you how many draw calls you're doing,

247
00:14:42,425 --> 00:14:44,846
like how much memory you have loaded for your GPU.

248
00:14:45,327 --> 00:14:50,969
StatSceneRendering lets you further drill into what your render thread is doing.

249
00:14:51,129 --> 00:14:57,031
So you might see that shadow or culling is taking a really long time.

250
00:14:57,632 --> 00:15:02,434
So one thing you have to keep in mind is that this stat system is really complex in Unreal,

251
00:15:02,574 --> 00:15:03,494
which means it also

252
00:15:05,155 --> 00:15:09,341
It really affects perf. It distorts the numbers it reports.

253
00:15:10,282 --> 00:15:18,313
I don't remember the numbers on the Quest, but just on PlayStation, just turning on any one of these stats just suddenly adds 2 milliseconds to your CPU.

254
00:15:18,808 --> 00:15:22,429
which can easily just kick you over your budget.

255
00:15:22,569 --> 00:15:24,589
So now all of a sudden you're waiting for an extra frame,

256
00:15:24,609 --> 00:15:25,630
your stats get distorted.

257
00:15:25,650 --> 00:15:27,050
So that's kind of useless.

258
00:15:27,590 --> 00:15:29,351
And on the other hand, kind of hilariously,

259
00:15:29,411 --> 00:15:32,092
the stat rendering is using this really antiquated

260
00:15:33,372 --> 00:15:35,613
UI rendering system called Canvas.

261
00:15:35,833 --> 00:15:37,633
So most of Unreal now uses Slate.

262
00:15:38,273 --> 00:15:40,354
And those, like each character is like adding

263
00:15:40,374 --> 00:15:41,374
like a draw call or something.

264
00:15:41,814 --> 00:15:43,435
So then once again, you use this system

265
00:15:43,555 --> 00:15:44,775
and it's just distorting your numbers.

266
00:15:45,475 --> 00:15:49,756
So as a kind of quick work around, of course, it's better

267
00:15:49,776 --> 00:15:52,517
to use RenderDoc if you really want to have a deep dive

268
00:15:52,537 --> 00:15:57,318
through. But it's convenient to be able to just have a glance

269
00:15:57,358 --> 00:15:59,858
at your stats so you can have QA running through all your

270
00:15:59,878 --> 00:16:04,359
maps and kind of record any bottlenecks, any hot areas. We

271
00:16:04,399 --> 00:16:09,480
created a lightweight slate widget that has some stats that

272
00:16:09,880 --> 00:16:12,301
we decided that are kind of useful that we show there.

273
00:16:13,941 --> 00:16:16,222
It's rendered using Slate, so it doesn't impact performance.

274
00:16:16,762 --> 00:16:19,484
And it's composed on the screen using this debug draw service.

275
00:16:21,564 --> 00:16:23,005
It shows the average and max values.

276
00:16:23,225 --> 00:16:27,367
So that's useful because I caught our world tick time.

277
00:16:27,967 --> 00:16:30,048
The average was good, but the tick time

278
00:16:30,068 --> 00:16:32,689
was like 10 milliseconds higher.

279
00:16:33,049 --> 00:16:35,370
And I realized just from there, then I did a profile.

280
00:16:35,390 --> 00:16:36,511
And I realized every like

281
00:16:36,990 --> 00:16:41,313
幾 milliseconds. We had something taking 10 milliseconds. So we had these spikes causing

282
00:16:42,073 --> 00:16:47,156
irregular framerate. And we have Iionized defining the budget for text color coding,

283
00:16:47,236 --> 00:16:52,819
so green is good. Yellow is probably a danger zone. Red is definitely bad. That's convenient

284
00:16:52,859 --> 00:16:56,460
as well because we define different budgets for different platforms if you have different

285
00:16:56,580 --> 00:16:57,361
frame rate or etc.

286
00:16:59,342 --> 00:17:02,643
And so there's some existing cached engine values that are already there.

287
00:17:03,523 --> 00:17:05,424
So we can already read them ourselves.

288
00:17:05,564 --> 00:17:07,584
We also modified the engine for some additional values,

289
00:17:07,785 --> 00:17:09,785
specifically world tick time, because like I said,

290
00:17:10,165 --> 00:17:13,666
the game thread time that's reported by stat unit is kind of useless

291
00:17:14,147 --> 00:17:16,948
because that's affected by waiting on the rendering thread, etc.

292
00:17:17,268 --> 00:17:19,628
Most of the time we're really interested in what your world tick time is,

293
00:17:19,648 --> 00:17:21,809
which is where all your gameplay logic is.

294
00:17:21,909 --> 00:17:23,710
That's the thing you're going to be optimizing most of the time.

295
00:17:26,257 --> 00:17:28,998
So CPU in Unreal, it's pretty standard.

296
00:17:29,018 --> 00:17:31,319
We stat star files, stat star files.

297
00:17:31,499 --> 00:17:32,260
It's a constant command.

298
00:17:32,340 --> 00:17:33,680
Use session front end.

299
00:17:33,940 --> 00:17:36,742
So starting in 4.23, Unreal Insights is coming.

300
00:17:36,782 --> 00:17:37,802
It's a whole new profiler.

301
00:17:38,022 --> 00:17:39,723
It's way more powerful.

302
00:17:40,543 --> 00:17:44,745
It also does profiling for memory loading, et cetera.

303
00:17:44,805 --> 00:17:46,886
So that's going to make your life way easier.

304
00:17:48,600 --> 00:17:51,423
It's really standard across, really, PlayStation, et cetera.

305
00:17:51,724 --> 00:17:53,566
What we found is moving components

306
00:17:53,626 --> 00:17:55,328
is usually one of the most expensive things,

307
00:17:56,249 --> 00:17:58,912
especially if you have these really deep attachment

308
00:17:58,972 --> 00:17:59,433
hierarchies.

309
00:18:01,984 --> 00:18:07,970
Um, so the simplest is just detach your hidden and disabled scene components like audio components,

310
00:18:07,990 --> 00:18:10,552
effects components, especially if you have like designers working with you.

311
00:18:10,572 --> 00:18:14,636
Sometimes they can be pretty sloppy and they attach all these things that aren't even being

312
00:18:14,716 --> 00:18:16,838
used right now and it's just costing you cycles.

313
00:18:17,259 --> 00:18:22,144
I know it sounds kind of mundane, but honestly, when you're in a really constrained platform,

314
00:18:22,164 --> 00:18:24,266
you really can't get away with just being sloppy like that.

315
00:18:25,046 --> 00:18:25,147
Um.

316
00:18:25,927 --> 00:18:31,270
All right, that's a typo. I don't know what it says. Overlays. That's supposed to say overlaps. My bad.

317
00:18:32,011 --> 00:18:39,215
So overlaps, so it's when you detect that one trigger box is within another trigger box. So

318
00:18:40,055 --> 00:18:46,119
those are really expensive in Unreal. Every time you move a component, then they update the

319
00:18:46,199 --> 00:18:49,661
overlaps. On top of that, it's kind of sloppy the way they wrote them is...

320
00:18:50,706 --> 00:18:54,309
Even if you don't have a single component in the attachment chain that updates an overlap,

321
00:18:54,489 --> 00:18:58,353
it will still go through this entire update overlap chain down the children.

322
00:18:58,473 --> 00:19:00,955
So once again, if you have a long attachment chain, it will go through that.

323
00:19:01,555 --> 00:19:06,419
So as an optimization, we just kind of deleted that because we didn't want to use them.

324
00:19:06,680 --> 00:19:09,042
And that saved us a lot of cycles since we weren't even using overlaps.

325
00:19:10,182 --> 00:19:16,404
Back in starting in raw data, we wrote our own async overlap system that updates overlaps on a worker thread.

326
00:19:17,085 --> 00:19:19,785
And that doesn't block your thread every time you move an object.

327
00:19:20,686 --> 00:19:25,127
Obviously it's deferred, but we use events for when overlaps happen anyway.

328
00:19:25,767 --> 00:19:29,068
So that's been a huge kind of optimization for us.

329
00:19:29,949 --> 00:19:32,869
I know it's easy to say, hey, my hand is close to this bottle.

330
00:19:32,889 --> 00:19:34,810
I'm just going to stick one trigger box in the hand,

331
00:19:34,890 --> 00:19:35,990
one trigger box in the bottle.

332
00:19:36,831 --> 00:19:38,771
You can't be sloppy like that on these platforms,

333
00:19:38,891 --> 00:19:41,472
especially once you start having thousands of bottles and two

334
00:19:41,512 --> 00:19:42,552
hands and touching everything.

335
00:19:43,192 --> 00:19:46,493
So ticking, once again, very simple.

336
00:19:46,553 --> 00:19:48,434
Just disable tick when not needed.

337
00:19:48,454 --> 00:19:50,495
So often, designers just have components,

338
00:19:50,555 --> 00:19:52,595
and actors just tick when they're not even

339
00:19:52,615 --> 00:19:55,016
they just have a flag to disable certain behavior,

340
00:19:55,036 --> 00:19:55,736
but they're still ticking.

341
00:19:56,176 --> 00:19:57,457
So tick interval is another thing.

342
00:19:58,135 --> 00:20:01,558
Often if the things are not significant, they don't even need to tick every frame.

343
00:20:02,539 --> 00:20:06,482
Once something you have to watch out for is in Unreal at least the tick interval,

344
00:20:06,722 --> 00:20:08,383
you can, they added tick intervals.

345
00:20:08,403 --> 00:20:12,106
So you can say like, okay, this tick ticks like once every like 0.1 seconds or

346
00:20:12,126 --> 00:20:14,087
something, but there's no control over which frame you tick.

347
00:20:14,648 --> 00:20:16,969
So now if you have a frame rate hike or whatever.

348
00:20:17,370 --> 00:20:19,270
Now all of a sudden things just get pushed into one frame.

349
00:20:19,290 --> 00:20:21,171
So you have like one frame where a bunch of things tick,

350
00:20:21,211 --> 00:20:22,131
the next frame nothing ticks.

351
00:20:22,171 --> 00:20:23,952
So you really want to load balance.

352
00:20:24,172 --> 00:20:26,272
So we've modified the engine once again to really help us

353
00:20:27,073 --> 00:20:29,994
load balance and tick things in one frame

354
00:20:30,014 --> 00:20:30,834
versus the other frame.

355
00:20:31,554 --> 00:20:33,895
I mean, the easiest is just to say, OK, half the enemy's

356
00:20:33,935 --> 00:20:35,735
ticking this frame, half the enemy's ticking the other frame.

357
00:20:36,104 --> 00:20:39,127
Now all of a sudden, technically, you just did a 50% optimization.

358
00:20:39,408 --> 00:20:39,888
Good job.

359
00:20:41,770 --> 00:20:47,336
So Blueprint logic, it's really slow.

360
00:20:47,796 --> 00:20:50,339
Try not to have any Blueprint logic in Tick.

361
00:20:50,379 --> 00:20:52,021
Try to nativize as much as possible.

362
00:20:52,121 --> 00:20:53,562
Throw in C++ if you can.

363
00:20:54,483 --> 00:20:55,925
Active pooling, just spawning things.

364
00:20:57,006 --> 00:20:59,467
Dynamically is pretty damn expensive.

365
00:20:59,647 --> 00:21:01,688
So we developed our own active polling system,

366
00:21:02,769 --> 00:21:06,310
which automatically disables like physics collision

367
00:21:06,350 --> 00:21:07,151
and a bunch of other things.

368
00:21:07,211 --> 00:21:08,571
So we don't have to do it manually every time.

369
00:21:08,591 --> 00:21:10,452
If you're using UMG UI,

370
00:21:10,472 --> 00:21:12,793
you can't get away without using a validation boxes.

371
00:21:14,054 --> 00:21:16,075
So let's move on to the draw calls.

372
00:21:16,535 --> 00:21:17,716
Make sure to use multi-view.

373
00:21:17,796 --> 00:21:20,337
So multi-view allows you to do one draw call per eye.

374
00:21:21,157 --> 00:21:22,278
Makes no sense not to use it

375
00:21:22,778 --> 00:21:24,139
unless you really want to double your draw calls

376
00:21:24,159 --> 00:21:24,579
for some reason.

377
00:21:26,523 --> 00:21:28,184
Try to merge your geometry as much as possible.

378
00:21:28,224 --> 00:21:31,666
You can do it in Maya or Unreal has a merge actor's feature.

379
00:21:32,566 --> 00:21:35,708
We actually modified Unreal to make an unmerge actor's feature

380
00:21:35,828 --> 00:21:37,709
that we serialized like the previous state.

381
00:21:37,729 --> 00:21:40,951
It's great for iteration, but make sure when you merge things,

382
00:21:40,991 --> 00:21:42,392
you actually minimize the material count,

383
00:21:42,612 --> 00:21:44,053
because even if you merge a whole bunch of...

384
00:21:44,373 --> 00:21:46,774
Actors together, but they're all using different materials still.

385
00:21:47,355 --> 00:21:49,496
That's still each individual draw call per material.

386
00:21:49,896 --> 00:21:52,258
So now you actually just made things worse, to be honest.

387
00:21:53,078 --> 00:21:54,079
Because now things don't call.

388
00:21:54,979 --> 00:21:56,400
So minimize your material count.

389
00:21:56,460 --> 00:21:59,082
Instance as much as you can, if you instant static meshes,

390
00:21:59,962 --> 00:22:00,883
then it's just one draw call.

391
00:22:01,083 --> 00:22:01,563
That's even better.

392
00:22:02,564 --> 00:22:04,025
And like I said, not all draw calls are equal.

393
00:22:04,965 --> 00:22:06,146
Some draw calls are more expensive.

394
00:22:06,506 --> 00:22:07,767
Switching materials is expensive.

395
00:22:07,907 --> 00:22:09,768
Switching meshes is even more expensive.

396
00:22:09,828 --> 00:22:12,110
And actually, the complexity of the mesh

397
00:22:12,250 --> 00:22:13,871
actually affects the draw call cost.

398
00:22:16,246 --> 00:22:22,270
This is a capture of RenderDoc, part of the scene in Creed.

399
00:22:22,910 --> 00:22:24,431
This is actually a stadium piece.

400
00:22:24,491 --> 00:22:29,593
You can see how we merged this one stadium piece all the way from the floor to the ceiling.

401
00:22:30,734 --> 00:22:33,035
We divided the stadium between five to seven pieces,

402
00:22:33,415 --> 00:22:35,857
and we used three shared texture atlases.

403
00:22:37,717 --> 00:22:41,539
In this one capture, you can see the only two textures that attach to this draw call

404
00:22:41,639 --> 00:22:44,441
is essentially the diffuse map and the shadow map.

405
00:22:46,421 --> 00:22:50,927
And so we used three texture atlases across the entire stadium.

406
00:22:51,027 --> 00:22:51,227
So.

407
00:22:54,085 --> 00:22:57,326
Moving on to GPU, disable early Z-pass.

408
00:22:57,466 --> 00:22:58,787
That's an optimization in Unreal.

409
00:22:59,567 --> 00:23:01,628
So early Z-pass is actually redundant

410
00:23:01,949 --> 00:23:02,969
in the tile-based renderer.

411
00:23:03,489 --> 00:23:07,671
So the binning process actually pre-sorts all the triangles

412
00:23:08,952 --> 00:23:13,614
so that it avoids overdraw by only rendering the triangle

413
00:23:13,634 --> 00:23:14,795
that's closest to the screen.

414
00:23:15,195 --> 00:23:17,996
So the Z-pass in Unreal actually counteracts that.

415
00:23:19,097 --> 00:23:20,278
Also, don't use alpha test.

416
00:23:20,898 --> 00:23:21,578
So if you have like a.

417
00:23:22,239 --> 00:23:27,542
texture that tells the pixel like this is transparent or not, actually don't use that.

418
00:23:28,463 --> 00:23:32,845
I know that's like a common optimization, but that actually counteracts once again this early

419
00:23:33,066 --> 00:23:37,869
sorting that happens on the hardware level in the GPU, because the GPU already pre-sorts

420
00:23:37,909 --> 00:23:42,992
all the triangles. So this actually forces it to invalidate that whole calculation.

421
00:23:44,053 --> 00:23:45,073
So get rid of specular.

422
00:23:46,494 --> 00:23:49,816
Specular added about 100 instructions for us per pixel.

423
00:23:50,196 --> 00:23:53,838
I know that's like an entire hard pill to swallow because things are usually shiny in the world.

424
00:23:54,799 --> 00:24:01,903
But for us, like the environment took up most of the screen and just removing that,

425
00:24:02,383 --> 00:24:05,225
Specular just gave us two milliseconds back on the GPU.

426
00:24:05,605 --> 00:24:08,327
So that was pretty massive gains.

427
00:24:08,507 --> 00:24:11,869
We still kept it on the characters because you're boxing, the characters are sweaty.

428
00:24:11,969 --> 00:24:13,770
We wanted to simulate that shininess of their sweat.

429
00:24:16,150 --> 00:24:17,772
and post-processing.

430
00:24:17,832 --> 00:24:20,454
So that's an even tougher pill to swallow

431
00:24:20,654 --> 00:24:24,438
because post-processing just is such an easy way

432
00:24:24,478 --> 00:24:25,980
to just really drastically change

433
00:24:26,020 --> 00:24:27,201
the appearance of the entire scene.

434
00:24:27,662 --> 00:24:29,664
The problem is it really does not play well

435
00:24:29,704 --> 00:24:30,925
with the architecture of the quest

436
00:24:31,445 --> 00:24:32,827
because with post-processing,

437
00:24:32,867 --> 00:24:35,650
essentially you have to do a whole new render pass.

438
00:24:35,710 --> 00:24:37,451
You have to take the rendered image

439
00:24:37,852 --> 00:24:39,293
and you have to pull it back into the...

440
00:24:40,637 --> 00:25:00,330
The process and operate on that again. So, it's just, it's really expensive. Something we're talking about in the future is just modifying our shaders for some just a global shader effects, so that you can potentially like apply apply things on a, you know, per object basis so it's not a screen space effect, but simulate those things.

441
00:25:01,277 --> 00:25:04,518
And also, stay away from dynamic lights.

442
00:25:06,179 --> 00:25:07,019
Fake as much as you can.

443
00:25:07,339 --> 00:25:08,920
It's kind of obvious, I guess.

444
00:25:09,400 --> 00:25:13,121
But we actually faked lighting on a per shader, per object

445
00:25:13,141 --> 00:25:13,922
basis where we needed.

446
00:25:15,102 --> 00:25:20,604
So speaking of faking post-processing and dynamic

447
00:25:20,624 --> 00:25:22,985
lights, so I don't know.

448
00:25:23,065 --> 00:25:23,765
Is that video playing?

449
00:25:24,746 --> 00:25:25,046
It's not?

450
00:25:25,846 --> 00:25:26,066
Sorry.

451
00:25:27,934 --> 00:25:43,564
Okay, so probably should have tested this but essentially it's a ring, there's spotlights floating around, and the spotlights hit the ring and you can actually see a circle. So for the bloom around the spotlights instead of using post processing bloom, just attach a sprite.

452
00:25:46,045 --> 00:26:06,422
And for the actual circle on the ground, what we did is we actually projected, instead of using the dynamic light to calculate how the spotlight affects it, we just projected a circle of patterns on the floor there, and that's way cheaper, only added about 20 instructions, but we didn't want to add, the thing is,

453
00:26:07,442 --> 00:26:09,103
That's 20 instructions for every single pixel.

454
00:26:09,403 --> 00:26:11,805
We didn't want that active during the actual fight

455
00:26:11,865 --> 00:26:13,846
because the spotlights were only floating around the flight

456
00:26:14,707 --> 00:26:16,308
during this intro sequence.

457
00:26:17,148 --> 00:26:19,130
And during the fight, we would have particle systems

458
00:26:19,150 --> 00:26:20,591
and all these other things spawning

459
00:26:20,671 --> 00:26:21,871
and using up more draw calls.

460
00:26:24,994 --> 00:26:27,695
We put in a global if statement to disable that.

461
00:26:28,076 --> 00:26:29,877
One thing you have to watch out for if you're using Unreal

462
00:26:30,557 --> 00:26:32,779
is if statements in the material graph

463
00:26:32,979 --> 00:26:34,640
still actually evaluate both conditions.

464
00:26:35,457 --> 00:26:36,759
And then they choose which one.

465
00:26:37,100 --> 00:26:38,822
So this is something we picked up in RenderDoc.

466
00:26:39,583 --> 00:26:42,807
So instead, we wrote this just in the USF file

467
00:26:42,847 --> 00:26:44,730
where we wrote the actual shader code with the if statement

468
00:26:44,750 --> 00:26:45,030
in there.

469
00:26:45,351 --> 00:26:46,853
And we called that using a custom node.

470
00:26:46,913 --> 00:26:48,195
In Unreal, you can use a custom node

471
00:26:48,215 --> 00:26:51,018
to call into any shader code by name.

472
00:26:52,803 --> 00:26:55,024
So, I mentioned texture atlases.

473
00:26:55,244 --> 00:26:58,245
Make sure to combine all your textures as much as possible.

474
00:26:58,426 --> 00:27:00,226
Like I said, switching between textures

475
00:27:00,306 --> 00:27:03,208
is a pretty expensive draw call operation,

476
00:27:03,488 --> 00:27:05,869
so you want to batch things as much as possible.

477
00:27:06,289 --> 00:27:09,130
So, we used about two, three for each environment.

478
00:27:09,551 --> 00:27:11,731
Make sure you use ASTC compression.

479
00:27:14,873 --> 00:27:16,654
You can use RenderDoc to confirm that,

480
00:27:16,834 --> 00:27:19,175
or Memoryport to confirm that your textures were actually

481
00:27:20,587 --> 00:27:22,109
Successfully converted to STC.

482
00:27:23,230 --> 00:27:26,993
Sometimes textures fail because of some weird things

483
00:27:27,033 --> 00:27:27,693
that the artist did.

484
00:27:29,235 --> 00:27:31,717
Similarly, actually, speaking about texture dimensions,

485
00:27:31,777 --> 00:27:32,678
make sure they're Power of 2.

486
00:27:33,098 --> 00:27:34,219
Just make sure the textures are clean.

487
00:27:34,259 --> 00:27:35,280
Because if they're not Power of 2,

488
00:27:35,320 --> 00:27:37,782
then they won't mipmap properly, and they're not

489
00:27:37,802 --> 00:27:38,643
going to stream properly.

490
00:27:39,964 --> 00:27:42,246
And mipmapping is great for caching, too,

491
00:27:42,306 --> 00:27:44,788
because then it's not going to use the highest res texture

492
00:27:44,828 --> 00:27:46,169
when it doesn't need to when it's far away.

493
00:27:47,911 --> 00:27:50,533
And on the topic of dependent versus independent texture reads,

494
00:27:50,573 --> 00:27:54,216
so dependent here refers to you using one texture's,

495
00:27:54,777 --> 00:27:58,040
you're looking up in one texture and using that result to actually look into another texture.

496
00:27:58,540 --> 00:28:01,403
So we found that the cost here was actually about the same.

497
00:28:01,563 --> 00:28:08,209
So if you can then potentially bake some expensive calculation you're doing at GPU at runtime,

498
00:28:08,309 --> 00:28:11,592
just bake that into a texture and use that to look up into another texture.

499
00:28:14,112 --> 00:28:17,256
MSAA, it's actually cheaper on tile-based renders.

500
00:28:18,097 --> 00:28:21,300
So, and honestly, in VR, you really should be using that.

501
00:28:21,320 --> 00:28:23,623
We ship with 4x MSAA.

502
00:28:24,584 --> 00:28:26,106
Shader hitches was another issue we had.

503
00:28:27,717 --> 00:28:33,280
Basically, any time a particle spawned for the first time in the game, you'd get a hitch.

504
00:28:33,520 --> 00:28:38,442
So, in Unreal, there's a console command, r.saveshadercache,

505
00:28:38,842 --> 00:28:43,324
which basically, we had to run through the entire game, make it as thoroughly as possible,

506
00:28:43,404 --> 00:28:47,306
use this console command, output a binary file with all the shader permutations,

507
00:28:47,326 --> 00:28:48,967
and then you can package with that.

508
00:28:49,387 --> 00:28:53,109
In 4.21, they have this PSO caching feature, which I hear is making that easier.

509
00:28:53,729 --> 00:28:54,309
We had to ship in 4.20.

510
00:28:56,725 --> 00:28:59,608
Fixed foveated rendering, if you don't know what that is,

511
00:28:59,688 --> 00:29:01,910
is essentially rendering the screen at different resolutions

512
00:29:01,990 --> 00:29:03,732
depending on if it's the center of the image

513
00:29:03,792 --> 00:29:04,733
or it's the edges of the image,

514
00:29:04,813 --> 00:29:07,556
since if it's in your peripheral,

515
00:29:07,596 --> 00:29:09,397
it doesn't need to be as high res.

516
00:29:09,998 --> 00:29:13,021
So you can actually control the resolutions of those regions.

517
00:29:13,962 --> 00:29:14,802
I mean, worst case scenario,

518
00:29:14,822 --> 00:29:16,784
you might even have to down res even the center image

519
00:29:16,824 --> 00:29:17,905
if you're really fill rate bound.

520
00:29:19,040 --> 00:29:27,202
And try to avoid long thin triangles because those can really not play nice with the whole binning process because then the the bounding box

521
00:29:27,402 --> 00:29:29,062
I'm still not you know reading online

522
00:29:29,082 --> 00:29:31,183
I'm still confused whether they have dealt with this or not

523
00:29:31,203 --> 00:29:36,364
But essentially as far as I understand the bounding box can make the long thin strips fall into multiple

524
00:29:36,424 --> 00:29:41,905
Tiles where they're not even really contributing any pixels and it you're just making all those tiles more expensive

525
00:29:43,567 --> 00:29:45,929
I'm going to talk about the fact that it's shared bandwidth.

526
00:29:46,129 --> 00:29:49,412
So that does mean that if you're doing some expensive stuff on the CPU with the memory,

527
00:29:49,492 --> 00:29:54,756
it can actually affect the GPU and vice versa, which once again is useful to be able to toggle

528
00:29:54,936 --> 00:29:58,519
one of the processes on and off to figure out which one's actually causing the bottlenecks.

529
00:29:59,740 --> 00:30:01,061
Some memory stomp tracking.

530
00:30:02,833 --> 00:30:07,215
Essentially, if you have somewhere writing or reading

531
00:30:07,275 --> 00:30:10,396
into memory that it doesn't actually own some de-allocated

532
00:30:10,436 --> 00:30:14,177
memory blocks, Unreal has a Memory Stomp allocator

533
00:30:15,018 --> 00:30:16,118
that you can compile with.

534
00:30:16,178 --> 00:30:19,199
But we found out that it caused the game to crash relatively

535
00:30:19,219 --> 00:30:20,700
fast because it really pads all the memory.

536
00:30:22,221 --> 00:30:27,148
So, like I said, ideally you test on the PC, but we had this case where our game was crashing

537
00:30:27,208 --> 00:30:31,253
like five times a day, randomly in like random regions.

538
00:30:31,313 --> 00:30:36,360
So we knew it was a memory stomp and it was only happening on the Creed, on the quest

539
00:30:36,420 --> 00:30:36,700
build.

540
00:30:36,780 --> 00:30:39,123
So it was a pretty kind of...

541
00:30:40,004 --> 00:30:44,705
So we found out that you can use essentially the built-in Android memory stomp allocator here.

542
00:30:45,365 --> 00:30:52,506
And we caught this stomp happening deep inside of the OVR compositor, specifically related to the splash page.

543
00:30:53,206 --> 00:31:03,008
So essentially in their load screen pop push functionality, they were accidentally writing over some memory that they didn't own.

544
00:31:03,368 --> 00:31:06,129
So we helped them fix that crash in their system.

545
00:31:07,837 --> 00:31:14,603
And yeah, so other general tips, they, you know, just like PlayStation VR, there's some

546
00:31:14,643 --> 00:31:20,107
TRCs related to how fast, you know, the game loads, how long you spend before you show

547
00:31:20,127 --> 00:31:20,708
the load screen.

548
00:31:21,368 --> 00:31:26,172
So what we've been doing basically for our titles is we usually load into an empty room

549
00:31:26,212 --> 00:31:26,452
first.

550
00:31:27,573 --> 00:31:33,798
And then, because if you have, if you're trying to load into your regular map first,

551
00:31:34,278 --> 00:31:39,602
it will try to load that and you just won't, will not be able to push the load screen fast enough,

552
00:31:39,742 --> 00:31:45,787
the game will just be stalling. But even there, there's often issues with just global assets

553
00:31:45,807 --> 00:31:50,050
being referenced, like global managers referencing some assets with hard references where they're not

554
00:31:50,070 --> 00:31:50,490
needed, etc. So.

555
00:31:51,992 --> 00:31:55,135
You're going to need to break those reference chains if you want to have a quick load time.

556
00:31:56,056 --> 00:32:02,501
Audio, the Unreal, the audio, the default Android audio does not actually spatialize audio.

557
00:32:03,021 --> 00:32:04,543
At least it didn't when we shipped.

558
00:32:05,563 --> 00:32:12,329
And so you can use Android, audio mixer Android or other third-party plugins for spatialization.

559
00:32:12,989 --> 00:32:16,052
It actually messed up all our mixing and we had to ship.

560
00:32:16,452 --> 00:32:19,295
So unfortunately we shipped without spatialization because

561
00:32:19,875 --> 00:32:21,536
it was either the audio team was going to somehow...

562
00:32:23,028 --> 00:32:25,169
I don't know, try to redo all our audio for the entire game,

563
00:32:25,189 --> 00:32:25,750
why not chip?

564
00:32:25,770 --> 00:32:27,771
So yeah.

565
00:32:27,891 --> 00:32:31,072
So that's about it from all the tips.

566
00:32:32,112 --> 00:32:33,733
Does anyone have any questions?

567
00:32:38,215 --> 00:32:39,676
Sorry, that was pretty, I don't know

568
00:32:39,696 --> 00:32:43,057
if you guys were ready for such a technical deep dive

569
00:32:43,297 --> 00:32:43,677
or whatever.

570
00:32:43,697 --> 00:32:44,238
I don't know.

571
00:32:44,478 --> 00:32:47,159
Hopefully that was useful to people

572
00:32:47,439 --> 00:32:48,820
who are thinking about targeting the Quest.

573
00:32:49,715 --> 00:32:53,897
Hey, that was really interesting and useful because I am in the same boat of thinking about porting.

574
00:32:53,917 --> 00:33:00,101
But I have a more general question on, like, once you've done it and you've got it working on the Quest,

575
00:33:00,521 --> 00:33:05,463
but you primarily develop on PC, like, how do you keep your integration working and keep, you know,

576
00:33:05,483 --> 00:33:08,705
because it's such a pain, like, trying to test it again and again and again.

577
00:33:08,725 --> 00:33:14,288
I'm just curious, how do you manage that, making sure your developers continue to keep it working once you've done the original port?

578
00:33:14,548 --> 00:33:18,509
Yeah, well, so what, that's why I don't like the word port, it's

579
00:33:18,549 --> 00:33:21,809
more parallel development, right? So you choose your your

580
00:33:21,929 --> 00:33:27,630
you choose your targets queue. And you, you have, ideally, qA

581
00:33:27,991 --> 00:33:31,991
that hammer on this build. Every day, you have continuous

582
00:33:32,031 --> 00:33:35,152
integration. So Jenkins or something that basically outputs

583
00:33:35,172 --> 00:33:39,253
these builds on a daily or hourly basis, and then daily

584
00:33:39,293 --> 00:33:41,333
basis, depending on, you know, if it's a full package,

585
00:33:41,373 --> 00:33:41,753
whatever. And

586
00:33:43,114 --> 00:33:45,536
You have QA actually testing these things on a regular basis

587
00:33:45,576 --> 00:33:49,119
so that they can catch issues really as fast as possible.

588
00:33:49,699 --> 00:33:51,401
So it's definitely a lot of process.

589
00:33:52,382 --> 00:33:55,084
And I'm not saying it's perfect.

590
00:33:55,164 --> 00:33:59,327
It's a constant battle of you getting in fights with other

591
00:33:59,347 --> 00:34:00,468
people because they break things.

592
00:34:00,708 --> 00:34:01,809
So yeah.

593
00:34:04,111 --> 00:34:04,211
Hi.

594
00:34:04,492 --> 00:34:04,792
Thank you.

595
00:34:05,773 --> 00:34:07,614
First off, are your slides going to be available?

596
00:34:07,634 --> 00:34:07,914
Do you know?

597
00:34:07,934 --> 00:34:09,315
Yeah, I can upload them.

598
00:34:09,335 --> 00:34:09,456
Yeah.

599
00:34:10,401 --> 00:34:15,007
And when you were mentioning some console commands, except for the few that were ADB,

600
00:34:16,128 --> 00:34:18,211
was that the Unreal console you were talking about?

601
00:34:18,231 --> 00:34:19,993
Yeah, it's all in the Unreal.

602
00:34:20,294 --> 00:34:21,135
All right, thank you.

603
00:34:23,962 --> 00:34:29,346
Hi, I was wondering for people starting to develop a new experience,

604
00:34:29,626 --> 00:34:34,349
would you recommend that they start by developing it on Rift and then port to Quest,

605
00:34:34,549 --> 00:34:40,212
or start on Quest and then add more stuff to take advantage of the higher performance on Rift?

606
00:34:40,653 --> 00:34:46,376
Well, you would always be kind of developing alongside because all your testing is probably,

607
00:34:46,476 --> 00:34:51,640
most of your iteration is going to be on PC. But if you're going to try to launch into Quest,

608
00:34:52,470 --> 00:34:55,951
Like a said avoid porting, try to launch that thing on the quest as soon as

609
00:34:55,991 --> 00:34:58,152
possible so you can at least periodically see that

610
00:34:58,532 --> 00:35:01,212
when you add things you didn't just blow yourself way past the budget

611
00:35:01,512 --> 00:35:03,593
because now you added twenty things and they're all

612
00:35:03,993 --> 00:35:07,554
past the budget and you have to determine what needs to be cut and what

613
00:35:07,614 --> 00:35:08,294
doesn't so

614
00:35:09,174 --> 00:35:11,375
it's always easier to add things than remove things

615
00:35:12,335 --> 00:35:14,055
Yeah removing things is killing your babies

616
00:35:14,975 --> 00:35:16,796
adding things is making more babies I guess

617
00:35:17,729 --> 00:35:20,130
That's interesting. I hear a lot of people say the opposite, actually.

618
00:35:20,631 --> 00:35:21,091
What do you mean?

619
00:35:21,631 --> 00:35:24,493
Just focus on developing the experience first without worrying about performance

620
00:35:24,533 --> 00:35:26,994
and then kind of

621
00:35:27,014 --> 00:35:27,835
do that after the fact.

622
00:35:28,175 --> 00:35:29,295
It's I guess it.

623
00:35:29,335 --> 00:35:32,097
I don't know. Question of philosophy.

624
00:35:32,117 --> 00:35:34,378
All right. Thank you. Yeah.

625
00:35:35,479 --> 00:35:36,940
Hi there. Thanks. That was really interesting.

626
00:35:37,280 --> 00:35:41,002
Can you tell us anything at all or comment at all about the submission process

627
00:35:41,062 --> 00:35:43,983
and how quickly they're turning approvals and communication at all?

628
00:35:45,104 --> 00:35:45,124
I.

629
00:35:48,621 --> 00:35:55,987
I don't know if I can really give an accurate estimation of that because A, I'm on the software

630
00:35:56,008 --> 00:35:58,930
side really so I'm not part of the schmoozing process.

