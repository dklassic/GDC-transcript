1
00:00:06,897 --> 00:00:08,498
Hello, my name is Alina Hill.

2
00:00:09,138 --> 00:00:11,780
This talk is called Make Your Game Run on the Quest

3
00:00:12,100 --> 00:00:12,901
and Look Pretty Too.

4
00:00:13,661 --> 00:00:15,523
We'll be talking about art optimization

5
00:00:16,063 --> 00:00:17,824
on the Oculus Quest VR headset

6
00:00:18,285 --> 00:00:19,926
and how to make art assets

7
00:00:20,446 --> 00:00:21,987
which will look good and perform well.

8
00:00:23,148 --> 00:00:24,609
We'll cover the basic do's and don'ts

9
00:00:24,649 --> 00:00:26,070
for asset creation and setup

10
00:00:26,490 --> 00:00:28,532
and how visual choices can impact performance.

11
00:00:31,794 --> 00:00:33,675
So a bit about me and why I'm giving this talk.

12
00:00:34,696 --> 00:00:39,599
I'm a 3D artist and art manager at the indie studio Phenomena, here in San Francisco.

13
00:00:40,400 --> 00:00:45,523
I spend most of my time creating art assets, breaking down art assets, and setting up assets in game.

14
00:00:46,283 --> 00:00:49,966
I worked on the title Luna, shown here, which was my first VR title.

15
00:00:50,466 --> 00:00:57,491
Since then, I've worked on a few more AR VR projects, including two VR projects developed exclusively for the Quest.

16
00:00:58,479 --> 00:01:02,423
Our first Quest project was in development before the device was released, and the latest

17
00:01:02,463 --> 00:01:05,046
project is releasing in about a month or two.

18
00:01:07,368 --> 00:01:11,052
Unfortunately I can't show stills from either of these projects today, so I have to bear

19
00:01:11,072 --> 00:01:12,274
with some of my art tests.

20
00:01:16,778 --> 00:01:17,879
So why am I giving this talk?

21
00:01:19,178 --> 00:01:25,202
Well, even though I had already shipped a VR game, when we first got our Quest devices, I was honestly pretty mystified.

22
00:01:25,222 --> 00:01:29,505
I'm not a performance engineer, so there's a lot I don't know about how rendering works,

23
00:01:30,345 --> 00:01:34,408
but I still needed to make a lot of decisions about how to make art assets for this device.

24
00:01:35,608 --> 00:01:39,691
It was hard for me to know what art assets were going to be a problem and what was not.

25
00:01:40,431 --> 00:01:43,073
Should I treat it like a mobile phone or like a VR game?

26
00:01:43,920 --> 00:01:45,461
Or a VR game running on min-spec?

27
00:01:45,821 --> 00:01:47,921
And how would all of this affect the overall look of the game?

28
00:01:48,282 --> 00:01:49,102
I wasn't sure.

29
00:01:52,103 --> 00:01:53,683
There were some guides and documentation

30
00:01:53,703 --> 00:01:54,523
that got me started.

31
00:01:54,963 --> 00:01:56,184
And there are fortunately more now.

32
00:01:56,684 --> 00:01:58,484
But the guides and the documentation

33
00:01:58,584 --> 00:01:59,405
were pretty technical.

34
00:02:00,065 --> 00:02:01,805
What I needed was more practical,

35
00:02:02,025 --> 00:02:04,046
less here's how the hardware works,

36
00:02:04,306 --> 00:02:06,887
guidelines geared towards art production and direction

37
00:02:07,287 --> 00:02:09,007
that covered a wide range of asset types,

38
00:02:09,047 --> 00:02:11,088
tools, techniques, and their limitations.

39
00:02:12,307 --> 00:02:16,571
So that's what I'm trying to put together here, a practical guide for those of you who are new to the Quest,

40
00:02:17,051 --> 00:02:19,693
but who really want to make your game look beautiful on this cool new device.

41
00:02:22,216 --> 00:02:27,060
Speaking of the Quest, let's start there. How cool is it that we have a mobile VR headset now?

42
00:02:27,840 --> 00:02:32,124
Honestly, I had a lot of fun after the Quest launched sharing games with people in unexpected places.

43
00:02:33,225 --> 00:02:34,586
Did you know it still works on a train?

44
00:02:35,967 --> 00:02:39,390
But what I love about this device is that it really changes who can access VR.

45
00:02:40,080 --> 00:02:44,482
Most people don't get sick from it, since the 6th off is pretty good, but also you don't

46
00:02:44,522 --> 00:02:46,583
need a gaming PC to run a VR app.

47
00:02:48,023 --> 00:02:51,624
Those two things alone just blow open the doors on who can access VR.

48
00:02:52,305 --> 00:02:56,266
In a lot of the talks I've seen, this is normally where the speaker would explain the Quest's

49
00:02:56,346 --> 00:03:02,108
cool new tile renderer and how it's able to do what it does because it changes the buffer

50
00:03:02,248 --> 00:03:07,930
fragment meatmorp or whatever, but I make art, so if that interests you, please learn

51
00:03:07,970 --> 00:03:08,790
about it from an engineer.

52
00:03:10,007 --> 00:03:12,149
What you need to know, or what I needed to know is,

53
00:03:12,769 --> 00:03:14,451
what are its restrictions as a mobile device

54
00:03:14,471 --> 00:03:15,431
when it comes to rendering?

55
00:03:16,152 --> 00:03:17,673
What are its VR restrictions?

56
00:03:18,153 --> 00:03:20,755
And what are the special Quest-only restrictions?

57
00:03:21,356 --> 00:03:22,677
Because restrictions aren't bad,

58
00:03:23,097 --> 00:03:25,219
they just change the artistic decisions we make,

59
00:03:25,659 --> 00:03:27,180
and so we need to know what they are

60
00:03:27,781 --> 00:03:29,462
so we can learn how to work with them.

61
00:03:30,857 --> 00:03:35,560
I'll go over a variety of these restrictions or performance guidelines, whatever you want

62
00:03:35,580 --> 00:03:39,762
to call them, but the first one I want to discuss is the one I had the least familiarity

63
00:03:39,802 --> 00:03:41,883
with when I started my first Quest project.

64
00:03:44,064 --> 00:03:45,265
Let's talk about draw calls.

65
00:03:46,866 --> 00:03:51,628
I sometimes go to schools and tell classrooms full of kids what my job is and how cool and

66
00:03:51,668 --> 00:03:52,369
creative it is.

67
00:03:53,349 --> 00:03:56,811
They always seem to ask, it's art, but you use computers.

68
00:03:57,571 --> 00:03:58,912
So do you do a lot of math?

69
00:04:00,237 --> 00:04:04,917
I usually lie and say no, because while I do some math every day, it's usually pretty

70
00:04:04,977 --> 00:04:09,858
simple, and anyone who can learn to use a 3D modeling program can probably learn to

71
00:04:09,898 --> 00:04:13,019
type 360 divided by whatever into a calculator.

72
00:04:14,619 --> 00:04:16,799
So now we have to do some math, but again, it's simple.

73
00:04:19,580 --> 00:04:23,961
Draw calls are how many times in every frame the computer needs to draw an object.

74
00:04:26,021 --> 00:04:29,002
These drawings stack up into layers and create the final frame.

75
00:04:30,007 --> 00:04:35,911
A PC can have several hundred draw calls per frame and not slow down, but the Quest really

76
00:04:35,931 --> 00:04:37,632
needs you to keep that number under about 120.

77
00:04:37,752 --> 00:04:43,976
And artists actually have the biggest impact on this number, so we need to make sure we

78
00:04:44,016 --> 00:04:49,038
don't add unnecessary draw calls while we make art for the game, because 120 is a very

79
00:04:49,099 --> 00:04:49,899
easy number to hit.

80
00:04:49,919 --> 00:04:52,921
Okay, time for the math.

81
00:04:53,584 --> 00:04:56,245
First, each separate object is a draw call.

82
00:04:56,686 --> 00:05:00,428
So if you have, for example, a character on a plane with a skybox,

83
00:05:00,988 --> 00:05:04,811
then you have three draw calls, one for each character, plane, skybox.

84
00:05:06,352 --> 00:05:07,613
Okay, that doesn't seem too bad.

85
00:05:08,753 --> 00:05:12,035
Maybe make sure you merge environment pieces as much as possible, right?

86
00:05:12,816 --> 00:05:12,996
Well.

87
00:05:13,737 --> 00:05:17,519
Second, each separate material on an object is a draw call.

88
00:05:18,360 --> 00:05:21,341
Okay, that character actually has four different materials applied.

89
00:05:22,168 --> 00:05:24,991
Well, that's a draw call per material, so we're at 6.

90
00:05:25,852 --> 00:05:29,055
4 on the character, plus 1 skybox, plus 1 ground plane.

91
00:05:29,996 --> 00:05:32,098
OK, the math is easy, but as a 3D artist,

92
00:05:32,238 --> 00:05:34,280
I need to use different materials and objects a lot.

93
00:05:37,443 --> 00:05:38,924
Counting draw calls isn't something

94
00:05:38,964 --> 00:05:40,926
we're used to needing to take into consideration.

95
00:05:41,467 --> 00:05:42,988
So just by keeping this math in mind

96
00:05:43,049 --> 00:05:44,550
when setting up models and textures,

97
00:05:44,770 --> 00:05:45,811
you can keep this number down.

98
00:05:47,497 --> 00:05:50,619
Try to keep each separate object, whether static or skin,

99
00:05:50,699 --> 00:05:52,559
to a single material, if possible.

100
00:05:53,360 --> 00:05:55,921
Atlas textures and merge meshes in environments where you can.

101
00:05:57,662 --> 00:06:00,243
Cool, so we can make better choices when setting up

102
00:06:00,263 --> 00:06:02,864
materials and models, but we can't keep track

103
00:06:02,884 --> 00:06:03,944
of the whole game in our head.

104
00:06:04,524 --> 00:06:07,226
So we need to be able to look at what the actual number of draw

105
00:06:07,246 --> 00:06:10,347
calls is during runtime to make sure we're on target.

106
00:06:11,187 --> 00:06:12,088
So let's talk tools.

107
00:06:14,272 --> 00:06:17,994
There are a couple tools I use a lot to keep an eye on performance or try to figure out

108
00:06:18,014 --> 00:06:19,215
what's affecting performance.

109
00:06:20,196 --> 00:06:22,138
The first of these is RenderDoc.

110
00:06:23,338 --> 00:06:27,642
RenderDoc connects with your quest and allows you to capture single frames from your game

111
00:06:27,762 --> 00:06:30,304
and break them down into calls and other information.

112
00:06:31,865 --> 00:06:35,267
You can use it to find out if something is taking more draw calls than you anticipated,

113
00:06:35,768 --> 00:06:39,631
or something is rendering on the wrong layer, or one time I was able to find there was a

114
00:06:39,711 --> 00:06:44,054
non-optimized light that was casting shadows everywhere and I had overlooked it.

115
00:06:45,760 --> 00:06:49,501
It's just a really great insight into the nuts and bolts of the images being drawn.

116
00:06:50,142 --> 00:06:54,003
Especially because draw calls can be a big performance hit on this device, it's very

117
00:06:54,083 --> 00:06:57,244
useful to be able to look over that information, even as an artist.

118
00:06:59,744 --> 00:07:01,265
So here's a screenshot from RenderDoc.

119
00:07:01,825 --> 00:07:05,086
I've highlighted here where the draw calls are listed, and you can actually tab through

120
00:07:05,186 --> 00:07:06,746
each draw call and see what's rendering.

121
00:07:08,627 --> 00:07:12,728
You can look at the textures being used, and the basic mesh that's being drawn as well.

122
00:07:13,267 --> 00:07:15,668
there's a ton more information you can get from RenderDoc,

123
00:07:16,129 --> 00:07:18,530
but just being able to inspect the draw calls

124
00:07:18,931 --> 00:07:21,653
and see what's being drawn has been a lifesaver for me.

125
00:07:24,815 --> 00:07:25,956
Second of all, frame rate.

126
00:07:27,157 --> 00:07:28,477
This talk could also be called

127
00:07:28,698 --> 00:07:31,400
how to make your game run at frame rate on the Quest,

128
00:07:31,940 --> 00:07:33,721
because frame rate or frames per second

129
00:07:34,101 --> 00:07:36,063
is probably the most important performance indicator

130
00:07:36,083 --> 00:07:36,703
we care about.

131
00:07:36,723 --> 00:07:40,226
In VR, you need at least 60, preferably 72 frames per second.

132
00:07:42,828 --> 00:07:48,350
A little frame lag on your phone or console game, and it's annoying, but frame lag in

133
00:07:48,370 --> 00:07:50,871
VR can make your player feel sick or even fall over.

134
00:07:52,592 --> 00:07:58,134
If you make the most beautiful VR game, but it runs at 30 frames per second, no one will

135
00:07:58,174 --> 00:08:00,174
play it and everyone who tries will get sick.

136
00:08:00,875 --> 00:08:06,637
So you can use any FPS counter that you want, but Oculus puts out a tool called OVRmetrics,

137
00:08:07,197 --> 00:08:09,978
which basically outputs performance information on the screen.

138
00:08:10,907 --> 00:08:16,932
Most of these numbers don't mean much to me, but if that frames per second counter is at 72,

139
00:08:17,292 --> 00:08:23,618
I know I'm good. If it's below, say, 65, I should probably fix something. And sure,

140
00:08:23,718 --> 00:08:28,602
it might be something non-art related, which is tanking your frame rate, but let's be honest,

141
00:08:28,762 --> 00:08:34,626
it's probably the art. In this image, every option is displayed, which looks insane.

142
00:08:35,267 --> 00:08:40,031
I usually just leave on the frames per second graph and counter, maybe a few other things.

143
00:08:40,655 --> 00:08:44,317
I couldn't get a screenshot of how I set up mine though, because it doesn't seem to show

144
00:08:44,338 --> 00:08:47,040
up in regularly captured photos or in RenderDoc.

145
00:08:48,240 --> 00:08:52,964
Additionally, if you're a total nerd, you can just leave OVR metrics on on your quest

146
00:08:53,384 --> 00:08:56,306
and see what the framerate of your favorite games is managing to achieve.

147
00:08:57,247 --> 00:08:58,028
Sorry developers.

148
00:08:59,609 --> 00:09:03,372
Okay, really quickly let's go over some basics for setting up mobile VR rendering.

149
00:09:03,992 --> 00:09:07,415
I don't want to dedicate a lot of time to these, but I think it's worth mentioning to

150
00:09:07,455 --> 00:09:07,895
get started.

151
00:09:11,965 --> 00:09:17,606
There are forward rendering, depth pass rendering, single pass stereo, anti-aliasing, and fixed

152
00:09:17,626 --> 00:09:18,507
foveated rendering.

153
00:09:20,207 --> 00:09:20,827
Forward rendering.

154
00:09:22,607 --> 00:09:23,908
You'll need to use forward rendering.

155
00:09:24,608 --> 00:09:27,688
The Quest is a mobile device, and that's the rule for mobile devices right now.

156
00:09:28,609 --> 00:09:32,409
Make sure you find out what forward rendering entails and means as far as art assets.

157
00:09:33,810 --> 00:09:37,870
The biggest bummer here is that decals don't work in forward rendering mode, so you'll

158
00:09:37,910 --> 00:09:40,131
actually have to hide your texture scenes properly.

159
00:09:41,567 --> 00:09:43,808
In Unity, you can use the lightweight render pipeline,

160
00:09:44,128 --> 00:09:46,169
which is part of their new Scriptable Render Pipeline.

161
00:09:47,390 --> 00:09:49,370
It's set up for forward rendering and a few other things

162
00:09:49,450 --> 00:09:50,671
which are really helpful in VR.

163
00:09:52,152 --> 00:09:53,832
I found this to be really cool and useful

164
00:09:54,252 --> 00:09:55,653
without even using the full power

165
00:09:55,693 --> 00:09:57,194
of the new Scriptable Render Pipeline.

166
00:09:58,374 --> 00:10:00,535
And in real, if you're not doing some magic

167
00:10:00,575 --> 00:10:02,156
like pulling a different branch of the engine,

168
00:10:02,696 --> 00:10:03,976
the settings for forward rendering

169
00:10:04,036 --> 00:10:05,137
are here in the project settings.

170
00:10:08,158 --> 00:10:10,039
Depth rendering, there's no depth rendering.

171
00:10:10,632 --> 00:10:12,093
The hardware just doesn't do this, I think.

172
00:10:12,654 --> 00:10:15,216
So, no fun shaders that use depth info.

173
00:10:15,996 --> 00:10:17,277
This includes soft particles.

174
00:10:17,938 --> 00:10:20,379
But don't worry, this doesn't mean you can't have some kind of fog.

175
00:10:20,860 --> 00:10:23,462
It's just not as fancy. We'll revisit fog though later.

176
00:10:26,024 --> 00:10:29,826
Single pass stereo is a technique which saves you performance

177
00:10:30,227 --> 00:10:33,429
by basically drawing both eyes as one image

178
00:10:33,849 --> 00:10:36,371
rather than drawing one eye and then drawing the other eye.

179
00:10:36,912 --> 00:10:40,034
This is on by default in Unity's lightweight render pipeline.

180
00:10:40,599 --> 00:10:42,180
And in Unreal, it's here in these settings.

181
00:10:44,420 --> 00:10:46,641
You need it, you want it. It's anti-aliasing.

182
00:10:47,061 --> 00:10:49,782
Without anti-aliasing, things look ugly really fast.

183
00:10:50,523 --> 00:10:53,704
In forward rendering mode, you have multi-sample anti-aliasing.

184
00:10:54,404 --> 00:10:56,705
And four times is good if your performance can handle it.

185
00:10:57,365 --> 00:11:00,706
Eight times is a bit of overkill, depending on your game's style, I think.

186
00:11:01,487 --> 00:11:03,167
But, use what you can get away with.

187
00:11:04,007 --> 00:11:05,388
It's in the project settings in Unreal.

188
00:11:06,288 --> 00:11:09,810
And in your lightweight render pipeline asset in Unity.

189
00:11:12,456 --> 00:11:16,678
Alright, one last thing for general rendering settings is fixed foveated rendering.

190
00:11:18,019 --> 00:11:21,400
This can come in handy, especially when you're stretching your rendering budget as much as

191
00:11:21,440 --> 00:11:21,921
possible.

192
00:11:23,721 --> 00:11:29,144
What this does is it lowers the pixel resolution on the edges of the screen so they don't take

193
00:11:29,184 --> 00:11:31,185
as much time to render that part of the image.

194
00:11:32,386 --> 00:11:38,108
This works because the output image in VR is a little warped or fish-eyed to accommodate

195
00:11:38,128 --> 00:11:39,209
the distortion of the lens.

196
00:11:40,032 --> 00:11:44,235
So there's a little resolution wiggle room in those areas that are being squished at the edges.

197
00:11:45,356 --> 00:11:49,820
And this isn't necessarily a trade-off. We perceive less detailed information in our periphery,

198
00:11:50,361 --> 00:11:54,705
so the player may not even notice it too much, and you could potentially save quite a bit of performance.

199
00:11:56,847 --> 00:12:01,210
Although, if done somewhat aggressively, fixed-foveated rendering can creep further

200
00:12:01,250 --> 00:12:05,474
into the middle of the render, to the point where you can start to see the drop-off

201
00:12:05,895 --> 00:12:07,336
in resolution pretty obviously.

202
00:12:09,136 --> 00:12:11,977
These images show what part of the screen is affected and how much.

203
00:12:12,437 --> 00:12:13,578
There's a left and right eye.

204
00:12:14,878 --> 00:12:19,340
Low fixed bovine rendering only affects a little part of the screen and doesn't drop

205
00:12:19,360 --> 00:12:20,340
the resolution that much.

206
00:12:21,000 --> 00:12:25,662
But turned up high, more of the screen is affected and the drop off in resolution is

207
00:12:25,682 --> 00:12:26,382
a lot stronger.

208
00:12:28,323 --> 00:12:32,144
You can see this a little bit more obviously in this render of the Oculus Home.

209
00:12:32,785 --> 00:12:35,206
Here I've turned it on low and high for comparison.

210
00:12:35,546 --> 00:12:37,546
You can also turn it off altogether, of course.

211
00:12:38,538 --> 00:12:45,902
Particularly on the couch and on the dome cross beams, you can see the pixelation that occurs in the higher contrast areas as the resolution drops.

212
00:12:47,623 --> 00:12:53,026
So I've played some games where it was obviously set up pretty high, and I really only noticed it when standing still.

213
00:12:53,566 --> 00:12:58,248
Anytime I actively played and was looking around, it became less noticeable.

214
00:12:59,048 --> 00:13:01,270
But in others I found it could be really distracting,

215
00:13:02,170 --> 00:13:07,533
even if it was on a more moderate setting, if there was a really high contrast values in that part of the screen.

216
00:13:08,553 --> 00:13:13,877
Things such as stars become really noisy when the resolution drops.

217
00:13:15,478 --> 00:13:20,703
That said, if you use fixed-boviated rendering, start subtle so there's not a hard line of

218
00:13:20,783 --> 00:13:26,027
resolution drop in the player's view, and be aware of the noise it might make in high-contrast

219
00:13:26,087 --> 00:13:26,407
areas.

220
00:13:29,110 --> 00:13:32,893
Now that we've covered the basics of performance, let's really jump into the artistic side of

221
00:13:32,933 --> 00:13:33,293
all this.

222
00:13:34,654 --> 00:13:36,055
First, lights and shadows.

223
00:13:38,813 --> 00:13:43,295
Lights are already a known source of performance issues, so there's no surprise there.

224
00:13:46,236 --> 00:13:50,657
There's a reason we have things like lightmap baking, light and shadow distance culling,

225
00:13:50,757 --> 00:13:51,218
etc.

226
00:13:51,498 --> 00:13:52,418
Lights are expensive.

227
00:13:54,719 --> 00:14:01,141
How to light your game is also one of your biggest artistic choices, so how do you balance

228
00:14:01,161 --> 00:14:03,382
what you want to do with what you have time for?

229
00:14:06,113 --> 00:14:10,955
Because with enough time and effort, you can have a pretty nicely lit game, in the traditional

230
00:14:10,995 --> 00:14:11,755
PBR sense.

231
00:14:12,775 --> 00:14:15,896
Not a next-gen console or anything, but pretty darn good.

232
00:14:16,936 --> 00:14:22,037
Some games have set up really great lighting, but the catch is it's probably all baked down.

233
00:14:22,537 --> 00:14:24,858
If you can bake it, you can probably have it.

234
00:14:25,698 --> 00:14:29,339
Which sounds like an easy answer, and there's absolutely nothing wrong with doing that.

235
00:14:29,899 --> 00:14:33,840
It's a very old and well-used process, and it can yield really great results.

236
00:14:35,401 --> 00:14:39,543
But it takes extra time and effort to make baked lighting look good.

237
00:14:40,383 --> 00:14:44,065
And it's important to think about whether your project's timeline can afford the amount

238
00:14:44,085 --> 00:14:46,225
of time it takes to do light mapping.

239
00:14:47,006 --> 00:14:50,727
If you only have one scene to light, probably not a big deal to light map it.

240
00:14:51,087 --> 00:14:54,649
But if you have 12, well, you'd better have a pretty big team then.

241
00:14:57,530 --> 00:14:59,071
So can you have non-baked lights?

242
00:14:59,451 --> 00:15:02,532
Yes, you can have one dynamic or stationary light.

243
00:15:03,286 --> 00:15:07,447
They're much more expensive at runtime, because they need to update every frame in order to

244
00:15:07,487 --> 00:15:10,268
change how they affect moving objects, such as the player's hands.

245
00:15:11,428 --> 00:15:16,209
Most mobile devices can't handle too many dynamic lights, but one is enough for your

246
00:15:16,249 --> 00:15:19,850
needs if you're careful, especially if you're baking down more complex lighting.

247
00:15:20,610 --> 00:15:22,231
Also, why waste computation?

248
00:15:22,811 --> 00:15:27,312
Even if you can get away with one directional light in the whole scene and still have it

249
00:15:27,352 --> 00:15:31,473
look okay, still think about baking out the static areas so you have wiggle room for other

250
00:15:31,513 --> 00:15:31,753
things.

251
00:15:33,863 --> 00:15:35,104
What about dynamic shadows?

252
00:15:35,884 --> 00:15:39,526
Yes, but dynamic shadows probably have the worst

253
00:15:39,626 --> 00:15:42,807
performance impact out of anything light and shadow related.

254
00:15:43,348 --> 00:15:45,829
So really think about how much you want them and where.

255
00:15:47,009 --> 00:15:49,550
You can only have one shadow casting light at a time,

256
00:15:50,071 --> 00:15:52,352
so if it would look odd or you'd have to spend time

257
00:15:52,392 --> 00:15:54,452
you don't have orchestrating which light

258
00:15:54,492 --> 00:15:55,693
is casting shadows when,

259
00:15:55,713 --> 00:15:58,034
then think about whether they're worth having at all.

260
00:15:59,760 --> 00:16:03,082
I would personally recommend just leaving them out, unless everything else is running

261
00:16:03,122 --> 00:16:03,722
really light.

262
00:16:05,142 --> 00:16:07,723
Then you can get away with some object casting hard shadows.

263
00:16:08,283 --> 00:16:08,984
No soft shadows.

264
00:16:09,944 --> 00:16:15,386
For example, here Bonfire and Half and Half both use them, but both these games are only

265
00:16:15,426 --> 00:16:19,027
rendering a few characters at a time, and have a pretty limited environment.

266
00:16:19,527 --> 00:16:21,608
If your game looks like one of these, then sure.

267
00:16:22,909 --> 00:16:25,470
The Half and Half example is a closeup of the player's shadow.

268
00:16:26,090 --> 00:16:29,431
They look fine as hard shadows, and they're actually a lot of fun to play with.

269
00:16:30,955 --> 00:16:35,920
If you're going for something more realistic, or have a lot more things to render, then

270
00:16:35,960 --> 00:16:38,502
save yourself the headache and just try and do without them.

271
00:16:39,083 --> 00:16:42,587
The quest is probably not the best platform for your shadow puppet puzzler.

272
00:16:44,969 --> 00:16:47,832
What about unlit looks, or looks with simplified lighting?

273
00:16:48,493 --> 00:16:51,956
If these kinds of styles could work for your game's aesthetic, then I'd recommend using

274
00:16:51,996 --> 00:16:52,116
them.

275
00:16:53,058 --> 00:16:56,179
For example, Virtual Virtual Reality looks great on the quest.

276
00:16:56,819 --> 00:17:01,000
It's a go-to example for me because I've played it on both the Rift and the quest,

277
00:17:01,141 --> 00:17:03,261
and I really don't notice a drop in the art quality.

278
00:17:04,222 --> 00:17:07,363
On the quest, it seems there aren't any dynamic shadows in the game.

279
00:17:08,243 --> 00:17:13,024
The characters and the player-moved objects don't cast shadows, but static meshes have

280
00:17:13,065 --> 00:17:15,405
shadows, so I've assumed they've been baked in.

281
00:17:16,566 --> 00:17:20,527
It almost fools you into thinking that more things have shadows than they do, especially

282
00:17:20,567 --> 00:17:22,888
since the objects themselves are cell-shaded.

283
00:17:23,580 --> 00:17:25,041
so the illusion is pretty complete.

284
00:17:27,943 --> 00:17:32,886
Another example is Nog, which technically isn't a game that's out on the quest, but

285
00:17:32,926 --> 00:17:36,948
it is out on the go, and I've always thought it was a great use of the unlit style.

286
00:17:37,548 --> 00:17:41,891
It's bright and interesting all on its own, and since this game wasn't developed for VR

287
00:17:41,951 --> 00:17:44,512
initially, I assume it's just a style choice.

288
00:17:45,473 --> 00:17:48,335
So if a bold graphic style works, then use it.

289
00:17:50,065 --> 00:17:56,446
Also, styles that use faked lighting or light and shadows that are painted in can look really

290
00:17:56,506 --> 00:17:58,287
good and save a lot on performance.

291
00:18:02,768 --> 00:18:07,449
Totally Unlit is going to be the easiest to make performant, and PBR is going to be the

292
00:18:07,549 --> 00:18:09,110
most difficult and time consuming.

293
00:18:12,410 --> 00:18:16,151
Bear in mind your project's timeline and resources and try to find a balance of what you can

294
00:18:16,191 --> 00:18:19,612
do versus what you really need for the aesthetic goal of your game.

295
00:18:23,595 --> 00:18:25,818
Next up is shaders, materials, and textures.

296
00:18:27,019 --> 00:18:29,281
So here, you mostly need to remember

297
00:18:29,341 --> 00:18:31,864
that mobile devices need things to run a little lighter.

298
00:18:32,805 --> 00:18:34,807
I mentioned the lightweight render pipeline earlier,

299
00:18:35,027 --> 00:18:36,388
and things like that will get you far,

300
00:18:36,929 --> 00:18:38,110
but you also have to keep account

301
00:18:38,150 --> 00:18:39,451
of what's going into your materials.

302
00:18:42,054 --> 00:18:42,414
Textures.

303
00:18:43,459 --> 00:18:47,961
Don't go crazy on texture resolutions. This isn't one of those next-gen consoles running 8

304
00:18:49,161 --> 00:18:54,302
4k textures per character. It's a mobile device and crunching all those pixels has a cost.

305
00:18:55,263 --> 00:19:00,104
In addition to texture size, be conservative with the number of textures needed for each material.

306
00:19:00,764 --> 00:19:03,945
Use what you really need and what can really contributes to the look,

307
00:19:04,306 --> 00:19:05,486
because they'll add up over time.

308
00:19:06,890 --> 00:19:11,716
What this means artistically is that some cool PBR looks that require a ton of textures

309
00:19:11,816 --> 00:19:14,238
at high resolutions aren't going to perform well.

310
00:19:15,339 --> 00:19:19,083
Maybe if your game is limited in the number of environments and props needing textures,

311
00:19:19,224 --> 00:19:24,910
you can push for that look, but generally you want a look that requires less maps overall.

312
00:19:26,531 --> 00:19:29,354
You can still texture everything in your game while keeping things performant.

313
00:19:29,982 --> 00:19:31,704
But be mindful of what you're doing.

314
00:19:32,304 --> 00:19:36,087
Use some tiling textures, try to reuse textures as much as possible.

315
00:19:36,688 --> 00:19:39,810
Also, don't forget to pay attention to your MIP levels and filtering,

316
00:19:40,190 --> 00:19:42,512
or your beautiful textures will look like pixel-y garbage.

317
00:19:44,634 --> 00:19:45,054
Shaders.

318
00:19:45,795 --> 00:19:47,616
Obviously, shaders can have some impact.

319
00:19:48,177 --> 00:19:50,879
Shader complexity is measured in the number of instructions,

320
00:19:51,539 --> 00:19:54,041
and you can preview shader complexity in some engines

321
00:19:54,862 --> 00:19:57,524
to kind of keep an eye on how complex things are getting overall.

322
00:19:59,212 --> 00:20:05,097
On the quest, it's good to ask if you can get away with a lighter shader and test complex ones that you make.

323
00:20:05,917 --> 00:20:12,842
It's also important to keep an eye on the number of textures needed in a shader and how much of the screen space the texture will fill.

324
00:20:13,903 --> 00:20:22,349
On my first quest project, we spent a couple days trying to figure out what was impacting performance on one scene before we discovered it was the water shader.

325
00:20:22,930 --> 00:20:26,793
The shader didn't seem that complex, but since it occupied a lot of the screen,

326
00:20:27,279 --> 00:20:31,762
and extended way into the distance, it ended up being really expensive to draw all the

327
00:20:31,802 --> 00:20:32,923
textures over and over.

328
00:20:32,943 --> 00:20:37,066
A quick redesign of its look really increased performance in that scene a lot.

329
00:20:38,207 --> 00:20:41,109
That said, don't be afraid of shaders at all.

330
00:20:41,590 --> 00:20:46,333
Some instructions are really lightweight, and shaders are a kind of beautiful math magic

331
00:20:46,393 --> 00:20:49,456
that you can use to make really interesting effects and styles in your game.

332
00:20:53,527 --> 00:20:58,289
On my most recent Quest project, I opted to use a style of texturing which uses gradient

333
00:20:58,309 --> 00:21:00,670
swatches instead of unique textures.

334
00:21:01,530 --> 00:21:07,653
In this style, you add a light and shadow gradient to the color swatch, and then adjust

335
00:21:07,693 --> 00:21:11,275
the model's UV placement so that it sort of looks lit.

336
00:21:12,483 --> 00:21:17,306
Initially, I was going to do the gradients in texture and bake them down in Photoshop,

337
00:21:17,846 --> 00:21:21,868
but I experimented with setting that up in the shader so that I could adjust the gradients

338
00:21:22,008 --> 00:21:26,230
and what their color was room to room and create a slightly different lighting look.

339
00:21:27,271 --> 00:21:31,993
So while the shader is more complex than a non-lit shader, it still has less performance

340
00:21:32,053 --> 00:21:36,755
impact than a lit shader, and it gives me a lot more control over the look I'm aiming

341
00:21:36,835 --> 00:21:37,055
for.

342
00:21:40,797 --> 00:21:41,217
Materials.

343
00:21:42,300 --> 00:21:45,903
One thing, which is quest specific. There's a slight performance hit

344
00:21:46,423 --> 00:21:49,806
every time a draw calls switches, materials, or switches shaders.

345
00:21:50,886 --> 00:21:53,628
So if it's drawing an object using one material

346
00:21:53,948 --> 00:21:57,051
and then goes to the next object it's using a different material or different

347
00:21:57,091 --> 00:22:00,653
shader, there's a performance hit. So there's a

348
00:22:00,693 --> 00:22:02,975
big incentive to atlas as much as you can

349
00:22:03,135 --> 00:22:05,496
and try to reduce the number of unique materials needed.

350
00:22:06,577 --> 00:22:09,479
So maybe you have four animating props in a scene, for example.

351
00:22:09,973 --> 00:22:13,756
which are similar looking, but all different rigs, and therefore, different draw calls.

352
00:22:15,137 --> 00:22:18,920
You still get better performance if those four skin meshes are all using the same material,

353
00:22:19,420 --> 00:22:21,041
even though they're still separate draw calls.

354
00:22:21,782 --> 00:22:25,785
It might also be Advent Changes to limit the number of shaders being used in a scene for

355
00:22:25,825 --> 00:22:26,625
that same reason.

356
00:22:27,766 --> 00:22:30,068
Splitting out functionality that you don't always need

357
00:22:30,672 --> 00:22:36,517
in one shader to two sounds smart, but if you're using both quite often, maybe just

358
00:22:36,557 --> 00:22:40,600
see how it performs if you just use the more complex one for everything.

359
00:22:41,321 --> 00:22:44,363
Again, it really depends on how many objects and how complex of a shader.

360
00:22:45,724 --> 00:22:50,628
As a 3D artist, my first question when starting to develop for the Quest was, of course, what's

361
00:22:50,668 --> 00:22:51,289
my poly count?

362
00:22:52,650 --> 00:22:56,333
The initial numbers I heard from Oculus were pretty understandable, given that it's a mobile

363
00:22:56,353 --> 00:22:56,673
device.

364
00:22:57,455 --> 00:23:02,819
I've made mobile games before, but 3D artists, we always want more polys, so I couldn't just

365
00:23:02,879 --> 00:23:10,503
accept the number. I had to be sure. So the poly limit given by Oculus is 50 to 100k

366
00:23:10,543 --> 00:23:19,469
ferts, which is okay. I've made do with less, but I did some tests. Okay, so just because

367
00:23:19,509 --> 00:23:20,730
some static mesh tests...

368
00:23:21,237 --> 00:23:26,078
with no physics or lights or gameplay, can handle half a million polys, doesn't mean

369
00:23:26,098 --> 00:23:27,919
that's true of the final game scenario.

370
00:23:28,779 --> 00:23:34,621
But I have consistently overshot Oculus' recommended poly count in almost every scene I've made,

371
00:23:34,641 --> 00:23:39,662
and so long as the other systems are kept light, I can almost double their recommended

372
00:23:39,722 --> 00:23:40,082
numbers.

373
00:23:42,023 --> 00:23:46,965
In fact, on my most recent project, I opted for a style which demands more mid-poly models.

374
00:23:47,997 --> 00:23:52,319
but has really lightweight shaders and textures, and uses no lights at all.

375
00:23:53,959 --> 00:23:56,500
So I can get away with needing the extra polys in that style.

376
00:23:57,260 --> 00:24:01,842
It did some tests and found out that most of my scenes in that project averaged about

377
00:24:02,282 --> 00:24:02,542
150k.

378
00:24:03,382 --> 00:24:07,724
I did start hitting some ceilings, but only when I was being really lazy with my poly

379
00:24:07,764 --> 00:24:07,984
count.

380
00:24:09,094 --> 00:24:10,575
And again, everything adds up.

381
00:24:11,175 --> 00:24:13,496
So if you really want a PBR look with lights

382
00:24:13,556 --> 00:24:14,776
and some dynamic shadows,

383
00:24:15,557 --> 00:24:17,878
maybe you don't have the wiggle room in your poly count

384
00:24:18,218 --> 00:24:20,279
and you should aim for the target that Oculus gives.

385
00:24:20,919 --> 00:24:24,000
I think that I was only able to really push this number

386
00:24:24,020 --> 00:24:25,921
due to the lack of lighting and textures

387
00:24:25,961 --> 00:24:26,861
in my project style.

388
00:24:31,503 --> 00:24:34,324
So what about the classic methods of lowering poly count?

389
00:24:34,744 --> 00:24:36,865
They're still there and they still work, so that's good.

390
00:24:37,570 --> 00:24:39,170
But they have a couple of caveats as well.

391
00:24:41,031 --> 00:24:41,611
Instancing.

392
00:24:42,171 --> 00:24:43,872
Yeah, it can really help with poly count.

393
00:24:44,452 --> 00:24:45,652
But remember our draw calls?

394
00:24:46,873 --> 00:24:50,154
Only certain kinds of instances actually draw on one call.

395
00:24:50,794 --> 00:24:53,635
And some types still render each instance on a different call.

396
00:24:54,696 --> 00:24:57,637
So you might save polys, but add draw calls.

397
00:24:58,117 --> 00:25:00,198
And since draw calls are more of an impact hit,

398
00:25:00,658 --> 00:25:02,418
be cautious with instancing, and make sure

399
00:25:02,438 --> 00:25:04,519
that it's also batching the draw calls together.

400
00:25:04,539 --> 00:25:06,440
We'll discuss batching more in a moment.

401
00:25:08,780 --> 00:25:11,522
LODs are also a great way to keep your polycount in check.

402
00:25:12,003 --> 00:25:16,647
I would particularly recommend that you use LODs for foliage and other things which repeat

403
00:25:16,687 --> 00:25:17,007
a lot.

404
00:25:17,508 --> 00:25:21,632
Depending on which engine you're using, certain instances will also work with LODs.

405
00:25:22,132 --> 00:25:26,376
So you can kind of get away with two for one, combining them to one draw call and still

406
00:25:26,476 --> 00:25:27,157
using LODs.

407
00:25:30,160 --> 00:25:34,183
Okay, so what can you do artistically when working with lower polycount?

408
00:25:35,258 --> 00:25:38,840
First of all, remember that all games involve some amount of poly monitoring.

409
00:25:39,741 --> 00:25:43,603
Even next-gen games don't just throw ZBrush sculpts into the engine.

410
00:25:44,604 --> 00:25:49,187
So even if you don't want a low-poly aesthetic, you're already working within a normal pipeline,

411
00:25:49,327 --> 00:25:53,249
you just need to be a little more cautious than on a traditional platform and keep an

412
00:25:53,309 --> 00:25:56,371
eye on how your attempts to reduce poly count may affect draw calls.

413
00:25:58,292 --> 00:26:00,634
Second, think about embracing a low-poly look.

414
00:26:01,194 --> 00:26:03,776
I actually really love low-poly styles and generally

415
00:26:04,242 --> 00:26:09,006
model low poly stuff, it's not everyone's cup of tea and certainly doesn't work for every game,

416
00:26:09,626 --> 00:26:15,351
but it can work for every type of game. And even if a low poly style is not what you want for your

417
00:26:15,371 --> 00:26:20,476
game, looking at how visual problems are solved with less polys can help you overcome poly count

418
00:26:20,516 --> 00:26:25,980
problems that you're dealing with. This is a difficult thing to show examples of because

419
00:26:26,021 --> 00:26:31,205
it's one of the places where artistic creativity and technical implementation really intersect

420
00:26:31,245 --> 00:26:32,086
without many rules.

421
00:26:33,553 --> 00:26:37,235
But as an example, foliage can be difficult to make performant,

422
00:26:37,755 --> 00:26:39,675
especially if you're trying to use a lot of cards.

423
00:26:40,696 --> 00:26:45,557
So looking at foliage in low poly games might help you find a way to create foliage which

424
00:26:45,777 --> 00:26:49,199
still suits your game style but doesn't rely on all those cards.

425
00:26:49,919 --> 00:26:54,760
You can still hit the visual target you want by learning to construct an asset in a different way.

426
00:26:56,501 --> 00:26:57,361
Just look at these games.

427
00:26:58,181 --> 00:27:02,163
Regardless of the final poly count, which I don't know because I didn't make these,

428
00:27:03,257 --> 00:27:09,001
These games lean into a certain low poly aesthetic, such as faceting on the enemies in Super Hot,

429
00:27:09,682 --> 00:27:15,987
or the chunky shapes in Job Simulator, or the simplified graphic shapes in Virtual Virtual

430
00:27:16,007 --> 00:27:22,273
Reality. They all look great and distinct from one another. So even if you're a little cautious,

431
00:27:22,713 --> 00:27:27,037
poly count is probably not going to be where you hit performance walls. I really only see this

432
00:27:27,077 --> 00:27:32,161
being an issue for pretty large scale games with lots of large environments and lots of foliage.

433
00:27:33,441 --> 00:27:36,003
But that said, looking to low poly styles

434
00:27:36,183 --> 00:27:37,744
to solve various visual problems

435
00:27:38,184 --> 00:27:39,805
may help your game look more polished

436
00:27:39,925 --> 00:27:43,388
than simply trying to use traditional high to low pipeline

437
00:27:44,008 --> 00:27:45,389
and just forcing it even lower.

438
00:27:46,970 --> 00:27:47,851
All right, back to batching.

439
00:27:48,752 --> 00:27:51,233
Speaking of LODs and instances and poly counts,

440
00:27:51,894 --> 00:27:54,215
I'm gonna jump back into our draw call math

441
00:27:54,396 --> 00:27:55,316
and discuss matching.

442
00:27:56,157 --> 00:27:57,718
I found batching to be really useful

443
00:27:58,198 --> 00:28:00,700
and I feel it's important to cover the batching options.

444
00:28:02,461 --> 00:28:02,561
So.

445
00:28:03,706 --> 00:28:08,727
Batching is when the engine takes normally separate objects and draws them all in the same call.

446
00:28:09,708 --> 00:28:13,649
As a quick example, this is what happens to all the quads that are generated in

447
00:28:13,829 --> 00:28:17,830
a dust mode particle system, so that each particle is in a draw call.

448
00:28:18,630 --> 00:28:22,391
So that's batching, but you can also batch with regular static meshes in the game.

449
00:28:23,632 --> 00:28:27,933
Which sounds great, but batching isn't going to magically solve all your draw call needs.

450
00:28:29,385 --> 00:28:33,027
They come with some strict rules too, but knowing what's going on with batching can

451
00:28:33,047 --> 00:28:34,408
help you set things up a little better.

452
00:28:35,609 --> 00:28:39,152
I don't want to get too into the weeds because there are different methods and rules depending

453
00:28:39,212 --> 00:28:44,795
on which engine you use, but what's important is figuring out whether batching is costing

454
00:28:44,856 --> 00:28:49,018
more performance to compute than just adding some draw calls and merging meshes.

455
00:28:50,900 --> 00:28:55,063
It's something that which may be on a case-by-case basis, depending on what kind of lighting

456
00:28:55,083 --> 00:28:57,765
you're using or other things which may affect performance.

457
00:28:58,490 --> 00:29:00,592
But at least it's good to know what tools you have.

458
00:29:01,833 --> 00:29:05,837
There are two types of batching in Unity, dynamic batching and static batching.

459
00:29:07,019 --> 00:29:12,604
Unity will dynamically batch objects under 300 verts, which use the same mesh and material.

460
00:29:13,565 --> 00:29:14,686
There are a few more rules to this,

461
00:29:14,827 --> 00:29:17,790
but the point is that it largely happens without you having to set much up.

462
00:29:21,447 --> 00:29:25,530
The drawback to dynamic batching is that it comes with some computation per object batched.

463
00:29:25,930 --> 00:29:30,413
So if a ton of objects are being batched together, it might actually not save you much performance.

464
00:29:30,793 --> 00:29:33,375
But for a smaller number of objects, it's actually pretty great.

465
00:29:35,677 --> 00:29:36,737
Then there's static batching.

466
00:29:37,298 --> 00:29:42,981
Marking an object as static in Unity tells Unity that the object doesn't move, and therefore

467
00:29:43,041 --> 00:29:43,782
can be batched.

468
00:29:44,322 --> 00:29:48,105
This static batching works with higher poly objects than the dynamic batching.

469
00:29:48,869 --> 00:29:53,353
Basically what it does is it merges meshes together into one object and then draws that

470
00:29:55,655 --> 00:29:57,456
using separate calls for different materials.

471
00:29:58,517 --> 00:30:03,562
This means it comes with a higher memory overhead since it's saving out that merged mesh, so

472
00:30:03,622 --> 00:30:07,525
again you don't get it for free, but it is a great way to consolidate your scenes after

473
00:30:07,565 --> 00:30:08,126
set dressing.

474
00:30:10,648 --> 00:30:12,950
There are a couple methods of batching in Unreal as well.

475
00:30:13,630 --> 00:30:15,432
The main one is instant static meshes.

476
00:30:16,685 --> 00:30:22,686
Unreal already deals with instancing meshes pretty well, but converting some static meshes

477
00:30:22,846 --> 00:30:26,727
into a proper instant static mesh will combine them into one call.

478
00:30:27,607 --> 00:30:32,968
However, you can end up with this kind of situation, where I have really combined all

479
00:30:33,008 --> 00:30:38,129
my draw calls, but I've also far exceeded my poly count, and nothing is getting called,

480
00:30:38,489 --> 00:30:43,810
the LODs aren't working, so my advice is to go straight to a different type of instance

481
00:30:44,771 --> 00:30:46,311
when working on the quest from Unreal.

482
00:30:47,962 --> 00:30:50,184
and that is the hierarchical instance static mesh.

483
00:30:50,765 --> 00:30:51,565
These are my favorite.

484
00:30:51,765 --> 00:30:53,127
You kind of get everything here,

485
00:30:53,947 --> 00:30:57,731
LODs, batching meshes into one call, instance calling.

486
00:30:58,011 --> 00:30:58,952
They're kind of amazing.

487
00:30:59,692 --> 00:31:02,354
The only drawback to hierarchical instance static meshes

488
00:31:02,735 --> 00:31:03,736
is just working with them

489
00:31:04,076 --> 00:31:06,518
since you can't comfortably move the instances around.

490
00:31:07,719 --> 00:31:09,821
However, it is pretty easy to create a tool

491
00:31:09,961 --> 00:31:12,043
which runs through all the instances in the scene

492
00:31:12,583 --> 00:31:15,205
and converts them to a hierarchical instance static mesh.

493
00:31:16,105 --> 00:31:19,207
If you really need a lot of instances of something,

494
00:31:19,227 --> 00:31:23,308
hierarchical and synthetic meshes are really the way to go in Unreal.

495
00:31:23,848 --> 00:31:26,690
I've used these a lot, especially with natural elements like rocks,

496
00:31:27,090 --> 00:31:29,011
which get duplicated out quite a bit.

497
00:31:31,452 --> 00:31:34,413
And of course, not all polys are the same. Skin meshes are

498
00:31:34,633 --> 00:31:38,314
more expensive because they're being deformed, and I don't think there's

499
00:31:38,354 --> 00:31:41,796
really any benchmark for how many skin meshes you can have per scene,

500
00:31:42,196 --> 00:31:45,117
or how many polys can be skinned versus static.

501
00:31:45,772 --> 00:31:48,854
It's going to depend on your game's overall performance, as well as the rig itself.

502
00:31:49,574 --> 00:31:54,858
Higher poly meshes, or skin meshes with a higher number of influences per vertex, are

503
00:31:54,878 --> 00:31:55,539
going to be heavier.

504
00:31:58,521 --> 00:32:02,344
The number of vertex influences can really hit performance.

505
00:32:03,384 --> 00:32:07,868
This isn't true for just the quest, it's true for most platforms, particularly mobile platforms.

506
00:32:08,508 --> 00:32:13,492
So when painting weights on skin meshes, I try to stick to 2-3 joints influencing each

507
00:32:13,552 --> 00:32:14,713
vert as much as possible.

508
00:32:15,985 --> 00:32:19,927
I will do three for things that need to be really smooth, but I would recommend not going

509
00:32:20,047 --> 00:32:20,647
above four.

510
00:32:21,727 --> 00:32:25,768
And balance the number of joint influences you have in your rigs against how many animating

511
00:32:25,808 --> 00:32:27,509
meshes you need at any given point.

512
00:32:28,349 --> 00:32:32,730
This is why the quality levels can adjust how many bones influence a vertex.

513
00:32:33,271 --> 00:32:34,931
It's just a big impact on performance.

514
00:32:36,231 --> 00:32:40,653
If you're still unsure about how many animating meshes you can use in a scene, run some tests.

515
00:32:43,059 --> 00:32:46,980
Use a scene with a static polycount that's a good average for your game and throw some

516
00:32:47,020 --> 00:32:47,640
rough rigs in.

517
00:32:48,321 --> 00:32:52,022
I just add multiples of 5 to 10 until I start to see performance drops.

518
00:32:52,622 --> 00:32:56,523
Too many animating characters can be a quick way to tank your framerate, but at the same

519
00:32:56,583 --> 00:33:00,824
time you want to use as much as you can because animation really brings games to life.

520
00:33:02,245 --> 00:33:06,926
Bear in mind though that animation controllers with a lot of layers can also impact performance,

521
00:33:07,627 --> 00:33:11,268
so if you're planning some really intense animation controllers, be sure to test those

522
00:33:11,328 --> 00:33:11,608
as well.

523
00:33:16,573 --> 00:33:20,694
Issues around transparency is one of the aspects of the quest that's not obvious.

524
00:33:21,375 --> 00:33:24,196
Transparency isn't a big issue on most platforms,

525
00:33:24,636 --> 00:33:26,677
probably because of the differences in the hardware.

526
00:33:27,817 --> 00:33:30,498
But transparent objects need to be handled with a lot of care

527
00:33:30,578 --> 00:33:31,819
when developing for the quest.

528
00:33:33,760 --> 00:33:35,881
The problem seems to stem from overdraw,

529
00:33:36,341 --> 00:33:39,002
which is when multiple objects or multiple polys

530
00:33:39,122 --> 00:33:40,883
are being drawn on top of one another.

531
00:33:40,903 --> 00:33:42,863
This already affects performance

532
00:33:42,923 --> 00:33:44,604
because you're taking time to draw things

533
00:33:44,704 --> 00:33:46,105
which maybe aren't even seen.

534
00:33:47,100 --> 00:33:50,622
But overdraw is basically unavoidable to some extent in all games.

535
00:33:52,703 --> 00:33:56,884
What becomes a problem on the quest is when one object is transparent,

536
00:33:57,324 --> 00:34:00,326
and so both objects will affect the final pixel in the image.

537
00:34:03,687 --> 00:34:07,468
In this example here, I've put the wall in front of several other objects,

538
00:34:07,989 --> 00:34:10,169
and you can see that those objects are still being drawn,

539
00:34:11,610 --> 00:34:13,131
but you can't actually see them.

540
00:34:14,511 --> 00:34:15,712
That's an example of overdraw.

541
00:34:16,425 --> 00:34:19,767
In transparency, you're drawing all those objects,

542
00:34:20,447 --> 00:34:21,968
but multiple of those objects

543
00:34:22,028 --> 00:34:23,528
are affecting the final outcome.

544
00:34:26,169 --> 00:34:28,210
Small objects like dust motes or text

545
00:34:28,370 --> 00:34:29,411
don't have a big impact

546
00:34:29,471 --> 00:34:31,191
because they don't overlap each other a lot

547
00:34:31,611 --> 00:34:33,392
and don't occupy a lot of screen space.

548
00:34:33,852 --> 00:34:35,273
But larger transparent objects

549
00:34:35,413 --> 00:34:37,794
like large cloud or fog cards,

550
00:34:38,254 --> 00:34:41,075
effect sprites, or even head bubble transition fades

551
00:34:41,676 --> 00:34:43,176
can be a real performance issue,

552
00:34:43,636 --> 00:34:45,537
especially if you're struggling to keep your frame rate up.

553
00:34:46,612 --> 00:34:51,314
My best advice to you is to avoid using transparency techniques that can occupy a large part of

554
00:34:51,334 --> 00:34:53,935
the screen, especially if they're going to layer a lot.

555
00:34:54,756 --> 00:34:58,618
You can use transparency here and there, but you need to make sure to keep it as small

556
00:34:58,638 --> 00:35:03,160
and infrequent as possible, and test it on the quest whenever you're going to add something

557
00:35:03,180 --> 00:35:03,561
like this.

558
00:35:04,841 --> 00:35:09,324
So because transparency is not normally a big issue for game art, it gets a little tricky

559
00:35:09,364 --> 00:35:12,305
to work around not using it, so here are a few quick tips.

560
00:35:14,238 --> 00:35:17,660
Don't use big soft cloud or fog cards.

561
00:35:18,701 --> 00:35:23,584
For soft particles you need depth pass rendering anyway, which we don't have on mobile, so

562
00:35:23,624 --> 00:35:26,827
they'll just clip through hard meshes and they won't look great anyway.

563
00:35:27,607 --> 00:35:33,031
I find sometimes that really soft alpha cards don't also look as good in build as they do

564
00:35:33,091 --> 00:35:36,693
in engine, so be sure to test your effects on the headset.

565
00:35:37,594 --> 00:35:42,237
The old style of fog, linear fog or vertex fog, performs really well on the Quest.

566
00:35:42,694 --> 00:35:46,096
I really pushed this and made it do some really interesting things.

567
00:35:47,096 --> 00:35:50,399
So as long as you have enough vertices to support it, it can work really well.

568
00:35:53,701 --> 00:35:57,043
Try to avoid using plant cards or foliage cards.

569
00:35:57,463 --> 00:35:59,344
There are other ways to make plants than just cards.

570
00:36:00,105 --> 00:36:04,568
Explore some styles that don't use as many cards and maybe rely on polys for the plant

571
00:36:04,608 --> 00:36:04,888
shapes.

572
00:36:06,069 --> 00:36:09,951
For sprites, use meshes fitted to the image to reduce as much overdraw as possible.

573
00:36:10,587 --> 00:36:16,270
Engines and sprite support software already makes this really easy to do, so there's no reason to render everything on big quads,

574
00:36:16,851 --> 00:36:18,892
especially since you're not as confined on the polys.

575
00:36:19,913 --> 00:36:26,297
Also, you can pick a more graphic look for effects and use meshes instead of transparent cards. Here on the right

576
00:36:26,337 --> 00:36:32,561
I've made some soap bubbles, and rather than using an alpha for transparency, I've kept the style really graphic.

577
00:36:33,421 --> 00:36:38,824
These are mesh renders. They still read clearly, but I don't have to worry about performance as much for these.

578
00:36:41,030 --> 00:36:46,616
Also, there's a setting in Particle Systems called Max Particle Size, which is really

579
00:36:46,656 --> 00:36:47,057
helpful.

580
00:36:47,437 --> 00:36:51,681
It'll prevent particles from taking up too much screen space, so that way your frame

581
00:36:51,701 --> 00:36:54,985
rate won't drop just because some dust moat got really close to the camera.

582
00:36:56,326 --> 00:37:02,032
And using the full screen mesh fade for transitions is easy, but can also affect the frame rate.

583
00:37:02,816 --> 00:37:06,597
And if you're already pushing performance, maybe try some different transition styles.

584
00:37:07,357 --> 00:37:08,597
Or build it into the shader.

585
00:37:09,437 --> 00:37:12,998
And if you do use a mesh for transitions, make sure to disable the object when it's

586
00:37:13,058 --> 00:37:13,898
fully transparent.

587
00:37:14,358 --> 00:37:16,458
It should only be visible during the transition.

588
00:37:18,879 --> 00:37:23,180
So if you've developed for VR at all, you know that post-processing is already somewhat

589
00:37:23,240 --> 00:37:26,280
problematic, and not just for performance reasons.

590
00:37:27,060 --> 00:37:29,921
Some post-effects just don't translate well into VR.

591
00:37:30,595 --> 00:37:33,516
largely due to the differences between the images shown to each eye.

592
00:37:33,536 --> 00:37:38,638
However, there are plenty of things like bloom, color correction, or color grading,

593
00:37:38,758 --> 00:37:42,919
which are really helpful. On the Quest, however, the tile renderer

594
00:37:43,000 --> 00:37:47,661
makes any traditional post processing really slow. Like, really slow.

595
00:37:48,761 --> 00:37:52,043
Because that post means after all the draw calls are done,

596
00:37:52,703 --> 00:37:55,884
and sending the image back through to get processed again

597
00:37:55,904 --> 00:37:58,225
is really a bad idea on this hardware.

598
00:38:00,298 --> 00:38:04,480
So while it's one of the biggest performance disappointments for art on this platform,

599
00:38:05,580 --> 00:38:10,241
it largely just means that the traditional or built-in post-processing tools are not going to

600
00:38:10,281 --> 00:38:16,523
cut it. You have to implement what you need in other ways. Color correction, for example, can be

601
00:38:16,543 --> 00:38:22,005
done before the image is complete. You can add color correction into the shader and adjust it

602
00:38:22,025 --> 00:38:25,386
from there, even scene to scene using global parameters.

603
00:38:26,912 --> 00:38:31,454
Cards can be used in places where you really, really want some bloom, since you can't get

604
00:38:31,494 --> 00:38:33,296
a whole image-style bloom pass.

605
00:38:35,057 --> 00:38:40,100
But the thing to keep in mind with post-processing is that it's just a tool to achieve a visual

606
00:38:40,160 --> 00:38:40,460
goal.

607
00:38:41,100 --> 00:38:45,003
If you can't use the tool you know, it doesn't mean that you give up on the work that you

608
00:38:45,043 --> 00:38:45,883
needed it to do.

609
00:38:46,464 --> 00:38:50,687
Assess the effect you wanted, and figure out other ways to get those results visually.

610
00:38:54,377 --> 00:38:58,778
So I've talked a lot about testing things to figure out what could be affecting your frame rate,

611
00:38:59,238 --> 00:39:03,339
or before committing yourself to a new technique or asset style all over your game.

612
00:39:04,099 --> 00:39:05,339
But what makes a good test?

613
00:39:06,480 --> 00:39:12,381
To find out what's affecting performance in a scene, I start by eliminating or changing the big offenders,

614
00:39:12,681 --> 00:39:14,102
and making a build with those changes.

615
00:39:14,802 --> 00:39:18,123
For example, I might disable or change the lighting scenario,

616
00:39:18,683 --> 00:39:20,783
or try removing a complex shader.

617
00:39:22,010 --> 00:39:26,893
Sometimes I'll replace high poly meshes with lower poly ones just to see if reducing the poly count helps.

618
00:39:28,354 --> 00:39:33,337
I ran this test one time on a very frustrating scene where I replaced every mesh with a cube

619
00:39:33,758 --> 00:39:36,179
just to make sure that the poly count wasn't the problem.

620
00:39:37,240 --> 00:39:39,181
Version control is very important here

621
00:39:39,201 --> 00:39:41,282
because you can revert all this.

622
00:39:43,797 --> 00:39:47,399
This is the same garden scene that I've been using through the whole talk, but I've just

623
00:39:47,419 --> 00:39:50,240
selected every mesh filter and replaced it with a cube.

624
00:39:50,901 --> 00:39:55,563
Obviously the polycount is going to be a lot lower, so if I still had problems at this

625
00:39:55,643 --> 00:39:57,804
point, I can eliminate a couple things.

626
00:39:59,665 --> 00:40:03,927
The best thing you can do to keep performance in check on the quest is to test often during

627
00:40:03,967 --> 00:40:04,447
development.

628
00:40:04,967 --> 00:40:09,569
That way, if the framerate does drop suddenly, you'll kind of know what's new in the scene

629
00:40:09,689 --> 00:40:11,310
and therefore most likely the cause.

630
00:40:13,508 --> 00:40:17,269
There are things to be cautious about while testing, though, or you'll end up with misleading

631
00:40:17,309 --> 00:40:17,869
information.

632
00:40:17,889 --> 00:40:20,390
So I'm going to do this example.

633
00:40:21,830 --> 00:40:25,991
Here I've put some fog cards into a really lightweight scene, mainly to show how bad

634
00:40:26,011 --> 00:40:31,533
the clipping looks, but there's no lights, hardly any textures, hardly any geo or other

635
00:40:31,573 --> 00:40:36,634
effects in the scene, so of course it's still running at 72 frames per second, nothing else

636
00:40:36,694 --> 00:40:37,294
is going on.

637
00:40:37,954 --> 00:40:41,215
The scene isn't representative of a finished scene in the game.

638
00:40:42,076 --> 00:40:43,576
Unless it is, well then yeah, it is this.

639
00:40:44,737 --> 00:40:48,558
The important thing is that you try to make your test scenes have the same complexity,

640
00:40:49,158 --> 00:40:54,420
so that you're using a reasonably similar number of draw calls, or using the same lighting complexity.

641
00:40:55,480 --> 00:40:57,781
If your test scene is really lightweight to render,

642
00:40:58,261 --> 00:41:03,323
then anything you test in there may behave differently when added into a more completed scene in your game.

643
00:41:06,404 --> 00:41:10,905
So, how do you translate all this information into decisions about how your game looks from the beginning?

644
00:41:12,327 --> 00:41:14,548
Well, most importantly, know your budget.

645
00:41:15,188 --> 00:41:16,129
How big is your game?

646
00:41:16,589 --> 00:41:18,030
How many people are making this game?

647
00:41:18,350 --> 00:41:19,391
What is their expertise?

648
00:41:20,391 --> 00:41:21,832
What does your timeline look like?

649
00:41:22,473 --> 00:41:27,496
If the answer to these questions is you have a lot of people and plenty of time, then try

650
00:41:27,516 --> 00:41:29,257
to make your game look like whatever you want.

651
00:41:29,697 --> 00:41:32,539
You can afford to spend time to explore and finesse the performance.

652
00:41:34,039 --> 00:41:38,002
If the answer sounds like most games, you have a few people and a less than ideal amount

653
00:41:38,042 --> 00:41:38,382
of time.

654
00:41:38,891 --> 00:41:43,733
Then aim for a style or make choices within your desired style, which eliminate problems and overhead.

655
00:41:44,933 --> 00:41:47,974
On my most recent quest project, we had a pretty short production timeline.

656
00:41:48,554 --> 00:41:54,576
I had done this piece, which you've seen throughout the talk, as a test of using the gradient swatches instead of traditional texture maps,

657
00:41:55,217 --> 00:41:57,037
before I even had the project get started.

658
00:41:58,038 --> 00:41:59,758
Look, I didn't even use the whole texture map.

659
00:42:00,959 --> 00:42:05,400
But for this really short project, I opted to use this method along with an unlit shader.

660
00:42:06,512 --> 00:42:09,374
And I saved a lot of time not having to worry about creating textures,

661
00:42:09,815 --> 00:42:12,997
managing texel density, and adjusting lights.

662
00:42:13,077 --> 00:42:16,980
And I used that time in other places like effects and animation and shaders.

663
00:42:18,161 --> 00:42:19,722
So, don't feel like this.

664
00:42:21,724 --> 00:42:24,086
Form an art style around your time and resources.

665
00:42:24,521 --> 00:42:29,682
and then you can focus your time on making your art look good instead of focusing on making it perform.

666
00:42:30,522 --> 00:42:34,643
And while the two are never inseparable, spending time making your game look polished

667
00:42:35,264 --> 00:42:39,124
is always better than trying to squeeze in new techniques that you don't have time to optimize.

668
00:42:41,185 --> 00:42:45,026
So in summary, test often, and keep an eye on your draw calls.

669
00:42:45,766 --> 00:42:50,787
Be cautious with lighting and shadows, and try to set those up smart in the beginning

670
00:42:50,907 --> 00:42:53,008
so that you can save yourself trouble down the line.

671
00:42:54,313 --> 00:42:57,818
You'll need to get creative with some things like post-processing and transparency,

672
00:42:58,418 --> 00:43:01,883
since a lot of the traditional methods can affect performance if you're not careful.

673
00:43:02,925 --> 00:43:05,428
But generally, try to have fun and make what you want,

674
00:43:05,608 --> 00:43:08,112
because you can achieve some really great art on the quest

675
00:43:08,272 --> 00:43:10,435
by just applying a little knowledge of how it works.

676
00:43:12,058 --> 00:43:13,319
Thank you for listening to this talk.

677
00:43:13,960 --> 00:43:19,386
If you would like to contact me or check out more of my art, you can see my website or

678
00:43:19,466 --> 00:43:20,207
catch me on Twitter.

679
00:43:20,787 --> 00:43:25,452
I'm Linus Teapot or Alina Hale on most platforms, so I'm pretty easy to find.

680
00:43:26,393 --> 00:43:27,494
Thank you again for listening.

681
00:43:27,615 --> 00:43:32,039
I hope this was really helpful, and I hope this helps you make some more great VR games.

