1
00:00:03,285 --> 00:00:05,486
Welcome to this last section of the day, entitled

2
00:00:05,506 --> 00:00:07,227
Interacting with Your 3D Geometry.

3
00:00:08,027 --> 00:00:09,808
You probably guessed I was a professional body builder,

4
00:00:09,828 --> 00:00:10,308
but you're wrong.

5
00:00:10,348 --> 00:00:12,369
I'm actually a graphics software engineer with Intel.

6
00:00:14,329 --> 00:00:16,810
All right, so games, graphics, there's all sorts of fun stuff.

7
00:00:16,830 --> 00:00:19,651
You've got particle systems, lens flares, cameras, lights.

8
00:00:19,991 --> 00:00:23,393
But any sort of meaningful interaction between the player and his environment

9
00:00:23,433 --> 00:00:27,034
happens with those geometric objects, whether it's rigid bodies, skin

10
00:00:27,074 --> 00:00:29,855
characters, or some of those soft body things that are becoming

11
00:00:29,895 --> 00:00:30,635
more and more important.

12
00:00:30,975 --> 00:00:32,896
And these old things, they all have meshes.

13
00:00:33,576 --> 00:00:36,959
OK, so we're going to cover a wide variety of things today.

14
00:00:37,279 --> 00:00:40,341
I'm going to first cover a lot of basics,

15
00:00:40,801 --> 00:00:43,223
review for some people, but it's fundamentals

16
00:00:43,243 --> 00:00:44,444
we want everybody to know.

17
00:00:45,145 --> 00:00:47,587
Following that, I'm going to dive deep into convex meshes.

18
00:00:48,227 --> 00:00:51,089
Then we'll take a look at solid meshes and spatial properties

19
00:00:51,109 --> 00:00:52,210
thereof that affect motion.

20
00:00:52,230 --> 00:00:54,472
And then we're going to finish off with some springy things.

21
00:00:55,673 --> 00:00:57,294
And hopefully lots of practical examples

22
00:00:57,674 --> 00:00:58,535
that'll be fun for you guys.

23
00:00:59,075 --> 00:01:01,117
And yeah, you're welcome to take pictures, of course.

24
00:01:01,257 --> 00:01:02,438
And these slides will be available.

25
00:01:03,042 --> 00:01:04,383
online later on.

26
00:01:04,984 --> 00:01:06,946
OK, this is math tutorial today.

27
00:01:07,106 --> 00:01:09,348
So you were warned there'd be some math in this course.

28
00:01:09,889 --> 00:01:10,530
But don't worry.

29
00:01:11,010 --> 00:01:13,633
A lot of it is very, very straightforward.

30
00:01:13,733 --> 00:01:16,976
In fact, just knowing your basic vector arithmetic, dot product,

31
00:01:17,037 --> 00:01:20,260
and cross product, that's going to give you guys 99% of what you

32
00:01:20,300 --> 00:01:21,501
need in this industry to succeed.

33
00:01:22,699 --> 00:01:26,621
For example, your standard lighting equation is in your shaders on your GPU.

34
00:01:26,821 --> 00:01:30,404
I mean, it's n.l to get your diffuse lighting, just dot product.

35
00:01:30,884 --> 00:01:34,166
You're writing some game script code for, let's say, some robot, right?

36
00:01:34,306 --> 00:01:37,028
And you want to know, OK, if the player walks in front of you,

37
00:01:37,388 --> 00:01:38,669
you have to shoot him down.

38
00:01:38,869 --> 00:01:41,811
Well, simply take the dot product of the direction the robot is facing

39
00:01:42,151 --> 00:01:44,452
with the vector from the robot to the player.

40
00:01:44,893 --> 00:01:47,734
And if that vector is close to 1, he's in front, fire away.

41
00:01:47,935 --> 00:01:49,876
If it's negative, save your ammo.

42
00:01:49,896 --> 00:01:50,576
He's somewhere behind you.

43
00:01:50,596 --> 00:01:51,037
You don't see him.

44
00:01:51,845 --> 00:01:54,227
OK, in addition to some of that basic math,

45
00:01:54,267 --> 00:01:55,467
there's going to be a few new things

46
00:01:55,487 --> 00:01:57,788
we're going to introduce today.

47
00:01:57,888 --> 00:02:00,650
Shown here on the right are the outer products

48
00:02:00,990 --> 00:02:02,251
and the Jacobians and stuff.

49
00:02:03,311 --> 00:02:05,092
You're probably wondering, outer product, what's that?

50
00:02:05,552 --> 00:02:07,713
Well, the dark product or inner product

51
00:02:07,773 --> 00:02:08,874
is something you're already familiar with.

52
00:02:08,914 --> 00:02:11,916
You can think of that as a row vector times a column vector.

53
00:02:12,076 --> 00:02:14,097
And that gives us the scale that we're all familiar with.

54
00:02:14,637 --> 00:02:17,518
The outer product, now think of it as a column vector

55
00:02:17,558 --> 00:02:18,759
times a row vector.

56
00:02:19,179 --> 00:02:20,700
The rules of matrix multiplication.

57
00:02:21,622 --> 00:02:23,943
produce, give you a 3x3 matrix.

58
00:02:25,344 --> 00:02:27,144
You're probably scratching your head wondering,

59
00:02:27,245 --> 00:02:29,446
OK, well, I started out with six numbers.

60
00:02:29,486 --> 00:02:30,286
I've got nine.

61
00:02:30,926 --> 00:02:35,188
That's like lossy compression, where the result is bigger

62
00:02:35,208 --> 00:02:36,229
than the original file size.

63
00:02:36,349 --> 00:02:36,929
What's the point?

64
00:02:37,349 --> 00:02:39,691
Well, this is actually useful, and we'll see why.

65
00:02:39,731 --> 00:02:44,473
But first, let's take a look at a geometric understanding

66
00:02:44,513 --> 00:02:46,854
of how the outer product might be used.

67
00:02:47,514 --> 00:02:48,575
OK, we already know that.

68
00:02:50,199 --> 00:02:51,139
you know, what the dot product is.

69
00:02:51,159 --> 00:02:53,220
Let's say we have a vector that's of unit length u.

70
00:02:54,020 --> 00:02:56,201
And we have some other vector v, and we take the dot product.

71
00:02:56,501 --> 00:02:59,843
And that gives us this distance of v as if we projected along u.

72
00:03:00,083 --> 00:03:00,883
Now, that's a scalar.

73
00:03:01,683 --> 00:03:04,284
If we want, let's say, a vector along that line,

74
00:03:04,744 --> 00:03:06,945
then we multiply u dot v times u.

75
00:03:07,425 --> 00:03:09,326
And that gives us this line.

76
00:03:09,406 --> 00:03:11,387
So v projected onto that line.

77
00:03:12,207 --> 00:03:12,247
OK.

78
00:03:14,595 --> 00:03:19,037
Now, so we have u times u dot v. Can we change the brackets

79
00:03:19,197 --> 00:03:20,057
and move it over to the left?

80
00:03:20,077 --> 00:03:22,739
So it's u dot u times v. Well, that doesn't work,

81
00:03:23,259 --> 00:03:25,280
because that's just 1 times v, which is actually

82
00:03:25,320 --> 00:03:27,781
v, which is different than this projection vector

83
00:03:27,801 --> 00:03:28,241
that we wanted.

84
00:03:28,801 --> 00:03:32,083
So to do that, it's actually you take the outer part of u

85
00:03:32,123 --> 00:03:35,685
with itself, and that gives you a 3 by 3 matrix

86
00:03:36,205 --> 00:03:38,186
that if I multiply that matrix by any vector,

87
00:03:38,606 --> 00:03:39,746
it projects it onto that line.

88
00:03:41,647 --> 00:03:44,008
So think of how you might write your.

89
00:03:44,795 --> 00:03:45,936
player navigation code.

90
00:03:46,676 --> 00:03:48,037
You got some guy running around your world,

91
00:03:48,617 --> 00:03:50,677
and the user hits the W key, and he's running along,

92
00:03:50,697 --> 00:03:51,358
and he hits a wall.

93
00:03:52,078 --> 00:03:54,419
And well, you don't want him to go through the wall,

94
00:03:54,999 --> 00:03:57,060
but maybe you don't want to have him stick there.

95
00:03:57,180 --> 00:03:58,940
You want to have him maybe slide along the wall.

96
00:03:59,460 --> 00:04:01,301
So you've probably written a routine like this

97
00:04:01,321 --> 00:04:03,602
called slide along wall, where you

98
00:04:03,782 --> 00:04:10,224
take the intended vector of the user, v, and you have this u.

99
00:04:10,244 --> 00:04:12,125
Let's say this u vector is now sticking into the wall.

100
00:04:13,086 --> 00:04:16,708
And you subtract out that component of the motion,

101
00:04:16,788 --> 00:04:19,729
and you're left with the green arrow there,

102
00:04:19,829 --> 00:04:21,150
so the player's sliding along the wall.

103
00:04:21,830 --> 00:04:24,692
All right, so in that little equation, we see v show up in there twice.

104
00:04:24,732 --> 00:04:25,713
Can we factor that out?

105
00:04:26,113 --> 00:04:26,993
Well, indeed you can.

106
00:04:27,574 --> 00:04:31,196
And what you get is the identity matrix minus this outer product

107
00:04:31,636 --> 00:04:36,399
is now this 3 by 3 matrix that you can use to project vectors

108
00:04:36,459 --> 00:04:39,100
onto a plane, of which u is the normal of.

109
00:04:40,254 --> 00:04:42,816
OK, now why it's better to have some, why it's sometimes

110
00:04:42,896 --> 00:04:45,599
useful to have things in that matrix form instead of just some function

111
00:04:45,619 --> 00:04:49,742
is, well, certain things you can pass matrices into,

112
00:04:49,782 --> 00:04:52,445
like other systems of equations and so on, where you can't necessarily

113
00:04:52,825 --> 00:04:53,886
stuff an arbitrary function.

114
00:04:55,167 --> 00:04:56,529
And we'll see more uses of this later on.

115
00:04:58,130 --> 00:05:02,476
Now, at first, because there's a lot of geometry algorithms that we've been writing,

116
00:05:03,216 --> 00:05:07,742
you know, this is the bane of existence of these things is numerical precision issues.

117
00:05:08,182 --> 00:05:11,526
If you're doing graphics and lighting, you know, everything just kind of works out, you know,

118
00:05:11,566 --> 00:05:12,968
that pixel is always the right color.

119
00:05:13,488 --> 00:05:17,773
But, you know, the problems are more when you're doing things with geometry like slicing and dicing and stuff.

120
00:05:18,607 --> 00:05:20,309
Now, it comes to this.

121
00:05:20,369 --> 00:05:23,751
When we have a line, for example, it's a continuous thing.

122
00:05:24,432 --> 00:05:27,714
And if you sort of zoom in, zoom in, zoom in to the lowest bits of precision,

123
00:05:28,195 --> 00:05:30,397
and you start looking at points along that line,

124
00:05:30,677 --> 00:05:32,418
well, they're not really on the line anymore,

125
00:05:32,458 --> 00:05:34,740
because you don't quite have the precision to do that.

126
00:05:35,120 --> 00:05:37,942
And you're thinking, well, floating point, you've got a 23-bit mantissa.

127
00:05:37,962 --> 00:05:39,243
That should be more than enough precision.

128
00:05:39,664 --> 00:05:43,127
Well, the problem is still not enough, because you

129
00:05:43,187 --> 00:05:44,408
might have a long line segment.

130
00:05:45,228 --> 00:05:48,689
you're chopping it, let's say, really close down to making something really

131
00:05:48,749 --> 00:05:52,009
short. And as a result, you can sort of change the direction of that line a

132
00:05:52,029 --> 00:05:54,890
little bit and can throw things off. Or you have those two lines that are sort

133
00:05:54,910 --> 00:05:58,070
of like this, you saw examples in the previous talk. Or you might be doing

134
00:05:58,130 --> 00:06:00,951
successive operations and you get numerical drift and things get really

135
00:06:00,971 --> 00:06:04,952
bad. Okay. And we're gonna see examples of this issue later on because it's just

136
00:06:04,972 --> 00:06:09,093
something we have to be aware of. Okay. So geometries. Let's take a look at the

137
00:06:09,133 --> 00:06:09,733
building blocks.

138
00:06:10,582 --> 00:06:14,145
Now, triangles and planes, and your college math class

139
00:06:14,165 --> 00:06:17,528
probably taught you that a plane is a 2D subset of a 3D space.

140
00:06:18,429 --> 00:06:21,112
In games and graphics, of course, our planes and triangles

141
00:06:21,132 --> 00:06:26,076
have to specify an above and a below, or on top or in front, behind,

142
00:06:26,156 --> 00:06:27,357
whatever you like to call it.

143
00:06:28,065 --> 00:06:31,747
So for triangles, typically there'll be a normal vector for the triangle saying which way is above,

144
00:06:31,867 --> 00:06:34,269
and maybe a counterclockwise convention to the vertices.

145
00:06:35,090 --> 00:06:38,072
For planes, it's that a, b, and c of the plane equation

146
00:06:38,872 --> 00:06:40,874
that define the normal which points up above.

147
00:06:42,135 --> 00:06:48,499
Also note that I prefer to use the convention ax plus by plus cz plus d equals 0,

148
00:06:48,819 --> 00:06:53,603
because then I can think of my plane-to-point test as this 4D dot product of the homogeneous coordinate

149
00:06:53,803 --> 00:06:55,984
or homogeneous point with the plane equation itself.

150
00:06:57,105 --> 00:07:01,987
One more small note, often instead of saying A, B, C, D, people will interchange and say

151
00:07:02,127 --> 00:07:06,269
X, Y, Z, W because that's the same convention used for quaternions and homogeneous coordinates

152
00:07:06,329 --> 00:07:08,611
and float for registers and da-da-da-da-da.

153
00:07:10,720 --> 00:07:16,523
So now, one of the things that we're going to need to be able to do is, you know, maybe find the intersection of three planes.

154
00:07:16,623 --> 00:07:17,283
Where do they all meet?

155
00:07:17,863 --> 00:07:21,025
You could have three faces on a mesh, and you want to know that vertex location.

156
00:07:21,685 --> 00:07:25,967
All right, well, this is a classic linear algebra problem of three equations and three unknowns.

157
00:07:26,327 --> 00:07:29,889
The x and y and z components of your position v are the unknowns.

158
00:07:30,389 --> 00:07:34,051
So take your three normals from the plane equations, put them in a 3 by 3 matrix,

159
00:07:34,451 --> 00:07:39,013
invert that, multiply it by this vector that composes the w coordinates, and voila, you get your answer.

160
00:07:39,592 --> 00:07:41,433
Now if you have two planes that are parallel,

161
00:07:41,473 --> 00:07:43,775
well, that matrix won't be invertible, and there's no answer anyway.

162
00:07:43,835 --> 00:07:45,457
So all the math kind of nicely works out.

163
00:07:46,398 --> 00:07:48,019
All right.

164
00:07:48,339 --> 00:07:49,420
So what if we have four planes?

165
00:07:50,181 --> 00:07:52,303
Well, OK, I have to explain what I mean by this problem.

166
00:07:52,863 --> 00:07:54,125
And I'm going to do it with an example.

167
00:07:54,145 --> 00:07:55,045
Let's say I'm building a house.

168
00:07:55,065 --> 00:07:57,407
So I start with this floor, and I build up the walls,

169
00:07:57,508 --> 00:07:58,829
and then I'm constructing the roof.

170
00:07:59,629 --> 00:08:01,311
And before I'm done, I want to know, well,

171
00:08:01,331 --> 00:08:02,732
what's the top of that house going to look like?

172
00:08:03,313 --> 00:08:05,855
How do those four planes come together just based on the plane equations?

173
00:08:06,790 --> 00:08:08,130
And there's three possibilities for that.

174
00:08:08,150 --> 00:08:10,611
I can have the north-south come together first, or the east-west,

175
00:08:10,671 --> 00:08:11,971
or they might all actually meet at a point.

176
00:08:12,792 --> 00:08:15,112
Well, using what you just learned from a previous slide,

177
00:08:15,132 --> 00:08:16,593
you can think, oh, I'll grab three of the planes,

178
00:08:16,653 --> 00:08:18,173
generate a point, test it against a fourth plane.

179
00:08:18,333 --> 00:08:19,373
And yes, that will work.

180
00:08:20,074 --> 00:08:23,035
But one of the things that we like to do whenever we construct algorithms

181
00:08:23,095 --> 00:08:27,536
is, can we do it in such a way where we're not sort of picking,

182
00:08:27,656 --> 00:08:30,137
how do I pick the three, who's the odd man out, and so on?

183
00:08:30,737 --> 00:08:34,358
So instead of that, let's try putting all four plane equations now

184
00:08:34,418 --> 00:08:35,758
in a 4 by 4 matrix.

185
00:08:37,459 --> 00:08:40,342
Now, if they all do maybe at a point, well, then I'll

186
00:08:40,363 --> 00:08:42,425
have a solution to the equation that's shown on the slide here.

187
00:08:43,346 --> 00:08:45,488
But I'm multiplying something by something else, and I'm getting 0.

188
00:08:46,389 --> 00:08:48,712
That's only going to happen if that matrix is singular.

189
00:08:49,660 --> 00:08:51,121
And we know a simple test for that already.

190
00:08:51,922 --> 00:08:53,864
And that's saying if the determinant of the matrix is 0.

191
00:08:54,484 --> 00:08:59,489
Furthermore, if my plane equations are in this matrix

192
00:08:59,529 --> 00:09:03,072
in a nice counterclockwise order, and I

193
00:09:03,293 --> 00:09:05,315
don't put any of my roofing material on upside down,

194
00:09:05,855 --> 00:09:07,797
then I can use the sign of the determinant

195
00:09:07,817 --> 00:09:09,298
to distinguish between the other two cases.

196
00:09:10,999 --> 00:09:14,423
OK, now you've seen this, but I'm just going to ram it down your throat

197
00:09:14,443 --> 00:09:15,584
because everyone needs to know this.

198
00:09:15,624 --> 00:09:16,606
So sorry if it's for you.

199
00:09:17,046 --> 00:09:18,988
But intersecting a line with a plane, I've got two points,

200
00:09:19,008 --> 00:09:20,410
and I want to know where they meet.

201
00:09:21,051 --> 00:09:22,833
V0 to V1 is my line segment.

202
00:09:23,453 --> 00:09:25,996
I can do that test, and I know the distance above and or below the plane.

203
00:09:26,825 --> 00:09:27,105
OK?

204
00:09:27,685 --> 00:09:31,966
And so I think of now, as I'm traveling from v0 to v1,

205
00:09:31,986 --> 00:09:33,386
think of yourself moving that direction.

206
00:09:33,806 --> 00:09:38,167
And so it's a matter of just solving, at what time

207
00:09:38,187 --> 00:09:39,387
do I cross that plane?

208
00:09:39,947 --> 00:09:42,108
And shown on the right, that's high school math

209
00:09:42,128 --> 00:09:44,048
to find that value of t for time.

210
00:09:44,828 --> 00:09:47,009
So once you've got that, then you take that value,

211
00:09:47,049 --> 00:09:49,509
shove it back in your equation, sort of move along that line,

212
00:09:50,229 --> 00:09:54,930
that fraction t, and you've got your 3D point of impact.

213
00:09:56,788 --> 00:10:01,050
All right, so getting back to doing some interaction in a game,

214
00:10:01,330 --> 00:10:02,771
well, things are made of triangles.

215
00:10:03,151 --> 00:10:07,473
So if, let's say, the user clicks on his mouse,

216
00:10:07,493 --> 00:10:08,854
you want to know, well, what did he click on?

217
00:10:08,994 --> 00:10:10,835
Or you've got some bullet flying through the scene,

218
00:10:10,935 --> 00:10:12,135
and does it hit the bad guy?

219
00:10:12,835 --> 00:10:17,799
So here we have to test this ray, the path of the bullet, against our geometry, say a triangle.

220
00:10:18,380 --> 00:10:23,144
So the triangle sits on a plane, we find the point on the plane where it hits,

221
00:10:23,864 --> 00:10:28,628
and then we say, well, we don't know if it's inside or out, so we test against all of the edges.

222
00:10:29,068 --> 00:10:31,450
This is the simple, easy, simplistic way of doing it.

223
00:10:32,071 --> 00:10:39,777
And in order to test against an edge, you have the edge cross product from one of the edge vertices to the point,

224
00:10:40,437 --> 00:10:40,878
and if that...

225
00:10:41,470 --> 00:10:43,652
cross product vector points the same direction as the normal,

226
00:10:43,772 --> 00:10:45,373
then, yeah, it's on the inside of that edge.

227
00:10:45,753 --> 00:10:47,574
On the inside of all three edges, you hit the triangle.

228
00:10:47,714 --> 00:10:49,435
Outside any of the edges, obviously you missed.

229
00:10:51,497 --> 00:10:53,738
And that's sort of the simple first implementation

230
00:10:53,758 --> 00:10:55,059
that you might write and implement.

231
00:10:56,120 --> 00:10:57,881
Okay, but things in your game,

232
00:10:58,001 --> 00:10:59,802
they have like thousands of triangles on them.

233
00:11:00,222 --> 00:11:01,083
Well, the answer's simple.

234
00:11:01,123 --> 00:11:02,744
Just check against all of the triangles.

235
00:11:03,524 --> 00:11:03,705
Now.

236
00:11:04,619 --> 00:11:08,121
Okay, that's obviously going to be fairly inefficient, and I invite you all tomorrow

237
00:11:08,141 --> 00:11:11,303
to attend Gino's talk on spatial structures, because he'll tell you how to rule out many

238
00:11:11,343 --> 00:11:14,746
of those tests altogether. Okay, but just conceptually for now, you can sort of think

239
00:11:14,786 --> 00:11:20,530
of it that way. But also keep in mind, depending on how you traverse the spatial structures and

240
00:11:20,930 --> 00:11:24,833
what's in your scene, you know, if you detect a hit, ooh, I got a triangle, well, you might

241
00:11:24,853 --> 00:11:28,715
have to keep checking, because there might be something closer, right, you know, that hits.

242
00:11:28,735 --> 00:11:31,117
So as you're checking, you sort of shorten your array and keep going.

243
00:11:31,577 --> 00:11:33,518
Because you don't want to spray a bunch of bullets

244
00:11:33,538 --> 00:11:35,279
against a crowd and have the people in the back fall down.

245
00:11:35,339 --> 00:11:36,900
No, no, you want the zombies in the front to fall down.

246
00:11:38,261 --> 00:11:40,462
Next, here's an issue you need to be aware of,

247
00:11:40,482 --> 00:11:42,944
is I can have two triangles nicely sitting together.

248
00:11:44,024 --> 00:11:46,105
And I shoot a ray, and it goes right through.

249
00:11:46,946 --> 00:11:48,187
But it's the same edge.

250
00:11:48,207 --> 00:11:49,027
They've got the same points.

251
00:11:49,728 --> 00:11:51,889
And that's because of this naive implementation.

252
00:11:51,929 --> 00:11:53,790
When I'm checking against one triangle,

253
00:11:53,890 --> 00:11:55,331
I generate a point on that plane.

254
00:11:55,431 --> 00:11:57,492
And let's say, numerical precision just

255
00:11:57,512 --> 00:11:58,392
falls outside an edge.

256
00:11:58,933 --> 00:11:59,813
Check the other triangle.

257
00:12:00,414 --> 00:12:02,195
Well, I'm projecting onto a different plane,

258
00:12:02,215 --> 00:12:03,515
so I'm generating a different point.

259
00:12:04,916 --> 00:12:07,438
And so you have to be aware of this.

260
00:12:07,638 --> 00:12:09,899
A simple fix would be to make the triangles a little bigger

261
00:12:09,939 --> 00:12:10,339
or something.

262
00:12:10,699 --> 00:12:12,981
Or you can go back and study Geno's slides

263
00:12:13,761 --> 00:12:15,622
with plucker coordinates and do this all the correct way.

264
00:12:16,663 --> 00:12:20,645
Now, and finally, your meshes themselves,

265
00:12:20,665 --> 00:12:21,726
well, they have to be intact.

266
00:12:22,446 --> 00:12:23,927
If you've got t intersections that are holes,

267
00:12:23,947 --> 00:12:25,788
you can imagine a bullet flying right through where

268
00:12:25,808 --> 00:12:26,628
there's a missing triangle.

269
00:12:27,510 --> 00:12:30,091
And that brings us to this notion of solid geometry.

270
00:12:30,171 --> 00:12:33,373
And we touched on that a little bit in the last section, you saw that.

271
00:12:33,813 --> 00:12:36,595
And that's this idea where you have a borderless manifold mesh.

272
00:12:36,655 --> 00:12:39,897
So anytime you have an edge, there's a face on both sides.

273
00:12:39,957 --> 00:12:43,499
And the normals are sort of all consistently facing outward and so on.

274
00:12:44,460 --> 00:12:45,621
And then it's all watertight.

275
00:12:45,681 --> 00:12:46,701
Nothing could leak in or out.

276
00:12:47,021 --> 00:12:49,683
And so the mesh itself becomes this infinitely thin boundary

277
00:12:49,723 --> 00:12:52,145
representation separating solid matter from empty space.

278
00:12:54,229 --> 00:12:57,072
And then, given that, I can take a point,

279
00:12:57,632 --> 00:12:59,915
and I can say whether that point definitively

280
00:12:59,955 --> 00:13:01,336
is inside or outside of my mesh.

281
00:13:01,636 --> 00:13:02,877
Just simply cast a long ray.

282
00:13:02,897 --> 00:13:04,419
If you first hit the backside of a polygon,

283
00:13:04,619 --> 00:13:06,020
it has to be on the inside of the object.

284
00:13:06,461 --> 00:13:10,064
Otherwise, it's free and clear in empty space outside.

285
00:13:12,026 --> 00:13:13,988
All right, so that's a little bit of review for everyone.

286
00:13:14,526 --> 00:13:17,229
Now I'm going to dive deep into convex meshes.

287
00:13:19,031 --> 00:13:23,817
Now your university classes or textbooks might have described a convex set

288
00:13:24,437 --> 00:13:27,961
is one for which any two elements, if you have picked any two elements

289
00:13:28,001 --> 00:13:31,986
in that set, the line segment between them must also be contained in that set.

290
00:13:32,489 --> 00:13:35,391
OK, now a more intuitive way to understand a convex mesh

291
00:13:35,431 --> 00:13:37,993
is to think, any time you've got two neighboring faces,

292
00:13:38,053 --> 00:13:39,915
their normals are going to be tilting away from each other

293
00:13:39,935 --> 00:13:40,936
instead of towards each other.

294
00:13:40,956 --> 00:13:45,740
A test for that, take the cross product of face A with face B,

295
00:13:45,980 --> 00:13:48,762
and the result should run in the same direction as the edge

296
00:13:48,802 --> 00:13:49,703
according to face A.

297
00:13:51,106 --> 00:13:55,069
You can also think of a convex mesh as a volume bounded by a number of planes,

298
00:13:55,409 --> 00:13:57,531
the intersection of a number of half spaces, essentially.

299
00:13:58,291 --> 00:14:02,315
Or, you can think of every vertex lies at or below every other face.

300
00:14:03,676 --> 00:14:08,580
So, the reason for convex meshes is that a lot of algorithms become so much easier to implement.

301
00:14:10,737 --> 00:14:14,539
For example, an in-and-out test. Well, to test if a point's inside a convex mesh,

302
00:14:14,579 --> 00:14:19,001
I just have to check with all the plane equations. If you're underneath any all the planes, you're inside.

303
00:14:19,121 --> 00:14:24,164
I don't worry about those edge tests and corner cases, numeric robustness, and all that. So that gets a little easier.

304
00:14:25,885 --> 00:14:31,908
Testing a ray, you know, like that bullet flying through space, whatever. For a ray intersecting a convex, well,

305
00:14:32,589 --> 00:14:35,350
for, okay, so I've got that ray and then for

306
00:14:36,395 --> 00:14:37,736
I've got this thing made out of planes.

307
00:14:38,036 --> 00:14:40,577
And just for whenever I take all the planes that

308
00:14:40,597 --> 00:14:43,478
are facing against the ray, so like the dot product of the ray

309
00:14:43,679 --> 00:14:45,199
and that plane normal is less than 0,

310
00:14:45,839 --> 00:14:48,501
and then it's just cropping any part of the ray that lies above.

311
00:14:49,061 --> 00:14:51,962
So here I'm sort of moving the back start of the ray, this v0,

312
00:14:52,262 --> 00:14:56,764
moving it up as it's being chopped by each of these planes.

313
00:14:57,264 --> 00:14:59,625
And then if I'm left with something of positive length,

314
00:15:00,386 --> 00:15:02,847
then that v0 is now the point of impact.

315
00:15:03,127 --> 00:15:05,088
The last plane that sliced it is the normal of impact.

316
00:15:06,718 --> 00:15:09,522
And this generalizes, of course, to a general line segment

317
00:15:10,463 --> 00:15:11,204
with two endpoints.

318
00:15:11,404 --> 00:15:15,770
And in addition to trimming from v0 with the front-facing planes,

319
00:15:15,930 --> 00:15:18,254
I trim v1 with the back-facing planes.

320
00:15:18,834 --> 00:15:20,817
And if I'm left with something a positive length at the end,

321
00:15:20,897 --> 00:15:23,160
then that's what's stuck inside my object.

322
00:15:24,142 --> 00:15:24,362
All right.

323
00:15:24,960 --> 00:15:26,580
So convex to convexes.

324
00:15:27,041 --> 00:15:30,342
Well, there's a nice property here that if two convex objects are not

325
00:15:30,422 --> 00:15:33,704
interpenetrating, there'll be a separating plane between them.

326
00:15:34,024 --> 00:15:36,225
And I'm sure the physics sessions tomorrow, if you attend those,

327
00:15:36,245 --> 00:15:38,606
they'll tell you all about fast ways to find these.

328
00:15:39,526 --> 00:15:44,248
Furthermore, if they are separated, one of the planes that will separate the two

329
00:15:44,308 --> 00:15:46,809
will be either a face from one, a face from the other,

330
00:15:47,169 --> 00:15:50,231
or something that takes an edge from each and the cross-projects as it's

331
00:15:50,251 --> 00:15:50,511
normal.

332
00:15:52,192 --> 00:15:53,372
Learn more about that tomorrow, I'm sure.

333
00:15:54,559 --> 00:15:59,442
If two convexes are touching, then the area, or contact patch which they're touching,

334
00:15:59,622 --> 00:16:03,205
will be either a point, a line segment, or itself a convex polygon.

335
00:16:03,225 --> 00:16:06,087
So you can understand why physics engines really like these things.

336
00:16:06,867 --> 00:16:07,068
OK.

337
00:16:07,768 --> 00:16:09,689
So I've sold you that, hey, convexes are cool.

338
00:16:09,710 --> 00:16:11,091
We want to use these for a lot of reasons.

339
00:16:11,591 --> 00:16:14,353
But I've got things in my scene, and oh, they're not convex.

340
00:16:14,433 --> 00:16:14,873
What do I do?

341
00:16:15,376 --> 00:16:20,227
Well, in that case, you generate a convex hull for those meshes,

342
00:16:20,608 --> 00:16:24,597
which is simply the smallest convex mesh that contains the original mesh.

343
00:16:25,238 --> 00:16:26,040
Well, so how do you do that?

344
00:16:27,448 --> 00:16:33,733
There's something that people have been doing for like 40 years now, and there's two general categories of approaches for generating convex hulls.

345
00:16:34,193 --> 00:16:39,337
You can start with like a big bounding box, and you kind of shrink it down and slice it, chop it,

346
00:16:39,437 --> 00:16:43,120
you know, whatever, until you get something that tightly fits all your points.

347
00:16:43,141 --> 00:16:44,722
Or you can start really small with like, you know,

348
00:16:44,742 --> 00:16:49,366
maybe a couple back-to-back triangles or tetrahedrons, something convex, and then you add points to it,

349
00:16:49,466 --> 00:16:53,329
keeping it convex as you grow it out until you've grown it out to contain all your points.

350
00:16:54,850 --> 00:16:56,710
So the most popular implementation out there

351
00:16:57,771 --> 00:16:59,492
is QHOL, based on the QuickHOL paper.

352
00:16:59,772 --> 00:17:01,713
And it's one of these expansionist types

353
00:17:01,753 --> 00:17:02,273
of algorithms.

354
00:17:03,413 --> 00:17:05,394
It works in an arbitrary number of dimensions,

355
00:17:05,414 --> 00:17:06,514
but typically if you're going to use it,

356
00:17:06,535 --> 00:17:08,095
you're going to use it for three-dimensional things.

357
00:17:09,216 --> 00:17:10,796
And it's one of the expansionist approaches.

358
00:17:10,956 --> 00:17:12,537
And so I've just illustrated what

359
00:17:12,577 --> 00:17:13,797
that looks like on the right.

360
00:17:14,638 --> 00:17:16,599
I've got some convex mesh, and there's a new point

361
00:17:16,619 --> 00:17:17,359
that we're going to add.

362
00:17:17,959 --> 00:17:20,080
Find all the faces for which it's above.

363
00:17:20,861 --> 00:17:23,648
Okay, then you throw those away, and there's left with the silhouette,

364
00:17:23,668 --> 00:17:27,738
and then you fill that hole with a new fan of polygons.

365
00:17:28,724 --> 00:17:34,286
An issue is you get, oh, and then just continue for the next vertex and so on until you've

366
00:17:34,306 --> 00:17:35,346
grown it up as big as you want.

367
00:17:35,827 --> 00:17:40,968
But at each step, you have this issue where, you know, you have to make sure that things

368
00:17:41,008 --> 00:17:42,409
are still intact and convex.

369
00:17:42,469 --> 00:17:46,130
And even the original quick-haul paper says, yeah, we have these numerical robustness issues,

370
00:17:46,150 --> 00:17:46,931
they always show up.

371
00:17:47,371 --> 00:17:50,932
You just have to, you know, constantly scan for them and fix them when you see them.

372
00:17:51,492 --> 00:17:53,253
What that might look like is as follows.

373
00:17:53,373 --> 00:17:56,814
Here I've got some little hole and I grow it with this new yellow point out here.

374
00:17:57,686 --> 00:17:59,487
throw away a couple triangles and add these three.

375
00:17:59,527 --> 00:18:01,048
And notice that one of them is kind of skinny.

376
00:18:02,128 --> 00:18:05,129
So you can see where something skinny like that,

377
00:18:05,610 --> 00:18:08,331
the normal might be bent over in a weird way,

378
00:18:08,371 --> 00:18:09,491
and it might not be convex.

379
00:18:09,852 --> 00:18:11,352
And so maybe flipping an edge or something

380
00:18:11,372 --> 00:18:12,273
will fix that sort of thing.

381
00:18:14,318 --> 00:18:19,200
And these algorithms typically work with, you know, WingDig data structures, which are very effective for this.

382
00:18:19,581 --> 00:18:22,802
But there's also a simple approach for hull generation.

383
00:18:24,203 --> 00:18:26,304
Just based on triangle meshes, it also works.

384
00:18:26,984 --> 00:18:30,225
And that's to think of, again, it's one of these expansion approaches.

385
00:18:30,686 --> 00:18:36,888
So you have this triangulated mesh, and anytime I want to iteratively grow the hull with new points,

386
00:18:37,429 --> 00:18:42,111
I find all the triangle structures above, then I take a tetrahedron and I glue it on top.

387
00:18:43,134 --> 00:18:47,436
So the three points are the three vertices of the triangle that I'm putting it on top of,

388
00:18:47,476 --> 00:18:48,897
and the fourth point is my new point up here.

389
00:18:49,898 --> 00:18:53,080
And then, you know, because we don't want all this stuff inside,

390
00:18:53,300 --> 00:18:55,461
we sort of just delete all the back-to-back triangles,

391
00:18:55,521 --> 00:18:58,243
and I'm left with just the boundary representation on the outside.

392
00:18:58,982 --> 00:19:04,786
So, you know, fairly simple, fairly elegant, but it too runs into this numerical robustness problem,

393
00:19:05,987 --> 00:19:08,249
because you can generate the folds and stuff even with this approach.

394
00:19:08,389 --> 00:19:14,873
So, I'm going to sort of dive into an example here to illustrate how they happen and how to fix them.

395
00:19:15,433 --> 00:19:19,776
So, imagine I've got some point cloud and a bunch of vertices that I'm generating a convex hull for.

396
00:19:20,417 --> 00:19:25,841
And five of these points, A, B, C, D, E, are at one end of this cloud and they're all sort of coplanar-ish.

397
00:19:26,773 --> 00:19:29,779
And at some point, I've generated an intermediate hull

398
00:19:29,839 --> 00:19:31,602
that's got all the points except for E.

399
00:19:32,544 --> 00:19:34,988
And now we want to add E to our hull for whatever reason.

400
00:19:36,244 --> 00:19:39,026
And OK, so I test E with the left triangle.

401
00:19:39,386 --> 00:19:43,569
And using 6-bit mathematics, it tells me that it's below.

402
00:19:43,589 --> 00:19:45,971
And then I test with the right triangle,

403
00:19:46,031 --> 00:19:48,392
and bad numerical precision, and it tells me, oh yeah,

404
00:19:48,552 --> 00:19:49,533
you're above that triangle.

405
00:19:50,193 --> 00:19:51,474
So then I have to slap a tetrahedron

406
00:19:51,534 --> 00:19:53,576
on top of the right triangle, lift it up,

407
00:19:54,116 --> 00:19:56,918
and this new vertex is over to E. Well, look what happened.

408
00:19:56,938 --> 00:19:58,539
I've got this upside down red triangle

409
00:19:58,559 --> 00:19:59,580
that's facing the wrong way.

410
00:20:00,160 --> 00:20:02,501
So as long as I have one point that's inside my convex hull,

411
00:20:02,582 --> 00:20:04,203
I can test for these and detect them.

412
00:20:04,683 --> 00:20:07,225
The solution is as simple as the way we're generating these hulls.

413
00:20:07,565 --> 00:20:09,767
You just take a new tetrahedron, you shove it in there.

414
00:20:10,188 --> 00:20:12,510
What it does, it deletes the bad triangle and the one

415
00:20:12,530 --> 00:20:13,871
that we didn't lift up in the first place,

416
00:20:14,251 --> 00:20:16,253
generates the two green triangles shown on the far right.

417
00:20:16,774 --> 00:20:20,497
And I'm left with this nice convex hull, everything facing outward as we like.

418
00:20:22,078 --> 00:20:22,799
And that's how that works.

419
00:20:22,999 --> 00:20:23,259
All right.

420
00:20:23,988 --> 00:20:28,149
So a lot of the off-the-shelf convex hull algorithms out there

421
00:20:28,190 --> 00:20:31,811
are going to generate your complete hull with all points on the extreme.

422
00:20:32,471 --> 00:20:34,252
But you may not really need all of those.

423
00:20:34,372 --> 00:20:37,233
Imagine if you've got a whole bunch of points in a point cloud,

424
00:20:37,913 --> 00:20:40,514
and there's sort of this round feature on the side.

425
00:20:41,475 --> 00:20:42,995
Every single one of those points, if they're extreme,

426
00:20:43,055 --> 00:20:43,856
are going to be included.

427
00:20:44,436 --> 00:20:47,017
The thing is, a convex hull is already this gross approximation.

428
00:20:47,297 --> 00:20:49,218
I mean, you don't need that many points.

429
00:20:49,238 --> 00:20:50,798
Maybe 30 will probably be more than enough.

430
00:20:52,014 --> 00:20:55,395
So the quick hull algorithm, it's order n log n time.

431
00:20:55,695 --> 00:20:57,755
And that's a contribution in the paper.

432
00:20:57,775 --> 00:21:00,416
One of the reasons that it is that way

433
00:21:00,456 --> 00:21:02,656
is because of the way they sort of order vertices

434
00:21:02,676 --> 00:21:03,396
to add to the hull.

435
00:21:04,196 --> 00:21:05,836
So instead of that, we don't really

436
00:21:05,856 --> 00:21:08,157
care about order n log n because this is offline processing

437
00:21:08,177 --> 00:21:08,497
typically.

438
00:21:08,517 --> 00:21:11,117
We're just kind of preparing our stuff to use at runtime.

439
00:21:11,157 --> 00:21:11,977
This isn't at runtime.

440
00:21:12,658 --> 00:21:16,318
But let's instead, at each step, let's always

441
00:21:16,378 --> 00:21:17,738
pick the best vertex.

442
00:21:17,798 --> 00:21:19,019
So we're always picking the best one

443
00:21:19,039 --> 00:21:21,019
to increase our volume of our hull the most.

444
00:21:21,659 --> 00:21:25,301
And then we can just stop if adding new vertices doesn't improve it,

445
00:21:25,522 --> 00:21:28,383
or if we've kind of reached a threshold, we don't want any more vertices in that.

446
00:21:28,403 --> 00:21:29,284
Okay.

447
00:21:30,125 --> 00:21:32,406
So that's the way to, you know, make your stuff game efficient.

448
00:21:32,426 --> 00:21:33,106
Okay.

449
00:21:34,387 --> 00:21:39,150
Furthermore, there's this trade-off between minimizing the number of planes

450
00:21:39,310 --> 00:21:40,731
versus minimizing the number of points.

451
00:21:41,152 --> 00:21:44,994
And what I've shown up here is two platonic solids that illustrate this trade-off perfectly.

452
00:21:45,454 --> 00:21:46,835
One has fewer planes, one has fewer points.

453
00:21:47,600 --> 00:21:52,602
Now, the algorithms I described for creating simplified Hull work on vertices, and they're triangulated.

454
00:21:53,222 --> 00:21:58,983
But you can use what's known as a geometric dual to solve for the other one.

455
00:21:59,524 --> 00:22:03,645
And I'll just kind of leave it as an exercise to look that up and study it,

456
00:22:03,705 --> 00:22:05,805
because I don't have a whole lot of time to get into a lot of detail.

457
00:22:06,145 --> 00:22:08,286
But essentially, by taking the dual—

458
00:22:08,506 --> 00:22:12,287
and, you know, so I have all these points that are actually the plane equations from this original full Hull—

459
00:22:12,927 --> 00:22:15,248
when you compute a simplified Hull that minimizes vertices,

460
00:22:15,748 --> 00:22:17,588
You're actually minimizing planes, take the dual back,

461
00:22:17,768 --> 00:22:21,149
and you've got a hull that will look more like the one on the right.

462
00:22:21,569 --> 00:22:23,349
Vertices will typically have a valence of three,

463
00:22:24,449 --> 00:22:27,450
and faces will have five or six sides, as opposed

464
00:22:27,470 --> 00:22:28,550
to something that looks triangulated.

465
00:22:30,370 --> 00:22:32,871
And there's a trade-off.

466
00:22:32,911 --> 00:22:36,951
Sometimes you want fewer vertices if it's something

467
00:22:36,991 --> 00:22:38,612
like you're doing GJK a lot.

468
00:22:38,932 --> 00:22:41,032
Sometimes if you're doing a lot of plane tests,

469
00:22:41,052 --> 00:22:42,012
then you want to have fewer planes.

470
00:22:42,052 --> 00:22:44,993
So there's trade-offs for which is better.

471
00:22:46,228 --> 00:22:46,469
All right.

472
00:22:47,631 --> 00:22:49,914
OK, so you know how to generate convex hulls,

473
00:22:49,954 --> 00:22:54,080
but let's say I've got some objects that it's not realistic enough.

474
00:22:54,160 --> 00:22:57,144
And things are colliding in the air, and it just doesn't look right.

475
00:22:57,425 --> 00:22:58,687
The fidelity is missing.

476
00:22:59,372 --> 00:23:02,874
So the solution there is to take more complicated objects

477
00:23:02,974 --> 00:23:05,556
and break them down into convex parts so you get a tighter fit.

478
00:23:06,057 --> 00:23:08,298
And artists can do this in 3ds Max or Maya.

479
00:23:08,939 --> 00:23:11,521
But fortunately, that can be a bit of work.

480
00:23:11,841 --> 00:23:13,662
Fortunately, there's a couple tools out there that can help.

481
00:23:14,403 --> 00:23:17,025
John Ratcliffe on the PhysX team now at NVIDIA,

482
00:23:17,545 --> 00:23:20,527
and Cled Mamow, who now works at AMD, both of these guys

483
00:23:20,587 --> 00:23:22,969
have written software.

484
00:23:22,989 --> 00:23:24,831
It's open source, free to download and use,

485
00:23:25,511 --> 00:23:26,612
that you can throw in your game engine

486
00:23:26,632 --> 00:23:27,793
and it'll do exactly this for you.

487
00:23:28,810 --> 00:23:30,771
Alternatively, if you've got skin characters,

488
00:23:31,131 --> 00:23:33,972
well, you've already kind of done the work, because it's rigged.

489
00:23:33,992 --> 00:23:34,692
You've got bones.

490
00:23:35,052 --> 00:23:36,693
You can grab a bone.

491
00:23:37,153 --> 00:23:40,314
For all the bones, simply sample your skin mesh.

492
00:23:40,874 --> 00:23:43,034
Find any vertices that are weighted to that bone,

493
00:23:43,815 --> 00:23:46,115
and generate a hull or collision volume based on that.

494
00:23:47,036 --> 00:23:48,276
So an example of that is shown here.

495
00:23:48,894 --> 00:23:52,135
And OK, I mean, you've all seen ragdolls falling down stairs

496
00:23:52,175 --> 00:23:53,255
demos and that sort of thing.

497
00:23:53,315 --> 00:23:55,356
So here, you see this is the skin mesh

498
00:23:55,376 --> 00:23:56,857
that we're drawing and showing.

499
00:23:59,218 --> 00:24:02,339
But instead of the actual skin mesh doing the interaction,

500
00:24:02,379 --> 00:24:04,380
it's really the underlying bones that

501
00:24:05,620 --> 00:24:07,281
are doing all the collision detection

502
00:24:07,321 --> 00:24:08,281
and interacting in the scene.

503
00:24:09,634 --> 00:24:11,516
So that would be the way to do it.

504
00:24:11,816 --> 00:24:15,258
And not just characters like full body, but other types of objects as well,

505
00:24:15,478 --> 00:24:17,280
you would do the same sort of thing.

506
00:24:17,480 --> 00:24:18,981
And there's our ragdoll hand, for example.

507
00:24:22,564 --> 00:24:25,566
Next, we're going to take a little detour and take a look

508
00:24:25,626 --> 00:24:29,729
at Boolean operations, another fun subject in computational solid

509
00:24:29,749 --> 00:24:30,189
geometry.

510
00:24:31,068 --> 00:24:36,411
So this is when you have a mesh, you remember they're solid, they define sort of empty and solid space.

511
00:24:36,972 --> 00:24:41,494
And if I have two of them, I can do set operations, union, intersection, and subtraction.

512
00:24:41,854 --> 00:24:43,295
A couple examples are shown in this video.

513
00:24:44,706 --> 00:24:50,189
Now in the general case, you know, you want to have a good winged edge data structure to implement this and what you would do

514
00:24:50,289 --> 00:24:50,709
is you would

515
00:24:51,509 --> 00:24:55,771
take all the edges of one, slice them with all the faces the other and vice versa and

516
00:24:55,811 --> 00:25:00,794
then whenever one passes in or out of the other you have to sort of tessellate along it, you know,

517
00:25:00,814 --> 00:25:03,935
adding new edges and for the other one as well and

518
00:25:03,975 --> 00:25:09,238
then match those edges and then sort of take half of one, half of the other, stick them together,

519
00:25:09,418 --> 00:25:10,558
you got your Boolean operation.

520
00:25:12,024 --> 00:25:16,769
Now, what I described in a few sentences is actually a heck of a lot harder to implement.

521
00:25:17,130 --> 00:25:20,513
You know, you've got all those corner cases, numeric robustness, you know, tolerance issues.

522
00:25:20,733 --> 00:25:21,874
It's not easy.

523
00:25:22,595 --> 00:25:27,881
So let's take a step back and think, okay, where are we going to use this stuff?

524
00:25:28,441 --> 00:25:31,304
You know, certainly level design, modeling, there's applications there.

525
00:25:31,685 --> 00:25:34,007
But a lot of the R tools, they already have this stuff built in.

526
00:25:35,689 --> 00:25:40,031
So if you're thinking at runtime, well, hey, destruction is kind of fun,

527
00:25:40,111 --> 00:25:42,952
or geomod where I'm tunneling through some environments and that.

528
00:25:43,772 --> 00:25:46,193
But in these cases, I don't have an artist who's

529
00:25:46,433 --> 00:25:48,373
finely tweaking and placing points.

530
00:25:48,534 --> 00:25:50,474
No, no, I'm checking grenades and blowing stuff up.

531
00:25:50,914 --> 00:25:55,536
So you might be thinking, OK, is there a quick and dirty, simple approach?

532
00:25:55,556 --> 00:25:58,157
Maybe something based on convexes, since we've been looking at those recently.

533
00:25:58,837 --> 00:26:00,478
And sure, OK, let's explore that a little bit.

534
00:26:01,427 --> 00:26:05,709
So we've already seen mesh cropping or slicing,

535
00:26:05,809 --> 00:26:07,210
where we're chopping all the edges.

536
00:26:07,970 --> 00:26:13,053
If you crop a convex mesh, you have this nice property

537
00:26:13,073 --> 00:26:16,155
that you get an open loop, but there's only going to be one.

538
00:26:16,836 --> 00:26:18,256
In general mesh, you can get more.

539
00:26:19,097 --> 00:26:21,799
But then that loop is also going to be a convex polygon.

540
00:26:22,079 --> 00:26:23,580
So it'll be easier to triangulate

541
00:26:24,060 --> 00:26:25,621
when you get to that step for rendering.

542
00:26:26,402 --> 00:26:32,363
So, intersecting two convexes, you can think of it as cropping one with all the planes of the other.

543
00:26:33,304 --> 00:26:40,105
Okay, but you say, wait, wait, wait a sec. You saw I took a convex mesh earlier and another convex mesh

544
00:26:40,646 --> 00:26:43,847
and I subtracted one from the other and the result wasn't convex. How does that work?

545
00:26:44,793 --> 00:26:47,376
Well, that's because that was a subtraction, not

546
00:26:47,416 --> 00:26:48,077
an intersection.

547
00:26:48,217 --> 00:26:51,020
The subtraction with the solid is

548
00:26:51,060 --> 00:26:54,184
the same as doing an intersection with all

549
00:26:54,224 --> 00:26:55,165
the stuff around it.

550
00:26:55,785 --> 00:26:58,108
So you can do non-convex operands

551
00:26:58,148 --> 00:27:01,812
as a union of a bunch of convex operands.

552
00:27:02,132 --> 00:27:04,575
So basically do all those convex to convex intersections

553
00:27:04,615 --> 00:27:06,377
and then just throw the result together.

554
00:27:08,543 --> 00:27:12,545
All right, but even crop, OK, we saw convex hull, you know,

555
00:27:13,945 --> 00:27:14,506
chopping a line.

556
00:27:14,946 --> 00:27:17,187
Even chopping a convex object, you're

557
00:27:17,227 --> 00:27:20,428
subject to those annoying numerical robustness issues.

558
00:27:21,149 --> 00:27:24,130
And you can do things like, OK, check the planes,

559
00:27:24,170 --> 00:27:26,791
make sure you're not generating any sort of twist.

560
00:27:26,851 --> 00:27:27,852
Because if you have a plane that's

561
00:27:27,892 --> 00:27:30,573
coming very close to a vertex, if you make a mistake

562
00:27:30,613 --> 00:27:33,734
and you sort of chop these edges instead of those ones,

563
00:27:33,774 --> 00:27:35,735
you can generate little problems at the corners.

564
00:27:36,784 --> 00:27:41,006
You know, but and then it still gets more hairy because you know, maybe you might have more than four planes

565
00:27:41,026 --> 00:27:45,147
You might have like five or six and so you're probably thinking oh, there's too many corner cases

566
00:27:45,227 --> 00:27:50,030
Is there something simple I can do like a snap to grid or something and just not have to deal with any of this stuff

567
00:27:50,530 --> 00:27:54,371
Okay, so here's a little trick that I've been doing for GeoMod for a while that it kind of works

568
00:27:55,432 --> 00:27:59,754
And that's not snap to grid, but it's something a little different. It's quantize the plane equations

569
00:28:00,575 --> 00:28:04,616
So any of the Boolean operands will only have plane equations

570
00:28:04,636 --> 00:28:06,057
that satisfy certain conditions.

571
00:28:06,357 --> 00:28:09,518
And what it is is I take for, remember our plane equations

572
00:28:09,558 --> 00:28:11,519
are ax plus by plus zz plus d equals 0.

573
00:28:12,079 --> 00:28:13,880
If I multiply those numbers by some number,

574
00:28:13,920 --> 00:28:14,840
it's still the same plane.

575
00:28:15,400 --> 00:28:17,121
So I make sure for any of the plane equations

576
00:28:17,601 --> 00:28:19,862
there exists some number I can multiply by so

577
00:28:19,882 --> 00:28:21,422
that a, b, c, d are all integers.

578
00:28:22,703 --> 00:28:24,263
Furthermore, a, b, and c are integers

579
00:28:24,283 --> 00:28:25,244
less than a small constant.

580
00:28:25,964 --> 00:28:26,204
All right.

581
00:28:26,674 --> 00:28:28,995
So now recall how when I have a vertex,

582
00:28:29,015 --> 00:28:30,796
it's going to be the intersection of three more planes.

583
00:28:31,377 --> 00:28:32,457
And how do we compute that?

584
00:28:32,537 --> 00:28:34,979
Well, we had this matrix, right?

585
00:28:35,799 --> 00:28:39,081
And that m matrix there of the normals, that's all integer values now.

586
00:28:39,902 --> 00:28:43,444
I invert it and multiply it by this vector, which are all integer values now.

587
00:28:44,344 --> 00:28:51,670
And so the result is going to be this point V, of which its x, y, and z components are all going to be rational numbers,

588
00:28:52,231 --> 00:28:55,353
where the denominator is no larger than the determinant.

589
00:28:55,814 --> 00:28:59,277
Because when I take an inverse of matrix, I have to divide by the determinant.

590
00:29:00,097 --> 00:29:04,301
So that means for any two points I generate, if they're not the same point,

591
00:29:04,581 --> 00:29:09,245
they'll have to be at least one over that determinant distance apart from each other.

592
00:29:10,158 --> 00:29:14,321
Well, what this gives me is a hard-coded, fixed epsilon

593
00:29:14,421 --> 00:29:19,105
I can throw in my code to tell me whether two points are the same or not.

594
00:29:20,306 --> 00:29:24,089
And based on that, I can throw rocks at this piece of glass all day,

595
00:29:24,430 --> 00:29:25,551
and nothing is ever going to break.

596
00:29:25,731 --> 00:29:27,412
Well, the glass is going to break, but the code isn't.

597
00:29:28,653 --> 00:29:29,514
So now.

598
00:29:31,017 --> 00:29:34,118
Now, even though I was doing this, there's no integer math in the implementation.

599
00:29:34,138 --> 00:29:37,340
No, no, no. All that stuff you saw in the last slide, that was just proof that this works.

600
00:29:37,780 --> 00:29:43,382
The implementation itself is, you know, floating-point math, 32-bit, you know, don't need double precision.

601
00:29:44,402 --> 00:29:46,523
Normals are of unit length, you know, just as you'd like.

602
00:29:47,184 --> 00:29:51,926
But the code itself doesn't have all those crazy corner cases, if-then-else

603
00:29:51,946 --> 00:29:53,467
statements, and this and that.

604
00:29:53,887 --> 00:29:57,109
So although here it's running on just a single core CPU,

605
00:29:57,249 --> 00:29:59,750
I mean, it potentially could run on a GPU fairly easily,

606
00:29:59,871 --> 00:30:01,451
like GPGPU type of implementation.

607
00:30:02,192 --> 00:30:02,952
And it's fairly efficient.

608
00:30:02,972 --> 00:30:06,454
I can do many Boolean operations per frame, break lots of glass.

609
00:30:06,514 --> 00:30:09,276
I can take the part that I chunk out, and I

610
00:30:09,316 --> 00:30:12,858
can generate little pieces of fragments or extra rigid bodies from them.

611
00:30:14,708 --> 00:30:18,469
So hey, that number theory course I took in university

612
00:30:18,489 --> 00:30:19,649
was actually useful for something.

613
00:30:20,469 --> 00:30:20,729
OK.

614
00:30:21,490 --> 00:30:24,931
Next, we're going to take a look at some other spatial properties

615
00:30:25,311 --> 00:30:26,951
of our solid objects.

616
00:30:27,631 --> 00:30:30,272
So when we have these meshes and they're solid, again,

617
00:30:30,352 --> 00:30:32,893
stressing that's an important factor, we can correctly

618
00:30:33,473 --> 00:30:36,934
calculate the volume, center mass, and the inertia of our objects,

619
00:30:37,394 --> 00:30:38,714
which will affect motions, we'll see.

620
00:30:40,313 --> 00:30:42,955
So I'm going to cover a little bit of review material

621
00:30:43,115 --> 00:30:46,696
or introductory material, depending on your perspective.

622
00:30:47,717 --> 00:30:49,778
So the center of mass of a triangle.

623
00:30:50,138 --> 00:30:51,338
Now, there's many ways to define center,

624
00:30:51,358 --> 00:30:52,319
but this is the center of mass.

625
00:30:52,339 --> 00:30:54,380
So if I chuck the triangle up in the air, what point is it

626
00:30:54,400 --> 00:30:55,020
going to spin around?

627
00:30:55,420 --> 00:30:59,442
That happens to be the point where if I take the three vertices

628
00:30:59,462 --> 00:31:01,182
and divide by 3, that's that point.

629
00:31:02,823 --> 00:31:06,005
The area of a triangle, well, if I take two edges,

630
00:31:06,245 --> 00:31:09,206
take the cross product, figure out its magnitude.

631
00:31:09,945 --> 00:31:11,466
Half of that is going to be the triangle area.

632
00:31:12,426 --> 00:31:14,707
Now, if I have a triangle with a predefined normal,

633
00:31:15,087 --> 00:31:16,828
well then, instead of taking the magnitude,

634
00:31:16,848 --> 00:31:18,368
I can just take the dot product with that normal.

635
00:31:18,388 --> 00:31:21,389
And the advantage here is I actually get a signed area.

636
00:31:21,529 --> 00:31:24,410
So I could have triangles with a negative area.

637
00:31:24,871 --> 00:31:26,191
And soon we will see why that's useful.

638
00:31:29,212 --> 00:31:30,612
Now, just to make it clear to everyone,

639
00:31:30,753 --> 00:31:32,413
it doesn't matter which two edges you pick.

640
00:31:33,493 --> 00:31:34,654
When you take the cross product, you're

641
00:31:34,674 --> 00:31:35,974
going to get the exact same result,

642
00:31:36,454 --> 00:31:37,515
unless you're going the other way,

643
00:31:37,535 --> 00:31:38,815
and then you'll get the negative result.

644
00:31:40,828 --> 00:31:45,573
OK, so how do I get the area of a polygon, something with endpoints?

645
00:31:46,033 --> 00:31:47,955
Well, break it down into a bunch of triangles.

646
00:31:48,575 --> 00:31:51,077
Find some reference point P, could be the origin, doesn't matter.

647
00:31:51,898 --> 00:31:55,601
And for every edge on my polygon, take those two vertices,

648
00:31:55,782 --> 00:31:59,285
my reference point, that's a triangle, and just add all those areas together.

649
00:32:00,356 --> 00:32:03,800
But what if this point P is on the outside of my polygon?

650
00:32:03,920 --> 00:32:06,883
Or if my polygon is all sorts of concavities and stuff,

651
00:32:06,923 --> 00:32:07,644
it's not convex.

652
00:32:08,124 --> 00:32:08,705
It doesn't matter.

653
00:32:08,745 --> 00:32:09,506
This still works.

654
00:32:10,046 --> 00:32:12,228
Because sure, I'm covering a bunch of area

655
00:32:12,268 --> 00:32:13,870
that's on the outside.

656
00:32:14,050 --> 00:32:18,675
But I'm also going to be adding these negative area triangles.

657
00:32:18,715 --> 00:32:19,836
It's going to cancel all that out.

658
00:32:20,037 --> 00:32:22,319
So you get the same result. It just works.

659
00:32:23,778 --> 00:32:23,959
OK.

660
00:32:24,680 --> 00:32:25,441
Oh, OK.

661
00:32:25,461 --> 00:32:28,205
So here, if I've got a tetrahedron, and now

662
00:32:28,245 --> 00:32:31,209
if I take the cross products from all four of the sides

663
00:32:31,289 --> 00:32:33,612
and combine them together, they cancel each other out.

664
00:32:33,993 --> 00:32:34,293
OK.

665
00:32:34,694 --> 00:32:36,997
So add these four vectors, and the result is 0.

666
00:32:38,331 --> 00:32:42,213
Now, remember how we generated those convex holes with the slapping the tetrahedrons together,

667
00:32:42,973 --> 00:32:46,495
and then removing the back-to-back triangles, which obviously those two normals would cancel out.

668
00:32:46,855 --> 00:32:53,278
So by mathematical induction, you can conclude that for any mesh that's closed and solid,

669
00:32:54,158 --> 00:32:57,720
adding up all the area-weighted normals is going to add up to zero.

670
00:32:58,400 --> 00:32:59,000
And that's why this works.

671
00:33:03,008 --> 00:33:07,370
Generating the polygon, the normal of a polygon with endpoints,

672
00:33:07,831 --> 00:33:08,991
and this could be a polygon.

673
00:33:09,011 --> 00:33:11,432
I shouldn't have drawn a convex one, because it could not actually

674
00:33:11,452 --> 00:33:14,454
work with something that's concave and points slightly off the plane

675
00:33:14,474 --> 00:33:15,114
equation and stuff.

676
00:33:15,874 --> 00:33:17,795
It's a matter of adding up all.

677
00:33:18,696 --> 00:33:22,720
combining all the triangle normals with the same sort of triangle summation, not

678
00:33:22,760 --> 00:33:26,004
the magnitudes but you know taking those vectors combining them together and

679
00:33:26,024 --> 00:33:29,888
getting this long green vector shown on the bottom right that is the normal of

680
00:33:29,928 --> 00:33:36,255
the polygon and length is double the area. Okay and again if this point P lies

681
00:33:36,355 --> 00:33:40,059
on lies on further away sure you know those arrows are going to grow.

682
00:33:40,572 --> 00:33:42,753
on top because there's more area, but there's also

683
00:33:43,933 --> 00:33:46,714
negative things pointing down that cancel each other out.

684
00:33:47,194 --> 00:33:49,715
The reference point P doesn't even have to lie in the same plane

685
00:33:49,755 --> 00:33:50,575
as all the other points.

686
00:33:51,995 --> 00:33:53,336
The only way it's going to break down is

687
00:33:53,356 --> 00:33:56,076
that if P is so far away that you're going to run into rounding error.

688
00:33:58,417 --> 00:33:59,977
All right, so that's the 2D stuff.

689
00:33:59,997 --> 00:34:02,158
Now let's start looking at the 3D things.

690
00:34:03,078 --> 00:34:05,699
You may have guessed that the center of mass of a tetrahedron

691
00:34:05,919 --> 00:34:07,380
is the average of the four vertices.

692
00:34:08,349 --> 00:34:08,809
and volume.

693
00:34:09,029 --> 00:34:10,530
OK, well, that's sort of base times height.

694
00:34:10,550 --> 00:34:11,231
Let's think of that.

695
00:34:12,252 --> 00:34:16,556
The base area is, you know, we have that cross product,

696
00:34:16,596 --> 00:34:19,018
which conveniently gives us this vector that points straight up.

697
00:34:19,398 --> 00:34:20,820
OK, so half of that.

698
00:34:22,251 --> 00:34:26,952
Now, in this vector form, we can take as our,

699
00:34:26,972 --> 00:34:30,313
because we don't know the height, per se,

700
00:34:30,573 --> 00:34:33,534
but we can take any edge leading up to our fourth vertex

701
00:34:34,154 --> 00:34:38,376
and dot product with that, because only this orthogonal component's

702
00:34:38,396 --> 00:34:40,436
going to matter, and that will give us our volume.

703
00:34:40,836 --> 00:34:42,677
But it's actually 1 third, because it's a pyramid.

704
00:34:43,850 --> 00:34:47,492
So this cross dot combo is also known as the triple product.

705
00:34:47,872 --> 00:34:51,574
And as mentioned in an earlier talk, it is mathematically equivalent to taking

706
00:34:52,174 --> 00:34:55,176
those three vectors, three edges from this tetrahedron,

707
00:34:55,216 --> 00:34:57,057
shoving them in a matrix and taking the determinant.

708
00:34:57,917 --> 00:34:57,997
OK.

709
00:34:59,458 --> 00:34:59,638
All right.

710
00:35:00,298 --> 00:35:03,740
So whatever we can deduce through simple geometric reasoning,

711
00:35:04,140 --> 00:35:06,621
we can also solve through very complicated calculus.

712
00:35:07,281 --> 00:35:11,363
So what I've shown here at the top is this is the definite integral.

713
00:35:12,015 --> 00:35:17,378
where the limits of the integration describe the limits,

714
00:35:17,438 --> 00:35:19,019
or the region, of the tetrahedron.

715
00:35:19,339 --> 00:35:21,200
And I can pass any function I want into there.

716
00:35:22,181 --> 00:35:26,904
So if I take my unit function, I pass it in, and run off for a few days,

717
00:35:26,964 --> 00:35:28,785
and write out all this calculus, and make sure I'm right,

718
00:35:29,085 --> 00:35:31,566
all will come back with the formula for the volume.

719
00:35:32,307 --> 00:35:36,609
If I pass in a function that basically returns the position,

720
00:35:36,629 --> 00:35:41,192
adjusted for volume, then I get back my center of mass.

721
00:35:42,284 --> 00:35:43,645
Now I'm going to invoke this a little bit later.

722
00:35:43,705 --> 00:35:46,268
I just want to take the opportunity now to scare everybody with it.

723
00:35:48,130 --> 00:35:50,853
So all right, you don't have a whole lot of four sided,

724
00:35:51,394 --> 00:35:52,935
four poly objects in your game.

725
00:35:52,955 --> 00:35:55,658
You probably have like thousands, tens of thousands

726
00:35:55,738 --> 00:35:57,060
of triangles on your objects.

727
00:35:57,523 --> 00:35:58,624
So how do you get the volume of them?

728
00:35:59,124 --> 00:36:02,386
Well, now, just like we saw a triangle summation, what we do here

729
00:36:02,446 --> 00:36:03,606
is tetrahedral summation.

730
00:36:04,146 --> 00:36:08,328
For all the triangles, the three points plus some reference point,

731
00:36:08,368 --> 00:36:11,289
perhaps the origin, we just add up all these tetrahedral volumes.

732
00:36:11,409 --> 00:36:13,250
And that gives us the volume of our entire object.

733
00:36:13,470 --> 00:36:16,852
And again, the same principle of things falling in the outside

734
00:36:16,892 --> 00:36:20,353
and negative volume tetrahedrons canceling out, it all just works.

735
00:36:21,114 --> 00:36:22,995
Center of mass, well, as you'd expect,

736
00:36:23,095 --> 00:36:25,396
it's just a volume-weighted average

737
00:36:25,536 --> 00:36:27,697
of all the center of masses of all the little tetrahedrons.

738
00:36:28,938 --> 00:36:31,379
So getting the right center of mass is a good thing to do.

739
00:36:31,599 --> 00:36:34,601
And here we have this catapult arm sort of thing.

740
00:36:35,101 --> 00:36:37,983
And we throw it in a physics scene,

741
00:36:38,023 --> 00:36:39,024
rig it up with a hinge joint.

742
00:36:39,044 --> 00:36:40,525
And there's sort of this large volume

743
00:36:40,565 --> 00:36:42,266
at the other end of the handle.

744
00:36:42,326 --> 00:36:44,767
So the center of mass, if we calculate it right,

745
00:36:44,787 --> 00:36:45,808
it's going to be somewhere around there.

746
00:36:46,228 --> 00:36:48,229
And then we just kind of let it fly in a game environment,

747
00:36:48,629 --> 00:36:50,350
and I get this nice behavior that we'd expect.

748
00:36:50,971 --> 00:36:52,593
Now, we didn't have to write any custom code.

749
00:36:52,853 --> 00:36:53,954
There's no springs here.

750
00:36:54,074 --> 00:36:55,856
This is just emergent behavior, the way

751
00:36:55,876 --> 00:36:58,099
that we like to enable artists to build things.

752
00:36:59,020 --> 00:37:03,004
Had I taken the bounding box of this object and taken its center

753
00:37:03,044 --> 00:37:04,566
and used that as a center of mass, we wouldn't

754
00:37:04,586 --> 00:37:05,748
have had this kind of behavior.

755
00:37:07,289 --> 00:37:10,753
So having solid meshes and solid matter matters.

756
00:37:12,189 --> 00:37:16,913
All right, so the third aspect of spatial properties that affects motion

757
00:37:16,973 --> 00:37:17,634
is the inertia.

758
00:37:18,655 --> 00:37:21,537
Hopefully, everyone's familiar with the moment of inertia in 2D.

759
00:37:22,298 --> 00:37:26,121
And you have this idea that if you've got something orbiting

760
00:37:26,161 --> 00:37:32,266
around a fixed axis, then for stuff that's further away from that axis,

761
00:37:32,387 --> 00:37:34,228
it takes a little bit more energy to get it up to speed.

762
00:37:34,886 --> 00:37:37,967
OK, so I've rewritten this moment of inertia calculation

763
00:37:38,347 --> 00:37:39,127
in a couple of ways here.

764
00:37:39,147 --> 00:37:41,108
So you can try to understand it as it's

765
00:37:41,128 --> 00:37:44,669
sort of the variance along x plus the variance along y

766
00:37:45,129 --> 00:37:47,530
to give you the moment of something spinning around z.

767
00:37:48,390 --> 00:37:50,211
Because when we step up to three dimensions,

768
00:37:51,151 --> 00:37:52,252
it's not a scalar anymore.

769
00:37:52,592 --> 00:37:55,273
We have a 3 by 3 matrix known as the inertia tensor that

770
00:37:55,313 --> 00:37:57,473
describes the motion of an object.

771
00:37:58,556 --> 00:38:00,838
And the form of that is shown in the bottom right.

772
00:38:00,938 --> 00:38:03,300
And then there's a high relationship between this matrix

773
00:38:03,520 --> 00:38:04,662
and the covariance matrix.

774
00:38:05,082 --> 00:38:06,303
So in order to compute inertia, we're

775
00:38:06,323 --> 00:38:07,865
actually going to compute covariance,

776
00:38:07,965 --> 00:38:10,727
because with one, you have the other, and vice versa.

777
00:38:12,109 --> 00:38:13,630
So if you studied statistics, this

778
00:38:13,670 --> 00:38:14,571
might look familiar to you.

779
00:38:15,472 --> 00:38:16,573
If not, it's still pretty easy.

780
00:38:17,394 --> 00:38:19,536
Imagine if I have an object that consists

781
00:38:19,576 --> 00:38:21,537
of a number of discrete little point masses.

782
00:38:22,338 --> 00:38:25,462
OK, to compute its covariance, it's

783
00:38:25,542 --> 00:38:28,325
simply summing up the outer product

784
00:38:28,345 --> 00:38:30,607
and all those positions with themselves in a matrix.

785
00:38:31,168 --> 00:38:33,551
So yes, here's yet another use of that outer product

786
00:38:33,791 --> 00:38:34,752
that I mentioned in the beginning.

787
00:38:36,344 --> 00:38:41,608
So, all right, that works for—that gives me the covariance of something with a bunch of points,

788
00:38:41,888 --> 00:38:44,270
but our objects are these continuous solids.

789
00:38:44,931 --> 00:38:48,894
So what we're going to try to do is one of those tetrahedral summation tricks.

790
00:38:48,994 --> 00:38:53,638
So now if I just get the covariance contribution from a single tetrahedron, then I'm done.

791
00:38:55,219 --> 00:38:58,062
So what I'm going to—now I'm going to re-invoke that scary triple integral,

792
00:38:58,082 --> 00:39:01,024
but I'm going to shove inside of it that outer product.

793
00:39:02,637 --> 00:39:06,558
And I did this online on Wolfram Alpha,

794
00:39:06,738 --> 00:39:09,319
where I'd shove in the equation, but then it timed out on me.

795
00:39:09,359 --> 00:39:10,939
So I had to put in part of the equation

796
00:39:10,979 --> 00:39:13,580
and then get half the result and then shove in the rest.

797
00:39:13,720 --> 00:39:15,961
Because the free version online just

798
00:39:15,981 --> 00:39:17,501
doesn't give you enough free cycles or something.

799
00:39:17,962 --> 00:39:19,982
But you have to trust me that the answer at the bottom

800
00:39:20,002 --> 00:39:20,542
there is the right.

801
00:39:21,183 --> 00:39:23,283
So now, I know this calculus might

802
00:39:23,303 --> 00:39:24,484
go over the heads of some people.

803
00:39:24,504 --> 00:39:25,184
Don't worry about it.

804
00:39:25,224 --> 00:39:28,125
What we have now is a formula for getting

805
00:39:28,685 --> 00:39:31,386
the covariance contribution from a single tetrahedron.

806
00:39:32,376 --> 00:39:34,517
And then, remember, we wanted to get the inertia.

807
00:39:34,838 --> 00:39:35,998
And so we have this covariance.

808
00:39:36,038 --> 00:39:38,660
And I've rewritten in the middle line there in another form,

809
00:39:38,680 --> 00:39:39,901
because it's a 3 by 3 matrix.

810
00:39:39,921 --> 00:39:42,042
So each of the ij elements of that matrix

811
00:39:42,062 --> 00:39:43,063
looks exactly like this.

812
00:39:43,564 --> 00:39:47,166
And we're summing over the mesh where u, v, and w

813
00:39:47,846 --> 00:39:52,209
are sort of the three vertices of each triangle.

814
00:39:52,369 --> 00:39:57,273
But because we know things will spin about their center of mass,

815
00:39:57,693 --> 00:39:58,914
we can't use any reference point.

816
00:39:58,934 --> 00:40:00,955
We have to use the center of mass as we do this summation.

817
00:40:02,324 --> 00:40:03,584
OK, so we got covariance.

818
00:40:04,125 --> 00:40:06,406
And then to get to inertia, it's that formula

819
00:40:06,526 --> 00:40:07,406
that's shown at the bottom.

820
00:40:08,387 --> 00:40:13,430
If you look at the top left, we see the yy plus zz

821
00:40:13,450 --> 00:40:15,311
in the upper left-hand corner of the inertia matrix.

822
00:40:15,711 --> 00:40:17,432
That's because if you're spinning around x,

823
00:40:17,492 --> 00:40:18,732
it's the stuff along x that doesn't matter.

824
00:40:18,752 --> 00:40:21,494
It's sort of the other two, the relationship between the two.

825
00:40:22,594 --> 00:40:25,056
But the matrices, covariance, inertia,

826
00:40:25,076 --> 00:40:26,717
they have the same eigenvectors.

827
00:40:26,737 --> 00:40:27,717
They diagonalize the same.

828
00:40:27,777 --> 00:40:28,638
So it's all good.

829
00:40:29,248 --> 00:40:30,449
So anyway, enough of that.

830
00:40:31,570 --> 00:40:32,751
We've got our inertia matrix.

831
00:40:32,791 --> 00:40:36,274
So how do we use this?

832
00:40:36,975 --> 00:40:40,278
And what the inertia is, it defines a relationship

833
00:40:40,438 --> 00:40:43,321
between angular momentum and angular spin.

834
00:40:44,322 --> 00:40:48,425
But spin also depends on the current orientation.

835
00:40:49,086 --> 00:40:51,188
So here we've got some spinning on some.

836
00:40:52,103 --> 00:40:55,365
spinning objects. They all have, they're all the same object, they have the same

837
00:40:55,485 --> 00:40:59,068
angular momentum, but the spin is very different because they started at

838
00:40:59,088 --> 00:41:01,790
different orientations. So you can see some things are going to be spinning a

839
00:41:01,810 --> 00:41:04,793
little faster because they're going around, you know, sort of the long axis

840
00:41:04,833 --> 00:41:08,916
versus the short axis, right? Even though they have the same momentum. So as we knock

841
00:41:08,936 --> 00:41:12,679
these things around, you know, we sort of get the behavior, the way things process

842
00:41:12,719 --> 00:41:15,141
and all that stuff. Now there's no gravity but...

843
00:41:15,842 --> 00:41:17,603
You know, hopefully that, yeah, as we hit things,

844
00:41:17,683 --> 00:41:19,384
it takes less energy to get them sort of spin,

845
00:41:19,804 --> 00:41:22,465
sort of the short way versus the long way and stuff.

846
00:41:22,825 --> 00:41:24,726
Here I've added gravity back in, but apparently not

847
00:41:24,746 --> 00:41:25,467
a whole lot of gravity.

848
00:41:25,507 --> 00:41:27,708
So this looks like kind of in slow motion,

849
00:41:27,808 --> 00:41:29,629
like you've got a GoPro camera and you're

850
00:41:29,649 --> 00:41:31,310
like filming your skateboarding tricks or something.

851
00:41:33,011 --> 00:41:34,712
But hopefully the behavior looks, yeah,

852
00:41:34,752 --> 00:41:35,832
this is kind of what you'd expect.

853
00:41:35,852 --> 00:41:37,833
You know, you could do kick flips in an environment like this.

854
00:41:38,994 --> 00:41:39,174
There.

855
00:41:39,954 --> 00:41:40,635
Landed it perfect.

856
00:41:41,223 --> 00:41:44,486
OK, oh yeah, and the equation is sort of shown on the right there.

857
00:41:44,886 --> 00:41:47,749
And you probably notice also that the spin vector sort of changes.

858
00:41:48,029 --> 00:41:50,711
It's the momentum that stays constant, but the spin actually

859
00:41:50,771 --> 00:41:51,892
changes from frame to frame.

860
00:41:53,193 --> 00:41:57,537
So what we looked at so far was the volume integration,

861
00:41:57,577 --> 00:41:59,679
or calculating these properties of our objects.

862
00:41:59,759 --> 00:42:02,661
So now, that's sort of the work half.

863
00:42:02,701 --> 00:42:06,324
And now let's study the other half, the fun half, a little bit more.

864
00:42:06,364 --> 00:42:08,046
And that's this time integration.

865
00:42:08,723 --> 00:42:11,465
OK, so volume integration and then now time integration.

866
00:42:12,046 --> 00:42:14,588
Well, that's just fancy terminology for how

867
00:42:14,628 --> 00:42:16,951
you update some objects from its current state

868
00:42:17,111 --> 00:42:19,453
to where it is at the next time step.

869
00:42:19,973 --> 00:42:23,837
So for position, you've got some guy positioned pt at time t.

870
00:42:24,358 --> 00:42:27,060
His position at pt plus delta t is simply

871
00:42:27,220 --> 00:42:29,923
at his velocity times the time step,

872
00:42:29,983 --> 00:42:31,044
and you've got the new position.

873
00:42:31,825 --> 00:42:32,365
So OK.

874
00:42:32,989 --> 00:42:35,236
This morning you took a class about quaternions.

875
00:42:35,256 --> 00:42:37,042
You're thinking, hey, I've got a spin vector.

876
00:42:37,082 --> 00:42:38,727
I know how to create a quaternion from that.

877
00:42:39,540 --> 00:42:43,943
that, you know, based on the spin. And so I can multiply that quaternion, pre-multiply that

878
00:42:44,063 --> 00:42:48,947
quaternion by my orientation to get my new orientation. And yeah, that sort of works.

879
00:42:49,768 --> 00:42:54,071
But one of the things, and we'll see why in a minute, is that we what we'd like to do is form

880
00:42:54,532 --> 00:43:02,658
these time integration equations as adding instead of multiplication. So the form on the right here

881
00:43:03,138 --> 00:43:08,563
is where I've got my next state. My next orientation is my current

882
00:43:09,339 --> 00:43:13,922
quaternion, current orientation, plus this derivative, plus a derivative, i.e. how

883
00:43:13,942 --> 00:43:17,785
that quaternion is going to change, times the time step value, like how much I'm

884
00:43:17,805 --> 00:43:23,789
going to change, or how much time has elapsed. Okay, so it gets a little trickier.

885
00:43:24,229 --> 00:43:28,112
Another important thing is that, remember that spin vector we saw that was sort of

886
00:43:28,212 --> 00:43:28,613
changing?

887
00:43:30,376 --> 00:43:32,820
The thing is, when I'm doing this orientation update,

888
00:43:33,161 --> 00:43:37,968
and this is the problem, that it's only valid at the beginning of the time step.

889
00:43:38,088 --> 00:43:41,253
So I can't really apply that same spin for the entire time step.

890
00:43:44,417 --> 00:43:46,099
You get this thing called numerical drift.

891
00:43:46,199 --> 00:43:50,902
And it's best explained by the classic example of you're

892
00:43:50,922 --> 00:43:52,063
following the path of a circle.

893
00:43:52,463 --> 00:43:54,365
So say I'm following the path of a circle.

894
00:43:54,865 --> 00:43:56,867
What I would do is I would look down, what's the tangent?

895
00:43:57,347 --> 00:43:57,848
Take a step.

896
00:43:58,388 --> 00:44:00,429
Look down, what's the tangent or the derivative?

897
00:44:00,850 --> 00:44:01,951
Take another step, and so on.

898
00:44:02,631 --> 00:44:05,752
But if I'm taking big steps, as shown in the little picture

899
00:44:05,772 --> 00:44:09,073
there in the upper right, I'm going to be slightly getting

900
00:44:09,173 --> 00:44:11,153
further away from the origin or falling out of orbit.

901
00:44:12,294 --> 00:44:16,035
And that's what happens with the typical what's

902
00:44:16,055 --> 00:44:17,715
known as a forward Euler update.

903
00:44:18,095 --> 00:44:20,256
You take that derivative from the current time step

904
00:44:20,316 --> 00:44:22,837
and you apply delta t time to that.

905
00:44:23,717 --> 00:44:25,598
So now instead, let's say I'm going

906
00:44:25,618 --> 00:44:28,578
to use a different approach to follow the path of a circle

907
00:44:29,579 --> 00:44:30,799
using this Runge-Kutta technique.

908
00:44:32,252 --> 00:44:35,877
What you do is, you look down at the circle, you say, what's the tangent?

909
00:44:35,977 --> 00:44:36,257
OK.

910
00:44:36,617 --> 00:44:39,841
Then instead of taking a full step along that tangent,

911
00:44:39,882 --> 00:44:43,526
you sort of look half a step forward in that direction, look down,

912
00:44:44,467 --> 00:44:46,830
what's the tangent at that point, or the derivative at that point?

913
00:44:47,311 --> 00:44:47,571
OK.

914
00:44:47,831 --> 00:44:48,753
Now you've got a new derivative.

915
00:44:49,253 --> 00:44:49,694
Lean back.

916
00:44:50,577 --> 00:44:52,998
Take a half step along that direction.

917
00:44:53,478 --> 00:44:53,998
Look down.

918
00:44:54,538 --> 00:44:56,319
What's the tangent or derivative here?

919
00:44:56,959 --> 00:44:57,299
OK.

920
00:44:57,819 --> 00:44:58,520
Got an instant value.

921
00:44:58,680 --> 00:44:59,160
Lean back.

922
00:44:59,700 --> 00:45:02,241
Now reach, lean sort of forward a full step

923
00:45:02,921 --> 00:45:04,241
with that latest tangent vector.

924
00:45:04,722 --> 00:45:05,202
Look down.

925
00:45:05,482 --> 00:45:07,382
OK, what's the derivative or tangent out here?

926
00:45:08,303 --> 00:45:10,924
And then, instead of using that last one,

927
00:45:10,964 --> 00:45:12,624
you take actually this weighted average

928
00:45:12,744 --> 00:45:14,605
of all four of those derivatives, or all four

929
00:45:14,625 --> 00:45:16,345
of those tangents, and you.

930
00:45:17,405 --> 00:45:19,307
And that's how you advance yourself.

931
00:45:19,647 --> 00:45:22,169
And this works great for people who like to walk around in circles.

932
00:45:22,629 --> 00:45:25,651
And it's a perfect way to update our orientation in our games.

933
00:45:26,371 --> 00:45:32,155
So first, I'm going to show objects with a very high angular momentum.

934
00:45:32,576 --> 00:45:34,757
And I'm going to turn on that forward Euler update.

935
00:45:35,318 --> 00:45:37,619
And look what happens.

936
00:45:38,200 --> 00:45:39,620
My object gained a whole bunch of energy.

937
00:45:40,141 --> 00:45:42,943
And the spin sort of converged to one of the principal axes of the object.

938
00:45:44,686 --> 00:45:46,086
Here I'm doing that Runge-Kutta update,

939
00:45:46,727 --> 00:45:47,807
and it's not gaining energy.

940
00:45:47,927 --> 00:45:48,807
This just kind of works.

941
00:45:49,367 --> 00:45:51,408
It's sort of spinning, getting that nice behavior,

942
00:45:51,728 --> 00:45:52,328
as we'd expect.

943
00:45:52,528 --> 00:45:55,309
And the spin sort of orbits around the momentum,

944
00:45:55,429 --> 00:45:57,870
which is what this shape of object is going to give us.

945
00:45:59,670 --> 00:46:03,512
All right, so we've looked so far sort of at rigid body

946
00:46:03,592 --> 00:46:05,352
objects and how they kind of work.

947
00:46:05,812 --> 00:46:07,913
Now we're going to explore the soft stuff a little bit.

948
00:46:10,048 --> 00:46:13,677
So instead of an object with a position and an orientation,

949
00:46:14,038 --> 00:46:17,286
don't worry about orientation, but every vertex on the object

950
00:46:17,346 --> 00:46:18,549
has its own position.

951
00:46:19,331 --> 00:46:19,452
Now.

952
00:46:20,967 --> 00:46:27,208
But all these vertices are going to be connected with some sort of constraint or spring.

953
00:46:27,608 --> 00:46:32,229
Okay, so when we build these sorts of things, there will be a visual mesh for objects,

954
00:46:32,369 --> 00:46:37,111
but the way we connect them with these springs or constraints might actually differ from that.

955
00:46:37,951 --> 00:46:43,352
Cloth is a classic example, so let's take a look at how we build a cloth mesh for simulation.

956
00:46:44,762 --> 00:46:50,490
You've got a whole bunch of vertices or points, and you're going to create these strong connections

957
00:46:50,550 --> 00:46:53,834
with their immediate neighbors, because cloth doesn't really stretch or compress all that

958
00:46:53,874 --> 00:46:55,637
much along that dimension.

959
00:46:56,298 --> 00:46:57,740
And then, okay, there's going to be some sort of...

960
00:46:59,122 --> 00:47:00,843
I'll do an example here if this works.

961
00:47:01,984 --> 00:47:04,667
It might shear a little bit like this, but there's

962
00:47:04,687 --> 00:47:05,748
be some resistance to it.

963
00:47:05,808 --> 00:47:09,471
So for every vertex along the diagonals,

964
00:47:09,491 --> 00:47:12,734
you're going to create some sort of connection with maybe a slightly less

965
00:47:12,794 --> 00:47:14,516
stiff connection between them.

966
00:47:15,337 --> 00:47:18,680
And to resist bending, something bending over like this,

967
00:47:19,601 --> 00:47:22,403
you have connections between every vertex and two over.

968
00:47:23,629 --> 00:47:24,389
in each direction.

969
00:47:25,570 --> 00:47:29,153
And you'd have stiffer connections for something like leather,

970
00:47:29,173 --> 00:47:30,234
or for something like silk.

971
00:47:30,594 --> 00:47:32,276
They'd be very weak or non-existent.

972
00:47:33,777 --> 00:47:35,138
And it's not just cloth.

973
00:47:35,178 --> 00:47:37,880
I mean, you can build rubber ducks or things out

974
00:47:37,900 --> 00:47:40,382
of 3D lattices of all sorts of connections.

975
00:47:41,883 --> 00:47:44,986
So for implementing these, it really comes down to the time integration.

976
00:47:45,006 --> 00:47:46,947
How do you simulate these soft objects?

977
00:47:47,328 --> 00:47:48,389
And there's two schools of thought.

978
00:47:48,409 --> 00:47:51,291
There's the kinematic approach and the dynamic approach.

979
00:47:52,193 --> 00:47:54,895
Now, the kinematic approach is to think of any time

980
00:47:54,915 --> 00:47:57,877
I have a connection between two vertices, that's a constraint.

981
00:47:58,437 --> 00:48:02,440
Those two things belong at this distance apart from each other.

982
00:48:03,320 --> 00:48:05,241
And so for the implementation, every frame,

983
00:48:05,642 --> 00:48:07,423
you'll see if two points, oh, if they're further away

984
00:48:07,463 --> 00:48:09,324
than they need to be, then you sort of nudge them closer.

985
00:48:09,364 --> 00:48:10,384
Maybe not move them all the way.

986
00:48:10,424 --> 00:48:11,765
Maybe you nudge them a little bit closer.

987
00:48:11,845 --> 00:48:13,466
Maybe do a few passes or something like that.

988
00:48:14,287 --> 00:48:16,290
Or if they're too close, then you just kind of nudge them apart.

989
00:48:16,730 --> 00:48:17,831
So it's very easy to implement.

990
00:48:17,872 --> 00:48:20,595
Just your basic vector arithmetic that I'm sure everyone's familiar with.

991
00:48:21,016 --> 00:48:22,778
Oh, plus you also have to know how to take a square root.

992
00:48:22,918 --> 00:48:23,779
Assuming you can do that too.

993
00:48:24,059 --> 00:48:24,961
Then you can implement this.

994
00:48:25,221 --> 00:48:32,070
And you can find many reference implementations and papers

995
00:48:32,130 --> 00:48:32,570
on how to do it.

996
00:48:33,211 --> 00:48:35,232
A nice thing is that these systems, they don't explode,

997
00:48:35,272 --> 00:48:37,693
because you're always pushing stuff closer to where it's supposed to be.

998
00:48:37,713 --> 00:48:40,254
You're not going to get any weird behavior where things all of a sudden

999
00:48:40,854 --> 00:48:42,195
vaporize and go off in space.

1000
00:48:43,015 --> 00:48:44,996
And not surprisingly, it's the most common system

1001
00:48:45,056 --> 00:48:47,117
used out there in games and physics engines.

1002
00:48:47,957 --> 00:48:51,999
The only caveat is that because of the way you're sort of implementing,

1003
00:48:52,019 --> 00:48:54,780
if you have things that are under sort of a true stress, either compression

1004
00:48:54,821 --> 00:48:58,822
or a stretch, are they guaranteed to converge

1005
00:48:58,902 --> 00:49:00,843
to some sort of force correct state?

1006
00:49:01,964 --> 00:49:04,306
I'm sure there's implementations where people have figured out how to do that,

1007
00:49:04,746 --> 00:49:08,669
but the alternative is to use a dynamic approach to solving cloth.

1008
00:49:09,450 --> 00:49:12,352
And this is, you know, more of the pure physics approach,

1009
00:49:12,853 --> 00:49:16,415
and it's to think, whenever I have two vertices that are connected,

1010
00:49:16,435 --> 00:49:18,577
they're connected with a spring that applies force.

1011
00:49:19,178 --> 00:49:23,801
Okay. So, if I've got springs that are fairly weak in force, it's easy to implement.

1012
00:49:23,821 --> 00:49:26,824
You just sort of, you know, add a little velocity to each of those endpoints,

1013
00:49:26,904 --> 00:49:27,785
and it moves, and so on.

1014
00:49:28,185 --> 00:49:30,547
But if I have, let's say, a very, very stiff spring,

1015
00:49:31,347 --> 00:49:35,049
And let's say, because a character in a game kind of moves to an end point or something,

1016
00:49:35,089 --> 00:49:38,010
now I have this string that's stretched out.

1017
00:49:39,011 --> 00:49:41,372
And if it's a very high force and I want to simulate that,

1018
00:49:41,552 --> 00:49:46,114
even if it's only 1 60th of a second, I can like, you know, bang to pull it back together.

1019
00:49:46,154 --> 00:49:48,355
But it'll overshoot because the forces are so high.

1020
00:49:48,375 --> 00:49:50,136
And then it's like, oh, now it's even more out of whack.

1021
00:49:50,176 --> 00:49:50,716
And then it shoots.

1022
00:49:51,136 --> 00:49:51,836
And then boom, boom.

1023
00:49:51,897 --> 00:49:53,157
And these things just explode, right?

1024
00:49:53,976 --> 00:49:59,883
So even if you try to run Kata integration, well, you're sort of looking at half steps,

1025
00:49:59,923 --> 00:50:03,928
but I mean half of a huge number is still a pretty huge number, so that doesn't work.

1026
00:50:04,328 --> 00:50:09,314
The only way to actually integrate these properly is with implicit integration or backward Euler.

1027
00:50:11,117 --> 00:50:13,099
And we're going to take a look at that.

1028
00:50:13,551 --> 00:50:16,274
But first let's compare with the kinematic approach.

1029
00:50:16,655 --> 00:50:17,656
Now it's easy to implement.

1030
00:50:17,696 --> 00:50:20,098
You can have like this is actually running on a single core, lots of cloth.

1031
00:50:20,138 --> 00:50:20,659
It's easy to do.

1032
00:50:21,200 --> 00:50:22,681
Now excuse my shading.

1033
00:50:22,741 --> 00:50:23,762
It might look a little plasticky.

1034
00:50:23,802 --> 00:50:25,464
But you know, hopefully you think and look at this thing.

1035
00:50:25,504 --> 00:50:26,526
Yeah, that behavior works.

1036
00:50:26,866 --> 00:50:27,827
You know, fairly responsive.

1037
00:50:27,867 --> 00:50:28,768
I could use this in a game.

1038
00:50:29,329 --> 00:50:29,389
And

1039
00:50:29,869 --> 00:50:31,110
Yeah, it kind of does the job.

1040
00:50:31,451 --> 00:50:33,412
And chances are, this probably is good enough for most people.

1041
00:50:34,573 --> 00:50:35,754
The only caveat, as I mentioned, is

1042
00:50:35,794 --> 00:50:36,915
I'm sort of pulling on things.

1043
00:50:36,935 --> 00:50:38,537
I have all these constraints that are sort of fighting

1044
00:50:38,577 --> 00:50:39,157
against each other.

1045
00:50:39,678 --> 00:50:41,059
And the way these things are connected,

1046
00:50:41,099 --> 00:50:42,761
you can kind of get this continued oscillation.

1047
00:50:42,801 --> 00:50:45,003
Because you're not sort of, it's not

1048
00:50:45,023 --> 00:50:47,124
getting this relaxed, forced, converged state.

1049
00:50:47,184 --> 00:50:48,386
It's no, no, you're constantly fighting.

1050
00:50:48,626 --> 00:50:52,329
So that's the only case where these things may break down.

1051
00:50:53,523 --> 00:50:54,664
It might depend on the implementation, too.

1052
00:50:57,208 --> 00:51:00,392
But we're going to now take a look at the implicit integration approach,

1053
00:51:00,432 --> 00:51:01,574
because it's kind of interesting.

1054
00:51:01,614 --> 00:51:02,535
You might actually learn something.

1055
00:51:04,576 --> 00:51:07,919
And like I said, it's based on forces and springs.

1056
00:51:08,720 --> 00:51:10,982
And the forward Euler approach is as follows.

1057
00:51:11,743 --> 00:51:15,686
You have, for every point in your cloth or soft object,

1058
00:51:16,467 --> 00:51:19,629
it's got a velocity and then all these springs connected to it,

1059
00:51:19,929 --> 00:51:22,131
and gravity and wind or whatever else.

1060
00:51:22,672 --> 00:51:24,433
So at each point, there's a net force

1061
00:51:24,693 --> 00:51:26,475
being applied to a point or a vertex.

1062
00:51:27,356 --> 00:51:29,618
So the forward Euler update would be to, OK.

1063
00:51:30,468 --> 00:51:34,692
Divide that net force by your mass, which is your acceleration.

1064
00:51:34,732 --> 00:51:37,114
Apply that, and you've got your velocity for the next time step.

1065
00:51:37,735 --> 00:51:39,476
We've already described why that's going to break down,

1066
00:51:39,536 --> 00:51:40,617
because things might explode.

1067
00:51:41,198 --> 00:51:44,761
So the implicit approach, what you do is,

1068
00:51:44,921 --> 00:51:48,024
instead of applying the forces at a point based

1069
00:51:48,124 --> 00:51:51,567
on the forces at the start of the time step,

1070
00:51:51,907 --> 00:51:54,650
you use the forces from the end of the time step.

1071
00:51:55,494 --> 00:51:58,195
But wait a second, those are forces from the future.

1072
00:51:58,275 --> 00:51:59,835
We're not there yet.

1073
00:51:59,875 --> 00:52:01,136
We don't know what they are, because we

1074
00:52:01,156 --> 00:52:02,336
don't know where everything's going to be.

1075
00:52:02,396 --> 00:52:03,357
I mean, how can we even do that?

1076
00:52:04,397 --> 00:52:06,378
And so that's why, for this approach,

1077
00:52:06,498 --> 00:52:08,538
you end up creating one of these linear systems

1078
00:52:08,598 --> 00:52:10,439
and solving for those forces.

1079
00:52:11,219 --> 00:52:13,180
And in order to do that, you need to know

1080
00:52:13,240 --> 00:52:15,280
the derivatives of the forces.

1081
00:52:15,461 --> 00:52:18,241
That is, how the force at a point

1082
00:52:18,321 --> 00:52:21,282
will change based on a change in position

1083
00:52:21,342 --> 00:52:22,423
and a change in velocity.

1084
00:52:24,203 --> 00:52:24,323
So.

1085
00:52:25,541 --> 00:52:31,749
Now, the thing is with force in springs in a 3D world, it is a 3D vector.

1086
00:52:32,209 --> 00:52:34,392
And I can move something.

1087
00:52:34,432 --> 00:52:37,135
As I move a spring, I can move that point in 3D.

1088
00:52:37,816 --> 00:52:42,382
So the derivative is now this 3 by 3 matrix known as a Jacobian.

1089
00:52:42,562 --> 00:52:44,164
And the general form is shown in the upper right.

1090
00:52:44,852 --> 00:52:48,233
So that's what we would have to derive to implement these systems.

1091
00:52:48,973 --> 00:52:52,874
Now, we don't have a whole lot of time left to go deep, deep into calculus.

1092
00:52:52,974 --> 00:52:53,914
But fortunately, we don't have to.

1093
00:52:53,954 --> 00:52:56,115
Let's try some geometric intuition instead.

1094
00:52:57,235 --> 00:53:00,316
When I have a spring, it's a simple, kind of a linear thing.

1095
00:53:00,336 --> 00:53:02,537
So let's first look at how does the force

1096
00:53:02,617 --> 00:53:05,537
change, this derivative of force, along the spring direction.

1097
00:53:06,177 --> 00:53:08,618
Well, if I have a spring, and let's say one point's at the origin

1098
00:53:08,658 --> 00:53:11,579
and the other point's at point P, or you can think of it as vector P

1099
00:53:11,599 --> 00:53:12,899
because one side's the origin.

1100
00:53:13,509 --> 00:53:17,672
If it's compressed, then there's a force at the end kind of facing out,

1101
00:53:17,832 --> 00:53:18,592
away from the spring.

1102
00:53:19,593 --> 00:53:23,555
As I move that out and I stretch it, now there's a force coming towards me.

1103
00:53:24,195 --> 00:53:26,517
So the change in force for a change in position

1104
00:53:26,577 --> 00:53:28,598
is simply minus k, that spring constant.

1105
00:53:30,419 --> 00:53:34,581
Not surprisingly, if the force is minus k times p,

1106
00:53:34,641 --> 00:53:37,883
well, the derivative with respect to p is just minus k, standard calculus.

1107
00:53:39,104 --> 00:53:40,525
Well, that's only half the equation.

1108
00:53:41,327 --> 00:53:44,372
Now, consider if I move that end point sort of up or down.

1109
00:53:44,993 --> 00:53:48,780
If my spring is at its rest length, and I grab this other point,

1110
00:53:48,860 --> 00:53:51,324
and I have to move it up or down, there's no force,

1111
00:53:51,344 --> 00:53:54,790
and there's no change in force for a small change up or down.

1112
00:53:55,897 --> 00:53:57,058
But the story changes.

1113
00:53:57,139 --> 00:54:01,383
If my spring is now stretched out, and I'm holding it up here,

1114
00:54:01,783 --> 00:54:04,206
there's a force coming down towards me from that end point.

1115
00:54:04,686 --> 00:54:07,569
I move my arm down, and now there's a force coming up towards me.

1116
00:54:08,070 --> 00:54:11,373
So there's a change in force from this to this, right?

1117
00:54:11,393 --> 00:54:12,154
So the change is up.

1118
00:54:12,534 --> 00:54:14,757
But if it was compressed, now I've got this force.

1119
00:54:15,577 --> 00:54:19,137
pointing up, and as I lower the endpoint, now I've got a force pointing down.

1120
00:54:19,858 --> 00:54:23,439
So my change in force for a change in position,

1121
00:54:23,759 --> 00:54:27,760
you know, anything orthogonal to the spring direction, now depends on where we

1122
00:54:27,820 --> 00:54:30,921
are relative to the rest length, r, which is shown in the bottom right there.

1123
00:54:31,801 --> 00:54:35,102
So for somebody, if they actually went off and they solved all that calculus

1124
00:54:35,162 --> 00:54:38,122
and came back, they would have come back with this, right?

1125
00:54:38,262 --> 00:54:39,543
That's what the calculus would have given you.

1126
00:54:40,210 --> 00:54:46,174
But hopefully, you know, if you follow the geometric intuition and remember what I talked about at the very beginning with those outer products,

1127
00:54:46,495 --> 00:54:51,759
this should look obvious, because it's simply minus k times that first thing in the brackets there,

1128
00:54:51,819 --> 00:54:56,202
that's, you know, p outer product p divided by p, which is essentially a unit length vector along that direction,

1129
00:54:57,003 --> 00:55:01,526
outer product with itself, okay? And that describes this motion, and then the perpendicular motion,

1130
00:55:01,866 --> 00:55:04,568
simply i minus that for the other term, right?

1131
00:55:05,246 --> 00:55:07,811
So cool, now you understand what a Jacobian is.

1132
00:55:09,254 --> 00:55:11,659
The spring equation is probably the easiest difference equation,

1133
00:55:11,679 --> 00:55:14,545
so this is probably the easiest example for trying to learn what a Jacobian is

1134
00:55:14,565 --> 00:55:15,106
that you can think of.

1135
00:55:16,580 --> 00:55:19,621
Now you do the same thing to get change in force for change in velocity,

1136
00:55:19,641 --> 00:55:22,563
because that's the other, you know, some more derivatives you need.

1137
00:55:23,103 --> 00:55:25,964
And then you have all these things, and you can put them in the linear system.

1138
00:55:26,284 --> 00:55:29,126
Now, I don't have time to go into all the algebra and all the details of it,

1139
00:55:29,486 --> 00:55:32,047
but essentially it's one of those things where you've got one of those big matrices,

1140
00:55:32,327 --> 00:55:35,488
you know, AX equals B, but X, the unknown, is now delta V,

1141
00:55:36,149 --> 00:55:39,870
and A, this matrix, is sort of identity minus that term and so on,

1142
00:55:39,910 --> 00:55:40,851
and B's the other vector.

1143
00:55:41,371 --> 00:55:45,913
And it's a little more tricky because, okay, you know, it's not just, you know, one 3D vector,

1144
00:55:45,953 --> 00:55:51,375
but you, you know, your velocity state and your position state are basically this concatenation

1145
00:55:51,415 --> 00:55:57,618
of all the points in your spring mesh. And this, so this A matrix becomes this big sparse linear

1146
00:55:57,638 --> 00:56:02,240
system and stuff. All that stuff's, you know, there's sources I can point to later that describe

1147
00:56:02,280 --> 00:56:05,081
it all, but I just kind of want to get some of this geometric intuition so you can kind of see

1148
00:56:05,101 --> 00:56:05,701
how these things work.

1149
00:56:06,657 --> 00:56:09,360
OK, so I'm going to illustrate what that can look like at runtime.

1150
00:56:09,420 --> 00:56:12,942
First, we'll see what the weak springs look like with that forward Euler

1151
00:56:13,043 --> 00:56:13,363
update.

1152
00:56:13,723 --> 00:56:16,305
And you see, oh, OK, this is kind of jello-y type behavior.

1153
00:56:16,365 --> 00:56:18,907
Maybe you could do some ocean waves with this, but it's not real cloth.

1154
00:56:19,348 --> 00:56:22,410
If you want something to touch and feel like real cloth stuff,

1155
00:56:22,751 --> 00:56:25,553
you've got to use those stiffer springs if you're

1156
00:56:25,573 --> 00:56:26,914
using the spring-based approach.

1157
00:56:27,474 --> 00:56:30,477
So here, there's the underlying spring network that you would have.

1158
00:56:30,577 --> 00:56:33,559
And yeah, OK, I mean, you already saw this kind of stuff

1159
00:56:33,579 --> 00:56:34,420
with the kinetic approach.

1160
00:56:36,172 --> 00:56:39,112
or, sorry, kinematic approach, what's

1161
00:56:39,132 --> 00:56:42,053
the advantage of the implicit integration?

1162
00:56:42,413 --> 00:56:43,013
Well, here it is.

1163
00:56:43,033 --> 00:56:45,314
It's when you have these things under stress.

1164
00:56:45,334 --> 00:56:47,894
There's no jitter, no billowing, no energy leaking the system.

1165
00:56:48,254 --> 00:56:49,795
In fact, when you pull back a slingshot,

1166
00:56:49,815 --> 00:56:52,275
because you're actually calculating the forces

1167
00:56:52,535 --> 00:56:53,075
on all these things.

1168
00:56:53,095 --> 00:56:54,536
So if you put a projectile there,

1169
00:56:55,056 --> 00:56:56,676
you would know how much force to apply to it

1170
00:56:56,776 --> 00:56:57,536
so you could launch it.

1171
00:56:57,777 --> 00:56:59,017
It's all sort of force correct.

1172
00:56:59,437 --> 00:57:01,557
And here's examples of sort of like 3D objects

1173
00:57:01,597 --> 00:57:03,098
kind of connected with a bunch of stiff springs.

1174
00:57:04,598 --> 00:57:04,918
All right.

1175
00:57:06,519 --> 00:57:11,205
Okay, now that was kind of a big whirlwind of topics and you know we started off

1176
00:57:11,265 --> 00:57:14,029
looking at some basic stuff, you know how four planes come together to meet, you

1177
00:57:14,049 --> 00:57:20,737
know, building that roof or so on. Now and we looked at sort of solids and motion

1178
00:57:20,857 --> 00:57:21,898
and all those kind of things.

1179
00:57:23,080 --> 00:57:28,921
The main objective here was to try to get people to, first of all, to think of their meshes as not just a bag of triangles.

1180
00:57:29,021 --> 00:57:37,963
But once you start thinking of a mesh as a solid, you know, and you can have this tetrahedral decomposition or breaking stuff into convex meshes for collision detection,

1181
00:57:37,983 --> 00:57:41,444
you know, you have this more intuitive, powerful understanding of your geometry.

1182
00:57:42,424 --> 00:57:46,705
And furthermore, then we sort of looked at, you know, things in motion.

1183
00:57:50,202 --> 00:57:53,364
A lot of people with graphics, you get this fairly good understanding of,

1184
00:57:53,484 --> 00:57:54,825
you know, you're basically in algebra.

1185
00:57:55,145 --> 00:57:58,146
But when you start exploring some of the physics space and geometry space,

1186
00:57:58,807 --> 00:58:01,128
you step a little bit beyond some of that math

1187
00:58:01,168 --> 00:58:05,230
and learning the value of things like outer product and Jacobians

1188
00:58:05,270 --> 00:58:06,070
and all that sort of thing.

1189
00:58:06,630 --> 00:58:10,092
And that can open the door to new and interesting fun things

1190
00:58:10,112 --> 00:58:11,533
you can do in your game experiences.

1191
00:58:13,174 --> 00:58:13,294
So.

1192
00:58:14,395 --> 00:58:17,496
Now, admittedly, that was probably quite a lot for some people to digest.

1193
00:58:18,336 --> 00:58:20,577
And you might have questions, and you might not think of them right away.

1194
00:58:20,597 --> 00:58:22,457
You might think of them like an hour after you leave here.

1195
00:58:22,897 --> 00:58:25,278
I'll be around all week, so feel free to flag me down.

1196
00:58:25,298 --> 00:58:26,558
Just look for the bodybuilder in the crowd.

1197
00:58:26,578 --> 00:58:29,619
That's me, and we can have coffee, and I'll explain things further.

1198
00:58:30,540 --> 00:58:33,160
In the meantime, if there's any questions that someone has right now,

1199
00:58:33,220 --> 00:58:35,461
I think we might have a few minutes left to answer.

1200
00:58:35,721 --> 00:58:36,781
Yeah, got a couple minutes.

1201
00:58:38,342 --> 00:58:39,122
Someone has a burning question.

1202
00:58:41,452 --> 00:58:43,732
I had a non-math related question, which is just,

1203
00:58:43,952 --> 00:58:47,513
what kind of input were you using for those hand gesture demos?

1204
00:58:49,274 --> 00:58:51,634
Oh, it's like a depth camera based thing.

1205
00:58:51,714 --> 00:58:51,934
So.

1206
00:58:51,994 --> 00:58:54,095
But like, is it a connector?

1207
00:58:55,215 --> 00:58:59,756
Well, in this case, I was actually using a time of flight camera.

1208
00:59:00,937 --> 00:59:05,138
So what I do, now just, I just got my paper published.

1209
00:59:06,398 --> 00:59:10,859
And a co-worker demoed this at i3d last week, a demo poster session.

1210
00:59:11,866 --> 00:59:14,987
We take the depth, you know, we have a sort of a model of the hand

1211
00:59:16,187 --> 00:59:20,328
And then we take the depth data and we want to fit that model to the depth data

1212
00:59:20,428 --> 00:59:22,188
I mean, there's a lot of people been trying to solve this problem

1213
00:59:22,689 --> 00:59:27,010
I'm sort of like a math 3d physics guy and I like, you know, I was tasked with like

1214
00:59:28,390 --> 00:59:31,951
You know assume that I already have this and then build cool experiences and interactions

1215
00:59:31,971 --> 00:59:35,732
I'm like but but I need software to track the hand so I had to like build it because nobody had it

1216
00:59:36,403 --> 00:59:42,606
So yeah, I took the depth data, and then I basically got like a rigid body model of the hand and all constructed.

1217
00:59:43,247 --> 00:59:44,327
And I've got, you know, the...

1218
00:59:44,867 --> 00:59:46,728
Oh, okay, I'll... sorry, I'll try to be quick.

1219
00:59:47,008 --> 00:59:49,130
The, you know, the, you know, the constraints...

1220
00:59:49,150 --> 00:59:51,091
You'll learn about this more if you go to the physics class, you know,

1221
00:59:51,111 --> 00:59:53,792
because it's really just an extension of like a physics engine.

1222
00:59:54,573 --> 00:59:58,117
You know, you have all these connections, you know, that are constraints on the joints.

1223
00:59:58,417 --> 00:59:59,418
You have collision constraints.

1224
00:59:59,799 --> 01:00:01,981
And then all those little depth values are like little magnets or something,

1225
01:00:02,021 --> 01:00:03,583
and you just kind of like pull on the surface.

1226
01:00:03,884 --> 01:00:05,325
You know, there's a few things you want to do.

1227
01:00:05,345 --> 01:00:07,628
You make them a little weaker because you might mismatch, you know,

1228
01:00:07,688 --> 01:00:09,050
points to where they lie on the surface.

1229
01:00:09,430 --> 01:00:11,853
And it relies a little bit on temporal coherence because, you know,

1230
01:00:11,873 --> 01:00:13,775
if you're starting from a bad frame, it's not going to work.

1231
01:00:14,215 --> 01:00:16,596
But you kind of need to do that anyway, because the depth data

1232
01:00:16,636 --> 01:00:17,856
is pretty bad, right?

1233
01:00:17,996 --> 01:00:20,477
Like for the speed and fidelity, because there

1234
01:00:20,517 --> 01:00:22,418
can be depth noise and occlusions and all that stuff.

1235
01:00:22,438 --> 01:00:24,078
So you really kind of need to take advantage

1236
01:00:24,098 --> 01:00:25,519
of typical coherence anyway in the solution.

1237
01:00:25,779 --> 01:00:26,779
But yeah, we can talk about that online.

1238
01:00:26,819 --> 01:00:27,419
I can show you.

1239
01:00:27,439 --> 01:00:29,080
I got like a camera here if you're interested.

1240
01:00:29,260 --> 01:00:29,420
Yeah.

1241
01:00:29,740 --> 01:00:32,861
But yeah, it's not really related to this talk, but sorry.

1242
01:00:33,801 --> 01:00:34,361
Any other questions?

1243
01:00:40,283 --> 01:00:40,423
Sure.

1244
01:00:42,614 --> 01:00:46,276
Hey, thanks for that.

1245
01:00:46,316 --> 01:00:51,377
Touching that last part with the spring network.

1246
01:00:52,878 --> 01:00:56,079
And when you do basically integration

1247
01:00:56,119 --> 01:01:01,501
of within that time step, do you have to?

1248
01:01:04,094 --> 01:01:09,864
take into account all the springs next to your current.

1249
01:01:10,184 --> 01:01:12,228
Basically, if you have a mass node with springs,

1250
01:01:19,343 --> 01:01:22,446
You have you have mass nodes and they are interconnected with springs

1251
01:01:22,687 --> 01:01:26,270
Yeah, so basically all the all the nodes next to your current node

1252
01:01:27,131 --> 01:01:28,853
They kind of have to affect

1253
01:01:29,894 --> 01:01:31,295
the position or

1254
01:01:32,136 --> 01:01:34,118
Or the next position of the node

1255
01:01:34,438 --> 01:01:39,924
Do you have to cache all those like the states of all those nodes that affect your current?

1256
01:01:42,182 --> 01:01:46,824
Yeah, do I understand? I'm having problems expressing myself.

1257
01:01:47,064 --> 01:01:52,466
Yeah, so when you're solving any sort of these systems, like even a general rigid body system,

1258
01:01:52,626 --> 01:01:55,447
you have to solve a lot of these equations simultaneously.

1259
01:01:56,108 --> 01:02:01,070
And then with the implicit integration, it's even worse because you're sort of solving kind of future,

1260
01:02:01,250 --> 01:02:04,731
like velocity and position kind of simultaneously as well.

1261
01:02:04,751 --> 01:02:07,713
So it does get very tricky because everything connects with everything else,

1262
01:02:07,773 --> 01:02:09,413
and they have to solve them all together.

1263
01:02:10,054 --> 01:02:10,914
So you end up...

1264
01:02:11,652 --> 01:02:14,955
And you know you end up sort of adding all these little Jacobians

1265
01:02:15,835 --> 01:02:20,279
You know in that system and then sort of solving into sort of an answer that will

1266
01:02:21,300 --> 01:02:24,943
You know, you know energy minimizing type of type of thing. Yeah

1267
01:02:25,292 --> 01:02:29,415
But in the middle, you will then have quite a lot of data, basically,

1268
01:02:30,315 --> 01:02:35,579
more data than you begin with to kind of hold all those.

1269
01:02:35,919 --> 01:02:37,120
It's going to be order of the size.

1270
01:02:37,160 --> 01:02:44,124
So it's going to be the topology, like the connections of each point.

1271
01:02:44,264 --> 01:02:51,149
Every point can be connected to 12, say, neighbors.

1272
01:02:52,089 --> 01:02:54,751
And so you're going to have an

1273
01:02:55,808 --> 01:02:58,750
amount of data to process like your math equations are going to have that much

1274
01:02:58,790 --> 01:03:02,752
stuff in them. So it's going to be like, you know, you know, over 10 times the

1275
01:03:02,852 --> 01:03:07,454
number of points in your matrix or in your mesh. Right. And it's in 3d. So

1276
01:03:07,514 --> 01:03:12,196
it's I mean, these are, you know, and with position and velocity and other

1277
01:03:12,377 --> 01:03:15,078
other things going on. So yeah, there's a bigger data footprint. It's

1278
01:03:15,118 --> 01:03:17,659
certainly the kinematic approach. I mean, they have a very small data

1279
01:03:17,679 --> 01:03:18,480
footprint. It's very

1280
01:03:22,341 --> 01:03:28,003
What helps make them more efficient is that makes it cache efficient as well too because they have a much smaller data footprint.

1281
01:03:28,023 --> 01:03:31,204
You're absolutely right, there's a huge data footprint cost as well.

1282
01:03:31,244 --> 01:03:38,847
Specifically, I'm just trying to create this really flowing water surface and try to get away with as little problem.

1283
01:03:40,744 --> 01:03:44,993
Yeah, water you can start out with the forward Euler systems,

1284
01:03:45,814 --> 01:03:47,638
because you get that nice wavy behavior.

1285
01:03:47,658 --> 01:03:49,001
And that's a good place to start.

1286
01:03:49,563 --> 01:03:51,126
And then for the implicit.

1287
01:03:52,131 --> 01:03:57,396
type things, I mean, there is a damping to it that just is natural with the integration.

1288
01:03:57,916 --> 01:04:01,299
So like the cloth will sort of settle and it's, you know, sometimes you have to do things

1289
01:04:01,339 --> 01:04:04,041
to kind of create that life back into objects.

1290
01:04:04,061 --> 01:04:04,301
Of course.

1291
01:04:04,362 --> 01:04:09,746
Because it's, even without adding damping terms, it will dampen itself, which is, you

1292
01:04:09,866 --> 01:04:11,087
know, something that can happen.

1293
01:04:11,187 --> 01:04:14,991
Well, I've been using the data from the previous step.

1294
01:04:15,791 --> 01:04:19,634
to integrate, like within the integrations and I've been getting away with it.

1295
01:04:20,175 --> 01:04:26,499
For some reason it works, maybe my coefficients are low enough for it to work.

1296
01:04:27,220 --> 01:04:29,281
Yeah, the coefficients are low enough, the forward order is easy.

1297
01:04:29,301 --> 01:04:31,783
I'm probably going to get into a lot of trouble if I just ignore about this.

1298
01:04:32,223 --> 01:04:32,444
Yeah.

1299
01:04:32,864 --> 01:04:33,484
Okay, thank you.

1300
01:04:33,665 --> 01:04:34,285
Yeah, no problem.

1301
01:04:35,326 --> 01:04:35,486
Thanks.

1302
01:04:36,026 --> 01:04:36,687
Oh, sorry, one more?

1303
01:04:37,467 --> 01:04:41,030
So, a lot of this is actually really new to me, but also seemed really interesting.

1304
01:04:41,050 --> 01:04:42,591
So, if we're actually trying to like...

1305
01:04:43,337 --> 01:04:47,216
understand the concepts more in detail and really like get it down. Would you recommend

1306
01:04:47,869 --> 01:04:51,410
more just jumping in and trying to write tech demos that kind of follow this?

1307
01:04:51,470 --> 01:04:52,751
Or would you add any books?

1308
01:04:53,011 --> 01:04:53,511
Absolutely.

1309
01:04:53,731 --> 01:04:57,812
Even if you're using at work, if you're using an off-the-shelf physics

1310
01:04:57,892 --> 01:05:02,774
engine or something, it's nice to write your own code of the same thing.

1311
01:05:02,814 --> 01:05:06,235
Like, when I used to work at Agia on the PhysX SDK and stuff,

1312
01:05:06,475 --> 01:05:09,576
one of the things that helped me be of benefit to my employer

1313
01:05:09,616 --> 01:05:11,897
was the fact that I had done a lot of that kind of stuff

1314
01:05:11,957 --> 01:05:14,397
on my own in the past before, like similar things.

1315
01:05:14,798 --> 01:05:17,158
Maybe not to the same extent, because it's quite a large engine.

1316
01:05:17,984 --> 01:05:45,195
So yeah, I would encourage anybody, like, you know, try writing a GJK algorithm or a, you know, a little, you know, little solver for springs, you know, and constantly challenge yourself, because then, you know, even if it works, you're using off the shelf systems, I mean, you'll understand those systems and the and the issues involved with them, right? Like that famous force, that the mass ratio issue with rigid body, ragdolls and stuff, right? Like, what is that if you've ever kind of thinking with the equations, it's like, oh, you got it. And then you'll be the guy in the room that you know,

1317
01:05:45,735 --> 01:05:47,917
Everyone's like, ah, we can't ship our game because it's broken.

1318
01:05:48,017 --> 01:05:48,838
And you'll just know.

1319
01:05:49,518 --> 01:05:51,039
So yeah, I would totally encourage that.

1320
01:05:51,640 --> 01:05:54,102
It's the same thing as if you take a math course

1321
01:05:54,582 --> 01:05:56,724
without ever solving any of the exercises

1322
01:05:56,764 --> 01:05:57,684
at the end of each chapter.

1323
01:05:57,744 --> 01:05:59,245
You're not really going to learn the math as well.

1324
01:05:59,826 --> 01:06:02,308
So that's my personal opinion.

1325
01:06:02,348 --> 01:06:05,430
But yeah, definitely, tinkering is always worthwhile.

1326
01:06:05,510 --> 01:06:07,051
But you have to balance it out because you

1327
01:06:07,071 --> 01:06:11,074
want to get paid, and you can't spend all your time reinventing

1328
01:06:11,094 --> 01:06:11,835
the wheel and stuff.

1329
01:06:12,916 --> 01:06:16,718
I guess I was a little lucky because I'm a little bit older, so like when I was a buyer

1330
01:06:16,738 --> 01:06:20,722
in the 90s, none of this stuff existed and we just had to kind of reinvent, you know,

1331
01:06:21,102 --> 01:06:24,484
I got the opportunity to kind of implement all this stuff when it was first around.

1332
01:06:24,845 --> 01:06:28,327
So I know it's a little harder for, you know, new guys coming in the industry because all

1333
01:06:28,367 --> 01:06:32,190
the stuff's already written, no one's going to pay you to write the stuff that I got paid

1334
01:06:32,210 --> 01:06:34,052
to write, you know, 15 years ago.

1335
01:06:34,252 --> 01:06:36,734
So sorry about that, but, you know.

1336
01:06:37,995 --> 01:06:42,000
But yeah, definitely, you know, hack on the side.

1337
01:06:42,501 --> 01:06:44,924
I can't stress enough, that's a very good way to learn.

1338
01:06:44,944 --> 01:06:45,525
Thank you.

1339
01:06:45,545 --> 01:06:45,625
Yeah.

1340
01:06:45,645 --> 01:06:45,866
All right.

1341
01:06:45,886 --> 01:06:46,386
Well, is that all?

1342
01:06:46,406 --> 01:06:51,874
Thanks guys for coming.

1343
01:06:51,894 --> 01:06:52,034
Thanks.

1344
01:06:52,054 --> 01:06:52,174
Thanks.

1345
01:06:52,194 --> 01:06:52,334
Thanks.

1346
01:06:52,354 --> 01:06:52,474
Thanks.

1347
01:06:52,494 --> 01:06:52,615
Thanks.

1348
01:06:52,635 --> 01:06:52,755
Thanks.

1349
01:06:52,775 --> 01:06:52,935
Thanks.

1350
01:06:52,955 --> 01:06:53,075
Thanks.

1351
01:06:53,316 --> 01:06:53,456
Thanks.

1352
01:06:53,476 --> 01:06:53,616
Thanks.

1353
01:06:53,656 --> 01:06:53,796
Thanks.

1354
01:06:53,816 --> 01:06:53,936
Thanks.

1355
01:06:53,956 --> 01:06:54,097
Thanks.

1356
01:06:54,117 --> 01:06:54,237
Thanks.

1357
01:06:54,257 --> 01:06:54,377
Thanks.

1358
01:06:54,397 --> 01:06:54,517
Thanks.

