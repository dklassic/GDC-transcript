1
00:00:07,636 --> 00:00:14,279
Hello everyone, this is Arvi Teekari and I'll be talking to you about the game Baba is You

2
00:00:14,279 --> 00:00:19,221
and specifically the rule system and the rule parsing system of Baba is You.

3
00:00:19,221 --> 00:00:25,424
This is the kind of a virtual talk as part of the GDC talks.

4
00:00:25,424 --> 00:00:31,707
If you hear some kind of white noise on the background in some situations, I'm unfortunately

5
00:00:31,707 --> 00:00:35,528
recording on a computer that apparently just randomly starts.

6
00:00:36,627 --> 00:00:38,769
doing something really heavy on the background.

7
00:00:38,769 --> 00:00:41,471
I have no idea what it is and the fans are very loud.

8
00:00:41,471 --> 00:00:45,914
So I don't think I can do much about that.

9
00:00:45,914 --> 00:00:47,595
I hope it won't be too distracting.

10
00:00:47,595 --> 00:00:51,657
Also, if my eyes kind of linger somewhere else

11
00:00:51,657 --> 00:00:53,999
and I'm looking at the camera in some situation,

12
00:00:53,999 --> 00:00:56,321
don't worry, I'm just looking at the slides.

13
00:00:56,321 --> 00:00:58,762
I need them as a kind of a reminder.

14
00:00:58,762 --> 00:01:02,205
So I'll take a sip of my tea and let's get started.

15
00:01:02,205 --> 00:01:05,747
All right.

16
00:01:06,564 --> 00:01:11,507
So if you haven't played Baba is You or don't know at all what I'm talking about or what the

17
00:01:11,507 --> 00:01:18,211
topic is about, then don't worry. I will start the presentation with some introductions. I will

18
00:01:18,211 --> 00:01:24,234
explain who I am and what is Baba is You. After that, I will go to the actual topic, the rule

19
00:01:24,234 --> 00:01:29,857
system of Baba is You and the rule parsing system of Baba is You. I will tell what it is, how it

20
00:01:29,857 --> 00:01:36,220
works, what kind of phases it has gone through, and finally, I will explain some...

21
00:01:36,661 --> 00:01:39,402
obstacle and problems with the system,

22
00:01:39,402 --> 00:01:39,842
kind of

23
00:01:39,842 --> 00:01:48,184
complications that I'm faced with the system right now and earlier in development. And finally, I'll just

24
00:01:48,184 --> 00:01:51,484
kind of gather my thoughts with some conclusions.

25
00:01:51,484 --> 00:01:53,505
Let's get started.

26
00:01:53,505 --> 00:01:59,766
Part one, introduction. So who am I? As mentioned, I'm Arvi Teikari,

27
00:01:59,766 --> 00:02:03,587
also known as Hempuli on the Internet.

28
00:02:03,587 --> 00:02:04,087
Hempuli.

29
00:02:05,787 --> 00:02:12,089
I'm a game developer from Helsinki, Finland, and I started making games as a hobby in primary school.

30
00:02:12,089 --> 00:02:18,810
I had already been interested in making video games in kindergarten because my cousin had

31
00:02:18,810 --> 00:02:24,712
a Super Nintendo and my brother also played a lot of video games, and Super Mario World

32
00:02:24,712 --> 00:02:27,072
on Super Nintendo is probably the kind of thing.

33
00:02:28,224 --> 00:02:34,649
biggest singular thing I can remember from my childhood as being kind of an inspiration to start making games.

34
00:02:34,649 --> 00:02:40,435
So in primary school a schoolmate asked me if I wanted to make games and showed the program GameMaker to me.

35
00:02:40,435 --> 00:02:43,477
And we started making games together.

36
00:02:43,477 --> 00:02:48,782
But the problem with GameMaker was that it has its own scripting language, the GML.

37
00:02:49,882 --> 00:02:55,486
And since I was a primary schooler, I had a pretty low attention span and I didn't understand English very well.

38
00:02:55,486 --> 00:03:01,170
So having to learn the scripting language turned out to be kind of a

39
00:03:01,170 --> 00:03:05,152
big roadblock. I just didn't have the patience to really get into it.

40
00:03:05,152 --> 00:03:11,357
And also it was very slow to learn it because I didn't understand it. I kind of had to learn by trial and error.

41
00:03:11,357 --> 00:03:12,558
So eventually...

42
00:03:13,135 --> 00:03:19,899
Another schoolmate showed this program called The Games Factory to me, made by Clickteam,

43
00:03:19,899 --> 00:03:26,202
which was actually pretty popular in Finland during that time, in like 2002 or 2003, and

44
00:03:26,202 --> 00:03:28,523
a lot of kids using it.

45
00:03:28,523 --> 00:03:31,765
And it was cool in that it didn't require any scripting at all.

46
00:03:31,765 --> 00:03:40,429
It had a purely visual interface with its own kind of visual coding, like conditions

47
00:03:40,429 --> 00:03:41,549
or event system.

48
00:03:42,231 --> 00:03:46,753
And because everything was on a list, even though everything was still in English,

49
00:03:46,753 --> 00:03:51,776
it was way easier for me to start learning it because the kind of trial and error approach

50
00:03:51,776 --> 00:03:56,319
was much more doable in there. And also I was kind of slowly learning English on the side as well.

51
00:03:56,319 --> 00:04:03,903
And I stuck with the Games Factory and eventually moved to its sequel or successor called

52
00:04:03,903 --> 00:04:09,726
Multibidder Fusion. Multibidder Fusion turned into Multibidder Fusion 2 and right now it's

53
00:04:09,726 --> 00:04:11,187
Clickteam Fusion 2.5 and 2.5+.

54
00:04:11,564 --> 00:04:20,928
Although I stopped following the progress at Multibit Efficient 2 because I was so used to that program and I've been using Multibit Efficient 2 ever since.

55
00:04:20,928 --> 00:04:28,851
And basically all of my games that I've put online have been made in Multibit Efficient 2, including Baba is You.

56
00:04:28,851 --> 00:04:35,893
Also, in 2010, I participated in a physical game jam for the first time.

57
00:04:35,893 --> 00:04:37,934
I had already participated in Ludum Dare.

58
00:04:38,914 --> 00:04:43,377
online jam and liked it quite a lot and because I didn't really have that many

59
00:04:43,377 --> 00:04:48,221
friends or any friends that were interested in game development except on a like very surface

60
00:04:48,221 --> 00:04:53,245
level it was still a very kind of nerdy thing in my mind at that point. It sounded super cool

61
00:04:53,245 --> 00:04:58,488
to be able to go somewhere else and meet other game developers that I know over the internet.

62
00:04:58,982 --> 00:05:01,562
So I went to SjÃ¶vde to No More Sweden.

63
00:05:01,562 --> 00:05:07,364
Don't worry about the name, it's not like an anti-Sweden game jam, it's organized in

64
00:05:07,364 --> 00:05:07,804
Sweden.

65
00:05:07,804 --> 00:05:09,884
The name is more of a pun.

66
00:05:09,884 --> 00:05:11,905
And I had a super nice time.

67
00:05:11,905 --> 00:05:17,226
I got hooked in the game jam experience and later went to Nordic Game Jam in Copenhagen

68
00:05:17,226 --> 00:05:20,547
and both those two kind of became my staples.

69
00:05:20,547 --> 00:05:25,868
And they became a very important part of my hobby because they involve a very nice sense

70
00:05:25,868 --> 00:05:28,049
of social interaction and prototyping.

71
00:05:28,462 --> 00:05:33,024
Working fast and not really worrying about bugs, all of those were big pluses for me.

72
00:05:33,024 --> 00:05:42,027
And this game development hobby eventually turned into a commercial job. I made a company,

73
00:05:42,027 --> 00:05:46,588
Hempuli, in 2015 and released my first commercial title in 2015 as well,

74
00:05:46,588 --> 00:05:51,930
called Environmental Station Alpha, and then later in 2019 I released Baba is You.

75
00:05:52,385 --> 00:05:58,072
I also worked on the game Noita in the Nola Games team, although with different tools

76
00:05:58,072 --> 00:05:58,653
to some extent.

77
00:05:58,653 --> 00:06:01,397
I'll check my time at this point.

78
00:06:01,397 --> 00:06:02,298
Okay, looks fine.

79
00:06:02,298 --> 00:06:05,903
Well then, so for Baba is You.

80
00:06:06,948 --> 00:06:11,850
It's a block-pushing puzzle game following in the footsteps of Sokoban,

81
00:06:11,850 --> 00:06:15,251
which might not have been the first block-pushing puzzle game,

82
00:06:15,251 --> 00:06:17,311
but kind of sets the genre in stone.

83
00:06:17,311 --> 00:06:23,774
The idea is that it's a grid-based, usually top-down, not always top-down game,

84
00:06:23,774 --> 00:06:26,175
where you have some kind of blocks you can push around,

85
00:06:26,175 --> 00:06:31,837
and you control some kind of a character that is locked into the grid.

86
00:06:31,837 --> 00:06:35,198
And in the very classic Sokoban-style game,

87
00:06:35,527 --> 00:06:42,751
You have boxes and you have slots for the boxes and the idea is that you have to push those boxes to fill every slot.

88
00:06:42,751 --> 00:06:46,273
And when every slot is filled with a box, you win the level.

89
00:06:46,273 --> 00:06:54,478
And in the past couple of years, this genre has kind of seen a, I don't know, like renaissance or something.

90
00:06:54,478 --> 00:07:00,522
There have been a lot of games in the genre that take this basic concept and twist it in really interesting ways.

91
00:07:00,522 --> 00:07:05,205
I've been super into this kind of, I generally really enjoy this concept of...

92
00:07:05,693 --> 00:07:15,316
taking a simple idea and then just kind of taking it into different directions and seeing what happens.

93
00:07:15,316 --> 00:07:21,659
Especially Steve and LaVell with their puzzle script and other games have been a very intriguing

94
00:07:21,659 --> 00:07:30,642
kind of approach into this block pushing system. And in Bala is You the gimmick, the twist to this

95
00:07:30,642 --> 00:07:35,283
block pushing system is that there are usually three word rules.

96
00:07:35,845 --> 00:07:39,968
that govern how the game works, that dictate what happens in the game.

97
00:07:39,968 --> 00:07:44,451
And the neat thing is that the words that make up these

98
00:07:44,451 --> 00:07:49,034
three-word rules are also pushable blocks in the game world. So not

99
00:07:49,034 --> 00:07:51,596
not only are there like rocks and other things you can push around,

100
00:07:51,596 --> 00:07:55,598
there are also words. And because they are pushable

101
00:07:55,598 --> 00:07:59,241
you can rearrange the words and make new rules so you can change the rules of the

102
00:07:59,241 --> 00:08:02,443
game as you play it. And that is kind of the

103
00:08:02,443 --> 00:08:03,003
the

104
00:08:04,131 --> 00:08:09,194
very core of Baba Is You's gameplay and the thing that makes it interesting.

105
00:08:09,194 --> 00:08:15,597
I created Baba Is You originally in Nordic Game Jam in Copenhagen in 2017,

106
00:08:15,597 --> 00:08:23,421
which is why I mentioned the game jams in the first place. The Nordic Game Jam has usually a

107
00:08:23,421 --> 00:08:28,063
very loose theme, you don't really have to follow it that carefully, but the theme that time was

108
00:08:28,063 --> 00:08:28,884
not there.

109
00:08:29,592 --> 00:08:34,836
And I for some reason concentrated very heavily on the not part of the theme.

110
00:08:34,836 --> 00:08:40,539
I kind of started thinking of how in logic you can have some concepts, an x, and you can

111
00:08:40,539 --> 00:08:47,204
reverse its meaning by saying not x. So you can kind of change the meaning of things with the not.

112
00:08:48,087 --> 00:08:56,275
And this mental logic concept combined with these block pushing games I had played over the years and some other puzzle games

113
00:08:56,275 --> 00:09:04,423
Such games as Steve and Sausage Roll, Snake Bird, A Good Snowman is Hard to Build, Braid and Corrupt

114
00:09:06,312 --> 00:09:10,194
And I kind of pondered up on those puzzle games.

115
00:09:10,194 --> 00:09:13,416
I had wanted to make a puzzle game for a long time,

116
00:09:13,416 --> 00:09:14,496
but had always had some problems

117
00:09:14,496 --> 00:09:16,877
with the implementation and ideas.

118
00:09:16,877 --> 00:09:21,240
And eventually these concepts in my mind kind of amalgamated.

119
00:09:21,758 --> 00:09:27,000
into this idea where there's a top-down block pushing game

120
00:09:27,000 --> 00:09:33,702
where there's a pool of lava and the lava is obviously hot and there are blocks of ice and

121
00:09:33,702 --> 00:09:38,443
the ice of course melts in the lava. So if the ice comes in contact with the lava the ice melts

122
00:09:38,443 --> 00:09:42,985
But as you can see here, where is my cursor? There's my cursor

123
00:09:42,985 --> 00:09:48,687
In this mental concept you could state ice is not melt

124
00:09:49,273 --> 00:09:51,953
to make the ice not care about the lava.

125
00:09:51,953 --> 00:09:54,614
This sounded kind of a dubious idea at first.

126
00:09:54,614 --> 00:09:56,114
It sounded like something that would run

127
00:09:56,114 --> 00:09:57,554
into implementation problems

128
00:09:57,554 --> 00:10:00,275
or wouldn't be very interesting to play with.

129
00:10:00,275 --> 00:10:02,835
But the nice thing about game jams is that

130
00:10:02,835 --> 00:10:05,376
it's very easy to just go and try out something

131
00:10:05,376 --> 00:10:07,156
and see if it works, make a prototype

132
00:10:07,156 --> 00:10:08,596
and throw it away if it doesn't.

133
00:10:08,596 --> 00:10:10,737
So I decided to prototype Ba Ba Zhu.

134
00:10:10,737 --> 00:10:14,418
And over the game jam, the idea kind of progressed.

135
00:10:14,418 --> 00:10:14,978
For example,

136
00:10:16,158 --> 00:10:23,563
Whereas originally I had had this concept of lava being hot by default and ice being meltable by default

137
00:10:23,563 --> 00:10:28,946
I decided that it's actually in more interesting if lava and ice are nothing by default

138
00:10:28,946 --> 00:10:34,270
But instead you have to state lava is hot and ice is melt separately

139
00:10:34,270 --> 00:10:38,732
So that like nothing in the game world has meaning unless there are rules applied to them

140
00:10:38,732 --> 00:10:41,034
I think that's a pretty cool concept and I went with that

141
00:10:41,960 --> 00:10:45,162
And, uh, Baba Is You ended up winning the Game Jam.

142
00:10:45,162 --> 00:10:49,184
It was voted the best game of the jam that year.

143
00:10:49,184 --> 00:10:53,807
And, uh, because of that, and because of encouragement

144
00:10:53,807 --> 00:10:56,108
and, uh, persuasion from other game developers,

145
00:10:56,108 --> 00:11:00,871
I decided eventually to, uh, make a full game out of it.

146
00:11:00,871 --> 00:11:05,413
And, uh, I worked on Baba Is You for almost exactly two years,

147
00:11:05,413 --> 00:11:05,794
from 2017 to 2019.

148
00:11:07,103 --> 00:11:12,725
And over that time it also won some other awards and was in some events.

149
00:11:12,725 --> 00:11:18,346
The most notable award was probably the IGF, Independent Games Festival,

150
00:11:18,346 --> 00:11:22,686
Excellence in Design and Best Student Game Awards in 2019.

151
00:11:22,686 --> 00:11:23,907
And in March 2019, sorry 2018,

152
00:11:23,907 --> 00:11:28,888
wasn't the Independent Games Festival as you can see here.

153
00:11:28,888 --> 00:11:30,288
I said it wrong.

154
00:11:30,288 --> 00:11:35,509
So in March 2019 the game was released and it's been fairly successful,

155
00:11:35,509 --> 00:11:36,769
so that's also cool.

156
00:11:37,614 --> 00:11:44,797
Yay. Anyway, I'll check the time. Here we go. Let's move on to the actual... No.

157
00:11:45,292 --> 00:11:52,214
I'm forgetting something. Yeah, so because I've only explained Baba Isu's concept only

158
00:11:52,214 --> 00:11:59,417
by words, kind of in theory so far, I have some pictures to kind of indicate how the

159
00:11:59,417 --> 00:12:04,818
game works so that it's easier to grasp what the game is about in case my explanation was

160
00:12:04,818 --> 00:12:13,301
too fast or too difficult. Not too difficult, too confusing, too bad.

161
00:12:14,114 --> 00:12:19,499
Anyway, so here we have two pictures indicating the basic gameplay of Baba is You.

162
00:12:19,499 --> 00:12:22,622
So here we have the creature Baba.

163
00:12:22,622 --> 00:12:28,508
As you probably guessed, the name Baba is You in itself is already a rule.

164
00:12:28,508 --> 00:12:35,154
It means that this creature, Baba, is you, the player, so you control Baba.

165
00:12:36,231 --> 00:12:41,533
And here, let's assume that Baba is you, the rule is somewhere out of way.

166
00:12:41,533 --> 00:12:45,816
Here we have wall is stop and flag is win.

167
00:12:45,816 --> 00:12:52,999
And we have this wall of wall and then the flag here.

168
00:12:52,999 --> 00:12:57,981
And Baba needs to reach the wall, needs to reach the flag because...

169
00:12:58,735 --> 00:13:09,082
In Baba is You, you win a level not by pushing blocks into marked spots, but instead by having something that is you touch something that is win.

170
00:13:09,082 --> 00:13:14,826
So if Baba is You and flag is win and Baba touches flag, then the level is won.

171
00:13:14,826 --> 00:13:18,269
And, uh, I'll have to take some tea, sorry.

172
00:13:22,927 --> 00:13:26,508
And here, Baba cannot reach the flag because wall is stopped.

173
00:13:26,508 --> 00:13:31,289
Baba cannot move through the wall because wall is stopped.

174
00:13:31,289 --> 00:13:32,690
Wall is solid.

175
00:13:32,690 --> 00:13:35,591
What Baba can do is, or the player can do,

176
00:13:35,591 --> 00:13:38,291
is break the rule, the wall is stopped rule,

177
00:13:38,291 --> 00:13:42,893
to misalign the words so that wall is no longer stopped.

178
00:13:42,893 --> 00:13:45,533
And as you can see here, Baba can walk from here, there.

179
00:13:46,370 --> 00:13:49,332
and move through the wall and reach the flag.

180
00:13:49,332 --> 00:13:52,935
That is kind of a very basic way the game can function,

181
00:13:52,935 --> 00:13:55,076
how the puzzles can function.

182
00:13:55,076 --> 00:13:58,979
As another example, here, let's assume that Baba,

183
00:13:58,979 --> 00:14:03,423
the creature is somewhere not seen, but like existing.

184
00:14:03,423 --> 00:14:06,065
There's the rule, wall is top again, flag is win again.

185
00:14:06,065 --> 00:14:08,547
Now Baba is you, the rule is also visible.

186
00:14:08,547 --> 00:14:11,889
There's again, the kind of square of wall.

187
00:14:12,601 --> 00:14:14,422
that Baba cannot move through.

188
00:14:14,422 --> 00:14:17,264
You could solve this situation in the same way as before.

189
00:14:17,264 --> 00:14:19,426
You could break the wall is stop rule.

190
00:14:19,426 --> 00:14:22,468
But if we, for example, assume that the wall is stop rule

191
00:14:22,468 --> 00:14:26,490
is somehow located so that you cannot change it,

192
00:14:26,490 --> 00:14:30,833
then what you can do is say, wall is you.

193
00:14:30,833 --> 00:14:32,495
You could replace the stop with you,

194
00:14:32,495 --> 00:14:35,497
but you can also do this, wall is stop, wall is you.

195
00:14:35,497 --> 00:14:38,218
And make the wall the player character.

196
00:14:38,218 --> 00:14:39,860
In this situation, Baba.

197
00:14:40,461 --> 00:14:44,228
would no longer be you and Baba would be nothing anymore.

198
00:14:44,228 --> 00:14:48,075
And instead, the world would become the player.

199
00:14:48,075 --> 00:14:48,977
And then, uh, the.

200
00:14:49,499 --> 00:14:55,365
this cartoon or comic series doesn't really indicate movement very well, but here the wall

201
00:14:55,365 --> 00:15:00,009
would move to the right a couple of times and reach the flag because they would now be the

202
00:15:00,009 --> 00:15:03,933
player character and since when something that is you touches something that is win you beat the

203
00:15:03,933 --> 00:15:08,897
level, the level would be won in this situation. So yeah, that's the basic functionality of the

204
00:15:08,897 --> 00:15:14,423
game. There's a lot of complications later but that's the basic gist of it. Anyway, uh...

205
00:15:15,467 --> 00:15:17,848
Yeah, let's move on to the actual topic.

206
00:15:17,848 --> 00:15:20,890
So, the rule system of the game.

207
00:15:20,890 --> 00:15:22,551
So, there are all these rules, but...

208
00:15:22,551 --> 00:15:30,116
But the game needs to somehow translate those rules

209
00:15:30,116 --> 00:15:33,858
that exist in the game world into some kind of a format

210
00:15:33,858 --> 00:15:36,019
that it can understand on a code level,

211
00:15:36,019 --> 00:15:39,942
in the game logic level.

212
00:15:39,942 --> 00:15:41,563
And because I hadn't seen any other game

213
00:15:41,563 --> 00:15:42,423
do anything like this.

214
00:15:43,600 --> 00:15:47,163
I felt that I needed a pretty novel solution for this.

215
00:15:47,163 --> 00:15:50,326
Also, because I was making the first version of the game

216
00:15:50,326 --> 00:15:54,850
during the game jam, the first version had to be very simplistic and quick

217
00:15:54,850 --> 00:15:58,673
so I just made up something. It was a very crude solution but it worked.

218
00:15:58,673 --> 00:16:04,819
I was pretty happy with it so I had to figure out some quick

219
00:16:04,819 --> 00:16:07,121
dirty solution fast.

220
00:16:11,056 --> 00:16:19,403
And since after I decided to make a full game out of Baba Is You,

221
00:16:19,403 --> 00:16:24,047
the rule system evolved a lot over the two years of development.

222
00:16:24,047 --> 00:16:29,451
There were several rewrites and rebalances and re-whatevers over that time.

223
00:16:29,451 --> 00:16:36,257
But the basic structure of the rules stayed the same.

224
00:16:36,257 --> 00:16:39,820
So while in-game the game kind of has a list of rules,

225
00:16:40,598 --> 00:16:44,100
which it kind of... what is the word?

226
00:16:44,100 --> 00:16:49,805
consults to find rules, to check what rules there are

227
00:16:49,805 --> 00:16:57,410
and there are three components that make up every rule, that are at

228
00:16:57,410 --> 00:17:04,295
the basis of every rule. So these three basic components are

229
00:17:04,295 --> 00:17:09,339
firstly the object, which means a baba, rock, wall, flag

230
00:17:10,788 --> 00:17:19,454
It could also be called subject, but I kind of like object because I call the things that actually exist in the game world objects as well.

231
00:17:19,454 --> 00:17:28,580
An object basically indicates which thing, which object does this rule apply to.

232
00:17:28,580 --> 00:17:31,682
What is the target of this rule?

233
00:17:31,682 --> 00:17:36,044
Then there are verbs, for example, is.

234
00:17:36,844 --> 00:17:45,668
that act as kind of connectors between this first type and the third type of words in the rules and

235
00:17:45,668 --> 00:17:53,211
they kind of modulate the interaction between the first and the last words. They kind of indicate

236
00:17:53,211 --> 00:17:56,212
how the third word affects the object.

237
00:17:56,212 --> 00:18:04,475
And depending on the verbs.

238
00:18:05,266 --> 00:18:07,427
They can do different things

239
00:18:07,427 --> 00:18:09,948
Finally the third type

240
00:18:09,948 --> 00:18:11,168
quality

241
00:18:11,168 --> 00:18:14,070
Which is basically you

242
00:18:14,070 --> 00:18:16,871
For example or move or push or win

243
00:18:16,871 --> 00:18:22,173
Which is effectively the kind of effect that is applied to the object

244
00:18:22,173 --> 00:18:28,596
In some situations some verbs might also accept

245
00:18:28,596 --> 00:18:33,738
other objects as a kind of connecting thing so you could say

246
00:18:35,024 --> 00:18:39,065
Baba is you, flag is win, rock is push, wall is stop, and so on.

247
00:18:39,065 --> 00:18:40,985
So you could connect object into a quality.

248
00:18:40,985 --> 00:18:46,247
But you could also say, Baba is wall or Baba is flag

249
00:18:46,247 --> 00:18:48,687
to create a kind of a transformation effect.

250
00:18:48,687 --> 00:18:53,168
And in that case, it would be the verb connecting two objects.

251
00:18:53,168 --> 00:18:56,429
So there's some kind of flexibility there.

252
00:18:56,429 --> 00:19:03,430
But still, those three parts of the rule are always there in some form.

253
00:19:05,568 --> 00:19:11,212
But there can be additional components, as you will see in just a moment.

254
00:19:11,212 --> 00:19:18,456
So, as I alluded to, during the gameplay, the game logic basically works, is built around

255
00:19:18,456 --> 00:19:22,319
the game asking different kind of questions from this list of rules.

256
00:19:22,319 --> 00:19:28,703
So it will go through the list of rules in different ways and check, like, which objects

257
00:19:28,703 --> 00:19:30,624
does this rule apply to?

258
00:19:34,967 --> 00:19:38,649
what rules does this object specifically have?

259
00:19:38,649 --> 00:19:42,591
Or does, if I have this rule,

260
00:19:42,591 --> 00:19:46,593
does this specific rule apply to this specific instance

261
00:19:46,593 --> 00:19:49,975
of this specific object, that kind of stuff?

262
00:19:49,975 --> 00:19:54,538
Or what kind of qualities are connected to a verb

263
00:19:54,538 --> 00:19:56,599
or what kind of objects are connected to a verb?

264
00:19:56,599 --> 00:20:01,361
How does the, what kind of things is the verb modulating?

265
00:20:02,291 --> 00:20:06,312
And then the rule system tells it, hey, OK, I have this rule.

266
00:20:06,312 --> 00:20:06,952
Do what you want.

267
00:20:06,952 --> 00:20:10,573
And then the game logic tries to interpret those rules

268
00:20:10,573 --> 00:20:12,854
as it best, as well as it can.

269
00:20:12,854 --> 00:20:22,616
And I will next be explaining the kind of structure

270
00:20:22,616 --> 00:20:31,438
of the rule-forming process, the rule-parsing process.

271
00:20:31,438 --> 00:20:31,998
And

272
00:20:32,534 --> 00:20:40,696
Most of the rule parsing logic is implemented in the Lua scripting language and I'm pretty sure that a lot of people who watch this talk

273
00:20:40,696 --> 00:20:43,357
already know what Lua scripting is

274
00:20:43,357 --> 00:20:49,199
and know what tables are, but I'm going to explain tables quickly to just kind of

275
00:20:49,199 --> 00:20:54,100
just in case someone doesn't know what Lua tables are or wants to get like a refresher or something.

276
00:20:55,078 --> 00:21:00,781
So Lua tables are basically databases of key-value pairs.

277
00:21:00,781 --> 00:21:04,763
So there's some kind of a key, which is if you think of like a

278
00:21:04,763 --> 00:21:11,446
shelf with boxes, the key is kind of the notes on the box

279
00:21:11,446 --> 00:21:16,248
that it's kind of ID, it's identifier. It can be a number or a string, so you

280
00:21:16,248 --> 00:21:17,869
could have a shelf of boxes.

281
00:21:18,600 --> 00:21:25,605
where the boxes have names or numbers and then you can find a certain box using its name or number.

282
00:21:25,605 --> 00:21:31,710
That is the key. And then every key is connected to a value and the value can be quite a few things.

283
00:21:31,710 --> 00:21:35,092
Basically these are the boxes in this metaphor.

284
00:21:35,839 --> 00:21:39,623
So the box or the value can be a number or a text string.

285
00:21:39,623 --> 00:21:46,651
It can even be a Lua function. It can be another table, a sub table so to say.

286
00:21:46,651 --> 00:21:48,854
So there's a lot of flexibility in this system

287
00:21:48,854 --> 00:21:55,561
and that is that makes it really powerful but also kind of...

288
00:21:56,342 --> 00:22:00,084
susceptible to certain kinds of bugs and errors.

289
00:22:00,084 --> 00:22:04,827
And I think some people are not huge fans of Lua in general or the Lua tables

290
00:22:04,827 --> 00:22:09,150
because they are so arbitrary, but I personally really like it how

291
00:22:09,150 --> 00:22:15,154
the Lua table can in a single structure do many different data

292
00:22:15,154 --> 00:22:19,957
structures from other languages. A table can be an array, it can be a list,

293
00:22:19,957 --> 00:22:23,119
it can be other more complex types of databases,

294
00:22:23,119 --> 00:22:24,620
just in the same thing.

295
00:22:25,198 --> 00:22:30,542
And I've even drawn this small MS Paint diagram to explain the idea of a table.

296
00:22:30,542 --> 00:22:35,967
So, here's this box is table and later on when I explain things,

297
00:22:35,967 --> 00:22:43,453
if I have these kinds of boxes, these are the tables.

298
00:22:43,453 --> 00:22:47,337
And within the table we can have, for example here,

299
00:22:47,337 --> 00:22:52,501
with a key 1 or slot 1, we can have the string A.

300
00:22:52,501 --> 00:22:53,222
Or in slot 2.

301
00:22:54,332 --> 00:22:56,973
Well, value two, we can have the string hello.

302
00:22:56,973 --> 00:23:02,796
Or with the key hello, we can instead have the number three.

303
00:23:02,796 --> 00:23:06,598
Or we could have the string hello be the key

304
00:23:06,598 --> 00:23:08,018
and the value be also hello.

305
00:23:08,018 --> 00:23:10,319
Everything works or whatever works.

306
00:23:10,319 --> 00:23:15,722
Here's also the key foo has the value function

307
00:23:15,722 --> 00:23:18,583
and the function can then be defined,

308
00:23:18,583 --> 00:23:20,885
or the key bar.

309
00:23:21,713 --> 00:23:27,239
has a subtable which in turn contains other key value pairs.

310
00:23:27,239 --> 00:23:28,940
That's the basic structure.

311
00:23:28,940 --> 00:23:30,442
It's neat in my opinion.

312
00:23:30,442 --> 00:23:35,686
So how it actually works, how does the rule forming,

313
00:23:35,686 --> 00:23:37,188
the rule parsing part work?

314
00:23:37,188 --> 00:23:40,491
The initial problem is of course,

315
00:23:40,491 --> 00:23:42,613
that we have a level with a lot of words

316
00:23:42,613 --> 00:23:46,576
and the words can be in all kinds of configurations.

317
00:23:46,576 --> 00:23:47,357
There might be.

318
00:23:48,443 --> 00:23:52,706
There might be jumbles of words, a huge mess.

319
00:23:52,706 --> 00:23:57,668
There could be a single word somewhere, there could be just... whatever.

320
00:23:57,668 --> 00:24:04,511
Some of these words might form valid sentences that can make rules.

321
00:24:04,511 --> 00:24:09,314
You can already see here vertically, Baba is you, or Rock is push.

322
00:24:09,314 --> 00:24:15,257
But then there's stuff like, is grass you, which is just nonsense, or there's just water,

323
00:24:15,257 --> 00:24:16,497
which doesn't do anything.

324
00:24:17,057 --> 00:24:21,060
or wall is, which is almost a working sentence but

325
00:24:21,060 --> 00:24:27,425
doesn't work. And the solution to the problem of how to handle, how to

326
00:24:27,425 --> 00:24:33,691
make these objects that are words into actual sentences that the game logic can

327
00:24:33,691 --> 00:24:38,575
use, lies in having doing multiple passes

328
00:24:38,575 --> 00:24:41,998
throughout the level and throughout the these

329
00:24:41,998 --> 00:24:43,078
potential sentences.

330
00:24:43,573 --> 00:24:50,876
And I will now go through all these passes in a kind of a slightly abstract way.

331
00:24:50,876 --> 00:25:01,181
So the first pass means that the rule logic tries to find all words that could be the

332
00:25:01,181 --> 00:25:03,922
first word of a sentence.

333
00:25:03,922 --> 00:25:08,925
And because for some game designers, some simplicity reasons, all rules

334
00:25:09,726 --> 00:25:15,330
are either from left to right, I think this is your left to right, or top to bottom,

335
00:25:15,330 --> 00:25:20,274
and they have to be in a straight line, they cannot do L-shapes or curves or whatever.

336
00:25:20,274 --> 00:25:26,359
Basically, when checking which words could be the first word of a sentence,

337
00:25:26,359 --> 00:25:29,441
the game only has to check,

338
00:25:29,441 --> 00:25:29,921
is this...

339
00:25:31,751 --> 00:25:37,575
Sorry. Is there something above or to the left of a word?

340
00:25:37,575 --> 00:25:40,958
If there's nothing to the left or above a word,

341
00:25:40,958 --> 00:25:44,941
it can be assumed that it might be the first word of a sentence.

342
00:25:45,768 --> 00:25:49,712
And the game then adds all these potential first words into a list,

343
00:25:49,712 --> 00:25:54,737
goes through them, and checks how many other words they are linked to.

344
00:25:54,737 --> 00:25:58,481
In other words, how many words are below them

345
00:25:58,481 --> 00:26:03,106
or to the right from them. That's right for you.

346
00:26:03,106 --> 00:26:05,469
And in this situation...

347
00:26:06,145 --> 00:26:10,831
The game only cares about just finding words.

348
00:26:10,831 --> 00:26:13,394
It doesn't care about what those words are.

349
00:26:13,394 --> 00:26:21,123
And because, as mentioned earlier, the basic rule structure always has at least three components.

350
00:26:21,123 --> 00:26:23,886
The object, the verb, and the quality.

351
00:26:24,620 --> 00:26:36,712
any sentence or word, kind of lines, strings of words that have less than three words can be discarded outright.

352
00:26:36,712 --> 00:26:40,615
So here we can see that Baba is You Rock.

353
00:26:40,615 --> 00:26:46,621
It's four words. That's fine. That works. Let's add it to the potential sentence list.

354
00:26:46,621 --> 00:26:48,163
It doesn't matter if it works or not.

355
00:26:48,567 --> 00:26:57,732
Then there's Rocky's push, Easygrass U, again, who cares if it works? It looks fine, so let's go with it.

356
00:26:57,732 --> 00:27:02,735
And Flag Has Win also has three words, it's more than one or two, it works.

357
00:27:03,285 --> 00:27:10,169
water or wall lava or wall is are all discarded, they don't get long enough.

358
00:27:10,169 --> 00:27:18,233
Technically the game even tests if this is might be the first word in the sentence going in this

359
00:27:18,233 --> 00:27:23,575
direction, but obviously because there are no words here and is cannot be the first word of

360
00:27:23,575 --> 00:27:32,200
a sentence then it's just discarded. Anyway, these potential proto-sentences get

361
00:27:32,746 --> 00:27:34,868
get to go forward to the second pass.

362
00:27:34,868 --> 00:27:36,949
And in the second pass,

363
00:27:36,949 --> 00:27:38,470
the game kind of goes through

364
00:27:38,470 --> 00:27:41,473
these sentences a bit more carefully

365
00:27:41,473 --> 00:27:44,315
and tries to figure out

366
00:27:44,315 --> 00:27:48,458
kind of roughly if they might be sensible rules.

367
00:27:48,458 --> 00:27:50,220
And here,

368
00:27:50,220 --> 00:27:52,261
something called word type

369
00:27:52,261 --> 00:27:54,283
becomes very important.

370
00:27:54,283 --> 00:27:55,063
Every different...

371
00:27:59,182 --> 00:28:02,806
Every different type of word has its own ID number.

372
00:28:02,806 --> 00:28:10,977
For example, baba, the object, has type 0, verbs like is have type 1, and you, qualities,

373
00:28:10,977 --> 00:28:12,979
have type 2.

374
00:28:12,979 --> 00:28:15,923
And in this second pass, the game kind of...

375
00:28:16,504 --> 00:28:22,826
starts from the first word and goes from there and checks using a certain

376
00:28:22,826 --> 00:28:30,448
pretty complicated logic actually if the words follow this like if the word types follow a

377
00:28:30,448 --> 00:28:33,229
Certain well logic. I guess I repeated myself there

378
00:28:33,229 --> 00:28:33,350
and

379
00:28:33,350 --> 00:28:42,073
Even in this situation there might be some cases where the sentence doesn't actually make sense

380
00:28:42,073 --> 00:28:45,954
But if it follows this certain logic it will get past this second pass

381
00:28:46,692 --> 00:28:56,254
To give an example, in this first image we had BabaIsYouRock, which passed the first pass.

382
00:28:56,254 --> 00:29:03,895
In the second pass, the game checks, okay, BabaIsYou, yeah, that works, there's type 0, type 1, type 2, everything is fine.

383
00:29:03,895 --> 00:29:09,336
Then it finds Rock and thinks that, okay, no, Rock cannot follow You.

384
00:29:09,336 --> 00:29:11,317
Let's discard Rock.

385
00:29:11,317 --> 00:29:13,457
And then it says, okay, BabaIsYou works.

386
00:29:13,833 --> 00:29:16,516
we'll use that, rock is discarded.

387
00:29:16,516 --> 00:29:18,978
And it does the same for rock is push and flag is win.

388
00:29:18,978 --> 00:29:21,360
Flag is win also is type zero, type one, type two.

389
00:29:21,360 --> 00:29:21,840
So it gets the pass.

390
00:29:21,840 --> 00:29:23,542
But if a word is discarded in this situation,

391
00:29:23,542 --> 00:29:26,985
it still has a second try,

392
00:29:26,985 --> 00:29:33,150
because it could be that sometimes a word that is discarded

393
00:29:33,150 --> 00:29:35,852
because it doesn't fit a certain rule

394
00:29:35,852 --> 00:29:38,454
might fit another rule on its own.

395
00:29:38,454 --> 00:29:39,375
So for example,

396
00:29:40,651 --> 00:29:44,052
In this case, if there was Baba is U,

397
00:29:44,052 --> 00:29:48,013
Rock is push vertically all the way through.

398
00:29:48,013 --> 00:29:50,653
When Rock is discarded,

399
00:29:50,653 --> 00:29:54,394
the Rock would still form a valid rule with Rock is push.

400
00:29:54,394 --> 00:29:58,215
So it's important that when the game checks

401
00:29:58,215 --> 00:29:58,835
that Baba is U, Rock.

402
00:29:58,835 --> 00:30:03,496
Okay, Rock doesn't work with Baba is U, let's remove Rock.

403
00:30:03,496 --> 00:30:05,596
That it returns back to Rock to notice that,

404
00:30:05,596 --> 00:30:08,257
hey, okay, Rock is push is a valid rule again.

405
00:30:08,257 --> 00:30:09,017
So it kind of, yeah.

406
00:30:09,017 --> 00:30:09,897
There's that.

407
00:30:10,877 --> 00:30:15,998
needs to be some safety there so that accidentally rules being

408
00:30:15,998 --> 00:30:20,680
next to each other don't kind of cause each other to not work

409
00:30:20,680 --> 00:30:22,380
or something like that.

410
00:30:22,380 --> 00:30:26,261
And as mentioned earlier, there are some other word types

411
00:30:26,261 --> 00:30:30,382
that were added later that complicate this process

412
00:30:30,382 --> 00:30:31,222
enormously.

413
00:30:31,222 --> 00:30:36,723
The second pass is probably the most complicated part

414
00:30:36,723 --> 00:30:39,064
of this rule parsing.

415
00:30:39,339 --> 00:30:42,041
system because of those extra rule types.

416
00:30:42,041 --> 00:30:51,027
Anyway, so here we have Baba is you, Rock is push, Flag has win, which go to the third pass. I'll check the time

417
00:30:51,027 --> 00:30:52,268
Okay

418
00:30:52,268 --> 00:30:55,810
And in the third pass

419
00:30:55,810 --> 00:31:04,056
This kind of in this situation the rules are finally evaluated fully to see if they

420
00:31:04,056 --> 00:31:07,138
actually kind of make sense and

421
00:31:07,138 --> 00:31:07,938
in this situation

422
00:31:10,696 --> 00:31:19,021
Instead of just checking the word types, the game checks which words allow which words

423
00:31:19,021 --> 00:31:20,282
to follow them.

424
00:31:20,282 --> 00:31:28,107
So for example, flag has win worked in the second pass because it had the correct word

425
00:31:28,107 --> 00:31:28,427
types.

426
00:31:28,427 --> 00:31:30,309
But in third pass...

427
00:31:31,074 --> 00:31:40,201
Has doesn't allow qualities like win after it. It only allows other objects. So you could say

428
00:31:40,201 --> 00:31:43,925
Flag has Baba, but you cannot say flag has win

429
00:31:43,925 --> 00:31:50,991
So in the third pass this flag has win rule gets disregarded and removed or discarded I guess

430
00:31:50,991 --> 00:31:52,692
as

431
00:31:52,692 --> 00:31:56,896
As we can see here

432
00:31:56,896 --> 00:31:58,637
and so

433
00:31:59,448 --> 00:32:02,289
In this example picture, flagAsWin got removed.

434
00:32:02,289 --> 00:32:04,871
We were left with just BabaIsYou and RockIsPush.

435
00:32:04,871 --> 00:32:10,094
And these two sentences, now that they were verified to work,

436
00:32:10,094 --> 00:32:12,955
they are then transformed into a format

437
00:32:12,955 --> 00:32:16,217
that the game can understand and the game logic can use

438
00:32:16,217 --> 00:32:19,799
in the actual in-game functionality.

439
00:32:22,229 --> 00:32:26,511
and they get added into different rule lists.

440
00:32:26,511 --> 00:32:28,952
For example, there's a kind of a global rule list

441
00:32:28,952 --> 00:32:32,074
that has every single rule in it,

442
00:32:32,074 --> 00:32:35,656
but there are also object-specific rule lists

443
00:32:35,656 --> 00:32:39,718
so that if I want to see which rules does Baba have,

444
00:32:39,718 --> 00:32:41,258
I don't have to check every single rule.

445
00:32:41,258 --> 00:32:44,220
I can just check from like a Baba-specific list.

446
00:32:44,220 --> 00:32:45,520
It's nice.

447
00:32:45,520 --> 00:32:48,842
And before everything is done,

448
00:32:48,842 --> 00:32:50,123
there are some extra steps.

449
00:32:50,730 --> 00:33:00,334
So finally, before the game is happy with the rules, it needs to do some complicated shuffling

450
00:33:00,334 --> 00:33:06,077
related to conditional words, which is a kind of a special word type that I will cover more later.

451
00:33:06,077 --> 00:33:10,579
And it will have to make sure that the words are kind of

452
00:33:10,579 --> 00:33:14,001
in their own respective groups. Also more about that later.

453
00:33:15,049 --> 00:33:23,334
Also, the game needs to handle rules that might kind of create other rules because there are some rules that don't really do much in

454
00:33:23,334 --> 00:33:29,078
themselves, but during the parsing process they get divided into other rules.

455
00:33:29,078 --> 00:33:36,163
A good example is all is you or all word in general because all is you

456
00:33:36,163 --> 00:33:40,126
basically just means that every object in level is you.

457
00:33:40,126 --> 00:33:44,368
So instead of just saying all is you and having hard-coded special code for all,

458
00:33:44,840 --> 00:33:50,225
The parsing system divides all is you into baba is you, rock is you, wall is you, flag is you and so on.

459
00:33:50,225 --> 00:33:57,973
And then same happens with the not baba is you. Not baba means that everything that is

460
00:33:57,973 --> 00:34:01,016
not baba is you. So here

461
00:34:01,016 --> 00:34:04,159
rock is you, wall is you, flag is you, but

462
00:34:04,159 --> 00:34:05,740
baba

463
00:34:05,740 --> 00:34:08,743
isn't you or baba is nothing by default with this rule.

464
00:34:10,642 --> 00:34:14,945
There are also rules that might disable other rules.

465
00:34:14,945 --> 00:34:18,688
Again, with the not word, we could say Baba is not you.

466
00:34:18,688 --> 00:34:22,992
And this takes priority over Baba is you and disables Baba is you.

467
00:34:22,992 --> 00:34:27,736
So in this situation, after parsing the rules, we need to go through the rules

468
00:34:27,736 --> 00:34:33,461
again to see these situations where some rule needs to be marked as disabled.

469
00:34:33,461 --> 00:34:37,685
Some people have wondered if this Baba is not you type thing depends on the

470
00:34:37,685 --> 00:34:39,166
order of the rules somewhere.

471
00:34:39,166 --> 00:34:39,566
So that's.

472
00:34:40,144 --> 00:34:42,346
whichever is first takes priority.

473
00:34:42,346 --> 00:34:47,370
But because Baba is not you, would not do anything on its own

474
00:34:47,370 --> 00:34:48,491
if it had kind of lower priority,

475
00:34:48,491 --> 00:34:51,393
I made it so that these disabling rules

476
00:34:51,393 --> 00:34:55,116
always have higher priority than the rules they disable.

477
00:34:55,116 --> 00:34:57,918
And finally, there are some visual things

478
00:34:57,918 --> 00:35:01,921
like throwing particles around, playing sounds,

479
00:35:01,921 --> 00:35:03,622
changing the color of the active rules

480
00:35:03,622 --> 00:35:06,344
and marking disabled rules, stuff like that.

481
00:35:06,344 --> 00:35:08,346
It's not really relevant for this presentation,

482
00:35:08,346 --> 00:35:09,307
but it happens.

483
00:35:12,093 --> 00:35:22,035
Okay, so then as for the kind of how the rules are stored in this list that I've mentioned a couple of times.

484
00:35:22,035 --> 00:35:29,017
So after parsing the rules, when they are added into the rule list, what is the format they use

485
00:35:29,017 --> 00:35:35,338
so that the game logic can understand them? This has been a very long process to get right.

486
00:35:35,338 --> 00:35:40,039
As mentioned earlier, I did a really quick implementation at the Game Jam originally.

487
00:35:40,693 --> 00:35:48,997
and it has required at least five iterations and at least three almost full reworks to get this stuff working properly.

488
00:35:48,997 --> 00:35:54,279
And it's still not working properly for multiple reasons that I will cover in the obstacles area of the talk.

489
00:35:54,279 --> 00:36:01,842
So basically I just started with a simple system, augmented and added to it as needed,

490
00:36:01,842 --> 00:36:05,304
and eventually, inevitably, it became too bloated.

491
00:36:05,654 --> 00:36:09,718
It had too many corner cases, too many hard-coded special things,

492
00:36:09,718 --> 00:36:16,044
or I wanted to add some extra feature that was just impossible to bolt into the existing system,

493
00:36:16,044 --> 00:36:19,928
so I just had to decide to rewrite something,

494
00:36:19,928 --> 00:36:25,513
either the whole rule system or just a part of it, and then start a new iteration.

495
00:36:26,552 --> 00:36:30,914
So the first iteration of the system was very simple as mentioned.

496
00:36:30,914 --> 00:36:36,677
There were basically all the rules were just three words long at maximum.

497
00:36:36,677 --> 00:36:41,179
I only had to check if a rule has three words and if they follow the

498
00:36:41,179 --> 00:36:47,842
object verb quality or object verb object system. And if they follow that

499
00:36:47,842 --> 00:36:52,405
structure they had no fewer no more words and the words

500
00:36:52,405 --> 00:36:53,725
follow this logic then

501
00:36:54,358 --> 00:36:56,779
it was guaranteed that it was a working rule.

502
00:36:56,779 --> 00:36:57,660
So that was very nice.

503
00:36:57,660 --> 00:37:00,361
And parsing, yeah, parsing was very simple,

504
00:37:00,361 --> 00:37:01,581
same for the formatting.

505
00:37:01,581 --> 00:37:05,723
Here's actually a diagram showcasing how the rule was

506
00:37:05,723 --> 00:37:08,044
formatted in the list,

507
00:37:08,044 --> 00:37:10,625
in the kind of Lua table that is the rule list.

508
00:37:11,290 --> 00:37:19,356
So here's the global rule list, which is a table, and within that table, there's the rule subtable.

509
00:37:19,356 --> 00:37:26,741
This blue thing is the actual rule as its own kind of box of things.

510
00:37:26,741 --> 00:37:35,907
Uh, some car horns outside. And within this rule, there was just the, like, the base rule.

511
00:37:35,907 --> 00:37:38,409
Base rule as three words stored.

512
00:37:39,324 --> 00:37:43,618
in a table. So in this table in slot one

513
00:37:44,498 --> 00:37:46,880
There was the first word, baba, in slot 2.

514
00:37:46,880 --> 00:37:51,823
There was a second word, is, in the third slot with a key, 1, 2, 3.

515
00:37:51,823 --> 00:37:54,465
Third slot, there was the word, you.

516
00:37:54,465 --> 00:37:58,107
In fact, I made a slight mistake with this picture.

517
00:37:58,107 --> 00:38:01,549
This orange subtable doesn't need to even exist.

518
00:38:01,549 --> 00:38:06,232
Like, just inside this blue rule subtable,

519
00:38:06,232 --> 00:38:09,734
there can just be three slots with three words, and that's it.

520
00:38:10,552 --> 00:38:15,834
But then I added new words that complicated things enormously as mentioned earlier.

521
00:38:15,834 --> 00:38:20,975
So I added the word AND and conditional words.

522
00:38:20,975 --> 00:38:27,997
To start with AND, AND basically lets you bundle words of the same type together

523
00:38:27,997 --> 00:38:32,398
so that they can be grouped and it's kind of faster.

524
00:38:32,398 --> 00:38:35,598
You don't have to repeat the same thing multiple times in different areas.

525
00:38:37,392 --> 00:38:42,395
When it comes to its normal usage, it works pretty simply.

526
00:38:42,395 --> 00:38:47,057
For example, you can say, Baba and Rock is You, so you make a group of Baba and Rock,

527
00:38:47,057 --> 00:38:48,638
and they are both You.

528
00:38:48,638 --> 00:38:53,640
Or you can say, Baba is You and Move, so you make a group of You and Move, and then Baba

529
00:38:53,640 --> 00:38:54,281
is both of those.

530
00:38:54,281 --> 00:38:57,022
And the nice thing about these is that...

531
00:38:58,063 --> 00:39:00,424
The same with all earlier.

532
00:39:00,424 --> 00:39:03,166
I can just divide baba and rock is you

533
00:39:03,166 --> 00:39:04,347
into two different rules.

534
00:39:04,347 --> 00:39:06,888
Baba is you and rock is you.

535
00:39:06,888 --> 00:39:08,249
And with baba is you and move,

536
00:39:08,249 --> 00:39:10,630
I can just say baba is you and baba is move.

537
00:39:10,630 --> 00:39:11,951
And it's the same thing.

538
00:39:11,951 --> 00:39:14,693
I don't really have to kind of do any special logic

539
00:39:14,693 --> 00:39:17,835
for the and except in the rule parsing phase.

540
00:39:17,835 --> 00:39:19,576
Once the rule is parsed,

541
00:39:19,576 --> 00:39:22,778
I can still use the same data format

542
00:39:22,778 --> 00:39:26,080
because it's just the same thing in other words.

543
00:39:26,527 --> 00:39:31,970
But with these conditional words, things changed.

544
00:39:31,970 --> 00:39:34,452
So the first conditional word was on

545
00:39:34,452 --> 00:39:36,973
and the conditional word as the name implies

546
00:39:36,973 --> 00:39:39,895
added some kind of a condition to the rule

547
00:39:39,895 --> 00:39:42,117
so that not every object had that rule,

548
00:39:42,117 --> 00:39:46,079
but they instead had to fulfill some kind of a requirement

549
00:39:46,079 --> 00:39:46,720
to get that rule.

550
00:39:46,720 --> 00:39:51,383
And the first, yeah, as mentioned,

551
00:39:51,383 --> 00:39:53,844
the first conditional was on,

552
00:39:53,844 --> 00:39:56,126
which meant that the requirement was that

553
00:39:56,912 --> 00:40:05,854
For example, Baba on grass is you meant that if Baba is on the same tile coexisting with grass,

554
00:40:05,854 --> 00:40:10,976
Baba is you. If Baba is not on grass, if there's no grass on the same tile as Baba, then Baba is

555
00:40:10,976 --> 00:40:19,458
not you. And these first conditional words have required these parameters. So in this case,

556
00:40:19,458 --> 00:40:24,979
on is the conditional word and grass is the parameter, Baba on grass is you.

557
00:40:24,979 --> 00:40:25,139
But

558
00:40:26,052 --> 00:40:31,675
I think the original version only had one parameter possible, so you could only say

559
00:40:31,675 --> 00:40:37,559
baba on wall, baba on grass, baba on kiki, kiki is another creature in the game, is

560
00:40:37,559 --> 00:40:38,499
you, or push or whatever.

561
00:40:38,499 --> 00:40:46,524
But I very quickly wanted to add the and functionality to these conditional words, so you could

562
00:40:46,524 --> 00:40:50,486
say baba on grass and flower is you.

563
00:40:52,047 --> 00:40:56,868
The problem with this is that because the conditional only applies to this single rule,

564
00:40:56,868 --> 00:41:02,909
I cannot do the same thing as here where I would divide the rule into multiple things that kind of

565
00:41:02,909 --> 00:41:10,411
together handle the AND, kind of take care of the functionality of the AND, but instead I had to add

566
00:41:10,411 --> 00:41:18,592
new functionality to account for the AND. And because there could be an arbitrary number of

567
00:41:18,592 --> 00:41:21,253
objects or parameters for the conditional, this could be

568
00:41:21,652 --> 00:41:28,398
Baba on grass and flower and wall and flag and kiki and rock and blah blah blah blah is you.

569
00:41:28,398 --> 00:41:33,883
I needed to make a system where a rule could contain an arbitrary number of parameters.

570
00:41:33,883 --> 00:41:42,290
And the first implementation of this system was very naive.

571
00:41:42,290 --> 00:41:48,515
I think my logic was that I wanted to keep the rule kind of...

572
00:41:49,827 --> 00:41:55,411
the order of things within the rule, this kind of what is in slot one, what is in slot two, what is

573
00:41:55,411 --> 00:42:03,236
in slot three, and so on, in the same order as they were in the actual sentence, which meant that

574
00:42:03,236 --> 00:42:08,480
I made a distinction between rules that have conditionals or don't have conditionals.

575
00:42:09,826 --> 00:42:15,009
Rules that don't have conditionals would still follow almost the same format,

576
00:42:15,009 --> 00:42:19,492
so that there would be the rule list, there would be the actual rule, subtable,

577
00:42:19,492 --> 00:42:27,938
and in the subtable there would be on slot one the object Baba, on slot two the verb is,

578
00:42:27,938 --> 00:42:34,422
and on slot three kinda the quality with some differences I will explain in just a moment.

579
00:42:34,422 --> 00:42:38,485
And if a rule had conditions, conditionals...

580
00:42:38,886 --> 00:42:40,749
then the structure would be different.

581
00:42:40,749 --> 00:42:44,715
In slot 1 would be the object again, baba,

582
00:42:44,715 --> 00:42:47,279
but in slot 2 would actually be the conditional,

583
00:42:47,279 --> 00:42:50,383
because in this sentence baba on grass is you,

584
00:42:50,383 --> 00:42:52,727
the on is the second word.

585
00:42:53,208 --> 00:43:00,090
And in slot three, there would be a subtable that contained all the parameters.

586
00:43:00,090 --> 00:43:07,052
So if I had just Baba on grass is you, then in slot three would be a subtable with only one entry.

587
00:43:07,052 --> 00:43:11,113
So in this subtable in slot one would be grass.

588
00:43:11,113 --> 00:43:21,536
If I had Baba on grass and flower is you, then slot three would contain a subtable where in slot one would be grass, in slot two would be flower.

589
00:43:21,536 --> 00:43:22,216
And then...

590
00:43:23,103 --> 00:43:31,946
Slot 4 would contain the verb as usual or not as usual but like would contain the verb is and slot 5 would contain the

591
00:43:31,946 --> 00:43:33,586
quality you

592
00:43:33,586 --> 00:43:35,167
And uh

593
00:43:35,167 --> 00:43:41,409
To keep kind of parity between these systems, even though they had a different amount of slots used

594
00:43:41,409 --> 00:43:49,131
I wanted to make it so that slot 3 would always be a table no matter what the format

595
00:43:49,131 --> 00:43:51,491
No matter whether the rule had conditionals or not

596
00:43:52,149 --> 00:43:59,091
So in this non-conditional rule, I had to make it so that slot 3 is still a subtable.

597
00:43:59,091 --> 00:44:06,594
It just contains only the quality and not grass or flower, but the U and nothing else.

598
00:44:06,594 --> 00:44:12,337
And this system, as you can imagine, was very awkward because it meant that...

599
00:44:13,383 --> 00:44:20,489
When testing if a rule exists, I had to actually do very different things.

600
00:44:20,489 --> 00:44:26,514
For example, if I wanted to see what the verb is in a sentence, I would have to check if

601
00:44:26,514 --> 00:44:35,342
the rule has three or five components and check either slot two or slot four, depending

602
00:44:35,342 --> 00:44:36,442
on that.

603
00:44:36,442 --> 00:44:41,086
And if the rule had only three words, I would have to check

604
00:44:41,823 --> 00:44:47,046
the subtable in slot three in a different way than if it had

605
00:44:47,046 --> 00:44:51,848
five components. So the ideal way to do this would have been a system

606
00:44:51,848 --> 00:44:56,691
where the structure is the same no matter if the rule has conditionals or

607
00:44:56,691 --> 00:44:59,992
not. But well, I think this worked for a

608
00:44:59,992 --> 00:45:03,494
moment for me and I was happy with that but eventually I had to rewrite it

609
00:45:03,494 --> 00:45:09,877
completely because I wanted to add more conditionals.

610
00:45:10,139 --> 00:45:17,383
I wanted to add more conditionals with parameters such as near where baba near grass is you means that if baba

611
00:45:17,383 --> 00:45:23,947
has grass somewhere around baba then baba is you or phasing where if baba is looking at some grass

612
00:45:23,947 --> 00:45:29,611
then baba is you but I also wanted to add conditionals with new types for example lonely

613
00:45:29,611 --> 00:45:34,674
which doesn't take parameters but works more as a kind of a prefix

614
00:45:35,606 --> 00:45:38,207
So you could say lonely Baba is you.

615
00:45:38,207 --> 00:45:42,870
So Baba would be you only if there's no one else on the same tile as Baba.

616
00:45:42,870 --> 00:45:49,293
And as you can imagine, this old rule system couldn't accommodate.

617
00:45:49,293 --> 00:45:53,555
First of all, originally I assumed that there would be only one conditional on.

618
00:45:53,555 --> 00:45:55,976
I didn't take into account other conditionals at all.

619
00:45:55,976 --> 00:46:01,439
But also this system was way too rigid to work with the lonely system at all.

620
00:46:01,439 --> 00:46:03,420
So I had to...

621
00:46:03,420 --> 00:46:04,701
Well, I had to just like...

622
00:46:05,045 --> 00:46:13,529
break everything and rebuild it. And after this third iteration, I found a system that I will show

623
00:46:13,529 --> 00:46:21,554
in the next on the next slide that has basically worked as it is until now or to this day. But

624
00:46:21,554 --> 00:46:30,038
there have been some reworks, some polishing, some even pretty substantial like underlying work,

625
00:46:30,038 --> 00:46:33,560
but the format has mostly stayed the same afterwards.

626
00:46:36,563 --> 00:46:44,228
Yeah, yeah, like there have been more exotic rules, more exotic words that have required extra work in the rule parsing system

627
00:46:44,228 --> 00:46:47,411
But the formatting has been spared mostly

628
00:46:47,411 --> 00:46:48,572
Okay

629
00:46:48,572 --> 00:46:57,238
So here's a nice diagram, very simple, very easy to understand diagram of how what the

630
00:46:57,238 --> 00:47:00,881
rule formatting rule looks right now

631
00:47:00,881 --> 00:47:00,941
so

632
00:47:02,108 --> 00:47:09,134
Even though you probably don't need any explanation, I'll go through this system briefly.

633
00:47:09,134 --> 00:47:15,479
We still have the rule list table, and within this rule list we have these different rules

634
00:47:15,479 --> 00:47:16,840
in their own sub tables.

635
00:47:16,840 --> 00:47:20,964
Here's rule one, here's rule two, they both contain the same stuff, I just didn't draw

636
00:47:20,964 --> 00:47:23,546
the same boxes within rule two.

637
00:47:23,546 --> 00:47:29,170
In rule one, there are three compartments that contain different information.

638
00:47:29,588 --> 00:47:34,610
there's the base rule compartment that contains the same thing as in the

639
00:47:34,610 --> 00:47:38,392
first iteration just kind of the in slot one

640
00:47:38,392 --> 00:47:41,993
baba is slot two is in slot three you the kind of

641
00:47:41,993 --> 00:47:45,614
object verb quality or object verb object structure.

642
00:47:45,614 --> 00:47:54,338
Then the second compartment is the conditional compartment

643
00:47:54,338 --> 00:47:57,399
which contains all the conditionals the rule has.

644
00:47:58,201 --> 00:48:03,963
And because there can be an arbitrary number of conditionals, for reasons I will talk about in just a moment,

645
00:48:03,963 --> 00:48:10,946
and because those conditionals need to be able to have potentially arbitrary numbers of parameters,

646
00:48:10,946 --> 00:48:15,067
these conditionals need to have all their own subtables.

647
00:48:15,067 --> 00:48:21,370
So here in the conditionals compartment, conditional one has its own subtable,

648
00:48:21,370 --> 00:48:27,492
inside which on slot one is the type of the conditional, on in this case.

649
00:48:28,205 --> 00:48:33,269
And on slot two, there's the parameter list,

650
00:48:33,269 --> 00:48:34,610
which is its own subtable.

651
00:48:34,610 --> 00:48:41,156
In this example, the conditional one, whoops,

652
00:48:41,156 --> 00:48:43,138
is of type on.

653
00:48:43,138 --> 00:48:45,780
And in slot two, it has only one parameter

654
00:48:45,780 --> 00:48:47,582
in the subtable grass.

655
00:48:47,582 --> 00:48:52,626
But for example, if we did the baba on grass and flower

656
00:48:52,626 --> 00:48:55,188
is you, then there would be again,

657
00:48:55,849 --> 00:48:58,370
in slot one, grass, in slot two, flower.

658
00:48:58,370 --> 00:49:02,511
And there could be several of these conditional sub tables

659
00:49:02,511 --> 00:49:03,911
and they would look pretty much the same.

660
00:49:03,911 --> 00:49:08,313
If there's a conditional that doesn't have parameters

661
00:49:08,313 --> 00:49:11,274
like lonely, it would still have the same structure

662
00:49:11,274 --> 00:49:14,515
but the second slot sub table would just be empty

663
00:49:14,515 --> 00:49:15,835
and treated as such.

664
00:49:15,835 --> 00:49:18,136
There's also the conditional never

665
00:49:18,136 --> 00:49:20,216
which is done for disabling rules.

666
00:49:20,216 --> 00:49:21,296
It's kind of a special case.

667
00:49:21,296 --> 00:49:23,657
And the third compartment.

668
00:49:24,030 --> 00:49:34,740
is storing the IDs of these words. Basically it's like a reference to the in-level objects, the words

669
00:49:34,740 --> 00:49:40,265
as the player sees them visually in the game. These are needed because, for example, when

670
00:49:40,626 --> 00:49:45,389
the rule becomes active and I want to display some particles or change the

671
00:49:45,389 --> 00:49:50,272
colors of the words, I need to be able to somehow refer back to the words from

672
00:49:50,272 --> 00:49:53,854
this, uh, formatted rule list.

673
00:49:53,854 --> 00:50:00,438
So then I just looked into, look into this word ID, sub table, go through

674
00:50:00,438 --> 00:50:03,060
these and do whatever I want to do all of those.

675
00:50:03,060 --> 00:50:06,982
And then for example, like slot one might refer to Baba.

676
00:50:07,671 --> 00:50:11,758
slot 2 might refer to is as they appear in the level.

677
00:50:11,758 --> 00:50:17,608
I'd say it's a pretty nice system, it works pretty well right now.

678
00:50:17,608 --> 00:50:19,271
But then...

679
00:50:20,106 --> 00:50:23,967
As I've been alluding to, this system has its own problems.

680
00:50:23,967 --> 00:50:30,730
There are a bunch of issues with the system because I've been adding a lot more stuff over time.

681
00:50:30,730 --> 00:50:32,931
The game has become a lot more complicated over time.

682
00:50:32,931 --> 00:50:40,754
And certain new word and rule additions have made parsing everything way more complicated,

683
00:50:40,754 --> 00:50:45,376
even if I have this pretty stable structure.

684
00:50:45,376 --> 00:50:48,097
And here I will go through some examples.

685
00:50:48,097 --> 00:50:49,457
So as the...

686
00:50:49,843 --> 00:50:56,406
rule system became more complicated, the amount of possible word combinations increased,

687
00:50:56,406 --> 00:51:05,710
the complexity increased pretty much exponentially, and some of the words I added were really cool,

688
00:51:05,710 --> 00:51:10,412
but well yeah complicated matters even further, they made it even more difficult to make a

689
00:51:10,412 --> 00:51:15,954
stable nice rule system and right now I don't think a stable nice rule system is even salvageable.

690
00:51:15,954 --> 00:51:17,355
Here are some examples.

691
00:51:18,811 --> 00:51:20,312
First of all, there's the word not.

692
00:51:20,312 --> 00:51:23,634
Not does the same thing as I mentioned

693
00:51:23,634 --> 00:51:26,296
at the beginning of this presentation.

694
00:51:26,296 --> 00:51:32,760
Not turns the kind of meaning of a word to the opposite.

695
00:51:32,760 --> 00:51:35,102
I gave some examples of where not is used

696
00:51:35,102 --> 00:51:37,123
and in its basis, it's pretty simple.

697
00:51:37,123 --> 00:51:40,526
But the rule system needs to be able to parse something

698
00:51:40,526 --> 00:51:43,648
like not baba, not on, not grass, is not you

699
00:51:43,648 --> 00:51:46,169
because not can go into many different places

700
00:51:46,169 --> 00:51:48,311
and the rule system needs to be able to understand.

701
00:51:48,637 --> 00:51:54,000
what it does in all those different places. Also as a kind of a gimmick I wanted to add

702
00:51:54,000 --> 00:52:01,245
multiple negation so not not not baba is you needs to be parsable as well. Then there's

703
00:52:01,245 --> 00:52:07,269
chainable conditionals. So as mentioned here there can be multiple conditionals

704
00:52:07,269 --> 00:52:10,291
in a single sentence and you can do this

705
00:52:11,245 --> 00:52:16,247
for example, by saying Baba on grass and near wall is you.

706
00:52:16,247 --> 00:52:18,989
And technically you can chain those forever.

707
00:52:18,989 --> 00:52:23,971
Baba on grass and near wall and facing Kiki

708
00:52:23,971 --> 00:52:26,033
or something is you.

709
00:52:26,033 --> 00:52:29,514
And I don't think this system works perfectly right now.

710
00:52:29,514 --> 00:52:31,495
I think there are some bugs with it even now.

711
00:52:31,495 --> 00:52:32,876
I need to work on that.

712
00:52:32,876 --> 00:52:33,837
I want to work on that.

713
00:52:33,837 --> 00:52:36,538
It's still a pretty simple system.

714
00:52:36,538 --> 00:52:38,999
It just requires making the parsing logic

715
00:52:38,999 --> 00:52:40,420
a bit more involved.

716
00:52:40,420 --> 00:52:40,720
But.

717
00:52:41,620 --> 00:52:44,382
It's not the worst, but it's still more complexity.

718
00:52:44,382 --> 00:52:47,685
Here comes a spoiler.

719
00:52:47,685 --> 00:52:53,409
I'm sorry I forgot to warn you about this, but in the game eventually you run into letters

720
00:52:53,409 --> 00:52:57,412
that can form words, and these words can be used in sentences.

721
00:52:57,412 --> 00:52:57,973
For example...

722
00:52:58,470 --> 00:53:04,113
B-A-B-A is you is parsed as Baba is you.

723
00:53:04,113 --> 00:53:07,074
W-A-L-L is stop. Well, wall is stop.

724
00:53:07,074 --> 00:53:13,656
Or B-A-B-A-I-S-Y-O-U is Baba is you.

725
00:53:13,656 --> 00:53:17,558
And the letters are probably the single most

726
00:53:17,558 --> 00:53:21,279
complicated and complex system in the whole game because...

727
00:53:22,240 --> 00:53:28,563
They have a lot of corner cases, they have a lot of complex... a lot of, like, kind of very difficult

728
00:53:28,563 --> 00:53:35,967
parsing quirks to them. For example, there's W-A-L-L is stop.

729
00:53:35,967 --> 00:53:41,590
Is this wall is stop or is it all is stop?

730
00:53:41,590 --> 00:53:49,114
Right now, the game needs to be able to understand both of those and add both of those into the rule list.

731
00:53:49,114 --> 00:53:50,695
And it actually does. That one works.

732
00:53:51,597 --> 00:54:03,648
in B-A-B-A-I-S-Y-O-U, the game needs to be able to understand the limits of the words, to detect where the words end and where the next word begins.

733
00:54:03,648 --> 00:54:11,475
If there's an A-I word somewhere in the game, there's a valid object, the game would have to understand that.

734
00:54:12,395 --> 00:54:19,998
There's Baba is you, but there will also be AI here that could form its own rule somewhere.

735
00:54:19,998 --> 00:54:22,679
That becomes very, very, very complex.

736
00:54:22,679 --> 00:54:27,001
Then there are stacked rules.

737
00:54:27,001 --> 00:54:31,323
So you can put two rules on top of each other in some situations.

738
00:54:31,323 --> 00:54:36,445
Basically in the game you just find a way where you can have two blocks on top of each other.

739
00:54:36,445 --> 00:54:40,326
And if those blocks happen to be words, then you have two words on top of each other.

740
00:54:40,807 --> 00:54:48,331
So for example, there's the situation Baba Kiki is you, which needs to form both Baba is you and Kiki is you.

741
00:54:48,331 --> 00:54:57,876
Or you could have Baba Kiki is you move, which should form the rules Baba is you, Baba is move, Kiki is you, Kiki is move.

742
00:54:57,876 --> 00:55:06,100
Basically the game needs to go through all the possible combinations of those words and form all the valid rules.

743
00:55:06,742 --> 00:55:14,786
And this is again extremely complicated, especially when combined with some of these other things, such as the letters of the chained conditionals.

744
00:55:14,786 --> 00:55:20,650
To give an example, here's BABA ON EAST GRASS U EAST MOVE.

745
00:55:20,650 --> 00:55:24,312
I drew a little diagram to show how this...

746
00:55:24,865 --> 00:55:34,552
jumble of words should be interpreted. So here, on is and grass you are on top of each other. So in total there are five

747
00:55:34,552 --> 00:55:34,872
words

748
00:55:34,872 --> 00:55:37,835
seemingly, but two of the words are

749
00:55:37,835 --> 00:55:40,176
duplicate or like multiple words.

750
00:55:40,176 --> 00:55:46,701
So there are three different possibilities for how this could be interpreted and all of those should

751
00:55:47,249 --> 00:55:53,574
be interpreted correctly. The rule system should get three rules out of this instead of just one or

752
00:55:53,574 --> 00:56:03,141
two. So we can have BABA ON GRASS IS MOVE. So BABA ON GRASS IS MOVE. Pretty simple.

753
00:56:03,141 --> 00:56:07,004
Then there's BABA IS, so the second option.

754
00:56:07,768 --> 00:56:13,189
And after this, actually, both grass and you are valid options to come after is.

755
00:56:13,189 --> 00:56:20,531
So there's Baba is grass and Baba is you that should both come out of this mess.

756
00:56:20,531 --> 00:56:27,372
And this, yeah, this gets super complicated. There are totally, like, many situations where it doesn't work right, but

757
00:56:27,372 --> 00:56:35,174
it's a very cool concept. I like that it's in the game, even though it causes me some sleepless nights.

758
00:56:35,174 --> 00:56:36,414
And finally, as a

759
00:56:37,022 --> 00:56:43,507
fairly tame example, there are ways to combine rules so that

760
00:56:43,507 --> 00:56:49,913
two different rules share some words. So for example, there's

761
00:56:49,913 --> 00:56:52,736
I guess this computer made a noise

762
00:56:52,736 --> 00:56:56,639
There's Baba is grass and rock is push

763
00:56:56,639 --> 00:57:01,563
So this should work form the words or the rules Baba is grass and rock

764
00:57:01,981 --> 00:57:08,145
and grass and rock is push. Right now this actually bugs and the game only forms the rules

765
00:57:08,145 --> 00:57:15,750
baba is grass and rock and rock is push because it doesn't realize that grass and should be included

766
00:57:15,750 --> 00:57:21,333
when doing the rock is push check. I'm going to try to fix that but right now it's a problem

767
00:57:21,333 --> 00:57:25,936
and there are some with letters for example there are some similar issues that are way worse.

768
00:57:28,752 --> 00:57:31,735
So those are some of the complications I've run into.

769
00:57:31,735 --> 00:57:36,660
Some of them I've solved, some of them are still to be solved, some of them

770
00:57:36,660 --> 00:57:40,824
are solved partially but create endless amounts of new

771
00:57:40,824 --> 00:57:47,291
work. So for some conclusions from all of this, let's see.

772
00:57:47,291 --> 00:57:48,692
I still have a couple of minutes of time.

773
00:57:49,926 --> 00:57:57,971
The conclusions I've come to when working on this system is that it's futile to attempt to make a perfectly

774
00:57:57,971 --> 00:58:01,173
parsable system or parsing system without

775
00:58:01,173 --> 00:58:08,238
simplifying something. The system as it is is way too complicated to ever make it work perfectly. Maybe someone

776
00:58:08,238 --> 00:58:15,203
dedicated their whole life to doing that or there was like a huge team they might be able to do that, but as it is I

777
00:58:15,203 --> 00:58:17,364
have to admit that I'll either

778
00:58:17,858 --> 00:58:20,659
have to remove some of the more unstable elements or...

779
00:58:20,659 --> 00:58:27,461
...accept that there are going to be some oddities there,

780
00:58:27,461 --> 00:58:29,401
some things that don't work as they intended,

781
00:58:29,401 --> 00:58:31,582
maybe some bugs that become features

782
00:58:31,582 --> 00:58:33,782
or some things that I just acknowledge that,

783
00:58:33,782 --> 00:58:37,123
okay, that doesn't work, no can do.

784
00:58:37,123 --> 00:58:41,824
And at this point, I do realize that,

785
00:58:41,824 --> 00:58:46,645
for me, including words that felt fitting or cool into the game...

786
00:58:47,467 --> 00:58:54,009
took priority over the stability of the system. For example, those letters, they add a lot of

787
00:58:54,009 --> 00:59:00,292
complications into the rule parsing, but it's such a cool thing, it's such a nice exploration

788
00:59:00,292 --> 00:59:04,353
of the themes of Baba is You that I absolutely couldn't leave it out. And there are many other

789
00:59:04,353 --> 00:59:11,076
examples of that, where I kind of took a larger bite that I can chew because I felt that I

790
00:59:11,076 --> 00:59:12,957
needed to have something in the game.

791
00:59:13,795 --> 00:59:19,566
Yeah, I've even mentioned to myself there like especially letters are like that

792
00:59:19,566 --> 00:59:19,686
um

793
00:59:19,686 --> 00:59:22,692
And i'm kind of happy with that in some situations

794
00:59:22,692 --> 00:59:23,614
because

795
00:59:23,614 --> 00:59:25,818
in the bass game

796
00:59:26,586 --> 00:59:33,430
If I knew that there was some problem with a certain rule or certain parsing thing or whatever,

797
00:59:33,430 --> 00:59:37,733
I could design levels so that I don't showcase those.

798
00:59:37,733 --> 00:59:41,416
I try to generally make all the systems as dynamic as possible.

799
00:59:41,416 --> 00:59:45,438
I didn't want to make some rule that only works in one specific situation

800
00:59:45,438 --> 00:59:49,000
and then I just try to hide from the player that it doesn't work at all.

801
00:59:49,000 --> 00:59:50,381
There's some specific...

802
00:59:51,392 --> 00:59:56,837
Sorry, some specific examples of that as well, but I mostly try to make everything dynamic.

803
00:59:56,837 --> 01:00:08,206
But even still, if there are situations where some rule might be kind of arbitrarily not working,

804
01:00:08,206 --> 01:00:10,628
I still have the option of...

805
01:00:11,348 --> 01:00:17,432
not giving the player the tools to break the rules in that way, to kind of see the weaknesses of the system,

806
01:00:17,432 --> 01:00:23,676
which was kind towards the players, I feel, and also saved me some extra work.

807
01:00:23,676 --> 01:00:26,898
But we are releasing a level editor for BaBaSU

808
01:00:26,898 --> 01:00:30,821
later this year, at some point. I'm working on it right now.

809
01:00:30,821 --> 01:00:35,484
And the problem with the level editor, especially because it has level sharing, online level sharing,

810
01:00:35,744 --> 01:00:43,108
there are going to be people trying all kinds of wild stuff, and even if I spend all the time from now on to the release

811
01:00:43,108 --> 01:00:54,134
fixing things, all the quirks I know, people will inevitably find something new that doesn't work, or that is funky, or...

812
01:00:54,134 --> 01:01:00,078
Yeah, so eventually I'll just have to admit that, okay, some things are features, not bugs,

813
01:01:00,078 --> 01:01:03,500
and people may use them in their levels, or I'll have to say that...

814
01:01:03,958 --> 01:01:12,606
Please don't do this. I know it doesn't work, but I cannot help it anymore, or I don't have the energy, willpower, or something to fix it.

815
01:01:12,606 --> 01:01:14,668
It's a shame, but it happens.

816
01:01:14,668 --> 01:01:18,031
And then finally, as the final point, a quick thing.

817
01:01:18,031 --> 01:01:28,301
There were some words that I wanted to add throughout the development, but I didn't because I kind of felt that, okay, this is maybe too much, too much work, more work than it's worth.

818
01:01:29,034 --> 01:01:32,875
And one specific example is the if word.

819
01:01:32,875 --> 01:01:40,556
It would be super cool to be able to say something like Baba is you if Rock is Push to create like if clauses

820
01:01:40,556 --> 01:01:44,237
because it could increase the kind of logic

821
01:01:44,237 --> 01:01:49,058
nuance and elegance of the system a lot. I've seen people make stuff like

822
01:01:49,058 --> 01:01:52,559
Conway's Game of Life in Baba is you and I'm super happy about the stuff like that

823
01:01:52,559 --> 01:01:58,020
and I want to support those kind of endeavors and I think the if word would have done that.

824
01:01:58,300 --> 01:02:02,383
But at the same time, I feel that if I added the if word,

825
01:02:02,383 --> 01:02:06,046
I would have to make the following sentence actually parse.

826
01:02:06,046 --> 01:02:10,910
Lonely Baba near grass is you, if rock is on flag and facing right.

827
01:02:10,910 --> 01:02:15,153
And as you can see from my onomatopoeia in there,

828
01:02:15,153 --> 01:02:18,035
that would be terrible.

829
01:02:18,035 --> 01:02:22,719
I wouldn't want to be in a situation where I would have to make sure

830
01:02:22,719 --> 01:02:27,462
that all those possible combinations of words actually work in the game system.

831
01:02:27,462 --> 01:02:27,522
So.

832
01:02:28,600 --> 01:02:34,982
if stays out for now. I have some ideas how to implement it in a more simplistic way, but

833
01:02:34,982 --> 01:02:40,144
as it is, it's kind of out of consideration. I have to fix other things first.

834
01:02:40,144 --> 01:02:44,646
All right, so thank you very much for listening to my babbling.

835
01:02:45,087 --> 01:02:53,914
I hope you enjoyed, I hope maybe you learned something from this, maybe you didn't learn anything but it was still intriguing.

836
01:02:53,914 --> 01:02:59,798
If you watched it until the end, I hope you didn't have a super terrible time, even if you didn't enjoy what you were watching.

837
01:02:59,798 --> 01:03:08,125
I'm sorry if that happened, but to be honest, it kinda isn't my fault if you watched the whole thing through, maybe.

838
01:03:08,125 --> 01:03:13,269
Thanks a lot. Oh no, I'm about three minutes over time, but...

839
01:03:13,812 --> 01:03:19,376
Thanks a lot to the GDC staff for organizing this virtual talk thing.

840
01:03:19,376 --> 01:03:24,020
And yeah, I think that's it.

841
01:03:24,020 --> 01:03:27,102
Thanks for watching and take care.

842
01:03:27,102 --> 01:03:35,649
Remember to wash your hands and watch other presentations also from this virtual GDC presentation.

843
01:03:35,649 --> 01:03:37,630
Rigamarole. Thank you.

