1
00:00:05,875 --> 00:00:07,156
So my name is Ka-Chen.

2
00:00:07,636 --> 00:00:09,637
I'm a technique architect at Ubisoft.

3
00:00:10,778 --> 00:00:12,719
My job is to go to different projects

4
00:00:13,359 --> 00:00:15,780
and help them to build new technologies

5
00:00:16,400 --> 00:00:17,301
or improve the games.

6
00:00:18,661 --> 00:00:21,903
Last year, I had the opportunity to work on Far Cry 4

7
00:00:22,903 --> 00:00:25,745
and developed a technique called adaptive virtual textures.

8
00:00:27,406 --> 00:00:30,127
With this technique, we are able to render thousands

9
00:00:30,167 --> 00:00:33,308
of decals on terrain surfaces in less than one millisecond.

10
00:00:34,756 --> 00:00:37,658
and achieves 10 pixels per centimeter resolution.

11
00:00:39,219 --> 00:00:42,942
It gives our artists the freedom to place as many details

12
00:00:43,042 --> 00:00:47,325
as they want and achieves great result in FabFly 4.

13
00:00:56,691 --> 00:00:59,754
So the content of the talk is divided into five parts.

14
00:01:00,294 --> 00:01:03,996
First, I will give an overview of virtual textures technique.

15
00:01:05,344 --> 00:01:07,985
Then I'll talk about Far Cry 4, terrain rendering.

16
00:01:09,226 --> 00:01:13,267
Our first approach, implementing a procedural virtual textures.

17
00:01:14,368 --> 00:01:16,208
The problem with that, with Far Cry 4,

18
00:01:16,589 --> 00:01:19,590
and why we would like to develop adaptive virtual textures.

19
00:01:21,090 --> 00:01:23,852
After that, I'll talk about what this technique is,

20
00:01:24,692 --> 00:01:28,153
how it works, and why we call it adaptive virtual textures.

21
00:01:29,774 --> 00:01:31,455
Then I'll talk about the challenges

22
00:01:31,535 --> 00:01:33,355
we faced during the implementation

23
00:01:33,435 --> 00:01:34,356
of the virtual textures.

24
00:01:35,648 --> 00:01:36,549
and how we solve them.

25
00:01:37,990 --> 00:01:40,312
At last, I will show some screenshots from the game,

26
00:01:41,272 --> 00:01:44,574
talk about the performance, memory, and give a summary.

27
00:01:49,578 --> 00:01:51,519
Virtual textures is not a new technique.

28
00:01:52,139 --> 00:01:56,062
It was first mentioned by John Carmack as megatextures

29
00:01:56,562 --> 00:01:57,543
from ID software.

30
00:01:59,764 --> 00:02:03,046
Megatextures emulates a very large map of textures.

31
00:02:04,218 --> 00:02:06,439
This texture is too large to fit into the memory,

32
00:02:06,899 --> 00:02:09,981
so it is divided into multiple equal-sized pages.

33
00:02:11,141 --> 00:02:17,605
For example, the page size could be 256 by 256, or 128 by 128.

34
00:02:20,827 --> 00:02:23,528
We allocate a smaller size physical texture cache

35
00:02:23,988 --> 00:02:27,610
in the video memory to cache the resident virtual texture pages.

36
00:02:29,227 --> 00:02:31,289
We also use an indirection texture

37
00:02:31,649 --> 00:02:34,672
to map the relationship between the virtual texture page

38
00:02:35,252 --> 00:02:36,453
and the physical texture page.

39
00:02:38,736 --> 00:02:40,777
The content of this indirection texture

40
00:02:41,138 --> 00:02:44,761
is used to translate the virtual texture UV address

41
00:02:45,222 --> 00:02:46,703
into physical texture address.

42
00:02:50,687 --> 00:02:52,789
The virtual textures are used in some games.

43
00:02:53,109 --> 00:02:54,791
For example, mega textures.

44
00:02:55,716 --> 00:02:59,419
in read and procedural virtual textures in Battlefield 3.

45
00:03:03,102 --> 00:03:07,165
Mega Textures pre-bakes all the textures used by the game

46
00:03:07,365 --> 00:03:09,087
into a very large virtual texture,

47
00:03:09,887 --> 00:03:11,108
and it is stored on the disk.

48
00:03:12,489 --> 00:03:13,850
The rendering engine then decides

49
00:03:13,991 --> 00:03:16,332
which page are needed, depending on where

50
00:03:16,352 --> 00:03:17,533
the camera is looking at.

51
00:03:17,553 --> 00:03:21,457
It then loads the required page from the disk

52
00:03:21,897 --> 00:03:23,738
and updates the page table.

53
00:03:25,190 --> 00:03:26,991
This way, the final pixel shaders

54
00:03:27,231 --> 00:03:29,152
know the location of each virtual page

55
00:03:29,472 --> 00:03:31,373
inside the physical texture cache.

56
00:03:34,854 --> 00:03:37,995
On GDC 2012, DICE presented a new technique

57
00:03:38,315 --> 00:03:40,096
called procedural virtual textures.

58
00:03:41,937 --> 00:03:44,778
It is a bit different than the mega textures we talked about,

59
00:03:45,818 --> 00:03:48,659
because it neither bakes the textures

60
00:03:48,819 --> 00:03:51,480
into the virtual texture in the tool,

61
00:03:52,080 --> 00:03:53,621
nor stream them from the hard drive.

62
00:03:54,904 --> 00:03:57,806
Instead, it displays the terrain rendering

63
00:03:57,926 --> 00:03:59,748
into virtual textures at runtime,

64
00:04:00,468 --> 00:04:03,150
and uses this as a cache for future frames rendering.

65
00:04:04,871 --> 00:04:07,233
By doing that, it can save the expensive rendering

66
00:04:07,273 --> 00:04:08,994
cost of terrain material blending

67
00:04:09,815 --> 00:04:11,516
once they are cached in the physical texture

68
00:04:11,957 --> 00:04:14,498
and improve the terrain rendering performance.

69
00:04:16,220 --> 00:04:18,101
Since the missing virtual texture page

70
00:04:18,261 --> 00:04:21,043
are rendered by a graphics engine into virtual texture,

71
00:04:21,724 --> 00:04:22,184
UV space.

72
00:04:23,386 --> 00:04:25,147
The prime of the physical texture cache

73
00:04:25,327 --> 00:04:28,608
is much faster comparing to loading them from the disk.

74
00:04:29,768 --> 00:04:33,109
So there is much less visual popping up

75
00:04:33,329 --> 00:04:35,490
comparing to standard virtual textures.

76
00:04:37,391 --> 00:04:39,672
Our adaptive virtual textures is actually

77
00:04:39,852 --> 00:04:41,112
based on this technique.

78
00:04:44,493 --> 00:04:47,174
Now I will explain the basic Factory 4 terrain rendering

79
00:04:47,214 --> 00:04:49,475
pipeline and our visual target.

80
00:04:50,608 --> 00:04:54,269
I will also explain our first approach using procedural virtual textures.

81
00:04:57,270 --> 00:05:03,291
Far Cry 4 is a cross-platform game we developed on both current generation and next generation.

82
00:05:04,811 --> 00:05:08,152
It has a very large world, as 10 by 10 kilometer size.

83
00:05:10,132 --> 00:05:15,673
The terrain is divided into two parts, far distance terrain and near distance terrain.

84
00:05:17,602 --> 00:05:21,885
We render far distant terrain by offline baked geometry and textures.

85
00:05:22,666 --> 00:05:24,347
We call this Vista terrain.

86
00:05:26,229 --> 00:05:31,032
The near distant terrain geometry is generated from a high-res height map.

87
00:05:32,594 --> 00:05:37,377
The rendering is done by blending four detailed material layers using a mask texture.

88
00:05:38,938 --> 00:05:45,563
We also support float splines and decals to add unique details on terrain surfaces.

89
00:05:47,140 --> 00:05:50,482
Our visual target is as high as 10 pixels per centimeter,

90
00:05:51,182 --> 00:05:54,464
so that the terrain surfaces are displayed with fine details

91
00:05:55,124 --> 00:05:56,385
when the camera is very close.

92
00:05:58,546 --> 00:05:59,987
It is worth mentioning that we would

93
00:06:00,027 --> 00:06:03,608
like to apply our virtual textures on near distance

94
00:06:03,669 --> 00:06:04,269
terrain only.

95
00:06:07,330 --> 00:06:09,852
To distinguish the next generation platforms

96
00:06:10,192 --> 00:06:12,913
from the current generation, we would

97
00:06:12,953 --> 00:06:15,015
like to add a massive number of details.

98
00:06:16,057 --> 00:06:19,379
which is procedurally generated into the terrain

99
00:06:19,579 --> 00:06:20,979
to enrich the environment.

100
00:06:22,480 --> 00:06:25,702
I'll show a difference between without

101
00:06:25,882 --> 00:06:28,363
and with procedural generated decals.

102
00:06:28,783 --> 00:06:32,385
This is without, and this is with.

103
00:06:35,666 --> 00:06:37,387
Another example showing the difference,

104
00:06:37,707 --> 00:06:38,688
and this is without.

105
00:06:41,329 --> 00:06:43,310
This is with the procedural decals.

106
00:06:44,329 --> 00:06:50,171
We would like to achieve a unique and diversified terrain looking by adding decals with leaves,

107
00:06:50,411 --> 00:06:55,013
pebbles, sands, cracks, and trees, for example.

108
00:06:56,594 --> 00:07:02,456
A simple deferred decals rendering would be too expensive to render decals in this quantity

109
00:07:02,576 --> 00:07:03,136
and quality.

110
00:07:04,196 --> 00:07:09,938
So, we are thinking about baking these decals into procedural virtual textures as an optimization.

111
00:07:14,066 --> 00:07:17,507
Our first approach is implementing procedural virtual textures.

112
00:07:18,767 --> 00:07:24,668
We allocate a 512K by 512K virtual texture, and the page size is 256 by 256.

113
00:07:26,709 --> 00:07:31,169
We use an indirection texture to map from the virtual texture to physical texture.

114
00:07:32,990 --> 00:07:33,970
The size is 2K.

115
00:07:36,071 --> 00:07:40,631
Our physical texture size is configurable, and we set it as 9K by 9K.

116
00:07:42,137 --> 00:07:42,917
We have three of them.

117
00:07:43,377 --> 00:07:46,278
They are Aerobito, NormalMap, and Specular.

118
00:07:49,680 --> 00:07:52,981
The information for required virtual pages

119
00:07:53,101 --> 00:07:58,043
are computed during the GBuffer rendering pass.

120
00:07:59,144 --> 00:08:00,665
For every pixel on the screen, we

121
00:08:00,765 --> 00:08:04,026
output the page index and the mipmap level

122
00:08:04,626 --> 00:08:07,287
of the virtual texture into a full screen render target.

123
00:08:08,908 --> 00:08:10,989
We call this Page ID Buffer.

124
00:08:12,545 --> 00:08:15,366
We will explain the format for this buffer later in the talk.

125
00:08:17,027 --> 00:08:19,528
We analyze this page ID buffer on CPU

126
00:08:20,689 --> 00:08:24,470
to see which pages are needed at which bitmap level.

127
00:08:26,791 --> 00:08:28,712
We then allocate physical texture pages

128
00:08:28,932 --> 00:08:32,454
and render both terrain material and the decals into this page.

129
00:08:33,994 --> 00:08:36,235
Finally, we update the indirection texture

130
00:08:36,355 --> 00:08:38,656
to be able to translate from the virtual address

131
00:08:38,836 --> 00:08:39,696
into physical address.

132
00:08:41,810 --> 00:08:45,751
These pages are cached in our physical texture caches,

133
00:08:46,291 --> 00:08:48,872
according to our least recent used algorithm.

134
00:08:49,992 --> 00:08:52,133
Once in the cache, the terrain shader

135
00:08:52,253 --> 00:08:54,194
could just fetch from the virtual textures,

136
00:08:55,014 --> 00:08:57,395
and we completely remove the rendering

137
00:08:57,455 --> 00:09:00,456
cost of terrain materials and decals in the future.

138
00:09:04,537 --> 00:09:06,257
And with conventional virtual textures,

139
00:09:06,798 --> 00:09:10,079
we use an indirection texture to map from the virtual UV

140
00:09:10,439 --> 00:09:11,239
into physical UV.

141
00:09:12,762 --> 00:09:14,883
Each entry of this in-direction texture

142
00:09:15,864 --> 00:09:18,766
represents a mapping from the virtual address

143
00:09:18,966 --> 00:09:20,007
into physical address.

144
00:09:21,748 --> 00:09:24,530
The content of this texture is used

145
00:09:24,550 --> 00:09:27,512
to generate the final physical memory location

146
00:09:27,612 --> 00:09:28,913
for the virtual texture page.

147
00:09:31,795 --> 00:09:35,157
The format of this texture is 32-inch bit

148
00:09:35,437 --> 00:09:38,299
with the first 16-bit representing

149
00:09:38,399 --> 00:09:41,641
the final physical texture page offset.

150
00:09:42,887 --> 00:09:45,929
and eight is representing the MIPMAP level of this page.

151
00:09:46,749 --> 00:09:48,431
The last bit is for debug only.

152
00:09:55,676 --> 00:09:58,458
So procedural virtual textures works quite well

153
00:09:58,658 --> 00:10:01,640
to cache the rendering result of the terrain and the decals

154
00:10:02,241 --> 00:10:03,782
as an optimization approach.

155
00:10:05,203 --> 00:10:07,264
But there's a big problem for the Far Cry 4.

156
00:10:08,445 --> 00:10:10,066
Since the standard virtual textures

157
00:10:11,305 --> 00:10:14,567
applies the virtual texture onto the whole world uniformly.

158
00:10:15,768 --> 00:10:20,311
With a 512K by 512K virtual texture on a 10 by 10 kilometer

159
00:10:20,391 --> 00:10:26,935
world, this means the texture resolution is only 0.5 texels

160
00:10:27,015 --> 00:10:27,675
per centimeter.

161
00:10:29,236 --> 00:10:30,117
This is too low.

162
00:10:31,558 --> 00:10:34,039
To achieve a 10 texels per centimeter resolution,

163
00:10:34,960 --> 00:10:38,522
it would require 10 million by 10 million sized

164
00:10:38,822 --> 00:10:39,483
virtual textures.

165
00:10:41,010 --> 00:10:43,871
This is definitely over the limit of the next generation

166
00:10:43,931 --> 00:10:44,391
platform.

167
00:10:47,131 --> 00:10:48,712
So we need to find a better solution.

168
00:11:00,654 --> 00:11:03,414
So our goal is to develop a procedural virtual textures

169
00:11:03,474 --> 00:11:07,495
technique in a larger world and achieve a high texture

170
00:11:07,515 --> 00:11:09,735
resolution of 10 texels per centimeter.

171
00:11:11,531 --> 00:11:14,492
This seems impossible when we're applying the virtual textures

172
00:11:14,752 --> 00:11:15,893
uniformly onto the wood.

173
00:11:17,414 --> 00:11:19,755
But one thing in our favor is that we only

174
00:11:19,835 --> 00:11:22,476
need that 10 texels per centimeter resolution

175
00:11:23,456 --> 00:11:25,697
when the camera is very close to the terrain.

176
00:11:27,158 --> 00:11:29,099
For terrain surfaces that are a bit further away,

177
00:11:29,799 --> 00:11:31,800
a 5 texels per centimeter might be enough.

178
00:11:33,301 --> 00:11:35,902
And it would require even less texture resolution

179
00:11:36,222 --> 00:11:38,763
when the terrain surfaces are very far away from the camera.

180
00:11:40,603 --> 00:11:43,244
So the key is to find a way to apply the virtual texture

181
00:11:43,525 --> 00:11:46,626
non-uniformly onto the world based on the distance

182
00:11:46,786 --> 00:11:47,446
from the camera.

183
00:11:49,687 --> 00:11:52,588
This is how our adaptive virtual textures come into play.

184
00:11:57,250 --> 00:11:59,170
Now let's talk about adaptive virtual textures.

185
00:12:00,511 --> 00:12:02,552
It is based on procedural virtual textures.

186
00:12:03,772 --> 00:12:07,173
And it improves it by increasing the texture resolution.

187
00:12:09,521 --> 00:12:12,183
We divided our world into multiple sectors.

188
00:12:12,563 --> 00:12:15,986
Each sector is 64 by 64 meter size.

189
00:12:18,528 --> 00:12:19,889
For all near distance sectors,

190
00:12:20,190 --> 00:12:22,792
we will allocate a virtual image for each of them

191
00:12:23,292 --> 00:12:24,673
inside the virtual texture.

192
00:12:26,254 --> 00:12:28,696
A virtual image is simply a square space

193
00:12:28,796 --> 00:12:30,258
inside the virtual texture.

194
00:12:33,060 --> 00:12:35,802
And the size of this image increases.

195
00:12:37,317 --> 00:12:40,219
for the sectors nearer the camera and vice versa.

196
00:12:41,960 --> 00:12:44,842
This is why we call it adaptive virtual textures.

197
00:12:45,162 --> 00:12:47,544
We adapt the resolution of the virtual texture

198
00:12:48,404 --> 00:12:51,286
based on the distance from the camera to the sector.

199
00:12:53,928 --> 00:12:57,450
Nearest sectors are located at full resolution

200
00:12:57,550 --> 00:12:59,171
of 10 pixels per centimeter.

201
00:12:59,651 --> 00:13:02,213
So we allocate 64 by 64K virtual image.

202
00:13:05,870 --> 00:13:12,154
Further sectors allocate less, like 32K by 32K, or 16K by 16K.

203
00:13:14,136 --> 00:13:16,698
The minimum size is 1K by 1K.

204
00:13:20,180 --> 00:13:23,603
We display our allocation of the virtual image

205
00:13:23,743 --> 00:13:28,066
inside the virtual texture as an overlay on the game screen,

206
00:13:28,546 --> 00:13:30,147
marked as the red square.

207
00:13:32,009 --> 00:13:34,891
Inside the virtual textures, the colored square.

208
00:13:37,388 --> 00:13:41,691
here represent the allocated virtual images

209
00:13:41,791 --> 00:13:43,192
for all needed sensors sectors.

210
00:13:47,115 --> 00:13:51,018
Every sector saves its virtual image, UV offset, and size.

211
00:13:51,499 --> 00:13:54,281
And this information will be passed into TerrainShader

212
00:13:54,901 --> 00:13:57,723
to determine the page ID and the mipmap level

213
00:13:57,984 --> 00:13:59,325
for every pixel on the screen.

214
00:14:03,386 --> 00:14:07,269
Now let's have a deeper look at the allocation of the virtual images.

215
00:14:09,711 --> 00:14:18,037
First, we find two sectors nearest to the camera and we allocate two 64x64 sized virtual images.

216
00:14:20,018 --> 00:14:25,342
Then we found six sectors further away from the camera and we allocate six 32kx32k virtual images.

217
00:14:30,157 --> 00:14:32,779
For multiple sectors that are even further away,

218
00:14:32,859 --> 00:14:36,122
we allocate 16K by 16K virtual images.

219
00:14:37,423 --> 00:14:40,446
We continue this process until all the needed sectors

220
00:14:40,646 --> 00:14:43,048
are allocated inside our virtual texture.

221
00:14:48,212 --> 00:14:49,673
At runtime, during each frame,

222
00:14:49,714 --> 00:14:52,996
we calculate a target virtual image size for every sector

223
00:14:53,116 --> 00:14:55,138
based on its distance from the camera.

224
00:14:56,357 --> 00:14:59,139
If this size is different than the current size of the sector,

225
00:14:59,339 --> 00:15:02,642
we will allocate a new virtual image as the target size

226
00:15:02,863 --> 00:15:04,004
and remove the older one.

227
00:15:07,747 --> 00:15:09,749
Now I will play a video demonstrating

228
00:15:10,029 --> 00:15:12,551
the adjustment of the virtual image for all the sectors

229
00:15:13,732 --> 00:15:14,293
during the game.

230
00:15:20,558 --> 00:15:23,101
You will notice that when a player moves forward,

231
00:15:23,937 --> 00:15:27,342
some sectors are becoming closer or further to the camera

232
00:15:28,745 --> 00:15:31,710
so that their virtual images are adjusted dynamically

233
00:15:31,890 --> 00:15:35,015
by allocating a new one and remove the old one.

234
00:15:57,039 --> 00:16:01,261
Let's look at some place here.

235
00:16:04,742 --> 00:16:06,063
Here you will notice that there's

236
00:16:06,103 --> 00:16:10,204
like a blue virtual image is allocated with the bigger size

237
00:16:10,324 --> 00:16:12,725
when this sector is closer to the camera.

238
00:16:12,906 --> 00:16:15,427
Then later on, it is removed from the virtual texture

239
00:16:15,547 --> 00:16:18,148
because this sector is behind the camera

240
00:16:18,208 --> 00:16:20,028
and it moves further away from the camera.

241
00:16:25,099 --> 00:16:30,863
These two pictures show the upscaling of the virtual image when the camera moves closer to a sector.

242
00:16:33,205 --> 00:16:40,310
The virtual image size is increased from 32K to 64K to provide higher display resolution.

243
00:16:43,453 --> 00:16:49,177
And these two pictures show the downscaling of the virtual image when the camera is further away from the sector.

244
00:16:49,787 --> 00:16:57,373
the sector. The size is decreased from 64K to 32K, as higher resolution is not necessary.

245
00:17:02,657 --> 00:17:08,381
Now let's look at what happens when we upscale a virtual image from 32K to 64K.

246
00:17:10,142 --> 00:17:14,225
Our adaptive virtual textures need to be updated to reflect the changes

247
00:17:15,406 --> 00:17:18,328
of the virtual image and make sure the rendering is correct.

248
00:17:20,105 --> 00:17:23,166
The naive way would be render all the visible pages

249
00:17:23,406 --> 00:17:27,127
inside the new virtual image from scratch

250
00:17:27,387 --> 00:17:30,668
and update the direction texture entries for these pages.

251
00:17:32,688 --> 00:17:34,328
But this would be too slow.

252
00:17:36,729 --> 00:17:39,850
In fact, the rendering result of the terrain material

253
00:17:39,890 --> 00:17:42,770
blending with additional decals is already

254
00:17:42,850 --> 00:17:44,471
cached in our physical texture.

255
00:17:46,191 --> 00:17:48,012
We don't want to render them all over again.

256
00:17:50,332 --> 00:17:54,194
We could just shift them around by updating our in-direction

257
00:17:54,234 --> 00:17:56,596
capture entries and reuse the content.

258
00:18:01,239 --> 00:18:05,561
Since we are scaling the image from 32K to 64K,

259
00:18:06,702 --> 00:18:09,884
we realized that the MIP map in the old image

260
00:18:10,364 --> 00:18:13,766
are exactly the same as the MIP map when

261
00:18:14,447 --> 00:18:15,868
MIP lower in the new image.

262
00:18:17,267 --> 00:18:22,633
So we can accomplish most what we need to do by remapping the virtual texture so that

263
00:18:23,193 --> 00:18:26,877
the old MIPS from 0 to 9 becomes the new MIPS from 1 to 10.

264
00:18:28,779 --> 00:18:36,087
The 32K by 32K virtual image contains 16,000 pages, so we use a compute shader to rewrite

265
00:18:36,768 --> 00:18:38,089
the indirection texture.

266
00:18:39,596 --> 00:18:43,478
Note that the indirection texture contains the MIP level,

267
00:18:44,018 --> 00:18:46,639
so the modification needs to be a little bit more complex

268
00:18:47,179 --> 00:18:50,480
than the simple copy of the indirection entry.

269
00:18:57,583 --> 00:18:59,284
We now demonstrate how to update

270
00:18:59,524 --> 00:19:01,785
the indirection texture entries

271
00:19:01,845 --> 00:19:04,866
to reuse the MIP0 of the old image

272
00:19:04,986 --> 00:19:06,547
for MIP1 of the new image.

273
00:19:08,188 --> 00:19:08,608
For example.

274
00:19:10,505 --> 00:19:18,471
We mark the MIP0 old virtual image as red square inside the virtual texture and its

275
00:19:18,611 --> 00:19:22,174
related space in indirection texture.

276
00:19:23,234 --> 00:19:31,981
We also mark the new virtual image MIP1 inside the virtual texture and the indirection texture

277
00:19:32,261 --> 00:19:33,022
as yellow square.

278
00:19:34,343 --> 00:19:40,087
What we need to do is to remap the virtual texture so that we use the content.

279
00:19:41,544 --> 00:19:46,808
of the red square in yellow square, to yellow square.

280
00:19:47,889 --> 00:19:51,311
So let's look at the specific in direction texture entries,

281
00:19:52,612 --> 00:19:55,615
pointing to a page inside our physical texture

282
00:19:56,455 --> 00:19:58,197
as offset 3, 2, and the MIP 0.

283
00:19:59,598 --> 00:20:03,160
To reuse this content, we simply copy the page offset

284
00:20:03,401 --> 00:20:05,963
into a new place and shift down the MIP by 1.

285
00:20:07,684 --> 00:20:10,166
We do this for all the pages inside the MIP 1

286
00:20:10,286 --> 00:20:11,246
of the new virtual image.

287
00:20:16,162 --> 00:20:19,825
For the pages in the new image from MIP2 to MIP10,

288
00:20:20,006 --> 00:20:21,787
the updates are very similar as what

289
00:20:21,887 --> 00:20:23,749
we explained for the MIP1.

290
00:20:26,231 --> 00:20:30,995
So now we have updated all the direction texture entries

291
00:20:31,215 --> 00:20:34,218
for MIP1 to MIP10 in our new virtual image.

292
00:20:35,359 --> 00:20:36,960
Then what about the MIP0 pages?

293
00:20:38,281 --> 00:20:41,124
This page don't exist in the old virtual image

294
00:20:41,444 --> 00:20:43,386
because they have higher texture resolution.

295
00:20:45,747 --> 00:20:48,188
These pages need to be rendered in the next frame.

296
00:20:49,008 --> 00:20:51,289
But in this frame, we cannot leave it like that.

297
00:20:52,909 --> 00:20:54,730
Otherwise, there will be some random color

298
00:20:54,770 --> 00:20:58,111
displayed on the screen, because these pages are not rendered

299
00:20:58,231 --> 00:21:00,071
yet into our virtual textures.

300
00:21:04,072 --> 00:21:07,293
By the nature of the MIP map, we know that four MIP0 pages

301
00:21:07,413 --> 00:21:09,274
correspond to one MIP1 page.

302
00:21:10,434 --> 00:21:14,555
So we will temporarily map them to corresponding lower page.

303
00:21:15,204 --> 00:21:17,044
to prevent visual popping up.

304
00:21:19,206 --> 00:21:23,008
They will be correctly updated when the pages are

305
00:21:23,048 --> 00:21:24,328
rendered in the next frame.

306
00:21:25,709 --> 00:21:28,410
As a result, the terrain surface will look a bit blurred

307
00:21:28,470 --> 00:21:32,312
in this frame, but in the next frame, it will become sharp.

308
00:21:32,993 --> 00:21:34,834
This happens very quickly during the frame,

309
00:21:34,914 --> 00:21:36,655
so it is generally not noticeable.

310
00:21:40,237 --> 00:21:42,358
Here we show how we duplicate the image.

311
00:21:43,702 --> 00:21:45,903
in direction entry to do a remapping.

312
00:21:48,324 --> 00:21:53,805
We simply duplicate MIP1 in direction entry

313
00:21:53,926 --> 00:21:56,986
into four corresponding MIP0 entry

314
00:21:57,847 --> 00:21:59,387
to remap the virtual texture.

315
00:22:00,848 --> 00:22:02,968
We don't shift down the MIP level in this case.

316
00:22:04,829 --> 00:22:08,450
And we will do this for all the pages inside the MIP0.

317
00:22:11,030 --> 00:22:14,472
You notice that we set the MIP map level as one

318
00:22:14,752 --> 00:22:18,213
in the in-direction texture entry instead of zero.

319
00:22:19,213 --> 00:22:21,134
This would tell the rendering of terrain

320
00:22:21,194 --> 00:22:23,175
to display a lower MIP level instead.

321
00:22:25,856 --> 00:22:28,037
The pixel shader that handles the terrain rendering

322
00:22:28,197 --> 00:22:30,078
uses the in-direction texture entry

323
00:22:30,198 --> 00:22:33,499
to calculate the final physical texture UV address.

324
00:22:34,579 --> 00:22:35,179
It will shift.

325
00:22:36,025 --> 00:22:39,828
It will scale the UV coordinate by shifted MIP level

326
00:22:39,968 --> 00:22:42,250
and display a lower MIP level result.

327
00:22:44,791 --> 00:22:46,833
I provided the code snippet for your reference.

328
00:22:49,955 --> 00:22:52,297
Now let's look at downscaling a virtual image

329
00:22:52,597 --> 00:22:54,758
from 64K to 32K.

330
00:22:56,640 --> 00:22:58,921
The process is actually the reverse

331
00:22:58,941 --> 00:23:00,803
of upscaling a virtual image.

332
00:23:01,283 --> 00:23:03,965
Again, we update the corresponding

333
00:23:04,045 --> 00:23:05,266
in-direction texture entries.

334
00:23:06,150 --> 00:23:08,131
to reuse the content of the old image.

335
00:23:15,114 --> 00:23:19,656
In this case, the MIP1 to MIP10 from the old image

336
00:23:19,896 --> 00:23:22,918
is the same as the MIP0 to MIP9 in the new virtual image.

337
00:23:24,818 --> 00:23:28,200
So we use a computer shader to rewrite our in-direction

338
00:23:28,240 --> 00:23:28,840
texture entries.

339
00:23:32,225 --> 00:23:37,610
Note that the MIPS 10 pages don't exist in the old virtual image, so we cannot remap from there.

340
00:23:38,671 --> 00:23:47,799
But in fact, that MIPS that are smaller than 64 by 64 shouldn't be utilized by our virtual texture system,

341
00:23:48,800 --> 00:23:55,525
because this page are very far away from the camera, and it is handled by a different rendering system,

342
00:23:56,886 --> 00:23:59,929
which we explained before as far distance terrain rendering.

343
00:24:01,723 --> 00:24:04,904
So in reality, we just ignore these MIPS

344
00:24:05,144 --> 00:24:06,665
and use a higher MIP instead.

345
00:24:17,310 --> 00:24:19,311
Now I will explain some challenges

346
00:24:19,371 --> 00:24:22,693
we faced during developing virtual textures

347
00:24:22,773 --> 00:24:23,673
and how we solved them.

348
00:24:27,670 --> 00:24:30,092
The first challenge is to reduce the memory footprint

349
00:24:30,272 --> 00:24:33,293
when we are outputting the virtual texture page ID

350
00:24:34,214 --> 00:24:36,115
during the gbuffer rendering pass.

351
00:24:37,836 --> 00:24:39,817
Our page ID buffer is 32 bits.

352
00:24:40,718 --> 00:24:44,740
The first two bits represent the page ID,

353
00:24:46,281 --> 00:24:49,182
and four bits for the MIP level, and four bits

354
00:24:49,262 --> 00:24:50,823
for the virtual image size.

355
00:24:53,104 --> 00:24:56,606
We need to keep the data minimum to reduce the memory

356
00:24:56,626 --> 00:24:56,866
footprint.

357
00:24:57,569 --> 00:24:59,690
footprint and bandwidth.

358
00:25:01,871 --> 00:25:06,093
We use 1 by 1 eighth read-write buffer instead of a full

359
00:25:06,113 --> 00:25:12,596
screen render target so that the actual memory is only 1

360
00:25:12,876 --> 00:25:15,678
64th of the full render target.

361
00:25:17,319 --> 00:25:20,460
We have to set early depth stencil attribute in the

362
00:25:20,500 --> 00:25:24,202
shader so that any pixels filling the depth test won't

363
00:25:24,262 --> 00:25:26,003
be outputted into the page ID buffer.

364
00:25:28,356 --> 00:25:31,478
This is how our game scene and page ID buffer look like.

365
00:25:34,940 --> 00:25:37,502
Caching of the virtual textures can take a long time

366
00:25:37,762 --> 00:25:41,105
when many new pages are requested in a single frame.

367
00:25:42,305 --> 00:25:44,887
For example, when the camera is moving fast,

368
00:25:45,508 --> 00:25:47,089
we need to render a lot of pages.

369
00:25:48,470 --> 00:25:51,612
This happens in Far Cry 4 when the player is driving a vehicle

370
00:25:51,732 --> 00:25:53,013
or flying with the windsuit.

371
00:25:55,511 --> 00:25:58,693
Our solution to this problem is called distributed rendering.

372
00:26:00,493 --> 00:26:03,395
We sort required pages by their MIP map level,

373
00:26:03,835 --> 00:26:04,715
from low to high.

374
00:26:06,776 --> 00:26:09,998
Lower MIP map pages are rendered before higher MIP pages.

375
00:26:11,279 --> 00:26:14,680
So if the rendering cost for the adaptive virtual textures

376
00:26:15,000 --> 00:26:19,042
is higher than the threshold, for example, one millisecond,

377
00:26:20,483 --> 00:26:23,545
we will postpone the remaining high MIP pages

378
00:26:23,725 --> 00:26:24,725
into the next frames.

379
00:26:26,527 --> 00:26:30,488
As a result, there is a transition from blurred to sharp

380
00:26:30,708 --> 00:26:34,369
for terrain surfaces in several frames.

381
00:26:35,329 --> 00:26:39,270
But it happens very quickly, so it is generally not noticeable.

382
00:26:43,271 --> 00:26:49,133
Here I will show four continuous frames

383
00:26:50,113 --> 00:26:51,773
when we do distributed rendering.

384
00:26:52,834 --> 00:26:54,494
You will see that the frame.

385
00:26:55,471 --> 00:26:59,534
transition from blurred to sharp in full frames.

386
00:26:59,834 --> 00:27:03,037
But it really happens very quickly, so you can't see it.

387
00:27:07,000 --> 00:27:08,802
Because our adaptive virtual textures

388
00:27:09,002 --> 00:27:11,344
can render so many decals efficiently,

389
00:27:12,004 --> 00:27:15,087
our artists would like to place a massive number of decals

390
00:27:16,167 --> 00:27:16,548
in the game.

391
00:27:17,729 --> 00:27:20,051
But placing such amount of decals by hand

392
00:27:20,191 --> 00:27:21,031
is not a solution.

393
00:27:22,352 --> 00:27:24,074
So in Far Cry 4, we developed a.

394
00:27:25,010 --> 00:27:28,032
procedural content generator to place these decals

395
00:27:28,192 --> 00:27:28,732
automatically.

396
00:27:30,774 --> 00:27:33,275
The artist can set the rules to generate decals,

397
00:27:33,576 --> 00:27:37,158
like leaves, sand, stones, on the trees,

398
00:27:37,238 --> 00:27:40,480
and beside the bushes, with random shapes and colors.

399
00:27:43,182 --> 00:27:45,404
This really helps our artist director

400
00:27:45,624 --> 00:27:47,325
achieve our graphics benchmark.

401
00:27:51,068 --> 00:27:52,268
Here we show the.

402
00:27:53,662 --> 00:27:56,764
road rendering with procedurally generated decals.

403
00:27:58,424 --> 00:28:01,966
We mark the procedural decals as red squares.

404
00:28:04,067 --> 00:28:09,869
These are cracks, dirt, stones, leaves, for example.

405
00:28:12,190 --> 00:28:14,151
Another example with procedural decals.

406
00:28:15,392 --> 00:28:18,593
We place automatically the stones, leaves, sands,

407
00:28:19,033 --> 00:28:20,454
under trees and beside the bushes.

408
00:28:22,655 --> 00:28:33,704
And we can have thousands of them automatically attached.

409
00:28:34,244 --> 00:28:37,327
If we use a bilinear filtering for virtual textures,

410
00:28:38,468 --> 00:28:40,429
the image will look very blurred when

411
00:28:40,449 --> 00:28:43,972
you view the terrain surface from a very sharp view angle.

412
00:28:45,494 --> 00:28:48,596
So we would like to support 8x anisotropic filtering

413
00:28:48,776 --> 00:28:49,617
for virtual textures.

414
00:28:52,169 --> 00:28:54,671
But because of the nature of the virtual texture,

415
00:28:55,152 --> 00:28:57,313
the neighbor physical texture pages

416
00:28:57,473 --> 00:28:59,996
are not necessarily adjacent in the world space.

417
00:29:02,418 --> 00:29:03,819
So there will be a color bleeding

418
00:29:04,099 --> 00:29:06,441
when the textures are filtered across page border.

419
00:29:08,963 --> 00:29:12,566
To solve this problem, we add a four-textures border

420
00:29:12,646 --> 00:29:14,127
to our physical texture page.

421
00:29:15,208 --> 00:29:17,870
And our physical texture page size becomes 264 by 264.

422
00:29:23,908 --> 00:29:26,208
We render the page with enlarged viewport

423
00:29:27,449 --> 00:29:29,529
so that the border pixels are rendered

424
00:29:29,709 --> 00:29:32,230
with color that are adjacent in the world space.

425
00:29:38,851 --> 00:29:42,172
Doing that, we can support 8x anisotropic filtering nicely.

426
00:29:48,754 --> 00:29:51,354
If we only do anisotropic filtering

427
00:29:51,554 --> 00:29:53,075
with a bilinear filtering.

428
00:29:53,968 --> 00:30:01,310
We could see visible seams on terrain surfaces when there is a MIP level change in the area.

429
00:30:03,851 --> 00:30:05,432
So we need to do something better.

430
00:30:06,712 --> 00:30:11,673
We support a software tri-linear filtering for Far Cry 4 to fix the problem.

431
00:30:14,634 --> 00:30:15,714
The solution is very simple.

432
00:30:15,754 --> 00:30:19,455
We just fetch the virtual textures twice with two different MIP levels.

433
00:30:20,199 --> 00:30:24,581
and we do a linear blending between these two colors to get the final color.

434
00:30:27,823 --> 00:30:28,783
This works very well.

435
00:30:31,605 --> 00:30:35,267
Another solution is to use a hardware trilinear filtering.

436
00:30:37,168 --> 00:30:41,770
You can do this by creating a quarter-sized MIP-1 physical texture,

437
00:30:42,571 --> 00:30:48,454
and you update this MIP-1 physical texture cache whenever the MIP-0 physical texture cache is updated.

438
00:30:49,142 --> 00:30:52,385
So you basically keep two MIPS of the physical texture

439
00:30:52,525 --> 00:30:53,106
in the memory.

440
00:30:54,507 --> 00:30:57,049
But this would require 25% more memory

441
00:30:58,230 --> 00:30:59,391
for the physical texture cache.

442
00:31:01,313 --> 00:31:04,736
Our physical texture in Far Cry 4

443
00:31:04,856 --> 00:31:07,518
use 200 megabytes in the video memory.

444
00:31:08,819 --> 00:31:11,782
So we basically save about 50 megabytes

445
00:31:12,262 --> 00:31:16,266
by using software virtual tri-linear filtering.

446
00:31:17,699 --> 00:31:20,301
And the performance difference between the software

447
00:31:20,421 --> 00:31:23,062
and the hardware approach is very small in Far Cry 4.

448
00:31:27,865 --> 00:31:29,906
Here we can see with only bilinear filtering,

449
00:31:30,127 --> 00:31:31,327
the image is very blurred.

450
00:31:33,268 --> 00:31:35,390
And also you can see here, there's

451
00:31:35,430 --> 00:31:41,193
the seams, because the image in front of that

452
00:31:45,693 --> 00:31:50,476
with, for example, a lower BIF map, and the image below that is with a higher BIF map.

453
00:31:54,458 --> 00:31:58,521
And anisotropic filtering makes the image quite sharp in this case,

454
00:31:59,021 --> 00:32:02,303
but we can still see visible seams here.

455
00:32:05,765 --> 00:32:09,667
Using trilinear filtering and anisotropic filtering has the best result.

456
00:32:15,418 --> 00:32:18,079
Now I will show some screenshots from the game

457
00:32:18,379 --> 00:32:20,300
and talk about the performance and the memory.

458
00:32:26,982 --> 00:32:29,023
We only support adaptive virtual textures

459
00:32:29,183 --> 00:32:32,665
on the next generation platforms rendered with procedurally

460
00:32:32,725 --> 00:32:33,765
generated decals.

461
00:32:35,406 --> 00:32:38,707
On current generation platforms like PS3 and 360,

462
00:32:40,568 --> 00:32:43,349
we simply disable virtual textures

463
00:32:43,569 --> 00:32:44,950
and procedural decals.

464
00:32:47,345 --> 00:32:51,106
Here we can see the difference between current generation

465
00:32:51,727 --> 00:32:53,127
platform and next generation.

466
00:32:54,407 --> 00:32:57,828
This is current generation, and this is next generation.

467
00:33:02,390 --> 00:33:05,811
This is another example showing the difference

468
00:33:06,291 --> 00:33:08,891
between the current generation and next generation.

469
00:33:15,173 --> 00:33:16,073
Again, another example.

470
00:33:20,650 --> 00:33:23,471
We can render a massive number of decals

471
00:33:23,731 --> 00:33:26,192
thanks to our adaptive virtual textures.

472
00:33:28,712 --> 00:33:30,553
And they really enrich our environment

473
00:33:30,813 --> 00:33:34,254
by adding a lot more variety into the game.

474
00:33:37,675 --> 00:33:39,235
We captured the rendering performance

475
00:33:39,355 --> 00:33:41,376
for adaptive virtual textures on PS4.

476
00:33:44,176 --> 00:33:46,297
The rendering cost for adaptive virtual textures

477
00:33:46,677 --> 00:33:50,198
is less than 0.2 milliseconds for a static scene.

478
00:33:51,886 --> 00:33:56,889
For dynamic scene where we need to cache a lot of virtual texture pages,

479
00:33:58,549 --> 00:34:02,071
the rendering cost is less than one millisecond.

480
00:34:04,512 --> 00:34:08,074
This is quite good because to render such amount of decals

481
00:34:08,915 --> 00:34:11,396
with a traditional deferred decals rendering,

482
00:34:12,116 --> 00:34:14,738
it would probably take more than 10 milliseconds.

483
00:34:16,499 --> 00:34:19,120
So our adaptive virtual textures is more than...

484
00:34:20,614 --> 00:34:22,935
10 times faster and achieve better result.

485
00:34:29,516 --> 00:34:32,397
The memory usage for adaptive virtual textures

486
00:34:32,557 --> 00:34:33,957
is around 220 megabytes.

487
00:34:34,017 --> 00:34:38,378
Here we have 16 megabytes for indirection texture

488
00:34:39,278 --> 00:34:41,538
and 200 megabytes for our physical texture.

489
00:34:46,095 --> 00:34:51,976
Our physical texture is actually compressed into GXT and the BC format to save the memory.

490
00:34:52,697 --> 00:34:56,618
And this is done in the runtime using a compute shader.

491
00:35:00,199 --> 00:35:07,721
So to summarize, procedural virtual textures is a good technique to improve the terrain

492
00:35:07,781 --> 00:35:08,621
rendering performance.

493
00:35:13,044 --> 00:35:16,707
adaptive virtual textures to increase the resolution of virtual textures.

494
00:35:18,309 --> 00:35:24,975
And then we can achieve a great visual result by drawing a massive number of details on

495
00:35:25,015 --> 00:35:25,375
Far Cry 4.

496
00:35:29,579 --> 00:35:33,462
I would like to thank the Far Cry 4 rendering team and art team for the support of the technique.

497
00:35:34,523 --> 00:35:37,526
And also GDC advisory for the review of the slides.

498
00:35:39,572 --> 00:35:43,233
I provided some reference for the virtual textures on the slide.

499
00:35:45,734 --> 00:35:46,454
And thank you very much.

500
00:35:55,677 --> 00:35:58,038
So if there's any questions, you are free to ask.

501
00:35:58,358 --> 00:36:01,599
Just stand in front of the microphone.

502
00:36:08,201 --> 00:36:09,302
Hiya, great talk.

503
00:36:10,675 --> 00:36:16,281
Just wondering whether you considered using partially resonant textures at all,

504
00:36:16,921 --> 00:36:18,843
whether you think that would fit with this technique?

505
00:36:20,085 --> 00:36:24,950
Yes, we evaluated the partially resonant textures during the game,

506
00:36:25,030 --> 00:36:26,972
and we finally didn't use that because...

507
00:36:28,562 --> 00:36:35,604
During the development of Far Cry 4, the features are not completed on all platforms,

508
00:36:36,404 --> 00:36:40,626
and the implementation is all different in PS4 and Xbox.

509
00:36:40,766 --> 00:36:48,908
For example, Xbox is called a tiled resource, and PS4 is more like partially rendered textures using virtual memory.

510
00:36:51,395 --> 00:36:57,558
It is good to use a software approach because we can keep the same rendering API and on

511
00:36:57,658 --> 00:37:05,522
cross all the platforms and it really saves a lot of effort for us and it's actually the

512
00:37:05,542 --> 00:37:06,823
soft approach is quite fast.

513
00:37:07,003 --> 00:37:09,664
It doesn't really slow than the hardware approach.

514
00:37:10,845 --> 00:37:18,208
Quite good, but in the future we might consider using that if because a soft a small problem of the software

515
00:37:18,628 --> 00:37:25,811
Software approach is that you have to add a full textual border on the physical texture page that we explain for the

516
00:37:26,511 --> 00:37:30,332
Filtering so we you might save some memory by using a hardware approach

517
00:37:31,513 --> 00:37:31,713
Thanks

518
00:37:36,987 --> 00:37:41,150
One question, do you use any kind of parallax occlusion mapping or any kind of parallax

519
00:37:41,230 --> 00:37:43,712
mapping on a virtual, on a terrain?

520
00:37:44,692 --> 00:37:45,193
I beg pardon?

521
00:37:45,793 --> 00:37:47,494
Do you use any kind of parallax mapping?

522
00:37:47,534 --> 00:37:48,055
Okay, okay, okay.

523
00:37:48,575 --> 00:37:52,938
So you're asking any, if I use any kind of parallax mappings for the terrain?

524
00:37:54,739 --> 00:38:00,543
We have some kind of parallax decals for the terrain, but for these decals we don't render

525
00:38:00,583 --> 00:38:02,264
with virtual textures.

526
00:38:03,006 --> 00:38:04,428
Because this is depending on the view angle,

527
00:38:04,448 --> 00:38:06,291
so we cannot really bake them.

528
00:38:07,172 --> 00:38:08,714
But in the future, we are thinking

529
00:38:08,774 --> 00:38:11,778
about baking a height map into virtual textures.

530
00:38:12,482 --> 00:38:14,523
So you can have kind of like,

531
00:38:14,763 --> 00:38:17,003
tessellation, you achieve hardware tessellations

532
00:38:17,683 --> 00:38:18,784
with virtual textures.

533
00:38:19,144 --> 00:38:22,364
So you save diffuse, normal map, and specular,

534
00:38:22,444 --> 00:38:24,485
and also 8-bit height map.

535
00:38:24,665 --> 00:38:26,885
This will be compressed into BC format.

536
00:38:27,545 --> 00:38:31,706
So if you use hardware tessellation shader,

537
00:38:32,326 --> 00:38:35,587
you can fetch this height map in the tessellation sheet,

538
00:38:35,647 --> 00:38:38,108
and then you can get that directly from the virtual texture

539
00:38:38,248 --> 00:38:38,728
instead of...

540
00:38:39,456 --> 00:38:42,897
rendering these decals with parallax.

541
00:38:43,658 --> 00:38:47,380
So it's using a tessellation shield instead.

542
00:38:48,180 --> 00:38:49,161
Or you can do whatever you want.

543
00:38:55,644 --> 00:38:55,725
Hi.

544
00:38:57,806 --> 00:38:58,506
Great talk, thanks.

545
00:39:00,047 --> 00:39:01,808
I was wondering if you are allocating

546
00:39:01,908 --> 00:39:04,689
the virtual texture pages dynamically.

547
00:39:07,861 --> 00:39:12,742
Do I see it correct that it gets a two-time indirect fetch in the pixel shader?

548
00:39:14,442 --> 00:39:15,723
Can you repeat that?

549
00:39:16,683 --> 00:39:22,464
If the whole terrain is mapped on one virtual texture, the UV coordinates of the terrain

550
00:39:22,584 --> 00:39:23,504
are pretty obvious.

551
00:39:24,164 --> 00:39:30,026
But if you are allocating dynamic tiles, it's two times indirection?

552
00:39:31,846 --> 00:39:34,787
So are you asking if I allocate this for...

553
00:39:36,517 --> 00:39:44,121
virtual image dynamically? Yes, we do. Like we said, we have to dynamically adjust the

554
00:39:45,342 --> 00:39:52,605
virtual image size depending on the adjustment from the camera. So when we need to change

555
00:39:52,625 --> 00:39:56,708
the size of the virtual image, we have to remove the old virtual image and create a

556
00:39:56,728 --> 00:39:59,449
new one. So this is really dynamically allocating.

557
00:40:00,270 --> 00:40:03,632
So one thing I didn't talk about that is that we have kind

558
00:40:03,652 --> 00:40:04,992
of the allocation system.

559
00:40:05,092 --> 00:40:09,114
So you can just standardly remove the older one and have

560
00:40:09,134 --> 00:40:09,574
the new one.

561
00:40:09,654 --> 00:40:12,975
But it's kind of like a quadtree style.

562
00:40:13,175 --> 00:40:17,517
So there's not much fragmentations when you are

563
00:40:17,837 --> 00:40:19,678
looking at a new one and remove the new one.

564
00:40:19,718 --> 00:40:24,039
So it's always like a land on the power tool.

565
00:40:24,760 --> 00:40:26,740
So that's it.

566
00:40:33,801 --> 00:40:35,002
Yes, I had a question.

567
00:40:36,843 --> 00:40:38,525
Concerning your physical texture,

568
00:40:38,545 --> 00:40:42,488
I was wondering if you had any issues with fragmentation

569
00:40:42,788 --> 00:40:45,490
on that texture, and also if you had any issues

570
00:40:46,571 --> 00:40:51,035
with thrashing your texture cache.

571
00:40:51,475 --> 00:40:53,897
So you're asking if I have fragmentation

572
00:40:53,957 --> 00:40:55,178
for the physical texture.

573
00:40:55,899 --> 00:40:58,341
And if I have some trash, you mean

574
00:40:59,081 --> 00:41:00,122
the physical texture is full?

575
00:41:00,770 --> 00:41:06,072
So in the physical texture as you're allocating bigger and smaller textures into it,

576
00:41:06,672 --> 00:41:14,534
did you run into any issues where your fragmentation was filling it up bigger than potentially it could hold?

577
00:41:16,995 --> 00:41:22,137
We don't have fragmentation issues because we allocate the same size.

578
00:41:22,437 --> 00:41:23,177
Every page is 264 by 264.

579
00:41:26,052 --> 00:41:28,094
So we don't have any fragmentation issues.

580
00:41:28,534 --> 00:41:30,835
But we do have some kind of like,

581
00:41:30,996 --> 00:41:31,396
yeah, you,

582
00:41:32,817 --> 00:41:35,398
the texture, physical texture cache could be full, right?

583
00:41:35,498 --> 00:41:38,320
Because you are rendering into physical texture

584
00:41:39,061 --> 00:41:39,501
all the time.

585
00:41:39,921 --> 00:41:41,162
So, but we use, like I said,

586
00:41:41,182 --> 00:41:43,924
we use a least recently used algorithm.

587
00:41:44,625 --> 00:41:47,226
So the least used physical texture pages

588
00:41:47,306 --> 00:41:49,588
will be swept out automatically,

589
00:41:49,808 --> 00:41:51,469
and we render with a new,

590
00:41:52,710 --> 00:41:54,631
with a new rendering into this physical texture.

591
00:41:55,536 --> 00:42:01,199
So also, we set the size of our physical texture as 9K by 9K.

592
00:42:01,999 --> 00:42:04,720
So we can adjust this size.

593
00:42:05,441 --> 00:42:08,322
So we find a good spot for the correct size

594
00:42:08,482 --> 00:42:10,223
for our physical texture.

595
00:42:10,263 --> 00:42:15,186
So we don't see a lot of the swiping out and swiping in

596
00:42:15,286 --> 00:42:16,366
of the rendering.

597
00:42:16,646 --> 00:42:20,788
So otherwise, if you constantly swipe out,

598
00:42:21,389 --> 00:42:24,650
then you don't save much by using the virtual textures.

599
00:42:25,552 --> 00:42:30,396
because you want always to keep the result in the memory

600
00:42:30,496 --> 00:42:34,319
for the terrain that's in front of you, for example.

601
00:42:34,980 --> 00:42:37,062
But yeah, sometimes you face some problem

602
00:42:37,162 --> 00:42:41,145
and the way you go forward and you turn around,

603
00:42:41,866 --> 00:42:43,407
there might be some issues with that.

604
00:42:43,527 --> 00:42:46,089
But with all this distributed rendering

605
00:42:46,209 --> 00:42:48,912
and the mid-level rendering, you don't really see them.

606
00:42:49,793 --> 00:42:50,573
So yeah, that's it.

607
00:42:51,561 --> 00:42:56,763
and the second part, so did you do anything to minimize

608
00:42:57,644 --> 00:43:02,226
texture cache misses when you're looking into your

609
00:43:02,686 --> 00:43:04,167
physical texture space?

610
00:43:05,687 --> 00:43:09,269
Do I do anything to maximize my texture?

611
00:43:09,850 --> 00:43:13,011
So your texture cache, when you're grabbing that texture

612
00:43:13,091 --> 00:43:15,911
to render your different decals, sections,

613
00:43:16,411 --> 00:43:18,672
it could potentially look at all sorts of different spots

614
00:43:19,292 --> 00:43:20,972
on that physical texture,

615
00:43:21,512 --> 00:43:25,233
and potentially your texture cache can get thrashed

616
00:43:25,293 --> 00:43:26,833
and you need to pull in more textures.

617
00:43:27,213 --> 00:43:28,934
Did you run into any issues like that?

618
00:43:30,574 --> 00:43:32,814
No, we didn't see any issues for that.

619
00:43:33,354 --> 00:43:35,195
The rendering of the terrain is very fast.

620
00:43:35,255 --> 00:43:37,835
It takes less than one millisecond.

621
00:43:38,613 --> 00:43:40,354
to render all the terrain and the decals.

622
00:43:41,194 --> 00:43:43,535
So I didn't really check for that.

623
00:43:44,235 --> 00:43:44,536
Thank you.

624
00:43:52,639 --> 00:43:55,441
So you mentioned that you rendered

625
00:43:55,501 --> 00:43:58,082
during the GPL for pass, deferred pass,

626
00:43:58,122 --> 00:43:59,503
you render page IDs.

627
00:44:00,303 --> 00:44:03,284
And then you said that you use quarter size

628
00:44:03,885 --> 00:44:05,985
page ID buffer instead of full resolution.

629
00:44:06,466 --> 00:44:07,946
Does that mean that you actually?

630
00:44:08,730 --> 00:44:14,853
shrink after the full screen different paths,

631
00:44:15,213 --> 00:44:17,874
shrink the size to get it, because otherwise I...

632
00:44:17,934 --> 00:44:21,275
Okay, so the question is that if I render

633
00:44:21,295 --> 00:44:22,655
into full screen render target,

634
00:44:23,136 --> 00:44:27,797
or if I render into a 1-8th size of the page ID?

635
00:44:27,837 --> 00:44:29,078
This is different, yeah.

636
00:44:29,358 --> 00:44:32,319
So actually, rendering into a full screen render target

637
00:44:32,479 --> 00:44:33,680
is our first approach,

638
00:44:34,120 --> 00:44:35,620
then later on we change that approach.

639
00:44:36,335 --> 00:44:38,877
So we do not render into a fullscreen target anymore.

640
00:44:39,597 --> 00:44:42,579
Instead, we render into a 1F size.

641
00:44:43,580 --> 00:44:46,362
So you're not taking occlusion into account

642
00:44:46,482 --> 00:44:49,945
if some tree, for example, or big stone, or house

643
00:44:50,405 --> 00:44:52,647
occluding part of the terrain,

644
00:44:53,667 --> 00:44:56,309
it still be in a page ID buffer,

645
00:44:56,369 --> 00:44:59,432
it still be like there's no occlusion.

646
00:45:00,989 --> 00:45:05,973
No, it's okay, because I, as I explained, I didn't write in the slide, but I have said

647
00:45:06,133 --> 00:45:13,519
on the notes that I also talked that when you do a read-write buffer, you can set attribute

648
00:45:13,539 --> 00:45:14,019
in the shader.

649
00:45:14,059 --> 00:45:16,801
You can set as early depth stencil.

650
00:45:17,182 --> 00:45:23,206
So with that shader, you, any pixels that failing the depth test won't be writing to

651
00:45:23,246 --> 00:45:24,587
your read-write buffer.

652
00:45:25,532 --> 00:45:27,252
So if it's occluded, it won't be right.

653
00:45:27,332 --> 00:45:30,454
And if you have two pixels, which is behind that pixel,

654
00:45:31,154 --> 00:45:34,636
and this won't be right again into your page buffer.

655
00:45:35,176 --> 00:45:39,938
So you have to downsize the depth buffer in each area?

656
00:45:40,038 --> 00:45:42,719
No, I don't downsize the depth.

657
00:45:42,820 --> 00:45:44,420
It's in the gbuffer rendering path.

658
00:45:44,980 --> 00:45:47,542
It's ultimately done by the shader attribute.

659
00:45:48,362 --> 00:45:51,043
So it's like rendering to the render target,

660
00:45:51,063 --> 00:45:52,764
same as rendering to render target.

661
00:45:53,450 --> 00:45:56,272
But the difference is that if you don't add that attribute

662
00:45:56,352 --> 00:45:59,454
into your shader, it will output all the pixels

663
00:45:59,614 --> 00:46:00,654
into your read-write buffer.

664
00:46:01,335 --> 00:46:02,976
But as soon as you add that shader, which

665
00:46:03,076 --> 00:46:08,319
is an attribute from the shader language,

666
00:46:08,699 --> 00:46:10,760
and then it will do it same as the render target.

667
00:46:10,840 --> 00:46:13,021
But you can still render into the buffer.

668
00:46:14,622 --> 00:46:17,383
So you don't render any pixels twice, or you like that.

669
00:46:17,403 --> 00:46:21,846
Is it clear?

670
00:46:24,999 --> 00:46:27,902
Hi, I have sort of two related questions.

671
00:46:28,602 --> 00:46:35,688
First, you mentioned that the budget for rendering new pages was 1 millisecond, right?

672
00:46:36,128 --> 00:46:39,951
How many texels could you actually fill in 1 millisecond?

673
00:46:41,412 --> 00:46:41,873
How many?

674
00:46:42,473 --> 00:46:43,014
How many texels?

675
00:46:43,334 --> 00:46:45,355
So, I mean, the 1 millisecond...

676
00:46:46,644 --> 00:46:52,908
implies some kind of actual amount of texture you could actually fill for creating new MIPS, so...

677
00:46:54,209 --> 00:47:00,073
Are you talking about how many new virtual texture pages I can actually render?

678
00:47:00,233 --> 00:47:01,794
Well, I guess physical texture pages.

679
00:47:01,834 --> 00:47:04,335
Yeah, physical texture pages I can actually render.

680
00:47:04,656 --> 00:47:06,637
Yeah.

681
00:47:08,561 --> 00:47:12,503
maybe 10, 20, I don't remember, maybe 10 something.

682
00:47:12,963 --> 00:47:13,183
Okay.

683
00:47:13,343 --> 00:47:16,425
Because you don't really, when you,

684
00:47:16,865 --> 00:47:18,566
when the player walks in the game,

685
00:47:19,106 --> 00:47:22,067
they are not updated frequently, right?

686
00:47:22,187 --> 00:47:23,448
So the related question is,

687
00:47:23,608 --> 00:47:26,329
what about weird extreme cases,

688
00:47:26,429 --> 00:47:28,830
like a player taking the helicopter?

689
00:47:29,263 --> 00:47:31,665
and flying it very close to the ground very, very quickly,

690
00:47:32,046 --> 00:47:35,508
like hugging the ground, so creating like a worst-case scenario

691
00:47:35,528 --> 00:47:37,910
where you're zipping over the ground

692
00:47:38,450 --> 00:47:41,813
and you're sort of getting ahead of the cache.

693
00:47:42,233 --> 00:47:43,194
Yeah, yeah, so...

694
00:47:43,895 --> 00:47:45,356
I mean, you mentioned that you fall back,

695
00:47:45,456 --> 00:47:49,359
but are there cases where the blurring of falling back

696
00:47:49,499 --> 00:47:50,880
can become actually obvious?

697
00:47:55,370 --> 00:48:01,353
So yeah, I mentioned I have a fallback to low-res virtual maps.

698
00:48:01,833 --> 00:48:02,013
Right.

699
00:48:02,773 --> 00:48:03,693
Yes, actually you're right.

700
00:48:04,454 --> 00:48:10,036
You could sometimes, like when you really run a lot of pages in one frame, and you could

701
00:48:10,076 --> 00:48:12,396
not finish, and you have to postpone to the next frame.

702
00:48:13,037 --> 00:48:16,338
For example, if you walk forward.

703
00:48:17,407 --> 00:48:20,849
And if you walk backward, like do this,

704
00:48:21,750 --> 00:48:24,952
and you suddenly turn 180 degrees around,

705
00:48:25,553 --> 00:48:30,797
you could see the pages transition from blurred to sharp.

706
00:48:30,877 --> 00:48:32,658
And sometimes it's quite obvious.

707
00:48:33,359 --> 00:48:37,882
So we have a different algorithm for this.

708
00:48:38,503 --> 00:48:40,284
So in this case, we sort the pages

709
00:48:40,544 --> 00:48:42,205
according to their importance.

710
00:48:43,253 --> 00:48:48,298
So I always render the important which is in front of me first,

711
00:48:49,019 --> 00:48:51,922
then the page that are farther away from me.

712
00:48:52,222 --> 00:48:55,946
So you have a lot less visual popping up in this case.

713
00:48:56,026 --> 00:48:56,867
It works quite well.

714
00:48:57,621 --> 00:48:58,742
Okay, cool. Thanks.

715
00:48:58,762 --> 00:49:02,244
man 2 Can I still elaborate here?

716
00:49:02,264 --> 00:49:05,386
Because it's free frames of latency, right?

717
00:49:06,466 --> 00:49:08,928
You analyze on CPU, meaning from GPU,

718
00:49:09,168 --> 00:49:10,689
meaning it's GPU readback.

719
00:49:11,149 --> 00:49:15,972
Typical PC driver invokes free frames of latency.

720
00:49:16,712 --> 00:49:19,754
So in that case, exactly you've mentioned,

721
00:49:19,774 --> 00:49:22,035
you're going backward, then you turn around.

722
00:49:23,992 --> 00:49:27,214
Although you can do that very fast when you realize what's happening,

723
00:49:27,814 --> 00:49:33,177
but there will be free frames of latency where you'll see blurred image.

724
00:49:36,619 --> 00:49:42,362
We also have a kind of like a CPU page ID feedback.

725
00:49:43,262 --> 00:49:46,924
So because the GPU page ID feedback, you only feedback the pages that

726
00:49:47,144 --> 00:49:51,606
in your view first term, right? And we increase that first term a little bit larger.

727
00:49:53,129 --> 00:49:58,610
so that some pages that are beside you,

728
00:49:59,330 --> 00:50:01,111
outside of your platform, they're also

729
00:50:01,371 --> 00:50:04,872
included into the feedback of the page ID list.

730
00:50:05,812 --> 00:50:08,712
But they are a bit like low res, but still it

731
00:50:08,753 --> 00:50:12,793
helps because when you turn right, like you said,

732
00:50:12,813 --> 00:50:14,334
you have free latency.

733
00:50:14,934 --> 00:50:16,254
So it's already there.

734
00:50:17,334 --> 00:50:20,155
So I think it will help.

735
00:50:20,235 --> 00:50:20,875
And also, uh,

736
00:50:22,154 --> 00:50:28,785
Usually you don't really see that much because a page is quite large. So you always have that cached and you always go like this

737
00:50:29,546 --> 00:50:31,069
So most time it's okay

738
00:50:32,591 --> 00:50:32,771
Thanks

739
00:50:35,864 --> 00:50:40,908
So I just wanted to clarify from the question that was over there.

740
00:50:42,429 --> 00:50:47,192
So you're actually, you're rendering the scene again, presumably with low resolution geometry

741
00:50:47,332 --> 00:50:50,915
at, you know, an eighth size buffer, is that right?

742
00:50:51,175 --> 00:50:53,277
No, no, we don't render the scene again.

743
00:50:53,517 --> 00:50:56,939
We only render the scene one time in the G-buffer.

744
00:50:57,600 --> 00:51:02,043
But we output it into a low-res read-write buffer.

745
00:51:03,369 --> 00:51:07,956
Okay, right. Okay. That was the bit that I okay, so you're just selecting that based on

746
00:51:09,479 --> 00:51:10,641
on presumably some

747
00:51:11,872 --> 00:51:12,932
One of the, just the...

748
00:51:12,952 --> 00:51:14,953
Yeah, one of the, one of the, so yeah,

749
00:51:14,973 --> 00:51:15,794
I should have said that.

750
00:51:16,034 --> 00:51:16,214
Right.

751
00:51:16,314 --> 00:51:18,655
So you have like 16 pixels.

752
00:51:18,975 --> 00:51:19,395
Right, yeah.

753
00:51:19,435 --> 00:51:20,816
And you select one pixels.

754
00:51:20,836 --> 00:51:21,296
Okay.

755
00:51:21,316 --> 00:51:26,399
Because it doesn't matter, because usually the page,

756
00:51:27,319 --> 00:51:30,761
the near close pixels are sharing the same page ID.

757
00:51:31,221 --> 00:51:31,401
Right.

758
00:51:31,521 --> 00:51:33,942
If they don't share the same page ID,

759
00:51:33,962 --> 00:51:38,564
it doesn't really matter if you have one level lower

760
00:51:38,624 --> 00:51:39,385
in one pixel.

761
00:51:39,405 --> 00:51:40,345
Yeah, totally, totally.

762
00:51:40,865 --> 00:51:41,365
Okay, thanks.

763
00:51:43,326 --> 00:51:47,306
I was just curious, what are the different maps that you're supporting currently?

764
00:51:48,167 --> 00:51:53,548
You talked about wanting to have eight maps later on, but currently it's with diffuse,

765
00:51:53,608 --> 00:51:54,948
normal, specular.

766
00:51:55,788 --> 00:51:59,989
What kind of maps currently are you managing with your virtual texture?

767
00:52:01,169 --> 00:52:03,709
What kind of map I'm managing with the virtual texture?

768
00:52:03,789 --> 00:52:07,370
So we have diffuse, which is XYZ.

769
00:52:08,130 --> 00:52:08,890
We have normal map.

770
00:52:10,279 --> 00:52:11,100
which is XY

771
00:52:12,340 --> 00:52:15,682
We have specular occlusion and we have roughness

772
00:52:16,883 --> 00:52:18,323
We have what else?

773
00:52:21,765 --> 00:52:24,107
I don't remember. It's like that

774
00:52:26,931 --> 00:52:36,753
Physical textures, how much physical textures you do the, so maps, normal map, diffuse,

775
00:52:36,833 --> 00:52:40,014
maybe you can utilize alpha channel in the... Yes, that's right.

776
00:52:40,434 --> 00:52:42,094
How many physical textures? Three.

777
00:52:43,054 --> 00:52:47,375
Yeah. Formats, what are the formats?

778
00:52:48,075 --> 00:52:48,375
Format.

779
00:52:52,336 --> 00:52:53,496
Diffuse is a DXT1.

780
00:52:55,577 --> 00:52:57,779
Normal map is BC5.

781
00:52:59,060 --> 00:53:00,081
BC5, yes.

782
00:53:00,282 --> 00:53:02,604
And another one is GXT1, I think.

783
00:53:03,485 --> 00:53:05,486
For the normal map, I have to use BC5.

784
00:53:05,567 --> 00:53:07,568
Otherwise, the compression will be really bad.

785
00:53:08,870 --> 00:53:10,231
But BC5 is really great.

786
00:53:17,618 --> 00:53:18,118
Other questions?

787
00:53:20,521 --> 00:53:21,201
OK, thank you very much.

