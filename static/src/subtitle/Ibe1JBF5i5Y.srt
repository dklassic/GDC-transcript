1
00:00:11,934 --> 00:00:16,198
My name is Eric Wolle and I'm a graphics programmer at Sucker Punch Productions.

2
00:00:17,079 --> 00:00:21,864
This talk is about the procedural grass systems we used in Ghost of Tsushima to achieve our

3
00:00:21,904 --> 00:00:22,745
art direction goals.

4
00:00:23,683 --> 00:00:28,765
A quick note, barring some unforeseen circumstance, I'll be available in the live Q&A chat for

5
00:00:28,785 --> 00:00:32,547
this video when it's presented, so feel free to put any questions you have during the talk

6
00:00:32,567 --> 00:00:34,548
there and I'll answer them as soon as I am able.

7
00:00:36,409 --> 00:00:40,731
Ghosts of Tsushima is set on the island of Tsushima off the coast of ancient Japan, and

8
00:00:40,751 --> 00:00:44,874
from early on, one of the primary goals was to portray the natural beauty of the island.

9
00:00:46,394 --> 00:00:51,297
This meant a lot of foliage, giant forests of gently swaying trees, endless rolling hills

10
00:00:51,337 --> 00:00:53,218
of grass, and everything in between.

11
00:00:54,824 --> 00:00:59,689
Art direction also decided to lean into a painted feel, where instead of having fields of many

12
00:00:59,789 --> 00:01:04,915
intermingled types of flowers, shrubs and ferns, for instance, we opted to have large swaths of

13
00:01:04,935 --> 00:01:11,882
a single type of flower, as if painted there by a giant brushstroke. Very, very early on,

14
00:01:12,363 --> 00:01:14,365
we experimented with traditional grass cards.

15
00:01:15,101 --> 00:01:17,043
These ended up not being desirable for our goals

16
00:01:17,063 --> 00:01:18,003
for a couple of reasons.

17
00:01:18,604 --> 00:01:21,286
First, wind was something we really wanted to push on.

18
00:01:21,706 --> 00:01:24,348
And having our animation tied to the entire grass card

19
00:01:24,408 --> 00:01:25,189
was very limiting.

20
00:01:26,230 --> 00:01:29,972
Second, overdraw was problematic for the density of foliage

21
00:01:30,032 --> 00:01:31,434
we were looking to have in our world.

22
00:01:32,114 --> 00:01:34,756
Around this time, we found an excellent blog post

23
00:01:34,776 --> 00:01:37,678
by Altera called Procedural Grass Rendering that

24
00:01:37,698 --> 00:01:39,200
inspired a lot of our approach.

25
00:01:39,700 --> 00:01:41,601
I'll have a link to their blog post at the end of the talk,

26
00:01:41,761 --> 00:01:43,403
and I definitely recommend you check it out.

27
00:01:45,996 --> 00:01:47,037
So here's what we came up with.

28
00:01:47,817 --> 00:01:50,660
The scene considers just over 1 million blades of grass

29
00:01:51,140 --> 00:01:52,961
and renders about 83,000 of them,

30
00:01:53,762 --> 00:01:55,544
each individually animating with the wind

31
00:01:55,784 --> 00:01:58,366
and taking about two and a half milliseconds end to end.

32
00:02:00,016 --> 00:02:02,018
The grass is highly artist configurable.

33
00:02:02,759 --> 00:02:05,741
We use the same grass system for our giant fields of pampas grass,

34
00:02:06,002 --> 00:02:08,384
our burnt out fields, and our huge fields of flowers.

35
00:02:09,205 --> 00:02:10,966
The grass interacts with our wind system

36
00:02:11,407 --> 00:02:14,310
to help give the player a sense of direction to support our guiding wind

37
00:02:14,390 --> 00:02:17,192
mechanic, where the direction of the wind shows the player where to go.

38
00:02:18,273 --> 00:02:20,836
The grass reacts to the player and enemies moving through it too.

39
00:02:23,579 --> 00:02:25,260
So here's how I'm hoping to organize this talk.

40
00:02:26,445 --> 00:02:28,547
We'll talk first about what our compute shaders produce,

41
00:02:29,067 --> 00:02:30,668
then how that information gets passed around.

42
00:02:31,268 --> 00:02:32,729
Then we'll go into our vertex shaders

43
00:02:32,889 --> 00:02:34,531
and how they handle things, followed

44
00:02:34,551 --> 00:02:37,412
by how we determine our material data in our pixel shaders.

45
00:02:38,113 --> 00:02:39,694
The last section is a bit of a grab bag

46
00:02:39,714 --> 00:02:41,575
of things that help pull the whole system together

47
00:02:41,655 --> 00:02:42,976
in an actual production engine.

48
00:02:43,796 --> 00:02:44,357
So let's get started.

49
00:02:46,078 --> 00:02:47,959
The first step for us is chopping the world up

50
00:02:48,099 --> 00:02:48,640
into tiles.

51
00:02:50,371 --> 00:02:52,412
These tiles contain a suite of textures for things

52
00:02:52,452 --> 00:02:54,314
like the height of the terrain, the material

53
00:02:54,334 --> 00:02:56,395
to render the terrain as, and for our purposes

54
00:02:56,455 --> 00:02:59,537
here, what type of grass to put at that location

55
00:02:59,717 --> 00:03:00,718
and how tall it should be.

56
00:03:02,539 --> 00:03:05,021
Those tiles are further subdivided into the tiles

57
00:03:05,061 --> 00:03:06,202
we actually render.

58
00:03:06,802 --> 00:03:09,244
They sample from subsections of the textures

59
00:03:09,344 --> 00:03:10,425
in their parent tiles.

60
00:03:11,165 --> 00:03:13,427
The textures are 512 by 512, which

61
00:03:13,467 --> 00:03:15,949
ends up meaning we have one texel every 39 centimeters

62
00:03:16,009 --> 00:03:16,229
or so.

63
00:03:18,549 --> 00:03:20,830
For each render tile, we run one compute shader.

64
00:03:21,910 --> 00:03:24,451
Each lane in the compute shader gets a position on a grid

65
00:03:24,511 --> 00:03:26,732
within the tile and adds a random offset

66
00:03:26,872 --> 00:03:28,012
to pick our blade's position.

67
00:03:29,293 --> 00:03:32,034
Once we know where it is, we do distance culling and frustum

68
00:03:32,054 --> 00:03:32,374
culling.

69
00:03:33,734 --> 00:03:36,555
After that, we sample from our previously mentioned textures

70
00:03:36,575 --> 00:03:38,976
to determine what types of grass it is

71
00:03:39,376 --> 00:03:40,397
and how tall it should be.

72
00:03:41,857 --> 00:03:43,498
Lanes that either have the null grass type

73
00:03:43,698 --> 00:03:45,318
or have a height of 0 are dropped.

74
00:03:47,120 --> 00:03:48,982
Now that we're fairly certain we have a grass blade,

75
00:03:49,322 --> 00:03:50,243
we do occlusion culling.

76
00:03:50,963 --> 00:03:52,124
Late in the project, we found this

77
00:03:52,144 --> 00:03:54,205
to be a small perf win in the majority of shots.

78
00:03:56,327 --> 00:03:58,208
Each grass blade has a specific type,

79
00:03:58,428 --> 00:04:00,690
which determines what artist-authored parameters

80
00:04:00,850 --> 00:04:01,371
it uses.

81
00:04:02,211 --> 00:04:04,573
Each tile has a 512 by 512 texture

82
00:04:04,633 --> 00:04:06,854
that maps each tile position to a grass type,

83
00:04:07,335 --> 00:04:10,457
stored as an 8-bit index into an array of grass parameters.

84
00:04:11,306 --> 00:04:15,472
We can't do a bilinear sample on this data since interpolating between up to four different

85
00:04:15,553 --> 00:04:20,300
indices is meaningless. This is what it looks like if we do a simple point sample.

86
00:04:21,162 --> 00:04:24,728
You can fairly clearly see the texels of the texture that control the grass type.

87
00:04:27,257 --> 00:04:31,019
So instead, we do a gather, then we randomly choose one of the grass types,

88
00:04:31,399 --> 00:04:34,260
weighted by our position relative to the center of the four textiles.

89
00:04:34,780 --> 00:04:38,522
This gives us a smoother dither transition than if we just did a point sample,

90
00:04:39,003 --> 00:04:43,745
which is important for making it less obvious that we're driving our grass type from a low-resolution texture.

91
00:04:45,986 --> 00:04:50,969
Now, for each lane that's still active, we fill in 16 floats of per-blade instance data.

92
00:04:52,009 --> 00:04:55,231
Three floats for position and two for the facing direction of the blade.

93
00:04:56,047 --> 00:04:59,649
This 2D facing vector determines the direction the blade of grass is pointing.

94
00:05:00,970 --> 00:05:04,272
We put the strength of the wind at the blade's position, which drives animation.

95
00:05:05,853 --> 00:05:09,936
We place a per blade position based hash that drives various things on the blade,

96
00:05:10,136 --> 00:05:14,978
including animation. The type of grass it is, which determines which set of artist author

97
00:05:14,998 --> 00:05:20,142
parameters to use. Clumping information, which I'll go into more detail on in a second here.

98
00:05:21,342 --> 00:05:24,364
And lastly, various parameters for controlling the shape of the blade.

99
00:05:25,458 --> 00:05:28,100
These parameters are influenced by upper blade hash,

100
00:05:28,420 --> 00:05:30,541
what clump the blade belongs to, the wind,

101
00:05:30,941 --> 00:05:32,782
slope of the underlying terrain, things

102
00:05:32,842 --> 00:05:34,943
moving through the grass and pushing it out of the way,

103
00:05:35,403 --> 00:05:37,144
the position of the camera, and more.

104
00:05:38,525 --> 00:05:40,285
The way the blades interact with those things

105
00:05:40,505 --> 00:05:42,386
are all driven by artist author parameters

106
00:05:42,566 --> 00:05:44,327
and are different for each type of grass.

107
00:05:46,748 --> 00:05:48,709
I want to draw attention to the clump values I mentioned

108
00:05:48,729 --> 00:05:49,550
in the previous slide.

109
00:05:50,290 --> 00:05:51,651
Before we added our clumping code,

110
00:05:52,091 --> 00:05:54,072
all our fields looked mostly like grass

111
00:05:54,112 --> 00:05:54,892
you'd want to golf on.

112
00:05:55,448 --> 00:05:57,049
You can increase the randomness per blade

113
00:05:57,069 --> 00:05:59,370
to make it look messier, but it didn't look more

114
00:05:59,390 --> 00:06:00,511
like a natural field.

115
00:06:01,331 --> 00:06:02,292
It just looked random.

116
00:06:03,032 --> 00:06:04,273
Real fields vary.

117
00:06:04,753 --> 00:06:06,433
Maybe this area is in shadow in the morning

118
00:06:06,474 --> 00:06:07,494
and the grass grows less.

119
00:06:07,974 --> 00:06:09,875
Maybe this area has a bit more nitrogen in the soil

120
00:06:09,895 --> 00:06:10,835
and the grass grows taller.

121
00:06:11,596 --> 00:06:13,177
To try and emulate this, we decided

122
00:06:13,217 --> 00:06:14,737
to organize the grass into clumps

123
00:06:15,117 --> 00:06:17,378
and use which clump the blade belongs to

124
00:06:17,499 --> 00:06:18,959
to affect the other parameters.

125
00:06:21,020 --> 00:06:24,021
We achieved this by using a procedural Voronoi algorithm.

126
00:06:24,747 --> 00:06:29,729
For any given position in our 2D space, we look at the nearest nine points on a grid.

127
00:06:31,670 --> 00:06:35,071
Each point is jittered according to a hash to give it variation.

128
00:06:36,692 --> 00:06:39,853
Then we assign this 2D sample point to the nearest points clump.

129
00:06:40,754 --> 00:06:44,896
With this shared clump and a distance to it, we can influence the various grass parameters.

130
00:06:46,576 --> 00:06:47,437
We can adjust the height.

131
00:06:50,078 --> 00:06:52,339
We can have the clump all point in the same direction.

132
00:06:54,697 --> 00:06:57,298
We can pull the blades closer to the clump point.

133
00:06:59,660 --> 00:07:02,021
We can make the blades all face away from the clump point,

134
00:07:03,782 --> 00:07:05,524
or combinations of all of those things.

135
00:07:08,866 --> 00:07:11,507
So here's an overview of what our shader flow looks

136
00:07:11,547 --> 00:07:12,488
like overall.

137
00:07:13,449 --> 00:07:15,630
Our first compute shader fills in our instance data

138
00:07:15,870 --> 00:07:17,331
and accumulates our blade count.

139
00:07:18,136 --> 00:07:20,998
A second compute shader, which runs once the first is finished,

140
00:07:21,558 --> 00:07:23,780
moves that blade count to the indirect draw arguments

141
00:07:23,960 --> 00:07:25,081
for this tile's draw call.

142
00:07:25,781 --> 00:07:28,563
The second compute shader runs just one way front

143
00:07:28,723 --> 00:07:29,664
and takes almost no time.

144
00:07:31,025 --> 00:07:32,826
Once it finishes and the indirect draw args

145
00:07:32,846 --> 00:07:34,648
are ready to go, the vertex shaders

146
00:07:34,668 --> 00:07:37,550
will kick off and render according to the instance data.

147
00:07:38,230 --> 00:07:40,312
Finally, the pixel shader just has to do the shading.

148
00:07:42,793 --> 00:07:44,715
We don't process all the tiles at the same time,

149
00:07:44,775 --> 00:07:46,956
though, as the memory costs would be very high.

150
00:07:47,779 --> 00:07:50,600
Instead, our instance data buffer can hold eight tiles

151
00:07:50,640 --> 00:07:51,540
worth of GRASS data.

152
00:07:52,300 --> 00:07:54,761
We first run four tiles through their compute shaders.

153
00:07:55,061 --> 00:07:57,401
Then, while their vertex and pixel shaders run,

154
00:07:57,681 --> 00:07:59,982
we run the next four tiles through their compute shaders.

155
00:08:00,782 --> 00:08:03,322
This double buffer strategy keeps the GPU busy

156
00:08:03,643 --> 00:08:05,163
and doesn't eat up our memory budget.

157
00:08:05,183 --> 00:08:09,344
All right, now that we've got a handle on compute,

158
00:08:09,804 --> 00:08:10,624
onto the vertex shader.

159
00:08:11,464 --> 00:08:14,485
The vertex shaders are drawn with an instanced indexed draw

160
00:08:14,545 --> 00:08:16,045
call and no vertex streams.

161
00:08:16,715 --> 00:08:20,056
they generate their output data just from their index and instance ID.

162
00:08:20,776 --> 00:08:24,597
Each tile is one draw call and there's either low-LOD or high-LOD.

163
00:08:25,337 --> 00:08:27,358
High-LOD grass has 15 verts per blade,

164
00:08:27,738 --> 00:08:28,938
while the low-LOD has seven.

165
00:08:30,559 --> 00:08:32,999
For each vert, we need to know a 0-1 value

166
00:08:33,199 --> 00:08:35,220
for where it lies along the length of the blade,

167
00:08:35,660 --> 00:08:37,440
and if it's on the left side or the right side.

168
00:08:37,460 --> 00:08:39,701
It's worth noting at this point that

169
00:08:39,721 --> 00:08:42,141
the curvature of our grass blades isn't very well distributed,

170
00:08:42,161 --> 00:08:46,342
and we therefore might not want to have our verts evenly distributed either.

171
00:08:47,345 --> 00:08:49,885
To help with this, we have an artist configurable parameter

172
00:08:50,226 --> 00:08:52,606
that lets them rescale where the verts go along the blade.

173
00:08:55,447 --> 00:08:57,428
Transitioning seamlessly between the two LODs

174
00:08:57,548 --> 00:08:58,428
is a little bit tricky.

175
00:08:59,108 --> 00:09:01,049
Since our grass can have very high curvature,

176
00:09:01,429 --> 00:09:04,050
there can be popping when we move to a lower number of verts.

177
00:09:04,590 --> 00:09:07,791
To alleviate this, the high LOD blends towards the low LOD

178
00:09:07,991 --> 00:09:08,691
as it nears it.

179
00:09:11,596 --> 00:09:15,858
Also worth mentioning that the low lot tiles are twice the size of the high lot tiles,

180
00:09:16,178 --> 00:09:20,880
but have the same number of grass blades. This means that grass blades are spread out twice as far.

181
00:09:21,980 --> 00:09:27,383
To make this seamless, the high lot tiles lot out three out of every four grass blades before

182
00:09:27,423 --> 00:09:34,846
they transition to the low lot tiles. Normally, all of our verts are spent on a single blade,

183
00:09:35,306 --> 00:09:39,448
but if the grass is short enough, we fold the verts to form two blades instead.

184
00:09:40,224 --> 00:09:42,145
This is one of the great ideas we got from Altera,

185
00:09:42,506 --> 00:09:45,388
and it really helps make areas of short grass denser.

186
00:09:46,469 --> 00:09:48,291
So in addition to the placement along the blade,

187
00:09:48,551 --> 00:09:50,372
in the left or right side of the blade,

188
00:09:50,392 --> 00:09:52,474
there's also a which of the two blades

189
00:09:52,534 --> 00:09:55,277
am I variable we determined from the vertex ID.

190
00:09:56,758 --> 00:09:59,000
Because the number of verts in our grass blade is odd,

191
00:09:59,500 --> 00:10:02,022
one of the blades end up having one less vertex than the other.

192
00:10:02,042 --> 00:10:04,765
This causes us to have a weird triangle on one side.

193
00:10:05,607 --> 00:10:07,927
For the low LODs, lower vertex count blade,

194
00:10:08,227 --> 00:10:10,668
we don't have a tip because it's pretty noticeable how

195
00:10:10,728 --> 00:10:13,308
low poly it was when animating, even at a distance.

196
00:10:21,390 --> 00:10:23,511
Now that we know which type of grass blade we are

197
00:10:23,531 --> 00:10:25,551
and relevant details about our vertex,

198
00:10:26,011 --> 00:10:28,332
we have to decide where our vertex goes in world space.

199
00:10:29,132 --> 00:10:32,153
The shape of each grass blade is a cubic Bezier curve.

200
00:10:32,633 --> 00:10:34,133
This has a lot of useful properties.

201
00:10:35,776 --> 00:10:38,717
Vertex positions along the blade are trivial to calculate.

202
00:10:39,918 --> 00:10:41,859
The derivatives are also trivial to calculate,

203
00:10:42,239 --> 00:10:44,180
which makes our normals very easy to determine.

204
00:10:45,120 --> 00:10:47,081
And the control points give us a lot of control

205
00:10:47,221 --> 00:10:48,282
over the shape of the blade.

206
00:10:48,302 --> 00:10:50,243
This makes it easy to animate the grass

207
00:10:50,483 --> 00:10:52,804
and also have lots of different shapes of grass.

208
00:10:54,945 --> 00:10:56,906
But where do we place our Bezier control points?

209
00:10:57,607 --> 00:11:00,828
To start, we decide the position of the tip relative to the base.

210
00:11:01,829 --> 00:11:03,790
This is controlled by the tilt parameter from earlier,

211
00:11:04,070 --> 00:11:04,990
as well as the facing.

212
00:11:06,616 --> 00:11:10,038
Next, we define the midpoint, which is controlled by the bend parameter.

213
00:11:10,578 --> 00:11:14,039
If bend is 0, the midpoint lies along the line between base and tip.

214
00:11:15,080 --> 00:11:18,281
Values larger than 0 push it up and away from that line.

215
00:11:19,061 --> 00:11:23,103
For split blades, we keep the same general shape, but push the two blades apart.

216
00:11:23,623 --> 00:11:27,065
This keeps them facing the same general direction while still increasing coverage.

217
00:11:29,586 --> 00:11:31,287
Now that we know where our control points are,

218
00:11:31,307 --> 00:11:34,728
it's straightforward to determine our world space position for our vertex.

219
00:11:35,757 --> 00:11:41,059
We take our 0 to 1 value that determines where we are along the blade and feed that into our Bezier curve function.

220
00:11:42,320 --> 00:11:48,682
Next, we take our facing direction, flip the X and Y and negate one to find a normal orthogonal to our facing.

221
00:11:49,702 --> 00:11:53,264
We step our vertex in the normal direction and distance depending on the width of the blade,

222
00:11:53,624 --> 00:11:56,785
calculated in the compute shader and scaled by where we are along the blade.

223
00:11:57,445 --> 00:11:59,366
We want to taper down as we reach the tip.

224
00:12:01,105 --> 00:12:05,247
Next, to find the vertex normal, we find the derivative of the Bezier curve at our position

225
00:12:05,407 --> 00:12:12,669
and cross it with the normal we just found. But how do we make it move? A quick aside about our

226
00:12:12,709 --> 00:12:17,871
wind system. We decided early on that we wanted to have a unified wind system that could be sampled

227
00:12:18,111 --> 00:12:24,893
on CPU and GPU and had relatively minimal overhead. To that end, we aimed for simplicity.

228
00:12:26,349 --> 00:12:32,910
The wind is effectively 2D Perlin noise shaped by user parameters and scrolled in the direction that the wind is blowing.

229
00:12:33,570 --> 00:12:37,051
The Perlin noise gives us a single wind push force value at a location,

230
00:12:37,491 --> 00:12:43,513
which we combine with our 2D wind direction vector to use as an input to our various systems that react to the wind.

231
00:12:44,833 --> 00:12:50,034
For grass and some particle systems, we do an additional layer of Perlin noise to get more complex motion.

232
00:12:50,840 --> 00:12:52,163
If you want to know more about our wind,

233
00:12:52,684 --> 00:12:54,668
check out my colleague Bill Rockenbeck's talk,

234
00:12:54,948 --> 00:12:55,890
Blowing from the West.

235
00:12:58,595 --> 00:12:59,496
So back to our grass blade.

236
00:13:00,499 --> 00:13:05,961
Our facing was already influenced by the wind in the compute shader, so now we just do some simple bobbing up and down.

237
00:13:06,501 --> 00:13:12,183
This bobbing is a simple sine wave where the phase offset is affected by the per blade hash,

238
00:13:12,663 --> 00:13:16,644
as well as the position along the grass blade to give the motion a swaying look.

239
00:13:17,244 --> 00:13:20,685
The per blade hash offset ensures each blade's motion is different.

240
00:13:21,665 --> 00:13:28,249
It's important to note at this point that the arc length of a Bezier curve is not very easy to calculate and hard to control.

241
00:13:28,810 --> 00:13:31,992
As the blade animates, the arc length definitely varies.

242
00:13:33,333 --> 00:13:37,135
However, if the animation is kept relatively constrained, this isn't noticeable.

243
00:13:40,244 --> 00:13:41,985
That's the high-level gist of how it's put together.

244
00:13:42,005 --> 00:13:44,868
But there's a couple more pieces that helped sell the field.

245
00:13:45,708 --> 00:13:48,971
First, we tilt the normals of the grass blades outward a bit.

246
00:13:49,571 --> 00:13:52,474
This helps give the grass blades a more natural, rounded look,

247
00:13:52,834 --> 00:13:54,715
and it's a lot cheaper than adding more verts.

248
00:13:56,657 --> 00:13:58,298
We also ran into difficulties making

249
00:13:58,438 --> 00:14:00,120
the fields look full enough.

250
00:14:00,740 --> 00:14:02,661
Adding more grass blades was, of course, an option,

251
00:14:02,922 --> 00:14:04,223
but a rather expensive one.

252
00:14:05,904 --> 00:14:12,191
Instead, we slightly shift the blade's verts in view space when the blade's normal is orthogonal to the view vector.

253
00:14:12,811 --> 00:14:23,483
This subtly thickens the grass blade from the user's view, which both means we spend less time rasterizing very thin triangles, and the field has a fuller look.

254
00:14:25,850 --> 00:14:31,034
We also struggled with very aliased specular highlights in the mid to far distance, especially

255
00:14:31,074 --> 00:14:31,534
in the rain.

256
00:14:32,295 --> 00:14:36,679
The normals of the grass blades at that distance end up varying dramatically in screen space.

257
00:14:37,099 --> 00:14:40,442
And since the grass is very glossy, there was a lot of noise.

258
00:14:40,962 --> 00:14:43,184
As the grass animated, it ended up glittering.

259
00:14:45,770 --> 00:14:48,290
To help with this, as the distance to the camera increases,

260
00:14:48,710 --> 00:14:50,451
we start to lerp the outputted normal

261
00:14:50,511 --> 00:14:52,371
towards a common normal for the grass clump.

262
00:14:52,851 --> 00:14:54,912
This helps maintain the shape of the field

263
00:14:55,112 --> 00:14:56,272
while still reducing noise.

264
00:14:57,012 --> 00:14:59,473
Additionally, we reduce gloss in the pixel shader.

265
00:14:59,493 --> 00:15:01,873
This is reasonable if you think of gloss

266
00:15:01,933 --> 00:15:04,474
as a representation of how the surface normals vary

267
00:15:04,494 --> 00:15:05,914
at sub-pixel detail.

268
00:15:06,534 --> 00:15:09,675
Since the normal variance is increasing, we reduce gloss.

269
00:15:12,121 --> 00:15:13,881
So we have our grass blades and their verts.

270
00:15:14,482 --> 00:15:15,942
Now we just have to shade those triangles.

271
00:15:16,782 --> 00:15:19,443
Our grass outputs to our deferred renderer's G buffers,

272
00:15:19,663 --> 00:15:21,743
so all we have to do is come up with our material data.

273
00:15:22,823 --> 00:15:25,264
The gloss is a simple 1D texture that we

274
00:15:25,284 --> 00:15:26,724
stretch across the width of the blade

275
00:15:26,864 --> 00:15:27,945
and repeat down the length.

276
00:15:30,125 --> 00:15:31,825
For diffuse, we have two textures.

277
00:15:33,806 --> 00:15:35,386
The first works the same as gloss

278
00:15:35,546 --> 00:15:37,707
and gives the vein that runs down the grass blade

279
00:15:37,827 --> 00:15:39,307
and some variation over the width.

280
00:15:40,518 --> 00:15:43,940
The second is a 2D texture that contains the actual color

281
00:15:43,960 --> 00:15:44,541
information.

282
00:15:45,241 --> 00:15:47,182
The V dimension of the texture gives the color

283
00:15:47,362 --> 00:15:49,263
as it changes with the length of the blade.

284
00:15:49,964 --> 00:15:51,705
This lets the base of the blade of grass

285
00:15:51,765 --> 00:15:54,366
be dark and fade to a light color higher up, for instance.

286
00:15:55,066 --> 00:15:58,148
The U dimension of the texture is controlled by the clump

287
00:15:58,728 --> 00:16:00,089
the grass blade belongs to.

288
00:16:00,549 --> 00:16:02,070
Rather than each individual blade

289
00:16:02,110 --> 00:16:03,851
having its own random color, this

290
00:16:03,871 --> 00:16:05,432
lets us have splashes of variation

291
00:16:05,452 --> 00:16:07,373
throughout a field that can be controlled by artist

292
00:16:07,413 --> 00:16:07,913
preference.

293
00:16:08,706 --> 00:16:11,468
In practice, the color differences between clumps

294
00:16:11,568 --> 00:16:14,390
is often to be very small to maintain our painted look.

295
00:16:14,810 --> 00:16:17,132
But in the future, I think this is worth more experimentation.

296
00:16:18,793 --> 00:16:20,714
For translucency and ambient occlusion,

297
00:16:20,934 --> 00:16:22,875
we output constant values that vary

298
00:16:22,935 --> 00:16:24,416
over the length of the grass blade.

299
00:16:25,437 --> 00:16:27,959
The translucency is fairly low at the base of the grass blade

300
00:16:27,999 --> 00:16:30,160
where it's thickest and reduces towards the tip.

301
00:16:31,381 --> 00:16:34,123
AO functions the same, being dark near the base

302
00:16:34,263 --> 00:16:36,785
where the light is likely to be colluded by other grass blades

303
00:16:37,005 --> 00:16:37,845
and lighter towards the tip.

304
00:16:40,037 --> 00:16:42,038
OK, so the question you probably have

305
00:16:42,378 --> 00:16:45,180
is why do we output AO values at all instead

306
00:16:45,200 --> 00:16:46,581
of just relying on an SSAO?

307
00:16:47,081 --> 00:16:49,363
Well, our grass doesn't write velocity

308
00:16:49,383 --> 00:16:50,323
to our velocity buffer.

309
00:16:52,505 --> 00:16:54,286
The stateless nature of the grass blades

310
00:16:54,426 --> 00:16:56,267
makes it a bit difficult but doable.

311
00:16:56,948 --> 00:16:58,969
To find the position of the previous frame's vertex,

312
00:16:59,349 --> 00:17:01,351
we'd need to cache off last frame's wind data,

313
00:17:01,831 --> 00:17:03,592
since wind speed and direction can be changing.

314
00:17:04,253 --> 00:17:05,814
We'd also need to have the displacement

315
00:17:05,834 --> 00:17:07,975
buffer from last frame in case the player was

316
00:17:08,035 --> 00:17:09,056
walking over this grass.

317
00:17:10,662 --> 00:17:14,084
And since a lot of wind and displacement information is processed in the compute shader,

318
00:17:14,465 --> 00:17:17,887
we'd need to store the process data per blade for the vertex shaders to consume.

319
00:17:17,908 --> 00:17:23,092
This is all very possible, but the performance and memory constraints made it impractical.

320
00:17:23,932 --> 00:17:29,317
That said, if we did produce the velocity data for our temporally accumulated SSIO to consume,

321
00:17:29,737 --> 00:17:33,480
the way the GRASS works makes it a poor target for temporally accumulated effects.

322
00:17:34,543 --> 00:17:37,368
the grass blades constantly wave back and forth over each other,

323
00:17:37,388 --> 00:17:39,652
occluding and disoccluding nonstop.

324
00:17:40,033 --> 00:17:42,538
So even if we did spend the perf to get correct velocities,

325
00:17:42,558 --> 00:17:45,463
our AO would end up a splotchy and glittery mess.

326
00:17:51,364 --> 00:17:54,107
So we have lots of sufficiently convincing grass blades,

327
00:17:54,547 --> 00:17:57,230
but fields are not just endless blades of grass

328
00:17:57,310 --> 00:17:57,951
most of the time.

329
00:17:58,651 --> 00:18:01,314
To complete the appearance, we also procedurally place

330
00:18:01,534 --> 00:18:03,877
full artist-authored assets throughout the fields.

331
00:18:04,677 --> 00:18:07,380
This lets us easily add things like spider lilies,

332
00:18:07,600 --> 00:18:10,543
tiny flowers, or most often, pampas grass.

333
00:18:11,384 --> 00:18:13,626
Our growth systems use a GPU instance draw system

334
00:18:13,666 --> 00:18:14,487
instead of a single layer.

335
00:18:14,567 --> 00:18:15,928
of creating full game objects.

336
00:18:16,628 --> 00:18:19,969
The growth systems effectively output a stream of minimal data,

337
00:18:20,289 --> 00:18:22,650
just position, orientation, and calling information,

338
00:18:22,670 --> 00:18:25,650
and then draws large number of assets from that.

339
00:18:26,331 --> 00:18:27,771
For more information on our growth systems,

340
00:18:28,011 --> 00:18:29,832
check out my colleague Matt Pullman's talk,

341
00:18:30,232 --> 00:18:32,633
Samurai Landscapes, Building and Rendering Tsushima Island

342
00:18:32,793 --> 00:18:33,133
on PS4.

343
00:18:35,728 --> 00:18:37,869
When we load a tile, we run a compute shader

344
00:18:38,009 --> 00:18:39,710
that generates the same data stream

345
00:18:39,870 --> 00:18:41,430
for the procedural grass field assets

346
00:18:41,550 --> 00:18:42,631
that the gross systems use.

347
00:18:43,531 --> 00:18:46,692
We keep the nearest 3 by 3 tiles to the camera in memory

348
00:18:47,092 --> 00:18:48,533
and drop anything out of that, so we

349
00:18:48,553 --> 00:18:50,834
don't burn too much keeping distant assets around.

350
00:18:51,754 --> 00:18:54,215
The placement algorithm works similar to the grass blades.

351
00:18:54,635 --> 00:18:56,876
It picks a position in the tile, randomly

352
00:18:56,916 --> 00:18:59,397
generates it, then checks to see if the type of grass

353
00:18:59,417 --> 00:19:00,957
at that spot matches its type.

354
00:19:01,677 --> 00:19:04,038
If so, it adds procedural transform data to the stream

355
00:19:04,218 --> 00:19:04,918
to be rendered later.

356
00:19:07,190 --> 00:19:09,191
I initially had just dubbed in the random jitter

357
00:19:09,211 --> 00:19:11,291
to come back and try and do something more complex.

358
00:19:11,712 --> 00:19:13,452
But by the time I found time to do so,

359
00:19:13,592 --> 00:19:15,073
the artist had already used the system

360
00:19:15,413 --> 00:19:18,114
to place these rice crops, which worked pretty great.

361
00:19:18,394 --> 00:19:19,655
So I just left it as is.

362
00:19:22,056 --> 00:19:23,856
One of the biggest struggles we had with grass

363
00:19:24,036 --> 00:19:25,757
was how to handle very far lods.

364
00:19:26,858 --> 00:19:28,458
The island of Tsushima has locations

365
00:19:28,478 --> 00:19:30,199
the player can get to that let them see

366
00:19:30,339 --> 00:19:31,799
almost the entire island at once.

367
00:19:32,220 --> 00:19:33,640
And rendering grass blades out that far

368
00:19:33,940 --> 00:19:35,161
is obviously impractical.

369
00:19:36,090 --> 00:19:37,731
I experimented with some view-dependent ways

370
00:19:37,771 --> 00:19:39,472
of running the terrain that were driven by the clump

371
00:19:39,512 --> 00:19:40,013
information.

372
00:19:40,673 --> 00:19:44,195
After all, if the clumps drive the normals,

373
00:19:44,635 --> 00:19:46,256
they should be able to control the far view where

374
00:19:46,276 --> 00:19:47,237
the normal is dominant.

375
00:19:48,578 --> 00:19:51,500
Unfortunately, this ended up being impractically expensive.

376
00:19:52,220 --> 00:19:54,501
Additionally, once we later added the artist-authored

377
00:19:54,581 --> 00:19:56,463
assets I mentioned a bit ago, this approach

378
00:19:56,503 --> 00:19:57,163
wouldn't have worked.

379
00:19:57,683 --> 00:19:59,464
Large fields of bright red spider lilies

380
00:19:59,484 --> 00:20:00,725
would have blotted out to green grass.

381
00:20:03,029 --> 00:20:05,830
So instead, we chose to render an artist-authored texture

382
00:20:06,011 --> 00:20:07,471
at that place in the terrain instead

383
00:20:07,491 --> 00:20:08,552
of the underlying material.

384
00:20:09,352 --> 00:20:11,653
This approach is inexpensive and works well enough,

385
00:20:12,334 --> 00:20:14,335
but there is still room for improvement here.

386
00:20:17,424 --> 00:20:19,425
In Ghost, the player can hide in the grass

387
00:20:19,725 --> 00:20:22,567
to surprise assassinate Mongols and be generally sneaky.

388
00:20:23,208 --> 00:20:26,270
Since all of our grass data is stored on GPU-friendly textures

389
00:20:26,330 --> 00:20:28,472
that aren't convenient to access on CPU,

390
00:20:28,972 --> 00:20:31,314
whenever we load a tile, we run a compute shader

391
00:20:31,374 --> 00:20:34,056
that copies some information from our fast GPU textures

392
00:20:34,496 --> 00:20:35,957
to more CPU-friendly ones.

393
00:20:36,898 --> 00:20:38,719
From this hide information, we generate

394
00:20:38,799 --> 00:20:41,921
fizz meshes that gameplay can raycast against to determine

395
00:20:41,961 --> 00:20:43,022
if the player is visible or not.

396
00:20:44,252 --> 00:20:46,674
We originally returned the height of the grass unmodified,

397
00:20:47,014 --> 00:20:49,116
but found that this could be pretty inconsistent.

398
00:20:49,756 --> 00:20:52,518
Instead, each type of grass is either flagged as stealth grass

399
00:20:52,678 --> 00:20:55,401
or decorative grass and returns a constant height

400
00:20:55,441 --> 00:20:56,121
based on that.

401
00:20:56,802 --> 00:21:02,887
For consistency reasons, each stealth grass type

402
00:21:02,927 --> 00:21:05,249
has pampas flowers in it, but the actual stealthiness

403
00:21:05,309 --> 00:21:06,510
comes from the grass itself.

404
00:21:09,332 --> 00:21:11,734
We also had to do some special optimizations for shadows.

405
00:21:12,554 --> 00:21:15,276
We do support running the full compute and vertex pixel shader

406
00:21:15,316 --> 00:21:18,178
pipe for shadow casting lights, but it's very expensive,

407
00:21:18,338 --> 00:21:20,780
considering it has to run for each light at least once.

408
00:21:21,680 --> 00:21:23,302
Though we do this in some rare cases,

409
00:21:23,682 --> 00:21:25,843
we generally rely on an imposter system

410
00:21:25,943 --> 00:21:27,465
that uses the underlying terrain.

411
00:21:29,166 --> 00:21:31,427
Effectively, we raise the verts of the terrain

412
00:21:31,587 --> 00:21:33,789
to match the height of the grass at that location,

413
00:21:34,149 --> 00:21:36,411
then offset the depth we write out to the shadow map

414
00:21:36,471 --> 00:21:37,411
in a dithered pattern.

415
00:21:38,157 --> 00:21:40,018
When we combine this with our shadow filtering,

416
00:21:40,418 --> 00:21:42,300
we end up with a result that roughly matches

417
00:21:42,320 --> 00:21:43,761
the shadow density of the grass.

418
00:21:44,301 --> 00:21:45,582
It's not without its issues, though.

419
00:21:45,943 --> 00:21:47,664
The discrete nature of the proxy mesh

420
00:21:47,964 --> 00:21:50,546
can end up with hard edges that are difficult to resolve.

421
00:21:51,207 --> 00:21:54,990
But in the majority of scenes in the game, the results were good

422
00:21:55,190 --> 00:21:56,070
and the perf was great.

423
00:21:58,152 --> 00:22:00,874
For more fine detail, we relied on screen space shadows

424
00:22:00,914 --> 00:22:01,755
to make up the difference.

425
00:22:02,415 --> 00:22:03,916
Screen space shadows can't understand

426
00:22:03,936 --> 00:22:07,159
the thickness of objects when our grass is super thin anyway.

427
00:22:08,502 --> 00:22:10,443
They're limited to short range and screen space,

428
00:22:10,843 --> 00:22:12,584
but our grass is pretty small in screen space

429
00:22:12,604 --> 00:22:13,464
the majority of the time.

430
00:22:14,205 --> 00:22:15,866
They don't account for off-screen geometry,

431
00:22:16,006 --> 00:22:17,806
but again, with our grass being small,

432
00:22:18,887 --> 00:22:21,688
nothing off-screen is going to have a huge impact on what's

433
00:22:21,988 --> 00:22:22,929
on-screen anyway.

434
00:22:23,909 --> 00:22:26,690
So between our imposter geometry and the screen space shadows,

435
00:22:27,111 --> 00:22:29,071
we end up with a decent quality shadows that

436
00:22:29,111 --> 00:22:30,212
don't blow our perf budget.

437
00:22:32,333 --> 00:22:33,633
And here's the in-game result.

438
00:22:38,425 --> 00:22:41,227
Moving forward, there's a few improvements to the system that I'd like to make.

439
00:22:42,048 --> 00:22:46,612
First, at many times during production, an artist will be placing an asset that they want to grass on,

440
00:22:46,952 --> 00:22:48,894
but we are strictly limited to grass on terrain.

441
00:22:50,379 --> 00:22:52,560
Assets have an option to sample the terrain materials

442
00:22:52,600 --> 00:22:55,142
when intersecting the ground and blend the material

443
00:22:55,403 --> 00:22:57,524
to the terrain's material to have smooth transitions

444
00:22:57,604 --> 00:22:59,066
from the height map control terrain

445
00:22:59,506 --> 00:23:00,807
to artist authored assets.

446
00:23:01,488 --> 00:23:03,850
But since the grass couldn't be placed on those assets,

447
00:23:04,170 --> 00:23:07,332
there was often an awkward edge or worse grass poking out

448
00:23:07,372 --> 00:23:08,593
from underneath the asset.

449
00:23:09,474 --> 00:23:11,035
In the future, I think it would be worthwhile

450
00:23:11,075 --> 00:23:14,198
to have artist authored geometry flagged as a grass surface

451
00:23:14,618 --> 00:23:16,300
that we can procedurally grow blades from.

452
00:23:16,940 --> 00:23:18,822
Then the transition between assets and the terrain

453
00:23:18,842 --> 00:23:19,823
could be truly seamless.

454
00:23:22,272 --> 00:23:24,934
Second, the cubic Bezier vertices we produce now

455
00:23:25,074 --> 00:23:27,176
are quite flexible and fast, but there

456
00:23:27,196 --> 00:23:29,157
are a lot of other types of dense foliage

457
00:23:29,197 --> 00:23:30,378
that we could procedurally place.

458
00:23:30,918 --> 00:23:33,420
Ferns, inco leaves, or even small rocks

459
00:23:33,500 --> 00:23:35,781
could have a very similar vertex count to our current grass,

460
00:23:36,342 --> 00:23:38,883
but would be more difficult to procedurally generate.

461
00:23:40,004 --> 00:23:42,326
Artist-driven assets support, especially when

462
00:23:42,346 --> 00:23:44,827
combined with being able to grow it on arbitrary surfaces,

463
00:23:44,948 --> 00:23:46,008
could be very powerful.

464
00:23:46,729 --> 00:23:48,830
Maybe we could grow fur cards for high detailed animals.

465
00:23:49,631 --> 00:23:51,212
I'm not sure, but it's something I want to experiment with

466
00:23:51,232 --> 00:23:51,692
in the future.

467
00:23:54,157 --> 00:23:56,978
Third, because each rendered tile is twice the size

468
00:23:56,998 --> 00:23:58,759
of the previous tile, by the time

469
00:23:58,779 --> 00:24:00,399
we've switched to the next tile size up,

470
00:24:00,539 --> 00:24:02,640
we've dropped three out of every four grass blades.

471
00:24:03,461 --> 00:24:05,281
Each tile has the same number of grass blades,

472
00:24:05,461 --> 00:24:06,642
which is nice and simple.

473
00:24:07,362 --> 00:24:09,423
However, this means that we're tied to lotting out

474
00:24:09,483 --> 00:24:11,604
3 4ths of our grass blades at a distance that

475
00:24:11,664 --> 00:24:12,825
isn't very easy to change.

476
00:24:13,745 --> 00:24:16,506
In the future, we want to disassociate the lotting out

477
00:24:16,546 --> 00:24:19,507
from the size of a tile more, so we can push our grass distance

478
00:24:19,567 --> 00:24:20,188
out more easily.

479
00:24:22,705 --> 00:24:25,026
So that's how we rendered huge fields of grass

480
00:24:25,066 --> 00:24:27,507
within our frame budget and met our art direction goals.

481
00:24:28,147 --> 00:24:31,029
We used compute shaders to generate per grass blade

482
00:24:31,149 --> 00:24:33,690
instance data that was highly artist configurable,

483
00:24:34,110 --> 00:24:37,372
then used indirect draw calls to get almost 100,000 Bezier

484
00:24:37,512 --> 00:24:38,312
curves on screen.

485
00:24:38,952 --> 00:24:41,053
We supplemented these simple grass blades

486
00:24:41,213 --> 00:24:42,954
with procedurally placed artist assets

487
00:24:43,374 --> 00:24:45,936
and used very simple imposters for shadows and far lods.

488
00:24:47,116 --> 00:24:48,457
Although there's still improvements to be made,

489
00:24:48,857 --> 00:24:50,718
we're happy with the results we managed to achieve.

490
00:24:53,438 --> 00:24:55,380
If you have any questions about what we did or how we did it,

491
00:24:55,920 --> 00:24:57,261
feel free to reach out to me on Twitter.

492
00:24:57,461 --> 00:24:58,842
I'd love to answer any questions you have.

493
00:24:58,862 --> 00:25:02,164
I also want to thank a bunch of people

494
00:25:02,204 --> 00:25:03,985
who worked on the grass and goats at Tsushima with me.

495
00:25:04,706 --> 00:25:07,167
Jasmine Petrie for doing all the hard work

496
00:25:07,207 --> 00:25:08,468
of the initial prototype and then

497
00:25:08,488 --> 00:25:10,429
letting me just make things wiggle for a couple of years.

498
00:25:11,550 --> 00:25:13,932
Bill Rockenbeck for helping me fix countless floating point

499
00:25:13,952 --> 00:25:14,712
precision issues.

500
00:25:15,333 --> 00:25:17,754
Adrian Bentley for letting me break down his office door

501
00:25:17,894 --> 00:25:18,955
and berate him with questions.

502
00:25:19,435 --> 00:25:21,316
Matt Pullman for making the whole thing actually

503
00:25:21,397 --> 00:25:22,277
usable for artists.

504
00:25:23,280 --> 00:25:25,261
Tom Lowe for all his awesome shadow work,

505
00:25:25,901 --> 00:25:28,723
Dave Elder for his great offline terrain AO baking,

506
00:25:29,343 --> 00:25:31,685
and Joanna Wang for endlessly tweaking the two score

507
00:25:31,705 --> 00:25:34,086
parameters it took to make a rat's nest of vertices

508
00:25:34,126 --> 00:25:35,327
look like actual grass.

509
00:25:37,468 --> 00:25:39,610
And as a last note, I'd like to point out that we're hiring.

510
00:25:40,530 --> 00:25:42,592
We have graphics and gameplay programmer positions

511
00:25:42,612 --> 00:25:43,712
we're looking to pick people up for.

512
00:25:43,832 --> 00:25:45,453
So if you're interested by what we're working on,

513
00:25:45,713 --> 00:25:46,354
please reach out.

514
00:25:47,254 --> 00:25:48,675
Thank you so much for watching my talk,

515
00:25:49,075 --> 00:25:49,796
and I hope you have a good day.

516
00:25:52,723 --> 00:25:55,668
And here's the Altera blog post I promised earlier.

517
00:25:55,868 --> 00:25:56,910
You should definitely check it out.

