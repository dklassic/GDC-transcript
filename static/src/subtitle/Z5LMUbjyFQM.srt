1
00:00:04,307 --> 00:00:11,297
My name is Lerna and I'm a programmer at Paradox Development Studio, which is based in Stockholm.

2
00:00:12,218 --> 00:00:13,239
We do strategy games.

3
00:00:14,081 --> 00:00:19,728
Christian down here, he told me that this is going to be the shortest Paradox experience

4
00:00:19,848 --> 00:00:21,210
ever, and I think that's true.

5
00:00:24,016 --> 00:00:29,238
I've worked in the Stellaris team the past two and a half years, and I came in quite

6
00:00:29,338 --> 00:00:30,918
early into the team.

7
00:00:31,698 --> 00:00:34,539
We were like five people at that time or something.

8
00:00:35,579 --> 00:00:37,080
And I worked mostly on the AI.

9
00:00:37,100 --> 00:00:45,242
And this talk is about how to break down like a massive universe of complex elements into

10
00:00:45,342 --> 00:00:50,623
manageable variables to create emergent NPCs in the game.

11
00:00:52,665 --> 00:00:56,009
Before I start, I just want to ask, how many of you are designers?

12
00:00:58,552 --> 00:00:58,832
Okay.

13
00:00:59,913 --> 00:01:00,974
Like a third or something.

14
00:01:01,195 --> 00:01:01,915
And programmers?

15
00:01:03,297 --> 00:01:03,657
The rest.

16
00:01:03,898 --> 00:01:04,118
Okay.

17
00:01:09,964 --> 00:01:10,284
Right.

18
00:01:11,486 --> 00:01:12,367
So the agenda.

19
00:01:13,384 --> 00:01:18,888
Well, the background of this presentation is that we make really complex games in terms

20
00:01:18,988 --> 00:01:26,013
of the amount of input and the dependencies that the AI needs to process to create a human-like

21
00:01:26,053 --> 00:01:26,474
behavior.

22
00:01:26,954 --> 00:01:33,519
So it's really about how we use data-driven design to solve this and make complex AI simple.

23
00:01:34,727 --> 00:01:37,768
What I will be covering today is a presentation of the game,

24
00:01:38,229 --> 00:01:40,510
why data-driven design is used in the AI,

25
00:01:40,770 --> 00:01:42,852
some concrete examples of how we do this,

26
00:01:44,192 --> 00:01:47,414
and a few things to keep in mind with this method.

27
00:01:47,434 --> 00:01:50,856
And finally, I will summarize it all,

28
00:01:50,896 --> 00:01:52,938
and hopefully we'll have some time for questions.

29
00:01:56,000 --> 00:01:58,041
So Stellaris is a grand strategy game

30
00:01:58,081 --> 00:02:00,602
where you play an empire managing your resources,

31
00:02:02,063 --> 00:02:04,225
economy, politics, or diplomacy.

32
00:02:05,940 --> 00:02:10,661
and military in order to survive in space and hopefully expand.

33
00:02:12,101 --> 00:02:15,062
Unlike our other games, Stellaris is a non-historical game.

34
00:02:16,083 --> 00:02:20,444
So the AI is quite different, but it still

35
00:02:20,524 --> 00:02:22,604
follows the general theme of our games

36
00:02:23,084 --> 00:02:26,225
with high replayability, depth, and subject matter.

37
00:02:30,617 --> 00:02:33,358
So here you see the galaxy map in Stellaris.

38
00:02:33,838 --> 00:02:36,359
Every colored circle on this map is an empire

39
00:02:36,859 --> 00:02:38,340
with a different set of behaviors.

40
00:02:38,960 --> 00:02:41,401
What's important to understand about our games

41
00:02:41,521 --> 00:02:44,442
is that the AI needs to do exactly the same thing

42
00:02:44,783 --> 00:02:45,863
as a human player.

43
00:02:46,823 --> 00:02:50,225
So it needs to last throughout the game.

44
00:02:50,385 --> 00:02:53,826
And this creates a very different challenge

45
00:02:54,367 --> 00:02:57,168
compared to other games where the AIs might be obstacles

46
00:02:57,268 --> 00:02:58,628
instead of opponents.

47
00:03:03,852 --> 00:03:07,493
I prepared a short trailer for you to see.

48
00:03:07,513 --> 00:03:09,394
Pegi 12.

49
00:03:17,038 --> 00:03:21,119
Ever since the dawn of our civilization, we've been reaching for the heavens.

50
00:03:22,280 --> 00:03:24,341
Our first man rocket was a crude device.

51
00:03:25,252 --> 00:03:27,533
far more advanced vessels would follow.

52
00:03:28,614 --> 00:03:31,356
But for two centuries, we stared longingly

53
00:03:31,376 --> 00:03:34,579
at the vast ocean of stars beyond our solar system,

54
00:03:35,640 --> 00:03:38,222
fearing them forever out of reach.

55
00:03:38,702 --> 00:03:42,705
Then, in one swooped stroke, the invention of the warp drive

56
00:03:42,825 --> 00:03:43,846
changed our world.

57
00:03:44,287 --> 00:03:47,989
A new frontier loomed, and the start of an intense race

58
00:03:48,029 --> 00:03:51,092
to colonize the far reaches of space began.

59
00:03:51,632 --> 00:03:52,813
We named her Nepsis.

60
00:03:54,454 --> 00:03:57,074
9,000 brave souls heading toward an issue.

61
00:03:57,114 --> 00:04:01,615
The star most likely to have an orbiting planet suitable for our first colony.

62
00:04:02,916 --> 00:04:06,536
Four months, two weeks, and five days into the mission,

63
00:04:06,956 --> 00:04:09,297
we received NEPSIS' final message.

64
00:04:09,697 --> 00:04:11,938
Panicked voices broken by static.

65
00:04:11,998 --> 00:04:14,658
An alien message impossible to decipher.

66
00:04:15,098 --> 00:04:17,759
Then nothing.

67
00:04:17,979 --> 00:04:21,300
Our first generation of warships would lead the rescue operation.

68
00:04:22,592 --> 00:04:27,013
When we arrived, we soon located the remains of Nefsis floating in the darkness.

69
00:04:27,133 --> 00:04:33,875
And approaching us, a fleet of alien warships, their technology far beyond ours.

70
00:04:34,355 --> 00:04:41,997
Using salvaged technology from Nefsis, these alien entities had managed to decipher our communications.

71
00:04:42,017 --> 00:04:43,417
So they recounted the story.

72
00:04:44,197 --> 00:04:47,278
A large, unidentified ship had entered their system.

73
00:04:47,698 --> 00:04:51,619
Despite repeated warnings, it would not change course, and a trigger was pulled.

74
00:04:54,242 --> 00:04:58,289
It is a galaxy full of danger, but also opportunity.

75
00:04:58,329 --> 00:05:04,679
There are an untold number of species, border disputes, political tension, and betrayal.

76
00:05:05,120 --> 00:05:06,903
Not that different from home.

77
00:05:14,858 --> 00:05:18,160
All right, so now you should have a decent idea

78
00:05:18,240 --> 00:05:18,961
about the game.

79
00:05:19,321 --> 00:05:22,804
So let's go into why we chose to use data-driven design.

80
00:05:26,287 --> 00:05:28,028
Some of the benefits of this method,

81
00:05:28,068 --> 00:05:29,569
which you're probably familiar with,

82
00:05:30,270 --> 00:05:32,171
is separating the data from the logic,

83
00:05:32,551 --> 00:05:36,695
making the data accessible to scripters and designers.

84
00:05:38,145 --> 00:05:40,386
It's also a good way of controlling state changes

85
00:05:40,466 --> 00:05:42,447
from the input data rather than in code,

86
00:05:43,428 --> 00:05:45,889
as well as a modular way of building features.

87
00:05:47,029 --> 00:05:50,911
These are general benefits, but I want to go more into depth

88
00:05:51,031 --> 00:05:54,272
about why Stellaris benefits from this model.

89
00:05:57,193 --> 00:05:59,514
First of all, we make content-heavy games.

90
00:05:59,875 --> 00:06:01,075
To the left on the picture,

91
00:06:01,555 --> 00:06:03,456
you have a list of the current information

92
00:06:03,476 --> 00:06:07,038
that the AI needs to process to output certain behaviors.

93
00:06:08,111 --> 00:06:11,572
As you can see, our AI needs to handle a large set of data.

94
00:06:11,872 --> 00:06:14,013
And it needs to process each of these elements

95
00:06:14,093 --> 00:06:18,194
differently, depending on the dependencies that they have.

96
00:06:18,994 --> 00:06:21,655
So for example, a policy can be locked

97
00:06:21,775 --> 00:06:25,897
by a technology, which you need to research.

98
00:06:26,777 --> 00:06:29,718
And whether the AI wants to have that policy or not

99
00:06:29,758 --> 00:06:32,499
can depend on the empire ethos or government

100
00:06:32,559 --> 00:06:33,499
type or something else.

101
00:06:35,294 --> 00:06:40,056
If we would use the concept of state machines, behavior trees, or decision trees for the

102
00:06:40,176 --> 00:06:45,719
AI, we would need to go through all the combinations that these elements in the list can create

103
00:06:45,739 --> 00:06:46,300
with each other.

104
00:06:47,180 --> 00:06:52,903
And not only would that be time consuming, it will cause probably massive performance

105
00:06:52,964 --> 00:06:59,107
issues and still result in a rather predictable AI, which is the opposite of what we want.

106
00:07:00,353 --> 00:07:04,154
So in short, there are multiple valid options for AI

107
00:07:04,534 --> 00:07:06,295
to make at each decision point.

108
00:07:06,855 --> 00:07:10,497
And we want to pick the ones that

109
00:07:10,557 --> 00:07:15,098
are most reasonable rather than the best one every single time.

110
00:07:16,739 --> 00:07:19,980
It's also worth mentioning that the term utility AI

111
00:07:20,020 --> 00:07:21,941
has been thrown around a lot these days.

112
00:07:22,601 --> 00:07:27,803
And this is probably something that falls under that category.

113
00:07:32,156 --> 00:07:36,238
All right, so secondly, our games should have high replayability.

114
00:07:36,618 --> 00:07:38,019
This is one of our game pillars.

115
00:07:38,539 --> 00:07:42,681
This is important because we want our players to be able to play the games for a long time.

116
00:07:43,835 --> 00:07:46,678
One example of how we satisfy this condition in the game

117
00:07:47,198 --> 00:07:49,400
is by having randomly generated galaxies,

118
00:07:49,660 --> 00:07:51,001
including random AIs.

119
00:07:51,922 --> 00:07:54,865
We don't really know what qualities the AI will have

120
00:07:54,965 --> 00:07:57,107
until we've started that particular session.

121
00:07:57,887 --> 00:08:00,329
So working with data-driven design in our way

122
00:08:00,429 --> 00:08:02,831
enables emergent behavior for the AI.

123
00:08:03,092 --> 00:08:05,914
And it can basically make decisions in situations

124
00:08:05,974 --> 00:08:08,156
that the designers or the programmers

125
00:08:08,776 --> 00:08:11,719
or anyone else for the matter in the team hasn't foreseen.

126
00:08:13,081 --> 00:08:16,763
It also creates that sense of uniqueness and unpredictability

127
00:08:16,803 --> 00:08:20,005
that you want to have when playing against NPCs.

128
00:08:24,467 --> 00:08:27,608
Another thing is that our games have long lifetimes.

129
00:08:28,489 --> 00:08:30,210
Crusader Kings was released in 2012,

130
00:08:30,870 --> 00:08:33,672
and we still make new content for it today.

131
00:08:34,712 --> 00:08:38,754
And this is not only because we want to keep our fans happy.

132
00:08:38,774 --> 00:08:41,916
It's also to be able to release.

133
00:08:44,911 --> 00:08:46,392
grow our player base, sorry.

134
00:08:47,452 --> 00:08:50,515
And I wanted to give you some numbers here,

135
00:08:50,615 --> 00:08:53,436
but since our IPO, we've been really secret

136
00:08:53,496 --> 00:08:55,938
with all the numbers, so you just have to take my word

137
00:08:55,978 --> 00:09:00,001
for it, but we've like massively increased our player base

138
00:09:00,021 --> 00:09:03,703
since we first released Crusader Kings until now.

139
00:09:06,805 --> 00:09:10,006
To be able to add content years after release,

140
00:09:10,126 --> 00:09:15,188
we need to have a game that is easy to add new content

141
00:09:15,228 --> 00:09:16,828
with little support from programmers,

142
00:09:16,868 --> 00:09:19,569
because we have really small teams at Paradox.

143
00:09:20,549 --> 00:09:23,070
And the teams are even smaller after release.

144
00:09:24,571 --> 00:09:30,193
We also want to be able to rebalance and scale the game.

145
00:09:33,207 --> 00:09:36,028
Worth mentioning is that Crusader Kings only has one

146
00:09:36,068 --> 00:09:37,229
programmer at the moment.

147
00:09:37,929 --> 00:09:40,851
So just imagine if he would spend all his time on the AI.

148
00:09:44,673 --> 00:09:47,014
Finally, we want our games to be moddable.

149
00:09:47,995 --> 00:09:50,136
This is one of my favorite mods where you can determine

150
00:09:50,176 --> 00:09:53,738
the shape of the galaxy, in this case, the PDX logo.

151
00:09:54,759 --> 00:09:58,641
By being mod-friendly, we enable ourselves to create a

152
00:09:58,661 --> 00:10:00,482
strong connection to our community.

153
00:10:01,748 --> 00:10:04,549
and to learn from people outside the studio.

154
00:10:05,209 --> 00:10:07,610
It's part of our mission to make games

155
00:10:07,670 --> 00:10:09,690
where the players can create their own stories,

156
00:10:10,651 --> 00:10:12,271
and this is one way of doing that.

157
00:10:15,372 --> 00:10:18,112
So to sum it up, the NPCs in Stellaris

158
00:10:18,152 --> 00:10:20,833
need to be scalable for new content, moddable,

159
00:10:21,093 --> 00:10:23,333
be able to transform a large set of data

160
00:10:23,833 --> 00:10:25,794
to different behaviors, and be unique

161
00:10:25,834 --> 00:10:28,475
in order to support game replayability.

162
00:10:29,514 --> 00:10:32,876
Now you know the why, so let's go into how it's implemented.

163
00:10:32,896 --> 00:10:42,982
Alright, so the tools for this is really, really simple.

164
00:10:44,543 --> 00:10:48,885
We have a trigger, in this case we have an hasEthic trigger.

165
00:10:50,829 --> 00:10:55,634
that checks if a certain scope, for example an empire,

166
00:10:55,654 --> 00:11:00,500
is militarist or not, which is an ethos or ethic.

167
00:11:02,202 --> 00:11:04,065
And this trigger returns true

168
00:11:04,285 --> 00:11:07,869
if that condition is satisfied, else false.

169
00:11:09,515 --> 00:11:15,802
That trigger we can then use to put a certain weight on one of our objects in the database.

170
00:11:16,382 --> 00:11:23,229
And most of our elements are objects in a database, like buildings, traditions, ascension

171
00:11:23,250 --> 00:11:26,473
perks, policies, edicts, and so on.

172
00:11:27,834 --> 00:11:31,738
So every building has an AI weight.

173
00:11:34,822 --> 00:11:37,704
There is a base, say 10 in this case,

174
00:11:38,224 --> 00:11:42,128
and then we add a modifier where we use that trigger

175
00:11:42,348 --> 00:11:45,190
to check if this is militarist,

176
00:11:45,851 --> 00:11:49,594
then we will multiply it by a factor of two.

177
00:11:53,117 --> 00:11:56,920
And later then in code, we use all these weights

178
00:11:57,120 --> 00:12:00,443
to randomize which of these we're gonna use.

179
00:12:01,799 --> 00:12:04,041
So say we have three options, A, B, and C,

180
00:12:04,621 --> 00:12:06,864
and they have the different weights of five, five, and 10.

181
00:12:07,805 --> 00:12:08,846
Then we have a total weight of 20,

182
00:12:09,346 --> 00:12:11,869
and the chances for each of these being chosen

183
00:12:11,929 --> 00:12:12,249
is 25, 25, and 50%.

184
00:12:20,071 --> 00:12:23,033
Here are some other examples, because we don't have to

185
00:12:23,134 --> 00:12:26,957
randomize the weights every single time.

186
00:12:27,417 --> 00:12:31,320
We can, for example, just use the weight that is highest,

187
00:12:32,161 --> 00:12:33,922
like we do with policies, for example.

188
00:12:34,943 --> 00:12:42,810
We can also have an allow trigger that we use to not

189
00:12:42,970 --> 00:12:45,612
even add that object to the list of weights.

190
00:12:46,353 --> 00:12:47,874
So we basically just skip it.

191
00:12:49,392 --> 00:12:53,934
And the final way or example that I'm

192
00:12:53,974 --> 00:12:56,235
going to tell you about today is that we

193
00:12:56,275 --> 00:12:57,456
can use it as fractions.

194
00:12:57,616 --> 00:13:01,598
So say you have unlocked the tech for cruisers,

195
00:13:02,798 --> 00:13:05,339
and you only want the AI to build cruisers from now.

196
00:13:05,519 --> 00:13:08,861
Then you just set the weights of corvettes and destroyers

197
00:13:08,901 --> 00:13:10,862
to zero once that tech is unlocked.

198
00:13:11,782 --> 00:13:14,143
And every time the AI will build a new ship,

199
00:13:14,323 --> 00:13:15,724
it will just build a cruiser.

200
00:13:19,282 --> 00:13:21,164
All right, so all of these tools are great,

201
00:13:21,224 --> 00:13:23,986
but if they're just used independently and randomly,

202
00:13:24,666 --> 00:13:29,030
it's really hard to create that sense of good game balance

203
00:13:29,310 --> 00:13:31,232
and a human-like AI.

204
00:13:32,453 --> 00:13:36,075
So we want to be able to expect a certain behavior.

205
00:13:36,916 --> 00:13:39,498
And similar to a human player, it

206
00:13:39,538 --> 00:13:41,319
should have a certain style of playing,

207
00:13:41,800 --> 00:13:44,342
but still have room for some unpredictability.

208
00:13:44,882 --> 00:13:46,884
And for this, we implemented personalities.

209
00:13:48,525 --> 00:13:50,786
Going back to this image that I showed you earlier,

210
00:13:52,187 --> 00:13:54,988
every colored circle represents an empire in our game.

211
00:13:55,008 --> 00:13:59,829
And each of the empires that are played by NPCs

212
00:14:00,049 --> 00:14:01,550
have been assigned a personality.

213
00:14:01,870 --> 00:14:05,251
And this will be like their backbone of their behavior.

214
00:14:09,907 --> 00:14:14,891
The personalities are visualized in the game in the diplomacy screens and every interaction

215
00:14:14,931 --> 00:14:19,694
with the AIs will enhance that experience through the dialogues.

216
00:14:20,294 --> 00:14:26,418
And it's really important here to actually connect the dialogues and the way of communicating

217
00:14:26,478 --> 00:14:30,121
with the personalities to get that realistic sense.

218
00:14:34,922 --> 00:14:37,904
So a quick description of how we choose the personalities.

219
00:14:37,984 --> 00:14:39,505
It's really, really simple.

220
00:14:40,485 --> 00:14:43,287
We just start off with, say, around 20 personalities.

221
00:14:44,287 --> 00:14:46,728
And each personality is weighted differently

222
00:14:46,809 --> 00:14:51,231
depending on traits, ethics, government type,

223
00:14:51,271 --> 00:14:52,371
whatever you add in script.

224
00:14:54,190 --> 00:14:58,853
And once we have this, we can then randomize which one.

225
00:14:59,653 --> 00:15:03,275
First, we actually will get two options, maybe, or more,

226
00:15:03,895 --> 00:15:09,398
that will render weights above zero.

227
00:15:10,999 --> 00:15:13,420
And from those two, we will randomize

228
00:15:13,460 --> 00:15:14,441
which one it will pick.

229
00:15:15,742 --> 00:15:19,043
And the personality then has a set of behaviors

230
00:15:19,183 --> 00:15:20,404
that is connected to it.

231
00:15:21,864 --> 00:15:25,665
So this is a way to make choices without having to randomize

232
00:15:25,705 --> 00:15:28,746
and calculate the behavior for the AI every single time.

233
00:15:29,786 --> 00:15:33,787
And it's the part of the AI that is predictable.

234
00:15:36,428 --> 00:15:37,848
In this case, for example,

235
00:15:37,928 --> 00:15:41,369
we have that hegemonic imperialists will enslave,

236
00:15:41,429 --> 00:15:44,990
they will not purge, they will build robots,

237
00:15:45,070 --> 00:15:49,231
they will conquer planets, they will vassalize, et cetera.

238
00:15:50,705 --> 00:15:55,110
I can also add that even the AI personalities are objects

239
00:15:55,230 --> 00:15:57,733
in the database that you can use for your triggers.

240
00:16:02,298 --> 00:16:04,480
OK, so one of the benefits with this model

241
00:16:04,620 --> 00:16:08,284
is that it's really easy to keep your code simple and clean.

242
00:16:09,824 --> 00:16:13,886
For the coming expansion, we added two features of traditions

243
00:16:14,006 --> 00:16:17,847
and ascension perks to enable more empire customization

244
00:16:18,667 --> 00:16:21,008
and to add more interesting choices for the player.

245
00:16:22,228 --> 00:16:26,030
And it's two fairly big features in terms of content.

246
00:16:26,050 --> 00:16:28,891
I'm sure our content designers will agree to that.

247
00:16:29,431 --> 00:16:32,592
But in terms of code, it was less than a day's work.

248
00:16:33,877 --> 00:16:37,979
So basically what we do in this code is we go through the list of ascension perks, we

249
00:16:38,019 --> 00:16:43,482
list all the weights, store them, and then we use a random weighted algorithm to choose

250
00:16:43,742 --> 00:16:45,383
which one of these we actually want.

251
00:16:46,403 --> 00:16:48,044
And then finally post a command to do it.

252
00:16:51,717 --> 00:16:56,762
Exposing as much of the AI as possible in a script does not only make the code easier.

253
00:16:57,523 --> 00:17:03,849
When you separate the AI design from programming, the programmer can focus on what she does

254
00:17:03,889 --> 00:17:08,874
best and will also have more time to allocate to other tasks.

255
00:17:09,975 --> 00:17:12,137
You also empower your content designers.

256
00:17:13,604 --> 00:17:23,912
Maybe I should add that content designers at Paradox are scripters and designers by enabling them to script the AI behavior independently from us.

257
00:17:28,012 --> 00:17:30,694
Similarly, it exposes the AI to the modders,

258
00:17:30,874 --> 00:17:32,856
which means that they can do a lot of cool stuff.

259
00:17:33,556 --> 00:17:37,139
As a side effect, though, they can easily introduce bugs

260
00:17:37,299 --> 00:17:38,820
or crashes into the game.

261
00:17:39,441 --> 00:17:42,263
We can, of course, reduce this by having good tool

262
00:17:42,283 --> 00:17:45,565
descriptions and adapting the code

263
00:17:45,605 --> 00:17:47,506
so that we can handle script errors.

264
00:17:47,887 --> 00:17:50,248
But the second part is easier said than done.

265
00:17:56,042 --> 00:17:59,344
Another benefit is that you will save a lot of time

266
00:17:59,444 --> 00:18:05,609
by being able to balance and tune the AI in game.

267
00:18:08,652 --> 00:18:09,593
I don't know about you,

268
00:18:09,653 --> 00:18:12,575
but I spend quite some time compiling,

269
00:18:13,136 --> 00:18:14,457
so I rather not do that.

270
00:18:20,081 --> 00:18:21,823
One thing that you need to consider though

271
00:18:21,903 --> 00:18:23,224
when you do this is that

272
00:18:24,490 --> 00:18:27,012
By moving a lot of things to script,

273
00:18:27,492 --> 00:18:33,136
you will also force the content designers or scripters

274
00:18:33,197 --> 00:18:36,139
and designers to actually be aware of stuff

275
00:18:36,179 --> 00:18:37,280
that they usually aren't.

276
00:18:37,880 --> 00:18:38,100
So.

277
00:18:39,917 --> 00:18:45,580
By setting a lot of the AI's behavior in script, we also

278
00:18:45,681 --> 00:18:47,502
move the performance issues there.

279
00:18:48,062 --> 00:18:53,126
So we need to make them aware of how to use

280
00:18:53,166 --> 00:18:54,306
the script efficiently.

281
00:18:54,967 --> 00:19:00,190
And the code also needs to be designed for performance.

282
00:19:01,151 --> 00:19:04,033
And this is something that I wished we had

283
00:19:04,093 --> 00:19:05,414
focused more on early on.

284
00:19:09,991 --> 00:19:12,812
Finally, debugging of the system needs tools.

285
00:19:12,992 --> 00:19:16,574
And I don't know how many of you saw this panel discussion

286
00:19:16,894 --> 00:19:19,115
on the Monday, but it was a very good overview

287
00:19:19,895 --> 00:19:23,016
of the most common issues of debugging AI,

288
00:19:23,337 --> 00:19:24,517
including Stellaris.

289
00:19:25,810 --> 00:19:27,472
But for Stellaris specifically, I

290
00:19:28,273 --> 00:19:31,235
think the AI is fairly easy to write and debug.

291
00:19:31,936 --> 00:19:35,879
The part that is difficult is that the behavior is

292
00:19:36,019 --> 00:19:39,402
unexpected sometimes, which we want in many cases.

293
00:19:40,023 --> 00:19:44,627
But to be able to see when it is doing something

294
00:19:44,647 --> 00:19:48,571
that it shouldn't, we need to play the game a lot.

295
00:19:49,900 --> 00:19:51,803
So we basically have to play the game.

296
00:19:51,823 --> 00:19:54,125
I think one of the guys said it really well

297
00:19:54,225 --> 00:19:55,266
at that discussion.

298
00:19:55,767 --> 00:19:59,271
Like you have to try to break the AI.

299
00:20:04,857 --> 00:20:06,679
Yeah, future improvements for this

300
00:20:06,759 --> 00:20:11,224
would be to build better tools than what we have today.

301
00:20:16,748 --> 00:20:20,590
So to summarize, our design will enable you to create

302
00:20:20,650 --> 00:20:23,912
unique NPCs with complex semi-unpredictable behavior.

303
00:20:24,912 --> 00:20:28,734
It's a good way of processing high amounts of input data and

304
00:20:28,754 --> 00:20:29,475
dependencies.

305
00:20:29,935 --> 00:20:33,316
You can tune the AI in-game.

306
00:20:34,297 --> 00:20:35,137
It's mod-friendly.

307
00:20:35,237 --> 00:20:35,938
It's scalable.

308
00:20:36,418 --> 00:20:37,138
It's modular.

309
00:20:37,538 --> 00:20:42,080
And the code will be kept simpler and cleaner, which

310
00:20:42,140 --> 00:20:44,241
means that your programmers will be happier.

311
00:20:46,287 --> 00:20:49,389
To finish off, I would like to quote our game director.

312
00:20:49,769 --> 00:20:51,470
It's a very robust system.

313
00:20:51,931 --> 00:20:55,653
You could basically redesign almost the whole game

314
00:20:55,793 --> 00:20:58,475
without having to redesign all of the AI.

315
00:20:59,315 --> 00:21:00,856
And that's something that is really good.

316
00:21:01,817 --> 00:21:03,998
I'm now open to any questions that you might have.

317
00:21:04,899 --> 00:21:05,119
Thanks.

318
00:21:15,920 --> 00:21:19,403
No questions? Okay.

319
00:21:24,209 --> 00:21:31,296
You talked a lot about

320
00:21:39,238 --> 00:21:43,479
I guess my question basically is, if you were going to do this system over again, what is

321
00:21:43,519 --> 00:21:45,080
the one change that you would make?

322
00:21:45,120 --> 00:21:47,601
What is one area for improvement in the system that you see?

323
00:21:51,382 --> 00:21:52,423
What was your name?

324
00:21:52,443 --> 00:21:53,763
Andrea.

325
00:21:53,783 --> 00:21:54,123
Andrea.

326
00:21:54,763 --> 00:21:59,065
Yeah, I listened to Andrea yesterday, and I think she said something that is really

327
00:21:59,105 --> 00:21:59,325
good.

328
00:22:01,506 --> 00:22:05,928
Sometimes when you do stuff, you get blind, and you think that that method is the only

329
00:22:05,968 --> 00:22:06,808
thing you should use.

330
00:22:06,828 --> 00:22:07,828
Right.

331
00:22:10,429 --> 00:22:12,551
What I would do differently is actually

332
00:22:12,611 --> 00:22:15,793
evaluate when we actually need to use the system

333
00:22:16,313 --> 00:22:19,095
and if there are parts where we can use something else.

334
00:22:19,515 --> 00:22:21,857
I'm not saying we're using data-driven design

335
00:22:21,877 --> 00:22:22,738
for everything.

336
00:22:23,158 --> 00:22:24,639
We have pathfinders.

337
00:22:24,719 --> 00:22:27,881
We have nav meshes, whatever.

338
00:22:28,522 --> 00:22:31,564
But there are some places where I

339
00:22:31,644 --> 00:22:34,386
think maybe behavior trees would be better, for example.

340
00:22:37,489 --> 00:22:42,714
Hello, I was hoping you could elaborate on what kind of things would be good to automate

341
00:22:42,794 --> 00:22:50,301
in AI testing as opposed to not automating and possibly how to go forth with the quality

342
00:22:50,341 --> 00:22:55,466
assurance of an AI, unit testing or any kind of strategies that you have found that work

343
00:22:55,526 --> 00:22:56,607
in your field.

344
00:22:56,687 --> 00:23:01,311
Yeah, some, the question was what kind of testing.

345
00:23:02,534 --> 00:23:10,422
is it that would help this style of game design or code

346
00:23:10,442 --> 00:23:10,782
design.

347
00:23:13,265 --> 00:23:16,808
Some of the tools that we use is all of our objects

348
00:23:16,928 --> 00:23:19,311
have IDs, which we can see in game.

349
00:23:19,851 --> 00:23:24,696
So when we debug, we can easily break point with that ID

350
00:23:24,736 --> 00:23:25,357
and find stuff.

351
00:23:26,920 --> 00:23:31,621
We have like console commands where we can just in game do stuff.

352
00:23:32,922 --> 00:23:35,562
We can play as an AI in game.

353
00:23:35,622 --> 00:23:38,163
We can add populations to our planets.

354
00:23:38,203 --> 00:23:39,903
We can own a new planet.

355
00:23:39,963 --> 00:23:43,684
So we can basically create those situations that we want to test.

356
00:23:45,264 --> 00:23:50,305
But we've discussed unit tests at Paradox a lot.

357
00:23:52,753 --> 00:23:56,617
There's probably some way you can use it,

358
00:23:56,777 --> 00:24:02,963
but I personally feel like this system requires

359
00:24:03,023 --> 00:24:05,205
you to play the game a lot.

360
00:24:06,066 --> 00:24:09,069
And you can't really get away from that.

361
00:24:13,625 --> 00:24:16,407
I'm curious to know more about the scripting of your AI.

362
00:24:16,887 --> 00:24:20,969
From what you showed, it looked like it was very limited what the designers and scripters

363
00:24:21,009 --> 00:24:21,270
could do.

364
00:24:21,330 --> 00:24:25,292
They could just set parameters and flags, I guess, that influence the decision-making

365
00:24:25,392 --> 00:24:26,013
of the AI.

366
00:24:26,853 --> 00:24:30,655
But how much can they directly force the AI to do something in the event of a trigger?

367
00:24:30,795 --> 00:24:34,798
Or maybe another question would be how many commands are there in the scripting language

368
00:24:34,858 --> 00:24:35,358
that they use?

369
00:24:35,817 --> 00:24:39,400
There are much more stuff that they can use than what I

370
00:24:39,460 --> 00:24:40,280
showed you today.

371
00:24:40,881 --> 00:24:43,803
Like they have triggers, they have effects

372
00:24:43,883 --> 00:24:44,884
that they can trigger.

373
00:24:44,964 --> 00:24:48,147
They have on action events that you can put in code at

374
00:24:48,227 --> 00:24:53,711
special, like say a planet is changing on Earth, then you

375
00:24:53,731 --> 00:24:56,113
can trigger an on action event for that.

376
00:24:57,735 --> 00:25:00,537
There's lots of stuff you can do in script.

377
00:25:01,097 --> 00:25:01,858
And basically we.

378
00:25:03,803 --> 00:25:07,005
We do as much as we can to support them,

379
00:25:07,966 --> 00:25:12,770
because they have a really important job at Paradox.

380
00:25:13,271 --> 00:25:15,572
Like, I usually tell people that ask me,

381
00:25:15,612 --> 00:25:17,174
like, I personally believe

382
00:25:17,214 --> 00:25:19,015
that the content designers make our games.

383
00:25:19,576 --> 00:25:23,099
Like, we're just there to help them make that.

384
00:25:24,640 --> 00:25:24,920
Thank you.

385
00:25:27,062 --> 00:25:28,003
Hi, thanks for the talk.

386
00:25:28,443 --> 00:25:30,705
I'm one of the few designers that put their hand up,

387
00:25:30,785 --> 00:25:31,325
I think, so.

388
00:25:33,286 --> 00:25:34,867
Probably following on from that question,

389
00:25:36,188 --> 00:25:38,510
how do you feel that the content designers

390
00:25:39,471 --> 00:25:40,352
work with this process?

391
00:25:40,392 --> 00:25:43,735
Do they come to you with a lot of requests,

392
00:25:43,795 --> 00:25:46,238
or do they find that this is very limiting

393
00:25:46,378 --> 00:25:47,158
for how they work?

394
00:25:47,299 --> 00:25:49,320
Or do they feel empowered

395
00:25:50,061 --> 00:25:52,023
with this systems-driven approach?

396
00:25:52,884 --> 00:25:53,684
I think it's both.

397
00:25:55,514 --> 00:26:02,099
I know that this system enables them to do much more than if we

398
00:26:02,199 --> 00:26:03,801
would do a lot of stuff in code.

399
00:26:04,621 --> 00:26:07,463
But at the same time, of course they want better tools.

400
00:26:07,724 --> 00:26:13,768
Of course they want more, be able to do more cool stuff.

401
00:26:13,948 --> 00:26:17,871
And that is something that we are working on all the time.

402
00:26:19,273 --> 00:26:20,113
But it's not like.

403
00:26:21,478 --> 00:26:23,920
It's not like they want to do something and they can't,

404
00:26:24,000 --> 00:26:25,200
and then we just ignore it.

405
00:26:25,481 --> 00:26:27,482
Then we try to figure out a way to do it.

406
00:26:28,302 --> 00:26:33,605
So do you find that almost the modularity that this provides

407
00:26:34,566 --> 00:26:36,827
is a good prototype process for the designers

408
00:26:36,887 --> 00:26:40,229
to come to you with new ideas for functionality

409
00:26:40,389 --> 00:26:41,029
within the code?

410
00:26:44,611 --> 00:26:46,452
Can you please elaborate?

411
00:26:46,492 --> 00:26:49,253
How do you mean, like, functionalities in the code?

412
00:26:49,654 --> 00:26:50,094
This could.

413
00:26:51,047 --> 00:26:53,449
A scripter could quickly prototype

414
00:26:53,509 --> 00:26:55,090
with the modularity of the system

415
00:26:55,130 --> 00:26:58,313
to come up with a whole new thing

416
00:26:58,333 --> 00:27:00,655
that you might want to implement in the code that

417
00:27:01,316 --> 00:27:03,718
is better suited in the code rather than in script.

418
00:27:04,339 --> 00:27:04,779
Oh, yeah.

419
00:27:05,600 --> 00:27:09,363
So the question was if there are stuff,

420
00:27:10,064 --> 00:27:12,947
if the scripters or content designers can come with.

421
00:27:15,494 --> 00:27:19,295
ideas about how to implement stuff in code instead of in script.

422
00:27:20,955 --> 00:27:22,716
Yeah, they can and they do that.

423
00:27:23,556 --> 00:27:27,216
And when it's better to have it in code, we do that.

424
00:27:27,597 --> 00:27:32,357
Sometimes for performance issues as well, it's not optimal to have it in script.

425
00:27:33,918 --> 00:27:41,719
That's probably more based on that the code is not optimized for performance, but still, we have to adapt.

426
00:27:44,903 --> 00:27:45,984
Thanks for the talk, it was great.

427
00:27:46,784 --> 00:27:49,647
I have, I guess, in a way, two separate questions,

428
00:27:49,667 --> 00:27:51,188
so you can choose to answer either or both.

429
00:27:52,249 --> 00:27:54,130
I've dealt with a bunch of the problems that you described

430
00:27:54,290 --> 00:27:57,453
several different times in my career, where we've both

431
00:27:57,793 --> 00:28:01,216
developed AI and also designer scripting-based systems

432
00:28:01,296 --> 00:28:03,658
and encountered many of the same kinds of problems.

433
00:28:04,279 --> 00:28:06,560
And I'm wondering how, if you encountered some of them,

434
00:28:06,620 --> 00:28:08,601
and also how you dealt with them.

435
00:28:09,582 --> 00:28:11,263
One of the things that you didn't touch on was,

436
00:28:11,923 --> 00:28:15,506
sometimes when you introduce the opportunity for designers

437
00:28:15,526 --> 00:28:18,408
to implement individual scripts such as that,

438
00:28:19,408 --> 00:28:20,629
one of the things that doesn't show up

439
00:28:20,689 --> 00:28:23,311
unless you have a really extensive amount of testing

440
00:28:23,471 --> 00:28:24,131
is to have...

441
00:28:27,605 --> 00:28:31,087
global interactions or combinatoric interactions

442
00:28:31,167 --> 00:28:33,069
between some of the entities that aren't visible

443
00:28:33,349 --> 00:28:35,310
within the scope of a given script.

444
00:28:35,410 --> 00:28:37,891
You know, he's scripting something for one entity

445
00:28:38,312 --> 00:28:40,113
and you don't really notice emergent behavior

446
00:28:40,153 --> 00:28:42,294
until you start playing it out in the entire system.

447
00:28:42,874 --> 00:28:45,336
And so designers can code things that look sane

448
00:28:46,016 --> 00:28:47,877
from the standpoint of one entity's behavior,

449
00:28:47,937 --> 00:28:50,499
but it turns out to be something that's exploitable.

450
00:28:51,119 --> 00:28:54,081
in the global system or it can even break things or something like that.

451
00:28:54,101 --> 00:28:56,743
I was wondering if you encountered any situations like that and

452
00:28:57,003 --> 00:29:00,125
and or if you found ways to prevent that.

453
00:29:01,086 --> 00:29:04,148
So that's kind of one category thing about behaviors. On the AI testing

454
00:29:06,492 --> 00:29:11,914
I was wondering if you had implemented anything in your system around, it's partly tied into

455
00:29:11,954 --> 00:29:15,636
the question about unit tests, but around being able to force behaviors in different

456
00:29:15,656 --> 00:29:20,057
directions such as always choose this weighted option or always choose the eccentric option

457
00:29:20,197 --> 00:29:25,919
of behavior, you know, either on a global level or on a personality, by personality

458
00:29:25,959 --> 00:29:29,961
basis to be able to exercise sort of different vectors within the AI behavior.

459
00:29:31,916 --> 00:29:33,919
Yeah, so I'll start with the second question.

460
00:29:35,642 --> 00:29:41,670
The question was if we've used the script to actually have

461
00:29:41,690 --> 00:29:43,733
a set behavior for the AI.

462
00:29:45,781 --> 00:29:46,001
Right?

463
00:29:46,402 --> 00:29:46,602
Sure.

464
00:29:46,622 --> 00:29:47,483
Something like that.

465
00:29:48,825 --> 00:29:50,087
Yes, and we do that.

466
00:29:51,488 --> 00:29:54,392
But that is one of the places where

467
00:29:54,552 --> 00:29:58,237
I think maybe data-driven design isn't the best option.

468
00:29:59,038 --> 00:30:01,722
If you already know that you're going to pick the best

469
00:30:01,842 --> 00:30:02,983
option every single time.

470
00:30:04,225 --> 00:30:07,948
then you might as well have a tree, for example.

471
00:30:10,411 --> 00:30:12,112
But yes, we do that.

472
00:30:12,973 --> 00:30:15,535
The first question was basically

473
00:30:16,276 --> 00:30:21,220
if the content designers have put in events or scripts

474
00:30:21,580 --> 00:30:26,464
where it breaks the AI without us really anticipating it.

475
00:30:27,065 --> 00:30:27,185
Yeah.

476
00:30:28,205 --> 00:30:29,786
One version of that is, like you mentioned,

477
00:30:29,826 --> 00:30:32,128
you can break from a performance perspective.

478
00:30:32,428 --> 00:30:35,689
In Unreal, somebody can write a blueprint

479
00:30:35,709 --> 00:30:37,510
that iterates through all actors of a class.

480
00:30:37,570 --> 00:30:38,991
And if that's not used really carefully,

481
00:30:39,251 --> 00:30:41,092
it can have a terrible impact on performance.

482
00:30:41,152 --> 00:30:43,454
But you can also break other things besides performance.

483
00:30:43,674 --> 00:30:44,274
Yeah, of course.

484
00:30:44,354 --> 00:30:45,054
Break behavior.

485
00:30:48,736 --> 00:30:50,377
I mean, we do.

486
00:30:50,597 --> 00:30:53,059
We do break the AI all the time.

487
00:30:54,272 --> 00:30:56,514
Like every single time we add something,

488
00:30:56,534 --> 00:30:58,015
we probably break something.

489
00:30:58,035 --> 00:31:01,358
Because the challenge in a system like yours that has as

490
00:31:01,398 --> 00:31:04,540
many separate entities and different interactions between

491
00:31:04,581 --> 00:31:07,463
all of them, like technologies and policies and all that, is

492
00:31:07,543 --> 00:31:10,085
that anything you add can potentially have kind of a

493
00:31:10,145 --> 00:31:13,247
combinatoric interaction with the rest of the system.

494
00:31:13,307 --> 00:31:15,609
You know, it could have interactions with everything

495
00:31:15,689 --> 00:31:19,993
else, and everything else can have some form of behavior

496
00:31:20,033 --> 00:31:21,514
that depends on that thing that you added.

497
00:31:23,997 --> 00:31:26,998
Yeah, usually we don't have that many dependencies.

498
00:31:27,598 --> 00:31:29,779
But let me think.

499
00:31:31,800 --> 00:31:33,341
So it kind of depends on the touch points

500
00:31:33,601 --> 00:31:35,202
between the behaviors and the data.

501
00:31:35,802 --> 00:31:38,943
I mean, if I say it like this, it's

502
00:31:39,043 --> 00:31:41,124
really simple to break the AI.

503
00:31:41,885 --> 00:31:44,786
So basically what we have to do at each point

504
00:31:45,046 --> 00:31:45,226
is to

505
00:31:48,280 --> 00:31:51,361
like go through what we are planning to do

506
00:31:51,581 --> 00:31:55,783
and then actually thinking about how might this break the AI

507
00:31:56,023 --> 00:31:57,743
and is there anything we can do about it.

508
00:31:58,364 --> 00:32:01,885
And sometimes we find those issues before we implement it

509
00:32:02,245 --> 00:32:06,086
and most often there is always something that we missed.

510
00:32:06,707 --> 00:32:09,808
So basically what we do then is to try

511
00:32:09,888 --> 00:32:11,689
to find a solution to it.

512
00:32:14,956 --> 00:32:17,378
I mean, I think it's the same in code, really.

513
00:32:17,398 --> 00:32:21,000
It's just that our games are super, super complex.

514
00:32:21,621 --> 00:32:23,762
Like, they're even complex for a human player.

515
00:32:24,202 --> 00:32:28,225
Like, we've added now a personality of hive minds

516
00:32:28,285 --> 00:32:30,787
where you don't have to think so much about politics

517
00:32:30,847 --> 00:32:33,829
and don't have to think when you actually want to purge

518
00:32:33,909 --> 00:32:35,910
all the alien pops and stuff.

519
00:32:36,311 --> 00:32:40,053
And I think Martin implemented that for me, because...

520
00:32:41,540 --> 00:32:43,523
I got tired of thinking so much.

521
00:32:43,623 --> 00:32:52,593
Like there is so much like you can do in our games and that's one of the things that we

522
00:32:52,653 --> 00:32:57,218
want but it's also one of the biggest challenges.

523
00:32:57,679 --> 00:32:57,939
Thank you.

524
00:32:59,519 --> 00:33:00,519
Hi, thank you for the talk.

525
00:33:01,300 --> 00:33:04,643
I think you mentioned the word unpredictable AI at one point.

526
00:33:05,264 --> 00:33:08,086
So the objective is to have a more engaging experience

527
00:33:08,126 --> 00:33:09,347
for the human player.

528
00:33:10,048 --> 00:33:11,629
So when it comes to unpredictable,

529
00:33:11,669 --> 00:33:13,771
which methods do you employ to make it unpredictable?

530
00:33:13,791 --> 00:33:14,912
Is it just randomization of?

531
00:33:15,753 --> 00:33:18,616
behaviors and traits based on the content that you add?

532
00:33:19,316 --> 00:33:21,798
Or is it there's any learning from the human player,

533
00:33:21,819 --> 00:33:24,721
whether their aggressiveness or how they collect resources

534
00:33:24,801 --> 00:33:25,742
or how they build structure?

535
00:33:25,782 --> 00:33:28,524
Does the AI learn and choose different paths

536
00:33:28,684 --> 00:33:30,266
of behaviors based on that?

537
00:33:30,906 --> 00:33:35,750
So the question was if the AI learns from other players

538
00:33:36,070 --> 00:33:41,395
or if it just bases its unpredictability on randomization.

539
00:33:43,836 --> 00:33:47,882
It bases it mostly on randomization and it cheats a bit.

540
00:33:47,942 --> 00:33:51,928
I mean, the AI has access to all the data.

541
00:33:55,189 --> 00:34:02,655
So is it data gathered of the users as they play or is it data that you've pre-populated?

542
00:34:02,695 --> 00:34:03,656
No, it's not.

543
00:34:04,196 --> 00:34:09,220
It doesn't learn from the players, but it can see stuff that the players can't see.

544
00:34:09,701 --> 00:34:14,725
And it's not like I deliberately put in stuff so that the AI actually cheats.

545
00:34:15,345 --> 00:34:16,766
But it can use that data.

546
00:34:16,806 --> 00:34:18,647
Like, if it's going to start a war,

547
00:34:18,687 --> 00:34:21,629
there's no point of starting it if it has one ship

548
00:34:21,909 --> 00:34:23,530
and the enemy has 1,000.

549
00:34:23,870 --> 00:34:27,352
That would just seem dumb to any human player.

550
00:34:27,873 --> 00:34:31,955
So we just avoid that by actually knowing that, OK,

551
00:34:32,836 --> 00:34:34,977
you can actually see that in game as a human player

552
00:34:35,017 --> 00:34:37,759
as well, like the ratio towards an enemy.

553
00:34:38,119 --> 00:34:41,721
But anyways, we use that data in order

554
00:34:41,801 --> 00:34:44,343
to limit the AI's behavior.

555
00:34:44,883 --> 00:34:47,146
to make it seem more human-like.

556
00:34:47,166 --> 00:34:48,248
Yeah.

557
00:34:48,729 --> 00:34:49,029
Thank you.

558
00:34:51,673 --> 00:34:51,973
Okay.

559
00:34:53,496 --> 00:34:58,042
Yeah, so we're out of time, but come talk to me if you want to discuss this more.

