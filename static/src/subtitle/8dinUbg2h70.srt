1
00:00:02,255 --> 00:00:05,938
Okay, we'll start. Whatever. So this talk is implementation of

2
00:00:05,978 --> 00:00:08,640
rewind and braid. It is a technical talk in case you're

3
00:00:08,660 --> 00:00:11,402
thinking some kind of design implementation or something.

4
00:00:11,542 --> 00:00:15,685
That's not it. When I submitted this talk, I was like, oh, sure,

5
00:00:15,706 --> 00:00:18,047
it's pretty simple. I'll be able to talk about everything in 25

6
00:00:18,288 --> 00:00:20,870
minutes. It doesn't seem to be how it is. There's a lot of

7
00:00:20,910 --> 00:00:23,392
little details I won't be able to get into. May go a little

8
00:00:23,432 --> 00:00:27,855
bit over time. Whatever. Feel free to ask me by e-mail or

9
00:00:27,875 --> 00:00:29,517
something. Anyway, who ----

10
00:00:30,183 --> 00:00:33,947
How many people in the room have not played the game? All right,

11
00:00:34,087 --> 00:00:36,309
that's enough. Okay, cool. So I'll show you really quickly

12
00:00:36,729 --> 00:00:41,334
what it's like. It's pretty simple in some ways. It's a

13
00:00:41,354 --> 00:00:45,278
little 2D platformer. It's shipped on the Xbox 360, PS3 and

14
00:00:45,318 --> 00:00:50,963
PC and Mac. You run around, you can jump as you always can. You

15
00:00:50,983 --> 00:00:52,705
can go into these little worlds where things happen.

16
00:00:56,480 --> 00:00:59,881
And you know, a world is sort of a scrolling area with parallax

17
00:00:59,941 --> 00:01:00,542
and all that.

18
00:01:00,742 --> 00:01:03,943
It can be from one screen to eight or 10 screens large.

19
00:01:04,563 --> 00:01:06,143
There's all these objects that move.

20
00:01:06,183 --> 00:01:06,904
You can get killed.

21
00:01:07,604 --> 00:01:08,824
And you can rewind like this.

22
00:01:10,105 --> 00:01:11,605
And the rewind is unlimited.

23
00:01:11,965 --> 00:01:13,026
It's not a resource.

24
00:01:13,086 --> 00:01:21,348
And so that was the first of the design goals that I had,

25
00:01:21,388 --> 00:01:24,269
was I wanted to find out what happens.

26
00:01:25,944 --> 00:01:28,926
When you design a game where rewind is not a resource and

27
00:01:28,946 --> 00:01:32,909
there's not a traditional sort of death challenge, you know,

28
00:01:32,929 --> 00:01:35,812
gating the game. I knew I wanted to be able to run on consoles

29
00:01:35,832 --> 00:01:40,975
because I wanted to maybe sell some copies. I knew that I was

30
00:01:40,995 --> 00:01:43,878
going to be the only programmer on the game. That ended up not

31
00:01:43,918 --> 00:01:45,959
quite being true. I got a little help at the very end.

32
00:01:47,243 --> 00:01:49,064
I really wanted to limit the amount of programming work that

33
00:01:49,084 --> 00:01:52,525
I would do because I was also the designer and biz guy and all

34
00:01:52,545 --> 00:01:56,586
that stuff. So if you spend all your time programming, you won't

35
00:01:56,626 --> 00:01:59,807
have a game because those other elements are missing. Now this

36
00:01:59,847 --> 00:02:02,368
is a platformer and I knew it was going to involve puzzles.

37
00:02:03,008 --> 00:02:05,209
So when you start talking about rewind and puzzles, you start

38
00:02:05,229 --> 00:02:06,149
thinking, you know, I'm going to do this.

39
00:02:06,718 --> 00:02:08,700
You know, I don't want my puzzles to be exploitable, right?

40
00:02:09,120 --> 00:02:11,562
Like, a typical kind of puzzle might be you can't get between

41
00:02:11,602 --> 00:02:14,484
point A and point B in less than a certain amount of time unless

42
00:02:14,504 --> 00:02:15,605
you do something special, right?

43
00:02:16,046 --> 00:02:19,508
But, like, maybe if your rewind doesn't put you back exactly

44
00:02:19,528 --> 00:02:21,189
where you were, you could, like, rewind.

45
00:02:21,970 --> 00:02:24,812
You could go forward two frames and rewind one frame and stuff

46
00:02:24,872 --> 00:02:27,554
and get little extra centimeters and eventually exploit the

47
00:02:27,594 --> 00:02:27,914
puzzle.

48
00:02:28,335 --> 00:02:30,717
Or you could, like, somehow jump over a hurdle that you wouldn't

49
00:02:30,737 --> 00:02:33,339
have been able to jump over normally if you can mess with

50
00:02:33,359 --> 00:02:33,919
your momentum.

51
00:02:34,399 --> 00:02:34,559
So...

52
00:02:36,004 --> 00:02:38,725
I wanted to ensure that whatever time manipulation is in the

53
00:02:38,765 --> 00:02:40,746
game is not exploitable and I wanted the game to run at 60

54
00:02:41,026 --> 00:02:44,567
frames per second, which we usually think of as a CPU kind

55
00:02:44,607 --> 00:02:46,688
of issue. But when you start talking about remembering

56
00:02:46,748 --> 00:02:49,509
things, as you need to do for rewind or recording videos or

57
00:02:49,529 --> 00:02:52,070
something, as you raise your frame rate, the amount of data

58
00:02:52,090 --> 00:02:55,231
that you have to deal with goes up. But I felt that this was

59
00:02:55,291 --> 00:02:59,972
important for a fluid, solid platforming experience. So now,

60
00:03:00,232 --> 00:03:01,833
if you're a programmer who's been around for a while,

61
00:03:02,678 --> 00:03:05,160
I hope these don't get cut off too bad. We'll see. Anyway,

62
00:03:05,180 --> 00:03:07,783
there are some ways you might think of to implement rewind.

63
00:03:08,384 --> 00:03:11,808
And they're generally grounded in optimization style thinking.

64
00:03:11,868 --> 00:03:14,571
Like, what's the best way to implement rewind, right? One

65
00:03:14,591 --> 00:03:17,854
thing that we often do in game engines in order to repro and

66
00:03:18,114 --> 00:03:18,695
fix bugs.

67
00:03:19,916 --> 00:03:23,681
that can be used for this kind of system is to record all the

68
00:03:23,761 --> 00:03:26,384
user input. You kind of hook the input function in the engine

69
00:03:26,424 --> 00:03:29,328
and you record all the button presses that happen and then you

70
00:03:29,368 --> 00:03:32,672
can run it again in playback mode and as long as all your

71
00:03:32,712 --> 00:03:34,254
functions in your game are deterministic.

72
00:03:34,894 --> 00:03:37,296
then you'll get exactly the same result as you play back the

73
00:03:37,336 --> 00:03:41,119
events. I've done that a few times. I hate it. It's a pain

74
00:03:41,139 --> 00:03:45,382
in my ass all the time because things break. They're not robust

75
00:03:45,443 --> 00:03:48,265
across revisions, like a recording that you make once is

76
00:03:48,325 --> 00:03:49,766
not going to work on a different revision. You get

77
00:03:50,739 --> 00:03:54,321
revision is confused. But even worse, it places constraints on

78
00:03:54,401 --> 00:03:58,583
other parts of the code that live for the duration of the

79
00:03:58,623 --> 00:04:01,144
thing. So I didn't really explore this option until later

80
00:04:01,164 --> 00:04:03,025
in development, but it's lucky that I didn't. Because if I had

81
00:04:03,045 --> 00:04:04,926
gone this way, I would have ended up designing a very

82
00:04:04,966 --> 00:04:08,087
different game, because the gameplay depends on having

83
00:04:08,127 --> 00:04:09,928
functionality that this would not have enabled. And I'll go

84
00:04:09,948 --> 00:04:10,449
into that later.

85
00:04:12,227 --> 00:04:14,189
Another wacky idea you might think of is reversible

86
00:04:14,229 --> 00:04:17,331
simulation. We usually have an engine with entities that have

87
00:04:17,371 --> 00:04:19,532
a tick function and the tick function knows how to bring

88
00:04:19,572 --> 00:04:21,793
them forward in time. What if that could also bring them

89
00:04:21,853 --> 00:04:25,035
backward in time inside that function? Well, it's a question

90
00:04:25,055 --> 00:04:27,577
of exactly how to do that. We're used to just having

91
00:04:27,617 --> 00:04:30,519
discontinuous state changes in objects. If you have

92
00:04:30,559 --> 00:04:33,121
differentiable functions, that's easy to reverse. People who do

93
00:04:33,161 --> 00:04:33,761
physics know that.

94
00:04:35,736 --> 00:04:39,720
have to start recording weird data and how do you do that?

95
00:04:39,740 --> 00:04:42,722
And, you know, gameplay code is pretty complicated and it's a

96
00:04:42,742 --> 00:04:44,944
big source of bugs already. And if you make it twice as

97
00:04:44,984 --> 00:04:48,407
complicated it seems like a bad idea. And then if you can only

98
00:04:48,467 --> 00:04:51,810
simulate in reverse, how do you get random access to your

99
00:04:51,870 --> 00:04:54,312
time stream, right? If you want to go back to 10,000 frames ago

100
00:04:55,994 --> 00:04:58,255
How do you do that without simulating 10,000 frames

101
00:04:58,455 --> 00:04:58,855
backwards?

102
00:04:59,335 --> 00:05:02,176
So it's not necessarily seeming like a good idea

103
00:05:02,196 --> 00:05:02,737
to do it that way.

104
00:05:03,157 --> 00:05:06,258
OK, well, what started seeming like the best option to me

105
00:05:06,318 --> 00:05:07,919
was just to record the full state of the world,

106
00:05:07,939 --> 00:05:09,040
because you know that's robust.

107
00:05:09,880 --> 00:05:11,061
You know you can reproduce that.

108
00:05:11,521 --> 00:05:12,601
And that's going to be a lot of data,

109
00:05:12,621 --> 00:05:13,882
so maybe you drop frames.

110
00:05:14,082 --> 00:05:16,543
So maybe you record every 100th frame and the frames

111
00:05:16,583 --> 00:05:17,063
in between that.

112
00:05:17,648 --> 00:05:21,510
you interpolate between the end points. But that's not really a

113
00:05:21,550 --> 00:05:24,251
good idea because it's non-exact. Your interpolated

114
00:05:24,291 --> 00:05:27,932
frame has a very low probability of being what the actual frame

115
00:05:28,272 --> 00:05:31,873
was that you threw away. So there are quality questions

116
00:05:31,913 --> 00:05:33,914
about that. And again, that question of how to avoid

117
00:05:33,994 --> 00:05:40,716
exploits comes up. So I had to kind of suppress my impulse.

118
00:05:40,776 --> 00:05:44,237
So us guys wanting to be star programmers, our impulse is,

119
00:05:44,277 --> 00:05:46,118
man, I'm going to do something that's awesome and fast and has

120
00:05:46,158 --> 00:05:46,458
a tiny...

121
00:05:47,427 --> 00:05:50,530
going to be better than anything anyone in history has ever done

122
00:05:50,550 --> 00:05:54,293
and it's going to be awesome. But my attitude at the time was

123
00:05:54,433 --> 00:05:58,296
different than that. I'm lucky I had this attitude because this

124
00:05:58,316 --> 00:06:00,217
is what allowed me to finish and ship the game.

125
00:06:01,166 --> 00:06:03,088
It's that, you know, I've been doing all this 3D graphics,

126
00:06:03,268 --> 00:06:07,873
high tech stuff for years. We kill ourselves to get 10% or 5%

127
00:06:08,114 --> 00:06:11,317
performance differences. We make massively complicated systems to

128
00:06:11,357 --> 00:06:15,141
get that performance boost. And it breaks all the time. Games

129
00:06:15,542 --> 00:06:18,805
crash and they just go slowly when they're supposed to go

130
00:06:18,825 --> 00:06:19,086
fast.

131
00:06:20,307 --> 00:06:21,968
Since I'm going to have to be designing this game, and I

132
00:06:21,988 --> 00:06:23,849
actually want to ship this game so that my independent

133
00:06:23,909 --> 00:06:26,491
developer career will succeed, I'm going to do the most

134
00:06:26,551 --> 00:06:28,092
robust thing possible.

135
00:06:28,492 --> 00:06:31,114
So my focus was on robust, enabled me to build the game.

136
00:06:31,494 --> 00:06:33,316
And so what is the most robust thing?

137
00:06:33,356 --> 00:06:35,837
It's not any of these things I talked about, because those

138
00:06:35,857 --> 00:06:38,819
were concocted with the mindset of being tricky.

139
00:06:38,859 --> 00:06:41,221
And tricky means complicated, usually.

140
00:06:43,970 --> 00:06:46,032
And so what I came up with is a variant of that third idea,

141
00:06:46,412 --> 00:06:47,052
but dead simple.

142
00:06:47,092 --> 00:06:49,674
Just record all the world state, every frame, always.

143
00:06:50,254 --> 00:06:51,055
Don't drop any frames.

144
00:06:51,075 --> 00:06:52,856
Just record everything, and then figure out a way

145
00:06:52,876 --> 00:06:53,396
to compress it.

146
00:06:54,217 --> 00:06:57,319
And most people would not approach this problem this way,

147
00:06:57,859 --> 00:07:00,261
but I believe it was by far the best way to approach it.

148
00:07:01,842 --> 00:07:05,424
So how do you record game state?

149
00:07:05,504 --> 00:07:07,926
Well, you've got a world which has got some objects in it.

150
00:07:08,822 --> 00:07:11,202
And each object in the world has a bunch of properties.

151
00:07:11,222 --> 00:07:12,243
This is pretty universal.

152
00:07:12,463 --> 00:07:13,603
Games work this way.

153
00:07:13,663 --> 00:07:14,824
So this is a shot of the editor.

154
00:07:14,844 --> 00:07:17,545
In the upper right, there's sort of this panel for this

155
00:07:17,645 --> 00:07:19,165
entity that I had highlighted.

156
00:07:19,745 --> 00:07:21,526
And it's got a bunch of member variables.

157
00:07:21,806 --> 00:07:23,847
And there's types to them.

158
00:07:23,867 --> 00:07:24,767
So some of them are integers.

159
00:07:24,807 --> 00:07:25,767
Some of them are vectors.

160
00:07:25,827 --> 00:07:27,208
Some of them are strings, whatever.

161
00:07:27,948 --> 00:07:30,009
You have to have this somehow in your game if you're going

162
00:07:30,029 --> 00:07:34,870
to save the world file so that you can edit it and load it in

163
00:07:34,910 --> 00:07:35,431
and play it.

164
00:07:39,422 --> 00:07:42,242
You could think of other ways to store things. I could take the

165
00:07:42,282 --> 00:07:45,283
entities in my world and clone them and have a little side

166
00:07:45,323 --> 00:07:47,624
world off to the side and do that every time I want to record

167
00:07:47,664 --> 00:07:51,885
something. But live entities in a game engine tend to be

168
00:07:51,925 --> 00:07:54,645
individually allocated. And if you're playing a lot with

169
00:07:54,705 --> 00:07:57,646
memory that way, that creates fragmentation. You allocate a

170
00:07:57,666 --> 00:07:59,147
bunch of memory, you free something out of the middle,

171
00:07:59,167 --> 00:08:02,327
there's a hole that you may or may not be able to use. And

172
00:08:02,367 --> 00:08:04,068
that's bad, especially if you're running on a console.

173
00:08:07,856 --> 00:08:10,738
And the second point off the bottom of the slide is that

174
00:08:11,238 --> 00:08:13,460
things that are serialized are easily compressible. If you

175
00:08:13,480 --> 00:08:15,501
want to do entropy coding on them or something like that,

176
00:08:15,882 --> 00:08:18,704
it's a stream of bytes. You can feed a stream of bytes into any

177
00:08:18,744 --> 00:08:23,247
generic compressor. And if you were to think about some kind of

178
00:08:23,307 --> 00:08:26,249
live entity scheme, if you were going to compress that, you have

179
00:08:26,289 --> 00:08:28,751
to eventually turn it into a stream of bytes. So you just

180
00:08:28,771 --> 00:08:35,176
serialize. So here's some list of properties from some very

181
00:08:36,564 --> 00:08:44,387
basic object. And there's a bunch of these objects in a

182
00:08:44,407 --> 00:08:47,508
level. How many I don't actually remember, but there's a bunch.

183
00:08:47,749 --> 00:08:51,590
And if you look at the size of the levels on disk, right,

184
00:08:52,271 --> 00:08:57,793
they're between 25k bytes and 175k bytes. And that's great.

185
00:08:58,073 --> 00:08:59,914
That's a pretty good size for levels on disk, but when you're

186
00:08:59,934 --> 00:09:02,835
recording 60 of those per second, it adds up to a lot of

187
00:09:02,855 --> 00:09:05,116
memory really fast. So you start

188
00:09:05,876 --> 00:09:08,500
doing the second part of what I said, which is figure out a way to compress it.

189
00:09:08,540 --> 00:09:10,824
And that's basically what the rest of the talk from here on is.

190
00:09:15,733 --> 00:09:16,635
So the most obvious thing...

191
00:09:17,895 --> 00:09:19,956
And the first thing people will think of when they have

192
00:09:19,976 --> 00:09:22,519
programming experience is most of these entities aren't

193
00:09:22,559 --> 00:09:23,059
changing at all.

194
00:09:23,079 --> 00:09:23,620
They're constant.

195
00:09:23,660 --> 00:09:24,380
We factor them out.

196
00:09:24,400 --> 00:09:25,681
We only record the things that change.

197
00:09:25,761 --> 00:09:25,961
Right?

198
00:09:26,522 --> 00:09:27,983
And of course this is a massive win.

199
00:09:28,283 --> 00:09:31,086
So in Braid there's a couple sets of things that are constant.

200
00:09:31,766 --> 00:09:35,870
On the left is collision geometry which you don't ever see in the game but it determines

201
00:09:35,910 --> 00:09:37,071
where you can go and where you can't go.

202
00:09:37,591 --> 00:09:39,813
And on the right is, you know, cosmetic stuff.

203
00:09:39,853 --> 00:09:43,256
It's layout that usually matches up to the collision geometry and just makes the level

204
00:09:43,296 --> 00:09:43,736
look nice.

205
00:09:43,856 --> 00:09:44,016
Right?

206
00:09:44,901 --> 00:09:47,623
those don't change, so you just keep them in a separate array

207
00:09:48,164 --> 00:09:50,586
after you load the level and any time you want to seek through

208
00:09:50,606 --> 00:09:54,069
the timeline to a particular time, then you just copy these,

209
00:09:54,529 --> 00:09:56,971
there's one copy of these for all the frames, right, so you

210
00:09:56,991 --> 00:10:00,534
just make a copy of those and then you go look into the data

211
00:10:00,554 --> 00:10:04,117
that you recorded, you extract the changing entities, right,

212
00:10:04,137 --> 00:10:06,219
the only ones that you actually needed to save, and then you

213
00:10:06,259 --> 00:10:10,863
mix them in and you have your final state. Now,

214
00:10:12,034 --> 00:10:20,342
This third screen is particles in Braid. The look of Braid depends very heavily on particles.

215
00:10:20,382 --> 00:10:25,326
There's a bunch of particles everywhere. They fade in and out and provide a very sort of

216
00:10:26,668 --> 00:10:28,429
shifting feeling to the graphics.

217
00:10:30,948 --> 00:10:33,189
And if you actually were to record these in a naive way,

218
00:10:33,209 --> 00:10:36,010
it's a gigantic amount of data because there's thousands, tens

219
00:10:36,030 --> 00:10:38,510
of thousands of particles on a level, you need to record

220
00:10:38,530 --> 00:10:41,971
position, color, and probably about 17 other properties for

221
00:10:42,011 --> 00:10:45,192
each one. It's gigantic, right? So what you do is you make the

222
00:10:45,232 --> 00:10:50,213
particle entities constant, right? And how do you do that?

223
00:10:50,253 --> 00:10:52,494
Well, you make a function that is a sort of

224
00:10:52,952 --> 00:10:55,794
closed form kind of thing where you feed in a seed from a

225
00:10:55,814 --> 00:10:58,075
random number generator and you feed in a bunch of properties

226
00:10:58,115 --> 00:11:01,037
describing how the particles should look like, what texture

227
00:11:01,077 --> 00:11:03,138
is it and what are the UV coordinates and what color does

228
00:11:03,178 --> 00:11:05,100
it start at and what color does it end, right? All the usual

229
00:11:05,140 --> 00:11:07,681
particle system stuff. But instead of those properties

230
00:11:07,742 --> 00:11:10,543
evolving over time, they're fixed and then when it comes

231
00:11:10,583 --> 00:11:15,307
time to generate the particles, you kind of run the equations

232
00:11:15,347 --> 00:11:19,750
of physics and interpolate all the colors and all that.

233
00:11:20,366 --> 00:11:23,388
in closed form and spit out a particle from nothing every

234
00:11:23,428 --> 00:11:26,791
frame. When you do this, it's slower than the way particles

235
00:11:26,871 --> 00:11:29,272
usually happen. Usually we're tracing particles through space

236
00:11:29,292 --> 00:11:32,595
and modifying each property a little bit. In this case, you

237
00:11:32,615 --> 00:11:36,818
have to regenerate a bunch of random numbers for every

238
00:11:36,858 --> 00:11:41,421
particle, every frame. And that's slower. And sort of the

239
00:11:41,441 --> 00:11:44,803
caveat to this is that I actually had to optimize the

240
00:11:44,823 --> 00:11:45,564
particle inner loop.

241
00:11:46,593 --> 00:11:49,174
relatively heavily compared to the rest of the game in order

242
00:11:49,194 --> 00:11:54,397
to get it to run well on consoles. Yeah, the current

243
00:11:54,437 --> 00:11:56,919
consoles. There's no problem on PCs because of out of order

244
00:11:56,979 --> 00:12:02,662
processing. Anyway, I wish I could really see more of the

245
00:12:02,682 --> 00:12:06,644
slides, but okay. So you've got a lot of stuff going on.

246
00:12:07,437 --> 00:12:09,857
this scheme where you're taking all the state of the game or

247
00:12:10,577 --> 00:12:13,738
all the changing state, right, so it's a massive win to factor

248
00:12:13,778 --> 00:12:16,079
out the constant objects, but it's still way too big, right,

249
00:12:16,099 --> 00:12:18,339
because we're talking about massive amounts of data. So

250
00:12:18,799 --> 00:12:24,100
what do you do next? You diff individual fields of an entity

251
00:12:24,140 --> 00:12:25,981
so you don't have to save the whole entity, right? If you

252
00:12:26,001 --> 00:12:29,142
have a continuous gameplay experience, then chances are

253
00:12:29,202 --> 00:12:32,002
that whatever the objects are in the world at frame N plus 1,

254
00:12:32,342 --> 00:12:35,503
they're a lot like where they were at frame N with some minor

255
00:12:35,523 --> 00:12:36,863
differences, right? So...

256
00:12:39,538 --> 00:12:44,861
Wow. What just happened? I don't, okay. Oh, thanks, you're

257
00:12:44,881 --> 00:12:49,343
trying to fix it. Okay. Now the sides are gone. If we can keep

258
00:12:49,383 --> 00:12:51,023
trying to fix it, that would be good, though. So this diagram

259
00:12:51,043 --> 00:12:56,906
down here, right, is the one that's going to be the

260
00:12:58,551 --> 00:13:02,814
is sort of a diagram of what happens in this scheme when we

261
00:13:02,894 --> 00:13:05,757
try to seek to a certain frame in the timeline. So we want to

262
00:13:05,797 --> 00:13:08,759
find where that red dot is, right? And so we've got these

263
00:13:08,819 --> 00:13:12,842
larger sort of yellowish blocks. Those are the base frames which

264
00:13:12,902 --> 00:13:16,185
behave exactly like I explained before. They contain data for

265
00:13:16,265 --> 00:13:18,667
all the entities in the world. So if you wanted to seek exactly

266
00:13:18,747 --> 00:13:22,410
to that point in the timeline, you only decode what's in that

267
00:13:22,430 --> 00:13:23,130
block and you're done.

268
00:13:24,251 --> 00:13:26,552
For anything in between, those are smaller blocks that only

269
00:13:26,592 --> 00:13:27,473
contain diffs.

270
00:13:27,953 --> 00:13:30,214
So if I want to seek to where that red spot is,

271
00:13:30,554 --> 00:13:31,695
I have to decode the diffs.

272
00:13:32,716 --> 00:13:34,597
I have to decode what's in the base frame.

273
00:13:34,617 --> 00:13:36,278
And then I have to apply the diffs to the base frame.

274
00:13:38,519 --> 00:13:42,140
When I say diffs here, I'm not doing delta encoding as people

275
00:13:42,180 --> 00:13:45,042
do in compression a lot. In delta encoding, if the value

276
00:13:45,102 --> 00:13:48,863
used to be 100 and now it's 100.5, you store plus .5 and

277
00:13:48,904 --> 00:13:50,964
it's usually smaller. I didn't do that because I didn't want to

278
00:13:50,985 --> 00:13:53,686
worry about rounding, accumulation of error, any of

279
00:13:53,726 --> 00:13:58,908
that. I wanted to be very, very clean so I just store 100.5 or

280
00:13:59,268 --> 00:14:03,350
whatever. And this again is another massive win. In braid,

281
00:14:06,724 --> 00:14:09,885
I put base frames every two seconds, I believe, in the

282
00:14:09,925 --> 00:14:14,627
final builds. So that's every 120 frames. So this gets rid of

283
00:14:14,667 --> 00:14:20,729
about probably 95% of the memory usage or something like that.

284
00:14:22,750 --> 00:14:27,551
But it's not enough. Or at least, wow. Okay. How about if

285
00:14:27,591 --> 00:14:32,913
I do this? There we go. Okay. So I'm going to do this. I'm going

286
00:14:35,104 --> 00:14:39,448
is it shift F5 to resume from where you, yeah, okay, cool. So

287
00:14:42,030 --> 00:14:44,351
what I found after I did this is that even though it was a

288
00:14:44,392 --> 00:14:47,354
massive memory savings, now these base frames still took

289
00:14:47,494 --> 00:14:53,579
over half the memory of, you know, the memory of the

290
00:14:54,490 --> 00:14:55,930
I don't know if this math works out, but whatever.

291
00:14:56,150 --> 00:14:58,931
They took about half the memory of the system, right?

292
00:14:58,971 --> 00:15:00,411
And the delta frames took the other half.

293
00:15:00,791 --> 00:15:03,752
So one frame out of every 120 was taking half the memory.

294
00:15:03,792 --> 00:15:05,853
It's obviously ripe for optimization, so what do you do?

295
00:15:06,453 --> 00:15:08,414
And, you know, all sorts of schemes can be thought of,

296
00:15:08,454 --> 00:15:10,754
like, hey, we'll diff the base frame from the previous base frame,

297
00:15:10,774 --> 00:15:12,195
so we'll have, like, a hierarchical thing.

298
00:15:12,875 --> 00:15:15,637
and it's like log base 120 or something, so you climb up a

299
00:15:15,697 --> 00:15:18,920
tree to decode. But that's kind of, that's too non-local for me.

300
00:15:19,321 --> 00:15:22,684
So what I did, and it worked great, is I diffed the base

301
00:15:22,724 --> 00:15:25,806
frames again off the default constructed state of an entity.

302
00:15:25,826 --> 00:15:28,068
So if you're programming in C++ or something, you've got a

303
00:15:28,108 --> 00:15:31,171
constructor for your object, it fills in, especially if it's a

304
00:15:31,211 --> 00:15:33,313
live object in a game engine, it's going to fill in valid

305
00:15:33,353 --> 00:15:36,235
values for all the properties of that object, and often you won't

306
00:15:36,255 --> 00:15:37,356
change a lot of those properties.

307
00:15:40,741 --> 00:15:44,263
So in the base frames now, they're not diffed off any

308
00:15:44,363 --> 00:15:46,784
frame anymore, but they're diffed off of how is this

309
00:15:46,884 --> 00:15:49,066
entity different from if you just constructed it and didn't

310
00:15:49,086 --> 00:15:51,087
do anything to it and didn't even add it into the world.

311
00:15:58,851 --> 00:16:00,252
So after this, you've done a bunch of high-level

312
00:16:00,312 --> 00:16:01,973
optimization, you start thinking about low-level

313
00:16:02,033 --> 00:16:04,574
optimization, like an entropy coding layer, you know,

314
00:16:04,674 --> 00:16:06,515
LZW on this stream of bytes or something.

315
00:16:07,175 --> 00:16:10,277
There isn't any in Braid, partially because it was not

316
00:16:10,317 --> 00:16:13,619
needed, partially because I had speed concerns about that.

317
00:16:14,039 --> 00:16:15,500
And I needed as much speed as I could.

318
00:16:15,520 --> 00:16:18,521
I forget if I talk about that later in these slides or not.

319
00:16:19,182 --> 00:16:19,742
I had to cut some.

320
00:16:23,056 --> 00:16:26,097
wasn't needed because on the Xbox 360 where you have 512

321
00:16:26,137 --> 00:16:29,880
megs of RAM total, I dedicated 40 megabytes to rewind data

322
00:16:30,000 --> 00:16:33,262
which seems like a lot of memory but on a game that's completely

323
00:16:33,322 --> 00:16:38,725
based on time manipulation it totally makes sense. So devoting

324
00:16:39,005 --> 00:16:42,227
40 megabytes gave the player between 30 and 60 minutes of

325
00:16:42,267 --> 00:16:45,128
recording time on most levels which is vastly more than you

326
00:16:45,168 --> 00:16:50,792
need usually. It turns out some levels actually need that which

327
00:16:50,852 --> 00:16:51,592
is why it's good to have.

328
00:16:54,288 --> 00:16:57,430
Now, if you're unpacking all these frames all the time,

329
00:16:57,590 --> 00:17:02,033
that's going to be slow, of course. So here's a screen shot

330
00:17:02,073 --> 00:17:05,035
showing a trail effect behind these little monsters when you

331
00:17:05,055 --> 00:17:08,857
rewind. And the way that works is it just samples the monster's

332
00:17:08,937 --> 00:17:10,458
actual position over the last

333
00:17:11,616 --> 00:17:14,197
lots of frames, a couple of seconds usually in alpha

334
00:17:14,217 --> 00:17:16,297
blends. I wanted to do that instead of some kind of

335
00:17:16,357 --> 00:17:19,078
extrapolation because again, accuracy issues. You get

336
00:17:19,118 --> 00:17:22,238
weirdness if you start trying to guess where things were. So to

337
00:17:22,278 --> 00:17:25,099
do that you have to touch a lot of frames every time you want to

338
00:17:25,139 --> 00:17:28,920
render. So it makes sense to have a frame cache, which in

339
00:17:28,940 --> 00:17:35,842
braid is probably about 24 frames. And those are totally

340
00:17:35,882 --> 00:17:38,282
live instantiated entities. They're just not added to the

341
00:17:38,302 --> 00:17:39,823
main universe. They're just off to the side.

342
00:17:42,011 --> 00:17:47,615
and, yeah, it's what you would think. So some further

343
00:17:47,655 --> 00:17:51,818
implementation details. I was talking about how, let's say

344
00:17:51,898 --> 00:17:55,621
we're on frame 130, we want to seek to frame 137 and its base

345
00:17:55,661 --> 00:18:00,585
frame is frame 120, right, off to the left, not to scale. And

346
00:18:01,685 --> 00:18:04,327
you know, the frame before that, you actually constructed a new

347
00:18:04,407 --> 00:18:06,389
object. So it's in frame 136, it's in frame 137, it's not in

348
00:18:06,409 --> 00:18:06,529
frame 120.

349
00:18:08,950 --> 00:18:10,930
So if you go to apply this diff, it's not there, right?

350
00:18:10,970 --> 00:18:14,111
And the simple solution to that is just any time you constructed

351
00:18:14,151 --> 00:18:15,871
a new object and it's not on a base frame,

352
00:18:16,151 --> 00:18:19,052
you just store the state for that object back in the base

353
00:18:19,092 --> 00:18:20,172
frame so everybody can find it.

354
00:18:21,132 --> 00:18:23,252
Now, you don't want to store it in the same array

355
00:18:23,292 --> 00:18:25,093
that the actual live data for the world is,

356
00:18:25,113 --> 00:18:26,833
because when you rewind to that time,

357
00:18:26,893 --> 00:18:28,193
you don't want to accidentally think

358
00:18:28,213 --> 00:18:29,874
that this object that doesn't exist yet exists.

359
00:18:29,894 --> 00:18:32,034
So you just store it in two parallel arrays.

360
00:18:35,155 --> 00:18:35,295
So.

361
00:18:36,285 --> 00:18:39,227
you know, it still only takes two frames to decode regardless

362
00:18:39,267 --> 00:18:42,950
of what objects you knew or create or destroy. If you

363
00:18:42,970 --> 00:18:45,771
destroy an object, you just don't really worry about it.

364
00:18:45,831 --> 00:18:49,554
Because the way that it works is we start at the target frame,

365
00:18:49,614 --> 00:18:51,875
and so if the object doesn't exist there, we won't try to

366
00:18:51,915 --> 00:18:54,517
diff it at all. If it exists in the base frame, we just ignore

367
00:18:54,557 --> 00:19:00,421
it. Okay, so if you have limited memory to work with, then you

368
00:19:00,461 --> 00:19:02,542
have to forget things or else you'll crash.

369
00:19:04,544 --> 00:19:06,746
Now, fragmentation, like I said, is a big issue also.

370
00:19:06,806 --> 00:19:09,088
So we want to somehow figure out how to forget stuff

371
00:19:09,108 --> 00:19:09,989
without fragmenting.

372
00:19:10,069 --> 00:19:12,412
And I experimented with a bunch of things.

373
00:19:12,452 --> 00:19:15,655
And the thing I was happiest with, actually, I

374
00:19:15,675 --> 00:19:17,117
think the only thing that actually worked

375
00:19:17,577 --> 00:19:18,498
across all platforms.

376
00:19:20,130 --> 00:19:23,171
was to group all the frames into a big bucket, like just for

377
00:19:23,411 --> 00:19:26,992
memory allocation purposes, and create a heap for that whole

378
00:19:27,032 --> 00:19:31,534
bucket. And then destroy the heap when I want to forget all

379
00:19:31,574 --> 00:19:35,116
that stuff. And the reason that I do that is because when you

380
00:19:35,136 --> 00:19:41,578
destroy a heap, you know that the actual pages get

381
00:19:41,618 --> 00:19:43,859
deallocated. They get returned back to the operating system.

382
00:19:43,879 --> 00:19:45,900
So you're just not going to have fragmentation. There's no way.

383
00:19:48,577 --> 00:19:51,678
So at the same time though, if you're using, say you're on

384
00:19:51,718 --> 00:19:54,420
Windows and you're using heap alec, that's super slow, right?

385
00:19:54,780 --> 00:19:57,002
You can't call heap alec for every allocation that you want

386
00:19:57,022 --> 00:20:00,704
to make, so what you do is you put a faster allocator in front

387
00:20:00,724 --> 00:20:02,885
of that, that allocates chunks out of the heap and then hands

388
00:20:02,925 --> 00:20:04,226
little pieces back to the application.

389
00:20:04,886 --> 00:20:08,128
For this it's super simple, it uses a pool, which hopefully

390
00:20:08,168 --> 00:20:10,510
most of us know, but it's just basically an array, and you move

391
00:20:10,550 --> 00:20:12,651
a pointer along the array, and if they say I want 10 bytes, you

392
00:20:12,671 --> 00:20:15,673
give them 10 bytes, and you move the pointer 10 bytes, and you

393
00:20:15,693 --> 00:20:17,954
know, everything's totally packed together. There's no way

394
00:20:17,974 --> 00:20:20,556
to ever deallocate anything from a pool, but you don't need to,

395
00:20:20,616 --> 00:20:22,477
because you're just going to destroy the heap when you want

396
00:20:22,497 --> 00:20:24,959
to forget all this data. The heap size in Braid is about 24

397
00:20:25,599 --> 00:20:28,381
seconds of gameplay, so, you know, after I've recorded 30

398
00:20:28,681 --> 00:20:30,702
minutes or 60 minutes and memory's full and I have to

399
00:20:30,722 --> 00:20:33,084
start forgetting, I forget 24 second chunks at a time.

400
00:20:34,047 --> 00:20:36,549
and that's about, you know, 60 frames per second, that's about

401
00:20:36,769 --> 00:20:41,171
1,000, or exactly, 1,440 frames per heap. Now, there's a

402
00:20:41,191 --> 00:20:43,533
constraint on this number, right? It can't effectively be

403
00:20:43,633 --> 00:20:47,575
smaller than the difference between base frames, right?

404
00:20:47,595 --> 00:20:50,297
Because if your first frame isn't a base frame, then you've

405
00:20:50,317 --> 00:20:52,658
got frames at the beginning of your data that you don't know

406
00:20:52,678 --> 00:20:54,639
how to decode because there's nowhere to go back to when you

407
00:20:54,659 --> 00:20:55,539
want to do the diff, right?

408
00:20:56,180 --> 00:20:59,802
So it has to be a multiple of two seconds, because that's how

409
00:20:59,842 --> 00:21:02,063
long I put between base frames, and 24 seconds seem pretty

410
00:21:02,083 --> 00:21:06,405
good. Now, this is still a lot of heaps. So if I've got 60

411
00:21:07,386 --> 00:21:10,988
minutes of gameplay recorded right now, and let's round it up

412
00:21:11,028 --> 00:21:16,811
to 30 seconds for easy math, that's 120 heaps live. But it

413
00:21:17,511 --> 00:21:20,493
seems like a lot. I've never done that before, but it seemed

414
00:21:20,513 --> 00:21:22,694
fine on all the target platforms. I did it again.

415
00:21:28,002 --> 00:21:34,047
I'm just going to maybe stay. Okay. So that's kind of the

416
00:21:34,107 --> 00:21:36,189
basics of the system. Now I'm going to talk about some special

417
00:21:36,209 --> 00:21:39,552
concerns that came up that are more specific to this game but

418
00:21:39,592 --> 00:21:42,014
that might have analogs in other games and how they were dealt

419
00:21:42,034 --> 00:21:47,299
with. Yeah, I'm going to stay. All right. So sound effects,

420
00:21:47,319 --> 00:21:48,880
whenever people ask me about this, I usually

421
00:21:51,216 --> 00:21:54,922
assume I did something crazy for sound effects. I try to guess

422
00:21:55,242 --> 00:21:57,826
when a sound would have finished and started up going backwards.

423
00:21:57,886 --> 00:22:01,211
That's not how it works at all. Sound effects are invisible

424
00:22:01,292 --> 00:22:03,315
entities just like everything else in the world.

425
00:22:05,511 --> 00:22:08,033
And then there's an audio layer that's a little more

426
00:22:08,113 --> 00:22:10,515
asynchronous even than usual. The audio layer is usually

427
00:22:10,535 --> 00:22:13,557
just streaming samples out to the audio hardware at its own

428
00:22:13,597 --> 00:22:18,000
rate. This one has a little layer that once per frame goes

429
00:22:18,040 --> 00:22:20,162
and looks at the world state, looks at all the entities that

430
00:22:20,182 --> 00:22:21,523
are supposed to be in the world state.

431
00:22:22,023 --> 00:22:24,486
creating sound and actually pulls the data. So it's pretty

432
00:22:24,566 --> 00:22:28,811
autonomous. It will create or destroy a stream that, you know,

433
00:22:28,831 --> 00:22:31,094
it will create a stream if there's an entity making sound

434
00:22:31,114 --> 00:22:34,779
that it hasn't got a stream for and vice versa. And so the app

435
00:22:34,999 --> 00:22:36,521
never directly plays a sound.

436
00:22:39,876 --> 00:22:42,898
And I actually like this a lot more, not even considering

437
00:22:42,938 --> 00:22:47,060
rewind. But this sort of sound in the world database approach

438
00:22:47,720 --> 00:22:50,221
I found is actually really nice for everything. And I use it in

439
00:22:50,241 --> 00:22:51,542
my new game, which doesn't even have rewind.

440
00:22:55,124 --> 00:22:59,488
you're going to call a sound effect. I don't want to keep

441
00:22:59,528 --> 00:23:02,671
the memory for it or keep storing it in rewind all the

442
00:23:02,711 --> 00:23:04,652
time. I want to know when the sound is done so I can delete

443
00:23:04,672 --> 00:23:07,595
it. You might check to see when all the samples are streamed

444
00:23:07,775 --> 00:23:10,978
out or look for an audio notification from your sound

445
00:23:10,998 --> 00:23:13,640
hardware. That's not a good idea because you're going to

446
00:23:14,341 --> 00:23:18,603
that is, with respect to the software, like your app, that

447
00:23:18,643 --> 00:23:21,765
is kind of non-deterministic. You don't exactly know when

448
00:23:21,785 --> 00:23:23,987
that's going to happen and if you rewind and do something

449
00:23:24,047 --> 00:23:28,710
again and the sound has been deleted, this time the audio

450
00:23:28,750 --> 00:23:31,952
clock might go a little longer and it just doesn't match up.

451
00:23:32,012 --> 00:23:35,474
So in Braid, sounds actually have their own timer that is

452
00:23:35,514 --> 00:23:39,196
tied to the game clock and not any kind of audio system clock.

453
00:23:41,341 --> 00:23:43,183
and if it's supposed to be a second long sound I just

454
00:23:43,203 --> 00:23:48,528
destroy it after a second plus a safety margin of about 10% to

455
00:23:48,608 --> 00:23:51,051
account for the fact that the clock on the audio hardware is

456
00:23:51,071 --> 00:23:53,513
going to be a little bit different from your idea of what

457
00:23:53,553 --> 00:23:58,358
the real time clock is. Okay. So the first thing I want to do is

458
00:23:59,427 --> 00:24:02,489
So I talked before about how it was really important that you

459
00:24:02,529 --> 00:24:04,631
make particles constant because it's a huge amount of data,

460
00:24:05,112 --> 00:24:07,053
but there's a whole world in braid where that's not true.

461
00:24:07,934 --> 00:24:10,076
In this world, you can drop this little ring that makes this

462
00:24:10,136 --> 00:24:12,058
bubble and time goes slowly inside the bubble,

463
00:24:12,138 --> 00:24:14,520
proceeding faster and faster as you radiate out from it.

464
00:24:15,300 --> 00:24:17,943
And I felt it was very important for the coherency of

465
00:24:17,983 --> 00:24:18,483
the world to

466
00:24:23,036 --> 00:24:25,957
to ensure that this affects all moving objects, right?

467
00:24:26,038 --> 00:24:27,398
And through all the other worlds,

468
00:24:27,418 --> 00:24:28,939
there's all this background particles

469
00:24:28,959 --> 00:24:30,860
that are noticeably moving.

470
00:24:31,220 --> 00:24:33,141
And so here, particles that are noticeably moving

471
00:24:33,621 --> 00:24:37,343
should be slowed by this as well.

472
00:24:37,403 --> 00:24:38,664
And what that means is that you can't

473
00:24:39,144 --> 00:24:41,025
use that approach I was talking about before, where you just

474
00:24:41,065 --> 00:24:43,706
generate the particles from a seed

475
00:24:44,087 --> 00:24:48,569
because you don't know where the ring's been for the past while.

476
00:24:48,609 --> 00:24:51,270
And so you try to apply that to the seed data, and it breaks.

477
00:24:52,211 --> 00:24:54,492
You get a lot of discontinuities when you pick up and drop the

478
00:24:54,532 --> 00:24:59,976
ring and stuff. So what do you do? Well, you can kind of guess.

479
00:25:00,716 --> 00:25:01,436
I just record it all.

480
00:25:03,079 --> 00:25:05,061
But I'm trying to be careful again to make it small.

481
00:25:05,461 --> 00:25:08,423
So I made a different kind of particle system that is only

482
00:25:08,483 --> 00:25:10,845
present in this world where you have time dilation.

483
00:25:11,525 --> 00:25:14,107
And on those base frames I was talking about before, it

484
00:25:14,147 --> 00:25:17,270
actually records the positions of all the particles.

485
00:25:17,310 --> 00:25:19,791
These particles don't have as much animation as the particles

486
00:25:19,831 --> 00:25:20,652
in the earlier world.

487
00:25:20,732 --> 00:25:22,733
So there's not a lot of state to record.

488
00:25:23,454 --> 00:25:26,476
Just a position and then a number that you can get the

489
00:25:26,496 --> 00:25:27,337
other properties from.

490
00:25:29,919 --> 00:25:36,180
Like the ring doesn't affect the color of the particle, it just

491
00:25:36,220 --> 00:25:36,921
affects the time.

492
00:25:37,061 --> 00:25:41,122
So you can reconstruct the color and rotation and all that, as long as you can reconstruct

493
00:25:41,142 --> 00:25:41,562
the time.

494
00:25:43,183 --> 00:25:48,364
So on non-base frames, though, I don't want to try to store diffs somehow of all these

495
00:25:48,404 --> 00:25:51,185
particles because that's still a giant amount of data, like one diff per particle.

496
00:25:51,225 --> 00:25:51,685
So what I do...

497
00:25:52,519 --> 00:25:54,320
I just store where the ring is because that's the only thing

498
00:25:54,340 --> 00:25:55,140
that can distort time.

499
00:25:55,661 --> 00:25:57,822
Because the base frames are 120 frames apart,

500
00:25:57,842 --> 00:26:01,505
that's up to 120 frames of data about where this time dilating

501
00:26:01,565 --> 00:26:01,985
object is.

502
00:26:02,025 --> 00:26:03,466
And when I implemented that, because I

503
00:26:03,506 --> 00:26:05,367
knew I was going to have to do the next thing I'm about to say,

504
00:26:05,387 --> 00:26:06,628
but I was like, no, I'm just going to try it.

505
00:26:07,309 --> 00:26:08,650
And it was a ton of data.

506
00:26:08,670 --> 00:26:11,512
Because on frame 119, you're storing 119 frames

507
00:26:11,972 --> 00:26:12,652
in that one frame.

508
00:26:12,672 --> 00:26:13,853
And on frame 118, you store 118.

509
00:26:13,913 --> 00:26:17,195
It's, yeah, it adds up real fast.

510
00:26:20,054 --> 00:26:22,995
there's an RLE, run length encoding kind of mechanism in

511
00:26:23,035 --> 00:26:25,917
there. Like that ring that you're carrying around, it's

512
00:26:25,937 --> 00:26:30,680
allowed to, I'm being told to cut off. All right. I'll take

513
00:26:30,720 --> 00:26:36,603
another one minute and then I'll cut off. Question? Come on up

514
00:26:36,643 --> 00:26:43,207
to the mic if you got one. Nobody? All right. Thank you

515
00:26:43,247 --> 00:26:43,567
very much.

516
00:26:51,892 --> 00:26:51,937
Oh

