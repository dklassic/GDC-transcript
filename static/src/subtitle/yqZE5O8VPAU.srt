1
00:00:05,260 --> 00:00:07,380
Hello, my name is Eric Johnson.

2
00:00:07,380 --> 00:00:08,981
I'm an AI programmer at Kojima Productions.

3
00:00:08,981 --> 00:00:12,241
And today I want to share with you some of the AI features

4
00:00:12,241 --> 00:00:14,962
we built, challenges we faced, and things

5
00:00:14,962 --> 00:00:17,543
we learned during the development of Death Stranding.

6
00:00:17,543 --> 00:00:19,903
This is primarily a navigation talk.

7
00:00:19,903 --> 00:00:22,544
To that end, I want to begin by discussing the game

8
00:00:22,544 --> 00:00:25,264
environment and why it was such a challenge for us

9
00:00:25,264 --> 00:00:28,425
to work with, game design's goals for NPCs,

10
00:00:28,425 --> 00:00:30,846
and how they affected our approach to dealing

11
00:00:30,846 --> 00:00:32,466
with the environment, how we reflected

12
00:00:32,466 --> 00:00:34,587
the complexity of the terrain on the nav mesh.

13
00:00:35,162 --> 00:00:37,184
the impact this complexity had on navigation,

14
00:00:37,184 --> 00:00:41,006
support for different types of dynamic terrain,

15
00:00:41,006 --> 00:00:44,589
a quick look at a trick we used to improve position selection

16
00:00:44,589 --> 00:00:47,791
in our environments, and a peek into a few of the other AI

17
00:00:47,791 --> 00:00:49,072
systems we built for the game.

18
00:00:50,694 --> 00:00:52,756
First, I want to give special thanks to Guerrilla

19
00:00:52,756 --> 00:00:54,537
for providing us with the Decima engine

20
00:00:54,537 --> 00:00:55,738
on which Death Stranding is built,

21
00:00:55,738 --> 00:00:57,660
as well as the ongoing support

22
00:00:57,660 --> 00:00:59,121
they've given us throughout development.

23
00:00:59,121 --> 00:01:01,663
I also want to thank the rest of the NPC team

24
00:01:01,663 --> 00:01:02,904
at Kojima Productions,

25
00:01:02,904 --> 00:01:05,186
whose work I'll be sharing with you today.

26
00:01:05,186 --> 00:01:08,889
Without them, this talk would not be possible.

27
00:01:08,889 --> 00:01:11,311
So, as most of you are probably familiar,

28
00:01:11,311 --> 00:01:12,552
Death Stranding is a game

29
00:01:12,552 --> 00:01:15,334
with a heavy focus on environmental traversal,

30
00:01:15,334 --> 00:01:18,056
deciding your route, what equipment to bring,

31
00:01:18,056 --> 00:01:19,497
and how to approach the landscape.

32
00:01:20,987 --> 00:01:26,111
overcoming environmental obstacles using a variety of tools at your disposal,

33
00:01:26,111 --> 00:01:31,396
such as ropes, ladders, and bridges,

34
00:01:31,396 --> 00:01:36,540
all in order to ultimately reach your destination. But it's not just these large-scale obstacles you

35
00:01:36,540 --> 00:01:45,067
need to worry about. Even flat terrain is difficult to traverse. You can lose your balance and stumble,

36
00:01:45,067 --> 00:01:46,588
slip in the mud when it rains,

37
00:01:50,023 --> 00:01:56,148
lose your footing on steep slopes,

38
00:01:56,148 --> 00:01:58,630
or get swept away by the current of rivers.

39
00:01:58,630 --> 00:02:02,032
Every step has the potential to be hazardous.

40
00:02:02,032 --> 00:02:05,095
So, to create an environment where even walking would be a challenge,

41
00:02:05,095 --> 00:02:09,619
in the early days of the company, the team went location hunting in Iceland to gather reference material.

42
00:02:09,619 --> 00:02:16,244
While they were there, they toured volcanic rock fields, rivers, valleys, and gorges.

43
00:02:17,097 --> 00:02:22,539
crevices, caves, and geysers, which they reference to create environments like these. Take a look.

44
00:03:01,981 --> 00:03:04,902
So these were the types of beautiful but unforgiving

45
00:03:04,902 --> 00:03:06,582
landscapes the environment team had created

46
00:03:06,582 --> 00:03:07,763
to challenge the player.

47
00:03:07,763 --> 00:03:09,783
But if this terrain was meant to be

48
00:03:09,783 --> 00:03:12,264
difficult for the player to traverse,

49
00:03:12,264 --> 00:03:16,145
this meant it was going to be even harder for the AI.

50
00:03:16,145 --> 00:03:17,566
Because while the central challenge

51
00:03:17,566 --> 00:03:19,306
is overcoming the environment, it's

52
00:03:19,306 --> 00:03:20,727
not the player's only obstacle.

53
00:03:20,727 --> 00:03:22,567
There are, of course, enemy encounters.

54
00:03:22,567 --> 00:03:24,388
And the ones I want to talk about today

55
00:03:24,388 --> 00:03:27,669
are mules, melee enemies that chase after the player

56
00:03:27,669 --> 00:03:28,729
and steal their cargo.

57
00:03:30,142 --> 00:03:32,704
Terrorists, ranged attackers whose target is the player

58
00:03:32,704 --> 00:03:35,225
who can use cover, and the catchers,

59
00:03:35,225 --> 00:03:39,347
giant BTs who need to be able to navigate around,

60
00:03:39,347 --> 00:03:45,210
climb on top of, and even destroy dynamic terrain.

61
00:03:45,210 --> 00:03:46,671
During the concept phase,

62
00:03:46,671 --> 00:03:48,352
the core gameplay loop revolved around

63
00:03:48,352 --> 00:03:50,393
the cat and mouse game of mules searching for

64
00:03:50,393 --> 00:03:51,754
and stealing the player's cargo,

65
00:03:51,754 --> 00:03:53,155
as the player attempted to make it

66
00:03:53,155 --> 00:03:55,236
through hostile territory to complete their delivery.

67
00:03:56,423 --> 00:03:58,605
Because they'd need to steal packages directly from the player,

68
00:03:58,605 --> 00:04:02,568
as much as possible, we would need to provide traversal parity.

69
00:04:02,568 --> 00:04:06,611
Wherever the player could move, mules would need to be able to follow.

70
00:04:06,611 --> 00:04:09,534
Similarly, if cargo was dropped onto the terrain,

71
00:04:09,534 --> 00:04:13,657
NPCs would need to be able to reach it to pick it up wherever it lands.

72
00:04:13,657 --> 00:04:17,580
Finally, a lot of effort was placed on making the player interact realistically

73
00:04:17,580 --> 00:04:19,482
with the terrain to feel grounded.

74
00:04:19,482 --> 00:04:22,304
We wanted NPCs to have a similar level of fidelity.

75
00:04:24,193 --> 00:04:25,334
Here's where we started.

76
00:04:25,334 --> 00:04:26,635
This is our first AI prototype.

77
00:04:26,635 --> 00:04:30,857
You can see here the mules are searching the area for cargo.

78
00:04:30,857 --> 00:04:34,120
The player can subdue them with a non-lethal takedown.

79
00:04:34,120 --> 00:04:36,962
And while still undetected, they are

80
00:04:36,962 --> 00:04:38,263
able to escape and make their way

81
00:04:38,263 --> 00:04:48,870
towards the cargo destination.

82
00:04:48,870 --> 00:04:51,172
A year later, we had added more non-lethal weapons

83
00:04:51,172 --> 00:04:51,812
like the Bola gun.

84
00:04:52,728 --> 00:04:57,790
NPCs could now respond to noise and perform investigation behaviors.

85
00:04:57,790 --> 00:05:02,052
Perception had been iterated on, enabling the player to evade the enemy in tall grass,

86
00:05:02,052 --> 00:05:05,893
but NPCs now had the ability to ping the player's cargo to track them down.

87
00:05:05,893 --> 00:05:11,515
Still, the gameplay loop remained focused on evading and escaping rather than fighting.

88
00:05:11,515 --> 00:05:18,778
And here's the final version that we shipped. When the player enters mule territory,

89
00:05:18,778 --> 00:05:19,898
their cargo is pinged.

90
00:05:22,027 --> 00:05:26,410
A search party is formed and a group of enemies move to the pinged location to try and find

91
00:05:26,410 --> 00:05:27,391
the cargo that was detected.

92
00:05:27,391 --> 00:05:32,155
This gives the player an opportunity to escape while they're searching for the package.

93
00:05:32,155 --> 00:05:39,200
If the player successfully evades the enemy long enough, they will re-ping the area and

94
00:05:39,200 --> 00:05:40,962
the cat and mouse game begins again.

95
00:05:46,165 --> 00:05:49,026
But if the player is spotted, all mules in the encampment

96
00:05:49,026 --> 00:05:50,726
will immediately begin chasing the player

97
00:05:50,726 --> 00:05:54,247
to steal their cargo, switching gameplay from evasion to escape.

98
00:05:54,247 --> 00:05:56,928
This is the core loop the NPC team

99
00:05:56,928 --> 00:05:58,588
was responsible for delivering.

100
00:05:58,588 --> 00:06:00,689
And one of the major components in doing so

101
00:06:00,689 --> 00:06:06,951
was developing reliable navigation over the terrain.

102
00:06:06,951 --> 00:06:08,371
So why is this terrain such an issue?

103
00:06:08,371 --> 00:06:10,932
And what kinds of problems does it create for the NavMesh?

104
00:06:12,615 --> 00:06:15,135
To explain, let's start by looking at some NavMesh

105
00:06:15,135 --> 00:06:17,096
that represents what we were used to seeing

106
00:06:17,096 --> 00:06:19,257
in a typical production.

107
00:06:19,257 --> 00:06:22,958
Here's a man-made environment with flat level ground,

108
00:06:22,958 --> 00:06:26,159
open spaces, clearly defined walls and corridors.

109
00:06:26,159 --> 00:06:31,700
There are challenges in navigation over a NavMesh like this,

110
00:06:31,700 --> 00:06:33,561
positioning, finding cover, flanking,

111
00:06:33,561 --> 00:06:36,442
but these are ones that we were generally familiar with

112
00:06:36,442 --> 00:06:38,762
and knew how to handle.

113
00:06:38,762 --> 00:06:40,483
Likewise, in natural environments,

114
00:06:41,443 --> 00:06:45,725
NavMesh was often just a continuous sheet with the occasional hole where rocks, trees,

115
00:06:45,725 --> 00:06:49,686
and other obstacles have been placed to decorate the terrain.

116
00:06:49,686 --> 00:06:53,727
However, because the environment in Death Stranding was designed first as an obstacle

117
00:06:53,727 --> 00:06:55,967
for the player, our NavMesh now looked like this.

118
00:06:55,967 --> 00:07:01,709
Everywhere we looked, there were jagged shapes with sharp turns, thin strips of NavMesh,

119
00:07:01,709 --> 00:07:05,050
and tiny, disconnected NavMesh islands covering the landscape.

120
00:07:06,112 --> 00:07:10,575
Normally, we would either make these areas off limits to the AI or work with level design

121
00:07:10,575 --> 00:07:13,097
to make them easier to traverse.

122
00:07:13,097 --> 00:07:17,321
But in order to chase the player in the world of Death Stranding, this time, neither of

123
00:07:17,321 --> 00:07:18,001
those was an option.

124
00:07:18,001 --> 00:07:25,107
To illustrate just how much more complex things had become for us, seen from above, the difference

125
00:07:25,107 --> 00:07:27,769
between the two looks like this.

126
00:07:27,769 --> 00:07:31,572
Both of these areas are the same scale and show a single NavMesh tile, but for every

127
00:07:31,572 --> 00:07:34,635
NavMesh polygon on the left, there are a dozen on the right.

128
00:07:35,788 --> 00:07:38,550
This was much more complex than anything we dealt with before.

129
00:07:38,550 --> 00:07:43,853
But let's take a step back, because you may have noticed,

130
00:07:43,853 --> 00:07:46,175
even if the terrain in the complex example

131
00:07:46,175 --> 00:07:49,276
has collision like this, at worst,

132
00:07:49,276 --> 00:07:52,698
the NavMesh should look something like this.

133
00:07:52,698 --> 00:07:53,779
So what is this mess?

134
00:07:53,779 --> 00:07:59,422
To explain, let's take a look at some sample terrain.

135
00:07:59,422 --> 00:08:01,584
Here we have some grassy hills on the left,

136
00:08:01,584 --> 00:08:03,185
rocky terrain on the right, and a river

137
00:08:03,185 --> 00:08:04,365
that cuts through the middle.

138
00:08:06,193 --> 00:08:08,954
In the beginning, this is what a NavMesh looked like.

139
00:08:08,954 --> 00:08:10,715
For humanoid NPCs, it was configured

140
00:08:10,715 --> 00:08:12,316
so that they would stay out of the water

141
00:08:12,316 --> 00:08:14,557
and step around rocks too big to climb over.

142
00:08:14,557 --> 00:08:18,760
However, the player's movement controller

143
00:08:18,760 --> 00:08:21,441
could automatically detect and step over obstacles

144
00:08:21,441 --> 00:08:23,842
that are roughly knee-high.

145
00:08:23,842 --> 00:08:26,043
So NPCs needed to be able to as well if they were

146
00:08:26,043 --> 00:08:27,904
going to follow the player.

147
00:08:27,904 --> 00:08:32,107
So we first raised the NavMesh step height,

148
00:08:32,107 --> 00:08:34,168
covering most of the areas where these small rocks were.

149
00:08:35,354 --> 00:08:37,496
Then we added raycast checks in front of the NPC

150
00:08:37,496 --> 00:08:40,318
to detect these small ledges, and then

151
00:08:40,318 --> 00:08:43,200
play special step up and step down animations

152
00:08:43,200 --> 00:08:45,201
to get over them.

153
00:08:45,201 --> 00:08:48,083
However, if the player runs over those same rocks,

154
00:08:48,083 --> 00:08:50,625
there is a chance they'll trip and lose their balance.

155
00:08:50,625 --> 00:08:52,526
And we wanted NPCs to do this as well

156
00:08:52,526 --> 00:08:54,688
to show that it's just as hard for them to traverse

157
00:08:54,688 --> 00:08:56,048
the terrain as it is for the player.

158
00:08:56,048 --> 00:08:59,971
So we implemented ground material checks

159
00:08:59,971 --> 00:09:02,053
that could trigger specific animations.

160
00:09:02,323 --> 00:09:07,226
When stepping onto a rocky material, we added a random chance for an NPC to slip or stumble.

161
00:09:07,226 --> 00:09:13,629
Of course, knowing this, the player learns to avoid running over rocks to prevent tripping,

162
00:09:13,629 --> 00:09:16,810
so NPCs should have enough understanding of the terrain to do so as well.

163
00:09:16,810 --> 00:09:22,893
But how are we going to add that? The answer is something we call placement painting.

164
00:09:22,893 --> 00:09:30,037
Most of the rocks, grass, and other decoration on the terrain are added via Decima's procedural

165
00:09:30,037 --> 00:09:30,877
placement system.

166
00:09:31,935 --> 00:09:34,416
For Rock Spawn in this way, we painted the nav mesh

167
00:09:34,416 --> 00:09:36,597
with a high cost area that surrounded each one.

168
00:09:36,597 --> 00:09:40,219
This encourages the navigation system

169
00:09:40,219 --> 00:09:42,860
to produce paths that go around obstacles

170
00:09:42,860 --> 00:09:44,901
without removing the nav mesh on top of them.

171
00:09:44,901 --> 00:09:48,522
This means that NPCs can still walk through rocky areas,

172
00:09:48,522 --> 00:09:50,423
but they'll only do so if there are no better options.

173
00:09:50,423 --> 00:09:55,105
The player is also able to wade through deep water.

174
00:09:55,105 --> 00:09:56,166
So in order to give chase,

175
00:09:56,166 --> 00:09:57,786
NPCs need to be able to follow them

176
00:09:57,786 --> 00:09:59,267
into and through these areas too.

177
00:10:01,477 --> 00:10:05,097
So we ensure that there is NavMesh generated over the water as well.

178
00:10:05,097 --> 00:10:11,098
This works, but as you can see, wading through water is very slow,

179
00:10:11,098 --> 00:10:14,139
and it's easy for a player on land to get away from a mule in the water.

180
00:10:14,139 --> 00:10:20,760
In addition, because it can drain stamina, players learn that in general it's better

181
00:10:20,760 --> 00:10:25,441
to avoid moving through water when possible.

182
00:10:25,441 --> 00:10:28,381
To handle this, we applied the same strategy as placement painting.

183
00:10:28,943 --> 00:10:31,425
We paint a high-cost area onto the nav mesh

184
00:10:31,425 --> 00:10:34,747
wherever water is present, allowing navigation through it,

185
00:10:34,747 --> 00:10:36,849
but discouraging NPCs from entering,

186
00:10:36,849 --> 00:10:39,631
unless it's the fastest way to the destination.

187
00:10:39,631 --> 00:10:41,613
We actually shrink this a little bit,

188
00:10:41,613 --> 00:10:44,675
only painting areas with at least 30 centimeters of water,

189
00:10:44,675 --> 00:10:48,798
as this is the threshold for the wading animation.

190
00:10:48,798 --> 00:10:50,960
As a result, NPCs would now skirt

191
00:10:50,960 --> 00:10:52,521
right along the edges of the shore,

192
00:10:52,521 --> 00:10:54,503
taking as optimal a route as possible when

193
00:10:54,503 --> 00:10:55,663
going around bodies of water.

194
00:10:57,957 --> 00:11:01,339
And that is how we got from this rough but still reasonable

195
00:11:01,339 --> 00:11:05,261
nav mesh on the left to this multicolored mesh on the right.

196
00:11:05,261 --> 00:11:08,382
But in doing so, we created a huge amount

197
00:11:08,382 --> 00:11:09,823
of new problems for ourselves.

198
00:11:09,823 --> 00:11:12,464
The first being the cost of pathfinding itself.

199
00:11:12,464 --> 00:11:14,545
Due to the size of the environment,

200
00:11:14,545 --> 00:11:16,566
the search area can be very large.

201
00:11:16,566 --> 00:11:19,508
So to manage performance, we kept A star search

202
00:11:19,508 --> 00:11:20,588
to 500 iterations.

203
00:11:20,588 --> 00:11:21,809
Often, this is not an issue.

204
00:11:21,809 --> 00:11:24,230
Take, for example, this scene from the time fall farm.

205
00:11:26,132 --> 00:11:31,135
If we take a look at a nav mesh, we can see some fences and small structures over basically

206
00:11:31,135 --> 00:11:34,157
flat terrain, nothing too complicated.

207
00:11:34,157 --> 00:11:37,379
We then try to find a path from the left side to the right.

208
00:11:37,379 --> 00:11:39,840
The result looks something like this.

209
00:11:39,840 --> 00:11:45,003
The green polygons are a path corridor, and then the nodes explored during ASTAR are shaded

210
00:11:45,003 --> 00:11:47,004
from yellow to red depending on when they were opened.

211
00:11:47,004 --> 00:11:52,828
In this example, we were able to successfully generate a complete path over a distance of

212
00:11:52,828 --> 00:11:54,729
about 200 meters without any issues.

213
00:11:56,963 --> 00:12:03,467
However, if we move to another area with more complex terrain, like the cliffs by this mule camp,

214
00:12:03,467 --> 00:12:06,569
we can see that the navmesh is much more fragmented.

215
00:12:06,569 --> 00:12:11,733
And if we then try to perform the same pathfinding request, navigating from the left to the right,

216
00:12:11,733 --> 00:12:17,537
we're only able to generate a partial path, and don't even make it 25 meters before hitting our 500 node iteration cap.

217
00:12:17,537 --> 00:12:19,198
Compared to the timefall farm,

218
00:12:19,660 --> 00:12:22,923
which produced a 200 meter path without hitting this limit.

219
00:12:22,923 --> 00:12:25,726
So depending on the location, the farthest range

220
00:12:25,726 --> 00:12:28,249
at which we could reliably produce a complete path

221
00:12:28,249 --> 00:12:31,072
would change dramatically.

222
00:12:31,072 --> 00:12:33,134
On top of this, the NavMesh in Death Stranding

223
00:12:33,134 --> 00:12:36,097
is generated at runtime using NavMesh bubbles placed

224
00:12:36,097 --> 00:12:37,438
on NPCs and the player.

225
00:12:37,438 --> 00:12:40,461
This means that it's common for NavMesh

226
00:12:40,461 --> 00:12:42,944
to not even exist at the destination we begin moving.

227
00:12:45,502 --> 00:12:50,285
So because NavMesh polygons are much smaller, it is now much more expensive to run pathfinding

228
00:12:50,285 --> 00:12:54,427
as more nodes need to be explored than when we started.

229
00:12:54,427 --> 00:12:58,389
As well, there's no guarantee that we'll get a complete path to a reachable destination

230
00:12:58,389 --> 00:13:00,671
either, even for very short distances.

231
00:13:00,671 --> 00:13:06,234
So at some point while following one of these incomplete paths, we knew we'd need to repath

232
00:13:06,234 --> 00:13:08,936
to continue making progress, but how could we determine when this is?

233
00:13:09,984 --> 00:13:13,627
Well, to start, how do we normally decide when to repath?

234
00:13:13,627 --> 00:13:17,010
When we're following a complete path and we want to detect when something has gone

235
00:13:17,010 --> 00:13:22,054
wrong, common methods include ray casting ahead to a point further along the path.

236
00:13:22,054 --> 00:13:25,777
If we hit anything, it means we've deviated too far from our path or

237
00:13:25,777 --> 00:13:27,918
detected a change in the nav mesh.

238
00:13:27,918 --> 00:13:32,502
Or we can automatically repath at regular intervals, avoiding the issue by ensuring

239
00:13:32,502 --> 00:13:35,605
that a path is only ever going to be invalid for a limited amount of time.

240
00:13:37,690 --> 00:13:40,331
However, both of these techniques have their own issues.

241
00:13:40,331 --> 00:13:42,053
Ray casting only detects problems

242
00:13:42,053 --> 00:13:43,453
immediately in front of us.

243
00:13:43,453 --> 00:13:46,375
Even if we can see a change in the environment further away,

244
00:13:46,375 --> 00:13:48,977
we won't respond to it until we get close.

245
00:13:48,977 --> 00:13:50,478
For time-free pathing,

246
00:13:50,478 --> 00:13:52,940
it isn't clear how frequent is frequent enough.

247
00:13:52,940 --> 00:13:55,461
Too slow when we run into things,

248
00:13:55,461 --> 00:13:58,223
too fast and we waste performance performing pathfinding

249
00:13:58,223 --> 00:13:59,804
when nothing's wrong.

250
00:13:59,804 --> 00:14:01,825
On top of that, it introduces another problem.

251
00:14:03,835 --> 00:14:08,919
So it turns out that in early development, this was actually the method we were using,

252
00:14:08,919 --> 00:14:13,802
rebounding twice a second and simply heading towards the next waypoint in the path.

253
00:14:13,802 --> 00:14:18,885
Around this time, we received reports that NPCs were occasionally looking around when patrolling,

254
00:14:18,885 --> 00:14:22,568
which was strange because we hadn't actually added any behavior to do that.

255
00:14:23,114 --> 00:14:25,536
And we thought it might be an aim or look at bug,

256
00:14:25,536 --> 00:14:28,418
but on closer investigation, we discovered

257
00:14:28,418 --> 00:14:30,999
that at specific points along the patrol route,

258
00:14:30,999 --> 00:14:33,521
the path could change completely for just a moment

259
00:14:33,521 --> 00:14:34,442
and then revert back.

260
00:14:34,442 --> 00:14:37,664
And you can see that here when the mule reaches the yellow

261
00:14:37,664 --> 00:14:38,084
arrow.

262
00:14:38,084 --> 00:14:40,226
This would actually be expected.

263
00:14:40,226 --> 00:14:43,828
When pathfinding, depending on your starting location

264
00:14:43,828 --> 00:14:45,669
in an avmesh polygon, there may be

265
00:14:45,669 --> 00:14:47,891
completely different optimal routes to the target.

266
00:14:48,425 --> 00:14:52,747
By chance, we were repathing after crossing one of these thresholds,

267
00:14:52,747 --> 00:14:57,148
which resulted in the NPC turning momentarily towards the new path,

268
00:14:57,148 --> 00:14:59,889
and then back again on the next repath.

269
00:14:59,889 --> 00:15:01,569
It was clear we needed a better system.

270
00:15:01,569 --> 00:15:04,210
Because our search range was limited,

271
00:15:04,973 --> 00:15:07,534
We knew we might need to perform multiple pathfinding requests

272
00:15:07,534 --> 00:15:11,175
to reach targets, even ones as close as 25 meters away.

273
00:15:11,175 --> 00:15:13,116
We also wanted to repath automatically

274
00:15:13,116 --> 00:15:15,856
as soon as an issue was detected, but no sooner,

275
00:15:15,856 --> 00:15:19,397
both to improve performance and to avoid the instability

276
00:15:19,397 --> 00:15:21,718
we were experiencing.

277
00:15:21,718 --> 00:15:24,279
So we first identified five conditions

278
00:15:24,279 --> 00:15:28,200
that could require a repath in order to reach our destination.

279
00:15:28,200 --> 00:15:30,700
To illustrate them, here we have an agent on the left

280
00:15:30,700 --> 00:15:32,441
following a path to a target on the right.

281
00:15:33,090 --> 00:15:38,054
and the white squares represent the NavMesh polygons of the path corridor.

282
00:15:38,054 --> 00:15:42,277
The first situation is if the agent moves outside of the path corridor entirely.

283
00:15:42,277 --> 00:15:48,602
This could happen if the NPC misses a turn or is pushed out by an external force.

284
00:15:48,602 --> 00:15:52,285
Similarly, we could also require a path if the destination moves

285
00:15:52,285 --> 00:15:54,106
outside its polygon at the end of the path corridor.

286
00:15:56,570 --> 00:15:59,392
Or if a polygon in the corridor becomes invalid,

287
00:15:59,392 --> 00:16:02,534
that indicates that the NavMesh at that location has changed.

288
00:16:02,534 --> 00:16:05,196
This can happen if an obstacle is added or removed,

289
00:16:05,196 --> 00:16:07,317
or if NavMesh no longer exists there.

290
00:16:07,317 --> 00:16:10,620
A tricky one is that in the event

291
00:16:10,620 --> 00:16:15,103
that NavMesh tiles have not been generated at our destination,

292
00:16:15,103 --> 00:16:16,844
to serve as a temporary stand-in,

293
00:16:16,844 --> 00:16:19,506
we clamp the destination to the boundary of the closest

294
00:16:19,506 --> 00:16:22,168
NavMesh tile in the direction of the agent

295
00:16:22,168 --> 00:16:23,649
and navigate to that point instead.

296
00:16:25,002 --> 00:16:27,144
then if this clamp location moves,

297
00:16:27,144 --> 00:16:29,246
that indicates that NavMesh tiles

298
00:16:29,246 --> 00:16:30,587
between the agent and the target

299
00:16:30,587 --> 00:16:32,128
have either been added or removed,

300
00:16:32,128 --> 00:16:35,171
or that the destination itself has moved.

301
00:16:35,171 --> 00:16:39,154
If this occurs, a better path may now be available.

302
00:16:39,154 --> 00:16:41,557
Now, finally, if none of the above situations occur

303
00:16:41,557 --> 00:16:44,579
and we successfully navigate to the end of the path,

304
00:16:44,579 --> 00:16:46,361
but the path itself is incomplete

305
00:16:46,361 --> 00:16:48,583
due to hitting the A-star iteration cap,

306
00:16:48,583 --> 00:16:50,324
we can try repatting again on arrival

307
00:16:50,324 --> 00:16:52,286
to see if we can make any further progress

308
00:16:52,286 --> 00:16:53,066
from our new location.

309
00:17:00,030 --> 00:17:01,451
In order to support this, we needed

310
00:17:01,451 --> 00:17:03,792
to move away from simple waypoint following

311
00:17:03,792 --> 00:17:06,813
and monitor both the path and the path corridor.

312
00:17:06,813 --> 00:17:08,973
So we added a validator that would run every frame

313
00:17:08,973 --> 00:17:11,674
during navigation, checking all repath conditions

314
00:17:11,674 --> 00:17:12,975
that we had identified.

315
00:17:12,975 --> 00:17:15,436
If any condition failed, it would automatically

316
00:17:15,436 --> 00:17:16,716
trigger a repath request.

317
00:17:16,716 --> 00:17:19,857
Then this new path would replace the current one,

318
00:17:19,857 --> 00:17:23,459
and navigation will continue uninterrupted.

319
00:17:23,459 --> 00:17:26,520
Here's our event-based repathing system in action.

320
00:17:26,520 --> 00:17:28,180
So long as no validation errors occur.

321
00:17:28,856 --> 00:17:32,840
We continue following our initial path, avoiding any unnecessary pathfinding calls.

322
00:17:32,840 --> 00:17:37,524
However, if a qualifying event occurs, such as a change in the navmesh,

323
00:17:37,524 --> 00:17:41,548
a corridor passes through, validation will trigger a repath,

324
00:17:41,548 --> 00:17:43,730
which replaces the original while we are moving.

325
00:17:43,730 --> 00:17:48,595
You can see that this happens both when an obstacle appears in our path and when it's removed.

326
00:17:53,437 --> 00:17:57,721
And here's an example of the validation check for tile clamped locations.

327
00:17:57,721 --> 00:18:01,565
As the NPC moves, new tiles are generated around its navmesh bubble.

328
00:18:01,565 --> 00:18:05,889
When this happens, it causes the clamp destination to move, triggering a

329
00:18:05,889 --> 00:18:09,432
repath that lets the agent make incremental progress toward the destination.

330
00:18:14,072 --> 00:18:17,952
So now agents were navigating, but they weren't navigating well.

331
00:18:17,952 --> 00:18:22,213
We started getting reports that NPCs on patrol were taking weird detours,

332
00:18:22,213 --> 00:18:27,675
even when they should have had a clear path to their destination.

333
00:18:27,675 --> 00:18:30,595
When we investigated, we saw the path and the port or the NPCs were

334
00:18:30,595 --> 00:18:34,356
following look like this, but why would this happen?

335
00:18:34,356 --> 00:18:36,457
Why would ASTI return this as the core?

336
00:18:39,007 --> 00:18:40,307
This is what we were expecting.

337
00:18:40,307 --> 00:18:42,729
If there is nothing between us and the destination,

338
00:18:42,729 --> 00:18:46,391
we should be getting a simple two-point path passing

339
00:18:46,391 --> 00:18:48,813
straight through the corridor.

340
00:18:48,813 --> 00:18:51,054
However, this is what we were actually getting.

341
00:18:51,054 --> 00:18:54,136
The problem is that the path corridor is generated

342
00:18:54,136 --> 00:18:56,898
by searching between the midpoints of navmesh polygon

343
00:18:56,898 --> 00:18:59,860
edges, which is only an approximation of the shortest

344
00:18:59,860 --> 00:19:02,081
path to the destination.

345
00:19:02,081 --> 00:19:04,483
When we then string pull a path through this corridor,

346
00:19:05,189 --> 00:19:10,291
kinks will appear wherever there's a large difference between the approximation and the optimal paths.

347
00:19:10,291 --> 00:19:17,613
I should add that you don't need a tiled nav mesh for this to happen either.

348
00:19:17,613 --> 00:19:21,734
In this example, if I search for a path from the blue point on the left to the red target on the

349
00:19:21,734 --> 00:19:27,456
right, because the edge midpoints used during pathfinding look like this,

350
00:19:28,628 --> 00:19:34,452
and it's the shortest path that passes through these midpoints that determines the path corridor,

351
00:19:34,452 --> 00:19:40,175
a situation like this results in a path like this.

352
00:19:40,175 --> 00:19:44,518
But by chance, while we were working on how to deal with this, I was rereading the author of

353
00:19:44,518 --> 00:19:49,661
Recast, Miko Manonen's old blog post about its development. Here he is describing the

354
00:19:49,661 --> 00:19:54,023
funnel algorithm in a post from over 10 years ago on March 8, 2010.

355
00:19:55,477 --> 00:19:59,280
In the comments section, someone posted that they were having the exact same issue.

356
00:19:59,280 --> 00:20:03,483
Kingston, what should have been a straight path over a tiled navmesh?

357
00:20:03,483 --> 00:20:09,068
Mikko's recommendation was to use navmesh raycast to find waypoints in the path that could be skipped,

358
00:20:09,068 --> 00:20:13,432
then replace the section of the path corridor between those two points with the corridor

359
00:20:13,432 --> 00:20:20,477
returned by the navmesh raycast. So this is exactly what we did.

360
00:20:20,477 --> 00:20:24,361
Starting at the first waypoint in the path, we skip over the second waypoint,

361
00:20:24,940 --> 00:20:28,763
and perform a NavMesh raycast to each remaining point in the path.

362
00:20:28,763 --> 00:20:30,904
And remember the last successful result.

363
00:20:30,904 --> 00:20:36,248
We continue until we reach the end or the raycast hits something.

364
00:20:36,248 --> 00:20:41,051
Once either happens, we stop, remove the portion of the

365
00:20:41,051 --> 00:20:44,973
path corridor from the start to the last successful result,

366
00:20:44,973 --> 00:20:49,176
and replace it with the corridor returned by the raycast.

367
00:20:49,176 --> 00:20:51,237
Now this part of the corridor has been straightened.

368
00:20:52,427 --> 00:20:55,707
and we repeat the process from the next uncorrected node.

369
00:20:55,707 --> 00:20:58,668
In this case, the original corridor is already optimal,

370
00:20:58,668 --> 00:21:00,489
so we keep it and return the merged result.

371
00:21:00,489 --> 00:21:02,509
In the version we shipped,

372
00:21:02,509 --> 00:21:06,110
we actually performed this straightening operation

373
00:21:06,110 --> 00:21:08,631
a second time from the end of the path to the start,

374
00:21:08,631 --> 00:21:11,652
which is usually enough to find all potential shortcuts

375
00:21:11,652 --> 00:21:13,152
in most situations.

376
00:21:13,757 --> 00:21:16,999
In addition, even if the raycast is successful,

377
00:21:16,999 --> 00:21:19,100
it may pass through a high cost area of NAV.

378
00:21:19,100 --> 00:21:21,882
So we only replace the corridor section

379
00:21:21,882 --> 00:21:24,684
if the straightened version has a lower traversal cost.

380
00:21:24,684 --> 00:21:28,267
Now our corridor has been straightened,

381
00:21:28,267 --> 00:21:29,888
but there's still one more step.

382
00:21:29,888 --> 00:21:31,669
We need to perform string pulling again

383
00:21:31,669 --> 00:21:33,110
through the straightened corridor

384
00:21:33,110 --> 00:21:35,692
to generate the final path, like this.

385
00:21:42,137 --> 00:21:43,838
And here's the final result.

386
00:21:43,838 --> 00:21:46,159
Path quality had been greatly improved,

387
00:21:46,159 --> 00:21:48,921
and NPCs were now navigating directly to their destination.

388
00:21:48,921 --> 00:21:53,964
At this point, things were looking good.

389
00:21:53,964 --> 00:21:56,105
NPCs could handle different types of terrain,

390
00:21:56,105 --> 00:21:59,627
repath on their own, and navigation looked natural

391
00:21:59,627 --> 00:22:00,607
until they started to run.

392
00:22:00,607 --> 00:22:04,650
Because we had stopped repathing on timed intervals,

393
00:22:05,313 --> 00:22:10,815
NPCs could deviate significantly from the original path as long as they stayed in their path corridor.

394
00:22:10,815 --> 00:22:14,015
And because we simply steered directly towards the next waypoint on the path,

395
00:22:14,015 --> 00:22:18,537
it was possible for them to get into a situation where that waypoint was no longer reachable.

396
00:22:18,537 --> 00:22:22,738
Here you can see that after an NPC passes the first two waypoints,

397
00:22:22,738 --> 00:22:27,620
it attempts to move directly towards the player, but falls out of the path corridor, triggering a repath.

398
00:22:28,347 --> 00:22:37,696
Because of its large turn radius while running, it then misses those waypoints, exits the corridor again, causing another repath, creating a situation where it's never able to reach its goal.

399
00:22:37,696 --> 00:22:49,028
It turns out that this problem had also been solved over 10 years ago, and the solution was in the exact same blog entry we referenced to straighten path corridors.

400
00:22:50,355 --> 00:22:53,297
At the end of Mikko's post about the funnel algorithm,

401
00:22:53,297 --> 00:22:55,819
he noted that it's so fast, you could perform string pulling

402
00:22:55,819 --> 00:22:57,661
over the path corridor every frame

403
00:22:57,661 --> 00:23:01,723
to find the next corridor or corner to steer towards,

404
00:23:01,723 --> 00:23:04,145
which is also exactly what we did.

405
00:23:04,145 --> 00:23:06,827
Now when the NPC makes its wide turn,

406
00:23:06,827 --> 00:23:08,208
a new corner appears in the path.

407
00:23:08,208 --> 00:23:09,929
It turns towards that instead of the player

408
00:23:09,929 --> 00:23:13,192
and is able to reach its destination on the first try.

409
00:23:13,192 --> 00:23:15,353
Note that we aren't repathing when this happens.

410
00:23:15,353 --> 00:23:17,034
We're only rerunning string pulling

411
00:23:17,034 --> 00:23:18,275
over the original corridor.

412
00:23:20,272 --> 00:23:22,693
Well, this was looking good in the test environment,

413
00:23:22,693 --> 00:23:26,316
but around this time, we also started getting bug reports

414
00:23:26,316 --> 00:23:30,219
that NPCs were randomly making 360-degree turns

415
00:23:30,219 --> 00:23:30,900
while walking.

416
00:23:30,900 --> 00:23:34,442
Here, you can see an NPC approaching the player.

417
00:23:34,442 --> 00:23:37,625
But when the agent gets close to the pink high-cost area,

418
00:23:37,625 --> 00:23:41,028
it turns around momentarily before moving forward again.

419
00:23:41,028 --> 00:23:47,292
What was happening is that when an NPC deviated from its path

420
00:23:47,292 --> 00:23:49,454
and stepped into a high-cost navmesh area,

421
00:23:50,021 --> 00:23:54,223
Leaving the corridor would immediately trigger a repath, but the new path would almost always

422
00:23:54,223 --> 00:23:58,365
prefer to back out of the high-cost area we just entered instead of going through it,

423
00:23:58,365 --> 00:24:02,327
which caused agents to turn around in order to get back to low-cost terrain.

424
00:24:02,327 --> 00:24:06,490
We did want enemies to avoid high-cost areas, but if they entered one by accident,

425
00:24:06,490 --> 00:24:10,832
it would usually only be for a moment, so they might as well keep going.

426
00:24:10,832 --> 00:24:10,932
So,

427
00:24:11,785 --> 00:24:23,109
To discourage agents from entering high-cost areas, but commit to walking through one if they stepped into one, we extended NavMesh areas to support not only traversal costs, but an entry cost as well.

428
00:24:23,109 --> 00:24:32,093
A path would receive a one-time cost penalty for moving into a NavMesh area, but this could be adjusted independently from the cost of moving through it.

429
00:24:32,888 --> 00:24:36,491
For rocks, we reduced the traversal cost to the default

430
00:24:36,491 --> 00:24:39,913
and added a large one-time entry cost instead.

431
00:24:39,913 --> 00:24:41,935
This meant that once inside, rocky areas

432
00:24:41,935 --> 00:24:44,177
would be treated like ordinary navmesh.

433
00:24:44,177 --> 00:24:46,699
But while outside, NPCs would still

434
00:24:46,699 --> 00:24:49,121
prefer to avoid them, staying on flat terrain

435
00:24:49,121 --> 00:24:49,861
as much as possible.

436
00:24:51,309 --> 00:24:56,491
And here's the result. You can see that the NPC's path tries to avoid passing through high-cost areas,

437
00:24:56,491 --> 00:25:02,692
but if it misses its turn and steps into one, it commits to traversing through it and continues moving forward.

438
00:25:02,692 --> 00:25:08,254
Once it gets back to low-cost terrain, it continues to avoid entering other high-cost areas,

439
00:25:08,254 --> 00:25:11,515
but no longer backtracks if it enters them.

440
00:25:11,515 --> 00:25:18,297
So, after all this work, we finally had natural, reliable navigation over all types of terrain,

441
00:25:18,297 --> 00:25:21,118
with paths that would update automatically and only when needed.

442
00:25:22,733 --> 00:25:23,894
Almost.

443
00:25:23,894 --> 00:25:26,256
Even after adding entry costs, we're

444
00:25:26,256 --> 00:25:29,499
still getting reports of NPCs backtracking and turning

445
00:25:29,499 --> 00:25:29,999
in circles.

446
00:25:29,999 --> 00:25:32,781
It turns out that there was still one more issue

447
00:25:32,781 --> 00:25:34,963
we had to solve.

448
00:25:34,963 --> 00:25:37,505
Using the event-based repathing system,

449
00:25:37,505 --> 00:25:41,148
when an agent's NavMesh bubble moves and generates or destroys

450
00:25:41,148 --> 00:25:44,250
NavMesh tiles, the destination's tile clamp position

451
00:25:44,250 --> 00:25:46,312
moves as well, triggering a repath.

452
00:25:46,312 --> 00:25:48,213
But depending on the terrain, this

453
00:25:48,213 --> 00:25:51,976
can trap us in an area where the partial path to the clamp

454
00:25:52,501 --> 00:25:54,903
oscillates between opposite directions,

455
00:25:54,903 --> 00:25:57,105
causing the agent to pace back and forth forever.

456
00:25:57,105 --> 00:26:00,828
Initially, we just expanded the bubble size

457
00:26:00,828 --> 00:26:02,829
to fix the specific case shown here in the video,

458
00:26:02,829 --> 00:26:04,791
but that solution wouldn't work everywhere.

459
00:26:04,791 --> 00:26:12,557
Consider the following scenario.

460
00:26:12,557 --> 00:26:15,680
Now this mule has spotted the player in its territory

461
00:26:15,680 --> 00:26:17,942
at the bottom of a deep chasm

462
00:26:17,942 --> 00:26:19,263
and wants to move in to attack range.

463
00:26:21,469 --> 00:26:28,172
The crevice is far too deep for it to jump down, so in order to pursue the player it has to find another way around.

464
00:26:28,172 --> 00:26:33,795
Looking at the area from above, we can see that there is an opening in the crevice near the top where we can enter.

465
00:26:33,795 --> 00:26:40,979
So we might expect the mule to take a route like this, moving up to the crevice entrance and then back down again to approach the player. One problem

466
00:26:42,070 --> 00:26:45,492
The size of the landscape features here are too large to pathfind around.

467
00:26:45,492 --> 00:26:49,335
Even if we extend the radius of an agent's navmesh bubble up to 100 meters,

468
00:26:49,335 --> 00:26:53,958
we still hit our A-star iteration cap without even discovering the inference.

469
00:26:53,958 --> 00:26:59,782
In this situation, the closest position to the player that we can find is our current location at the top of the cliff.

470
00:26:59,782 --> 00:27:04,505
In early testing, it was trivially easy for players to escape mules in these areas.

471
00:27:06,515 --> 00:27:11,616
Worse, if the mule did manage to make its way into the crevice, it was almost never able to

472
00:27:11,616 --> 00:27:16,217
make its way back out again. The size of the NAMISH polygons inside the crevice are much smaller,

473
00:27:16,217 --> 00:27:21,558
so our search radius would shrink to just a few dozen meters, which meant that there was also

474
00:27:21,558 --> 00:27:26,300
no way that it was going to make its way back to base after an encounter had ended. We needed a way

475
00:27:26,300 --> 00:27:30,801
to navigate around these large-scale terrain features, and it was clear that the NAMISH alone

476
00:27:30,801 --> 00:27:31,741
wouldn't be sufficient.

477
00:27:33,582 --> 00:27:39,504
Our solution was to take advantage of another feature in Decima, the AI Road Network.

478
00:27:39,504 --> 00:27:45,025
Initially, this existed as a self-contained graph with its own pathfinding functionality.

479
00:27:45,025 --> 00:27:50,147
We extended it so that the NPC's path-following component could use it as a general-purpose,

480
00:27:50,147 --> 00:27:55,528
high-level navigation layer, merging the results of road paths and navmesh paths into a hybrid

481
00:27:55,528 --> 00:27:56,648
navigation system.

482
00:27:58,658 --> 00:28:00,999
Once AI roads had been placed by game design,

483
00:28:00,999 --> 00:28:03,680
NPCs could seamlessly get on and off the road network

484
00:28:03,680 --> 00:28:05,081
to reach their destination if they

485
00:28:05,081 --> 00:28:07,901
were unable to find the complete path using only the nav image.

486
00:28:07,901 --> 00:28:12,783
Here's what our navigation behavior originally looked like.

487
00:28:12,783 --> 00:28:14,504
The NPC at the bottom is trying to reach

488
00:28:14,504 --> 00:28:16,284
the player at the top.

489
00:28:16,284 --> 00:28:18,425
But as it approaches the cliff in the middle,

490
00:28:18,425 --> 00:28:21,366
it's unable to find a way around it and get stuck.

491
00:28:21,366 --> 00:28:23,126
Even with a 500 node iteration cap,

492
00:28:23,126 --> 00:28:26,007
the terrain features here are just too big for it

493
00:28:26,007 --> 00:28:27,028
to navigate around.

494
00:28:29,165 --> 00:28:32,147
However, with the hybrid path following component,

495
00:28:32,147 --> 00:28:34,888
as the NPC approaches, it discovers a high-level path

496
00:28:34,888 --> 00:28:35,949
on the road network.

497
00:28:35,949 --> 00:28:38,770
And because it was only following a partial NavMesh path,

498
00:28:38,770 --> 00:28:40,011
it switches to use the road network

499
00:28:40,011 --> 00:28:43,172
to ensure it reaches its destination.

500
00:28:43,172 --> 00:28:46,014
The NPC now uses the NavMesh to follow the road path,

501
00:28:46,014 --> 00:28:48,095
navigating towards an intermediate position

502
00:28:48,095 --> 00:28:49,735
a few meters further along the road.

503
00:28:49,735 --> 00:28:53,037
It will then continue to follow this moving target

504
00:28:53,037 --> 00:28:54,818
until it exits the road network,

505
00:28:54,818 --> 00:28:57,579
after which point it will revert back to navigating

506
00:28:57,579 --> 00:28:58,540
using only the NavMesh.

507
00:29:01,719 --> 00:29:07,081
And now, finally, movement behavior was not only stable across all types of terrain,

508
00:29:07,081 --> 00:29:12,523
but agents could also navigate reliably across the entire map, even for complex routes spanning

509
00:29:12,523 --> 00:29:17,185
several kilometers. But up to this point, all the work that we had been doing was only to support

510
00:29:17,185 --> 00:29:22,047
navigation over static environments. We also had several types of dynamic terrain to deal with,

511
00:29:22,047 --> 00:29:23,467
each with its own challenges.

512
00:29:24,704 --> 00:29:27,166
For example, when a catcher encounter begins,

513
00:29:27,166 --> 00:29:31,169
we spawn in a number of strand objects, buildings, vehicles,

514
00:29:31,169 --> 00:29:34,371
chunks of concrete that rise up from the tar.

515
00:29:34,371 --> 00:29:36,672
The catcher needed to be able to not only navigate

516
00:29:36,672 --> 00:29:39,254
around these objects, but jump up on top of them

517
00:29:39,254 --> 00:29:40,735
as well in order to chase the player.

518
00:29:40,735 --> 00:29:45,479
You can see here that as soon as strand objects begin to appear,

519
00:29:45,479 --> 00:29:47,600
we generate nav mesh over their location,

520
00:29:47,600 --> 00:29:49,782
along with jump links connecting them to the ground below.

521
00:29:51,046 --> 00:29:54,807
The catcher is then able to use these links to jump up onto the buildings.

522
00:29:54,807 --> 00:29:58,729
And once it does, the building will begin to sink back into the tar.

523
00:29:58,729 --> 00:30:03,031
When this happens, that strand object's navmesh is removed.

524
00:30:03,031 --> 00:30:08,253
This allows the catcher to follow the player anywhere across the encounter area as it changes.

525
00:30:08,253 --> 00:30:09,653
And here's how we did it.

526
00:30:09,653 --> 00:30:14,135
Each strand object actually has two sets of collision, one for the object itself,

527
00:30:14,135 --> 00:30:16,456
and another that only responds to the navmesh.

528
00:30:16,986 --> 00:30:19,587
Because strand objects are in constant motion,

529
00:30:19,587 --> 00:30:22,008
using their actual collision to regenerate the navmesh

530
00:30:22,008 --> 00:30:23,089
wasn't a feasible option.

531
00:30:23,089 --> 00:30:26,290
Instead, on spawn, the navmesh collision

532
00:30:26,290 --> 00:30:28,712
is activated at the object's final position,

533
00:30:28,712 --> 00:30:30,993
and then off-mesh links are added around its perimeter

534
00:30:30,993 --> 00:30:32,814
to connect it to the ground.

535
00:30:32,814 --> 00:30:35,295
When a strand object is scheduled to sync and despawn,

536
00:30:35,295 --> 00:30:38,696
the navmesh collision and surrounding links are removed,

537
00:30:38,696 --> 00:30:40,457
and the area reverts to its original shape.

538
00:30:42,312 --> 00:30:45,434
Outside of catcher encounters, most dynamic terrain in the game

539
00:30:45,434 --> 00:30:48,075
takes the form of navmesh obstacles attached to props,

540
00:30:48,075 --> 00:30:50,636
like these retractable barriers at the entrance

541
00:30:50,636 --> 00:30:54,938
to distribution centers, or destructible physics objects,

542
00:30:54,938 --> 00:31:00,680
like barrels and fences, as well as vehicles

543
00:31:00,680 --> 00:31:07,723
when they are pumped, or on player-built structures,

544
00:31:07,723 --> 00:31:08,983
like this timefall shelter.

545
00:31:16,757 --> 00:31:19,238
But they aren't used simply to prevent movement.

546
00:31:19,238 --> 00:31:21,258
To chase the player effectively, we

547
00:31:21,258 --> 00:31:23,379
wanted NPCs to take advantage of the player's

548
00:31:23,379 --> 00:31:26,320
own traversal structures during navigation.

549
00:31:26,320 --> 00:31:29,901
For example, by attaching NavMesh obstacles to bridges,

550
00:31:29,901 --> 00:31:32,321
we were able to allow NPCs to use them too.

551
00:31:32,321 --> 00:31:35,522
Here you can see the player constructing a bridge.

552
00:31:35,522 --> 00:31:38,003
Once it begins printing, the NavMesh

553
00:31:38,003 --> 00:31:39,783
responds to the change in collision

554
00:31:39,783 --> 00:31:42,144
and automatically generates NavMesh across its span.

555
00:31:45,603 --> 00:31:55,429
Then, once printing is finished, NPCs are able to use it just like the player.

556
00:31:55,429 --> 00:31:58,310
Once this was working, game design came to us with a question.

557
00:31:58,310 --> 00:32:02,513
If they can use bridges, can we also let them use ladders?

558
00:32:02,513 --> 00:32:07,116
And at first, we weren't sure. In most games, ladders are statically placed,

559
00:32:07,116 --> 00:32:09,277
perfectly vertical, every variable is controlled.

560
00:32:09,277 --> 00:32:12,639
Even then, supporting them is a significant amount of work.

561
00:32:14,508 --> 00:32:18,511
But in our case, the player can place them anywhere and at any angle.

562
00:32:18,511 --> 00:32:24,057
Ladders placed at more than 45 degrees, like this one, need to be climbed with both hands,

563
00:32:24,057 --> 00:32:28,000
but ladders placed at less than 45 degrees would be walked across, like bridges.

564
00:32:28,000 --> 00:32:32,845
But because these provide avenues of escape for the player,

565
00:32:32,845 --> 00:32:35,627
it was important for NPCs to be able to traverse them as well.

566
00:32:35,627 --> 00:32:39,791
If they couldn't use them, it would be trivial for the player to move somewhere that they couldn't follow.

567
00:32:41,298 --> 00:32:47,220
So we accepted the challenge and started by enumerating all possible ways an NPC could get on and off a ladder.

568
00:32:47,220 --> 00:32:56,003
For vertical ladders, there were four ways to get on, grabbing on from the top or bottom, or from the sides at two different angles.

569
00:32:56,003 --> 00:33:05,527
There were five ways to get off, depending on whether we dismounted by stepping off at the end of a ladder or by jumping.

570
00:33:05,527 --> 00:33:10,569
Similarly, for horizontal ladders, there were two ways to step on, from the ends or the sides.

571
00:33:11,886 --> 00:33:14,208
and four ways to step off or jump off,

572
00:33:14,208 --> 00:33:17,711
depending on how close we were to the ground.

573
00:33:17,711 --> 00:33:21,135
The next step was to identify where an NPC could get on

574
00:33:21,135 --> 00:33:24,218
to determine entry points for the ladder.

575
00:33:24,218 --> 00:33:26,700
We started by defining sampling points

576
00:33:26,700 --> 00:33:28,021
at 50 centimeter intervals.

577
00:33:28,021 --> 00:33:30,403
And then at each sample point,

578
00:33:30,403 --> 00:33:33,747
checked for NavMesh at all possible boarding spots.

579
00:33:35,011 --> 00:33:38,213
All the locations here in white represent a possible position

580
00:33:38,213 --> 00:33:40,835
where we could get on the ladder from the NavMesh.

581
00:33:40,835 --> 00:33:44,318
The next step would be to find all possible exits

582
00:33:44,318 --> 00:33:48,060
and connect pairs of entrances and exits with off-mesh links.

583
00:33:48,060 --> 00:33:50,442
But testing all possible pairs isn't practical.

584
00:33:50,442 --> 00:33:53,384
This would generate hundreds of links, most of which

585
00:33:53,384 --> 00:33:55,386
would be redundant.

586
00:33:55,386 --> 00:33:58,408
So to reduce the number of tests and connections,

587
00:33:58,408 --> 00:34:01,590
we form groups from runs of matching NavMesh entrances.

588
00:34:02,635 --> 00:34:09,177
Then from left to right, we perform a collision check for validation from the entrance to the ladder,

589
00:34:09,177 --> 00:34:11,737
but only for the last entrance in a group.

590
00:34:11,737 --> 00:34:20,119
Because ladder traversal is slow, this minimizes the time we spend on it by ensuring we get on at the last possible moment.

591
00:34:20,119 --> 00:34:24,360
Then we do the same for the first entrance of subsequent groups for step-off connections.

592
00:34:24,360 --> 00:34:27,521
This ensures that we get off the ladder as soon as possible.

593
00:34:29,153 --> 00:34:33,856
Also, I should mention that to walk off a ladder from the center without turning, we

594
00:34:33,856 --> 00:34:37,639
add a hidden dismount exit during this step.

595
00:34:37,639 --> 00:34:41,001
For groups without entrances, we can only jump off.

596
00:34:41,001 --> 00:34:46,024
Here we perform both a collision check off the ladder down to the ground, as well as

597
00:34:46,024 --> 00:34:49,066
test for navmesh at the bottom.

598
00:34:49,066 --> 00:34:54,069
Jump off points that either don't have navmesh below them, or fail the collision test are

599
00:34:54,069 --> 00:34:58,672
leaving the final set of exit points for the first entrance group.

600
00:34:59,383 --> 00:35:02,204
We then add an off-mesh link connecting each entrance

601
00:35:02,204 --> 00:35:05,405
to exit pair in this set and continue the process

602
00:35:05,405 --> 00:35:07,985
for subsequent entrance groups.

603
00:35:07,985 --> 00:35:10,226
Finally, we perform the entire operation again

604
00:35:10,226 --> 00:35:12,927
in the opposite direction.

605
00:35:12,927 --> 00:35:15,868
At runtime, the process of analyzing the terrain

606
00:35:15,868 --> 00:35:18,348
and adding off-mesh links happens in a time-sliced job

607
00:35:18,348 --> 00:35:23,970
that checks one pair per tick and looks like this.

608
00:35:23,970 --> 00:35:25,250
And here's what it looks like in game.

609
00:35:26,065 --> 00:35:29,306
Here we have an NPC commanded to approach the player's position.

610
00:35:29,306 --> 00:35:32,547
If we place a ladder, the moment it hits the ground,

611
00:35:32,547 --> 00:35:34,568
a terrain analysis job is kicked off,

612
00:35:34,568 --> 00:35:36,348
and link generation is already complete

613
00:35:36,348 --> 00:35:37,789
by the time the player grabs onto it.

614
00:35:37,789 --> 00:35:45,791
After we jump off, we can see the NPC

615
00:35:45,791 --> 00:35:48,672
is already approaching the ladder entrance

616
00:35:48,672 --> 00:35:50,853
in order to follow us to the top of the shelter.

617
00:35:59,917 --> 00:36:04,758
Because terrain analysis failed to find any valid step-off positions on top of the shelter,

618
00:36:04,758 --> 00:36:09,979
the NPC dismounts by jumping and continues to our location.

619
00:36:09,979 --> 00:36:13,399
If we then place a horizontal ladder, the process repeats,

620
00:36:13,399 --> 00:36:21,581
connecting that mesh at the top of the shelter to the far side of the ladder and the ground below.

621
00:36:21,581 --> 00:36:25,542
Likewise, as soon as we jump off, the NPC continues to approach us,

622
00:36:25,542 --> 00:36:27,542
using our own ladder to jump down from above.

623
00:36:32,677 --> 00:36:37,680
Spatial queries and position picking also played a large part in navigation and behavior development,

624
00:36:37,680 --> 00:36:41,343
and there's a lot on this topic that I'd love to talk about, but today I want to focus on

625
00:36:41,343 --> 00:36:47,467
one specific problem we faced and the trick we came up to handle it. Let's imagine we are the

626
00:36:47,467 --> 00:36:52,130
blue NPC on the left and we want to find an attack position near the yellow player on the right.

627
00:36:52,130 --> 00:36:57,513
In between us is a high-cost navmesh area representing a large body of deep water.

628
00:36:57,513 --> 00:37:01,215
We want to get close, but stay out of the water as it's going to slow us down.

629
00:37:02,219 --> 00:37:05,360
If we generate a grid of sample points over the terrain,

630
00:37:05,360 --> 00:37:08,261
we can give positions inside high cost areas a low score

631
00:37:08,261 --> 00:37:09,221
to avoid entering them.

632
00:37:09,221 --> 00:37:13,282
And if we then rank the rest based on distance to the target

633
00:37:13,282 --> 00:37:15,782
we'll get something near the player and outside the water.

634
00:37:15,782 --> 00:37:16,442
Great.

635
00:37:16,442 --> 00:37:21,344
And because it is a high cost NavMesh area,

636
00:37:21,344 --> 00:37:22,804
the path to our attack position

637
00:37:22,804 --> 00:37:24,804
will go around the water as well.

638
00:37:24,804 --> 00:37:26,525
This type of query actually worked well for us

639
00:37:26,525 --> 00:37:28,285
in early development,

640
00:37:28,285 --> 00:37:30,686
but if the player was not near a lake, but a river,

641
00:37:31,517 --> 00:37:33,878
we would encounter a problem.

642
00:37:33,878 --> 00:37:37,159
We could test for positions in high-cost NAVMISH areas

643
00:37:37,159 --> 00:37:38,780
and give them a low score.

644
00:37:38,780 --> 00:37:41,321
But at the end of our position-picking query,

645
00:37:41,321 --> 00:37:44,622
our target position could be on the far side of the river.

646
00:37:44,622 --> 00:37:47,183
And the NPC would spend ages waiting across just

647
00:37:47,183 --> 00:37:49,984
to stand on the other side, when someplace on the near side

648
00:37:49,984 --> 00:37:51,384
would have been just as effective.

649
00:37:51,384 --> 00:37:55,406
But because both sides look equally attractive

650
00:37:55,406 --> 00:37:57,006
from our spatial queries perspective,

651
00:37:57,534 --> 00:38:04,517
In combat, NPCs would cross and recross the same river over and over as they reposition around the player.

652
00:38:04,517 --> 00:38:08,679
What we needed was not just a way to avoid choosing positions in high-cost areas,

653
00:38:08,679 --> 00:38:15,162
but also positions that NPCs would have to pass through high-cost areas to get to.

654
00:38:15,162 --> 00:38:16,402
So we came up with an idea.

655
00:38:18,120 --> 00:38:22,364
Our spatial query system could already use a Dijkstra search over the navmesh from the

656
00:38:22,364 --> 00:38:27,448
agent's position to calculate a rough approximation of path cost, letting us rank points based

657
00:38:27,448 --> 00:38:30,091
on their estimated navigation cost.

658
00:38:30,091 --> 00:38:35,055
Here you can see that areas on our side of the river have a low path cost shown in blue,

659
00:38:35,055 --> 00:38:39,740
while areas that enter or pass through the river on the right have a high cost shown

660
00:38:39,740 --> 00:38:39,860
in red.

661
00:38:39,860 --> 00:38:43,823
This was close to what we wanted, but places that were simply far away, like the area on

662
00:38:43,823 --> 00:38:44,524
the far left.

663
00:38:45,018 --> 00:38:49,481
would also have a high path cost, even though they didn't pass through a river or other high cost area.

664
00:38:49,481 --> 00:38:57,825
We wanted to test that would rank positions based on how much unfavorable terrain they would have to pass through to get there, regardless of distance.

665
00:39:00,715 --> 00:39:04,980
But the same test could also return the raw path length to areas around it.

666
00:39:04,980 --> 00:39:10,746
If we subtracted this length from the cost, places where the path length and cost differed

667
00:39:10,746 --> 00:39:16,773
would indicate areas that would require the MPC to pass through a high cost area at some point.

668
00:39:16,773 --> 00:39:19,736
Conversely, places where the length and cost were the same

669
00:39:19,736 --> 00:39:22,840
represented areas that could be reached without walking through difficult terrain.

670
00:39:24,314 --> 00:39:25,415
This is what we were after.

671
00:39:25,415 --> 00:39:27,997
So we added a third setting to our pathfinding test

672
00:39:27,997 --> 00:39:32,441
in the spatial query system, the delta path, delta cost,

673
00:39:32,441 --> 00:39:37,305
the delta between path cost and path length.

674
00:39:37,305 --> 00:39:42,569
However, there was one issue.

675
00:39:42,569 --> 00:39:44,871
While this worked as we had imagined

676
00:39:44,871 --> 00:39:46,893
when the NPC was outside of a high cost area,

677
00:39:46,893 --> 00:39:50,235
avoiding both entering and passing through the river.

678
00:39:51,293 --> 00:39:54,635
If an NPC was already in the river, it would stop moving entirely.

679
00:39:54,635 --> 00:40:00,158
The reason is because from inside a high-cost area, moving anywhere would force us to pass

680
00:40:00,158 --> 00:40:03,300
through more unfavorable terrain than just standing still.

681
00:40:03,300 --> 00:40:07,803
We would need a different heuristic if we wanted to discourage agents from staying in

682
00:40:07,803 --> 00:40:11,585
high-cost areas and instead move back into easily traversable terrain.

683
00:40:13,336 --> 00:40:16,518
The trick we came up with was to manipulate the reported path

684
00:40:16,518 --> 00:40:19,699
length and cost so that the total distance to all locations

685
00:40:19,699 --> 00:40:21,080
looked the same.

686
00:40:21,080 --> 00:40:23,001
What this means is that we would first

687
00:40:23,001 --> 00:40:25,722
find the highest path length among all sample locations

688
00:40:25,722 --> 00:40:29,704
in the query, and then for the rest of the locations,

689
00:40:29,704 --> 00:40:33,366
virtually extend the length at the end of their path to match.

690
00:40:33,366 --> 00:40:36,387
We then adjust the path cost to match this added length

691
00:40:36,387 --> 00:40:37,128
at the destination.

692
00:40:39,090 --> 00:40:40,851
Another way of putting it is that the test now

693
00:40:40,851 --> 00:40:43,553
compared how much time an agent was spending in high cost

694
00:40:43,553 --> 00:40:46,374
areas, even if it wasn't moving.

695
00:40:46,374 --> 00:40:47,995
If it could reach a location quickly,

696
00:40:47,995 --> 00:40:50,536
it would stay there and accumulate the traversal cost

697
00:40:50,536 --> 00:40:53,958
at that location until it had traveled a virtual distance

698
00:40:53,958 --> 00:40:58,640
equal to that of the longest path in the query.

699
00:40:58,640 --> 00:41:00,121
Now we have the heuristic we were after.

700
00:41:00,121 --> 00:41:02,742
Our special query could identify all locations

701
00:41:02,742 --> 00:41:06,524
that required us to pass through a high cost area to reach.

702
00:41:06,896 --> 00:41:11,639
and if we were already inside of one, we would know which locations could get us out the fastest.

703
00:41:11,639 --> 00:41:19,084
And here's the final result. Here we have an NPC moving from right to left across a river.

704
00:41:19,084 --> 00:41:22,987
Initially, both points in the river and on the other side of it have a high path cost delta

705
00:41:22,987 --> 00:41:27,390
and receive a low score. Once we enter, the river still has the lowest ranking,

706
00:41:27,390 --> 00:41:31,053
but the far side is now a bit higher and gradually increases as we get closer.

707
00:41:32,054 --> 00:41:38,200
Finally, once we leave the water, the river and the area beyond it both received low scores again, as before.

708
00:41:38,200 --> 00:41:47,570
This is actually a really simple technique and very easy to implement, but we hadn't encountered it before, and the added spatial awareness this test gave to NPCs

709
00:41:47,570 --> 00:41:54,658
made a real difference in the quality of behaviors we were able to achieve. So hopefully some of you will find it useful as well.

710
00:42:02,277 --> 00:42:08,558
Lastly, I want to talk briefly about a few other features we've spent time on and what they allowed us to accomplish.

711
00:42:08,558 --> 00:42:11,939
First among them is the approach we used to support cover in terrorist camps.

712
00:42:11,939 --> 00:42:20,321
We built our solution on top of Decima's dynamic cover system, which provided a way for NPCs to generate cover on demand.

713
00:42:20,321 --> 00:42:26,483
When a cover point was requested, a frame-budgeted job would analyze a subset of nearby navmesh edges,

714
00:42:26,483 --> 00:42:29,924
performing collision tests on any edge long enough for an NPC to hide behind.

715
00:42:30,485 --> 00:42:35,349
creating crouching or standing cover points wherever an NPC was both protected by cover

716
00:42:35,349 --> 00:42:37,711
and could peek out to shoot.

717
00:42:37,711 --> 00:42:42,054
Once generated, NPCs could use the spatial query system to test for a line of fire from

718
00:42:42,054 --> 00:42:43,295
these cover points to a target.

719
00:42:45,082 --> 00:42:48,565
which would check as many points as it could fit into its frame budget

720
00:42:48,565 --> 00:42:51,667
and return a list of all valid cover locations.

721
00:42:51,667 --> 00:42:55,329
Finally, these results were cached, so over time the entire area would

722
00:42:55,329 --> 00:42:58,011
incrementally become populated with cover points

723
00:42:58,011 --> 00:43:01,294
and their status would be revalidated during the encounter

724
00:43:01,294 --> 00:43:04,136
as NPCs continued to make additional cover requests.

725
00:43:05,025 --> 00:43:09,989
This was great for performance, but because the encounter area in terrorist camps was so large,

726
00:43:09,989 --> 00:43:13,872
it could take several minutes before enough cover points had been generated for an NPC

727
00:43:13,872 --> 00:43:19,837
to find a usable one consistently. Even after the area was populated, since only a small number of

728
00:43:19,837 --> 00:43:24,201
cover points are ever in the right position to actually provide cover from the target at a given

729
00:43:24,201 --> 00:43:28,945
time, testing only a handful of them on demand usually resulted in failure.

730
00:43:29,551 --> 00:43:34,475
As a result, terrorists weren't able to take advantage of the system as well as they should have,

731
00:43:34,475 --> 00:43:36,016
and sometimes they never used cover at all.

732
00:43:36,016 --> 00:43:42,841
What we needed was a way to prepare and analyze cover in advance, before it was requested,

733
00:43:42,841 --> 00:43:46,343
so it would be ready to go when an NPC eventually did need it.

734
00:43:46,343 --> 00:43:50,506
We could have accomplished this by just placing static cover by hand instead.

735
00:43:51,242 --> 00:43:53,563
But we didn't want to lose the ability to respond

736
00:43:53,563 --> 00:43:55,364
to changes in the navmesh.

737
00:43:55,364 --> 00:43:58,385
So our approach was to transition cover generation

738
00:43:58,385 --> 00:44:01,067
and analysis from an on-demand service

739
00:44:01,067 --> 00:44:03,308
to a persistent background job.

740
00:44:03,308 --> 00:44:05,910
When combat begins, agents register themselves

741
00:44:05,910 --> 00:44:08,831
with the cover manager and specify a target.

742
00:44:08,831 --> 00:44:10,912
And as long as at least one agent is registered,

743
00:44:10,912 --> 00:44:12,693
the cover manager will incrementally

744
00:44:12,693 --> 00:44:15,635
analyze the navmesh around them in its own thread,

745
00:44:15,635 --> 00:44:17,876
as well as check the line of fire from generated cover

746
00:44:17,876 --> 00:44:18,717
points to the target.

747
00:44:20,038 --> 00:44:23,440
Here you can see the status of cover generation

748
00:44:23,440 --> 00:44:25,261
as NavMesh tiles are analyzed.

749
00:44:25,261 --> 00:44:28,883
Red tiles have generated partial cover results,

750
00:44:28,883 --> 00:44:31,064
while blue tiles have finished analysis.

751
00:44:31,064 --> 00:44:33,705
And those that contain at least one cover point

752
00:44:33,705 --> 00:44:35,446
are highlighted in light blue.

753
00:44:35,446 --> 00:44:38,868
Later, when an agent finally does request a cover point,

754
00:44:38,868 --> 00:44:41,249
we simply return these cache results to the cover manager

755
00:44:41,249 --> 00:44:43,030
that it's been preparing for us.

756
00:44:45,935 --> 00:44:48,377
Here's another example viewed from ground level.

757
00:44:48,377 --> 00:44:50,999
You can see that as terrorists approach the player,

758
00:44:50,999 --> 00:44:53,161
cover is gradually generated around them.

759
00:44:53,161 --> 00:44:56,783
And once a valid cover point becomes available,

760
00:44:56,783 --> 00:44:58,165
an NPC moves into it immediately.

761
00:44:58,165 --> 00:45:03,929
And this is what the line of fire check looks like

762
00:45:03,929 --> 00:45:05,511
from the debug view.

763
00:45:05,511 --> 00:45:07,332
The cover points around each registered NPC

764
00:45:07,332 --> 00:45:08,733
are batched together,

765
00:45:08,733 --> 00:45:10,815
and the resulting set is sent to a background job

766
00:45:10,815 --> 00:45:13,337
to check for both exposure and line of fire to the target.

767
00:45:13,778 --> 00:45:16,561
As soon as one job finishes, a new one is started.

768
00:45:16,561 --> 00:45:19,184
Here an agent has moved into a green cover point,

769
00:45:19,184 --> 00:45:21,526
which has both cover and line of fire to the player.

770
00:45:21,526 --> 00:45:23,808
And if we crouch on the other side of the barrier,

771
00:45:23,808 --> 00:45:25,750
it turns red as it loses line of fire,

772
00:45:25,750 --> 00:45:28,193
and the NPC immediately responds by repositioning.

773
00:45:28,193 --> 00:45:29,875
And this is what we were after.

774
00:45:29,875 --> 00:45:32,397
By keeping the cover state updated asynchronously

775
00:45:32,397 --> 00:45:34,419
in the background, finally, we were

776
00:45:34,419 --> 00:45:36,301
able to produce consistent cover behavior

777
00:45:36,301 --> 00:45:38,083
over large encounter areas like these.

778
00:45:39,539 --> 00:45:43,542
Another feature we added was AI for low LOD entities.

779
00:45:43,542 --> 00:45:45,684
Most NPCs are actually persistent.

780
00:45:45,684 --> 00:45:48,366
When the player is far away, they don't despawn,

781
00:45:48,366 --> 00:45:50,507
but instead switch to a low LOD mode

782
00:45:50,507 --> 00:45:52,388
without a physical representation

783
00:45:52,388 --> 00:45:54,050
until the player comes back.

784
00:45:54,050 --> 00:45:55,571
When this happens, they also switch

785
00:45:55,571 --> 00:45:57,672
to a simple lightweight version of their AI

786
00:45:57,672 --> 00:46:01,595
so that they can continue to perform the same activities

787
00:46:01,595 --> 00:46:02,956
that they do in high LOD.

788
00:46:02,956 --> 00:46:06,639
This includes enemies making patrols around camps,

789
00:46:06,639 --> 00:46:08,660
inspecting vehicles, stopping for breaks.

790
00:46:09,819 --> 00:46:14,523
orders following delivery routes, dropping off packages, picking up new orders, and so on.

791
00:46:14,523 --> 00:46:21,690
And while we do completely suspend some NPCs when they're extremely far away,

792
00:46:21,690 --> 00:46:26,014
in general the whole world is alive and in motion, even when it's out of view.

793
00:46:26,014 --> 00:46:28,937
And adding this mode also allowed us to do one other neat thing.

794
00:46:31,301 --> 00:46:34,342
When the player triggers an event that causes time to pass,

795
00:46:34,342 --> 00:46:37,383
we could now fast forward the AI by the same amount

796
00:46:37,383 --> 00:46:39,304
by temporarily switching them to low LOD

797
00:46:39,304 --> 00:46:42,925
and running their update tick with a large delta time.

798
00:46:42,925 --> 00:46:45,646
So when the player passes time in the timefall shelter,

799
00:46:45,646 --> 00:46:48,527
10 minutes will pass not only for them, but for NPCs as well.

800
00:46:48,527 --> 00:46:51,928
This is what lets us do things like advance porters

801
00:46:51,928 --> 00:46:54,109
along the delivery routes, like you can see here.

802
00:46:57,603 --> 00:47:03,410
Finally, it wouldn't be a postmortem if I didn't talk about some things we tried that didn't work.

803
00:47:03,410 --> 00:47:06,834
First is bidirectional pathfinding.

804
00:47:06,834 --> 00:47:07,956
At the 2018 AI Summit,

805
00:47:08,558 --> 00:47:12,721
Nathan Sturtevant presented a great talk on bidirectional search.

806
00:47:12,721 --> 00:47:16,463
Our environment met all the criteria it should be suited for,

807
00:47:16,463 --> 00:47:21,747
a weighted terrain, problem asymmetry, map asymmetry, and local minimum.

808
00:47:21,747 --> 00:47:25,450
And it just so happened that this was right around the time that we were struggling with

809
00:47:25,450 --> 00:47:28,172
regularly hitting our A-star iteration limit,

810
00:47:28,172 --> 00:47:31,294
so we were very curious to see how bidirectional search might perform.

811
00:47:32,517 --> 00:47:34,719
And after a bit of work, we actually

812
00:47:34,719 --> 00:47:37,541
did manage to get to port NBS to recast

813
00:47:37,541 --> 00:47:39,982
and had it running inside the game.

814
00:47:39,982 --> 00:47:41,523
And it was performing great.

815
00:47:41,523 --> 00:47:43,345
Early tests showed promise in areas

816
00:47:43,345 --> 00:47:46,347
that in the game that were difficult for forward search

817
00:47:46,347 --> 00:47:48,148
to handle.

818
00:47:48,148 --> 00:47:51,030
Unfortunately, we ran into two issues.

819
00:47:51,030 --> 00:47:53,972
After adding one-way jump links, the nav mesh

820
00:47:53,972 --> 00:47:56,113
was no longer an undirected graph.

821
00:47:56,113 --> 00:47:58,815
Jump down link had no connection in the opposite direction

822
00:47:58,815 --> 00:48:00,316
for the reverse search to explore,

823
00:48:00,316 --> 00:48:01,497
breaking search symmetry.

824
00:48:02,656 --> 00:48:06,197
Likewise, after adding NavMesh area entry costs,

825
00:48:06,197 --> 00:48:09,098
the reverse search would incur the entry costs as well,

826
00:48:09,098 --> 00:48:12,018
creating a situation where we'd pay the cost both on entry

827
00:48:12,018 --> 00:48:13,679
and exit.

828
00:48:13,679 --> 00:48:16,800
To be clear, both these are solvable problems.

829
00:48:16,800 --> 00:48:20,060
With some modifications to how off-mesh links and entry costs

830
00:48:20,060 --> 00:48:22,541
are handled, NBS can absolutely be made

831
00:48:22,541 --> 00:48:23,921
to work in this environment.

832
00:48:23,921 --> 00:48:26,922
But in our case, even though the results were promising,

833
00:48:26,922 --> 00:48:29,783
we had to put it aside and were unable to return to it later.

834
00:48:36,842 --> 00:48:39,963
We also tried a number of methods to improve path smoothing.

835
00:48:39,963 --> 00:48:44,285
If an agent was running, simply heading directly towards the next waypoint often resulted in

836
00:48:44,285 --> 00:48:48,968
them missing follow and turn, which made it difficult for them to reliably hit the start

837
00:48:48,968 --> 00:48:52,009
of jump links or the entrance to a ladder.

838
00:48:52,009 --> 00:48:56,931
The method we ended up shipping with in the end was actually just a Bezier spline that

839
00:48:56,931 --> 00:49:00,973
the agent could follow, constructed so that the curve would already be turning in the

840
00:49:00,973 --> 00:49:03,475
direction of the next segment before hitting the waypoint.

841
00:49:04,810 --> 00:49:13,893
Additionally, to avoid triggering a repath, each apex was constrained so that the smooth path would never leave the corridor.

842
00:49:13,893 --> 00:49:20,016
To a degree, this actually worked. Agents will, depending on the situation, make wide turns and do hit more waypoints, but

843
00:49:20,016 --> 00:49:29,100
the checks we used to constrain the spline to the corridor were overly strict, and even path corridors in flat terrain could be very narrow,

844
00:49:29,100 --> 00:49:32,021
which means that often the spline shape is

845
00:49:32,822 --> 00:49:35,523
not significantly different than the original straight path.

846
00:49:35,523 --> 00:49:37,663
So there's still a lot of work we'd

847
00:49:37,663 --> 00:49:43,545
like to do in this area to improve path quality further.

848
00:49:43,545 --> 00:49:45,625
Finally, while we were able to generate

849
00:49:45,625 --> 00:49:48,946
jump links for ladders and strand objects procedurally,

850
00:49:48,946 --> 00:49:50,387
every other jump link in the game

851
00:49:50,387 --> 00:49:53,588
was placed by hand by game designers, which

852
00:49:53,588 --> 00:49:56,168
became a painstaking process because links would break

853
00:49:56,168 --> 00:49:58,809
and need to be adjusted repeatedly as changes were

854
00:49:58,809 --> 00:50:01,250
made both to animation and the environment

855
00:50:01,250 --> 00:50:01,950
during development.

856
00:50:03,430 --> 00:50:05,912
Now, we wanted to develop a procedural placement system

857
00:50:05,912 --> 00:50:08,014
for these links as well, but weren't

858
00:50:08,014 --> 00:50:10,175
able to fit it in the development schedule.

859
00:50:10,175 --> 00:50:12,117
So we had to use brute force to make sure

860
00:50:12,117 --> 00:50:16,120
that every encounter area, every ledge, rooftop, and nav mesh

861
00:50:16,120 --> 00:50:17,521
island that the player could access

862
00:50:17,521 --> 00:50:21,844
was connected by jump links so that NPCs could follow.

863
00:50:21,844 --> 00:50:23,805
In the end, we had about 2,000 of these links

864
00:50:23,805 --> 00:50:26,788
placed across all areas, which was more than enough

865
00:50:26,788 --> 00:50:28,729
that by the end, we regretted not

866
00:50:28,729 --> 00:50:30,330
being able to automate this task.

867
00:50:32,297 --> 00:50:35,678
So to wrap everything up, in this post-mortem,

868
00:50:35,678 --> 00:50:38,218
we took a look at the environment of desk training

869
00:50:38,218 --> 00:50:41,059
and why it was such a challenge to work with for AI,

870
00:50:41,059 --> 00:50:42,780
discussed game design's goals for NPCs

871
00:50:42,780 --> 00:50:46,321
and how that drove our need for robust animation,

872
00:50:46,321 --> 00:50:48,021
how we went about creating a nav mesh

873
00:50:48,021 --> 00:50:50,402
we could use to satisfy those goals

874
00:50:50,402 --> 00:50:53,423
and the problems this created for navigation,

875
00:50:53,423 --> 00:50:56,003
techniques we used to support dynamic obstacles

876
00:50:56,003 --> 00:50:58,024
that NPCs could use to follow the player.

877
00:50:58,898 --> 00:51:02,142
One trick that served us well for believable repositioning

878
00:51:02,142 --> 00:51:05,105
over natural terrain, and a brief overview

879
00:51:05,105 --> 00:51:07,447
of a few other features we developed for the game,

880
00:51:07,447 --> 00:51:08,648
including some that didn't work out.

881
00:51:08,648 --> 00:51:12,272
So I hope you've enjoyed taking this look

882
00:51:12,272 --> 00:51:14,654
at some of the challenges our team faced

883
00:51:14,654 --> 00:51:17,177
over the course of developing the AI for Death Stranding.

884
00:51:17,177 --> 00:51:18,398
Thanks for attending.

