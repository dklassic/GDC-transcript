1
00:00:06,393 --> 00:00:07,894
Let's get the shame out of the way early.

2
00:00:08,334 --> 00:00:10,814
Everybody think of an example of bad AI.

3
00:00:12,215 --> 00:00:12,535
You got it?

4
00:00:12,895 --> 00:00:13,155
OK.

5
00:00:13,815 --> 00:00:15,876
I think a lot of you are thinking of something like this.

6
00:00:17,596 --> 00:00:20,217
And the first thing I'd like to convince you of during this

7
00:00:20,257 --> 00:00:23,197
talk is that this is not bad AI.

8
00:00:24,158 --> 00:00:24,858
I mean, it's not good.

9
00:00:25,498 --> 00:00:26,938
But what we're really looking at here

10
00:00:26,978 --> 00:00:29,939
is a failure of production, of management, resourcing.

11
00:00:31,166 --> 00:00:33,948
Because here's the thing, if your AI isn't very good,

12
00:00:33,989 --> 00:00:34,769
you know what you can do?

13
00:00:35,190 --> 00:00:36,030
You can hide it.

14
00:00:36,691 --> 00:00:39,073
Put these guys on rails because of that bug,

15
00:00:39,233 --> 00:00:41,535
put disabled grenades in that room, stuff like that.

16
00:00:42,096 --> 00:00:45,259
Actual bad AI in a competently developed game

17
00:00:45,399 --> 00:00:48,782
doesn't usually directly impact the player experience.

18
00:00:49,362 --> 00:00:52,024
What it impacts is the overall game quality

19
00:00:52,344 --> 00:00:54,265
by sapping the efficiency of everyone else.

20
00:00:54,665 --> 00:00:57,826
You end up with more pressure on the iterative QA process.

21
00:00:58,227 --> 00:00:59,987
Your level designers spend more time

22
00:01:00,067 --> 00:01:02,008
working around quirks in the Pathfinder

23
00:01:02,369 --> 00:01:04,970
and less time working on tweaking for balance and fun.

24
00:01:05,590 --> 00:01:08,732
You spend less time, well, you spend more time

25
00:01:08,832 --> 00:01:11,033
and then you eventually end up dialing down your ambitions

26
00:01:11,093 --> 00:01:12,774
for like, say, tactical AI.

27
00:01:13,254 --> 00:01:15,855
You might cut down some emergent tactics

28
00:01:15,915 --> 00:01:17,436
and just move towards something more like

29
00:01:17,536 --> 00:01:18,436
on-rails shootouts.

30
00:01:19,884 --> 00:01:24,087
The most sinister thing about bad AI, real bad AI,

31
00:01:24,507 --> 00:01:26,428
is that it doesn't look like bad AI.

32
00:01:26,868 --> 00:01:28,249
It just looks disappointing.

33
00:01:28,849 --> 00:01:30,951
It looks like something less than it could have been.

34
00:01:30,971 --> 00:01:33,572
It looks like the team didn't try hard enough.

35
00:01:36,492 --> 00:01:37,914
So what I'd like to do with this talk

36
00:01:38,415 --> 00:01:42,279
is help you think about AI development in a way that

37
00:01:42,400 --> 00:01:44,703
leads to solid and dependable systems.

38
00:01:45,123 --> 00:01:47,206
This is not going to be an exciting talk,

39
00:01:47,286 --> 00:01:49,228
because it's not about being creative.

40
00:01:50,189 --> 00:01:52,873
It's about supporting and enabling creativity.

41
00:01:53,233 --> 00:01:55,736
It's about building something you can build on.

42
00:01:58,767 --> 00:02:01,950
The first topic I'll touch on is layering and the closely related

43
00:02:02,650 --> 00:02:04,271
topic of interface design.

44
00:02:04,932 --> 00:02:07,014
Now, Rodney Brooks described this idea

45
00:02:07,094 --> 00:02:11,757
of a subsumption architecture, a bottom-up approach to AI,

46
00:02:12,078 --> 00:02:15,060
where high-level competencies depend on lower-level skills.

47
00:02:16,021 --> 00:02:18,263
And we do this in AI without really thinking about it.

48
00:02:18,303 --> 00:02:20,545
In your guard's search behavior, you'll have something like,

49
00:02:20,906 --> 00:02:22,968
run to the last place you saw the player.

50
00:02:23,008 --> 00:02:26,491
But that behavior depends on a lower level locomotion system,

51
00:02:26,672 --> 00:02:28,934
which might defend on an even lower level pathfinder.

52
00:02:29,655 --> 00:02:31,476
And what you'll notice when you look at these layers,

53
00:02:31,516 --> 00:02:34,820
of course, is that the creative aspect of AI, the content,

54
00:02:35,040 --> 00:02:37,803
what makes this guard different from that villager,

55
00:02:38,624 --> 00:02:40,085
is all up in the top layer.

56
00:02:40,305 --> 00:02:42,967
And as you go down, the layers become generic.

57
00:02:43,268 --> 00:02:45,069
They're services, not content.

58
00:02:45,149 --> 00:02:47,371
And what you want is for the lower levels

59
00:02:47,671 --> 00:02:50,234
to be rock solid and boring, so you can ignore them

60
00:02:50,534 --> 00:02:52,035
and concentrate on the content, which

61
00:02:52,075 --> 00:02:53,396
is where your game really is.

62
00:02:54,738 --> 00:02:56,039
Well, that's the ideal anyway.

63
00:02:56,260 --> 00:02:59,582
And I think it's useful to look at what happens

64
00:02:59,622 --> 00:03:01,103
when layering starts to rot.

65
00:03:01,684 --> 00:03:03,185
And there's two ways this can happen.

66
00:03:03,565 --> 00:03:05,907
And the really bad one is this first one,

67
00:03:06,207 --> 00:03:08,168
when your creativity and your content

68
00:03:08,208 --> 00:03:10,570
starts to leak down into your services.

69
00:03:11,030 --> 00:03:12,972
The prime symptom of downwards leakage

70
00:03:13,352 --> 00:03:15,413
is when your service interface suddenly

71
00:03:15,454 --> 00:03:18,976
gets more semantically specific, more use case specific,

72
00:03:19,336 --> 00:03:20,797
when it starts thinking about things

73
00:03:20,837 --> 00:03:22,058
that it shouldn't need to think about.

74
00:03:23,638 --> 00:03:24,299
Here's an example.

75
00:03:24,339 --> 00:03:26,961
You're making a game whose levels include some farms.

76
00:03:27,382 --> 00:03:29,364
And there's some feral chickens wandering around,

77
00:03:29,404 --> 00:03:31,726
just randomly picking goal points around them.

78
00:03:32,207 --> 00:03:34,709
And the problem is, the chickens keep wandering away

79
00:03:34,769 --> 00:03:36,511
from the farm over time because they're just

80
00:03:36,551 --> 00:03:37,412
picking random points.

81
00:03:37,892 --> 00:03:39,794
But you want to keep the chickens tightly clustered

82
00:03:39,834 --> 00:03:40,715
there for set dressing.

83
00:03:41,636 --> 00:03:42,977
So you take your pathfinding system,

84
00:03:43,098 --> 00:03:45,560
and you add an option to the find path query called

85
00:03:46,021 --> 00:03:46,541
isChicken.

86
00:03:47,786 --> 00:03:50,153
And then your pathfinder, if isChicken is set,

87
00:03:50,514 --> 00:03:53,482
doesn't allow paths that go, say, more than 20 meters

88
00:03:53,542 --> 00:03:54,404
from the nearest farm.

89
00:03:58,029 --> 00:04:00,230
So now your Pathfinder has this concept of a chicken.

90
00:04:01,031 --> 00:04:03,212
If you want to do similar things for other characters,

91
00:04:03,232 --> 00:04:04,853
you'll have to edit the Pathfinder again

92
00:04:04,913 --> 00:04:05,914
and add more options.

93
00:04:06,274 --> 00:04:08,556
That 20 meter limit I mentioned is not

94
00:04:08,596 --> 00:04:10,157
with the rest of the chicken's behavior.

95
00:04:10,317 --> 00:04:12,558
It's somewhere deep down in the pathfinding code.

96
00:04:13,359 --> 00:04:15,900
What it means to be a chicken is no longer local.

97
00:04:16,280 --> 00:04:18,101
And what it means to find a path has now

98
00:04:18,141 --> 00:04:19,903
become more complicated and confusing,

99
00:04:19,943 --> 00:04:22,244
since previously you were worried about nodes and edges.

100
00:04:22,524 --> 00:04:24,185
And now you're still worried about nodes and edges

101
00:04:24,205 --> 00:04:25,266
and also farms and chickens.

102
00:04:26,953 --> 00:04:30,995
Now, that example is trivial to the point of being manifestly unfair.

103
00:04:31,115 --> 00:04:33,577
I think most of us would have done it a different way,

104
00:04:34,037 --> 00:04:36,138
by having the pathfinder, say, take a callback,

105
00:04:36,618 --> 00:04:39,100
which filters which faces are loud or not.

106
00:04:39,600 --> 00:04:42,782
Then the filter for chickens would apply those same limits I talked about,

107
00:04:43,162 --> 00:04:46,124
but the code for that would be part of the chicken system,

108
00:04:46,144 --> 00:04:47,405
it would be part of the chicken code base.

109
00:04:47,805 --> 00:04:50,687
The pathfinding system sticks to what it's good at, finding paths,

110
00:04:51,067 --> 00:04:54,389
and the extension to its interface, just adding this generic filter interface,

111
00:04:54,929 --> 00:04:55,710
makes a lot of sense.

112
00:04:58,030 --> 00:05:00,032
But now we have the opposite problem,

113
00:05:00,072 --> 00:05:02,134
because a piece of code that was previously

114
00:05:02,174 --> 00:05:03,876
concerned with pecking and clucking

115
00:05:04,216 --> 00:05:07,099
is now also calculating the distance between points

116
00:05:07,219 --> 00:05:08,320
and navmesh faces.

117
00:05:08,861 --> 00:05:10,342
It's scanning through the game level

118
00:05:10,382 --> 00:05:11,924
to try to find all the farms.

119
00:05:12,584 --> 00:05:15,007
All this knowledge of the underlying structure

120
00:05:15,127 --> 00:05:16,788
is going into the chicken's mind.

121
00:05:17,149 --> 00:05:19,071
So now, say, if you want to change

122
00:05:19,111 --> 00:05:21,092
how navmesh faces are stored, now

123
00:05:21,132 --> 00:05:22,774
you need to edit how chickens work.

124
00:05:23,635 --> 00:05:26,438
So this is the opposite problem with upwards layer leakage,

125
00:05:26,798 --> 00:05:30,141
because the service refused to give the content what it needed,

126
00:05:30,482 --> 00:05:33,485
and now service-like code is going into the content.

127
00:05:35,487 --> 00:05:37,088
This happens when you have a layered system.

128
00:05:37,689 --> 00:05:40,131
Both layers start saying, not my job.

129
00:05:40,492 --> 00:05:42,734
It's not the Pathfinder's job to care about chickens,

130
00:05:43,034 --> 00:05:44,576
and it's certainly not the chicken's job

131
00:05:44,616 --> 00:05:46,097
to care about navmesh geometry.

132
00:05:47,153 --> 00:05:49,615
What you generally end up, if you're doing your job correctly,

133
00:05:49,695 --> 00:05:52,256
is a set of utilities built around the lower level,

134
00:05:52,497 --> 00:05:54,818
which offer slightly higher-level services

135
00:05:54,858 --> 00:05:55,658
to the upper level.

136
00:05:56,959 --> 00:05:58,680
So if you see this sort of pattern

137
00:05:58,700 --> 00:06:01,081
where you've got two layers, and you can't decide

138
00:06:01,121 --> 00:06:02,662
where to put a piece of functionality,

139
00:06:02,922 --> 00:06:04,904
consider whether you need a third layer.

140
00:06:05,364 --> 00:06:08,105
Mapping gameplay concepts to mechanical queries

141
00:06:08,686 --> 00:06:10,267
is a type of functionality.

142
00:06:10,667 --> 00:06:12,588
It's a kind of code itself.

143
00:06:12,728 --> 00:06:14,089
It deserves to go somewhere.

144
00:06:14,169 --> 00:06:16,650
It deserves to be recognized as a separate system.

145
00:06:18,558 --> 00:06:20,439
The other thing to notice about these examples

146
00:06:20,599 --> 00:06:22,679
is that the risks differ depending

147
00:06:22,739 --> 00:06:24,120
on who's programming what.

148
00:06:24,760 --> 00:06:27,281
If it's the same programmer in charge of both layers,

149
00:06:27,321 --> 00:06:30,002
doing both, say, pathfinding and behaviors,

150
00:06:30,482 --> 00:06:32,303
you're at particular risk for things leaking

151
00:06:32,343 --> 00:06:34,024
through the layers, because why not?

152
00:06:34,064 --> 00:06:34,984
He's an expert in both.

153
00:06:35,484 --> 00:06:41,768
Whereas if it's different people in different layers, there's more likely to be separation,

154
00:06:41,928 --> 00:06:46,491
but it's also more likely that that separation will be in the wrong place, because it's more

155
00:06:46,531 --> 00:06:50,593
difficult for the two programmers to work together to refactor the layer design.

156
00:06:54,704 --> 00:06:55,705
So let's change gears a bit.

157
00:06:56,386 --> 00:06:58,668
You get a bug report where during a cut scene,

158
00:06:58,888 --> 00:07:00,730
in the middle of the scene, a goblin runs in

159
00:07:00,830 --> 00:07:02,792
and starts hitting one of the characters with a stick,

160
00:07:03,112 --> 00:07:05,054
which rather detracts from the drama of the moment.

161
00:07:05,955 --> 00:07:07,676
Now, the background characters, the goblins,

162
00:07:07,876 --> 00:07:09,698
need to keep doing goblin stuff.

163
00:07:09,718 --> 00:07:12,060
So you can't just turn off their AI during the scene.

164
00:07:12,100 --> 00:07:13,962
So you try various things, various approaches.

165
00:07:14,002 --> 00:07:16,004
And eventually, you find a solution.

166
00:07:17,165 --> 00:07:22,472
You happen to already have a utility which checks whether a character is playing a scripted

167
00:07:22,612 --> 00:07:25,175
animation sequence, which is a thing in your animation system.

168
00:07:25,656 --> 00:07:30,483
So in the target selection system, you exclude characters who are currently playing these

169
00:07:30,583 --> 00:07:32,265
pre-canned animation systems.

170
00:07:32,949 --> 00:07:33,510
There's sequences.

171
00:07:34,210 --> 00:07:36,071
And this is a practical solution.

172
00:07:36,512 --> 00:07:37,973
It's simple, and it's straightforward,

173
00:07:38,033 --> 00:07:39,434
and it happens to actually work.

174
00:07:40,194 --> 00:07:41,896
And it feels right.

175
00:07:42,316 --> 00:07:44,177
You guys know what I mean by feels right?

176
00:07:44,197 --> 00:07:47,199
Because if a target can't respond to combat,

177
00:07:47,280 --> 00:07:50,182
if a character is off doing their own thing,

178
00:07:50,522 --> 00:07:52,643
then they shouldn't be participating in combat,

179
00:07:52,683 --> 00:07:54,165
including as a target.

180
00:07:55,943 --> 00:07:57,244
Fast forward, the game is released,

181
00:07:57,325 --> 00:07:59,967
and players start noticing that if they keep sheathing

182
00:08:00,007 --> 00:08:01,848
and drawing their broadsword constantly,

183
00:08:02,729 --> 00:08:04,930
the player is invisible to enemies.

184
00:08:05,311 --> 00:08:08,433
Because late in the dev cycle, the act of drawing or putting

185
00:08:08,473 --> 00:08:10,354
away a broadsword got implemented

186
00:08:10,515 --> 00:08:13,937
as a scripted animation sequence to work around, say,

187
00:08:13,957 --> 00:08:14,798
some camera issues.

188
00:08:14,858 --> 00:08:17,120
So if you keep doing the broadsword thing,

189
00:08:17,640 --> 00:08:18,741
enemies keep ignoring you.

190
00:08:21,353 --> 00:08:22,734
What happened in this example?

191
00:08:22,874 --> 00:08:26,137
Well, what happened is you mistook functionality for intent.

192
00:08:26,617 --> 00:08:30,260
The attribute you were looking at was called isPlayingSequence.

193
00:08:30,360 --> 00:08:32,141
It was not called in a cut scene.

194
00:08:32,401 --> 00:08:34,463
And it certainly wasn't called in a scripted cut scene

195
00:08:34,483 --> 00:08:35,484
where people are talking to each other

196
00:08:35,524 --> 00:08:36,845
and everyone else should go do their own thing.

197
00:08:38,630 --> 00:08:42,854
It worked at that moment in time, because at that moment in time,

198
00:08:43,235 --> 00:08:46,498
nobody was using these canned animation sequences for anything else.

199
00:08:47,399 --> 00:08:50,182
But it wasn't testing what it wanted to test.

200
00:08:50,542 --> 00:08:52,124
It was testing a proxy of that.

201
00:08:54,115 --> 00:08:59,319
In the moment of implementation, this felt like a small, unimportant fix to a minor bug.

202
00:08:59,779 --> 00:09:04,583
And what I want to convey is that little decisions like this can have huge, far-reaching future

203
00:09:04,764 --> 00:09:05,244
impacts.

204
00:09:05,844 --> 00:09:10,168
You took the concept of scripted animation and you added to its definition.

205
00:09:10,728 --> 00:09:12,910
Before it was a detail of the animation system.

206
00:09:13,050 --> 00:09:18,094
Now it's a rule of gameplay, but it still has to be a detail of the animation system.

207
00:09:19,903 --> 00:09:22,043
So let's imagine the same scenario a different way,

208
00:09:22,123 --> 00:09:24,304
because I've known some really good QA testers,

209
00:09:24,624 --> 00:09:26,285
and constantly drawing their broadsword

210
00:09:26,465 --> 00:09:28,485
is exactly the sort of crap they'd try.

211
00:09:29,045 --> 00:09:30,166
So this never got released.

212
00:09:30,286 --> 00:09:32,826
It got reported a day after they made the broadsword

213
00:09:32,886 --> 00:09:33,887
thing a scripted sequence.

214
00:09:34,407 --> 00:09:37,147
And the combat programmer says, oh, I

215
00:09:37,167 --> 00:09:39,108
guess we can't use scripted sequences for that,

216
00:09:39,188 --> 00:09:40,528
because it breaks the AI.

217
00:09:41,208 --> 00:09:44,889
You, the AI programmer, just made the animation system

218
00:09:44,949 --> 00:09:45,249
worse.

219
00:09:46,130 --> 00:09:49,591
because you got there first, and you imposed definition

220
00:09:49,671 --> 00:09:51,752
on something, and you did not do a good job of it.

221
00:09:52,612 --> 00:09:54,773
Now, this is a particularly egregious example

222
00:09:54,853 --> 00:09:56,574
because it involves multiple systems.

223
00:09:56,654 --> 00:09:59,655
But this sort of thing happens on a smaller scale

224
00:10:00,015 --> 00:10:00,616
all the time.

225
00:10:01,196 --> 00:10:04,337
And it usually happens in AI, because AI

226
00:10:04,377 --> 00:10:07,178
has exactly the sort of semantically rich concepts

227
00:10:07,718 --> 00:10:09,879
with corner cases that nobody thinks about

228
00:10:09,919 --> 00:10:11,000
until the bugs are reported.

229
00:10:13,610 --> 00:10:15,372
The other thing to take away from these examples

230
00:10:15,432 --> 00:10:18,035
is that you should be wary of when something feels right.

231
00:10:18,676 --> 00:10:20,599
I'm not saying ignore your instincts,

232
00:10:21,079 --> 00:10:22,902
but what felt right in this example

233
00:10:23,222 --> 00:10:24,824
was not just your solution,

234
00:10:25,325 --> 00:10:27,948
but the whole context in which you imagined

235
00:10:27,988 --> 00:10:29,250
this solution existing.

236
00:10:31,149 --> 00:10:36,271
When there's ambiguity, there's a tendency to come to an understanding which is based

237
00:10:36,451 --> 00:10:40,093
on your own current needs, a sort of wishful thinking.

238
00:10:40,653 --> 00:10:46,575
Repurposing an existing tool to solve a new problem feels really rewarding because it's

239
00:10:46,655 --> 00:10:48,936
clever and being clever is rewarding.

240
00:10:49,557 --> 00:10:54,659
But when you feel happiness at your own cleverness, make sure to feel some worry as well.

241
00:10:58,520 --> 00:10:59,281
All right, so moving on.

242
00:10:59,801 --> 00:11:01,722
Who here has experienced bugs caused

243
00:11:01,762 --> 00:11:03,063
by floating point imprecision?

244
00:11:04,024 --> 00:11:04,284
Yeah.

245
00:11:04,924 --> 00:11:05,765
Yeah, OK, everybody.

246
00:11:06,125 --> 00:11:07,486
It's sort of a rite of passage, right?

247
00:11:07,526 --> 00:11:09,648
Looking at this number and wondering why it isn't one.

248
00:11:11,329 --> 00:11:12,569
OK, so here's an example of a bug.

249
00:11:12,970 --> 00:11:15,251
So you have an enemy AI for a melee character

250
00:11:15,571 --> 00:11:17,232
where the character tries to navigate

251
00:11:17,252 --> 00:11:19,074
to be exactly one meter away from the player

252
00:11:19,334 --> 00:11:21,015
because that's what the animations are built for.

253
00:11:22,049 --> 00:11:25,393
and the character measures distance from their own frame of reference,

254
00:11:25,433 --> 00:11:29,178
which involves a number of calculations, various additions and multiplications,

255
00:11:29,598 --> 00:11:31,140
and due to floating point imprecision,

256
00:11:31,500 --> 00:11:35,244
you find that the character actually ends up navigating to a point 0.99997 meters away.

257
00:11:40,171 --> 00:11:41,913
That's not a really compelling example.

258
00:11:42,254 --> 00:11:42,974
It's barely a bug.

259
00:11:43,155 --> 00:11:44,977
Nobody reported this because nobody cared.

260
00:11:45,718 --> 00:11:48,541
And if you think about it, why should floating point

261
00:11:48,802 --> 00:11:50,343
imprecision matter in AI?

262
00:11:50,363 --> 00:11:53,307
Because AI is all about uncertainty and fuzziness.

263
00:11:53,708 --> 00:11:55,830
Exact numbers aren't generally important.

264
00:11:55,870 --> 00:11:59,855
When we tweak our AI, we do it through sliders, not text boxes.

265
00:12:02,366 --> 00:12:04,288
But playing with curves and fuzziness

266
00:12:04,408 --> 00:12:06,110
is only the first half of AI.

267
00:12:06,771 --> 00:12:09,033
And the second half of AI is about taking

268
00:12:09,073 --> 00:12:11,736
these uncertainties and fuzzinesses and probabilities

269
00:12:11,796 --> 00:12:15,660
and such and making distinct behavioral decisions based

270
00:12:15,760 --> 00:12:16,000
on them.

271
00:12:18,937 --> 00:12:21,099
There's this related concept in math,

272
00:12:21,519 --> 00:12:23,360
in computational math, of a predicate.

273
00:12:23,960 --> 00:12:26,402
A predicate is a procedure that takes some data,

274
00:12:26,762 --> 00:12:29,064
say like the vertices of a polygon,

275
00:12:29,404 --> 00:12:31,525
and makes a discrete judgment based on that,

276
00:12:31,605 --> 00:12:33,747
like is that polygon convex,

277
00:12:33,947 --> 00:12:36,509
based on the real valued vertex positions.

278
00:12:37,329 --> 00:12:38,650
Or, like when you take data,

279
00:12:38,830 --> 00:12:41,212
like how far away is somebody,

280
00:12:41,572 --> 00:12:43,793
and you make a discrete decision based on that,

281
00:12:43,953 --> 00:12:45,394
like should I start fighting them.

282
00:12:46,115 --> 00:12:46,895
Both predicates.

283
00:12:48,556 --> 00:12:49,536
So let's try that bug again.

284
00:12:49,556 --> 00:12:51,357
You've got a character that wants to be one meter away.

285
00:12:51,717 --> 00:12:52,837
It does its calculation.

286
00:12:52,957 --> 00:12:56,218
And it says, oh no, I'm slightly more than one meter away.

287
00:12:56,399 --> 00:12:57,379
I'd better get closer.

288
00:12:57,939 --> 00:12:59,500
So it asks the navigation system,

289
00:12:59,780 --> 00:13:01,100
please take me to this place.

290
00:13:01,200 --> 00:13:03,241
I've calculated that it's exactly one meter away

291
00:13:03,261 --> 00:13:03,801
from the player.

292
00:13:04,141 --> 00:13:05,622
And let me know when I've arrived.

293
00:13:06,082 --> 00:13:08,523
And the navigation system does its own calculations

294
00:13:08,663 --> 00:13:11,604
in a different part of the code base and says, good news.

295
00:13:11,924 --> 00:13:12,464
You've arrived.

296
00:13:12,484 --> 00:13:14,364
You're one meter away at that goal point you gave me.

297
00:13:15,345 --> 00:13:17,266
And then the combat system, the following frame,

298
00:13:17,566 --> 00:13:19,828
redoes its calculation system and says, oh, no,

299
00:13:20,168 --> 00:13:22,049
I'm 1.002 meters away.

300
00:13:22,089 --> 00:13:22,970
I'd better get closer.

301
00:13:23,630 --> 00:13:24,351
I'll get there.

302
00:13:24,491 --> 00:13:25,732
I'm at my goal, et cetera.

303
00:13:26,512 --> 00:13:28,173
And from the player's point of view, of course,

304
00:13:28,233 --> 00:13:31,195
what's happening is that the kid's just sitting there

305
00:13:31,215 --> 00:13:31,996
and twitching a little.

306
00:13:34,858 --> 00:13:36,299
Now that feels like a bug, right?

307
00:13:36,979 --> 00:13:38,840
But it's not like a scary bug.

308
00:13:39,561 --> 00:13:42,423
So OK, for the audience, how should I fix this bug?

309
00:13:44,124 --> 00:13:44,364
Anybody?

310
00:13:46,292 --> 00:13:47,773
Add an epsilon, add a tolerance, yes.

311
00:13:48,574 --> 00:13:49,795
This was still not a great example.

312
00:13:49,815 --> 00:13:51,216
This was way too easy to fix.

313
00:13:53,018 --> 00:13:54,599
Let's talk about that tolerance value.

314
00:13:54,639 --> 00:13:55,761
I heard the word epsilon.

315
00:13:55,921 --> 00:13:56,942
What should the tolerance be?

316
00:13:57,923 --> 00:13:59,584
Well, there's float epsilon,

317
00:13:59,824 --> 00:14:02,247
which is not something you should be using for anything

318
00:14:02,307 --> 00:14:05,049
unless you fully understand how to do forward error analysis.

319
00:14:05,129 --> 00:14:06,851
I see this being misused so often.

320
00:14:06,891 --> 00:14:08,152
This is not a magic value

321
00:14:08,172 --> 00:14:09,934
that means two numbers are close enough.

322
00:14:16,464 --> 00:14:16,864
Yeah, all right.

323
00:14:20,007 --> 00:14:21,528
We'll call this 1 centimeter.

324
00:14:21,708 --> 00:14:24,410
And 1 centimeter off is going to be fine visually.

325
00:14:24,590 --> 00:14:27,012
And so you test with 1 centimeter, and it works.

326
00:14:27,392 --> 00:14:27,612
Ship it.

327
00:14:28,673 --> 00:14:29,774
Here's the problem, though.

328
00:14:30,474 --> 00:14:32,896
You tested this in your test level, which

329
00:14:32,936 --> 00:14:36,438
is maybe 50 meters on the side, and your characters

330
00:14:36,478 --> 00:14:37,279
are nearly at the origin.

331
00:14:37,739 --> 00:14:39,981
Now, the basic nature of floating-point error

332
00:14:40,362 --> 00:14:43,965
is that it is relative to the magnitude of the numbers

333
00:14:44,085 --> 00:14:44,626
involved.

334
00:14:45,187 --> 00:14:47,349
When you do math with large numbers,

335
00:14:47,609 --> 00:14:50,232
particularly when you are subtracting large numbers

336
00:14:50,332 --> 00:14:53,174
from each other, you end up with an error

337
00:14:53,655 --> 00:14:56,978
which is much higher than when all your numbers are small.

338
00:14:58,449 --> 00:15:01,230
Now, an example of small numbers is the coordinates

339
00:15:01,270 --> 00:15:02,991
of all the objects in your test level.

340
00:15:03,311 --> 00:15:05,472
This sets up this tragically common pattern

341
00:15:05,512 --> 00:15:07,373
where everything works fine when you test it,

342
00:15:07,633 --> 00:15:09,814
and then much later, you have to fix it again

343
00:15:10,235 --> 00:15:12,155
because you tested it so close to the origin,

344
00:15:12,516 --> 00:15:14,497
and then the game happens far, far away.

345
00:15:15,097 --> 00:15:17,918
It's very tricky to experimentally determine

346
00:15:17,938 --> 00:15:19,379
the proper value for tolerance,

347
00:15:19,819 --> 00:15:22,640
but a good first step is to do your tests

348
00:15:23,001 --> 00:15:25,162
as far from the origin as you're going to get.

349
00:15:27,741 --> 00:15:30,363
So tolerance solved that last problem, which is fine.

350
00:15:30,443 --> 00:15:31,845
That is a good enough solution.

351
00:15:31,925 --> 00:15:33,987
But I still want to drill into it a little bit more.

352
00:15:34,627 --> 00:15:36,068
Now I was talking about predicates.

353
00:15:36,769 --> 00:15:39,331
And in this last example, we have two predicates now.

354
00:15:39,351 --> 00:15:41,473
We've got the navigation systems predicate,

355
00:15:41,894 --> 00:15:42,875
am I one meter away?

356
00:15:43,235 --> 00:15:45,217
And we've, I'm sorry, the combat systems predicate

357
00:15:45,257 --> 00:15:48,299
and navigation systems predicate is, am I at my goal point?

358
00:15:49,543 --> 00:15:51,504
And the assumption is, if navigation says,

359
00:15:51,584 --> 00:15:54,585
yes, I'm at the goal, then combat is expected to agree,

360
00:15:54,925 --> 00:15:57,086
yes, I'm ready to start meleeing.

361
00:15:57,726 --> 00:15:59,086
That's mathematically reasonable,

362
00:15:59,406 --> 00:16:00,807
but throw in floating point error,

363
00:16:00,927 --> 00:16:02,527
and you lose that consistency.

364
00:16:02,907 --> 00:16:04,608
What we did with the tolerance, the reason

365
00:16:04,648 --> 00:16:06,768
this was an acceptable solution, was

366
00:16:06,828 --> 00:16:11,209
that we made this logical consequence more robust,

367
00:16:11,530 --> 00:16:14,290
so that when navigation says, yes, you've arrived,

368
00:16:14,870 --> 00:16:17,071
combat will definitely say, yes, I'm

369
00:16:17,251 --> 00:16:18,792
approximately one meter away.

370
00:16:21,599 --> 00:16:23,540
All right, so another example, squad combat.

371
00:16:24,080 --> 00:16:25,401
You've got a squad of two enemies.

372
00:16:26,221 --> 00:16:28,443
Let's just say this is a squad, and you

373
00:16:28,463 --> 00:16:30,884
want to avoid overwhelming the player with two enemies at once.

374
00:16:31,244 --> 00:16:33,386
So only the closest one engages the player,

375
00:16:33,706 --> 00:16:35,327
and the other one, say, waits his turn,

376
00:16:35,907 --> 00:16:37,928
like if you've watched a kung fu action film, that sort of thing.

377
00:16:38,489 --> 00:16:40,770
So each enemy, in their behavior,

378
00:16:41,130 --> 00:16:42,791
measures their own distance to the player,

379
00:16:43,172 --> 00:16:45,953
and then it measures the other enemy's distance to the player.

380
00:16:46,394 --> 00:16:48,915
And if it's the one that's closer, then it attacks.

381
00:16:49,235 --> 00:16:50,856
And if it isn't, then it waits around.

382
00:16:51,377 --> 00:16:52,538
and tries to look action-packed.

383
00:16:53,979 --> 00:16:57,261
But now let's say that both enemies are about the same

384
00:16:57,341 --> 00:17:00,084
distance to the player, and each one does the calculation

385
00:17:00,204 --> 00:17:01,405
in a different frame of reference,

386
00:17:01,465 --> 00:17:04,487
and each one thinks my squad mate is a little closer

387
00:17:04,988 --> 00:17:05,808
and waits its turn.

388
00:17:05,868 --> 00:17:08,610
And the result is much the same as with the last example,

389
00:17:09,031 --> 00:17:11,032
two enemies standing around checking their watches.

390
00:17:13,094 --> 00:17:14,595
So let's try adding some tolerance to that.

391
00:17:14,695 --> 00:17:16,777
So let's say if an enemy calculates

392
00:17:19,096 --> 00:17:21,518
that he's 10% closer than the squad mate,

393
00:17:21,858 --> 00:17:23,359
he says, yes, I'm definitely closer.

394
00:17:24,280 --> 00:17:27,403
If he's 10% farther away, he says, yes, I'm definitely

395
00:17:27,463 --> 00:17:27,823
farther.

396
00:17:28,223 --> 00:17:30,605
In those two cases, if he's definitely closer, he attacks.

397
00:17:30,906 --> 00:17:32,047
Definitely farther, he waits.

398
00:17:32,567 --> 00:17:34,148
And what about if it's in between?

399
00:17:34,248 --> 00:17:34,729
What then?

400
00:17:34,749 --> 00:17:39,693
We're seeing a different kind of tolerance here.

401
00:17:39,893 --> 00:17:41,754
In the goal reached case, it was simply

402
00:17:41,815 --> 00:17:44,837
identifying the region in which it was good enough.

403
00:17:46,530 --> 00:17:49,832
Here we're using a tolerance to express that in this zone,

404
00:17:50,152 --> 00:17:52,774
the predicate might not be giving the correct answer.

405
00:17:53,474 --> 00:17:55,035
But we still need an answer, right?

406
00:17:55,055 --> 00:17:57,516
Because the enemy still has to attack or not attack.

407
00:17:57,556 --> 00:17:59,397
We still have to make this binary decision.

408
00:18:01,044 --> 00:18:03,346
What if we added a tiebreaker that applied

409
00:18:03,486 --> 00:18:04,526
just in that error zone?

410
00:18:04,607 --> 00:18:06,308
If he's definitely closer, he attacks.

411
00:18:06,328 --> 00:18:08,089
If he's definitely farther, he waits.

412
00:18:08,529 --> 00:18:12,672
In the middle, he'll fall back on a tiebreaker.

413
00:18:13,332 --> 00:18:15,034
Select, look at your object ID

414
00:18:15,134 --> 00:18:16,435
and your squadmate's object ID.

415
00:18:16,575 --> 00:18:19,016
If yours is lower, you are closer.

416
00:18:19,096 --> 00:18:19,817
You get to attack.

417
00:18:21,198 --> 00:18:23,079
And this is obviously consistent.

418
00:18:23,579 --> 00:18:24,500
So does this work?

419
00:18:25,221 --> 00:18:25,321
No.

420
00:18:26,262 --> 00:18:27,702
you have just moved the bug over,

421
00:18:27,722 --> 00:18:29,703
you've just made it more complex to reproduce.

422
00:18:30,143 --> 00:18:32,944
Now there's a situation where one enemy thinks,

423
00:18:33,284 --> 00:18:35,285
I'm definitely farther, so I'll wait,

424
00:18:35,965 --> 00:18:37,165
just outside that tolerance.

425
00:18:37,385 --> 00:18:40,006
And the other one calculates, I'm in the error zone,

426
00:18:40,346 --> 00:18:42,467
and my ID is higher, so I'll wait.

427
00:18:42,607 --> 00:18:43,708
So they both wait.

428
00:18:45,968 --> 00:18:48,469
You cannot use tolerance and a tiebreaker.

429
00:18:48,729 --> 00:18:50,910
You cannot use this sort of escalation of

430
00:18:54,190 --> 00:18:58,754
complexity to fix floating point problems that are caused by inconsistent predicates.

431
00:18:59,174 --> 00:19:00,015
It doesn't work.

432
00:19:00,996 --> 00:19:02,397
This is a real life problem, by the way.

433
00:19:02,437 --> 00:19:03,338
This is not just game.

434
00:19:03,358 --> 00:19:04,378
So here's another example.

435
00:19:04,719 --> 00:19:06,520
Two cars come to a four-way stop.

436
00:19:06,861 --> 00:19:11,384
Now the law says, at least in California, that the driver on the right goes first.

437
00:19:11,725 --> 00:19:12,145
But if...

438
00:19:12,645 --> 00:19:12,966
I'm sorry.

439
00:19:13,206 --> 00:19:15,128
The driver who gets there first goes first.

440
00:19:15,208 --> 00:19:18,891
But if two drivers get there at the same time, the driver on the right goes first.

441
00:19:19,431 --> 00:19:23,976
Which, I'm sure they had the best of intentions when they made this law, but it doesn't help anything.

442
00:19:24,217 --> 00:19:28,501
Because now, instead of wondering whether you were there first or second,

443
00:19:28,742 --> 00:19:31,785
you're wondering whether you were there at the same enough time.

444
00:19:32,085 --> 00:19:33,587
So you get exactly the same problems.

445
00:19:34,588 --> 00:19:37,591
This is another bug caused by inconsistent predicates.

446
00:19:39,918 --> 00:19:42,761
So let's revert all that, enough with tolerances,

447
00:19:43,081 --> 00:19:44,903
to enemies, the closer one attacks.

448
00:19:45,363 --> 00:19:47,285
And there's a much cleaner solution, right?

449
00:19:47,845 --> 00:19:49,987
So they can just both measure

450
00:19:50,047 --> 00:19:51,749
from the same frame of reference, right?

451
00:19:52,735 --> 00:19:56,078
Because then they're both asking consistent questions.

452
00:19:56,238 --> 00:19:58,219
So of course they'll get consistent answers.

453
00:19:58,659 --> 00:20:00,200
They might get the wrong answer.

454
00:20:00,521 --> 00:20:02,622
They might say that A is slightly closer

455
00:20:02,962 --> 00:20:05,504
when really, truly B was slightly closer.

456
00:20:05,544 --> 00:20:07,886
But that's the sort of bug we don't care about.

457
00:20:07,946 --> 00:20:10,928
That's a 0.99997 meters away sort of bug.

458
00:20:11,908 --> 00:20:15,491
Once we have this consistency, in fact, if we detect a tie,

459
00:20:15,851 --> 00:20:17,852
then we can fall back on the tiebreaker

460
00:20:18,153 --> 00:20:21,675
because it'll only apply in the actual case of exact ties.

461
00:20:22,598 --> 00:20:24,560
Of course, we can make the solution even cleaner.

462
00:20:25,120 --> 00:20:27,842
Don't make the enemies make the decision separately.

463
00:20:28,183 --> 00:20:30,044
Have a squad behavior which handles this.

464
00:20:30,905 --> 00:20:33,927
And again, we're restoring consistency in this example,

465
00:20:34,508 --> 00:20:36,570
not by having two consistent predicates,

466
00:20:36,590 --> 00:20:39,392
but by chopping the number of predicates down to one.

467
00:20:42,625 --> 00:20:44,707
Now I want to disabuse you of the idea

468
00:20:44,847 --> 00:20:47,128
that floating point math is the only source

469
00:20:47,168 --> 00:20:48,489
of inconsistent predicates.

470
00:20:48,869 --> 00:20:50,510
It happens at stop signs, for instance.

471
00:20:51,111 --> 00:20:53,272
It's a common one with floating point math

472
00:20:53,312 --> 00:20:55,353
simply because we have all these intuitions

473
00:20:55,793 --> 00:20:57,775
about how math is supposed to work,

474
00:20:57,815 --> 00:20:59,396
which actually can kind of go out the window.

475
00:20:59,436 --> 00:21:02,237
But there's a danger of inconsistent predicates

476
00:21:02,638 --> 00:21:04,219
whenever you are making decisions

477
00:21:04,579 --> 00:21:06,980
based on multiple concepts whose relationship

478
00:21:07,401 --> 00:21:09,962
might be a little more complicated than it first seemed.

479
00:21:13,915 --> 00:21:16,116
All right, so changing gears a bit,

480
00:21:16,176 --> 00:21:19,337
let's talk about documentation, which is a huge topic,

481
00:21:19,457 --> 00:21:21,958
and it's not necessarily AI specific.

482
00:21:23,158 --> 00:21:26,480
But I think there is an AI specific bit of this,

483
00:21:26,500 --> 00:21:29,161
because I want to go back to something I touched on earlier.

484
00:21:29,361 --> 00:21:31,241
I mentioned in an earlier slide about,

485
00:21:31,261 --> 00:21:33,922
this is the one with the cut scene thing with the goblin.

486
00:21:35,143 --> 00:21:36,463
I said that the source of the bug

487
00:21:36,503 --> 00:21:39,785
was that the programmer confused functionality with intent.

488
00:21:41,482 --> 00:21:43,544
There's various kinds of documentation.

489
00:21:43,584 --> 00:21:45,185
There's different reasons that you might

490
00:21:45,265 --> 00:21:46,606
need to document something.

491
00:21:46,987 --> 00:21:51,110
But one crucial reason for AI is to document intent.

492
00:21:51,130 --> 00:21:54,713
All right, take a look at this function.

493
00:22:00,598 --> 00:22:01,559
I won't keep you in suspense.

494
00:22:02,019 --> 00:22:02,860
Anybody know what this is?

495
00:22:03,621 --> 00:22:04,421
This is Bubble Sort.

496
00:22:05,142 --> 00:22:06,963
If ever there was self-documenting code,

497
00:22:07,103 --> 00:22:07,484
it's this.

498
00:22:09,180 --> 00:22:10,401
All right, so keep that one in mind.

499
00:22:10,681 --> 00:22:11,662
Here's another function.

500
00:22:13,582 --> 00:22:14,843
Yes, that is identical code.

501
00:22:15,363 --> 00:22:17,424
No, these are not the same function.

502
00:22:17,684 --> 00:22:19,705
They have the same functionality, but they have

503
00:22:19,785 --> 00:22:20,666
different intent.

504
00:22:21,766 --> 00:22:26,309
This first function is intended to sort any array of characters by the character's age.

505
00:22:26,829 --> 00:22:27,530
It has a bug.

506
00:22:28,310 --> 00:22:31,893
If the array has length zero, it reads out of bounds and probably crashes.

507
00:22:32,713 --> 00:22:38,897
This second function is intended to sort any non-empty array of characters by their age.

508
00:22:39,257 --> 00:22:41,079
It's only used when the array is non-empty.

509
00:22:41,439 --> 00:22:42,600
It does not have a bug.

510
00:22:44,868 --> 00:22:46,489
And the only difference is the intent.

511
00:22:46,789 --> 00:22:49,131
This is why the most crucial documentation

512
00:22:49,231 --> 00:22:52,693
is documenting intent, because nothing else indicates intent.

513
00:22:52,953 --> 00:22:55,755
This code is self-documenting for most things,

514
00:22:56,236 --> 00:22:57,356
everything except the intent.

515
00:22:59,798 --> 00:23:01,459
Imagine that you saw that function crash,

516
00:23:01,819 --> 00:23:02,860
read out of bounds of memory.

517
00:23:02,900 --> 00:23:04,221
Well, where is the problem?

518
00:23:04,862 --> 00:23:06,543
Is the bug here in this function?

519
00:23:07,063 --> 00:23:09,345
Or is the bug in whatever code produced

520
00:23:09,505 --> 00:23:11,386
an empty array of characters, which

521
00:23:11,466 --> 00:23:12,607
is never supposed to happen?

522
00:23:13,649 --> 00:23:16,532
And if the bug is here, if empty arrays are reasonable,

523
00:23:16,892 --> 00:23:17,713
where did it come from?

524
00:23:17,833 --> 00:23:21,096
Why did this code use not equals instead of less than?

525
00:23:21,577 --> 00:23:23,098
Was the programmer not paying attention?

526
00:23:23,158 --> 00:23:24,319
Is there some subtlety?

527
00:23:24,419 --> 00:23:27,102
Maybe there's a range issue with signed integers.

528
00:23:27,703 --> 00:23:30,005
Maybe it's designed for a platform where that's faster.

529
00:23:30,465 --> 00:23:32,107
Is this code stupid or smart?

530
00:23:32,707 --> 00:23:34,228
For that matter, speaking of stupid or smart,

531
00:23:34,508 --> 00:23:35,208
why bubble sort?

532
00:23:35,909 --> 00:23:37,509
N squared time, why not use quicksort?

533
00:23:37,569 --> 00:23:39,510
But maybe the programmer doesn't know about quicksort,

534
00:23:39,610 --> 00:23:41,811
or maybe they do, but they wanted a stable sort,

535
00:23:41,911 --> 00:23:42,932
which quicksort is not.

536
00:23:42,972 --> 00:23:45,052
But then maybe they should have used merge sort.

537
00:23:45,433 --> 00:23:45,873
Maybe not.

538
00:23:45,913 --> 00:23:47,593
Maybe they're worried about branch prediction.

539
00:23:47,614 --> 00:23:50,175
Maybe they tuned this very specifically for the use case.

540
00:23:51,622 --> 00:23:52,002
Who knows?

541
00:23:52,723 --> 00:23:53,583
You know what this code is?

542
00:23:53,743 --> 00:23:55,023
It is uncooperative.

543
00:23:55,884 --> 00:23:58,244
It refuses to tell you what you need to know.

544
00:23:58,565 --> 00:24:01,706
And through that refusal, it refuses to change.

545
00:24:02,266 --> 00:24:03,946
This is code that you leave alone

546
00:24:04,146 --> 00:24:07,688
if you are not absolutely forced to not leave it alone.

547
00:24:08,008 --> 00:24:10,188
Because if you touch it, something might break.

548
00:24:12,581 --> 00:24:15,563
The other reason to document intent is to standardize it.

549
00:24:15,783 --> 00:24:18,145
Let's say your character has an isAlive method.

550
00:24:18,386 --> 00:24:19,707
What does alive mean here?

551
00:24:20,427 --> 00:24:21,928
Suppose you add a death animation.

552
00:24:21,968 --> 00:24:23,490
While the death animation is playing,

553
00:24:23,530 --> 00:24:25,391
should isAlive return true or false?

554
00:24:25,831 --> 00:24:28,413
The documentation of isAlive helps

555
00:24:28,453 --> 00:24:30,035
you answer that question by telling you

556
00:24:30,155 --> 00:24:31,636
what it's meant to be used for.

557
00:24:32,717 --> 00:24:35,459
Because the process of documenting a concept

558
00:24:35,839 --> 00:24:39,442
involves exploring that concept, defining that shape.

559
00:24:42,793 --> 00:24:44,554
Maybe, assuming we thought of that

560
00:24:44,574 --> 00:24:46,095
when we were making the documentation.

561
00:24:46,355 --> 00:24:48,536
But suppose we didn't think about it,

562
00:24:48,556 --> 00:24:49,996
because we didn't even think of the aspect

563
00:24:50,036 --> 00:24:53,197
of somebody being neither alive nor dead.

564
00:24:54,058 --> 00:24:57,219
That's still an example of a reason to document your intent,

565
00:24:57,339 --> 00:24:59,960
even if we have to go back and fix the documentation.

566
00:25:00,400 --> 00:25:02,481
Because when you fix a documentation,

567
00:25:02,921 --> 00:25:05,122
when you change the intent or clarify it,

568
00:25:05,142 --> 00:25:06,122
which is a kind of change,

569
00:25:06,302 --> 00:25:08,243
you're potentially cutting off certain usages.

570
00:25:12,939 --> 00:25:16,821
Update to the documentation forces you to think about that action you're taking.

571
00:25:16,841 --> 00:25:20,023
It forces you to think about all the use cases you might be ruining,

572
00:25:20,103 --> 00:25:23,725
all the future use cases even,

573
00:25:23,966 --> 00:25:27,148
ones not currently using this function that you might be cutting off.

574
00:25:31,073 --> 00:25:33,977
Now, documenting your intent isn't just about writing essays.

575
00:25:34,739 --> 00:25:36,261
Think about an architectural drawing.

576
00:25:36,762 --> 00:25:39,406
This is not a single picture.

577
00:25:39,426 --> 00:25:40,347
It's multiple pictures.

578
00:25:40,387 --> 00:25:42,651
You get redundant, overlapping information

579
00:25:42,711 --> 00:25:46,136
to resolve ambiguities in a single diagram.

580
00:25:47,265 --> 00:25:49,846
Similarly, if long comments are one view,

581
00:25:50,047 --> 00:25:51,707
another view is tests and assertions.

582
00:25:52,267 --> 00:25:54,488
Now I'm not going to talk very much about tests and assertions

583
00:25:54,548 --> 00:25:56,329
because I don't think I'm the right person to do it.

584
00:25:56,489 --> 00:25:58,310
Other people have thought about it a lot more than I have.

585
00:25:58,750 --> 00:26:02,051
But I will say that one of the most useful aspects of tests

586
00:26:02,291 --> 00:26:04,732
for me is as a form of documentation.

587
00:26:05,693 --> 00:26:07,194
They document what you were thinking about,

588
00:26:07,554 --> 00:26:08,615
what you were worried about.

589
00:26:08,655 --> 00:26:11,316
They highlight the difficult or under-specified cases.

590
00:26:11,737 --> 00:26:13,978
They help someone understand why you had

591
00:26:14,058 --> 00:26:15,539
to make the decisions you made.

592
00:26:16,279 --> 00:26:19,181
Though, while we're at it, if we're making an automated test,

593
00:26:19,541 --> 00:26:21,662
maybe we should document the intent of that test.

594
00:26:22,103 --> 00:26:23,984
Is this something that you never think will happen,

595
00:26:24,024 --> 00:26:25,545
but you just put it in just in case?

596
00:26:26,005 --> 00:26:27,046
Is it the common case?

597
00:26:27,186 --> 00:26:28,126
Is it an edge case?

598
00:26:28,507 --> 00:26:30,268
Is it why you didn't use QuickSort?

599
00:26:32,883 --> 00:26:35,904
Now a corollary of tests and assertions

600
00:26:35,944 --> 00:26:38,665
being a kind of documentation is that they don't have to break

601
00:26:38,785 --> 00:26:39,745
in order to be useful.

602
00:26:40,406 --> 00:26:42,947
I will often use assertions that I know

603
00:26:43,167 --> 00:26:45,928
will never, ever, ever fail for two reasons.

604
00:26:46,248 --> 00:26:47,408
First of all, sometimes they fail.

605
00:26:48,990 --> 00:26:52,372
Secondly, an assertion is inherently reliable.

606
00:26:53,072 --> 00:26:53,732
Look at this comment.

607
00:26:54,613 --> 00:26:55,513
X will never be zero.

608
00:26:55,573 --> 00:26:58,655
Well, says you, but the reason I'm even looking at this code

609
00:26:58,695 --> 00:26:59,615
is because there's a bug.

610
00:26:59,655 --> 00:27:01,236
So someone's wrong about something.

611
00:27:02,016 --> 00:27:04,358
But if it's an assertion, well, OK, you're right.

612
00:27:04,518 --> 00:27:05,098
It's not zero.

613
00:27:05,138 --> 00:27:06,559
The princess is in another castle.

614
00:27:06,639 --> 00:27:08,120
Otherwise, this assertion would have fired.

615
00:27:09,040 --> 00:27:11,821
And because it's an assertion and not a comment,

616
00:27:12,122 --> 00:27:14,463
I don't have to spend any time, any brain power,

617
00:27:14,543 --> 00:27:15,343
second guessing it.

618
00:27:16,104 --> 00:27:17,865
It's documentation you can believe in.

619
00:27:22,617 --> 00:27:26,681
I don't think document your code is a very controversial opinion, but it's one of those

620
00:27:26,741 --> 00:27:28,704
ideals we sometimes opt out from.

621
00:27:28,984 --> 00:27:32,668
Like we try to eat healthy, get plenty of vegetables, and then we see a burger and some

622
00:27:32,708 --> 00:27:38,074
steamed carrots, and we don't really feel like the steamed carrots, and what feels like

623
00:27:38,214 --> 00:27:38,755
in the moment...

624
00:27:40,007 --> 00:27:43,449
good to do is not documenting your code maybe.

625
00:27:43,589 --> 00:27:45,991
Maybe what you feel like doing is writing the code.

626
00:27:46,751 --> 00:27:50,613
Because AI programming,

627
00:27:51,114 --> 00:27:52,534
what feels good is getting stuff done.

628
00:27:54,854 --> 00:27:57,716
Not to mention, in a situation where you're experimenting

629
00:27:57,897 --> 00:28:00,479
and iterating and redesigning, if you document something

630
00:28:00,519 --> 00:28:01,840
while you're doing all that, it feels

631
00:28:01,860 --> 00:28:05,042
like you're trying to paint an oil painting of a football

632
00:28:05,062 --> 00:28:06,743
game while the football game is still going on.

633
00:28:07,364 --> 00:28:10,126
So documentation is often done as a post-pass.

634
00:28:11,547 --> 00:28:13,469
The good thing about documentation as a post-pass

635
00:28:13,509 --> 00:28:14,570
is you don't need to redo it.

636
00:28:15,130 --> 00:28:18,052
The bad thing about it is that it feels like such a chore,

637
00:28:18,132 --> 00:28:20,234
because you already did what you wanted to do.

638
00:28:20,274 --> 00:28:21,195
You fixed the bug.

639
00:28:21,215 --> 00:28:22,235
You got everything done.

640
00:28:22,316 --> 00:28:24,257
And now you have to go back and write a book report?

641
00:28:25,530 --> 00:28:27,271
Sorts the characters by age.

642
00:28:27,311 --> 00:28:28,151
There, documented.

643
00:28:30,513 --> 00:28:32,734
I want to advise you how to write good documentation.

644
00:28:32,774 --> 00:28:34,475
And I think to do that, I need to advise you

645
00:28:34,515 --> 00:28:36,437
how to want to write good documentation.

646
00:28:36,457 --> 00:28:39,118
Because there's no objective metric of documentation

647
00:28:39,198 --> 00:28:39,658
quality.

648
00:28:39,919 --> 00:28:42,160
If you just want to get it out of the way, you can do that.

649
00:28:42,200 --> 00:28:43,901
You can convince yourself that you documented

650
00:28:43,941 --> 00:28:44,842
everything you needed to.

651
00:28:45,342 --> 00:28:46,363
So here's my advice.

652
00:28:46,803 --> 00:28:49,445
In the moment, want to share that moment.

653
00:28:49,465 --> 00:28:50,805
If you did something clever, want

654
00:28:50,845 --> 00:28:52,046
to tell other people about it.

655
00:28:52,126 --> 00:28:54,388
Not to brag, but to share your joy.

656
00:28:54,928 --> 00:28:57,651
If something was a huge pain to write, tell them about it.

657
00:28:57,711 --> 00:28:59,833
Tell them about the journey that it took you through.

658
00:29:00,273 --> 00:29:03,156
Tell them why you were forced into this weird solution.

659
00:29:03,276 --> 00:29:05,278
Explain to them the dilemmas you faced.

660
00:29:05,719 --> 00:29:06,840
Document to share.

661
00:29:07,300 --> 00:29:09,122
Sometimes that'll happen while you're writing the code.

662
00:29:09,162 --> 00:29:10,664
Sometimes it'll happen afterwards.

663
00:29:10,944 --> 00:29:13,506
But always with the same intent, which is to help your team.

664
00:29:14,147 --> 00:29:16,570
Because the goal of your process is to help your team.

665
00:29:20,792 --> 00:29:23,155
I want to have some big inspiring conclusion for this talk,

666
00:29:23,236 --> 00:29:24,738
but I think that would be a little dishonest.

667
00:29:25,198 --> 00:29:26,460
You're still going to write some bugs.

668
00:29:26,800 --> 00:29:27,862
I hope I've helped you write fewer.

669
00:29:29,144 --> 00:29:29,344
Thank you.

