1
00:00:12,169 --> 00:00:17,391
Hello and thank you for coming to my presentation. This is the Rust language for game tooling.

2
00:00:17,891 --> 00:00:21,252
My name is Dan Olson. I'm a Principal Software Architect at Treyarch.

3
00:00:22,356 --> 00:00:25,377
A little bit about me. I've been working in games since 2004.

4
00:00:26,077 --> 00:00:30,198
I've been at Treyarch since 2008. I've shipped several Call of Duty titles in that time.

5
00:00:31,198 --> 00:00:34,199
I work on Treyarch's core engine team, which is a combined

6
00:00:34,379 --> 00:00:38,740
engine and tools team, so we work on both. Most engineers are responsible for

7
00:00:38,760 --> 00:00:43,081
working on both tools and engine. I've done a lot of things, but

8
00:00:43,341 --> 00:00:46,862
mostly I've been focused on data pipeline and infrastructure tooling.

9
00:00:47,520 --> 00:00:52,281
I haven't dabbled too much in, for instance, user interface programming or anything like that.

10
00:00:53,281 --> 00:00:54,701
So that's just where I'm coming from.

11
00:00:57,422 --> 00:01:01,442
What is Rust? Well, Rust is a programming language. It was started by Mozilla

12
00:01:02,443 --> 00:01:09,944
quite a while ago. It had a first stable release in 2015, and that was the 1.0 release.

13
00:01:10,004 --> 00:01:12,485
And everything since then is backwards compatibility.

14
00:01:13,524 --> 00:01:19,029
Since then, it's branched out a little bit from just being backed by Mozilla to now being backed

15
00:01:19,070 --> 00:01:24,014
by several other companies. The three listed here have all spun up internal compiler teams

16
00:01:24,715 --> 00:01:32,362
to try to advance the language. And there's also now a Rust language foundation for financial funding.

17
00:01:33,927 --> 00:01:37,569
It's also, the language is focused on security and performance.

18
00:01:38,409 --> 00:01:41,932
If you're working on game tooling, you might not think of security as a very high priority,

19
00:01:42,332 --> 00:01:46,314
especially if all your tools are internal. But we all like performance,

20
00:01:46,394 --> 00:01:48,515
especially in the game industry, so that's pretty appealing.

21
00:01:51,657 --> 00:01:54,379
This is just the outline of what I'm going to go over.

22
00:01:54,399 --> 00:01:57,121
I'm going to try to make a case for using Rust to start out with.

23
00:01:58,186 --> 00:02:06,474
Then I'm going to go over several interesting usages of Rust that have been helpful to me in my tools authoring.

24
00:02:06,955 --> 00:02:10,278
Then we're going to talk a little bit about how we integrated Rust at Treyarch.

25
00:02:13,001 --> 00:02:16,484
First I want to start out by talking about something that's not really Rust at all.

26
00:02:17,365 --> 00:02:19,968
This is a Python snippet and it's going to be a

27
00:02:21,278 --> 00:02:27,323
an implementation of an MD5SUM algorithm. So it's hashing a file and printing out the MD5SUM

28
00:02:27,683 --> 00:02:33,748
to standard out. And I just want to rate it on a couple different categories over on the side here.

29
00:02:35,569 --> 00:02:40,313
This is Python. I think if you're trying to follow this code, you'll have a pretty easy time.

30
00:02:40,433 --> 00:02:45,717
So I think easy to read and both easy to read and easy to write will get smiley faces from me.

31
00:02:46,898 --> 00:02:49,240
This was pretty straightforward to write, didn't require much.

32
00:02:50,856 --> 00:02:56,438
thought or much work or even much typing. Errors are handled. I give this a neutral face,

33
00:02:56,879 --> 00:03:01,821
and the reason why is because Python handles all errors by default to its exception handling,

34
00:03:02,981 --> 00:03:09,084
but the error messages that it gives are not always great for end users to

35
00:03:09,124 --> 00:03:13,186
be able to figure out what's going on. A programmer can dig in there pretty well,

36
00:03:13,226 --> 00:03:14,326
but maybe not end users.

37
00:03:15,816 --> 00:03:18,299
And performance oil is kind of a mixed bag with Python.

38
00:03:18,900 --> 00:03:22,123
In general, it performs rather poorly,

39
00:03:22,183 --> 00:03:24,346
but there's a lot of things affecting its performance.

40
00:03:25,507 --> 00:03:27,970
Often, library functions are implemented in C,

41
00:03:28,030 --> 00:03:29,271
and then they can be quite efficient.

42
00:03:30,373 --> 00:03:32,455
However, for the most part, the performance of Python

43
00:03:32,495 --> 00:03:33,136
is pretty low.

44
00:03:34,417 --> 00:03:35,418
If we look at this in C.

45
00:03:39,141 --> 00:03:42,383
I pulled this implementation from Stack Overflow.

46
00:03:42,564 --> 00:03:44,125
And the reason I use it is because,

47
00:03:44,745 --> 00:03:46,887
not because I think it's a really great piece of code,

48
00:03:46,927 --> 00:03:51,630
but because it is the highest voted code

49
00:03:52,391 --> 00:03:54,072
and the first link that you will get

50
00:03:54,112 --> 00:03:56,014
if you search for how to solve this problem in C.

51
00:03:57,895 --> 00:04:00,577
So if we start looking at this with the same things in mind,

52
00:04:00,597 --> 00:04:05,100
easy to read, I'll give this a neutral face.

53
00:04:05,141 --> 00:04:07,062
It's not bad if you're familiar with C.

54
00:04:08,709 --> 00:04:12,590
I've omitted quite a large part of it just for brevity,

55
00:04:13,610 --> 00:04:14,791
but it's pretty straightforward.

56
00:04:14,831 --> 00:04:17,131
If you know what mmap and unmap are,

57
00:04:17,391 --> 00:04:18,731
then you should be able to figure out

58
00:04:18,771 --> 00:04:19,752
what this code is doing.

59
00:04:21,512 --> 00:04:25,633
As for easy to write, well, this is kind of a long story

60
00:04:25,693 --> 00:04:28,754
because this MD5 function that we're relying on

61
00:04:28,794 --> 00:04:30,694
doesn't exist in the standard library.

62
00:04:30,954 --> 00:04:32,314
It's pulled in from somewhere else.

63
00:04:33,495 --> 00:04:35,935
And the process of pulling in dependencies

64
00:04:36,783 --> 00:04:42,045
and C and C++, despite everyone's best efforts towards this, is still pretty hard to do.

65
00:04:43,246 --> 00:04:46,667
So you have to download, you have to locate the dependency, you have to make sure it's

66
00:04:46,707 --> 00:04:52,650
suitably licensed for your program, you have to integrate it into your build system,

67
00:04:53,750 --> 00:04:57,871
and maybe even link in the library. So there's a lot of steps there.

68
00:04:58,698 --> 00:05:02,080
that don't always work together cleanly with what you're trying to do.

69
00:05:03,161 --> 00:05:08,324
And so I put a cryy face here because dependencies in cnc++ make me cry.

70
00:05:08,344 --> 00:05:14,888
As for whether errors are handled well, you can see that the author attempted to do this.

71
00:05:15,608 --> 00:05:19,191
The open is checked and will exit the program, which

72
00:05:20,091 --> 00:05:26,935
doesn't really help the user very much to do it silently. But they also missed the fact that mmap

73
00:05:27,689 --> 00:05:33,432
can return an error, and if it does in this program, then the program will crash because

74
00:05:33,912 --> 00:05:38,054
what mmap returns in the case of an error is a negative one casted to a pointer.

75
00:05:40,275 --> 00:05:45,758
As for whether this performs well, yeah, we'll assume that it does. C is generally either

76
00:05:46,859 --> 00:05:51,361
well performing out of the box, or it has all the tools that you can use to make it perform well.

77
00:05:52,934 --> 00:05:57,915
So performances is great in C and C++. That's one of the reasons we love them and use them.

78
00:05:58,476 --> 00:06:03,057
But I want to focus on these two middle ones for a second. As I mentioned,

79
00:06:03,077 --> 00:06:06,758
the dependencies problem in C is still a very real thing, and C++ as well.

80
00:06:08,058 --> 00:06:14,960
And error handling is tricky because all error handling in C is completely opt-in. The language

81
00:06:15,000 --> 00:06:20,461
doesn't care if you want to overwrite memory or do whatever, read from an invalid buffer,

82
00:06:20,481 --> 00:06:21,302
it just doesn't care.

83
00:06:22,390 --> 00:06:28,596
Also, there's no real standardization as to how functions in C or C++ report errors.

84
00:06:29,877 --> 00:06:33,100
And so, if you're writing this code, I'm sure you could do a lot better,

85
00:06:33,980 --> 00:06:36,622
but you still have these issues of how do we handle dependencies,

86
00:06:37,463 --> 00:06:41,366
and how do we make sure that all our errors are handled when this is totally opt-in,

87
00:06:41,386 --> 00:06:46,431
and it's actually pretty hard to validate that you've done everything correctly.

88
00:06:47,552 --> 00:06:48,593
So, moving on to Rust.

89
00:06:50,600 --> 00:06:52,501
This is our first bit of Rust code that we've seen,

90
00:06:52,681 --> 00:06:54,682
maybe for some of you, the first bit ever.

91
00:06:56,782 --> 00:06:59,963
I want to give this an easy to read and an easy to write.

92
00:07:00,003 --> 00:07:01,964
You'll have to take my word for it on easy to write,

93
00:07:03,364 --> 00:07:05,905
but pretty straightforward what this code is doing.

94
00:07:05,965 --> 00:07:08,646
I think even if the syntax is a little bit unfamiliar,

95
00:07:08,766 --> 00:07:10,546
maybe strange, you should be

96
00:07:10,566 --> 00:07:12,127
able to figure out what's going on here.

97
00:07:13,487 --> 00:07:15,568
As for whether errors are handled, again,

98
00:07:15,648 --> 00:07:17,809
you'll need to take my word for it if you're unfamiliar with Rust,

99
00:07:17,849 --> 00:07:19,109
but yes, they are.

100
00:07:20,164 --> 00:07:25,146
We have the same problem as Python here, where the errors are handled, but they're not particularly

101
00:07:25,246 --> 00:07:31,568
well suited for end users to read and understand what's going on. We'll get into this a little bit

102
00:07:31,588 --> 00:07:39,550
more later. As for whether the code performs well, well, Rust has many of the same characteristics

103
00:07:39,630 --> 00:07:47,093
as C and C++. It's compiled, it's optimized using LLVM, and it's not running into any sort of

104
00:07:47,833 --> 00:07:49,073
VM or anything like that.

105
00:07:50,215 --> 00:07:54,739
there's not even any garbage collection, so there's no potential stalls from that.

106
00:07:54,900 --> 00:08:00,605
So Rust is a little bit like C and C++ in that it either performs well out of the box,

107
00:08:00,685 --> 00:08:02,286
or you have the tools to make it perform well.

108
00:08:03,928 --> 00:08:07,231
So this is how we get to my Rust sales pitch.

109
00:08:08,652 --> 00:08:12,876
Efficiency of writing code in Rust, it's a little bit closer to Python,

110
00:08:13,036 --> 00:08:16,018
in my opinion. The efficiency of running code is a little bit closer to C++.

111
00:08:17,539 --> 00:08:20,541
So I feel like this is a kind of a happy medium between these two things,

112
00:08:20,581 --> 00:08:22,182
because you've got the high level and the low level,

113
00:08:22,282 --> 00:08:25,204
and you can kind of get the best of both worlds with Rust.

114
00:08:27,225 --> 00:08:28,666
But that's not really all.

115
00:08:29,366 --> 00:08:31,708
There's more to this sales pitch.

116
00:08:32,708 --> 00:08:37,231
With Rust, we also get a large centralized ecosystem of what they call crates,

117
00:08:37,311 --> 00:08:38,672
which is just libraries.

118
00:08:38,692 --> 00:08:40,413
It's a Rust term for libraries.

119
00:08:41,299 --> 00:08:42,920
And the centralized part is pretty important,

120
00:08:43,541 --> 00:08:45,962
because that means you can have tooling that interacts with it.

121
00:08:46,663 --> 00:08:48,324
It also means it's very easy to search.

122
00:08:49,184 --> 00:08:53,227
And we actually, indeed, do have tooling that works with this.

123
00:08:53,327 --> 00:08:55,829
It's an integrated build package and test tool

124
00:08:55,869 --> 00:08:59,151
called Cargo, which is part of every Rust distribution.

125
00:08:59,431 --> 00:09:00,812
And this is very nice to use.

126
00:09:00,832 --> 00:09:05,455
Let me give you an example of the previous program

127
00:09:05,475 --> 00:09:06,095
that we looked at.

128
00:09:07,455 --> 00:09:11,597
If I want to make a new program, I just use cargo new.

129
00:09:11,917 --> 00:09:13,558
By default, it makes a binary application.

130
00:09:14,939 --> 00:09:16,279
I change that directory.

131
00:09:16,299 --> 00:09:19,501
To add a dependency, I can just do cargo add md5,

132
00:09:20,421 --> 00:09:23,222
which is if I know what I want to add.

133
00:09:23,242 --> 00:09:26,544
This takes about 5, 10 seconds of typing.

134
00:09:27,524 --> 00:09:30,325
Then I write my code, and I can do cargo run.

135
00:09:31,506 --> 00:09:33,607
The code is basically what we saw on the last slide,

136
00:09:33,667 --> 00:09:34,347
except with some...

137
00:09:35,694 --> 00:09:38,636
additional handling for command line arguments and things like that.

138
00:09:39,516 --> 00:09:43,839
So I run it with cargo, it downloads if it needs to, compiles all the dependencies,

139
00:09:44,579 --> 00:09:49,703
and I see the output here. So this is very straightforward. It's very simple to add

140
00:09:49,723 --> 00:09:53,966
dependencies. Some people might argue too simple. I'm not one of those people. I think it's a very

141
00:09:54,566 --> 00:09:56,267
great aspect of using Rust.

142
00:09:59,369 --> 00:10:02,431
But this isn't really all either. There's still more.

143
00:10:04,436 --> 00:10:06,977
With Rust, you get static compile time validation

144
00:10:07,537 --> 00:10:08,778
of common memory problems.

145
00:10:08,878 --> 00:10:11,799
Common memory problems might be things like use after free,

146
00:10:12,519 --> 00:10:15,240
use after move, if you've ever run into that in C++,

147
00:10:16,140 --> 00:10:16,841
double free.

148
00:10:17,421 --> 00:10:21,703
These things are not really possible in Rust by default

149
00:10:21,763 --> 00:10:24,103
because the compiler won't validate them.

150
00:10:25,484 --> 00:10:27,605
And how this works is extremely interesting.

151
00:10:27,985 --> 00:10:29,786
I'm not going to go into this talk

152
00:10:29,846 --> 00:10:32,807
because there's other things I want to get to

153
00:10:33,067 --> 00:10:33,627
and because.

154
00:10:34,503 --> 00:10:40,006
every other presentation on Rust starts out with this. So you can trust me for now,

155
00:10:40,126 --> 00:10:43,728
this is static and it's compile-time validated. But that's not all either.

156
00:10:45,789 --> 00:10:49,671
We also have static compile-time validation of multi-threading problems, specifically

157
00:10:50,292 --> 00:10:55,114
what they call data races, which is mutation of data from multiple threads at the same time.

158
00:10:56,422 --> 00:11:04,287
And this is very interesting because Rust is the only language I know of that's considered maybe a common language that does this.

159
00:11:04,307 --> 00:11:06,308
It's going to be a real time saver.

160
00:11:06,928 --> 00:11:10,570
So if you're not convinced, let's look at an example.

161
00:11:12,091 --> 00:11:13,551
This is Treyarch's image packer.

162
00:11:13,651 --> 00:11:17,133
This is churning through all our images and mastering them for disk.

163
00:11:18,234 --> 00:11:20,255
It was rewritten in Rust and deployed in 2018.

164
00:11:20,415 --> 00:11:24,177
That was two games ago, if you're keeping track.

165
00:11:25,485 --> 00:11:29,506
It's a heavily multi-threaded tool because it's churning through a lot of data. It needs to do it as fast as possible.

166
00:11:30,166 --> 00:11:32,326
And it's been an active development throughout its lifetime.

167
00:11:33,106 --> 00:11:35,627
Especially this last title that we shipped.

168
00:11:36,447 --> 00:11:39,388
There were some several major developments on this tool.

169
00:11:40,628 --> 00:11:44,689
And throughout all this for three years the number of crash bugs that we've encountered, two.

170
00:11:45,349 --> 00:11:47,089
And I put this in quotes

171
00:11:47,829 --> 00:11:51,870
because one of these was more of like an unhandled exception type of thing, an unexpected stop.

172
00:11:51,890 --> 00:11:53,450
It wasn't really a crash.

173
00:11:54,680 --> 00:11:57,142
the other crash was interfacing with a C library.

174
00:11:58,182 --> 00:12:00,323
So imagine for the rest of the career,

175
00:12:00,363 --> 00:12:02,164
if you had to deal with on average,

176
00:12:02,304 --> 00:12:03,545
less than one crash a year,

177
00:12:03,745 --> 00:12:04,965
I think we'd all be pretty happy.

178
00:12:07,346 --> 00:12:08,787
So this is the full sales pitch.

179
00:12:09,367 --> 00:12:10,728
All these things work together

180
00:12:10,788 --> 00:12:12,209
to make a pretty compelling package.

181
00:12:14,190 --> 00:12:16,351
And I hope that you agree on that.

182
00:12:16,831 --> 00:12:20,793
Now I'm going to go through kind of lighting quick

183
00:12:23,100 --> 00:12:27,243
a number of areas that I think Rust really provides value to us as game programmers

184
00:12:28,363 --> 00:12:33,407
and as tools programmers. And these areas have certainly been helpful to me in the tools

185
00:12:33,427 --> 00:12:38,150
that I've written with Rust. So I hope you find something interesting here because we're going

186
00:12:38,170 --> 00:12:44,434
to go through it lightning quick. Air handling in Rust. There's two methods of air handling.

187
00:12:45,055 --> 00:12:45,775
One is a result.

188
00:12:46,628 --> 00:12:51,130
which is basically anything that can fail will return a result.

189
00:12:51,991 --> 00:12:54,212
And it's encoded into the signature of the function.

190
00:12:55,732 --> 00:12:59,734
It encodes exactly what errors can be returned, which is really interesting

191
00:12:59,754 --> 00:13:04,117
if you're coming from Python or C++ where you really don't necessarily have

192
00:13:04,177 --> 00:13:06,758
any idea what's going to throw an exception.

193
00:13:08,835 --> 00:13:11,316
So this holds the success or failure state of an operation,

194
00:13:11,536 --> 00:13:15,597
and we can use it to either handle failure or pass failure

195
00:13:15,777 --> 00:13:19,298
on to eventually report it to the end user.

196
00:13:19,698 --> 00:13:21,898
A panic is more like an instant program failure

197
00:13:22,699 --> 00:13:23,939
for an unrecoverable error.

198
00:13:24,079 --> 00:13:27,920
One example is if you access outside of an array bounds,

199
00:13:28,620 --> 00:13:30,640
this will instantly kill the program,

200
00:13:30,700 --> 00:13:32,361
and this is part of Rust security focus.

201
00:13:33,439 --> 00:13:40,524
What they don't want is that to trigger some sort of remote code execution buffer overflow state.

202
00:13:40,685 --> 00:13:44,988
So they just exit the program. These are things that you want to avoid in your coding.

203
00:13:45,028 --> 00:13:50,172
You want to write panic safe code, basically, in the best case.

204
00:13:50,732 --> 00:13:52,534
The results you want to pass on and handle.

205
00:13:53,794 --> 00:13:55,796
One way to do this is to use the question mark operator.

206
00:13:55,836 --> 00:13:58,798
We saw this a little bit earlier if you were paying attention.

207
00:14:00,099 --> 00:14:03,081
What this does is it passes a failed result up the call stack.

208
00:14:04,317 --> 00:14:06,758
And if the result doesn't fail, it

209
00:14:06,778 --> 00:14:09,920
will just return the successful value to whatever

210
00:14:09,940 --> 00:14:10,841
you're assigning it to.

211
00:14:11,521 --> 00:14:14,622
So in this example, if the read fails for any reason,

212
00:14:14,642 --> 00:14:15,963
it will pass it up to call stack,

213
00:14:16,724 --> 00:14:18,725
which means that the calling function also needs to return

214
00:14:18,745 --> 00:14:19,925
a result all the way up to main.

215
00:14:20,525 --> 00:14:23,747
And if you get all the way up to main, it will exit the program

216
00:14:23,907 --> 00:14:27,389
and print a useful message to the user about what happened.

217
00:14:28,550 --> 00:14:32,011
But the message isn't too useful, as we talked about with both Python and Rust.

218
00:14:32,831 --> 00:14:36,872
These are just kind of short messages that don't really help the user all the time.

219
00:14:37,892 --> 00:14:43,133
But we can use this idio-how crate to add context to errors, and I really enjoy this crate.

220
00:14:43,153 --> 00:14:48,875
Let's see an example. This is the error message you would get if you were just

221
00:14:49,195 --> 00:14:51,796
just doing the question mark operator like normal.

222
00:14:51,956 --> 00:14:54,896
And it's a good error message, but it doesn't really tell you enough.

223
00:14:55,884 --> 00:14:58,205
Whereas if you add some context to what's going on,

224
00:14:58,625 --> 00:15:01,406
you can basically say what you were doing when this error

225
00:15:01,446 --> 00:15:01,846
occurred.

226
00:15:02,426 --> 00:15:06,268
And that produces a much better error message.

227
00:15:06,328 --> 00:15:08,508
And maybe the user has a chance of figuring out

228
00:15:08,548 --> 00:15:09,769
what's going on at this point.

229
00:15:11,209 --> 00:15:12,390
So I really like this.

230
00:15:12,490 --> 00:15:16,031
It's very easy to cover all the error paths in your program.

231
00:15:16,331 --> 00:15:18,331
And to add context doesn't take that much time.

232
00:15:18,371 --> 00:15:21,092
So I feel like this is really valuable.

233
00:15:21,112 --> 00:15:21,172
And.

234
00:15:22,890 --> 00:15:25,991
gives you a really sense of peace that you've covered all the paths.

235
00:15:28,132 --> 00:15:32,053
Next, to give it a look briefly at multithreading, there's this crate called rayon

236
00:15:33,433 --> 00:15:36,494
that is really amazing. It makes multithreading very quick and easy.

237
00:15:37,515 --> 00:15:42,536
This example here is using kind of an iterative style that's kind of popular in Rust,

238
00:15:43,416 --> 00:15:47,978
where we're iterating over a list of file names. We're passing each file name to a function called

239
00:15:47,998 --> 00:15:48,598
hash file.

240
00:15:49,627 --> 00:15:53,929
which is then returning the hash presumably and then we're collecting that into another container.

241
00:15:54,849 --> 00:15:58,951
So this is a very popular way of programming in Rust's more functional style.

242
00:16:00,052 --> 00:16:03,794
And if you've programmed in this way to multi-thread this, the only thing that you have

243
00:16:03,814 --> 00:16:10,637
to do using the rayon create is change this iter to pair iter. And now each hash file call will get

244
00:16:10,697 --> 00:16:17,740
farmed out to a thread pool and the results will be collected into a new container. So ostensibly

245
00:16:17,780 --> 00:16:18,781
this will be much faster.

246
00:16:22,136 --> 00:16:24,197
I mentioned that there's static multi-threading guarantees.

247
00:16:24,237 --> 00:16:27,600
I just want to demonstrate this really quick with a simple example.

248
00:16:27,921 --> 00:16:30,723
In here, I've added a mutable reference to

249
00:16:30,743 --> 00:16:33,586
the counter that I pass into every hash file function.

250
00:16:34,787 --> 00:16:37,309
Ostensibly, I would increment this counter

251
00:16:37,409 --> 00:16:39,591
to maybe check how many files I've hashed.

252
00:16:40,600 --> 00:16:47,103
But Rust won't let me compile this because it knows that this is going to result in a mutation

253
00:16:47,143 --> 00:16:54,126
that's not safe under across multiple threads. If I change this back to an iter, Rust will

254
00:16:54,526 --> 00:17:00,408
accept this code. So already it's preventing us from from causing some serious mistakes.

255
00:17:03,786 --> 00:17:07,109
Parsing text, I think, is a pretty common use case,

256
00:17:07,369 --> 00:17:09,651
especially for like config files and things like that.

257
00:17:09,671 --> 00:17:11,472
I use the Serde crate.

258
00:17:11,572 --> 00:17:13,694
I'm not sure I pronounced it correctly, but I say Serde.

259
00:17:14,295 --> 00:17:16,096
It stands for serialized deserializer.

260
00:17:18,118 --> 00:17:21,080
And this crate is really great for generic serialization,

261
00:17:21,160 --> 00:17:21,861
just serialization.

262
00:17:21,881 --> 00:17:23,742
I'm only going to demonstrate deserialization here.

263
00:17:24,963 --> 00:17:26,705
Here, I have a configuration struct,

264
00:17:26,745 --> 00:17:27,786
and I have this little odd.

265
00:17:28,578 --> 00:17:34,660
syntax up here, derive deserialize. And what this does is it tells the library to take my structure

266
00:17:34,680 --> 00:17:38,822
and generate code behind the scenes to deserialize my structure.

267
00:17:40,882 --> 00:17:45,724
And then if I need to actually do the deserialization, I have to pull in a specific

268
00:17:45,844 --> 00:17:48,685
formatting deserializer. So in this case, JSON.

269
00:17:49,487 --> 00:17:51,647
I take a text string, I pass it through this,

270
00:17:51,827 --> 00:17:56,148
and I get a filled configuration structure out of it.

271
00:17:57,248 --> 00:17:58,929
If there's an error in the configuration,

272
00:17:58,949 --> 00:18:01,809
I'm missing a field or a bad type or anything like that,

273
00:18:01,889 --> 00:18:03,750
I'll get a decent error.

274
00:18:05,450 --> 00:18:08,231
And if I lose a bet and I have to change my configuration

275
00:18:08,291 --> 00:18:10,892
to YAML, that's a pretty simple change.

276
00:18:10,932 --> 00:18:14,252
I just switch out the deserializer.

277
00:18:15,012 --> 00:18:17,153
So this is a really big time saver.

278
00:18:17,173 --> 00:18:19,213
If you're keeping track, I think it's two lines of code.

279
00:18:20,564 --> 00:18:22,746
to deserialize from a config file.

280
00:18:23,026 --> 00:18:24,427
You can also serialize as well.

281
00:18:24,607 --> 00:18:26,648
You're just changing it to toString instead of fromString.

282
00:18:28,169 --> 00:18:29,270
Very, very nice.

283
00:18:29,710 --> 00:18:31,211
Very cool, I think.

284
00:18:33,212 --> 00:18:34,213
Command line interfaces.

285
00:18:34,233 --> 00:18:36,074
This is pretty similar to the last example.

286
00:18:38,555 --> 00:18:40,257
Here I have another derive.

287
00:18:40,297 --> 00:18:41,497
I'm deriving struct opt.

288
00:18:42,018 --> 00:18:45,260
But in this case, I also have some interesting little

289
00:18:45,300 --> 00:18:48,782
directives that tell me, or that tell the library how to.

290
00:18:49,662 --> 00:18:52,684
how to treat these arguments when it's generating the command line interface.

291
00:18:54,225 --> 00:18:59,850
And then when I want to get my options, I just call this fromRx function at this top of my program

292
00:19:00,851 --> 00:19:05,274
and it will fill out this option structure with whatever people passed in from the command line

293
00:19:05,294 --> 00:19:12,280
interface. And if there's an error, it will just print this help message. I can also get help

294
00:19:12,340 --> 00:19:13,141
and version for free.

295
00:19:14,545 --> 00:19:15,806
One thing that I'd like to point out,

296
00:19:15,846 --> 00:19:18,726
just because it's awesome, is that also my code comments got

297
00:19:18,786 --> 00:19:24,128
translated into help text in the dash dash help.

298
00:19:24,688 --> 00:19:26,048
So that is pretty cool.

299
00:19:28,669 --> 00:19:30,649
Parsing debug info, this one is a little bit,

300
00:19:31,269 --> 00:19:33,210
maybe something you don't do every day.

301
00:19:33,230 --> 00:19:36,010
I know I don't do it every day,

302
00:19:36,070 --> 00:19:37,651
but ever since I discovered these crates,

303
00:19:38,769 --> 00:19:42,431
seems like every few days we come up with a good usage for them.

304
00:19:42,911 --> 00:19:45,532
One of them is this example on the side,

305
00:19:46,173 --> 00:19:47,673
where I wrote a program that I've been

306
00:19:47,693 --> 00:19:49,154
wanting to write for a very long time,

307
00:19:49,274 --> 00:19:51,075
which examines an L file,

308
00:19:51,155 --> 00:19:52,656
pulls out all the debug information,

309
00:19:53,616 --> 00:19:55,777
and gives me a list of all the structures that could be

310
00:19:55,837 --> 00:19:59,099
padded more optimally to make them smaller.

311
00:19:59,179 --> 00:20:01,200
You can see that there's this padding here,

312
00:20:01,640 --> 00:20:03,601
which if the structure was rearranged would be

313
00:20:04,641 --> 00:20:06,662
removed and we can save eight bytes.

314
00:20:07,762 --> 00:20:12,486
8 bytes might not sound like much, but if you have 70,000 of these things, it can be pretty effective.

315
00:20:13,487 --> 00:20:20,373
And along with this talk, I'd just like to make a note that Activision has allowed us to open source this tool.

316
00:20:21,474 --> 00:20:23,135
So if you happen to ship on a

317
00:20:24,236 --> 00:20:27,859
platform that uses ELF files, you can go try this out on your own.

318
00:20:29,300 --> 00:20:30,741
I think it's a very useful program.

319
00:20:32,765 --> 00:20:37,666
And I want to note that I said I've been wanting to write this program for a long time.

320
00:20:37,706 --> 00:20:44,908
I've tried in various languages and I think that Python and C++, the ecosystem is actually a little

321
00:20:44,928 --> 00:20:51,970
bit behind in the parsing debug info, whereas Rust has some pretty useful crates in that area.

322
00:20:54,507 --> 00:21:00,793
C-ABI compatibility just quickly. You can bind Rust code to other languages through C-ABI.

323
00:21:01,613 --> 00:21:06,478
Python is the biggest one, and here's an example here of the py03 crate,

324
00:21:07,899 --> 00:21:14,585
making a Python module that does something silly. But we use this to bind our Rust code to Python,

325
00:21:15,005 --> 00:21:19,389
which has replaced a couple parallel implementations we had before.

326
00:21:20,249 --> 00:21:23,292
You can also bind to Node.js, you can bind to C and C++.

327
00:21:23,392 --> 00:21:25,234
Obviously, you can also bind to WebAssembly.

328
00:21:25,274 --> 00:21:29,718
So this is really helpful if you're doing something like replacing

329
00:21:29,818 --> 00:21:34,483
Python modules with faster C or Rust modules.

330
00:21:34,703 --> 00:21:35,724
I guess Rust in this case.

331
00:21:38,006 --> 00:21:42,350
And that's a big use case that a lot of people are doing outside in the wider tech world.

332
00:21:45,150 --> 00:21:55,473
Web applications, I know every once in a while I have to create quick and dirty web apps, usually using cherry pie or flask, but there's a lot of work to make this work for Rust.

333
00:21:55,773 --> 00:22:00,674
And so there's a couple of crates that are useful for this.

334
00:22:00,754 --> 00:22:02,655
I like this one. I'm not sure how to pronounce it.

335
00:22:02,675 --> 00:22:05,636
I think it's Rue. It's French for Rust.

336
00:22:07,316 --> 00:22:13,038
But you can create really quick and dirty servers using this if you're going to do something a little bit more substantial.

337
00:22:14,401 --> 00:22:20,326
you might want to use Tide or Actix Web. These are a little bit more mature, a little bit more full-featured.

338
00:22:21,768 --> 00:22:26,372
And I think that Tide is my favorite one I've seen, but I haven't really.

339
00:22:27,988 --> 00:22:29,709
done much practical work in this area.

340
00:22:30,069 --> 00:22:32,590
So, but I do want to caution as always,

341
00:22:32,630 --> 00:22:34,671
if you're going to make anything externally facing,

342
00:22:35,611 --> 00:22:37,192
please, please vet your dependencies.

343
00:22:38,272 --> 00:22:41,273
Rust safety guarantees are really strong,

344
00:22:41,834 --> 00:22:44,435
but at the same time, you need to take a look

345
00:22:44,475 --> 00:22:46,335
at what you're putting out there in the wild.

346
00:22:46,355 --> 00:22:49,736
And lastly, I want to look at GUIs.

347
00:22:50,337 --> 00:22:53,338
GUI programming was behind in Rust for a long time.

348
00:22:53,938 --> 00:22:54,958
People were having a hard time.

349
00:22:55,636 --> 00:22:59,919
wrapping their heads around how to mix and match Rust semantics and GUI needs.

350
00:23:00,900 --> 00:23:06,184
But a lot of useful libraries have started to emerge. Iced is one of them, Druid, eGUI.

351
00:23:06,204 --> 00:23:14,331
This is just a quick example of eGUI. eGUI is a immediate mode GUI. Iced is

352
00:23:15,352 --> 00:23:20,516
using the Elm architecture, which is pretty popular in functional languages. Druid is more

353
00:23:20,676 --> 00:23:21,576
influenced by Flutter.

354
00:23:23,159 --> 00:23:25,821
I don't actually recommend the C++ bindings,

355
00:23:25,841 --> 00:23:28,402
but I want to list them here in case you're

356
00:23:28,442 --> 00:23:32,084
tied to a specific UI toolkit and you want to use that.

357
00:23:32,585 --> 00:23:34,306
I think that there's a lot less friction

358
00:23:35,967 --> 00:23:37,107
using the Rust native ones.

359
00:23:37,147 --> 00:23:39,228
Specifically, EGUI is what I would probably

360
00:23:39,349 --> 00:23:40,109
use for new stuff.

361
00:23:40,389 --> 00:23:42,811
I've had the most success with it in my tinkering.

362
00:23:43,471 --> 00:23:48,274
But I've also seen a really nice application in Rust

363
00:23:48,414 --> 00:23:51,996
called Adure, which is a World of Warcraft add-on manager.

364
00:23:52,367 --> 00:23:59,152
and it uses ICE and it's one of the slickest apps I've ever used. So Rust is starting to get

365
00:24:00,574 --> 00:24:07,159
pretty powerful in the GUI space. I want to talk now about integrating Rust at Treyarch

366
00:24:08,821 --> 00:24:13,885
and our little journey, our Rust journey. We started working late 2017. I did some

367
00:24:13,925 --> 00:24:16,928
feasibility studies on a number of different languages because I was interested in.

368
00:24:18,081 --> 00:24:23,024
what was out there and if it was better. Rust kind of bubbled to the top as something that was worth looking into more.

369
00:24:23,965 --> 00:24:29,248
And fast forward to today, we have three major tools written in Rust and several

370
00:24:29,709 --> 00:24:33,291
smaller one-off tools as well, kind of like the struct pack that I shared earlier.

371
00:24:36,071 --> 00:24:38,953
around 120k lines of code, all told,

372
00:24:40,574 --> 00:24:41,635
27 individual contributors.

373
00:24:41,795 --> 00:24:44,657
I want to make a note that just because someone

374
00:24:44,677 --> 00:24:46,118
has contributed to Rust doesn't mean

375
00:24:46,158 --> 00:24:48,660
that they would consider themselves a Rust expert

376
00:24:48,720 --> 00:24:51,181
or even know Rust, but what you find is that

377
00:24:51,982 --> 00:24:53,703
when people are in a code base,

378
00:24:54,544 --> 00:24:57,466
they have examples of what to do around them.

379
00:24:57,526 --> 00:24:58,707
And if what they need to do is,

380
00:25:00,394 --> 00:25:07,078
you know, write some conditional statements and print a line of code, like they can do that, or print a string.

381
00:25:07,819 --> 00:25:11,621
They can usually do that without much trouble. And that's the type of contributions that people

382
00:25:11,661 --> 00:25:15,083
have made. I don't want to minimize those contributions because they're all important.

383
00:25:16,063 --> 00:25:20,045
But what I'm trying to get at is that just because something is in Rust, and Rust is an unfamiliar

384
00:25:20,065 --> 00:25:25,528
language, doesn't mean that people can't contribute. We've also had extremely high

385
00:25:25,588 --> 00:25:27,590
stability as we saw with the previous example.

386
00:25:29,587 --> 00:25:35,433
downsides. Rust has a very steep learning curve. I don't want to sugarcoat it. It can be pretty

387
00:25:35,533 --> 00:25:42,722
awful. It puts a lot of people off. This is a very different language from C++. And if you go and you

388
00:25:42,782 --> 00:25:48,548
actually read about how these static guarantees work, you'll find very quickly that that's true.

389
00:25:50,181 --> 00:25:54,504
It's a complicated language, there's a lot of corners, but I think this is kind of mitigated by

390
00:25:54,524 --> 00:26:00,368
the fact that we already often, most of us use a complicated language in C++ and I don't think

391
00:26:00,408 --> 00:26:07,192
any of us know the whole thing. So it's okay that it's complicated from my perspective, but it does

392
00:26:07,212 --> 00:26:08,073
put a lot of people off.

393
00:26:09,372 --> 00:26:11,213
It's heavily reliant on the ecosystem.

394
00:26:11,233 --> 00:26:13,095
This is really true of every language as well,

395
00:26:13,195 --> 00:26:16,117
but it is mostly about how mature is your ecosystem.

396
00:26:16,217 --> 00:26:19,980
And I think that Rust is in several areas mature enough

397
00:26:20,621 --> 00:26:22,762
and in a few areas still working on it.

398
00:26:24,404 --> 00:26:28,007
Compile times, I don't really run up against this much

399
00:26:28,107 --> 00:26:29,108
with the stuff I work on.

400
00:26:29,148 --> 00:26:29,868
I think it's fine,

401
00:26:29,948 --> 00:26:33,491
but this is a very common complaint about Rust.

402
00:26:34,892 --> 00:26:36,834
So how we approach these downsides

403
00:26:37,114 --> 00:26:38,595
is gonna be key to our integration.

404
00:26:40,349 --> 00:26:43,830
some tips from our own experience, communicate about what you're doing.

405
00:26:44,010 --> 00:26:45,210
This is a big mistake I made.

406
00:26:45,230 --> 00:26:47,551
I didn't communicate enough when I integrated Rust,

407
00:26:48,292 --> 00:26:49,492
and it caused a lot of strife.

408
00:26:51,753 --> 00:26:53,854
You want to keep Rust kind of siloed off

409
00:26:53,914 --> 00:26:56,235
until you get more experience in your company.

410
00:26:56,835 --> 00:27:00,577
What I did is I found an unmaintained tool that was actually poorly written.

411
00:27:01,777 --> 00:27:03,077
And I made it better.

412
00:27:03,438 --> 00:27:06,679
And through that process, it's been really interesting because.

413
00:27:08,040 --> 00:27:09,821
People started to see the potential in the tool,

414
00:27:09,861 --> 00:27:11,443
and it gained many more contributions

415
00:27:11,483 --> 00:27:13,485
than it had before it was written in Rust.

416
00:27:16,828 --> 00:27:17,969
Start with the best workflow.

417
00:27:18,049 --> 00:27:20,491
I think this is Visual Studio Code and Rust Analyzer

418
00:27:20,591 --> 00:27:21,692
plugin at this point.

419
00:27:23,234 --> 00:27:24,975
These are also other ones are also

420
00:27:25,035 --> 00:27:26,937
tools I recommend to install.

421
00:27:27,017 --> 00:27:28,459
Clippy especially is a linter.

422
00:27:29,420 --> 00:27:32,342
And this is extremely important to run as you're learning Rust

423
00:27:32,402 --> 00:27:33,443
because it will tell you.

424
00:27:34,644 --> 00:27:37,907
when you're doing things not enigmatically or unexpectedly,

425
00:27:38,767 --> 00:27:39,688
wasting performance.

426
00:27:40,729 --> 00:27:42,711
And it catches a lot of things

427
00:27:42,751 --> 00:27:43,972
and it will teach you a lot about Rust.

428
00:27:44,032 --> 00:27:46,854
So I recommend running Clippy on everything that you write,

429
00:27:46,934 --> 00:27:47,955
especially when you're starting out.

430
00:27:49,897 --> 00:27:51,618
Bad Rust code is really interesting

431
00:27:51,638 --> 00:27:53,280
because it has the same safety guarantees.

432
00:27:54,161 --> 00:27:59,005
So it's probably, you know, you want to avoid bad code,

433
00:27:59,045 --> 00:28:00,906
but what I'm saying is that while you're learning,

434
00:28:01,657 --> 00:28:07,359
it's not the end of the world if your code isn't perfect. Whereas in C++, if your code isn't

435
00:28:07,399 --> 00:28:14,382
perfect, it can melt down a nuclear reactor or something along those lines. It's very dangerous

436
00:28:14,402 --> 00:28:18,944
to have imperfect code in C++, but it's not as dangerous in Rust because of all the safety

437
00:28:18,964 --> 00:28:23,926
guarantees. The initial hurdles are high, like I said, but

438
00:28:24,941 --> 00:28:29,565
I noticed that there are large productivity gains after you get over those hurdles. I find that I'm

439
00:28:29,585 --> 00:28:33,769
more productive in Rust than in any other language and I just enjoy programming it more these days.

440
00:28:33,929 --> 00:28:37,352
I think that's a pretty common sentiment around people who have pushed through the hurdles.

441
00:28:39,454 --> 00:28:42,636
But you want to provide time and space to learn and teach the language.

442
00:28:43,717 --> 00:28:48,481
This means making presentations, doing courses, giving people examples, being

443
00:28:49,122 --> 00:28:52,385
available to answer questions, doing code reviews.

444
00:28:53,231 --> 00:28:57,152
all this stuff. This is kind of like the burden you have of pushing forward on this,

445
00:28:58,113 --> 00:29:02,254
is that you have to be available and you have to make it as easy on other people as possible.

446
00:29:04,535 --> 00:29:09,997
These are some learning resources. If you like to, or if you're anything like me, you want to

447
00:29:10,017 --> 00:29:16,019
just get right in and code. I recommend, you know, go on Elite Code. They have Rust built in. You can

448
00:29:16,099 --> 00:29:20,141
run some programs. Advent of Code is fun to work through in any language.

449
00:29:20,941 --> 00:29:24,102
These are just ways to invent problems to solve for yourself.

450
00:29:24,802 --> 00:29:27,302
And you can get quite a ways with those.

451
00:29:29,463 --> 00:29:33,524
If you like book learning, these are two of the more popular Rust books.

452
00:29:34,144 --> 00:29:37,885
And I haven't read either of these, but I've heard very good things about both of them.

453
00:29:39,005 --> 00:29:42,786
If you just want to stay online, the Rust Language site has a good learning section.

454
00:29:43,306 --> 00:29:44,667
There's a playground as well.

455
00:29:45,551 --> 00:29:50,855
where you can try Rust out in your browser and see if it compiles and what's generated and things

456
00:29:50,895 --> 00:29:58,141
like that. So that's it for me. Thank you for listening to my talk. I hope that you've learned

457
00:29:58,181 --> 00:30:02,925
something. I hope that you're interested in Rust. I hope that I've made a compelling argument for

458
00:30:02,945 --> 00:30:10,711
why Rust is good in game tools. And I'm happy to have your feedback as well. And as always,

459
00:30:11,151 --> 00:30:15,074
if you're interested in Treyarch, we're always hiring. So thank you for paying attention.

460
00:30:18,690 --> 00:30:19,172
You

